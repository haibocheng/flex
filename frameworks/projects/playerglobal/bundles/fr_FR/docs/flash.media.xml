<?xml version="1.0"?>
<apiPackage id="flash.media"><apiName>flash.media</apiName><apiDetail/><apiClassifier id="flash.media:SoundCodec"><apiName>SoundCodec</apiName><shortdesc>
La classe SoundCodec énumère les valeurs constantes utilisées lors de la définition de la propriété codec de la classe Microphone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe SoundCodec énumère les valeurs constantes utilisées lors de la définition de la propriété <codeph>codec</codeph> de la classe <codeph>Microphone</codeph>.

</apiDesc></apiClassifierDetail><apiValue id="flash.media:SoundCodec:NELLYMOSER"><apiName>NELLYMOSER</apiName><shortdesc> 
	Spécifie que le codec Nellymoser doit être utilisé pour la compression audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>NellyMoser</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Spécifie que le codec Nellymoser doit être utilisé pour la compression audio. Cette constante est la valeur par défaut de la propriété <codeph>Microphone.codec</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundCodec:SPEEX"><apiName>SPEEX</apiName><shortdesc> 
	Spécifie que le codec Speex doit être utilisé pour la compression audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>Speex</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Spécifie que le codec Speex doit être utilisé pour la compression audio.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:ID3Info"><apiName>ID3Info</apiName><shortdesc>
	 La classe ID3Info contient des propriétés qui reflètent les métadonnées ID3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe ID3Info contient des propriétés qui reflètent les métadonnées ID3. Vous pouvez obtenir des métadonnées supplémentaires pour les fichiers MP3 en accédant à la propriété <codeph>id3</codeph> de la classe Sound, par exemple <codeph>mySound.id3.TIME</codeph>. Pour plus d’informations, voir l’entrée <codeph>Sound.id3</codeph> et les définitions des balises ID3 à l’adresse <xref href="http://www.id3.org">http://www.id3.org</xref>.
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links><apiValue id="flash.media:ID3Info:album"><apiName>album</apiName><shortdesc>
		 Titre de l’album qui correspond à la balise ID3 2.0 TALB.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Titre de l’album qui correspond à la balise ID3 2.0 TALB.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:artist"><apiName>artist</apiName><shortdesc>
		 Nom de l’interprète qui correspond à la balise ID3 2.0 TPE1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Nom de l’interprète qui correspond à la balise ID3 2.0 TPE1.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:comment"><apiName>comment</apiName><shortdesc>
		 Commentaire sur l’enregistrement qui correspond à la balise ID3 2.0 COMM.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Commentaire sur l’enregistrement qui correspond à la balise ID3 2.0 COMM.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:genre"><apiName>genre</apiName><shortdesc>
		 Genre du morceau qui correspond à la balise ID3 2.0 TCON.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Genre du morceau qui correspond à la balise ID3 2.0 TCON.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:songName"><apiName>songName</apiName><shortdesc>
		 Titre du morceau qui correspond à la balise ID3 2.0 TIT2.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Titre du morceau qui correspond à la balise ID3 2.0 TIT2.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:track"><apiName>track</apiName><shortdesc>
		 Numéro de la piste qui correspond à la balise ID3 2.0 TRCK.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Numéro de la piste qui correspond à la balise ID3 2.0 TRCK.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:year"><apiName>year</apiName><shortdesc>
		 Année d’enregistrement qui correspond à la balise ID3 2.0 TYER.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Année d’enregistrement qui correspond à la balise ID3 2.0 TYER.
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Microphone"><apiName>Microphone</apiName><shortdesc>
 Servez-vous de la classe Microphone pour capturer un son depuis un microphone relié à un ordinateur exécutant Flash Player ou Adobe AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Servez-vous de la classe Microphone pour capturer un son depuis un microphone relié à un ordinateur exécutant <ph platform="actionScript">Flash Player ou </ph>Adobe AIR. Servez-vous de la classe Microphone pour contrôler l’audio localement. Utilisez les classes NetConnection et NetStream pour transmettre l’audio au Flash Media Server. Flash Media Server peut envoyer le flux audio à d’autres serveurs et le diffuser à d’autres clients exécutant <ph platform="actionScript">Flash Player ou </ph>Adobe AIR.
 
 <p>
 Pour plus d’informations sur la capture vidéo, voir la classe Camera.
 </p>
 
 <p>
 <b>Important : </b> Flash Player affiche une boîte de dialogue Confidentialité qui permet à l’utilisateur d’autoriser ou de refuser l’accès au microphone. Vérifiez la taille de la fenêtre de votre application qui doit être au moins de 215x138 pixels, taille minimale requise pour que Flash puisse afficher la boîte de dialogue.
 </p>
 
 <p>
 Pour créer ou référencer un objet Microphone, utilisez la méthode <codeph>Microphone.getMicrophone()</codeph>.
 </p>
 
 <p platform="actionscript"><b>Attention : </b>Pour le contenu situé en dehors du sandbox de l’application, une boîte de dialogue Confidentialité s’affiche pour permettre à l’utilisateur d’indiquer s’il autorise ou refuse l’accès au microphone. Cette boîte de dialogue requiert une taille de fenêtre d’application de 215 x 138 pixels au minimum. Pour le contenu Adobe AIR situé dans le sandbox de l’application, l’accès est autorisé et la boîte de dialogue ne s’affiche pas.</p>
 
 </apiDesc><example conref="examples\MicrophoneExample.as"> L’exemple suivant capture le son en utilisant la suppression de l’écho à partir du microphone une fois l’autorisation d’accès à l’ordinateur accordée par l’utilisateur. La méthode <codeph>Security.showSettings()</codeph> affiche la boîte de dialogue Flash Player qui demande l’autorisation d’accéder au microphone de l’utilisateur. L’appel à <codeph>setLoopBack(true)</codeph> réachemine l’entrée sur le haut-parleur local de sorte que vous pouvez entendre le son tandis que vous exécutez l’exemple.
 
 <p>Deux écouteurs surveillent les événements <codeph>activity</codeph> et <codeph>status</codeph>. L’événement <codeph>activity</codeph> est distribué au début et à la fin (si elle existe) de la session, et il est capturé par la méthode <codeph>activityHandler()</codeph> qui assure le suivi des informations sur l’événement. L’événement <codeph>status</codeph> est distribué si l’objet microphone joint signale des informations d’état ; sa capture et son suivi sont assurés par le biais de la méthode <codeph>statusHandler()</codeph>.</p>
 
 <p><b>Remarque :</b> un microphone doit être branché sur votre ordinateur pour le bon déroulement de cet exemple.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Microphone;
    import flash.system.Security;

    public class MicrophoneExample extends Sprite {
        public function MicrophoneExample() {
            var mic:Microphone = Microphone.getMicrophone();
            Security.showSettings("2");
            mic.setLoopBack(true);
                    
            if (mic != null) {
                mic.setUseEchoSuppression(true);
                mic.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                mic.addEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }

        private function statusHandler(event:StatusEvent):void {
            trace("statusHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Distribué lorsqu’un microphone publie son état.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un microphone publie son état. Si la valeur de la propriété <codeph>code</codeph> est réglée sur <codeph>"Microphone.Muted"</codeph>, l’utilisateur a interdit au fichier SWF d’accéder au microphone. Si la valeur de la propriété <codeph>code</codeph> est réglée sur <codeph>"Microphone.Unmuted"</codeph>, l’utilisateur a autorisé le fichier SWF à accéder au microphone. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>Microphone.getMicrophone()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Microphone_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Distribué lorsqu’un microphone commence ou termine une session.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un microphone commence ou termine une session. 
 
 <p>
 Pour spécifier la quantité de son requise pour déclencher cet événement avec une propriété <codeph>activating</codeph> <codeph>true</codeph> ou le délai devant s’écouler sans son pour déclencher cet événement avec une propriété <codeph>activating</codeph> <codeph>false</codeph>, utilisez <codeph>Microphone.setSilenceLevel()</codeph>.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>setSilenceLevel()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.media:Microphone:getMicrophone"><apiName>getMicrophone</apiName><shortdesc>
	 
	 Renvoie une référence à un objet Microphone pour capturer des données audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, Microphone.getMicropone, getMicrophone
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Une référence à un objet Microphone pour capturer des données audio.
	 
 	 </apiDesc><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Index du microphone.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Renvoie une référence à un objet Microphone pour capturer des données audio. Pour commencer la capture du flux audio, vous devez relier l’objet Microphone à un objet NetStream (voir <codeph>NetStream.attachAudio()</codeph>).
	 
	 <p>
	 Plusieurs appels à <codeph>Microphone.get()</codeph> font référence au même microphone. Ainsi, si votre code contient les lignes <codeph>mic1 = Microphone.get()</codeph> et <codeph>mic2 = Microphone.get()</codeph>, les lignes <codeph>mic1</codeph> et <codeph>mic2</codeph> font référence au même microphone (par défaut).</p>
	 <p>
	 Si vous souhaitez utiliser le microphone par défaut, vous devez appeler <codeph>getMicrophone()</codeph> avec -1. Si vous l’appelez sans paramètres, il renvoie le premier microphone dans la liste.
	 </p>
	 
	 <p>
	 Utilisez la propriété <codeph>index</codeph> pour obtenir la valeur d’index de l’objet Microphone actif. Vous pouvez ensuite transmettre cette valeur aux autres méthodes de la classe Microphone.
	 </p>
	 
	 <p>
	 En général, il est préférable de ne pas transmettre de valeur pour <codeph>index</codeph>. Utilisez simplement la méthode <codeph>Microphone.getMicrophone()</codeph> pour renvoyer une référence au microphone par défaut. Dans le panneau Paramètres du microphone, l’utilisateur peut spécifier le microphone par défaut que l’application doit utiliser. Si vous transmettez une valeur pour <codeph>index</codeph>, vous pouvez référencer un microphone différent de celui que l’utilisateur a choisi. Vous pouvez utiliser <codeph>index</codeph> en de rares occasions, par exemple si votre application capture un flux audio à partir de deux microphones simultanément.
	 </p>
	 
	 <p>
	 Lorsqu’un fichier SWF tente d’accéder à l’objet renvoyé par la méthode <codeph>Microphone.getMicrophone()</codeph>, par exemple lorsque vous appelez <codeph>NetStream.attachAudio()</codeph>, Flash Player affiche une boîte de dialogue Confidentialité qui permet à l’utilisateur d’autoriser ou de refuser l’accès au microphone (assurez-vous que la taille de votre scène est d’au moins 215 x 138 pixels ; il s’agit de la taille minimale requise par Flash Player pour afficher cette boîte de dialogue).
	 </p>
	 
	 <p>
     Lorsque l’utilisateur répond à cette boîte de dialogue, un événement <codeph>status</codeph> indiquant la réponse de l’utilisateur est distribué. Vous pouvez également vérifier la propriété <codeph>Microphone.muted</codeph> pour déterminer si l’utilisateur a autorisé ou interdit l’accès au microphone. 
	 </p>
	 
	 <p>
	 Si <codeph>Microphone.getMicrophone()</codeph> renvoie la valeur <codeph>null</codeph>, cela signifie que le microphone est utilisé par une autre application ou qu’aucun microphone n’est installé sur le système. Pour déterminer si un microphone est installé, utilisez <codeph>Microphones.names.length</codeph>. Pour afficher le panneau Paramètres du microphone de Flash Player, qui permet à l’utilisateur de choisir le microphone référencé par <codeph>Microphone.getMicrophone()</codeph>, utilisez <codeph>Security.showSettings()</codeph>. 
	 
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/event:status"><linktext>Microphone.status</linktext></link><link href="flash.net.xml#NetStream/attachAudio()"><linktext>flash.net.NetStream.attachAudio()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>flash.system.Security.showSettings()</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone:getMicrophone_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un microphone publie son état. Si la propriété <codeph>code</codeph> est réglée sur <codeph>Microphone.Muted</codeph>, l’utilisateur a interdit au fichier SWF d’accéder à son microphone. Si la propriété <codeph>code</codeph> est réglée sur <codeph>Microphone.Unmuted</codeph>, l’utilisateur a autorisé le fichier SWF à accéder à son microphone.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un microphone publie son état.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Microphone:setLoopBack"><apiName>setLoopBack</apiName><shortdesc>
	 Dirige le flux audio capturé par un microphone vers les haut-parleurs locaux.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>state</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData></apiParam></apiOperationDef><apiDesc>
	 Dirige le flux audio capturé par un microphone vers les haut-parleurs locaux.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.media:Microphone:setSilenceLevel"><apiName>setSilenceLevel</apiName><shortdesc>
	 Définit le niveau d’entrée minimal devant être considéré comme du son et (éventuellement) la durée de silence indiquant le début du silence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setSilenceLevel, setSilenceLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>silenceLevel</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Volume sonore requis pour activer le microphone et distribuer l’événement <codeph>activity</codeph>. Les valeurs gérées sont comprises entre 0 et 100. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Nombre de millisecondes qui doit s’écouler sans activité avant que Flash Player ou Adobe AIR considère que le son a cessé pour distribuer l’événement <codeph>dispatch</codeph>. La valeur par défaut est 2 000 (2 secondes). (<b>Remarque </b>: la valeur par défaut indiquée dans la signature, -1, est une valeur interne qui indique à Flash Player ou Adobe AIR d’utiliser 2 000).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit le niveau d’entrée minimal devant être considéré comme du son et (éventuellement) la durée de silence indiquant le début du silence.
	 <ul>
	   <li>Pour empêcher le microphone de détecter le son, attribuez la valeur 100 au paramètre <codeph>silenceLevel</codeph> ; dans ce cas, l’événement <codeph>activity</codeph> n’est jamais distribué. </li>
	   <li>Pour déterminer le volume sonore actuellement détecté par le microphone, utilisez <codeph>Microphone.activityLevel</codeph>. </li>
	 </ul>
	 
	 <p>La détection de l’activité est la capacité à détecter les niveaux audio indiquant qu’une personne est en train de parler. Lorsqu’une personne ne parle pas, il est possible d’économiser de la bande passante car il n’est pas nécessaire d’envoyer le flux audio correspondant. Ces informations peuvent également être utilisées à des fins de réponse visuelle afin que les utilisateurs (ou d’autres personnes) sachent qu’ils sont silencieux.</p>
	 
	 <p>Les valeurs de silence correspondent directement aux valeurs d’activité. La valeur d’activité 0 est associée au silence total. La valeur d’activité 100 est associée à un bruit fort constant (maximum enregistrable selon le paramètre de gain actuel). Une fois le gain ajusté convenablement, votre valeur d’activité est inférieure à votre valeur de silence lorsque vous ne parlez pas. Inversement, lorsque vous parlez, la valeur d’activité dépasse celle du silence.</p>
	 
	 <p>Cette méthode est similaire à la méthode <codeph>Camera.setMotionLevel()</codeph> ; ces deux méthodes sont utilisées pour spécifier à quel moment il convient de distribuer l’événement <codeph>activity</codeph>. Toutefois, leur impact sur la publication des flux diffère de manière significative :</p>
	 
	 <ul>
	   <li><codeph>Camera.setMotionLevel()</codeph> est conçu pour détecter le mouvement et n’a aucune incidence sur l’utilisation de la bande passante. La vidéo est envoyée peu importe qu’un flux vidéo détecte du mouvement ou non.</li>
	 
	   <li><codeph>Microphone.setSilenceLevel()</codeph> est conçu pour optimiser la bande passante. Lorsqu’un flux audio est considéré comme étant silencieux, aucune donnée audio n’est envoyée. En revanche, un message unique indiquant le début du silence est envoyé. </li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>flash.media.Camera.setMotionLevel()</linktext></link><link href="flash.media.xml#Microphone/activityLevel"><linktext>flash.media.Microphone.activityLevel</linktext></link><link href="flash.media.xml#Microphone/event:activity"><linktext>flash.media.Microphone.activity</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/silenceLevel"><linktext>flash.media.Microphone.silenceLevel</linktext></link><link href="flash.media.xml#Microphone/silenceTimeout"><linktext>flash.media.Microphone.silenceTimeout</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Microphone:setUseEchoSuppression"><apiName>setUseEchoSuppression</apiName><shortdesc>
	 Spécifie s’il convient d’utiliser la fonctionnalité de suppression de l’écho du codec audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setUseEchoSuppression, setUseEchoSuppression
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>useEchoSuppression</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur booléenne indiquant s’il convient d’utiliser la suppression de l’écho (<codeph>true</codeph>) ou non (<codeph>false</codeph>). 	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie s’il convient d’utiliser la fonctionnalité de suppression de l’écho du codec audio. La valeur par défaut est <codeph>false</codeph> sauf si l’utilisateur sélectionne l’option Réduire l’écho dans le panneau Paramètres du microphone de Flash Player.
	 
	 <p>La suppression de l’écho vise à réduire les effets de la réaction acoustique créée lorsque le son qui sort du haut-parleur est capté par le microphone sur un même ordinateur (elle diffère de l’annulation de l’écho qui supprime entièrement la réaction acoustique).</p>
	 
	 <p>En général, il est recommandé de supprimer l’écho lorsque le son capturé est lu via les haut-parleurs, et non par le casque, sur un même ordinateur. Si votre fichier SWF autorise les utilisateurs à spécifier le périphérique de sortie audio, il peut être souhaitable d’appeler <codeph>Microphone.setUseEchoSuppression(true)</codeph> s’ils précisent qu’ils utilisent les haut-parleurs et qu’ils ont également l’intention d’utiliser le microphone. </p>
	 
	 <p>Les utilisateurs peuvent également ajuster ces paramètres dans le panneau Paramètres du microphone de Flash Player.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link><link href="flash.media.xml#Microphone/useEchoSuppression"><linktext>flash.media.Microphone.useEchoSuppression</linktext></link></related-links></apiOperation><apiValue id="flash.media:Microphone:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 Volume sonore détecté par le microphone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.activityLevel, activityLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Volume sonore détecté par le microphone. Les valeurs gérées sont comprises entre 0 (aucun son n’est détecté) et 100 (un son de grande intensité est détecté). La valeur de cette propriété peut vous aider à déterminer la valeur qu’il convient de transmettre à la méthode <codeph>Microphone.setSilenceLevel()</codeph>.
	 
	 <p>Si le microphone est disponible, mais n’est pas encore utilisé car la méthode <codeph>Microphone.getMicrophone()</codeph> n’a pas été appelée, cette propriété est définie sur -1.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:codec:get"><apiName>codec</apiName><shortdesc>
	 Codec à utiliser pour la compression audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.getCodec, getCodec
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Codec à utiliser pour la compression audio. Les codecs disponibles sont Nellymoser (valeur par défaut) et Speex. La classe d’énumération <codeph>SoundCodec</codeph> contient les différentes valeurs valides pour la propriété <codeph>codec</codeph>.
	 
	 <p>Si vous utilisez le codec Nellymoser, vous pouvez définir le taux d’échantillonnage à l’aide de la méthode <codeph>Microphone.rate() </codeph>. Si vous utilisez le codec Speex, le taux d’échantillonnage est défini sur 16 kHz. </p>
	 
	 <p>Speex inclut la détection d’activité vocale (VAD) et réduit automatiquement la bande passante si aucune voix est détectée. Lorsque vous utilisez le codec Speex, Adobe vous conseille de définir le niveau de silence sur 0. Pour définir le niveau de silence, utilisez la méthode <codeph>Microphone.setSilenceLevel()</codeph>.</p>
	 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()s"><linktext>setSilenceLevel()s</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:encodeQuality:get"><apiName>encodeQuality</apiName><shortdesc>
	 Qualité du discours codé lorsque le codec Speex est utilisé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Qualité du discours codé lorsque le codec Speex est utilisé. Les valeurs possibles sont comprises entre 0 et 10. La valeur par défaut est 6. Les nombres les plus élevés offrent une plus grande qualité mais consomment davantage de bande passante, comme le montre le tableau suivant. Les valeurs de débits énumérées représentent les débits nets sans la surcharge de la mise en paquets.
	 <p>
	  <adobetable class="innertable">
	 
	    
	    
	    
	    
	    
	    
	    
	    
	 
	    
	    
	  <tgroup cols="2"><thead><row><entry>Valeur de Quality</entry><entry>Débit requis (Kbits par seconde)</entry></row></thead><tbody><row>
	      <entry>0</entry>
	      <entry> 3,95</entry>
	    </row><row>
	      <entry>1</entry>
	      <entry>5,75</entry>
	    </row><row>
	      <entry>2</entry>
	      <entry>7,75</entry>
	    </row><row>
	      <entry>3</entry>
	      <entry>9,80</entry>
	    </row><row>
	      <entry>4</entry>
	      <entry>12,8</entry>
	    </row><row>
	      <entry>5</entry>
	      <entry>16,8</entry>
	    </row><row>
	      <entry>6</entry>
	      <entry>20,6</entry>
	    </row><row>
	      <entry>7</entry>
	      <entry>23,8</entry>
	    </row><row>
	 <entry>8</entry>
	 <entry>27,8</entry>
	    </row><row>
	      <entry>9</entry>
	      <entry>34,2</entry>
	    </row><row>
	      <entry>10</entry>
	      <entry>42,2</entry>
	    </row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>codec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:framesPerPacket:get"><apiName>framesPerPacket</apiName><shortdesc>
	 Nombre d’images de discours Speex transmises dans un paquet (message).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’images de discours Speex transmises dans un paquet (message). La longueur de chaque image est 20 ms. La valeur par défaut est deux images par paquet.
	 
	 <p>Plus un message comporte d’images Speex, moins la bande passante requise est élevée, mais plus l’envoi du message est retardé. Moins d’images Speex augmente la bande passante, mais réduit le retard.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:gain:get"><apiName>gain</apiName><shortdesc>
	 Valeur selon laquelle le microphone amplifie le signal. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.gain, gain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur selon laquelle le microphone amplifie le signal. Les valeurs valides sont comprises entre 0 et 100. La valeur par défaut est 50.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:index:get"><apiName>index</apiName><shortdesc>
	 Index du microphone, tel qu’indiqué dans le tableau renvoyé par Microphone.names.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.index, index
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Index du microphone, tel qu’indiqué dans le tableau renvoyé par <codeph>Microphone.names</codeph>.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:muted:get"><apiName>muted</apiName><shortdesc>
	 Spécifie si l’utilisateur a refusé (true) ou autorisé (false) l’accès au microphone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.muted, muted
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si l’utilisateur a refusé (<codeph>true</codeph>) ou autorisé (<codeph>false</codeph>) l’accès au microphone. Lorsque cette valeur change, un événement <codeph>status</codeph> est distribué. Pour plus d’informations, voir <codeph>Microphone.getMicrophone()</codeph>. 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/event:status"><linktext>flash.media.Microphone.status</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:name:get"><apiName>name</apiName><shortdesc>
	 Nom du périphérique de capture audio actuel, tel que renvoyé par le matériel de capture de son.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.name, name
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Nom du périphérique de capture audio actuel, tel que renvoyé par le matériel de capture audio.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:names:get"><apiName>names</apiName><shortdesc>
	 Tableau de chaînes contenant les noms de tous les périphériques de capture audio disponibles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.names, names
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Tableau de chaînes contenant les noms de tous les périphériques de capture audio disponibles. Les noms sont renvoyés sans qu’il soit nécessaire d’afficher le panneau des paramètres de confidentialité de Flash Player à l’intention de l’utilisateur. Ce tableau indique l’index (commençant à zéro) de chaque périphérique de capture audio, ainsi que le nombre de ces périphériques présents dans le système, par le biais de la propriété <codeph>Microphone.names.length</codeph>. Pour plus d’informations, voir l’entrée de la classe Array.
	 
	 <p>L’appel de la propriété <codeph>Microphone.names</codeph> exige un examen minutieux du matériel et plusieurs secondes peuvent être nécessaires pour composer le tableau. Dans la plupart des cas, vous pouvez utiliser le microphone par défaut.</p>
	 
	 <p><b>Remarque :</b> pour connaître le nom du microphone actif, utilisez la propriété <codeph>name</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Array"><linktext>Array</linktext></link><link href="flash.media.xml#Microphone/name"><linktext>flash.media.Microphone.name</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:rate:get"><apiName>rate</apiName><shortdesc>
	 Taux auquel le microphone capture le son, en kHz.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.rate, rate
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Taux auquel le microphone capture le son, en kHz. Les valeurs possibles sont 5, 8, 11, 22 et 44. La valeur par défaut est 8 kHz si votre périphérique de capture audio prend en charge cette valeur. Dans le cas contraire, la valeur par défaut est le niveau de capture supérieur à 8 kHz immédiatement disponible et pouvant être pris en charge par votre périphérique de capture audio, généralement 11 kHz. Flash Player 10 et AIR 1.5 ou versions ultérieures prennent en charge la valeur du taux. 
	 
	 <p><b>Remarque :</b> si vous utilisez le codec Speex (<codeph>Microphone.codec = SoundCodec.SPEEX</codeph>) pour Flash Player 10 et AIR 1.5 ou version ultérieure, le taux par défaut est de 16 kHz. Si vous utilisez le codec Speex et modifiez la valeur du codec sur Nellymoser (<codeph>Microphone.codec = SoundCodec.NELLYMOSER</codeph>), le taux continue à être défini sur 16 kHz jusqu’à ce que vous définissiez explicitement une nouvelle valeur. Pour recevoir des données audio à l’aide des versions antérieures à Flash Player 10 et à AIR 1.5, modifiez à la fois le codec et le taux lorsque vous publiez les données audio. </p>
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>flash.media.Microphone.codec</linktext></link><link href="flash.media.xml#SoundCodec"><linktext>flash.media.SoundCodec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceLevel:get"><apiName>silenceLevel</apiName><shortdesc>
	 Volume sonore requis pour activer le microphone et distribuer l’événement activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceLevel, silenceLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Volume sonore requis pour activer le microphone et distribuer l’événement <codeph>activity</codeph>. La valeur par défaut est 10.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceTimeout:get"><apiName>silenceTimeout</apiName><shortdesc>
	 Nombre de millisecondes qui s’écoule entre le moment où le microphone arrête la détection du son et le moment où l’événement activity est appelé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceTimeout, silenceTimeout
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre de millisecondes qui s’écoule entre le moment où le microphone arrête la détection du son et le moment où l’événement <codeph>activity</codeph> est distribué. La valeur par défaut est 2 000 (2 secondes).
	 
	 <p>Pour définir cette valeur, utilisez la méthode <codeph>Microphone.setSilenceLevel()</codeph>.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Contrôle le son de cet objet Microphone lorsque le mode loopback est activé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Contrôle le son de cet objet Microphone lorsque le mode loopback est activé.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:useEchoSuppression:get"><apiName>useEchoSuppression</apiName><shortdesc>
	 Définit true si la fonctionnalité de suppression de l’écho est activée ; false dans le cas contraire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.useEchoSuppression, useEchoSuppression
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Définit <codeph>true</codeph> si la fonctionnalité de suppression de l’écho est activée ; <codeph>false</codeph> dans le cas contraire. La valeur par défaut est <codeph>false</codeph> sauf si l’utilisateur sélectionne l’option Réduire l’écho dans le panneau Paramètres du microphone de Flash Player.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.media:scanHardware"><apiName>scanHardware</apiName><shortdesc>
	 Impose un rebalayage des microphones et des caméras sur le système.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Impose un rebalayage des microphones et des caméras sur le système.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="flash.media:Camera"><apiName>Camera</apiName><shortdesc>
 Servez-vous de la classe Camera pour capturer une vidéo depuis une caméra reliée à l’ordinateur exécutant Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Servez-vous de la classe Camera pour capturer une vidéo depuis une caméra reliée à l’ordinateur exécutant Flash Player. Servez-vous de la classe Video pour contrôler la vidéo localement. Utilisez les classes NetConnection et NetStream pour transmettre la vidéo au Flash Media Server. Flash Media Server peut envoyer le flux vidéo à d’autres serveurs et le diffuser à d’autres clients exécutant Flash Player.
 
 <p>
 Pour plus d’informations sur la capture audio, voir la classe Microphone.
 </p>
 
 <p>
 <b>Important : </b> Flash Player affiche une boîte de dialogue Confidentialité qui permet à l’utilisateur d’autoriser ou de refuser l’accès à la caméra. Assurez-vous que la taille de la fenêtre de votre application soit d’au moins 215 x 138 pixels, taille minimale requise par Flash pour afficher cette boîte de dialogue.
 </p>
 
 <p>Pour créer ou référencer un objet Camera, utilisez la méthode <codeph>getCamera()</codeph>.</p>
 
 </apiDesc><example conref="examples\CameraExample.as"> L’exemple suivant montre l’image provenant d’une caméra après avoir pris connaissance de l’avertissement de sécurité. La scène est définie de telle sorte qu’il est impossible de la redimensionner, elle est alignée sur le coin supérieur gauche de la fenêtre du lecteur. L’événement <codeph>activity</codeph> est distribué au début et à la fin (si elle existe) de la session, et elle est capturée par la méthode <codeph>activityHandler()</codeph> qui imprime les informations concernant l’événement.
 
 <p><b>Remarque :</b> une caméra doit être reliée à votre ordinateur pour le bon déroulement de cet exemple.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Camera;
    import flash.media.Video;

    public class CameraExample extends Sprite {
        private var video:Video;
        
        public function CameraExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            
            var camera:Camera = Camera.getCamera();
            
            if (camera != null) {
                camera.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                video = new Video(camera.width * 2, camera.height * 2);
                video.attachCamera(camera);
                addChild(video);
            } else {
                trace("You need a camera.");
            }
        }
        
        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links><adobeApiEvent id="flash.media:Camera_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Distribué lorsqu’une caméra publie son état.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une caméra publie son état. Si la propriété <codeph>code</codeph> est définie sur <codeph>"Camera.Muted"</codeph>, l’utilisateur a interdit au fichier SWF d’accéder à sa caméra. Si la propriété <codeph>code</codeph> est réglée sur <codeph>"Camera.unmuted"</codeph>, l’utilisateur a autorisé le fichier SWF à accéder à sa caméra. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>Camera.getCamera()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Camera_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Distribué lorsqu’une caméra commence ou termine une session.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une caméra commence ou termine une session. Appelez <codeph>Camera.setMotionLevel()</codeph> pour spécifier la quantité de mouvement requise pour déclencher un événement <codeph>activity</codeph> avec une valeur <codeph>activating</codeph> de <codeph>true</codeph> ou le délai devant s’écouler sans activité avant le déclenchement d’un événement <codeph>activity</codeph> avec une valeur <codeph>activating</codeph> de <codeph>false</codeph>.
 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:Camera:getCamera"><apiName>getCamera</apiName><shortdesc>
	 Renvoie une référence à un objet Camera pour capturer de la vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, constructor, Camera.getCamera, getCamera
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Si le paramètre <codeph>name</codeph> n’est pas spécifié, cette méthode renvoie une référence à la caméra par défaut ou, si elle est utilisée par une autre application, à la première caméra disponible (si plusieurs caméras sont installées, l’utilisateur peut spécifier la caméra par défaut dans le panneau Paramètres de la caméra de Flash Player). Si aucune caméra n’est disponible ou installée, la méthode renvoie <codeph>null</codeph>. 
 	  
 	 </apiDesc><apiOperationClassifier>flash.media:Camera</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Spécifie la caméra à sélectionner, telle qu’elle est désignée à partir du tableau renvoyé par la propriété <codeph>names</codeph>. Dans la plupart des cas, omettez ce paramètre pour sélectionner la caméra par défaut. Pour spécifier une valeur pour ce paramètre, utilisez la représentation de chaîne de la position d’index basée sur zéro dans le tableau Camera.names. Par exemple, pour désigner la troisième caméra du tableau, utilisez <codeph>Camera.getCamera("2")</codeph>. 
 	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une référence à un objet Camera pour capturer de la vidéo. Pour commencer la capture de la vidéo, vous devez relier l’objet Camera à un objet vidéo (voir <codeph>Video.attachCamera() </codeph>). Pour transmettre la vidéo à Flash Media Server, appelez <codeph>NetStream.attachCamera()</codeph> pour relier l’objet Camera à un objet NetStream.
	 
	 <p>Plusieurs appels de la méthode <codeph>getCamera()</codeph> référencent le même pilote de caméra. Ainsi, si votre script contient du code comme <codeph>firstCam:Camera = getCamera()</codeph> et <codeph>secondCam:Camera = getCamera()</codeph>, alors <codeph>firstCam</codeph> et <codeph>secondCam</codeph> font référence à une même caméra, qui est la caméra par défaut de l’utilisateur.</p>
	 
	 <p>En général, évitez de transmettre la valeur du paramètre <codeph>name</codeph> ; contentez-vous d’utiliser <codeph>getCamera()</codeph> pour renvoyer une référence à la caméra par défaut. Via le panneau Paramètres de la caméra (comme indiqué plus bas dans cette section), l’utilisateur peut spécifier la caméra que Flash Player doit utiliser par défaut. </p>
	 
  	 <p>Vous ne pouvez pas utiliser ActionScript pour définir un paramètre d’autorisation ou de refus pour l’accès à la caméra, mais vous pouvez afficher la boîte de dialogue de configuration de la caméra des paramètres d’Adobe Flash Player dans laquelle l’utilisateur peut définir l’autorisation de la caméra. Lorsqu’un fichier SWF utilisant la méthode <codeph>attachCamera()</codeph> tente d’associer la caméra renvoyée par la méthode <codeph>getCamera()</codeph> à un objet Video ou NetStream, Flash Player affiche une boîte de dialogue qui permet à l’utilisateur d’autoriser ou de refuser l’accès à la caméra (vérifiez la taille de la fenêtre de votre application qui doit être au moins de 215 x 138 pixels, taille minimale requise par Flash Player pour afficher la boîte de dialogue). Lorsque l’utilisateur répond à la boîte de dialogue de configuration de la caméra, Flash Player renvoie un objet information dans l’événement <codeph>status</codeph> qui précise la réponse de l’utilisateur : <codeph>Camera.muted</codeph> indique que l’utilisateur a refusé l’accès à une caméra ; <codeph>Camera.unmuted</codeph> qu’il en a autorisé l’accès. Pour déterminer si l’utilisateur a refusé ou autorisé l’accès à la caméra sans traiter l’événement <codeph>status</codeph>, utilisez la propriété <codeph>muted</codeph>.</p>
  	 
 	 <p>L’utilisateur peut spécifier des paramètres de confidentialité permanents pour un domaine spécifique. Pour ce faire, il lui suffit de cliquer sur le bouton droit (Windows et Linux) ou de cliquer tout en maintenant la touche Contrôle enfoncée (Macintosh) lors de la lecture d’un fichier SWF, de sélectionner Paramètres, d’ouvrir la boîte de dialogue Confidentialité, puis de sélectionner Mémoriser. Si l’utilisateur sélectionne Mémoriser, Flash Player ne l’invite plus à autoriser ou refuser l’accès à votre caméra des fichiers SWF de ce domaine.</p>
  	 
  	 <p><b>Remarque :</b> la méthode <codeph>attachCamera()</codeph> n’invoque pas la boîte de dialogue permettant d’autoriser ou de refuser l’accès à la caméra si l’utilisateur a refusé l’accès en sélectionnant Mémoriser dans la boîte de dialogue Paramètres de Flash Player. Dans ce cas, vous pouvez demander à l’utilisateur de modifier le paramètre d’autorisation ou de refus en affichant le panneau de confidentialité de Flash Player pour l’utilisateur à l’aide de <codeph>Security.showSettings(SecurityPanel.PRIVACY)</codeph>.</p>
 	 
 	 <p>Si <codeph>getCamera()</codeph> renvoie la valeur <codeph>null</codeph>, cela signifie que la caméra est utilisée par une autre application ou qu’aucune caméra n’est installée sur le système. Pour déterminer si une caméra est installée, utilisez la propriété <codeph>names.length</codeph>. Pour afficher le panneau Paramètres de la caméra de Flash Player qui permet à l’utilisateur de choisir la caméra à référencer par <codeph>getCamera()</codeph>, utilisez <codeph>Security.showSettings(SecurityPanel.CAMERA)</codeph>. </p>
 	 
	 <p>L’analyse du matériel à la recherche de caméras exige un certain temps. Lorsque Flash Player détecte au moins une caméra, le matériel n’est plus analysé pendant la durée de vie de l’occurrence du lecteur. Cependant, si Flash Player ne détecte pas de caméra, il effectue une analyse à chaque appel de <codeph>getCamera</codeph>. Cela est particulièrement pratique si un utilisateur a oublié de connecter sa caméra. Si votre fichier SWF contient un bouton Réessayer qui appelle <codeph>getCamera</codeph>, Flash Player peut localiser la caméra sans que l’utilisateur ne soit obligé de redémarrer le fichier SWF.</p>
 	 
	 </apiDesc><example conref="examples\Camera_getCameraExample.as"> Dans l’exemple suivant, une fois que l’utilisateur a autorisé l’accès la caméra, la caméra associée est utilisée pour capturer des images vidéo. Les informations concernant le flux vidéo, telles que les images en cours par seconde, sont affichées également.
 
 <p>La méthode <codeph>Camera.getCamera()</codeph> renvoie une référence à un objet camera, ou renvoie null si aucune caméra n’est disponible ni installée. L’instruction if vérifie si la caméra a été trouvée et si l’utilisateur a autorisé l’accès à la caméra. Si l’utilisateur a refusé l’accès, la propriété <codeph>muted</codeph> est définie sur <codeph>true</codeph>.</p> 
 
 <p>Généralement, lorsque la méthode <codeph>attachCamera()</codeph> est appelée, une boîte de dialogue apparaît et invite l’utilisateur à autoriser ou à refuser l’accès Flash Player à la caméra. Néanmoins, si l’utilisateur a refusé l’accès et a sélectionné l’option <codeph>Mémoriser</codeph>, la boîte de dialogue n’apparaît pas et rien ne s’affiche. Pour vérifier que l’utilisateur a la possibilité d’autoriser l’accès à la caméra, le champ de texte <codeph>myTextField</codeph> demande à l’utilisateur de cliquer sur le champ de texte afin d’appeler la boîte de dialogue Paramètres de Flash Player.</p>
 
 <p>La méthode <codeph>clickHandler()</codeph> appelle la méthode <codeph>Security.showSettings()</codeph>, qui affiche le panneau <codeph>PRIVACY</codeph> de la boîte de dialogue Paramètres. Si l’utilisateur autorise l’accès, l’événement <codeph>StatusEvent.STATUS</codeph> est distribué et la valeur de la propriété <codeph>code</codeph> de l’événement est définie sur <codeph>Camera.Unmuted</codeph> (la propriété <codeph>mute</codeph> de l’objet de la caméra est définie sur <codeph>false</codeph> également).</p>
 
 <p>La méthode <codeph>statusHandler()</codeph>, ajoutée pour écouter le changement d’état du paramètre de l’utilisateur, appelle la méthode <codeph>connectCamera()</codeph>, si l’utilisateur autorise l’accès. La méthode <codeph>connectCamera()</codeph> instancie un objet video avec la hauteur et la largeur du flux capturé. Pour afficher la vidéo capturée de la caméra, la référence au flux vidéo est associée à l’objet video, et ce dernier est ajouté à la liste d’affichage.</p>
 
 <p>Un objet Timer est démarré également. Chaque seconde, un événement timer de l’objet Timer est distribué et la méthode <codeph>timerHandler()</codeph> est appelée. La méthode <codeph>timerHandler()</codeph> est affichée et met à jour plusieurs propriétés de l’objet Camera. </p> 
 <p><b>Remarque :</b> pour cet exemple, la seule propriété qui change est la propriété <codeph>currentFPS</codeph>.</p>    
    
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.StatusEvent;
    import flash.events.MouseEvent;
    import flash.system.SecurityPanel;
    import flash.system.Security;

    public class Camera_getCameraExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);
        
        public function Camera_getCameraExample() {
            myTextField = new TextField();
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";
                
            } else if (cam.muted) {
                myTextField.text = "To enable the use of the camera,\n"
                                 + "please click on this text field.\n" 
                                 + "When the Flash Player Settings dialog appears,\n"
                                 + "make sure to select the Allow radio button\n" 
                                 + "to grant access to your camera.";

                myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            }else {
                myTextField.text = "Connecting";
                connectCamera(); 
            }
   
            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            Security.showSettings(SecurityPanel.PRIVACY);

            cam.addEventListener(StatusEvent.STATUS, statusHandler);

            myTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function statusHandler(event:StatusEvent):void {

            if (event.code == "Camera.Unmuted") {
                connectCamera(); 
                cam.removeEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                t.start();
        }

        private function timerHandler(event:TimerEvent):void {
            myTextField.y = cam.height + 20;
            myTextField.text = "";
            myTextField.appendText("bandwidth: " + cam.bandwidth + "\n");
            myTextField.appendText("currentFPS: " + Math.round(cam.currentFPS) + "\n");
            myTextField.appendText("fps: " + cam.fps + "\n");
            myTextField.appendText("keyFrameInterval: " + cam.keyFrameInterval + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/muted"><linktext>muted</linktext></link><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links><adobeApiEvent id="flash.media:Camera:getCamera_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’une caméra publie son état. Si la propriété <codeph>code</codeph> est réglée sur <codeph>"Camera.muted"</codeph>, l’utilisateur a interdit au fichier SWF d’accéder à sa caméra. Si la propriété <codeph>code</codeph> est réglée sur <codeph>"Camera.unmuted"</codeph>, l’utilisateur a autorisé le fichier SWF à accéder à sa caméra. 
 	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’une caméra publie son état.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Camera:setKeyFrameInterval"><apiName>setKeyFrameInterval</apiName><shortdesc>
	 Spécifie les images qui sont transmises intégralement (images-clés) sans être interpolées par l’algorithme de compression vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>keyFrameInterval</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur spécifiant les images qui sont transmises intégralement (images-clés) sans être interpolées par l’algorithme de compression vidéo. La valeur 1 signifie que chaque image est une image-clé, 3 qu’une image sur trois est une image-clé, etc. Les valeurs gérées sont comprises entre 1 et 48.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie les images qui sont transmises intégralement (<i>keyframes</i>) sans être interpolées par l’algorithme de compression vidéo. Cette méthode ne fonctionne que si vous transmettez la vidéo via Flash Media Server.
	 
	 <p>L’algorithme de compression vidéo de Flash compresse la vidéo en transmettant uniquement les éléments modifiés à partir de la dernière image de la vidéo. Ces portions sont appelées images interpolées. Les images d’une vidéo peuvent être interpolées en fonction du contenu de l’image précédente. Une image-clé, en revanche, est une image vidéo complète. Elle n’est pas interpolée sur la base des images précédentes.</p> 
	 
	 <p>Pour déterminer la valeur du paramètre <codeph>keyFrameInterval</codeph>, tenez compte de la bande passante et de l’accessibilité de la lecture vidéo. Une valeur <codeph>keyFrameInterval</codeph> élevée (envoi moins fréquent des images-clés), par exemple, entraîne une consommation réduite de bande passante. En revanche, le temps nécessaire au positionnement de la tête de lecture à un point donné de la vidéo est susceptible d’augmenter, car il sera peut-être nécessaire d’interpoler un plus grand nombre d’images précédentes avant que la vidéo puisse reprendre.</p> 
	 
	 <p>Inversement, une valeur <codeph>keyFrameInterval</codeph> faible (envoi plus fréquent des images-clés) augmente la consommation de bande passante, car des images vidéo intégrales sont transmises plus souvent, mais elle peut réduire le temps nécessaire à la localisation d’une image spécifique dans une vidéo enregistrée.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/keyFrameInterval"><linktext>keyFrameInterval</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setLoopback"><apiName>setLoopback</apiName><shortdesc>
	 Indique s’il est nécessaire d’utiliser un flux vidéo compressé pour un visionnage local des données reçues par la caméra.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>compress</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique s’il est nécessaire d’utiliser un flux vidéo compressé (<codeph>true</codeph>) ou non (<codeph>false</codeph>) pour un visionnage local des données reçues par la caméra.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique s’il est nécessaire d’utiliser un flux vidéo compressé pour un visionnage local des données reçues par la caméra. Cette méthode n’est applicable que si vous transmettez du contenu vidéo à l’aide de Flash Media Server. Le réglage de <codeph>compress</codeph> sur <codeph>true</codeph> vous permet de déterminer plus précisément la façon dont la vidéo se présentera lorsque les utilisateurs la visionneront en temps réel.
	 
	 <p>Bien qu’un flux compressé soit utile à des fins de test, par exemple pour se faire une idée des paramètres de qualité vidéo, les coûts de traitement qu’il entraîne sont élevés car il implique plus qu’une simple compression. Le contenu vidéo est compressé, édité à des fins de transmission comme sur une connexion en direct, puis décompressé pour un visionnage local.</p>
	 
	 <p>Pour définir le taux de compression utilisé lorsque vous réglez <codeph>compress</codeph> sur <codeph>true</codeph>, servez-vous de <codeph>Camera.setQuality()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMode"><apiName>setMode</apiName><shortdesc>
	 Définit le mode de capture de la caméra sur le mode natif qui remplit le mieux les conditions requises.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMode, setMode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Largeur de capture demandée, en pixels. La valeur par défaut est 160.	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Hauteur de capture demandée, en pixels. La valeur par défaut est 120.	 
	 </apiDesc></apiParam><apiParam><apiItemName>fps</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Cadence à laquelle la caméra doit capturer des données, en images par seconde. La valeur par défaut est 15.	 
	 </apiDesc></apiParam><apiParam><apiItemName>favorArea</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Indique comment manipuler la largeur, la hauteur et la cadence si la caméra n’est pas dotée d’un mode natif qui remplit les conditions requises. La valeur par défaut est <codeph>true</codeph>, ce qui signifie que le maintien de la taille de capture est favorisé ; l’utilisation de ce paramètre permet de sélectionner le mode qui correspond le mieux aux valeurs <codeph>width</codeph> et <codeph>height</codeph>, même si cela affecte les performances en réduisant la cadence. Pour optimiser la cadence au détriment de la hauteur et de la largeur de la caméra, définissez le paramètre <codeph>false</codeph> sur <codeph>favorArea</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit le mode de capture de la caméra sur le mode natif qui remplit le mieux les conditions requises. Si la caméra ne dispose pas d’un mode natif correspondant à tous les paramètres que vous transmettez, Flash Player sélectionne un mode de capture qui synthétise le mieux le mode demandé. Cette manipulation peut nécessiter le découpage de l’image et l’omission d’images. 
	 
	 <p>Par défaut, Flash Player omet des images si nécessaire pour conserver la taille de l’image. Pour réduire le nombre d’images omises, même si cela passe par une réduction de la taille de l’image, définissez le paramètre <codeph>favorArea</codeph> sur <codeph>false</codeph>.</p>
	 
	 <p>Lorsqu’il choisit un mode natif, Flash Player tente de conserver les proportions demandées dans la mesure du possible. Par exemple, si vous publiez la commande <codeph>myCam.setMode(400, 400, 30)</codeph> et que les valeurs de largeur et de hauteur maximales disponibles sur la caméra sont 320 et 288, Flash Player définit la largeur et la hauteur sur 288. Ce faisant, Flash Player conserve la proportion 1/1 que vous avez demandée.</p>
	 
	 <p>Pour déterminer les valeurs affectées à ces propriétés une fois la sélection, par Flash Player, du mode qui correspond le mieux aux valeurs que vous avez demandées, utilisez les propriétés <codeph>width</codeph>, <codeph>height</codeph> et <codeph>fps</codeph>.</p>
	 
	 <p>
	 Si vous utilisez Flash Media Server, vous pouvez également capturer des images uniques ou créer une séquence en accéléré. Pour plus d’informations, voir la méthode <codeph>NetStream.attachCamera()</codeph>.
	 </p>
	 
	 </apiDesc><example conref="examples\Camera_setModeExample.as"> Dans l’exemple suivant, lorsqu’un utilisateur clique sur la Scène, la vidéo est redimensionnée et le taux de capture des images par seconde est défini sur une nouvelle valeur.  
 
 <p>La Scène est définie de façon à ne pas être redimensionnée. La méthode <codeph>Camera.getCamera()</codeph> renvoie une référence à un objet camera, ou renvoie null si aucune caméra n’est disponible ni installée. Si une caméra existe, la méthode <codeph>connectCamera()</codeph> est appelée. La méthode <codeph>connectCamera()</codeph> instancie un objet video. Pour afficher la vidéo capturée de la caméra, la référence au flux vidéo est associée à l’objet video, et ce dernier est ajouté à la liste d’affichage. Un écouteur d’événement est défini également pour un événement <codeph>MouseEvent.CLICK</codeph>. Une fois que l’utilisateur a cliqué sur la Scène, la méthode <codeph>clickHandler()</codeph> est invoquée. La méthode vérifie la largeur de la vidéo capturée et définit la largeur, la hauteur, et le taux demandé d’images par seconde du mode de capture de la caméra. L’objet video doit être supprimé et recréé pour que ces paramètres soient appliqués. La hauteur et la largeur de la vidéo doivent également être définies sur la hauteur et la largeur de l’objet de la caméra.</p>      
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.events.MouseEvent;
    import flash.display.StageScaleMode;

    public class Camera_setModeExample extends Sprite {
        private var cam:Camera;
        private var vid:Video;

        public function Camera_setModeExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;

            cam = Camera.getCamera();
            
            if (!cam) {
                trace("No camera is installed.");
            }else {
                connectCamera();
            }
        }

        private function connectCamera():void {
            vid = new Video();
            vid.width = cam.width;
            vid.height = cam.height; 
            vid.attachCamera(cam);
            addChild(vid);    

            stage.addEventListener(MouseEvent.CLICK, clickHandler);
        }
    
        private function clickHandler(e:MouseEvent):void {

            switch (cam.width) {
                case 160:
                cam.setMode(320, 240, 10); 
                break;
                case 320:
                cam.setMode(640, 480, 5); 
                break;
                default:
                cam.setMode(160, 120, 15); 
                break;
            } 

            removeChild(vid);           
            connectCamera();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/fps"><linktext>i/s</linktext></link><link href="flash.media.xml#Camera/height"><linktext>height</linktext></link><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.net.xml#NetStream/attachCamera()"><linktext>flash.net.NetStream.attachCamera()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMotionLevel"><apiName>setMotionLevel</apiName><shortdesc>
	 Spécifie la quantité (intensité) de mouvement requise pour distribuer l’événement activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMotionLevel, setMotionLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>motionLevel</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Spécifie la quantité (intensité) de mouvement requise pour distribuer l’événement <codeph>activity</codeph>. Les valeurs gérées sont comprises entre 0 et 100. La valeur par défaut est 50.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>2000</apiData><apiDesc>Indique le nombre de millisecondes qui doit s’écouler sans activité avant que Flash Player ne considère que l’activité a cessé et distribue l’événement <codeph>activity</codeph>. La valeur par défaut est 2 000 millisecondes (2 secondes).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie la quantité de mouvement requise pour distribuer l’événement <codeph>activity</codeph>. Peut éventuellement définir le nombre de millisecondes qui doit s’écouler sans activité avant que Flash Player ne considère que le mouvement a cessé et distribue l’événement. 
	 <p><b>Remarque : </b>la vidéo peut être affichée quelle que soit la valeur du paramètre <codeph>motionLevel</codeph>. Ce paramètre détermine uniquement à quel moment et dans quelles circonstances l’événement est distribué, pas si du contenu vidéo est capturé ou affiché.</p>
	 <p>
	 Pour empêcher la caméra de détecter le mouvement, attribuez la valeur 100 au paramètre <codeph>motionLevel</codeph>. Dans ce cas, l’événement <codeph>activity</codeph> n’est jamais distribué (vous utiliserez probablement cette valeur à des fins de tests uniquement, par exemple pour désactiver temporairement des gestionnaires qui seraient normalement déclenchés par la distribution de l’événement).
	 </p>
	 <p>
	 Pour déterminer la quantité de mouvement actuellement détectée par la caméra, utilisez la propriété <codeph>activityLevel</codeph>. Les valeurs de sensibilité de mouvement correspondent directement aux valeurs d’activité. La valeur d’activité 0 est associée à l’absence totale de mouvement. La valeur d’activité 100 est associée au mouvement constant. Lorsque vous êtes immobile, votre valeur d’activité est inférieure à votre valeur de sensibilité de mouvement. Inversement, lorsque vous vous déplacez, vos valeurs d’activité sont fréquemment supérieures à votre valeur de sensibilité de mouvement.
	 </p>
	 <p>
	 L’objectif de cette méthode est similaire à celui de <codeph>Microphone.setSilenceLevel()</codeph>. Les deux méthodes sont utilisées pour spécifier à quel moment il convient de distribuer l’événement <codeph>activity</codeph>. Toutefois, leur impact sur la publication des flux diffère de manière significative :
	 </p>
	 
	 <ul>
	   <li><codeph>Microphone.setSilenceLevel()</codeph> est conçu pour optimiser la bande passante. Lorsqu’un flux audio est considéré comme étant silencieux, aucune donnée audio n’est envoyée. En revanche, un message unique indiquant le début du silence est envoyé. </li>
	   <li><codeph>Camera.setMotionLevel()</codeph> est conçu pour détecter le mouvement et n’a aucune incidence sur l’utilisation de la bande passante. La vidéo est envoyée peu importe qu’un flux vidéo détecte du mouvement ou non.</li>
	 </ul>
	   
	 
	 
	 </apiDesc><example conref="examples\Camera_setMotionLevelExample.as"> Dans l’exemple suivant, la caméra de l’utilisateur est utilisée comme moniteur ou caméra de surveillance. La caméra détecte le mouvement et un champ de texte affiche le niveau d’activité (l’exemple peut être étendu pour émettre une alarme ou envoyer un message via un service Web à d’autres applications).
 
 <p>La méthode <codeph>Camera.getCamera()</codeph> renvoie une référence à un objet camera, ou renvoie null si aucune caméra n’est disponible ni installée. L’instruction if vérifie si une caméra est disponible, et appelle la méthode <codeph>connectCamera()</codeph> lorsqu’elle est disponible. La méthode <codeph>connectCamera()</codeph> instancie un objet video avec la hauteur et la largeur du flux capturé. Pour afficher la vidéo capturée de la caméra, la référence au flux vidéo est associée à l’objet video, et ce dernier est ajouté à la liste d’affichage. Généralement, lorsque la méthode <codeph>attachCamera()</codeph> est appelée, une boîte de dialogue apparaît et invite l’utilisateur à autoriser ou à refuser l’accès Flash Player à la caméra. Néanmoins, si l’utilisateur a refusé l’accès et a sélectionné l’option <codeph>Mémoriser</codeph>, la boîte de dialogue n’apparaît pas et rien n’est affiché. Pour vérifier que l’utilisateur a la possibilité d’autoriser l’accès à la caméra, utilisez la méthode <codeph>system.Security.showSettings()</codeph> pour appeler la boîte de dialogue Paramètres de Flash Player.</p>
 
 <p>La méthode <codeph>setMotionLevel()</codeph> définit le niveau d’activité (quantité de mouvement) avant que l’événement activity soit appelé, sur cinq, pour un mouvement minimal. Le délai qui s’écoule entre le moment où la caméra arrête de détecter le mouvement et le moment où l’événement activity est appelé, est défini sur 1 seconde (1 000 millisecondes). Après 1 seconde d’inactivité ou si le niveau d’activité atteint cinq, l’événement <codeph>ActivityEvent.ACTIVITY</codeph> est distribué et la méthode <codeph>activityHandler()</codeph> est invoquée. Si l’événement a été déclenché par le niveau d’activité, la propriété <codeph>activating</codeph> est définie sur <codeph>true</codeph> et un objet Timer est démarré. Chaque seconde, un événement timer de l’objet Timer est distribué et la méthode <codeph>timerHandler()</codeph> est invoquée, ce qui affiche le niveau d’activité en cours (même si un niveau de cinq ou supérieur déclenche la minuterie, le niveau d’activité en cours affiché peut être une valeur inférieure).</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.ActivityEvent;

    public class Camera_setMotionLevelExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);

        public function Camera_setMotionLevelExample() {
            myTextField = new TextField();
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";

            }else {
                myTextField.text = "Waiting to connect.";
                connectCamera(); 
            }

            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                cam.setMotionLevel(5, 1000);
                cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
        }

        private function activityHandler(e:ActivityEvent):void {
            if (e.activating == true) {
                t.start();    
            } else {
                myTextField.text = "Everything is quiet.";
                t.stop();
            }    
        }

        private function timerHandler(event:TimerEvent):void {
             myTextField.x = 10;
             myTextField.y = cam.height + 20;
             myTextField.text = "There is some activity. Level: " + cam.activityLevel;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/motionTimeout"><linktext>motionTimeout</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>Microphone.setSilenceLevel()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setQuality"><apiName>setQuality</apiName><shortdesc>
	 Définit la quantité maximale de bande passante par seconde ou la qualité d’image requise pour les données vidéo sortantes actuelles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera.setQuality, setQuality
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bandwidth</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Spécifie la quantité maximale de bande passante pouvant être utilisée par la vidéo sortante actuelle, en octets par seconde. Pour spécifier que la vidéo Flash Player peut utiliser autant de bande passante que nécessaire pour conserver la valeur de <codeph>quality</codeph>, attribuez la valeur 0 à <codeph>bandwidth</codeph>. La valeur par défaut est 16384.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier spécifiant le niveau de qualité d’image requis, tel que déterminé par le taux de compression appliqué à chaque image vidéo. Les valeurs acceptables sont comprises entre 1 (qualité la plus médiocre, compression maximale) et 100 (qualité optimale, pas de compression). Pour spécifier que la qualité d’image peut varier autant que nécessaire afin d’éviter un dépassement de la bande passante disponible, attribuez la valeur 0 à <codeph>quality</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit la quantité maximale de bande passante par seconde ou la qualité d’image requise pour les données vidéo sortantes actuelles. Cette méthode ne peut généralement être appliquée que si vous transmettez la vidéo via Flash Media Server.
	 
	 <p>Utilisez-la pour spécifier l’élément de la vidéo sortante le plus important pour votre application, la bande passante ou la qualité de l’image.</p>
	 
	 <ul>
	   <li>Pour indiquer que la bande passante est prioritaire, attribuez une valeur à <codeph>bandwidth</codeph> et la valeur 0 à <codeph>quality</codeph>. Flash Player transmet une vidéo de qualité optimale dans la bande passante spécifiée. Si nécessaire, Flash Player réduit la qualité de l’image afin d’éviter de dépasser la bande passante spécifiée. En général, plus le mouvement augmente, plus la qualité diminue.</li>
	   <li>Pour indiquer que la qualité est prioritaire, transmettez la valeur 0 à <codeph>bandwidth</codeph> et une valeur numérique à <codeph>quality</codeph>. Flash Player utilise autant de bande passante que nécessaire pour conserver la qualité spécifiée. Si nécessaire, Flash Player réduit la fréquence pour conserver la qualité de l’image. En général, plus le mouvement augmente, plus la consommation de bande passante augmente également.</li>
	   <li>Pour spécifier que la bande passante et la qualité sont aussi importantes l’une que l’autre, transmettez des valeurs numériques aux deux paramètres. Flash Player transmet alors de la vidéo permettant de respecter la qualité requise et ne dépassant pas la bande passante spécifiée. Si nécessaire, Flash Player réduit la fréquence pour conserver la qualité de l’image sans dépasser la bande passante spécifiée.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/quality"><linktext>quality</linktext></link></related-links></apiOperation><apiValue id="flash.media:Camera:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 Quantité de mouvement détecté par la caméra.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Quantité de mouvement détecté par la caméra. Les valeurs gérées sont comprises entre 0 (aucun mouvement n’est détecté) et 100 (une grande quantité de mouvement est détectée). La valeur de cette propriété peut vous aider à déterminer s’il est nécessaire de transmettre un paramètre à la méthode <codeph>setMotionLevel()</codeph>.
	 <p>Si la caméra est disponible mais qu’elle n’est pas encore utilisée parce que la méthode <codeph>Video.attachCamera()</codeph> n’a pas été appelée, cette propriété est définie sur -1.</p>
	 <p>Si vous diffusez en continu de la vidéo non compressée en local seulement, cette propriété n’est définie que si vous avez affecté une fonction au gestionnaire d’événement. Dans le cas contraire, elle n’est pas définie.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:bandwidth:get"><apiName>bandwidth</apiName><shortdesc>
	 Quantité maximale de bande passante pouvant être utilisée par la source vidéo sortante actuelle, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.bandwidth, bandwidth
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Quantité maximale de bande passante pouvant être utilisée par la source vidéo sortante actuelle, en octets. Une valeur de 0 signifie que la source peut utiliser autant de bande passante que nécessaire pour conserver la qualité d’image voulue.
	 <p>Pour définir cette propriété, utilisez la méthode <codeph>setQuality()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>	
	 Cadence à laquelle la caméra capture des données, en images par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.currentFPS, currentFPS
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>	
	 Cadence à laquelle la caméra capture des données, en images par seconde. Cette propriété ne peut pas être définie ; toutefois, vous pouvez utiliser la méthode <codeph>setMode()</codeph> pour définir une propriété connexe, <codeph>fps</codeph>, qui spécifie la cadence maximale à laquelle vous souhaitez que la caméra capture les données. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:fps:get"><apiName>fps</apiName><shortdesc>
	 Fréquence maximale à laquelle la caméra peut capturer des données, en images par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.fps, fps
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fréquence maximale à laquelle la caméra peut capturer des données, en images par seconde. La fréquence maximale possible dépend des capacités de la caméra ; cette fréquence peut ne pas être atteinte.
	 <ul>
	   <li>Pour définir une valeur souhaitée pour cette propriété, utilisez la méthode <codeph>setMode()</codeph>.</li>
	   <li>Pour déterminer la cadence à laquelle la caméra capture actuellement les données, utilisez la propriété <codeph>currentFPS</codeph>.</li>
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/currentFPS"><linktext>currentFPS</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:height:get"><apiName>height</apiName><shortdesc>
	 Hauteur de capture actuelle, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.height, height
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Hauteur de capture actuelle, en pixels. Pour définir une valeur à cette propriété, utilisez la méthode <codeph>setMode()</codeph>. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:index:get"><apiName>index</apiName><shortdesc>
	 Entier (commençant à zéro) qui spécifie l’index de la caméra, tel qu’indiqué dans le tableau renvoyé par la propriété names.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.index, index
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Entier (commençant à zéro) qui spécifie l’index de la caméra, tel qu’indiqué dans le tableau renvoyé par la propriété <codeph>names</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:keyFrameInterval:get"><apiName>keyFrameInterval</apiName><shortdesc>
	 Nombre d’images (appelées images-clés) qui sont transmises intégralement sans être interpolées par l’algorithme de compression vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’images vidéos (appelées <i>images-clés</i>) transmises intégralement sans être interpolées par l’algorithme de compression vidéo. La valeur par défaut, 15, indique que chaque quinzième image est une image-clé. Une valeur de 1 signifie que chaque image est une image-clé. Les valeurs autorisées vont de 1 à 48.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setKeyFrameInterval()"><linktext>setKeyFrameInterval()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:loopback:get"><apiName>loopback</apiName><shortdesc>
	 Indique si les données capturées par la caméra et visionnées localement sont compressées et décompressées (true), comme elles le seraient pour une transmission en directe par le biais de Flash Media Server, ou non compressées (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si les données capturées par la caméra et visionnées localement sont compressées et décompressées (<codeph>true</codeph>), comme elles le seraient pour une transmission en directe par le biais de Flash Media Server, ou non compressées (<codeph>false</codeph>). La valeur par défaut est <codeph>false</codeph>. 
	 
	 <p>
	 Le flux compressé est utile pour les tests, par exemple pour obtenir un aperçu des paramètres de qualité vidéo, mais son coût de traitement est important. L’affichage local est compressé, modifié pour être transmis comme il le serait sur une connexion directe, puis décompressé pour l’affichage local.
	 </p>
	 
	 <p>Pour définir cette valeur, utilisez <codeph>Camera.setLoopback()</codeph>. Pour définir le taux de compression utilisé lorsque vous réglez cette propriété sur true, utilisez <codeph>Camera.setQuality()</codeph>.</p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setLoopback()"><linktext>setLoopback()</linktext></link><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionLevel:get"><apiName>motionLevel</apiName><shortdesc>
	 Quantité de mouvement requis pour invoquer l’événement activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionLevel, motionLevel
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Quantité de mouvement requis pour invoquer l’événement <codeph>activity</codeph>. Les valeurs gérées sont comprises entre 0 et 100. La valeur par défaut est 50.
	 <p>La vidéo peut être affichée quelle que soit la valeur de la propriété <codeph>motionLevel</codeph>. Pour plus d’informations, voir l’entrée <codeph> setMotionLevel()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionTimeout:get"><apiName>motionTimeout</apiName><shortdesc>
	 Nombre de millisecondes qui s’écoule entre le moment où la caméra arrête la détection du mouvement et le moment où l’événement activity est appelé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionTimeout, motionTimeout
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre de millisecondes qui s’écoule entre le moment où la caméra arrête la détection du mouvement et le moment où l’événement <codeph>activity</codeph> est appelé. La valeur par défaut est 2 000 (2 secondes). 
	 <p>Pour définir cette valeur, utilisez <codeph>setMotionLevel()</codeph>. </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:muted:get"><apiName>muted</apiName><shortdesc>
	 Valeur booléenne qui indique si l’utilisateur a refusé (true) ou autorisé (false) l’accès à la caméra dans la boîte de dialogue de confidentialité de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.muted, muted
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur booléenne qui indique si l’utilisateur a refusé (<codeph>true</codeph>) ou autorisé (<codeph>false</codeph>) l’accès à la caméra dans la boîte de dialogue de confidentialité de Flash Player. Lorsque cette valeur change, l’événement <codeph>status</codeph> est distribué.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:name:get"><apiName>name</apiName><shortdesc>
	 Nom de la caméra en cours, tel que renvoyé par le matériel de la caméra.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Nom de la caméra en cours, tel que renvoyé par le matériel de la caméra.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:names:get"><apiName>names</apiName><shortdesc>
	 Tableau de chaînes qui indique les noms de toutes les caméras disponibles sans afficher la boîte de dialogue de confidentialité de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.names, names
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Tableau de chaînes qui indique les noms de toutes les caméras disponibles sans afficher la boîte de dialogue de confidentialité de Flash Player. Ce tableau se comporte de la même manière que tout autre tableau ActionScript : il fournit de façon implicite l’index, commençant à zéro, de chaque caméra et le nombre de caméras présentes sur le système (via <codeph>names.length</codeph>). Pour plus d’informations, voir l’entrée <codeph>names</codeph> dans la section consacrée à la classe Array.
	 
	 <p>L’appel de la propriété <codeph>names</codeph> exige un examen minutieux du matériel et plusieurs secondes peuvent être nécessaires pour créer le tableau. Dans la plupart des cas, vous pouvez utiliser la caméra par défaut.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/name"><linktext>nom</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:quality:get"><apiName>quality</apiName><shortdesc>
	 Niveau de qualité d’image requis, tel que déterminé par le taux de compression appliqué à chaque image vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.quality, quality
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Niveau de qualité d’image requis, tel que déterminé par le taux de compression appliqué à chaque image vidéo. Les valeurs de qualité acceptables sont comprises entre 1 (qualité la plus médiocre, compression maximale) et 100 (qualité optimale, pas de compression). La valeur par défaut est 0, ce qui signifie que la qualité de l’image peut varier si nécessaire pour éviter de dépasser la bande passante disponible.
	 
	 <p>Pour définir cette propriété, utilisez la méthode <codeph>setQuality()</codeph>.</p>
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:width:get"><apiName>width</apiName><shortdesc>
	 Largeur de capture actuelle, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.width, width
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Largeur de capture actuelle, en pixels. Pour définir une valeur souhaitée pour cette propriété, utilisez la méthode <codeph>setMode()</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
 La classe SoundTransform contient des propriétés relatives au volume et à la balance horizontale.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SoundTransform contient des propriétés relatives au volume et à la balance horizontale. 
 
 </apiDesc><example conref="examples\SoundTransformExample.as"> L’exemple suivant charge et lit un fichier MP3. Pendant la lecture du fichier MP3, déplacez la souris, le volume et la balance se modifient à mesure que vous bougez la souris sur la scène. Pour exécuter l’exemple, placez un fichier intitulé MySound.mp3 dans le même répertoire que votre fichier SWF.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundTransformExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundTransformExample() {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.load(request);
            channel = soundFactory.play();
            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function setPan(pan:Number):void {
            trace("setPan: " + pan.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.pan = pan;
            channel.soundTransform = transform;
        }

        private function setVolume(volume:Number):void {
            trace("setVolume: " + volume.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.volume = volume;
            channel.soundTransform = transform;
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            var halfStage:uint = Math.floor(stage.stageWidth / 2);
            var xPos:uint = event.stageX;
            var yPos:uint = event.stageY;
            var value:Number;
            var pan:Number;

            if (xPos > halfStage) {
                value = xPos / halfStage;
                pan = value - 1;
            } else if (xPos &lt; halfStage) {
                value = (xPos - halfStage) / halfStage;
                pan = value;
            } else {
                pan = 0;
            }

            var volume:Number = 1 - (yPos / stage.stageHeight);

            setVolume(volume);
            setPan(pan);
            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#SimpleButton/soundTransform"><linktext>flash.display.SimpleButton.soundTransform</linktext></link><link href="flash.display.xml#Sprite/soundTransform"><linktext>flash.display.Sprite.soundTransform</linktext></link><link href="flash.media.xml#Microphone/soundTransform"><linktext>flash.media.Microphone.soundTransform</linktext></link><link href="flash.media.xml#SoundChannel/soundTransform"><linktext>flash.media.SoundChannel.soundTransform</linktext></link><link href="flash.media.xml#SoundMixer/soundTransform"><linktext>flash.media.SoundMixer.soundTransform</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link></related-links><apiConstructor id="flash.media:SoundTransform:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
	 Crée un objet SoundTransform.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vol</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Volume, compris entre 0 (muet) et 1 (volume maximal).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>panning</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Balance horizontale du son, comprise entre -1 (balance à gauche) et 1 (balance à droite). La valeur 0 correspond à une balance équilibrée (centre). 
	 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet SoundTransform. 
	 
	 </apiDesc><example conref="examples\SoundTransform_constructorExample.as"> Dans l’exemple suivant, le fichier audio n’est lu qu’à partir du canal droit, et le volume est défini sur 50 pour-cent.
 
 <p>Dans le constructeur, le son est chargé et affecté à un canal audio (<codeph>channel</codeph>). Un objet SoundTranform (<codeph>transform</codeph>) est également créé. Son premier argument définit le volume sur 50 pour-cent (la plage va de 0.0 à 1.0). Son second argument définit la balance. Dans cet exemple, la balance est définie sur 1.0, ce qui signifie que le son provient du haut-parleur droit uniquement. Pour que ces réglages prennent effet, l’objet SoundTranform <codeph>transform</codeph> est attribué à la propriété <codeph>souundTransform</codeph> du canal audio.</p> 
<p> <b>Remarque :</b> la gestion d’erreur écrite pour cet exemple est limitée.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.events.IOErrorEvent;

    public class SoundTransform_constructorExample extends Sprite
    {
        public function SoundTransform_constructorExample() {
            var mySound:Sound = new Sound();
            var url:URLRequest = new URLRequest("mySound.mp3");
            var channel:SoundChannel;
            var transform:SoundTransform = new SoundTransform(0.5, 1.0);

            mySound.load(url);    
            channel = mySound.play();
            channel.soundTransform = transform;

            mySound.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundTransform:leftToLeft:set"><apiName>leftToLeft</apiName><shortdesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée gauche à émettre dans le haut-parleur gauche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée gauche à émettre dans le haut-parleur gauche.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:leftToRight:set"><apiName>leftToRight</apiName><shortdesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée gauche à émettre dans le haut-parleur droit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée gauche à émettre dans le haut-parleur droit.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:pan:set"><apiName>pan</apiName><shortdesc>
	 Balance horizontale du son, comprise entre -1 (balance à gauche) et 1 (balance à droite).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Balance horizontale du son, comprise entre -1 (balance à gauche) et 1 (balance à droite). La valeur 0 correspond à une balance équilibrée (centre).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToLeft:set"><apiName>rightToLeft</apiName><shortdesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée droite à émettre dans le haut-parleur gauche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée droite à émettre dans le haut-parleur gauche.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToRight:set"><apiName>rightToRight</apiName><shortdesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée droite à émettre dans le haut-parleur droit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur, comprise entre 0 (aucun) et 1 (maximum), indiquant la quantité d’entrée droite à émettre dans le haut-parleur droit.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:volume:set"><apiName>volume</apiName><shortdesc>
	 Volume, compris entre 0 (muet) et 1 (volume maximal).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Volume, compris entre 0 (muet) et 1 (volume maximal).
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Sound"><apiName>Sound</apiName><shortdesc>
  La classe Sound vous permet de contrôler le son dans une application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  La classe Sound vous permet de contrôler le son dans une application. Elle vous permet de créer un objet Sound, de charger et de lire un fichier MP3 externe dans cet objet, de fermer le flux audio et d’accéder aux données relatives au son (nombre d’octets que contient le flux, informations sur les métadonnées ID3, etc.). Un contrôle plus précis du son est possible via sa source (objet SoundChannel ou Microphone correspondant) et des propriétés de la classe SoundTransform qui contrôle l’émission du son par les haut-parleurs de l’ordinateur. 
  
  <p>Dans Flash Player 10 et les versions ultérieures, ainsi que dans AIR 1.5 et les versions ultérieures, vous pouvez également utiliser cette classe pour gérer le son généré dynamiquement. Dans ce cas, l’objet Sound utilise la fonction que vous affectez à un gestionnaire d’événement <codeph>sampleData</codeph> pour interroger les données audio. Le son est lu au fur et à mesure que les données sont récupérées dans un objet ByteArray que vous renseignez avec les données audio. Vous pouvez utiliser la méthode <codeph>Sound.extract()</codeph> pour extraire les données audio d’un objet Sound, après quoi vous pouvez les manipuler avant de les réécrire dans le flux pour la lecture.</p>
  
  <p>Pour contrôler des sons imbriqués dans un fichier SWF, utilisez les propriétés de la classe SoundMixer.</p>
  
  <p platform="actionscript"><b>Remarque </b>: l’API son d’ActionScript 3.0 est différente de celle d’ActionScript 2.0. Dans ActionScript 3.0, il est impossible de prendre des objets son et de les classer selon un ordre hiérarchique pour contrôler leurs propriétés.</p>
  
  <p>Lorsque vous employez cette classe, tenez compte du modèle de sécurité suivant : </p>
  
  <ul>
  
      <li>Le chargement et la lecture d’un son ne sont pas autorisés si le fichier appelant se trouve sur un sandbox réseau et que le fichier à charger est local.</li>
  
      <li>Par défaut, le chargement et la lecture d’un son sont interdits si le fichier appelant est local et tente de charger et de lire un son distant. Pour permettre ce type d’accès, un utilisateur doit accorder une autorisation explicite.</li>
  
      <li>Des restrictions s’appliquent à certaines opérations concernant le son. Les données d’un son chargé ne sont pas accessibles par un fichier appartenant à un autre domaine, sauf si vous mettez en place un fichier de régulation interdomaines. Les propriétés <codeph>Sound.id3</codeph>, <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph> et la classe <codeph>SoundTransform</codeph> comptent parmi les API liées au son qui sont soumises à cette restriction.</li>
  
  </ul>
  
  <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
  
  <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
  
  <ul>
  
  <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
  <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
  
    <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
  
  </ul>
  
  </apiDesc><example conref="examples\SoundExample.as"> L’exemple suivant affiche des informations concernant les événements sonores qui se produisent à l’ouverture et à la lecture d’un fichier MP3. Pour exécuter l’exemple, placez un fichier intitulé MySound.mp3 dans le même répertoire que votre fichier SWF.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;

    public class SoundExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var song:SoundChannel;

        public function SoundExample() {
            var request:URLRequest = new URLRequest(url);
            var soundFactory:Sound = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);
            song = soundFactory.play();
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.media.xml#Microphone"><linktext>Microphone</linktext></link><link href="flash.media.xml#SoundChannel"><linktext>SoundChannel</linktext></link><link href="flash.media.xml#SoundMixer"><linktext>SoundMixer</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:Sound_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Distribué lors de la réception de données, au fur et à mesure d’un chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lors de la réception de données, au fur et à mesure d’un chargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Distribué lors du démarrage d’une opération de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lors du démarrage d’une opération de chargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’un chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’un chargement. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.ID3_id3"><apiName>id3</apiName><shortdesc>
 Distribué par un objet Sound lorsque des données ID3 sont disponibles pour un son MP3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ID3</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par un objet Sound lorsque des données ID3 sont disponibles pour un son MP3. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Distribué lorsque le chargement de données aboutit.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque le chargement de données a abouti. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.SAMPLE_DATA_sampleData"><apiName>sampleData</apiName><shortdesc>
  Distribué lorsque le lecteur demande de nouvelles données audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SAMPLE_DATA</apiEventType><adobeApiEventClassifier>flash.events.SampleDataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Distribué lorsque le lecteur demande de nouvelles données audio. 
 
 </apiDesc><example conref="examples\Sound_SampleDataExample.as"> L’exemple suivant lit une onde sinusoïdale simple.
 
<codeblock>
var mySound:Sound = new Sound();
function sineWaveGenerator(event:SampleDataEvent):void {
    for ( var c:int=0; c&lt;8192; c++ ) {
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
    }
}

mySound.addEventListener(Event.SAMPLE_DATA,sineWaveGenerator);
mySound.play();
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/extract()"><linktext>extract()</linktext></link><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.events.xml#SampleDataEvent"><linktext>flash.events.SampleDataEvent</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.media:Sound:Sound"><apiName>Sound</apiName><shortdesc>
     Crée un objet Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc> URL pointant vers un fichier MP3 externe.
     
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> Un objet de contexte SoundLoader en option, qui peut définir la durée de mise en mémoire tampon (le nombre minimum de millisecondes de données MP3 à conserver dans la mémoire tampon de l’objet Sound) et peut spécifier si l’application doit rechercher un fichier de régulation interdomaines avant de charger le son.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un objet Sound. Si vous transmettez un objet URLRequest valide au constructeur Sound, celui-ci appelle automatiquement la fonction <codeph>load()</codeph> pour l’objet Sound. Si vous ne transmettez pas un objet URLRequest valide au constructeur Sound, vous devez appeler la fonction <codeph>load()</codeph> pour l’objet Sound, sans quoi le flux ne sera pas chargé.
     
     <p>Une fois la fonction <codeph>load()</codeph> appelée pour un objet Sound, vous ne pouvez plus charger de fichier audio dans l’objet. Pour ce faire, créez un autre objet Sound.</p>
     
     Dans Flash Player 10 et les versions ultérieures, ainsi que dans AIR 1.5 et les versions ultérieures, au lieu d’utiliser <codeph>load()</codeph>, vous pouvez utiliser le gestionnaire d’événement <codeph>sampleData</codeph> pour charger dynamiquement le son dans l’objet Sound.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Sound:close"><apiName>close</apiName><shortdesc>
     Ferme le flux, ce qui entraîne l’arrêt du téléchargement des données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La fermeture du flux continu s’est révélée impossible ou ce flux n’a pas été ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Ferme le flux, ce qui entraîne l’arrêt du téléchargement des données. Une fois la méthode <codeph>close()</codeph> appelée, aucune donnée ne peut être lue dans le flux.
     
     </apiDesc><example conref="examples\Sound_closeExample.as"> Dans l’exemple suivant, lorsque l’utilisateur clique sur le bouton Stop, la méthode <codeph>Sound.close()</codeph> est appelée et la diffusion du son s’arrête.
 
 <p>Dans le constructeur, un champ de texte est créé pour les boutons Start et Stop. Lorsque l’utilisateur clique sur le champ de texte, la méthode <codeph>clickHandler()</codeph> est invoquée. Elle gère le démarrage et l’arrêt du fichier audio. Notez que, selon la connexion réseau ou le moment où l’utilisateur clique sur le bouton Stop, une grande partie du fichier peut déjà avoir été chargée et l’arrêt de la lecture peut demander un certain temps. Un bloc <codeph>try...catch</codeph> est utilisé pour capturer toute erreur d’E/S pouvant survenir lors de la fermeture du flux. Par exemple, si le son est chargé depuis un répertoire local et n’est pas diffusé en continu, l’erreur 2029 est capturée et indique « Cet objet URLStream ne possède pas de flux ouvert ».</p> 
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;    
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;

    public class Sound_closeExample extends Sprite {
        private var snd:Sound = new Sound();
        private var button:TextField = new TextField();
        private var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
        
        public function Sound_closeExample() {
            button.x = 10;
            button.y = 10;
            button.text = "START";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.LEFT;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {

            if(button.text == "START") {

                snd.load(req);
                snd.play();        

                snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);

                button.text = "STOP";
            }
            else if(button.text == "STOP") {
                    
                try {
                    snd.close();
                    button.text = "Wait for loaded stream to finish.";
                }
                catch (error:IOError) {
                    button.text = "Couldn't close stream " + error.message;    
                }
            }
        }
        
        private function errorHandler(event:IOErrorEvent):void {
                button.text = "Couldn't load the file " + event.text;
        }
    }
}


</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:extract"><apiName>extract</apiName><shortdesc>
      Extrait les données audio brutes d’un objet Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre d’échantillons disponibles dans l’objet Sound.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray qui contient les échantillons audio extraits.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre d’échantillons audio à extraire. Un échantillon contient à la fois les canaux gauche et droit, c’est-à-dire deux valeurs 32 bits en virgule flottante.
          
     </apiDesc></apiParam><apiParam><apiItemName>startPosition</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>-1</apiData><apiDesc>Echantillon au niveau duquel l’extraction commence. Si vous ne spécifiez pas de valeur, le premier appel à <codeph>Sound.extract()</codeph> démarre au début du son ; les appels suivants sans valeur pour <codeph>startPosition</codeph> continuent en séquence tout au long du fichier.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
      Extrait les données audio brutes d’un objet Sound.
     
      <p>Cette méthode doit être employée lorsque vous gérez un son généré dynamiquement, à l’aide d’une fonction que vous affectez à l’événement <codeph>sampleData</codeph> pour un autre objet Sound. En d’autres termes, vous pouvez utiliser cette méthode pour extraire les données audio d’un objet Sound. Vous pouvez ensuite écrire les données dans le tableau d’octets utilisé par un autre objet Sound pour diffuser en continu les données audio dynamiques.</p>
     
      <p>Les données audio sont placées dans le tableau d’octets cible, à partir de la position actuelle du tableau d’octets. Les données audio sont toujours exposées au format 44100 Hz stéréo. Le type d’échantillon est une valeur 32 bits en virgule flottante qui peut être convertie en nombre par la méthode <codeph>ByteArray.readFloat()</codeph>. </p>
     
     </apiDesc><example conref="examples\Sound_extractExample.as"> L’exemple suivant charge un fichier mp3 et utilise la méthode <codeph>extract()</codeph> de la classe Sound pour accéder aux données audio.
 <p>Les données mp3 sont chargées dans l’objet Sound <codeph>sourceSnd</codeph>. Lorsque l’application charge les données mp3, elle appelle la fonction <codeph>loaded()</codeph> (le gestionnaire d’événement pour l’événement <codeph>complete</codeph> de l’objet <codeph>sourceSnd</codeph>). Un deuxième objet Sound, <codeph>outputSound</codeph>, est utilisé pour lire les données audio modifiées. L’objet <codeph>outputSound</codeph> possède un écouteur d’événement <codeph>sampleData</codeph> ; par conséquent, l’objet distribue régulièrement des événements <codeph>sampleData</codeph> lorsque vous appelez la méthode <codeph>play()</codeph> de l’objet. La méthode <codeph>upOctave()</codeph> renvoie un tableau d’octets des données audio modifiées en fonction des données audio source. Elle renvoie les sons plus hauts d’un octave en ignorant les échantillons audio dans les données source. Le gestionnaire d’événement de l’événement <codeph>sampleData</codeph> écrit le tableau d’octets renvoyé dans la propriété <codeph>data</codeph> de l’objet <codeph>outputSound</codeph>. Le tableau d’octets <codeph>data</codeph> est ajouté aux données audio de sortie de l’objet <codeph>outputSound</codeph>.</p>
 <p>Pour tester cet exemple, ajoutez un fichier test.mp3 au même répertoire que le fichier SWF.</p>
<codeblock>

var sourceSnd:Sound = new Sound();
var outputSnd:Sound = new Sound();
var urlReq:URLRequest = new URLRequest("test.mp3");

sourceSnd.load(urlReq);
sourceSnd.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void
{
    outputSnd.addEventListener(SampleDataEvent.SAMPLE_DATA, processSound);
    outputSnd.play();
}

function processSound(event:SampleDataEvent):void
{
    var bytes:ByteArray = new ByteArray();
    sourceSnd.extract(bytes, 4096);
    event.data.writeBytes(upOctave(bytes));
}

function upOctave(bytes:ByteArray):ByteArray
{
    var returnBytes:ByteArray = new ByteArray();
    bytes.position = 0;
    while(bytes.bytesAvailable > 0)
    {
        returnBytes.writeFloat(bytes.readFloat());
        returnBytes.writeFloat(bytes.readFloat());
        if (bytes.bytesAvailable > 0)
        {
            bytes.position += 8;
        }
    }
    return returnBytes;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Sound/event:sampleData"><linktext>sampleData</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Sound:load"><apiName>load</apiName><shortdesc>
     Lance le chargement d’un fichier MP3 externe à partir de l’URL spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur réseau a entraîné l’échec du chargement.
	 
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Les fichiers non approuvés au niveau local risquent de ne pas communiquer avec Internet. Pour contourner ce problème, reclassifiez le fichier en tant qu’approuvé<ph platform="actionscript"> ou en tant que fichier local avec accès au réseau</ph>.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>La propriété <codeph>digest</codeph> de l’objet <codeph>stream</codeph> n’est pas définie sur <codeph>null</codeph>. Vous devez définir la propriété <codeph>digest</codeph> d’un objet URLRequest uniquement lorsque vous appelez la méthode <codeph>URLLoader.load()</codeph> en vue de charger un fichier SWZ (un composant de la plateforme Adobe).
     
      </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> URL pointant vers un fichier MP3 externe.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> Un objet de contexte SoundLoader en option, qui peut définir la durée de mise en mémoire tampon (le nombre minimum de millisecondes de données MP3 à conserver dans la mémoire tampon de l’objet Sound) et peut spécifier si l’application doit rechercher un fichier de régulation interdomaines avant de charger le son.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lance le chargement d’un fichier MP3 externe à partir de l’URL spécifiée. Le constructeur Sound appelle automatiquement <codeph>Sound.load()</codeph> si vous lui fournissez un objet URLRequest valide. Vous ne devez appeler <codeph>Sound.load()</codeph> manuellement que si vous ne fournissez aucun objet URLRequest valide au constructeur Sound, ou si vous lui transmettez la valeur <codeph>null</codeph>.
     
     <p>Une fois la fonction <codeph>load()</codeph> appelée pour un objet Sound, vous ne pouvez plus charger de fichier audio dans l’objet. Pour ce faire, créez un autre objet Sound.</p>
     
	 <p platform="actionscript">Pour utiliser cette méthode, tenez compte du modèle de sécurité suivant :</p>
     
     <ul platform="actionscript">
     
     <li>L’appel de <codeph>Sound.load()</codeph> n’est pas autorisé si le fichier appelant se trouve dans le sandbox local avec système de fichiers et que le son se trouve sur un sandbox réseau.</li>
     
     <li>Un accès à partir du sandbox approuvé local ou du sandbox local avec accès au réseau exige l’autorisation du site Web via un fichier de régulation d’URL.</li>
     
      <li>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, reportez-vous à la rubrique « Restriction des API de réseau » dans le <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref> </ph> du manuel <i>Programmation avec ActionScript 3.0</i>. </li>
     
     <li>Vous pouvez éviter qu’un fichier SWF utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</li>
     
     </ul>
     
     <p platform="actionscript"> Dans Flash Player versions 10 et ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête « content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul platform="actionscript">
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p platform="actionscript">Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     <p platform="actionscript">Dans Adobe AIR, le contenu du sandbox de sécurité de l’<codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas restreint par ces limites de sécurité.</p>
     
     <p platform="actionscript">Pour plus de détails sur la sécurité, voir les sections suivantes :</p>
     
     <ul platform="actionscript">
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i></li>
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\Sound_loadExample.as"> L’exemple suivant présente la progression du chargement d’un fichier audio.
 
 <p>Dans le constructeur, un objet <codeph>URLRequest</codeph> est créé pour identifier l’emplacement du fichier audio, qui correspond à un podcast d’Adobe. Le fichier est chargé dans un bloc <codeph>try...catch</codeph> pour capturer toute erreur pouvant survenir pendant son chargement. En cas d’erreur d’E/S, la méthode <codeph>errorHandler()</codeph> est également invoquée et le message d’erreur s’inscrit dans le champ de texte réservé au rapport de progression. Pendant la progression d’une opération de chargement, un événement <codeph>ProgressEvent.PROGRESS</codeph> est envoyé et la méthode <codeph>progressHandler()</codeph> est appelée. Ici, un événement <codeph>ProgressEvent.PROGRESS</codeph> est utilisé comme minuteur pour calculer la progression du chargement.</p> 
  
 <p>La méthode <codeph>progressHandler()</codeph> divise la valeur <codeph>bytesLoaded</codeph> transmise avec l’objet <codeph>ProgressEvent</codeph> par la valeur <codeph>bytesTotal</codeph> pour arriver au pourcentage de données audio chargées. Elle affiche ensuite ces valeurs dans le champ de texte (notez que si le fichier est petit, mis en cache ou dans le répertoire local, la progression peut ne pas être perceptible).</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.ProgressEvent;
    import flash.events.IOErrorEvent;
    
    public class Sound_loadExample extends Sprite {
        private var snd:Sound = new Sound();
        private var statusTextField:TextField  = new TextField();

        public function Sound_loadExample(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
            snd.load(req);
            
            snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(ProgressEvent.PROGRESS, progressHandler);
                     
            this.addChild(statusTextField);
        }
    
        private function progressHandler(event:ProgressEvent):void {
            var loadTime:Number = event.bytesLoaded / event.bytesTotal;
            var LoadPercent:uint = Math.round(100 * loadTime);
              
            statusTextField.text = "Sound file's size in bytes: " + event.bytesTotal + "\n" 
                                 + "Bytes being loaded: " + event.bytesLoaded + "\n" 
                                 + "Percentage of sound file that is loaded " + LoadPercent + "%.\n";
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:play"><apiName>play</apiName><shortdesc>
     Crée un objet SoundChannel pour lire le son.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet SoundChannel permettant de contrôler le son. Cette méthode renvoie <codeph>null</codeph> si vous n’êtes pas équipé d’une carte son ou si aucun canal audio n’est disponible. Le nombre maximal de canaux audio disponibles simultanément est 32.
     
     </apiDesc><apiOperationClassifier>flash.media:SoundChannel</apiOperationClassifier></apiReturn><apiParam><apiItemName>startTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Position initiale du début de la lecture, en millisecondes.
     </apiDesc></apiParam><apiParam><apiItemName>loops</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Définit le nombre de boucles décrit par un son sur la valeur <codeph>startTime</codeph> avant que le canal audio arrête la lecture. 
     </apiDesc></apiParam><apiParam><apiItemName>sndTransform</apiItemName><apiOperationClassifier>flash.media:SoundTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet SoundTransform d’origine affecté au canal audio.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Crée un objet SoundChannel pour lire le son. Cette méthode renvoie un objet SoundChannel, auquel vous accédez pour arrêter le son et régler le volume (pour contrôler le volume, la balance horizontale et la balance, accédez à l’objet SoundTransform affecté au canal audio).
     
     </apiDesc><example conref="examples\Sound_playExample1.as"> Dans l’exemple suivant, une fois le fichier chargé, l’utilisateur peut sélectionner la position de départ (heure de démarrage) du fichier audio à l’aide d’une barre graphique.
 
 <p>Le constructeur appelle la méthode <codeph>Sound.load()</codeph> pour commencer à charger les données audio. Il appelle ensuite la méthode <codeph>Sound.play()</codeph> qui commencera à lire le fichier dès que suffisamment de données seront chargées. La méthode <codeph>Sound.play()</codeph> renvoie un objet SoundChannel qui peut être utilisé pour contrôler la lecture du fichier. Le champ de texte affiche les instructions. Pour être sûr que le contenu où l’utilisateur souhaite que le fichier audio commence ait déjà été chargé, un objet Sprite <codeph>bar</codeph> est créé et affiché à la fin du chargement du fichier. Un événement <codeph>Event.COMPLETE</codeph> est envoyé lorsque le chargement du fichier s’est terminé avec succès, ce qui déclenche la méthode <codeph>completeHandler()</codeph>. La méthode <codeph>completeHandler()</codeph> crée ensuite la barre et l’ajoute dans la liste d’affichage (un objet sprite est utilisé au lieu d’un objet shape pour assurer l’interactivité). Lorsque l’utilisateur clique sur la barre, la méthode <codeph>clickHandler()</codeph> est déclenchée.</p> 
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la position de la coordonnée x du clic de l’utilisateur, <codeph>event.localX</codeph>, est utilisée pour déterminer l’emplacement où l’utilisateur souhaite que le fichier démarre. Comme la barre fait 100 pixels et commence à la coordonnée x 100 pixels, il est facile de déterminer le pourcentage de la position. De même, comme le fichier est chargé, la propriété <codeph>length</codeph> du fichier audio aura la longueur du fichier terminé, en millisecondes. La position de démarrage du fichier audio est déterminée par la longueur de ce fichier et sa position dans la ligne. Après arrêt de la lecture, le fichier audio redémarre à la position de démarrage sélectionnée, transmise sous forme de paramètre <codeph>startTime</codeph> à la méthode <codeph>play()</codeph>.</p>
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.MouseEvent;
    import flash.media.Sound;;
    import flash.net.URLRequest;
    import flash.media.SoundChannel;
    import flash.events.ProgressEvent;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample1 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var infoTextField:TextField = new TextField();
    
        public function Sound_playExample1() {

            var req:URLRequest = new URLRequest("MySound.mp3");
            
            infoTextField.autoSize = TextFieldAutoSize.LEFT;
            infoTextField.text = "Please wait for the file to be loaded.\n" 
                                + "Then select from the bar to decide where the file should start.";
            
            snd.load(req);               
            channel = snd.play();

            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(Event.COMPLETE, completeHandler);


            this.addChild(infoTextField);
        }

        private function completeHandler(event:Event):void {                
            infoTextField.text = "File is ready.";

            var bar:Sprite = new Sprite();

            bar.graphics.lineStyle(5, 0xFF0000);
            bar.graphics.moveTo(100, 100);
            bar.graphics.lineTo(200, 100);

            bar.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(bar);
        }
    
        private function clickHandler(event:MouseEvent):void {
            
                var position:uint = event.localX;
                var percent:uint = Math.round(position) - 100;   
                var cue:uint = (percent / 100) * snd.length;

                channel.stop();
                channel = snd.play(cue);    
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            infoTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample2.as"> Dans l’exemple suivant, le fichier audio est diffusé une ou deux fois, selon si l’utilisateur clique une fois ou deux sur un bouton.
 
 <p>Dans le constructeur, le son est chargé et un simple objet sprite rectangle <codeph>button</codeph> est créé (un objet sprite est utilisé au lieu d’un objet shape pour assurer l’interactivité). Ici, le fichier audio est supposé être dans le même répertoire que le fichier SWF (il n’existe pas de code de gestion d’erreur pour cet exemple).</p>
 
 <p>Deux écouteurs d’événement sont configurés pour répondre aux simples clics et aux doubles clics de souris. Si l’utilisateur utilise un simple clic, la méthode <codeph>clickHandler()</codeph> est invoquée et la lecture du son commence. Si l’utilisateur double-clique sur le bouton, la méthode <codeph>doubleClickHandler()</codeph> est invoquée et le fichier audio est diffusé à deux reprises. Le second argument de la méthode <codeph>play()</codeph> est défini sur <codeph>1</codeph>, ce qui signifie que le fichier audio reviendra à l’heure de démarrage du fichier et sera diffusé à nouveau. L’heure de démarrage, premier argument, est définie sur <codeph>0</codeph>, ce qui signifie que la lecture du fichier doit commencer au début.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.media.Sound;
    import flash.net.URLRequest;

    public class Sound_playExample2 extends Sprite {
        private var button:Sprite = new Sprite(); 
        private var snd:Sound = new Sound();
            
        public function Sound_playExample2() {

            var req:URLRequest = new URLRequest("click.mp3");
            snd.load(req);               
     
            button.graphics.beginFill(0x00FF00);
            button.graphics.drawRect(10, 10, 50, 30);
            button.graphics.endFill();
     
            button.addEventListener(MouseEvent.CLICK, clickHandler);
            button.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClickHandler);
     
            this.addChild(button);
        }

        private function clickHandler(event:MouseEvent):void {
            snd.play();            
        }

        private function doubleClickHandler(event:MouseEvent):void {
            snd.play(0, 2);        
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample3.as"> L’exemple suivant présente la progression du chargement et de la lecture d’un fichier audio.
 
 <p>Dans le constructeur, le fichier est chargé dans un bloc <codeph>try...catch</codeph> pour capturer toute erreur pouvant survenir pendant le chargement de fichier. Un écouteur est ajouté dans l’objet audio et répondra à un événement <codeph>IOErrorEvent</codeph> par un appel à la méthode <codeph>errorHandler()</codeph>. Un autre écouteur est ajouté pour l’application principale et répondra à un événement <codeph>Event.ENTER_FRAME</codeph>, utilisé comme mécanisme de minuterie pour l’affichage de la progression de la lecture. Enfin, un troisième écouteur est ajouté pour le canal audio et répondra à un événement <codeph>Event.SOUND_COMPLETE</codeph> (à la fin de la lecture) par un appel à la méthode <codeph>soundCompleteHandler()</codeph>. La méthode <codeph>soundCompleteHandler()</codeph> supprime également l’écouteur de l’événement <codeph>Event.ENTER_FRAME</codeph>.</p>
 
 <p>La méthode <codeph>enterFrameHandler()</codeph> divise la valeur <codeph>bytesLoaded</codeph> transmise avec l’objet <codeph>ProgressEvent</codeph> par la valeur <codeph>bytesTotal</codeph> pour arriver au pourcentage de données audio chargées. Le pourcentage de données audio lues peut être déterminé en divisant la valeur de la propriété <codeph>position</codeph> du canal audio par la longueur des données audio. Toutefois, si les données audio ne sont pas entièrement chargées, la propriété <codeph>length</codeph> de l’objet audio ne présente que la taille des données audio déjà chargées. Une estimation de la taille définitive du fichier audio complet est calculée en divisant la valeur de la propriété <codeph>length</codeph> de l’objet audio en cours par la valeur de la propriété <codeph>bytesLoaded</codeph> divisée par la valeur de la propriété <codeph>bytesTotal</codeph>.</p>
 
 <p>Notez que si le fichier est petit, mis en cache ou dans le répertoire local, la progression du chargement peut ne pas être perceptible. De même, le délai qui sépare le démarrage du chargement des données audio et celui du démarrage de la lecture des données chargées est déterminé par la valeur de la propriété <codeph>SoundLoaderContext.buffertime</codeph>, qui correspond par défaut à 1 000 millisecondes et peut être réinitialisé.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample3 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel;
        private var statusTextField:TextField  = new TextField();

        public function Sound_playExample3(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;

           var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
                snd.load(req);
            
                channel = snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
                    
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                    
            this.addChild(statusTextField);
        }
    
        private function enterFrameHandler(event:Event):void {    
            var loadTime:Number = snd.bytesLoaded / snd.bytesTotal;
            var loadPercent:uint = Math.round(100 * loadTime);
            var estimatedLength:int = Math.ceil(snd.length / (loadTime));
            var playbackPercent:uint = Math.round(100 * (channel.position / estimatedLength));
      
            statusTextField.text = "Sound file's size is " + snd.bytesTotal + " bytes.\n" 
                                   + "Bytes being loaded: " + snd.bytesLoaded + "\n" 
                                   + "Percentage of sound file that is loaded " + loadPercent + "%.\n"
                                   + "Sound playback is " + playbackPercent + "% complete.";     
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }

        private function soundCompleteHandler(event:Event):void {
            statusTextField.text = "The sound has finished playing.";
            removeEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundChannel/stop()"><linktext>SoundChannel.stop()</linktext></link><link href="flash.media.xml#SoundMixer/stopAll()"><linktext>SoundMixer.stopAll()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Sound:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
     Renvoie le nombre d’octets actuellement disponibles dans cet objet Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie le nombre d’octets actuellement disponibles dans cet objet Sound. Cette propriété n’est généralement utile que pour les fichiers chargés en externe.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
     Renvoie le nombre total d’octets que contient l’objet Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie le nombre total d’octets que contient l’objet Sound. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:id3:get"><apiName>id3</apiName><shortdesc>
     Donne accès aux métadonnées faisant partie d’un fichier MP3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sound, Sound.id3, id3, mp3
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.media:ID3Info</apiValueClassifier></apiValueDef><apiDesc>
     Donne accès aux métadonnées faisant partie d’un fichier MP3.
     
     <p>Les fichiers son MP3 peuvent contenir des balises ID3 qui fournissent des métadonnées sur le fichier. Si le son MP3 que vous chargez à l’aide de la méthode <codeph>Sound.load()</codeph> contient des balises ID3, vous pouvez interroger ces propriétés. Seules les balises ID3 qui utilisent le jeu de caractères UTF-8 sont prises en charge.</p>
     
	 <p><ph outputclass="actionscript">Flash Player 9 et version ultérieure ainsi que le moteur d’exécution AIR prennent en charge </ph><ph platform="javascript">Le moteur d’exécution AIR prend en charge</ph> les balises ID3 2.0, plus particulièrement 2.3 et 2.4. Les tableaux suivants répertorient les balises ID3 2.0 standard et le type de contenu que les balises représentent. La propriété <codeph>Sound.id3</codeph> permet d’accéder à ces balises par le biais du format <codeph>my_sound.id3.COMM</codeph>, <codeph>my_sound.id3.TIME</codeph>, etc. Le premier tableau décrit les balises auxquelles il est possible d’accéder par le biais du nom de propriété ID3 2.0 ou le nom de propriété ActionScript. Le second tableau décrit les balises ID3 qui sont prises en charge, mais ne possèdent pas de propriétés prédéfinies dans ActionScript. </p>
     
     <adobetable class="innertable">
       
      
      
      
     
     
     
     
     <tgroup cols="2"><tbody><row>
         <entry><b>Balise ID3 2.0</b></entry>
	    <entry><b>Propriété de la classe Sound correspondante</b></entry>
      </row><row>
        <entry>COMM</entry>
        <entry>Sound.id3.comment</entry>
      </row><row>
        <entry>TALB</entry>
        <entry>Sound.id3.album </entry>
      </row><row>
     
       <entry>TCON</entry>
       <entry>Sound.id3.genre</entry>
      </row><row>
       <entry>TIT2</entry>
       <entry>Sound.id3.songname </entry>
     </row><row>
       <entry>TPE1</entry>
       <entry>Sound.id3.artist</entry>
     </row><row>
       <entry>TRCK</entry>
       <entry>Sound.id3.track </entry>
     </row><row>
       <entry>TYER</entry>
       <entry>Sound.id3.year </entry>
     </row></tbody></tgroup></adobetable>
     
     <p>Le tableau suivant décrit les balises ID3 qui sont prises en charge, mais ne possèdent pas de propriétés prédéfinies dans la classe Sound. Pour y accéder, appelez <codeph>mySound.id3.TFLT</codeph>, <codeph>mySound.id3.TIME</codeph>, etc.</p>  
      <adobetable class="innertable">
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      <tgroup cols="2"><tbody><row>
          <entry><b>Propriété</b></entry>
          <entry><b>Description</b></entry>
        </row><row>
          <entry>TFLT</entry>
          <entry>Type de fichier</entry>
        </row><row>
          <entry>TIME</entry>
          <entry>Durée</entry>
        </row><row>
          <entry>TIT1</entry>
          <entry>Description du groupe de contenus</entry>
        </row><row>
          <entry>TIT2</entry>
          <entry>Titre/nom du morceau/description du contenu</entry>
        </row><row>
          <entry>TIT3</entry>
          <entry>Sous-titre/description plus précise</entry>
        </row><row>
          <entry>TKEY</entry>
          <entry>Touche initiale</entry>
        </row><row>
          <entry>TLAN</entry>
          <entry>Langues</entry>
        </row><row>
          <entry>TLEN</entry>
          <entry>Durée</entry>
        </row><row>
          <entry>TMED</entry>
          <entry>Type de média</entry>
        </row><row>
          <entry>TOAL</entry>
          <entry>Titre de l’album/du film/du spectacle d’origine</entry>
        </row><row>
          <entry>TOFN</entry>
          <entry>Nom du fichier d’origine</entry>
        </row><row>
          <entry>TOLY</entry>
          <entry>Paroliers/auteurs d’origine</entry>
        </row><row>
          <entry>TOPE</entry>
          <entry>Interprètes/musiciens d’origine</entry>
        </row><row>
          <entry>TORY</entry>
          <entry>Année de parution d’origine</entry>
        </row><row>
          <entry>TOWN</entry>
          <entry>Propriétaire du fichier/détenteur de licence</entry>
        </row><row>
          <entry>TPE1</entry>
          <entry>Interprètes principaux/solistes</entry>
        </row><row>
          <entry>TPE2</entry>
          <entry>Groupe/orchestre/accompagnement</entry>
        </row><row>
          <entry>TPE3</entry>
          <entry>Chef d’orchestre/description plus détaillée des musiciens</entry>
        </row><row>
          <entry>TPE4</entry>
          <entry>Interprété, remixé ou modifié par</entry>
        </row><row>
          <entry>TPOS</entry>
          <entry>Elément d’un ensemble</entry>
        </row><row>
          <entry>TPUB</entry>
          <entry>Editeur</entry>
        </row><row>
          <entry>TRCK</entry>
          <entry>Numéro de piste/position dans l’ensemble</entry>
        </row><row>
          <entry>TRDA</entry>
          <entry>Dates d’enregistrement</entry>
        </row><row>
          <entry>TRSN</entry>
          <entry>Nom de la station radio Internet</entry>
        </row><row>
          <entry>TRSO</entry>
          <entry>Propriétaire de la station radio Internet</entry>
        </row><row>
          <entry>TSIZ</entry>
          <entry>Taille</entry>
        </row><row>
          <entry>TSRC</entry>
          <entry>ISRC (international standard recording code - code standard et international d’enregistrement)</entry>
        </row><row>
          <entry>TSSE</entry>
          <entry>Logiciel/matériel et paramètres utilisés pour le codage</entry>
        </row><row>
          <entry>TYER</entry>
          <entry>Année</entry>
        </row><row>
          <entry>WXXX</entry>
          <entry>Structure de lien URL</entry>
        </row></tbody></tgroup></adobetable>
     
     
     <p>Pour utiliser cette propriété, tenez compte du modèle de sécurité de Flash Player :</p>
     
     <ul>
     
     <li>La propriété <codeph>id3</codeph> d’un objet Sound est toujours autorisée pour les fichiers SWF qui se trouvent sur le même sandbox de sécurité que le fichier audio. Des contrôles de sécurité sont nécessaires pour les fichiers se trouvant sur d’autres sandbox.</li>
     
     <li>Lorsque vous chargez le son à l’aide de la méthode <codeph>load()</codeph> de la classe Sound, vous pouvez spécifier un paramètre <codeph>context</codeph> qui est un objet SoundLoaderContext. Si vous définissez la propriété <codeph>checkPolicyFile</codeph> de l’objet SoundLoaderContext sur <codeph>true</codeph>, Flash Player recherche un fichier de régulation d’URL sur le serveur à partir duquel le son est chargé. S’il existe un fichier de régulation qui autorise un accès à partir du domaine du fichier SWF effectuant le chargement, le fichier peut alors accéder à la propriété <codeph>id3</codeph> de l’objet Sound ; dans le cas contraire, l’accès lui est interdit.</li>
     
     </ul>
     
     <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
     
     <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul>
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
     
     

     
     </apiDesc><example conref="examples\Sound_id3Example.as"> L’exemple suivant lit les informations d’ID3 dans un fichier audio et les affiche dans un champ de texte.
 
 <p>Dans le constructeur, le fichier audio est chargé mais n’est pas défini sur lecture. Ici, le fichier est supposé être dans le répertoire SWF. Le système doit être autorisé à lire les balises ID3 d’un fichier audio chargé. Si le fichier contient des informations ID3 alors que le programme n’est pas autorisé à les lire, un événement <codeph>Event.ID3</codeph> est déclenché et la propriété <codeph>id3</codeph> du fichier audio est renseignée. La propriété <codeph>id3</codeph> contient un objet <codeph>ID3Info</codeph> renfermant toutes les informations ID3.</p>
 
 <p>Dans la méthode <codeph>id3Handler()</codeph>, les balises ID3 du fichier sont stockées dans <codeph>id3</codeph>, un objet de la classe ID3Info. Un champ de texte est instancié pour afficher la liste des balises ID3. La boucle for fait une itération à travers toutes les balises ID3 2.0 et ajoute le nom et la valeur au contenu du champ de texte. L’artiste, le titre de la chanson et le nom de l’album sont également ajoutés via les propriétés (<codeph>ID3Info</codeph>) des informations ID3. ActionScript 3.0 et Flash Player 9 et versions ultérieures prennent en charge les balises ID3 2.0, et en particulier 2.3 et 2.4. Si vous faites une itération des propriétés comme dans la boucle for, seules les balises ID3 2.0 apparaissent. Toutefois, les données des versions précédentes sont également stockées dans la propriété <codeph>id3</codeph> de la chanson et sont accessibles via les propriétés de la classe ID3Info. Les balises ID3 1.0 se situent à la fin du fichier alors que les balises ID3 2.0 sont placées au début du fichier (il arrive parfois que les balises des versions antérieures et ultérieures soient au même endroit dans le fichier). Lorsqu’un fichier est encodé avec des balises 1.0 et 2.0 au début et à la fin du fichier, la méthode <codeph>id3Handler()</codeph> doit être invoquée deux fois. Elle lit d’abord la version 2.0, puis la version 1.0. Si seule une balise ID3 1.0 est disponible, les informations sont alors accessibles via les propriétés d’informations ID3, telles que <codeph>id3.songname</codeph>. Pour ID3 2.0, la propriété <codeph>id3.TITS</codeph> récupère le titre de la chanson à l’aide de la nouvelle balise (TITS).</p>
 
 <p>Notez que aucune gestion d’erreur n’est écrite pour cet exemple et que si le contenu ID3 est long, le résultat peut dépasser la zone visible.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.net.URLRequest;
    import flash.media.ID3Info;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;

    public class Sound_id3Example extends Sprite {
        private var snd:Sound = new Sound();       
        private var myTextField:TextField = new TextField();

        public function Sound_id3Example() {
            snd.addEventListener(Event.ID3, id3Handler);
            snd.load(new URLRequest("mySound.mp3"));
        }
    
        private function id3Handler(event:Event):void {
            var id3:ID3Info = snd.id3;

            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.border = true;

            myTextField.appendText("Received ID3 Info: \n");
              
            for (var propName:String in id3) {
                myTextField.appendText(propName + " = " + id3[propName] + "\n");
            }
 
            myTextField.appendText("\n" + "Artist: " + id3.artist + "\n");
            myTextField.appendText("Song name: " + id3.songName + "\n");
            myTextField.appendText("Album: " + id3.album + "\n\n"); 
 
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiValue><apiValue id="flash.media:Sound:isBuffering:get"><apiName>isBuffering</apiName><shortdesc>
     Renvoie l’état de mise en mémoire tampon des fichiers MP3 externes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie l’état de mise en mémoire tampon des fichiers MP3 externes. Si la valeur correspond à <codeph>true</codeph>, la lecture éventuelle est interrompue pendant que l’objet attend des données supplémentaires.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:length:get"><apiName>length</apiName><shortdesc>
     Durée du son actuel, en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Durée du son actuel, en millisecondes.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:url:get"><apiName>url</apiName><shortdesc>
     URL à partir de laquelle le son a été chargé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     URL à partir de laquelle le son a été chargé. Cette propriété s’applique uniquement aux objets Sound chargés à l’aide de la méthode <codeph>Sound.load()</codeph>. Pour les objets Sound associés à une ressource son de la bibliothèque d’un fichier SWF, la valeur de la propriété <codeph>url</codeph> correspond à <codeph>null</codeph>.
     
     <p>La première fois que vous appelez <codeph>Sound.load()</codeph>, la valeur de la propriété <codeph>url</codeph> est d’abord définie <codeph>null</codeph> car l’URL finale n’est pas encore connue. La propriété <codeph>url</codeph> a une autre valeur dès qu’un événement <codeph>open</codeph> est distribué à partir de l’objet Sound.</p>
     
     <p>La propriété <codeph>url</codeph> contient l’URL absolue finale à partir de laquelle un son a été chargé. En règle générale, la valeur de la propriété <codeph>url</codeph> est identique à la valeur transmise au paramètre <codeph>stream</codeph> de <codeph>Sound.load()</codeph>. Si vous transmettez une URL relative à <codeph>Sound.load()</codeph>, la valeur de la propriété <codeph>url</codeph> représente l’URL absolue. En outre, si la requête d’URL d’origine est redirigée par un serveur HTTP, la valeur de la propriété <codeph>url</codeph> reflète l’URL finale à partir de laquelle le fichier audio a réellement été téléchargé. La publication d’une URL finale absolue est équivalente au comportement de <codeph>LoaderInfo.url</codeph>.</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
 La classe SoundLoaderContext effectue des contrôles de sécurité des fichiers qui chargent le son.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SoundLoaderContext effectue des contrôles de sécurité des fichiers qui chargent le son. Les objets SoundLoaderContext sont transmis en tant qu’arguments au constructeur et à la méthode <codeph>load()</codeph> de la classe Sound.
 
 <p>Lorsque vous employez cette classe, tenez compte du modèle de sécurité suivant : </p>
 
 <ul>
 <li>Le chargement et la lecture d’un son ne sont pas autorisés si le fichier appelant se trouve sur un sandbox réseau et que le fichier à charger est local.</li>
 
 	<li>Par défaut, le chargement et la lecture d’un son sont interdits si le fichier appelant est local et tente de charger et de lire un son distant. Pour que cette opération soit possible, un utilisateur doit accorder une autorisation explicite.</li>
 
 	<li>Des restrictions s’appliquent à certaines opérations concernant le son. Tout fichier appartenant à un autre domaine ne peut pas accéder aux données d’un son chargé, sauf si vous implémentez un fichier de régulation d’URL. La propriété <codeph>Sound.id3</codeph> et les méthodes <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph> et <codeph>SoundTransform()</codeph> comptent parmi les API liées au son qui sont soumises à cette restriction.</li>
 
 </ul>
 
 <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
 
 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
 
 <ul>
 
 <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i></li>
 
   <li>La section du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/devnet/flashplayer/security.html" scope="external">Sécurité</xref></li>
 
 </ul>
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.media:SoundLoaderContext:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
     Crée un objet SoundLoaderContext.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bufferTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1000</apiData><apiDesc>Durée, en secondes, de préchargement dans une mémoire tampon d’un son en flux continu avant que la diffusion ne commence.
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si l’existence d’un fichier de régulation d’URL doit être vérifiée après le chargement de l’objet (<codeph>true</codeph>) ou non.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un objet SoundLoaderContext.  
     
     </apiDesc><example conref="examples\SoundLoaderContextExample.as"> Dans l’exemple suivant, le tampon des données audio devant être chargées est défini sur trois secondes.
 
 <p>Le premier paramètre d’un objet SoundLoaderContext (<codeph>context</codeph>) est utilisé pour augmenter la valeur de tampon par défaut d’une seconde à trois secondes (la valeur est en millisecondes). Si le second paramètre de l’objet SoundLoaderContext est défini sur <codeph>true</codeph>, Flash Player recherche un fichier de régulation interdomaines lors du chargement de l’objet Ici, il est défini sur la valeur par défaut <codeph>false</codeph>, donc aucun fichier de régulation n’est recherché. La méthode <codeph>load()</codeph> de l’objet audio utilisera le paramètre de contexte pour s’assurer que le préchargement des données audio en flux continu dans un tampon prendra trois secondes avant que ces données ne commencent à être diffusées. L’objet <codeph>URLRequest</codeph> détermine l’emplacement du fichier, qui correspond à un podcast d’Adobe. Si une erreur <codeph>IOErrorEvent.IO_ERROR</codeph> se produit pendant le chargement du fichier audio, la méthode <codeph>errorHandler()</codeph> est invoquée.</p> 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.events.IOErrorEvent;
    
    public class SoundLoaderContextExample extends Sprite {

        public function SoundLoaderContextExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            var context:SoundLoaderContext = new SoundLoaderContext(3000, false);

            snd.load(req, context);
            snd.play();      
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }

    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundLoaderContext:bufferTime"><apiName>bufferTime</apiName><shortdesc>
	 Durée, en millisecondes, de préchargement dans une mémoire tampon d’un son en flux continu avant que la diffusion ne commence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1000</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Durée, en millisecondes, de préchargement dans une mémoire tampon d’un son en flux continu avant que la diffusion ne commence.
	 
	 <p>Vous pouvez remplacer la valeur de <codeph>SoundLoaderContext.bufferTime</codeph> en définissant la propriété globale <codeph>SoundMixer.bufferTime</codeph>. <ph platform="actionscript">La propriété <codeph>SoundMixer.bufferTime</codeph> affecte uniquement la durée de mise en mémoire tampon des sons en flux continu imbriqués dans un fichier SWF. Elle n’a aucune incidence sur les objets Sound créés dynamiquement (autrement dit, créés dans ActionScript).</ph></p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundLoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 Indique si l’application doit tenter de télécharger un fichier de régulation d’URL à partir du serveur du son chargé avant de commencer à charger ce dernier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext, NetStream
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si l’application doit tenter de télécharger un fichier de régulation d’URL à partir du serveur du son chargé avant de commencer à charger ce dernier. Cette propriété s’applique si le son chargé à l’aide de la méthode <codeph>Sound.load()</codeph> se trouve en dehors du domaine du fichier appelant.
	 
	 <p platform="javascript">Cette propriété s’applique uniquement au contenu SWF s’exécutant en dehors du sandbox de sécurité de l’application AIR. </p>
	 
	 <p platform="actionscript">Définissez cette propriété sur <codeph>true</codeph> lorsque vous chargez un son qui se trouve en dehors du domaine du fichier appelant et que le code dans le fichier appelant requiert un accès de niveau bas pour les données du son. Référencer la propriété <codeph>Sound.id3</codeph> pour extraire un objet ID3Info et appeler la méthode <codeph>SoundMixer.computeSpectrum()</codeph> pour extraire des échantillons audio du son chargé constituent des exemples d’accès de bas niveau. Si vous tentez d’accéder aux données audio sans régler la propriété <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> au chargement, vous risquez d’obtenir une exception SecurityError car le fichier de régulation requis n’a pas été téléchargé.</p>
	 
	 <p platform="actionscript">Si un accès de bas niveau aux données audio que vous chargez est inutile, il est préférable de ne pas régler <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>. La recherche d’un fichier de régulation consomme de la bande passante réseau et peut retarder le début du téléchargement. N’effectuez donc cette opération qu’en cas de nécessité.</p>
	 
	 <p platform="actionscript">Lorsque vous appelez <codeph>Sound.load()</codeph> en définissant <codeph>SoundLoaderContext.checkPolicyFile</codeph> sur <codeph>true</codeph>, Flash Player ou AIR doit télécharger un fichier de régulation d’URL approprié, ou déterminer qu’un tel fichier n’existe pas, avant de commencer à télécharger le son spécifié. Pour vérifier l’existence d’un fichier de régulation, <ph platform="actionscript">Flash Player ou </ph>AIR exécute les actions suivantes, dans l’ordre indiqué :</p>
	 
	 <ul platform="actionscript">
	 
	 <li>Flash Player ou AIR examine les fichiers de régulation téléchargés au préalable.</li>
	 
	 <li>Flash Player ou AIR tente de télécharger tout fichier de régulation en attente spécifié dans les appels de <codeph>Security.loadPolicyFile()</codeph>.</li>
	 
	 <li>Flash Player ou AIR tente de télécharger un fichier de régulation à partir de l’emplacement par défaut qui correspond à l’URL du son, autrement dit <codeph>/crossdomain.xml</codeph> sur le même serveur que <codeph>URLRequest.url</codeph> (l’URL du son est spécifiée dans la propriété <codeph>url</codeph> de l’objet URLRequest transmis à <codeph>Sound.load()</codeph> ou à la fonction du constructeur Sound()).</li>
	 </ul>
	 
	 <p platform="actionscript">Dans tous les cas, Flash Player ou AIR requiert que le serveur du son héberge un fichier de régulation approprié et que ce fichier autorise l’accès au fichier son à <codeph>URLRequest.url</codeph>, sur la base de l’emplacement du fichier de régulation, et qu’il permette au domaine du fichier appelant d’accéder au son par le biais d’une ou plusieurs balises <codeph>&lt;allow-access-from></codeph>.
	 </p>
	 
	 <p platform="actionscript">Si vous réglez <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>, Flash Player ouAIR attend la vérification du fichier de régulation avant de télécharger le son. Avant d’effectuer des opérations de bas niveau sur les données audio, en appelant <codeph>Sound.id3</codeph> ou <codeph>SoundMixer.computeSpectrum()</codeph> par exemple, attendez que l’objet Sound ait déclenché les événements <codeph>progress</codeph> et <codeph>complete</codeph>.
	 </p>
	 
	 <p platform="actionscript">Si vous définissez <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> et qu’il n’existe aucun fichier de régulation approprié, vous ne recevez aucun message d’erreur tant que vous n’effectuez pas d’opération nécessitant un tel fichier ; dans ce cas Flash Player ou AIR renvoie une exception <codeph>SecurityError</codeph>. Une fois que vous avez reçu un événement <codeph>complete</codeph>, vous pouvez vérifier qu’un fichier de régulation approprié a été éventuellement trouvé en extrayant la valeur de <codeph>Sound.id3</codeph> d’un bloc <codeph>try</codeph> et en vérifiant si une exception <codeph>SecurityError</codeph> est renvoyée.</p>
	 
	 
	 <p platform="actionscript">Servez-vous de <codeph>checkPolicyFile</codeph> avec précaution si vous téléchargez un son à partir d’une URL qui utilise des redirections HTTP côté serveur. Flash Player ou AIR tente d’extraire les fichiers de régulation correspondant à la propriété <codeph>url</codeph> de l’objet URLRequest transmis à <codeph>Sound.load()</codeph>. Si le fichier audio final provient d’une URL différente en raison de redirections HTTP, les fichiers de régulation initialement téléchargés peuvent ne pas être applicables à l’URL finale du son, autrement dit l’URL à prendre en compte dans les décisions relatives à la sécurité.</p>
	 
	 <p platform="actionscript">La solution ci-après peut vous permettre de résoudre ce problème. Après la réception d’un événement <codeph>progress</codeph> ou <codeph>complete</codeph>, vous pouvez examiner la valeur de la propriété <codeph>Sound.url</codeph> qui contient l’URL finale du son. Appelez ensuite la méthode <codeph>Security.loadPolicyFile()</codeph> en vous basant sur l’URL finale du son pour calculer l’URL du fichier de régulation. Enfin, interrogez <codeph>Sound.id3</codeph> jusqu’à ce qu’aucune exception ne soit renvoyée.</p>
	 
	 <p platform="actionscript">Ceci ne s’applique pas au contenu dans le sandbox de l’application AIR. Le contenu dans le sandbox de l’application a toujours un accès par programmation au contenu sonore, quelle que soit son origine.</p>
	 
	 <p platform="actionscript">Pour plus d’informations sur les fichiers de régulation, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>flash.media.Sound.load()</linktext></link><link href="flash.media.xml#Sound/id3"><linktext>flash.media.Sound.id3</linktext></link><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>flash.media.SoundMixer.computeSpectrum()</linktext></link><link href="flash.media.xml#Sound/url"><linktext>flash.media.Sound.url</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundChannel"><apiName>SoundChannel</apiName><shortdesc>
 La classe SoundChannel contrôle un son dans une application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SoundChannel contrôle un son dans une application. Chaque son est attribué à un canal audio, et l’application peut avoir plusieurs canaux audio mélangés. La classe SoundChannel contient une méthode <codeph>stop()</codeph>, des propriétés permettant de contrôler l’amplitude (volume) du canal et une propriété servant à affecter un objet SoundTransform au canal.
 
 </apiDesc><example conref="examples\SoundChannelExample.as"> L’exemple suivant charge un fichier MP3, le lit et affiche des informations sur les événements sonores qui se produisent tandis que le fichier MP3 est chargé et lu. Un objet Timer fournit des informations récentes sur le positionnement de la tête de lecture toutes les 50 millisecondes. Pour exécuter l’exemple, placez un fichier intitulé MySound.mp3 dans le même répertoire que votre fichier SWF.

<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundChannelExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundChannelExample() {
            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);

            channel = soundFactory.play();
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);

            positionTimer = new Timer(50);
            positionTimer.addEventListener(TimerEvent.TIMER, positionTimerHandler);
            positionTimer.start();
        }
        

        private function positionTimerHandler(event:TimerEvent):void {
            trace("positionTimerHandler: " + channel.position.toFixed(2));
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
            positionTimer.stop();       
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }

        private function soundCompleteHandler(event:Event):void {
            trace("soundCompleteHandler: " + event);
            positionTimer.stop();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:SoundChannel_flash.events.Event.SOUND_COMPLETE_soundComplete"><apiName>soundComplete</apiName><shortdesc>
 Distribué au terme de la lecture d’un son.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SOUND_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué au terme de la lecture d’un son. 
 </apiDesc><example conref="examples\SoundChannel_event_soundCompleteExample.as"> Dans l’exemple suivant, l’utilisateur sélectionne des chansons dans une liste de lecture, puis clique sur Lecture pour les écouter dans l’ordre sélectionné.
 
 <p>Dans le constructeur, un champ de texte est défini et contient la liste des chansons et une ligne de sélection des lectures (généralement, des boutons servent à lire et à lister les champs d’une liste de chansons). Un objet text format est défini pour changer le format des lignes de chansons en italique une fois qu’elles sont sélectionnées. Lorsqu’un utilisateur clique sur le champ de texte, la méthode <codeph>clickHandler()</codeph> est invoquée.</p> 
 
<p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getLineIndexAtPoint()</codeph> de l’objet text field renvoie l’index de la ligne sur laquelle l’utilisateur à cliqué. A l’aide de l’index de la ligne, la méthode <codeph>getLineText()</codeph> obtient le contenu du texte. L’instruction if vérifie si l’utilisateur a sélectionné un élément pour le lire ou pour ajouter une chanson à la liste de lecture. Si l’utilisateur a sélectionné la lecture et qu’une chanson a été sélectionnée, l’écouteur d’événement du clic de souris est supprimé et la méthode <codeph>playNext()</codeph> est appelée pour commencer la lecture des chansons. Si l’utilisateur a sélectionné un titre de chanson, le contenu de la ligne est ajouté au tableau <codeph>songList</codeph> et le format de la ligne est défini sur italique.</p>
 
 <p>La méthode <codeph>playNext()</codeph> charge et lit chaque chanson en faisant une itération dans la liste du tableau. La chanson est également affectée à un canal audio. Un écouteur d’événement du canal audio est ajouté pour répondre lorsque la lecture de la chanson est terminée et l’événement <codeph>Event.SOUND_COMPLETE</codeph> est distribué. La méthode <codeph>soundCompleteHandler()</codeph> invoque alors la méthode <codeph>playNext()</codeph> pour diffuser la chanson suivante. Ce processus se poursuit jusqu’à ce que la lecture de toutes les chansons du tableau soit terminée.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;

    public class SoundChannel_event_soundCompleteExample extends Sprite {
        private var channel:SoundChannel = new SoundChannel();
        private var songList:Array = new Array();
        private var listTextField:TextField = new TextField();
        private var songFormat:TextFormat = new TextFormat();
        private var arrayIndex:int = 0;
        private var songSelected:Boolean = false;
        
        public function SoundChannel_event_soundCompleteExample() {
            
            listTextField.autoSize = TextFieldAutoSize.LEFT;
            listTextField.border = true
            listTextField.background = true;
            listTextField.text = "Song1.mp3\n" + "Song2.mp3\n" 
                                + "Song3.mp3\n" + "Song4.mp3\n" + "PLAY";
        
            songFormat.italic = true;
 
            listTextField.addEventListener(MouseEvent.CLICK, clickHandler);
                        
            addChild(listTextField);
        }
        
        private function clickHandler(e:MouseEvent):void {
            var index:int = listTextField.getLineIndexAtPoint(e.localX, e.localY);
            var line:String = listTextField.getLineText(index);
            var firstIndex:uint = listTextField.getLineOffset(index);
            var playLine:uint = listTextField.numLines - 1;

                if((index == playLine) &amp;&amp; (songSelected == true)) {
                    listTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
                    playNext();       

                } else if (index != playLine) {
                     songList.push(line.substr(0, (line.length - 1)));
                     listTextField.setTextFormat(songFormat, firstIndex, 
                                (firstIndex + listTextField.getLineLength(index)));     
                    songSelected = true;
                 }
        }

        private function playNext():void {
 
             if(arrayIndex &lt; songList.length) {
                var snd:Sound = new Sound();
                snd.load(new URLRequest(songList[arrayIndex]));
                channel = snd.play();
                
                channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                arrayIndex++;
 
            } else {
                songSelected = false;
                    
                while(arrayIndex > 0) {
                    songList.pop();
                    arrayIndex--;
                }
            }
        }    

        private function soundCompleteHandler(e:Event):void {
            playNext();
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:SoundChannel:stop"><apiName>stop</apiName><shortdesc> 
	 Arrête la lecture du son dans le canal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 Arrête la lecture du son dans le canal.
	 
	 </apiDesc><example conref="examples\SoundChannel_stopExample.as"> Dans l’exemple suivant, l’utilisateur peut cliquer sur un bouton pour faire une pause et relire un fichier audio. 
 
 <p>Le fichier audio est chargé dans le constructeur (cet exemple suppose que le fichier est dans le même répertoire que le fichier SWF). Un champ de texte est utilisé comme bouton pour que l’utilisateur puisse lire ou interrompre la lecture. Lorsque l’utilisateur clique sur le champ de texte <codeph>button</codeph>, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, au premier clic de l’utilisateur sur le champ de texte, le son est défini sur lecture et affecté à un canal audio. Lorsque l’utilisateur clique ensuite sur le champ de texte pour faire une pause, la lecture s’interrompt. La propriété <codeph>position</codeph> du canal audio enregistre la position du son au moment où il a été arrêté. Cette propriété est utilisée pour reprendre le son à partir de cette position, une fois que l’utilisateur a cliqué sur le champ de texte pour relancer la lecture. Chaque fois que la méthode <codeph>Sound.play()</codeph> est appelée, un nouvel objet SoundChannel est créé et affecté à la variable <codeph>channel</codeph>. L’objet Sound doit être affecté à un objet SoundChannel pour que la méthode <codeph>stop()</codeph> du canal audio soit utilisée pour arrêter le son.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
            
    public class SoundChannel_stopExample extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var button:TextField = new TextField();

        public function SoundChannel_stopExample() {
            var req:URLRequest = new URLRequest("MySound.mp3");
            snd.load(req);
            
            button.x = 10;
            button.y = 10;
            button.text = "PLAY";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.CENTER;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {
            var pausePosition:int = channel.position;

            if(button.text == "PLAY") {
                channel = snd.play(pausePosition);
                button.text = "PAUSE";
            } 
            else {
                channel.stop();
                button.text = "PLAY";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundChannel:leftPeak:get"><apiName>leftPeak</apiName><shortdesc> 
	 Amplitude actuelle (volume) du canal gauche, comprise entre 0 (muet) et 1 (amplitude maximale).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Amplitude actuelle (volume) du canal gauche, comprise entre 0 (muet) et 1 (amplitude maximale).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:position:get"><apiName>position</apiName><shortdesc>
	 Lorsque le fichier est en cours de lecture, la propriété position indique en millisecondes le point en cours de lecture dans le fichier audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Lorsque le fichier est en cours de lecture, la propriété <codeph>position</codeph> indique en millisecondes le point en cours de lecture dans le fichier audio. Lorsque la lecture est arrêtée ou interrompue, la propriété <codeph>position</codeph> indique le dernier point lu dans le fichier audio.
	 
	 <p>Généralement, la valeur de la propriété <codeph>position</codeph> est enregistrée lorsque la lecture est interrompue. Vous pouvez ensuite reprendre la lecture en redémarrant à partir de cette position enregistrée.
	 </p>
	 
	 <p>Si le son fait l’objet d’une boucle, la propriété <codeph>position</codeph> est réinitialisée à 0 au début de chaque boucle.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:rightPeak:get"><apiName>rightPeak</apiName><shortdesc> 
	 Amplitude actuelle (volume) du canal droit, comprise entre 0 (muet) et 1 (amplitude maximale).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Amplitude actuelle (volume) du canal droit, comprise entre 0 (muet) et 1 (amplitude maximale).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 Objet SoundTransform affecté au canal audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 Objet SoundTransform affecté au canal audio. Un objet SoundTransform comprend les propriétés de réglage du volume, du déplacement panoramique, ainsi que des haut-parleurs gauche et droit.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:Video"><apiName>Video</apiName><shortdesc>
 
 La classe Video affiche une vidéo en direct ou enregistrée dans une application sans l’intégrer dans votre fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 La classe Video affiche une vidéo en direct ou enregistrée dans une application sans l’intégrer dans votre fichier SWF. Cette classe crée un objet Video dans une interface Adobe Flash ou Adobe Flex qui diffuse l’un des types de vidéo suivants : fichiers FLV enregistrés sur un serveur ou localement ou vidéo en direct capturée sur l’ordinateur de l’utilisateur. Un objet Video est un objet d’affichage de la liste d’affichage de l’application et représente l’espace visuel au sein duquel la vidéo s’exécute dans une interface utilisateur.
 
 <p>
 Utilisé avec Flash Media Server, l’objet Video vous permet d’envoyer une vidéo en direct depuis l’ordinateur de l’utilisateur vers le serveur, puis de la diffuser du serveur vers d’autres utilisateurs. Grâce à ses fonctionnalités, vous pouvez développer des applications multimédia telles qu’un simple lecteur vidéo, un lecteur vidéo avec publication multipoint d’un serveur à un autre ou une application de partage vidéo pour une communauté d’utilisateurs.
 </p>
 
 <p>
 Flash Player 9 gère la publication et la lecture des fichiers FLV codés avec le codec Sorenson ou On2 VP6, et prend également en charge un canal alpha. Le codec vidéo On2 VP6 utilise moins de largeur de bande que les technologies plus anciennes et offre des filtres supplémentaires de dégroupage et de deringing. Reportez-vous à la classe flash.net.NetStream pour de plus amples informations sur la lecture vidéo.</p>
 
 
 <p>
 Flash Player 9.0.115.0 et les versions ultérieures prennent en charge le mip-mapping pour optimiser les performances et la qualité du rendu au moment de l’exécution. Pour la lecture vidéo, Flash Player utilise l’optimisation mip-mapping si vous définissez la propriété <codeph>smoothing</codeph> de l’objet Video sur <codeph>true</codeph>. 
 </p> 
 
 <p>
 Comme pour les autres objets d’affichage de la liste d’affichage, vous pouvez contrôler différentes propriétés des objets Video. Par exemple, vous pouvez déplacer l’objet Video sur la scène à l’aide de ses propriétés <codeph>x</codeph> et <codeph>y</codeph>, modifier sa taille à l’aide de ses propriétés <codeph>height</codeph> et <codeph>width</codeph>, etc. 
 </p>
 
 <p>
 Pour lire un flux vidéo, utilisez <codeph>attachCamera()</codeph> ou <codeph>attachNetStream()</codeph> pour associer la vidéo à l’objet Video. Ajoutez ensuite l’objet Video à la liste d’affichage à l’aide de <codeph>addChild()</codeph>.
 </p>
 
 <p product="flash">
 Si vous utilisez l’outil de programmation de Flash, vous pouvez également placer l’objet Video sur la scène au lieu de l’ajouter avec <codeph>addChild()</codeph>, comme suit :
 </p>
 
 <ol product="flash">
   <li>Si le panneau Bibliothèque n’est pas visible, sélectionnez Fenêtre > Bibliothèque pour l’afficher.</li>
   <li>Ajoutez un objet Video imbriqué à la bibliothèque en cliquant sur le menu Options à droite de la barre de titre du panneau bibliothèque et en sélectionnant Nouvelle Vidéo.</li>
   <li>Dans la boîte de dialogue des propriétés de la vidéo, nommez l’objet Video intégré à utiliser dans la bibliothèque et cliquez sur OK.</li>
   <li>Faites glisser l’objet Video sur la scène et utilisez l’inspecteur des propriétés pour lui donner un nom d’occurrence unique, par ex. <codeph>ma_video</codeph> (ne l’appelez pas Video).</li>
 </ol>
 
 <p><b>Remarque :</b> la classe Video n’étant pas une sous-classe de la classe InteractiveObject, elle ne peut pas distribuer d’événements de souris. Vous pouvez cependant appeler la méthode <codeph>addEventListener()</codeph> sur le conteneur d’objet d’affichage qui contient l’objet Video.
 </p>
 
 </apiDesc><example conref="examples\VideoExample.as"> L’exemple suivant utilise un objet Video avec les classes NetConnection et NetStream pour charger et lire un fichier FLV. Pour exécuter cet exemple, vous avez besoin d’un fichier FLV dont le nom et l’emplacement correspondent à la variable transmise à <codeph>videoURL</codeph>, en l’occurrence un fichier FLV appelé Video.flv qui se trouve dans le même répertoire que le fichier SWF.
 <p>Dans cet exemple, le code qui crée les objets Video et NetStream, et appelle <codeph>Video.attachNetStream()</codeph> et <codeph>NetStream.play()</codeph>, est placé dans une fonction de gestionnaire. Le gestionnaire est appelé uniquement si la tentative de connexion à l’objet NetConnection a réussi, ce qui est le cas lorsque l’événement <codeph>netStatus</codeph> renvoie un objet info doté d’une propriété <codeph>code</codeph> signalant la réussite de l’opération. Il est recommandé d’attendre l’établissement d’une connexion avant d’appeler <codeph>NetStream.play()</codeph>. </p>
 <codeblock>

 package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;

    public class VideoExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function VideoExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }

        private function connectStream():void {
            stream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }
    }
 }
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>attachCamera()</linktext></link><link href="flash.media.xml#Video/attachNetStream()"><linktext>attachNetStream()</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#Stage/addChild()"><linktext>flash.display.Stage.addChild()</linktext></link></related-links><apiConstructor id="flash.media:Video:Video"><apiName>Video</apiName><shortdesc>
     Crée une occurrence de Video.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
     </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>320</apiData><apiDesc>Largeur de la vidéo, en pixels.
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>240</apiData><apiDesc>Hauteur de la vidéo, en pixels.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée une occurrence de Video. Si la valeur des paramètres <codeph>width</codeph> et <codeph>height</codeph> n’est pas définie, les valeurs par défaut sont utilisées. Vous pouvez aussi définir les propriétés de largeur et de hauteur de l’objet Video après sa construction initiale à l’aide des propriétés <codeph>Video.width</codeph> et <codeph>Video.height</codeph>. Lors de la création d’un objet Video, il est interdit de définir une largeur et une hauteur nulles. Si vous transmettez la valeur zéro, les valeurs par défaut sont appliquées.
     
     <p>Une fois l’objet Video créé, appelez la méthode <codeph>DisplayObjectContainer.addChild()</codeph> ou <codeph>DisplayObjectContainer.addChildAt()</codeph> pour l’ajouter à un objet DisplayObjectContainer parent.</p>
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Video:attachCamera"><apiName>attachCamera</apiName><shortdesc>
     Spécifie un flux vidéo provenant d’une caméra à afficher dans le cadre de l’objet Video de l’application. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.attachCamera, attachCamera()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>camera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>Objet Camera qui capture des données vidéo. Pour annuler la connexion à l’objet Video, transmettez <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Spécifie un flux vidéo provenant d’une caméra à afficher dans le cadre de l’objet Video de l’application. 
     
     <p>
     Utilisez cette méthode pour associer à l’objet Video une vidéo en direct provenant de l’ordinateur d’un utilisateur. Vous pouvez diffuser la vidéo en direct localement sur l’ordinateur sur lequel elle a été capturée ou l’envoyer au Flash Media Server et utiliser le serveur pour envoyer le flux aux autres utilisateurs.
     </p>
     
     </apiDesc><example>Pour une illustration de l’utilisation de cette méthode, voir l’exemple de la méthode <xref href="Camera.html#getCamera()">Camera.getCamera()</xref>. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachNetStream()"><linktext>Video.attachNetStream()</linktext></link><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:attachNetStream"><apiName>attachNetStream</apiName><shortdesc>
     Spécifie un flux vidéo à afficher dans le cadre de l’objet Video dans l’application. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, video, Video.attachNetStream, attachNetStream()
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>netStream</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier><apiDesc>Objet NetStream. Pour annuler la connexion à l’objet Video, transmettez <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Spécifie un flux vidéo à afficher dans le cadre de l’objet Video dans l’application. Le flux vidéo est soit un fichier FLV lu avec <codeph>NetStream.play()</codeph>, soit un objet Camera, soit <codeph>null</codeph>. Si vous utilisez un fichier FLV, il peut être stocké dans le système de fichiers local ou sur le serveur Flash Media Server. Si la valeur de l’argument <codeph>netStream</codeph> correspond à <codeph>null</codeph>, la vidéo n’est plus lue dans l’objet Video.
     
     <p>
     Vous n’êtes pas obligé(e) d’utiliser cette méthode si le fichier FLV contient uniquement des données audio ; la partie audio des fichiers FLV est automatiquement lue lors de l’appel de la méthode <codeph>NetStream.play()</codeph>. Pour contrôler les données audio associées à un fichier FLV, utilisez la propriété <codeph>soundTransform</codeph> de l’objet NetStream qui lit le fichier FLV.
     </p>
     
     </apiDesc><example>Pour une illustration de l’utilisation de cette méthode, voir l’exemple présenté à la fin de cette classe. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>flash.net.NetStream.play()</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:clear"><apiName>clear</apiName><shortdesc>
     Efface l’image actuellement affichée dans l’objet Video (pas le flux vidéo).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.clear, clear
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Efface l’image actuellement affichée dans l’objet Video (pas le flux vidéo). Cette méthode est très utile pour gérer l’image en cours. Par exemple, vous pouvez effacer la dernière image ou afficher des informations en attente sans masquer l’objet Video.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Video:deblocking:get"><apiName>deblocking</apiName><shortdesc>
     Indique le type de filtre appliqué aux vidéos décodées dans le cadre du posttraitement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.deblocking, deblocking
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Indique le type de filtre appliqué aux vidéos décodées dans le cadre du posttraitement. La valeur par défaut, 0, autorise le compresseur vidéo à appliquer le filtre de dégroupage si nécessaire.
     
     <p>La compression de la vidéo peut engendrer des artefacts indésirables. Vous pouvez utiliser la propriété <codeph>deblocking</codeph> pour définir des filtres de dégroupage et, pour la vidéo compressée utilisant le codex On2, ringing.</p>
     
     <p>Le <i>groupage</i> désigne les défauts visibles entre les limites des blocs qui composent chaque image vidéo. Le <i>ringing</i> fait référence aux déformations observées au niveau des bords des éléments dans une image vidéo.</p>
     
     <p>Deux filtres de dégroupage sont disponibles : l’un dans le codec Sorenson, l’autre dans le codec On2 VP6. Un filtre de deringing est également disponible lorsque vous utilisez le codec On2 VP6. Pour définir un filtre, utilisez une des valeurs suivantes :</p>
     
     <ul>
       <li>0 — Autorise le compresseur vidéo à appliquer le filtre de dégroupage si nécessaire.</li>
       <li>1 — N’utilise pas de filtre de dégroupage.</li>
       <li>2 — Utilise le filtre de dégroupage Sorenson.</li>
       <li>3 — Pour la vidéo On2 seulement, utilise le filtre de dégroupage On2, mais pas de filtre de deringing.</li>
       <li>4 — Pour la vidéo On2 seulement, utilise le filtre de dégroupage et le filtre de deringing On2.</li>
       <li>5 — Pour la vidéo On2 seulement, utilise le filtre de dégroupage On2 et un filtre de deringing On2 optimisé.</li>
     </ul>
     
     <p>Si une valeur supérieure à 2 est sélectionnée pour la vidéo alors que vous utilisez le codec Sorenson, le décodeur Sorenson applique par défaut la valeur 2.</p>
     
     <p>Le filtre de dégroupage a un effet sur les performances globales de lecture et il n’est généralement pas nécessaire pour la vidéo à large bande passante. Si le système d’un utilisateur n’est pas assez puissant, il lui sera peut-être difficile de lire la vidéo avec un tel filtre activé.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:smoothing:get"><apiName>smoothing</apiName><shortdesc>
     Indique si la vidéo doit être lissée (interpolée) lors de son redimensionnement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.smoothing, smoothing
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si la vidéo doit être lissée (interpolée) lors de son redimensionnement. Pour faciliter le lissage, le lecteur doit être en mode haute qualité. La valeur par défaut est <codeph>false</codeph> (pas de lissage).
     <p>Pour une lecture vidéo avec Flash Player 9.0.115.0 et versions ultérieures, définissez cette propriété sur <codeph>true</codeph> pour tirer parti de l’optimisation d’image mip-mapping.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:videoHeight:get"><apiName>videoHeight</apiName><shortdesc>
      Nombre entier spécifiant la hauteur en pixels du flux vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.height, height
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      Nombre entier spécifiant la hauteur en pixels du flux vidéo. Pour les flux vidéo en direct, cette valeur est identique à la propriété <codeph>Camera.height</codeph> de l’objet Camera qui capture le flux vidéo. Pour les fichiers FLV, elle correspond à la hauteur du fichier exporté au format FLV.
     <p>Vous pouvez utiliser cette propriété, par exemple, pour garantir que l’utilisateur regarde la vidéo au même format que celui auquel elle a été capturée, quel que soit le format réel de l’objet Video sur la scène.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/height"><linktext>flash.media.Camera.height</linktext></link></related-links></apiValue><apiValue id="flash.media:Video:videoWidth:get"><apiName>videoWidth</apiName><shortdesc>
      Nombre entier spécifiant la largeur en pixels du flux vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.width, width
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      Nombre entier spécifiant la largeur en pixels du flux vidéo. Pour les flux vidéo en direct, cette valeur est identique à la propriété <codeph>Camera.width</codeph> de l’objet Camera qui capture le flux vidéo. Pour les fichiers FLV, elle correspond à la largeur du fichier exporté au format FLV.
     <p>Vous pouvez utiliser cette propriété, par exemple, pour garantir que l’utilisateur regarde la vidéo au même format que celui auquel elle a été capturée, quel que soit le format réel de l’objet Video sur la scène.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>flash.media.Camera.width</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundMixer"><apiName>SoundMixer</apiName><shortdesc>
La classe SoundMixer contient des propriétés et des méthodes statiques permettant de contrôler globalement le son dans l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe SoundMixer contient des propriétés et des méthodes statiques permettant de contrôler globalement le son dans l’application. La classe SoundMixer contrôle les sons en flux continu intégrés dans l’application. elle ne contrôle pas dynamiquement les sons créés (c’est-à-dire les sons générés en réponse à un objet Sound qui distribue un événement <codeph>sampleData</codeph>).

</apiDesc></apiClassifierDetail><apiOperation id="flash.media:SoundMixer:areSoundsInaccessible"><apiName>areSoundsInaccessible</apiName><shortdesc> 
     Détermine si des sons sont inaccessibles en raison de restrictions de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Représentation de la chaîne de la valeur booléenne.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc> 
     Détermine si des sons sont inaccessibles en raison de restrictions de sécurité. Par exemple, un son chargé à partir d’un domaine différent de celui du contenu appelant cette méthode est inaccessible si le serveur du son ne possède pas de fichier de régulation d’URL autorisant l’accès au domaine de ce domaine. Le son peut cependant être chargé et lu, mais les opérations de bas niveau, telles que l’extraction de métadonnées ID3 pour le son, ne peuvent pas être exécutées sur des sons inaccessibles.
     
     <p>Pour le contenu d’une application AIR dans le sandbox de sécurité de l’application, l’appel à cette méthode renvoie toujours <codeph>false</codeph>. Tous les sons, y compris ceux chargés d’autres domaines, sont accessibles au contenu dans le sandbox de sécurité de l’application.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>computeSpectrum()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:computeSpectrum"><apiName>computeSpectrum</apiName><shortdesc>
     Génère un instantané de l’onde sonore actuelle et le place dans l’objet ByteArray spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should confirm if the floating point numbers are single- or double-precision.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>outputArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray qui contient les valeurs associées au son. Si certains sons ne sont pas disponibles en raison des restrictions de sécurité (<codeph>areSoundsInaccessible == true</codeph>), l’objet <codeph>outputArray</codeph> ne subit aucune modification. Si tous les sons sont arrêtés, l’objet <codeph>outputArray</codeph> est rempli de zéros.
     
     </apiDesc></apiParam><apiParam><apiItemName>FFTMode</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Valeur booléenne indiquant si les données audio sont d’abord soumises à une transformation de Fourier. Lorsque ce paramètre correspond à <codeph>true</codeph>, la méthode renvoie un spectre de fréquences, plutôt que l’onde sonore brute. Dans le spectre de fréquences, les basses fréquences sont représentées sur la gauche et les hautes fréquences sur la droite.
     
     </apiDesc></apiParam><apiParam><apiItemName>stretchFactor</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Résolution des échantillons audio. Si vous réglez la valeur <codeph>stretchFactor</codeph> sur 0, les données sont échantillonnées à 44,1 KHz. Réglez-la sur 1 et elles sont échantillonnées à 22,05 KHz ; sur 2 et elles sont échantillonnées à 11,025 KHz, etc.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Génère un instantané de l’onde sonore actuelle et le place dans l’objet ByteArray spécifié. Les valeurs sont mises en forme comme des valeurs à virgule flottante normalisées allant de -1,0 à 1,0. L’objet ByteArray transmis au paramètre <codeph>outputArray</codeph> est remplacé par de nouvelles valeurs. La taille de l’objet ByteArray créé est fixée à 512 valeurs à virgule flottante, les 256 premières représentant le canal gauche et les autres le canal droit.
     
     <p><b>Remarque </b>: cette méthode est soumise aux restrictions relatives à la sécurité des fichiers locaux et aux restrictions concernant le chargement interdomaines. Si vous utilisez des fichiers locaux ou des sons chargés à partir d’un serveur appartenant à un autre domaine que le contenu appelant, vous devez peut-être contourner les restrictions liées au sandbox par le biais d’un fichier de régulation interdomaines. Pour plus d’informations, voir la description de la classe Sound. En outre, cette méthode ne permet pas d’extraire des données de flux RTMP, même si elle est appelée par un contenu résidant dans le même domaine que le serveur RTMP.</p>
     
     
     <p>Cette méthode est prise en charge sur RTMP dans Flash Player 9.0.115.0 et versions ultérieures, ainsi que dans Adobe AIR. Vous pouvez contrôler l’accès aux flux sur un serveur FMS (Flash Media Server) dans un script coté serveur. Pour plus de détails, voir les propriétés <codeph>Client.audioSampleAccess</codeph> et <codeph>Client.videoSampleAccess</codeph> dans le <xref href="http://www.adobe.com/go/documentation_fr" scope="external"><i> Guide de référence du langage ActionScript d’Adobe Flash Media Server côté serveur</i></xref>.</p>
     
     </apiDesc><example conref="examples\SoundMixer_computeSpectrumExample.as"> Dans l’exemple suivant, la méthode <codeph>computeSpectrum()</codeph> est utilisée pour produire une représentation graphique des données d’ondes acoustiques. 
 
 <p>Dans le constructeur, un fichier audio est chargé et défini sur lecture (il n’y a pas de gestion d’erreur dans cet exemple, et le fichier audio est supposé être dans le même répertoire que le fichier SWF). Cet exemple est à l’écoute de l’événement <codeph>Event.ENTER_FRAME</codeph> pendant la lecture du son, ce qui déclenche de façon répétée la méthode <codeph>onEnterFrame()</codeph> pour le traçage du graphique des valeurs de données audio. Lorsque la lecture d’un son est terminée, la méthode <codeph>onPlaybackComplete()</codeph> arrête le processus de dessin en supprimant l’écouteur de l’événement <codeph>Event.ENTER_FRAME</codeph>.</p>
 
 <p>Dans la méthode <codeph>onEnterFrame()</codeph>, la méthode <codeph>computeSpectrum()</codeph> stocke le son brut dans l’objet tableau d’octets <codeph>bytes</codeph>. Les données sont échantillonnées à 44,1 KHz. Le tableau d’octets contient 512 octets de données, chacun contenant une valeur à virgule flottante comprise entre -1 et 1. Les 256 premières valeurs représentent le canal gauche et les autres le canal droit. La première boucle for lit les 256 premières valeurs (canal stéréo gauche ) et trace chaque fois une ligne d’un point à l’autre via la méthode <codeph>Graphics.lineTo()</codeph> (l’affichage du graphique vectoriel de l’onde acoustique est directement écrit dans l’objet Sprite de la classe). Les octets du son sont lus sous forme de nombre à virgule flottante 32 bits dans le flux d’octets et multipliés par la hauteur du point pour autoriser la plage verticale du graphique. La largeur est définie sur le double de la longueur du canal. La seconde boucle for lit les 256 valeurs suivantes (canal stéréo droit) et trace les lignes en ordre inverse. Les méthodes <codeph>g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);</codeph> et <codeph>g.lineTo(0, PLOT_HEIGHT);</codeph> tracent la base des ondes. Le dessin de la courbe audio qui en résulte produit un effet miroir.</p>  

<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.net.URLRequest;
    import flash.utils.ByteArray;
    import flash.text.TextField;

    public class SoundMixer_computeSpectrumExample extends Sprite {

        public function SoundMixer_computeSpectrumExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("Song1.mp3");
            snd.load(req);
            
            var channel:SoundChannel;
            channel = snd.play();
            addEventListener(Event.ENTER_FRAME, onEnterFrame);
            channel.addEventListener(Event.SOUND_COMPLETE, onPlaybackComplete);
        }

        private function onEnterFrame(event:Event):void {
            var bytes:ByteArray = new ByteArray();
            const PLOT_HEIGHT:int = 200;
            const CHANNEL_LENGTH:int = 256;

            SoundMixer.computeSpectrum(bytes, false, 0);
            
            var g:Graphics = this.graphics;
            
            g.clear();
       
            g.lineStyle(0, 0x6600CC);
            g.beginFill(0x6600CC);
            g.moveTo(0, PLOT_HEIGHT);
            
            var n:Number = 0;
            
            for (var i:int = 0; i &lt; CHANNEL_LENGTH; i++) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }

            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            g.endFill();
 
            g.lineStyle(0, 0xCC0066);
            g.beginFill(0xCC0066, 0.5);
            g.moveTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            
            for (i = CHANNEL_LENGTH; i > 0; i--) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }
  
            g.lineTo(0, PLOT_HEIGHT);
            g.endFill();
        }
        
        private function onPlaybackComplete(event:Event):void {
            removeEventListener(Event.ENTER_FRAME, onEnterFrame);
        }
    }
}

</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/areSoundsInaccessible()"><linktext>areSoundsInaccessible()</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.media.xml#Sound"><linktext>flash.media.Sound</linktext></link><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>flash.media.SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:stopAll"><apiName>stopAll</apiName><shortdesc>
     Arrête tout son en cours de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Arrête tout son en cours de lecture. 
     
     <p product="flash">Cette méthode n’arrête pas la tête de lecture. Les sons diffusés en continu sont émis de nouveau lorsque la tête de lecture passe au-dessus des images les contenant.</p>
     
     <p platform="actionscript">Pour utiliser cette propriété, tenez compte du modèle de sécurité suivant :</p>
     
     <ul platform="actionscript">
     
     <li> Par défaut, l’appel de la méthode <codeph>SoundMixer.stopAll()</codeph> arrête uniquement les sons se trouvant dans le même sandbox de sécurité que l’objet qui appelle la méthode. Les sons dont la lecture n’a pas été lancée à partir du sandbox de l’objet appelant ne sont pas arrêtés.</li>
     
     <li>Lorsque vous chargez le son à l’aide de la méthode <codeph>load()</codeph> de la classe Sound, vous pouvez spécifier un paramètre <codeph>context</codeph> qui est un objet SoundLoaderContext. Si vous réglez la propriété <codeph>checkPolicyFile</codeph> de l’objet SoundLoaderContext sur <codeph>true</codeph>, <ph platform="actionscript">Flash Player ou </ph>Adobe AIR recherche un fichier de régulation interdomaines sur le serveur à partir duquel le son est chargé. Si le serveur dispose d’un fichier de régulation interdomaines qui autorise le domaine du contenu appelant, ce fichier peut arrêter le son chargé par le biais de la méthode <codeph>SoundMixer.stopAll()</codeph> ; dans le cas contraire, il ne peut pas l’arrêter.</li>
     
     </ul>
     
     <p platform="actionscript">Cependant, dans Adobe AIR, le contenu du sandbox de sécurité de l’<codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas restreint par ces limites de sécurité.</p>
     
     <p platform="actionscript">Pour plus d’informations, voir les références suivantes :</p>
     
     <ul platform="actionscript">
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\SoundMixer_stopAllExample.as"> Dans l’exemple suivant, la méthode <codeph>stopAll()</codeph> est utilisée pour désactiver deux sons lus en même temps. 
 
 <p>Dans le constructeur, deux fichiers audio différents sont chargés et définis sur la lecture. Le premier est chargé localement et attribué à un canal audio (ce fichier est supposé être dans le même répertoire que le fichier SWF). Le second fichier est chargé et diffusé en continu depuis le site d’Adobe. Pour utiliser la méthode <codeph>SoundMixer.stopAll()</codeph>, tous les sons doivent être accessibles (un objet SoundLoaderContext peut être utilisé pour rechercher le fichier de régulation interdomaines). Chaque son doit également posséder un écouteur d’événement invoqué lorsqu’une erreur d’E/S survient lors du chargement du fichier audio. Un champ de texte <codeph>muteButton</codeph> est également créé. Il est à l’écoute d’un clic de souris, qui invoque la méthode <codeph>muteButtonClickHandler()</codeph>.</p>
 
 <p>Dans la méthode <codeph>muteButtonClickHandler()</codeph>, si le contenu du champ de texte est « MUTE », la méthode <codeph>areSoundsInaccessible()</codeph> vérifie que le mélangeur de sons a accès aux fichiers. Si les fichiers sont accessibles, la méthode <codeph>stopAll()</codeph> interrompt les sons. En cas de nouveau clic sur le champ de texte, la lecture du premier son commence et le contenu du champ de texte redevient « MUTE ». Cette fois la méthode <codeph>stopAll()</codeph> désactive le son en cours de lecture. Notez que la méthode <codeph>stop()</codeph> du canal audio peut également être utilisée pour arrêter un son spécifique attribué au canal (pour utiliser la fonctionnalité du canal, le son doit être réaffecté à ce canal à chaque appel de la méthode <codeph>play()</codeph>).</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.events.IOErrorEvent;

    public class SoundMixer_stopAllExample extends Sprite  {
        private var firstSound:Sound = new Sound();
        private var secondSound:Sound = new Sound();
        private var muteButton:TextField = new TextField();
        private var channel1:SoundChannel = new SoundChannel();
        
        public function SoundMixer_stopAllExample() {
            firstSound.load(new URLRequest("mySound.mp3"));
            secondSound.load(new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3"));

            firstSound.addEventListener(IOErrorEvent.IO_ERROR, firstSoundErrorHandler);
            secondSound.addEventListener(IOErrorEvent.IO_ERROR, secondSoundErrorHandler);
            
            channel1 = firstSound.play();
            secondSound.play();
            
            muteButton.autoSize = TextFieldAutoSize.LEFT;
            muteButton.border = true;
            muteButton.background = true;
            muteButton.text = "MUTE";
        
            muteButton.addEventListener(MouseEvent.CLICK, muteButtonClickHandler);         
        
            this.addChild(muteButton);
        }

        private function muteButtonClickHandler(event:MouseEvent):void {

            if(muteButton.text == "MUTE") {        
  
                if(SoundMixer.areSoundsInaccessible() == false) {
                    SoundMixer.stopAll();
                    muteButton.text = "click to play only one of sound.";
                }
                else {
                    muteButton.text = "The sounds are not accessible.";
                }
            }
           else {
                firstSound.play();        
                muteButton.text = "MUTE";
           }
        } 

        private function firstSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }

        private function secondSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundMixer:bufferTime:get"><apiName>bufferTime</apiName><shortdesc>
     Durée, en secondes, de préchargement dans une mémoire tampon d’un son en flux continu imbriqué avant que la diffusion en continu ne commence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Durée, en secondes, de préchargement dans une mémoire tampon d’un son en flux continu imbriqué avant que la diffusion en continu ne commence. Les données d’un son chargé, y compris sa durée de préchargement en mémoire tampon, ne sont pas accessibles par un fichier SWF appartenant à un autre domaine, sauf si vous mettez en place un fichier de régulation interdomaines. Pour plus d’informations sur la sécurité et le son, voir la description de la classe Sound. au flux. <ph platform="actionscript">Les données d’un son chargé, y compris sa durée de préchargement en mémoire tampon, ne sont pas accessibles par le code d’un fichier appartenant à un autre domaine, sauf si vous mettez en place un fichier de régulation interdomaines. Néanmoins, dans le sandbox d’application d’une application AIR, le code peut accéder aux données dans des fichiers de son à partir de n’importe quelle source. Pour plus d’informations sur la sécurité et le son, voir la description de la classe Sound.</ph> 
     
     <p>La propriété <codeph>SoundMixer.bufferTime</codeph> affecte uniquement la durée de mise en mémoire tampon des sons en flux continu imbriqués dans un fichier SWF. Elle n’a aucune incidence sur les objets Sound créés dynamiquement (autrement dit, créés dans ActionScript). La valeur de <codeph>SoundMixer.bufferTime</codeph> ne peut pas remplacer ni définir la durée de mise en mémoire tampon par défaut spécifiée dans l’objet SoundLoaderContext qui est transmis à la méthode <codeph>Sound.load()</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link></related-links></apiValue><apiValue id="flash.media:SoundMixer:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
     Objet SoundTransform contrôlant les propriétés audio globales.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
     Objet SoundTransform contrôlant les propriétés audio globales. Un objet SoundTransform comprend les propriétés de réglage du volume, du déplacement panoramique, ainsi que des haut-parleurs gauche et droit. L’objet SoundTransform utilisé dans cette propriété fournit des paramètres audio finaux qui sont appliqués à la totalité des sons après l’application de paramètres audio individuels.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier></apiPackage>