<?xml version="1.0"?>
<apiPackage id="flash.net"><apiName>flash.net</apiName><apiDetail/><apiClassifier id="flash.net:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
 
 La classe XMLSocket implémente les sockets client qui permettent à Flash Player ou à l’application AIR de communiquer avec un ordinateur serveur identifié par une adresse IP ou un nom de domaine.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLsocket, XMLsocket object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 La classe XMLSocket implémente les sockets client qui permettent à <ph platform="actionscript">Flash Player ou </ph>à l’application AIR de communiquer avec un ordinateur serveur identifié par une adresse IP ou un nom de domaine. La classe XMLSocket est utile pour les applications clients/serveur qui requièrent un court délai, telles que des systèmes de dialogue en ligne en temps réel. Une solution de dialogue en ligne par HTTP classique interroge fréquemment le serveur et télécharge les nouveaux messages à l’aide d’une requête HTTP. Par contraste, une solution de dialogue en ligne XMLSocket maintient une connexion ouverte avec le serveur, permettant à celui-ci d’envoyer immédiatement les messages entrants sans requête du client. Pour utiliser la classe XMLSocket, l’ordinateur serveur doit exécuter un démon capable de lire le protocole utilisé par la classe XMLSocket. Le protocole est décrit dans la liste suivante : 
 <ul>
   <li>Les messages XML sont envoyés via une connexion socket à flux TCP/IP bidirectionnel simultané.</li>
   <li>Chaque message XML est un document XML complet, terminé par un octet nul (0).</li>
   <li>Un nombre illimité de messages XML peut être envoyé et reçu via une connexion XMLSocket.</li>
 </ul>
 
 <p>La configuration d’un serveur en vue de la communication avec un objet XMLSocket peut être difficile à réaliser. Si votre application ne requiert pas d’interactivité en temps réel, utilisez la classe URLLoader, plutôt que la classe XMLSocket. </p>
 
 <p>Pour utiliser les méthodes de la classe XMLSocket, utilisez tout d’abord le constructeur, <codeph>new XMLSocket</codeph>, pour créer un objet XMLSocket.</p>
 
 <p>Les fichiers SWF du sandbox local avec système de fichiers peuvent ne pas utiliser de sockets.</p>
      
  <p> Les <i>fichiers de régulation de socket</i> situés sur l’hôte cible spécifient les hôtes à partir desquels les fichiers SWF peuvent établir des connexions de socket et les ports sur lesquels ces connexions peuvent être établies. Les exigences de sécurité relatives aux fichiers de régulation de socket sont devenues plus rigoureuses avec les dernières versions de Flash Player. Dans toutes les versions de Flash Player, Adobe recommande d’utiliser un fichier de régulation de socket ; dans certains cas, un tel fichier est même obligatoire. Ainsi, si vous utilisez des objets XMLSocket, assurez-vous que l’hôte cible fournisse au besoin un fichier de régulation de socket. </p>
 
  <p>Voici une liste résumant les exigences relatives aux fichiers de régulation de socket dans les différentes versions de Flash Player :</p>
 
  <ul>
  
   <li> Dans Flash Player 9.0.124.0 et versions ultérieures, un fichier de régulation de socket est obligatoire pour toutes les connexions XMLSocket. Cela signifie qu’un fichier de régulation de socket doit obligatoirement se trouver sur l’hôte cible, quel que soit le port sur lequel s’établit la connexion, et est obligatoire même si vous vous connectez à un port situé sur l’hôte servant le fichier SWF. </li>
 
   <li> Dans Flash Player versions 9.0.115.0 et ultérieures, si vous souhaitez vous connecter à un numéro de port inférieur à 1024, ou à un hôte autre que celui qui sert le fichier SWF, un fichier de régulation de socket est obligatoire sur l’hôte cible. </li>
 
  <li> Dans Flash Player 9.0.115.0, même si le fichier de régulation de socket n’est pas obligatoire, l’utilisation du débogueur de Flash Player entraîne l’affichage d’un avertissement si l’hôte cible ne fournit pas de fichier de régulation de socket. </li>
 
  </ul>
 
 <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
 
 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
 
 <ul>
 
 <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\XMLSocketExample.as"> L’exemple suivant utilise la classe XMLSocketExample pour envoyer des données à l’aide d’un XMLSocket et imprimer des informations pendant des événements XMLSocket. Pour ce faire, exécutez la procédure suivante :
 <ol>
  <li>Le constructeur XMLSocketExample crée une occurrence de XMLSocket nommée <codeph>socket</codeph> et transmet le <codeph>socket</codeph> à la méthode <codeph>ConfigureListeners()</codeph> (décrite ci-dessous), puis appelle la méthode <codeph>connect()</codeph> de XMLSocket avec le nom d’hôte « localhost » et le numéro de port <codeph>8080</codeph>.</li>
  <li>La méthode <codeph>configureListeners()</codeph> est ensuite appelée, ce qui ajoute des écouteurs à chacun des événements XMLSocket pris en charge :
  <ul>
      <li><codeph>closeHandler()</codeph> : écoute l’événement <codeph>close</codeph>, qui est distribué après la fermeture de la connexion réseau.</li>
      <li><codeph>connectHandler()</codeph> : écoute l’événement <codeph>connect</codeph>, qui est distribué à l’ouverture de la connexion réseau.</li>
      <li><codeph>dataHandler()</codeph> : écoute l’événement <codeph>data</codeph>, qui est distribué chaque fois que le XMLSocket reçoit de nouvelles données.</li>
      <li><codeph>progressHandler()</codeph> : écoute l’événement <codeph>progress</codeph>, qui est distribué à chaque appel de la méthode <codeph>send()</codeph> et pendant l’envoi.</li>
      <li><codeph>securityErrorHandler()</codeph> : écoute l’événement <codeph>securityError</codeph>, qui est distribué en cas de tentative d’accès au XMLSocket avec un paramètre de sécurité de lecture locale incorrect ou avec un numéro de port inférieur à 1024.</li>  
      <li><codeph>ioErrorHandler()</codeph> : écoute l’événement <codeph>ioError</codeph>, qui se produit uniquement en cas d’échec d’une opération d’envoi ou de réception de données.</li>  
  </ul></li>
 </ol>
 <p><b>Remarques :</b>
 <ul>
  <li>Vous devrez compiler le fichier SWF en définissant « Sécurité de lecture locale » sur « Accès au réseau uniquement ».</li>
  <li>Pour que cet exemple fonctionne, vous devez disposer d’un serveur s’exécutant sur votre domaine à l’aide du port 8080.</li>
  <li>Si vous exécutez Flash Player 9.0.124.0 ou une version ultérieure, vous devez placer sur votre serveur un fichier de régulation de socket autorisant les connexions de socket de votre domaine au port 8080. Pour plus d’informations sur la fourniture de fichiers de régulation de socket, voir la rubrique : <xref href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html" scope="external"> Configuration d’un serveur de fichier de régulation de socket</xref> du Centre des développeurs de Flash Player.</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.XMLSocket;

    public class XMLSocketExample extends Sprite {
        private var hostName:String = "localhost";
        private var port:uint = 8080;
        private var socket:XMLSocket;

        public function XMLSocketExample() {
            socket = new XMLSocket();
            configureListeners(socket);
            if (hostName &amp;&amp; port) {
                socket.connect(hostName, port);
            }
        }

        public function send(data:Object):void {
            socket.send(data);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CLOSE, closeHandler);
            dispatcher.addEventListener(Event.CONNECT, connectHandler);
            dispatcher.addEventListener(DataEvent.DATA, dataHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function closeHandler(event:Event):void {
            trace("closeHandler: " + event);
        }

        private function connectHandler(event:Event):void {
            trace("connectHandler: " + event);
        }

        private function dataHandler(event:DataEvent):void {
            trace("dataHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>flash.net.URLLoader.load()</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué si un appel de la méthode Socket.connect() tente une connexion à un serveur situé hors du sandbox de sécurité de l’appelant ou à un port inférieur à 1024.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>XMLSocket.connect()</codeph> tente une connexion à un serveur situé hors du sandbox de sécurité de l’appelant ou à un port inférieur à 1024.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>XMLSocket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’une opération d’envoi ou de réception.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’une opération d’envoi ou de réception. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.DataEvent.DATA_data"><apiName>data</apiName><shortdesc>
 Distribué après l’envoi ou la réception de données brutes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué après l’envoi ou la réception de données brutes.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 Distribué après un appel de la méthode XMLSocket.connect() qui a abouti.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué après un appel de la méthode <codeph>XMLSocket.connect()</codeph> qui a abouti.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Distribué lorsque le serveur ferme la connexion socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque le serveur ferme la connexion socket. L’événement <codeph>close</codeph> se produit uniquement lorsque le serveur ferme la connexion. Il n’est pas distribué lorsque vous appelez la méthode <codeph>XMLSocket.close()</codeph>.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:XMLSocket:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
    Crée un objet XMLSocket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de domaine DNS complet ou adresse IP au format <i>222.333.444</i>. Dans Flash Player 9.0.115.0 et AIR 1.0 et les versions ultérieures, vous pouvez spécifier les adresses IPv6, telles que rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. Vous pouvez également spécifier <codeph>null</codeph> pour vous connecter au serveur hôte qui héberge le fichier SWF. Si le fichier SWF effectuant cet appel s’exécute dans un navigateur Web, <codeph>host</codeph> doit appartenir au même domaine que le fichier SWF.
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Numéro du port TCP utilisé sur l’hôte cible pour établir une connexion. Dans Flash Player 9.0.124.0 et les versions ultérieures, l’hôte cible doit fournir un fichier de régulation de socket spécifiant que les connexions de socket sont autorisées depuis l’hôte fournissant le fichier SWF vers le port spécifié. Dans les versions précédentes de Flash Player, le fichier de régulation de socket n’est obligatoire que si vous souhaitez vous connecter à un numéro de port inférieur à 1024 ou à un hôte autre que celui servant le fichier SWF.
    
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Crée un objet XMLSocket. En l’absence de paramètres, un socket initialement déconnecté est créé. Si des paramètres sont spécifiés, une tentative de connexion à l’hôte et au port indiqués est effectuée.
    
    <p><b>Remarque :</b> il est fortement conseillé d’utiliser la forme du constructeur <b>sans paramètre</b>, d’ajouter ensuite des écouteurs d’événement éventuels, puis d’appeler la méthode <codeph>connect</codeph> avec les paramètres <codeph>host</codeph> et <codeph>port</codeph>. Cette séquence garantit que tous les écouteurs d’événement fonctionnent correctement.</p>
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:XMLSocket:close"><apiName>close</apiName><shortdesc>
     Ferme la connexion spécifiée par l’objet XMLSocket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.close, close
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Ferme la connexion spécifiée par l’objet XMLSocket. L’événement <codeph>close</codeph> se produit uniquement lorsque le serveur ferme la connexion. Il n’est pas distribué lorsque vous appelez la méthode <codeph>close()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:XMLSocket:connect"><apiName>connect</apiName><shortdesc>
     Etablit une connexion à l’hôte Internet spécifié en utilisant le port TCP indiqué.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.connect, connect
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les fichiers non approuvés au niveau local ne peuvent pas communiquer avec Internet. Pour contourner cette restriction, reclassifiez le fichier en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Il est impossible de spécifier un port de socket supérieur à 65535.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de domaine DNS complet ou adresse IP au format <i>111.222.333.444</i>. Vous pouvez également spécifier <codeph>null</codeph> pour vous connecter au serveur hôte qui héberge le fichier SWF. Si le fichier appelant est un fichier SWF s’exécutant dans un navigateur Web, <codeph>host</codeph> doit appartenir au même domaine que le fichier.
     
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Numéro du port TCP utilisé sur l’hôte cible pour établir une connexion. Dans Flash Player 9.0.124.0 et les versions ultérieures, l’hôte cible doit fournir un fichier de régulation de socket spécifiant que les connexions de socket sont autorisées depuis l’hôte fournissant le fichier SWF vers le port spécifié. Dans les versions précédentes de Flash Player, le fichier de régulation de socket n’est obligatoire que si vous souhaitez vous connecter à un numéro de port inférieur à 1024 ou à un hôte autre que celui servant le fichier SWF.
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Etablit une connexion à l’hôte Internet spécifié à l’aide du port TCP indiqué.
     
     <p>Si vous spécifiez <codeph>null</codeph> pour le paramètre <codeph>host</codeph>, l’hôte contacté est celui où réside le fichier appelant la méthode <codeph>XMLSocket.connect()</codeph>. Par exemple, si le fichier appelant a été téléchargé à partir du site www.adobe.com, le fait de spécifier <codeph>null</codeph> pour le paramètre host équivaut à se connecter à www.adobe.com.</p>
     
     
     <p platform="actionscript">Vous pouvez empêcher un fichier d’utiliser cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui comporte le contenu SWF.</p>
     
     <p>Pour plus d’informations, voir les références suivantes :</p>
	 
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/CONNECT"><linktext>flash.events.Event.CONNECT</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Une opération de connexion a tenté de se connecter à un hôte situé hors du sandbox de sécurité de l’appelant ou à un port qui nécessite un fichier de régulation de socket. Pour contourner ces problèmes, utilisez un fichier de régulation de socket sur l’hôte cible.
     </apiDesc></adobeApiEventDetail><shortdesc>Une opération de connexion a tenté de se connecter à un hôte situé hors du sandbox de sécurité de l’appelant ou à un port qui nécessite un fichier de régulation de socket.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_data"><apiName>data</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lors de la réception de données brutes.
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué à la réception de données brutes.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’une connexion réseau est établie. 
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’une connexion réseau est établie.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:XMLSocket:send"><apiName>send</apiName><shortdesc>
     Convertit l’objet ou les données XML spécifiés dans le paramètre object en une chaîne et la transmet au serveur, suivie d’un octet nul (0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.send, send
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’objet XMLSocket n’est pas connecté au serveur.
     
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Objet XML ou toute autre donnée à transmettre au serveur.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Convertit l’objet ou les données XML spécifiés dans le paramètre <codeph>object</codeph> en une chaîne et la transmet au serveur, suivie d’un octet nul (0). Si <codeph>object</codeph> est un objet XML, la chaîne est la représentation textuelle XML de l’objet XML. L’opération d’envoi est asynchrone ; elle est immédiatement renvoyée, mais les données peuvent être transmises plus tard. La méthode <codeph>XMLSocket.send()</codeph> ne renvoie pas de valeur indiquant si les données ont bien été transmises.
     
     <p>Si vous ne connectez pas l’objet XMLSocket au serveur à l’aide de <codeph>XMLSocket.connect()</codeph>, l’opération <codeph>XMLSocket.send()</codeph> échoue.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiValue id="flash.net:XMLSocket:connected:get"><apiName>connected</apiName><shortdesc>
     Indique si l’objet XMLSocket est actuellement connecté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’objet XMLSocket est actuellement connecté. Vous pouvez également vérifier si la connexion a abouti en vous enregistrant pour les événements <codeph>connect</codeph> et <codeph>ioError</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#XMLSocket/event:connect"><linktext>connect</linktext></link><link href="flash.net.xml#XMLSocket/event:ioError"><linktext>ioError</linktext></link></related-links></apiValue><apiValue id="flash.net:XMLSocket:timeout:set"><apiName>timeout</apiName><shortdesc>
     Indique le délai d’attente d’une connexion, en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Indique le délai d’attente d’une connexion, en millisecondes.
     
     <p>Si la connexion n’est pas établie pendant le délai spécifié, elle échoue. La valeur par défaut est de 20 000 (vingt secondes).</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:ObjectEncoding"><apiName>ObjectEncoding</apiName><shortdesc>
 La classe ObjectEncoding sert à définir les paramètres de sérialisation des classes qui sérialisent les objets (FileStream, NetStream, NetConnection, SharedObject et ByteArray) afin que celles-ci soient compatibles avec des versions antérieures d’ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>ObjectEncoding, ObjectEncoding object, built-in class, AMF, Action Message Format
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe ObjectEncoding sert à définir les paramètres de sérialisation des classes qui sérialisent les objets (FileStream, NetStream, NetConnection, SharedObject et ByteArray) afin que celles-ci soient compatibles avec des versions antérieures d’ActionScript. 
 
 <p>L’encodage d’objet détermine la manière dont les objets sont représentés au format AMF (Action Message Format). Flash Player utilise AMF pour améliorer l’efficacité des communications entre une application et un serveur distant. Le format AMF code les appels de procédure à distance dans un format binaire compact, qui peut être transféré via HTTP/HTTPS ou le protocole RTMP/RTMPS utilisé par Flash Media Server. Les objets et les valeurs de données sont sérialisés dans ce format binaire, qui est généralement plus compact que d’autres représentations, telles que XML.</p>
 
 <p>Adobe AIR et Flash Player 9 peuvent sérialiser dans deux formats différents : AMF3 et AMF0. AMF3, la sérialisation développée par défaut pour ActionScript 3.0, offre plusieurs avantages par rapport à AMF0, réservée à ActionScript 1.0 et 2.0. AMF3 envoie des données sur le réseau de manière plus efficace que AMF0. <ph platform="actionscript">AMF3 autorise l’envoi d’objets <codeph>int</codeph> et <codeph>uint</codeph> en tant qu’entiers et prend en charge des types de données, tels que ByteArray, XML, et IExternalizable, qui sont uniquement disponibles dans ActionScript 3.0. Ce format est uniquement disponible dans ActionScript 3.0 et avec les serveurs utilisant le codage AMF3, tels que Flex 2.</ph></p>
 
 <p>Les classes ByteArray, FileStream, NetConnection, NetStream, <ph platform="actionscript">SharedObject</ph>, Socket et URLStream contiennent la propriété <codeph>objectEncoding</codeph>, à laquelle une constante de la classe ObjectEncoding est affectée. Le comportement de la propriété <codeph>objectEncoding</codeph> varie en fonction de l’objet. La description de la propriété <codeph>objectEncoding</codeph> de chaque classe explique ce comportement en détail.</p>
 
 
 </apiDesc></apiClassifierDetail><apiValue id="flash.net:ObjectEncoding:AMF0"><apiName>AMF0</apiName><shortdesc>
	 Spécifie que les objets sont sérialisés à l’aide du format AMF (Action Message Format) utilisé par ActionScript 1.0 et 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie que les objets sont sérialisés à l’aide du format AMF (Action Message Format) utilisé par ActionScript 1.0 et 2.0.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:AMF3"><apiName>AMF3</apiName><shortdesc>
	 Spécifie que les objets sont sérialisés à l’aide du format AMF (Action Message Format) utilisé par ActionScript 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie que les objets sont sérialisés à l’aide du format AMF (Action Message Format) utilisé par ActionScript 3.0.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Spécifie le format par défaut (c’est-à-dire le plus récent) correspondant au moteur d’exécution actuellement utilisé (Flash&amp;#xAE; Player or Adobe&amp;#xAE; AIR&amp;#xAE;).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le format par défaut (c’est-à-dire le plus récent) correspondant au moteur d’exécution actuellement utilisé (Flash<sup>®</sup> Player ou Adobe<sup>®</sup> AIR<sup>®</sup>). Le contrôle de l’encodage d’objet étant uniquement disponible dans Flash Player 9 et les versions ultérieures, ainsi que dans Adobe AIR, le format AMF (Action Message Format) le plus récent utilisé est celui d’ActionScript 3.0.
	 
	 <p>Par exemple, si la propriété <codeph>objectEncoding</codeph> d’un objet est définie sur <codeph>ObjectEncoding.DEFAULT</codeph>, l’encodage AMF3 est utilisé. Si, à l’avenir, une version ultérieure de Flash Player ou d’Adobe AIR propose une nouvelle version d’AMF et que vous republiez votre contenu, l’application utilisera cette nouvelle version. Faites appel à cette constante uniquement si l’interopérabilité avec les versions antérieures n’a aucune importance.</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:dynamicPropertyWriter:get"><apiName>dynamicPropertyWriter</apiName><shortdesc>
	 Assure une meilleure maîtrise de la sérialisation des propriétés dynamiques des objets dynamiques.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.net:IDynamicPropertyWriter</apiValueClassifier></apiValueDef><apiDesc>
	 Assure une meilleure maîtrise de la sérialisation des propriétés dynamiques des objets dynamiques. Lorsque cette propriété est réglée sur <codeph>null</codeph>, sa valeur par défaut, les propriétés dynamiques sont sérialisées à l’aide de code natif, qui les écrit toutes, à l’exception de celles dont la valeur est une fonction.
     <p>Cette valeur n’est appelée que pour les propriétés d’un objet dynamique (objets déclarés au sein d’une classe dynamique) ou pour des objets déclarés à l’aide de l’opérateur <codeph>new</codeph>.</p>
	 
	 <p platform="actionscript">Cette propriété vous permet d’exclure des propriétés d’objets dynamiques de la sérialisation, d’écrire des valeurs dans les propriétés dynamiques des objets dynamiques ou de créer des propriétés dynamiques pour des objets dynamiques. Pour ce faire, réglez-la sur un objet qui implémente l’interface IDynamicPropertyWriter. Pour plus d’informations, voir l’interface IDynamicPropertyWriter.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:Socket"><apiName>Socket</apiName><shortdesc>
 La classe Socket permet au code d’établir des connexions socket, ainsi que de lire et d’écrire des données binaires brutes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Socket permet au code d’établir des connexions socket, ainsi que de lire et d’écrire des données binaires brutes. Elle est similaire à XMLSocket, mais n’impose pas le format des données reçues ou transmises.
 
 <p>La classe Socket est utile si vous utilisez des serveurs faisant appel à des protocoles binaires.</p>
 
 <p>Pour utiliser les méthodes de la classe Socket, utilisez tout d’abord le constructeur, <codeph>new Socket</codeph>, pour créer un objet Socket.</p>
 
 <p>Les fichiers SWF du sandbox local avec système de fichiers peuvent ne pas utiliser de sockets.</p>
      
  <p> Les <i>fichiers de régulation de socket</i> situés sur l’hôte cible spécifient les hôtes à partir desquels les fichiers SWF peuvent établir des connexions de socket et les ports sur lesquels ces connexions peuvent être établies. Les exigences de sécurité relatives aux fichiers de régulation de socket sont devenues plus rigoureuses avec les dernières versions de Flash Player. Dans toutes les versions de Flash Player, Adobe recommande d’utiliser un fichier de régulation de socket ; dans certains cas, un tel fichier est même obligatoire. Ainsi, si vous utilisez des objets XMLSocket, assurez-vous que l’hôte cible fournisse au besoin un fichier de régulation de socket. </p>
 
  <p>Voici une liste résumant les exigences relatives aux fichiers de régulation de socket dans les différentes versions de Flash Player :</p>
 
  <ul>
  
   <li> Dans Flash Player 9.0.124.0 et les versions ultérieures, un fichier de régulation de socket est requis pour toutes les connexions Socket. Cela signifie qu’un fichier de régulation de socket doit obligatoirement se trouver sur l’hôte cible, quel que soit le port sur lequel s’établit la connexion, et est obligatoire même si vous vous connectez à un port situé sur l’hôte servant le fichier SWF. </li>
 
   <li> Dans Flash Player versions 9.0.115.0 et ultérieures, si vous souhaitez vous connecter à un numéro de port inférieur à 1024, ou à un hôte autre que celui qui sert le fichier SWF, un fichier de régulation de socket est obligatoire sur l’hôte cible. </li>
 
  <li> Dans Flash Player 9.0.115.0, même si le fichier de régulation de socket n’est pas obligatoire, l’utilisation du débogueur de Flash Player entraîne l’affichage d’un avertissement si l’hôte cible ne fournit pas de fichier de régulation de socket. </li>
 
  </ul>
 
 <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
  
 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
 
 <ul>
 
 <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\SocketExample.as"> L’exemple suivant écrit et lit dans un socket et produit des informations transmises pendant des événements de socket. Vous trouverez ci-dessous des extraits de l’exemple :
 <ol>
    <li>Le constructeur crée une occurrence de <codeph>CustomSocket</codeph> nommée <codeph>socket</codeph> et transmet le nom d’hôte <codeph>localhost</codeph> et le port 80 comme arguments. <codeph>CustomSocket</codeph> étendant Socket, un appel à la méthode <codeph>super()</codeph> invoque un constructeur de Socket.</li>
    <li>Cet exemple appelle ensuite la méthode <codeph>configureListeners()</codeph>, qui ajoute des écouteurs pour les événements de Socket.</li>
      <li>Enfin, la méthode de socket <codeph>connect()</codeph> est appelée avec <codeph>localhost</codeph> comme nom d’hôte et 80 comme numéro de port.</li>
 </ol>
 
 <p> <b>Remarque :</b> Pour exécuter l’exemple, vous avez besoin d’un serveur s’exécutant dans le domaine où réside le fichier SWF (dans l’exemple, <codeph>localhost</codeph>) et d’une écoute du port 80.</p>
<codeblock>

package {
    import flash.display.Sprite;

    public class SocketExample extends Sprite {

        public function SocketExample() {
            var socket:CustomSocket = new CustomSocket("localhost", 80);
        }
    }
}

import flash.errors.*;
import flash.events.*;
import flash.net.Socket;

class CustomSocket extends Socket {
    private var response:String;

    public function CustomSocket(host:String = null, port:uint = 0) {
        super();
        configureListeners();
        if (host &amp;&amp; port)  {
            super.connect(host, port);
        }
    }

    private function configureListeners():void {
        addEventListener(Event.CLOSE, closeHandler);
        addEventListener(Event.CONNECT, connectHandler);
        addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);
    }

    private function writeln(str:String):void {
        str += "\n";
        try {
            writeUTFBytes(str);
        }
        catch(e:IOError) {
            trace(e);
        }
    }

    private function sendRequest():void {
        trace("sendRequest");
        response = "";
        writeln("GET /");
        flush();
    }

    private function readResponse():void {
        var str:String = readUTFBytes(bytesAvailable);
        response += str;
    }

    private function closeHandler(event:Event):void {
        trace("closeHandler: " + event);
        trace(response.toString());
    }

    private function connectHandler(event:Event):void {
        trace("connectHandler: " + event);
        sendRequest();
    }

    private function ioErrorHandler(event:IOErrorEvent):void {
        trace("ioErrorHandler: " + event);
    }

    private function securityErrorHandler(event:SecurityErrorEvent):void {
        trace("securityErrorHandler: " + event);
    }

    private function socketDataHandler(event:ProgressEvent):void {
        trace("socketDataHandler: " + event);
        readResponse();
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.net:Socket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué si un appel de Socket.connect() tente une connexion à un serveur situé hors du sandbox de sécurité de l’appelant ou à un port inférieur à 1024.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS check this info
 </internal></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de <codeph>Socket.connect()</codeph> tente une connexion à un serveur situé hors du sandbox de sécurité de l’appelant ou à un port inférieur à 1024.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>Socket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.ProgressEvent.SOCKET_DATA_socketData"><apiName>socketData</apiName><shortdesc>
 Distribué lorsqu’un socket a reçu des données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.SOCKET_DATA</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un socket a reçu des données. Les événements de type <codeph>socketData</codeph> n’utilisent pas la propriété <codeph>ProgressEvent.bytesTotal</codeph>. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’un envoi ou d’un chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’un envoi ou d’un chargement. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 Distribué lorsqu’une connexion réseau est établie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une connexion réseau est établie. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Distribué lorsque le serveur ferme la connexion socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque le serveur ferme la connexion socket. L’événement <codeph>close</codeph> se produit uniquement lorsque le serveur ferme la connexion. Il n’est pas distribué lorsque vous appelez la méthode <codeph>Socket.close()</codeph>.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:Socket:Socket"><apiName>Socket</apiName><shortdesc>
    Crée un nouvel objet Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS determine if all above events are accurate, and which ones also apply
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Cette erreur se produit dans le contenu SWF<ph platform="javascript">.</ph><ph platform="actionscript"> pour les raisons suivantes :</ph>
	 
     <ul platform="actionscript">
       <li>Les fichiers locaux avec système de fichiers ne peuvent pas communiquer avec Internet. Pour contourner ce problème, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé. Le contenu de l’application AIR dans le sandbox de sécurité de l’application n’est pas soumis à cette restriction.</li>
	 
      <li>Il est impossible de spécifier un port de socket supérieur à 65535.</li>
    </ul>
	 
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de domaine DNS complet ou adresse IP au format <i>111.222.333.444</i>. Dans Flash Player 9.0.115.0 et AIR 1.0 et les versions ultérieures, vous pouvez spécifier les adresses IPv6, telles que rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. Vous pouvez également spécifier <codeph>null</codeph> pour vous connecter au serveur hôte qui héberge le fichier SWF. Si le fichier SWF effectuant cet appel s’exécute dans un navigateur Web, <codeph>host</codeph> doit appartenir au même domaine que le fichier SWF.
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Numéro du port TCP utilisé sur l’hôte cible pour établir une connexion. Dans Flash Player 9.0.124.0 et les versions ultérieures, l’hôte cible doit fournir un fichier de régulation de socket spécifiant que les connexions de socket sont autorisées depuis l’hôte fournissant le fichier SWF vers le port spécifié. Dans les versions précédentes de Flash Player, le fichier de régulation de socket n’est obligatoire que si vous souhaitez vous connecter à un numéro de port inférieur à 1024 ou à un hôte autre que celui servant le fichier SWF.
    
    
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Crée un nouvel objet Socket. En l’absence de paramètres, un socket initialement déconnecté est créé. Si des paramètres sont spécifiés, une tentative de connexion à l’hôte et au port indiqués est effectuée.
    
    <p><b>Remarque :</b> il est fortement conseillé d’utiliser la forme du constructeur <b>sans paramètre</b>, d’ajouter ensuite des écouteurs d’événement éventuels, puis d’appeler la méthode <codeph>connect</codeph> avec les paramètres <codeph>host</codeph> et <codeph>port</codeph>. Cette séquence garantit que tous les écouteurs d’événement fonctionnent correctement.</p>
    
    </apiDesc></apiConstructorDetail><adobeApiEvent id="flash.net:Socket:Socket_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’une connexion réseau est établie.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’une connexion réseau est établie.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec de la connexion.
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec de la connexion.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><ph platform="javascript">Cette erreur se produit dans le contenu SWF.</ph><ph platform="actionscript">Distribué si un appel à <codeph>Socket.connect()</codeph> tente de se connecter à un serveur qui ne fournit pas de fichier de régulation de socket ou à un serveur dont le fichier de régulation n’accorde pas à l’hôte appelant l’accès au port spécifié. Pour plus d’informations sur les fichiers de régulation de socket, voir « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</ph>
	 
    </apiDesc></adobeApiEventDetail><shortdesc>Cette erreur se produit dans le contenu SWF. Distribué si un appel à Socket.connect() tente de se connecter à un serveur qui ne fournit pas de fichier de régulation de socket, ou à un serveur dont le fichier de régulation n’accorde pas l’accès de l’hôte appelant au port spécifié.</shortdesc></adobeApiEvent></apiConstructor><apiOperation id="flash.net:Socket:close"><apiName>close</apiName><shortdesc>
     Ferme le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La fermeture du socket a été impossible ou il n’a pas été ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Ferme le socket. Après l’appel de la méthode <codeph>close()</codeph>, toute lecture ou écriture de données est impossible.
     
     <p>L’événement <codeph>close</codeph> se produit uniquement lorsque le serveur ferme la connexion. Il n’est pas distribué lorsque vous appelez la méthode <codeph>close()</codeph>.</p>
     
     <p>Vous pouvez réutiliser l’objet Socket en lui appliquant à nouveau la méthode <codeph>connect()</codeph>.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:connect"><apiName>connect</apiName><shortdesc>
     Connecte le socket à l’hôte et au port spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS compare this entire description with XMLSocket.connect() and make consistent
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Aucun hôte n’a été spécifié et la connexion a échoué.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur se produit dans le contenu SWF<ph platform="javascript">.</ph><ph platform="actionscript"> pour les raisons suivantes :</ph>
	 
          <ul platform="actionscript">
              <li>Les fichiers SWF locaux non approuvés ne peuvent pas communiquer avec Internet. Pour contourner cette restriction, reclassifiez le fichier en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.</li>
               <li>Il est impossible de spécifier un port de socket supérieur à 65535.</li>
           <li>Dans la page HTML qui héberge le contenu SWF, le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> est défini sur <codeph>"none"</codeph>.</li>
	 
          </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom ou adresse IP de l’hôte auquel la connexion doit être établie. Si aucun hôte n’est spécifié, l’hôte hébergeant le fichier appelant est contacté. Si vous ne spécifiez pas d’hôte, utilisez un écouteur d’événement pour déterminer si la connexion a abouti.
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Numéro du port auquel établir la connexion.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Connecte le socket à l’hôte et au port spécifiés. Si la connexion échoue immédiatement, un événement est distribué ou une exception est émise : un événement d’erreur est distribué si un hôte a été spécifié, et une exception est émise dans le cas contraire. Dans tous les autres cas, l’état de la connexion est signalé par un événement. Si le socket est déjà connecté, la connexion existante est d’abord fermée.
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:Socket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’une connexion réseau est établie.
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’une connexion réseau est établie.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué si un hôte est spécifié et s’il se produit une erreur d’entrée/sortie entraînant l’échec de la connexion.
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un hôte est spécifié et qu’il se produit une erreur d’entrée/sortie entraînant l’échec de la connexion.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué si un appel à <codeph>Socket.connect()</codeph> tente de se connecter à un serveur qui ne fournit pas de fichier de régulation de socket ou à un serveur dont le fichier de régulation n’accorde pas à l’hôte appelant l’accès au port spécifié. Pour plus d’informations, voir « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué si un appel à Socket.connect() tente de se connecter à un serveur qui ne fournit pas de fichier de régulation de socket, ou à un serveur dont le fichier de régulation n’accorde pas l’accès de l’hôte appelant au port spécifié.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:Socket:flush"><apiName>flush</apiName><shortdesc>
     Efface les données accumulées dans la mémoire tampon de sortie du socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.       
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Efface les données accumulées dans la mémoire tampon de sortie du socket. Les données écrites à l’aide des méthodes <codeph>write</codeph> ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     Lit une valeur booléenne dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur <codeph>true</codeph> si l’octet lu est non nul, <codeph>false</codeph> dans le cas contraire.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit une valeur booléenne dans le socket. Après la lecture d’un seul octet, la méthode renvoie <codeph>true</codeph> si l’octet est non nul, <codeph>false</codeph> dans le cas contraire.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readByte"><apiName>readByte</apiName><shortdesc>
     Lit un octet signé dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur comprise entre -128 et 127.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un octet signé dans le socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBytes"><apiName>readBytes</apiName><shortdesc>
     Lit dans le socket le nombre d’octets de données spécifié par le paramètre length.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray dont les données doivent être lues.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décalage à partir duquel la lecture des données doit commencer dans le tableau d’octets.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre d’octets à lire. La valeur 0 (par défaut) provoque la lecture de toutes les données disponibles.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit dans le socket le nombre d’octets de données spécifié par le paramètre <codeph>length</codeph>. Les octets sont lus dans le tableau d’octets spécifié, en partant de la position indiquée par <codeph>offset</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readDouble"><apiName>readDouble</apiName><shortdesc>
     Lit dans le socket un nombre à virgule flottante à deux décimales et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à deux décimales, conforme à IEEE 754.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit dans le socket un nombre à virgule flottante à deux décimales et conforme à IEEE 754.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readFloat"><apiName>readFloat</apiName><shortdesc>
     Lit dans le socket un nombre à virgule flottante à une décimale et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à une décimale, conforme à IEEE 754.
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit dans le socket un nombre à virgule flottante à une décimale et conforme à IEEE 754.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readInt"><apiName>readInt</apiName><shortdesc>
     Lit un entier de 32 bits signé dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur comprise entre -2147483648 et 2147483647.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier de 32 bits signé dans le socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     Lit une chaîne multi-octets dans le flux d’octets, en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne codée au format UTF-8.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire dans le flux d’octets.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne désignant le le jeu de caractères à utiliser pour interpréter les octets. Parmi les chaînes de jeu de caractères supportées figurent <codeph>shift_jis</codeph>, <codeph>CN-GB</codeph> et <codeph>iso-8859-1</codeph>. Pour obtenir la liste complète, voir <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>.
     
     <p><b>Remarque :</b> si la valeur du paramètre <codeph>charSet</codeph> n’est pas reconnue par le système actuel, l’application utilise la page de code par défaut du système comme jeu de caractères. Par exemple, une valeur pour le paramètre <codeph>charSet</codeph>, comme dans <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> qui utilise <codeph>01</codeph> au lieu de <codeph>1</codeph> pourra éventuellement fonctionner sur votre poste de développement, mais pas sur un autre poste. Sur l’autre ordinateur, l’application utilisera la page de code par défaut du système.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit une chaîne multi-octets dans le flux d’octets, en utilisant le jeu de caractères spécifié.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readObject"><apiName>readObject</apiName><shortdesc>
     Lit dans le socket un objet codé au format AMF (Action Message Format) sérialisé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet désérialisé
     
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     Lit dans le socket un objet codé au format AMF (Action Message Format) sérialisé.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:readShort"><apiName>readShort</apiName><shortdesc>
     Lit un entier de 16 bits signé dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur comprise entre -32768 et 32767.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier de 16 bits signé dans le socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTF"><apiName>readUTF</apiName><shortdesc>
     Lit une chaîne UTF-8 dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit une chaîne UTF-8 dans le socket. La chaîne est supposée comporter un préfixe composé d’un entier court non signé indiquant sa longueur en octets.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     Lit dans le socket le nombre d’octets de données UTF-8 spécifié par le paramètre length et renvoie une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit dans le socket le nombre d’octets de données UTF-8 spécifié par le paramètre <codeph>length</codeph> et renvoie une chaîne.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     Lit un octet non signé dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur comprise entre 0 et 255.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un octet non signé dans le socket.  
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     Lit un entier de 32 bits non signé dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur comprise entre 0 et 4294967295.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier de 32 bits non signé dans le socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     Lit un entier de 16 bits non signé dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur comprise entre 0 et 65535.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier de 16 bits non signé dans le socket.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
     Ecrit une valeur booléenne dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket : 1 (<codeph>true</codeph>) ou 0 (<codeph>false</codeph>).
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit une valeur booléenne dans le socket. Cette méthode écrit un seul octet, dont la valeur correspond à 1 (<codeph>true</codeph>) ou à 0 (<codeph>false</codeph>).
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeByte"><apiName>writeByte</apiName><shortdesc>
     Ecrit un octet dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket. Les 8 bits inférieurs de la valeur sont utilisés. Les 24 bits supérieurs ne sont pas pris en compte.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit un octet dans le socket.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeBytes"><apiName>writeBytes</apiName><shortdesc>
     Ecrit une séquence d’octets extraits du tableau d’octets spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray duquel extraire les données à écrire.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décalage, commençant à zéro, dans l’objet ByteArray <codeph>bytes</codeph> auquel l’écriture des données doit commencer.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre d’octets à écrire. La valeur par défaut, 0, entraîne l’écriture de l’intégralité de la mémoire tampon, en partant de la valeur spécifiée par le paramètre <codeph>offset</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit une séquence d’octets extraits du tableau d’octets spécifié. L’écriture commence à la position indiquée par <codeph>offset</codeph>.
     
     <p>Si vous omettez le paramètre <codeph>length</codeph>, la valeur par défaut, 0, est utilisée et la méthode écrit l’intégralité de la mémoire tampon, en commençant à <codeph>offset</codeph>.</p>
     
     <p>Si vous omettez aussi le paramètre <codeph>offset</codeph>, toute la mémoire tampon est écrite.</p> 
      
     <p>Si <codeph>offset</codeph> ou <codeph>length</codeph> ne sont pas compris dans la plage gérée, ils sont ajustés de sorte à correspondre au début et à fin du tableau d’octets (<codeph>bytes</codeph>).</p>
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeDouble"><apiName>writeDouble</apiName><shortdesc>
     Ecrit dans le socket un nombre à virgule flottante à deux décimales et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit dans le socket un nombre à virgule flottante à deux décimales et conforme à IEEE 754.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeFloat"><apiName>writeFloat</apiName><shortdesc>
     Ecrit dans le socket un nombre à virgule flottante à une décimale conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit dans le socket un nombre à virgule flottante à une décimale conforme à IEEE 754.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeInt"><apiName>writeInt</apiName><shortdesc>
     Ecrit un entier signé de 32 bits dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit un entier signé de 32 bits dans le socket.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
     Ecrit une chaîne multi-octets extraite du flux d’octets, en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.writeMultiByte, writeMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne désignant le le jeu de caractères à utiliser pour interpréter les octets. Parmi les chaînes de jeu de caractères supportées figurent <codeph>shift_jis</codeph>, <codeph>CN-GB</codeph> et <codeph>iso-8859-1</codeph>. Pour obtenir la liste complète, voir <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit une chaîne multi-octets extraite du flux d’octets, en utilisant le jeu de caractères spécifié.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeObject"><apiName>writeObject</apiName><shortdesc>
     Ecrit un objet dans le socket au format AMF sérialisé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Objet à sérialiser.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit un objet dans le socket au format AMF sérialisé.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeShort"><apiName>writeShort</apiName><shortdesc>
     Ecrit un entier 16 bits dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit un entier 16 bits dans le socket. Les octets écrits se présentent comme suit :
     
     <pre><codeph>(v >> 8) &amp; 0xff v &amp; 0xff</codeph></pre>
     
     <p>Les 16 bits inférieurs du paramètre sont utilisés. Les 16 bits supérieurs ne sont pas pris en compte.</p>
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTF"><apiName>writeUTF</apiName><shortdesc>
     Ecrit les données suivantes dans le socket : un entier non signé de 16 bits, qui indique, en octets, la longueur de la chaîne UTF-8 spécifiée, suivie de la chaîne elle-même.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La longueur est supérieure à 65535.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à écrire dans le socket.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit les données suivantes dans le socket : un entier non signé de 16 bits, qui indique, en octets, la longueur de la chaîne UTF-8 spécifiée, suivie de la chaîne elle-même.
     
     <p>Avant d’écrire la chaîne, la méthode calcule le nombre d’octets nécessaires pour représenter tous les caractères requis.</p>
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
     Ecrit une chaîne UTF-8 dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à écrire dans le socket.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit une chaîne UTF-8 dans le socket. 
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
     Ecrit un entier non signé de 32 bits dans le socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Une erreur d’E/S s’est produite dans le socket ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur à écrire dans le socket.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit un entier non signé de 32 bits dans le socket.
     
     <p><b>Remarque :</b> les données écrites au moyen de cette méthode ne sont pas transmises immédiatement. Elles sont mises en file d’attente jusqu’à l’appel de la méthode <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiValue id="flash.net:Socket:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     Nombre d’octets de données disponibles en lecture dans la mémoire tampon d’entrée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Nombre d’octets de données disponibles en lecture dans la mémoire tampon d’entrée.
     
     <p>Votre code doit accéder à <codeph>bytesAvailable</codeph> pour garantir que les données disponibles sont suffisantes, avant leur lecture à l’aide d’une des méthodes <codeph>read</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:connected:get"><apiName>connected</apiName><shortdesc>
     Indique si l’objet Socket est actuellement connecté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’objet Socket est actuellement connecté. Un appel de cette propriété renvoie la valeur <codeph>true</codeph> si le socket est connecté, <codeph>false</codeph> dans le cas contraire.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:endian:get"><apiName>endian</apiName><shortdesc>
     Indique l’ordre des octets des données ; les valeurs possibles sont des constantes de la classe flash.utils.Endian, Endian.BIG_ENDIAN ou Endian.LITTLE_ENDIAN.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     Indique l’ordre des octets des données ; les valeurs possibles sont des constantes de la classe flash.utils.Endian, <codeph>Endian.BIG_ENDIAN</codeph> ou <codeph>Endian.LITTLE_ENDIAN</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Contrôle la version du format AMF utilisée lors de l’écriture ou de la lecture d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Contrôle la version du format AMF utilisée lors de l’écriture ou de la lecture d’un objet.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>Classe ObjectEncoding</linktext></link><link href="flash.net.xml#Socket/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#Socket/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:timeout:set"><apiName>timeout</apiName><shortdesc>
     Indique le délai d’attente d’une connexion, en millisecondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Indique le délai d’attente d’une connexion, en millisecondes.
     
     <p>Si la connexion n’est pas établie pendant le délai spécifié, elle échoue. La valeur par défaut est de 20 000 (vingt secondes).</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoader"><apiName>URLLoader</apiName><shortdesc>
 La classe URLLoader télécharge des données à partir d’une URL sous forme de texte, de données binaires ou de variables de code URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe URLLoader télécharge des données à partir d’une URL sous forme de texte, de données binaires ou de variables de code URL. Elle est utile pour télécharger des fichiers texte, XML ou d’autres informations destinées à être utilisées dans une application de données dynamique.
 
 <p>Un objet URLLoader télécharge toutes les données d’une URL avant de les mettre à disposition du code dans les applications. Il fournit des notifications sur la progression du téléchargement, que vous pouvez connaître en surveillant les propriétés <codeph>bytesLoaded</codeph> et <codeph>bytesTotal</codeph>, ainsi que les événements distribués.</p>
 
 <p>Dans le cas de chargements de fichiers vidéo très volumineux, tels que des FLV, des erreurs de mémoire insuffisante peuvent se produire.
 </p>
 
 
 
 <p>Lorsque vous employez cette classe<ph platform="actionscript"> dans Flash Player et</ph> dans le contenu de l’application AIR d’un sandbox de sécurité autre que celui de l’application, tenez compte du modèle de sécurité suivant :</p>
 
 <ul>
 <li>Un fichier SWF du sandbox local avec système de fichiers risque de ne pas charger des données depuis une ressource située dans le sandbox réseau, ni lui en fournir. </li>
 
 <li> Par défaut, le fichier SWF appelant et l’URL chargée doivent se trouver dans le même domaine. Par exemple, un fichier SWF à l’adresse www.adobe.com peut charger uniquement des données provenant de sources situées aussi à l’adresse www.adobe.com. Pour charger des données à partir d’un autre domaine, placez un fichier de régulation d’URL sur le serveur hébergeant les données.</li>
 </ul>
  
 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
 
 <ul>
 
 <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
   <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 
 </ul>
 
 
 </apiDesc><example conref="examples\URLLoaderExample.as"> L’exemple suivant charge et affiche les données détectées dans un fichier texte local. Il assure également le suivi des informations de gestion des événements.
 
 <p><b>Remarque :</b> pour exécuter cet exemple, placez un fichier nommé urlLoaderExample.txt dans le même répertoire que votre fichier SWF. Ce fichier ne doit contenir que la ligne de texte suivante : <codeph>answer=42&amp;question=unknown</codeph>
 </p>
 <p>Le code de l’exemple effectue les opérations suivantes :</p>
 <ol>
    <li>La fonction constructeur crée une occurrence d’URLLoader nommée <codeph>loader</codeph> et une occurrence d’URLRequest nommée <codeph>request</codeph>, qui contient l’emplacement et le nom du fichier à charger.</li>
    <li>L’objet <codeph>loader</codeph> est transmis à la méthode <codeph>configureListeners()</codeph>, qui ajoute des écouteurs à chacun des événements URLLoader pris en charge.</li>
    <li>L’objet <codeph>request</codeph> est ensuite transmis à la méthode <codeph>loader.load()</codeph>, qui charge le fichier texte.</li>
      <li>Lorsque l’URLLoader a terminé de chargé le fichier texte, l’événement <codeph>Event.COMPLETE</codeph> se produit et déclenche la méthode <codeph>completeHandler()</codeph>. La méthode <codeph>completeHandler()</codeph> crée un objet URLVariables à partir du texte chargé depuis le fichier. L’objet URLVariables convertit les paires nom/valeur d’URL codées en propriétés ActionScript pour faciliter la manipulation des données chargées.</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderExample extends Sprite {
        public function URLLoaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("urlLoaderExample.txt");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
    
            var vars:URLVariables = new URLVariables(loader.data);
            trace("The answer is " + vars.answer);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 Distribué si un appel de la méthode load() tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>load()</codeph> tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Distribué si un appel de la méthode URLLoader.load() tente d’accéder aux données via HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>URLLoader.load()</codeph> tente d’accéder aux données via HTTP. <ph platform="actionscript">Dans le cas de contenu s’exécutant dans Flash Player, cet événement n’est distribué que si l’environnement Flash Player actif est capable de détecter et de renvoyer le code d’état de la requête (certains environnements de navigateur ne sont pas capables de fournir cette information).</ph> Vous remarquerez que l’événement <codeph>httpStatus</codeph> (le cas échéant) est envoyé avant (et en complément de) tout événement <codeph>complete</codeph> ou <codeph>error</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué si un appel de la méthode URLLoader.load() tente de charger des données d’un serveur en dehors d’un sandbox de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>URLLoader.load()</codeph> tente de charger des données d’un serveur en dehors d’un sandbox de sécurité. Egalement distribué si un appel de la méthode <codeph>URLLoader.load()</codeph> tente de charger un fichier SWZ, si le certificat n’est pas valide ou si la chaîne digest ne correspond pas au composant.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué si un appel de la méthode URLLoader.load() provoque une erreur fatale qui met fin au téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>URLLoader.load()</codeph> provoque une erreur fatale qui met fin au téléchargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Distribué lorsque des données sont reçues pendant l’opération de téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué à la réception des données au fur et à mesure du téléchargement.
 
 <p>Notez qu’avec un objet URLLoader, il est impossible d’accéder aux données avant la fin de leur téléchargement. L’événement progress indique donc uniquement la progression du téléchargement. Pour accéder aux données avant la fin de leur téléchargement, utilisez un objet URLStream. </p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Distribué après le décodage de toutes les données reçues et leur placement dans la propriété data de l’objet URLLoader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué après le décodage de toutes les données reçues et leur placement dans la propriété <codeph>data</codeph> de l’objet URLLoader. Il est possible d’accéder aux données reçues une fois cet événement distribué.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Distribué lorsque l’opération de téléchargement commence suite à un appel de la méthode URLLoader.load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’opération de téléchargement commence suite à un appel de la méthode <codeph>URLLoader.load()</codeph>. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:URLLoader:URLLoader"><apiName>URLLoader</apiName><shortdesc>
	 Crée un objet URLLoader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc>Objet URLRequest indiquant l’URL à télécharger. Si ce paramètre n’est pas spécifié, aucune opération de chargement ne commence. S’il est spécifié, l’opération de chargement commence immédiatement (voir l’entrée <codeph>load</codeph> pour plus d’informations).
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet URLLoader.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:URLLoader:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Type d’événement.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction d’écouteur qui traite l’événement. Cette fonction doit accepter un objet Event comme paramètre unique et ne rien renvoyer<ph platform="actionscript">, comme illustré ci-dessous :</ph><ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Le nom de cette fonction n’a aucune importance.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Ce paramètre s’applique aux objets d’affichage dans l’architecture de la liste d’affichage ActionScript 3.0, utilisés par le contenu SWF.</ph> <ph platform="actionscript">Détermine si l’écouteur est actif pendant la phase de capture ou pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, l’écouteur traite l’événement uniquement pendant la phase de capture et non pendant les phases cible et de propagation vers le haut. Si la propriété <codeph>useCapture</codeph> est définie sur <codeph>false</codeph>, l’écouteur traite l’événement uniquement pendant les phases cible et de propagation vers le haut. Pour écouter l’événement dans les trois phases, appelez <codeph>addEventListener</codeph> à deux reprises, une première fois en définissant <codeph>useCapture</codeph> sur <codeph>true</codeph>, puis une nouvelle fois en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Niveau de priorité de l’écouteur d’événement. La priorité est indiquée par un entier signé de 32 bits. Plus le nombre est élevé, plus la priorité est élevée. Tous les écouteurs dont la priorité correspond à <i>n</i> sont traités avant les écouteurs dotés de la priorité <i>n</i> -1. Les écouteurs dont la priorité est identique sont traités dans l’ordre où ils ont été ajoutés. La priorité par défaut est 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Détermine si la référence à l’écouteur est forte ou faible. Une référence forte (valeur par défaut) empêche le nettoyage de votre écouteur, Cela n’est pas le cas avec une référence faible. <p>Les fonctions de membres de niveau classe n’étant pas soumises au nettoyage, vous pouvez définir <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour ces fonctions. Si vous définissez <codeph>useWeakReference</codeph> sur <codeph>true</codeph> pour un écouteur correspondant à une fonction imbriquée interne, la fonction sera nettoyée et ne sera donc pas permanente. Si vous créez des références à la fonction interne (enregistrée dans une autre variable), celle-ci n’est pas nettoyée et reste permanente.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	
	Enregistre un objet écouteur d’événement auprès d’un objet EventDispatcher afin que l’écouteur soit averti d’un événement. <ph platform="actionscript">Vous pouvez enregistrer les écouteurs d’événement dans tous les nœuds de la liste d’affichage pour un type spécifique d’événement, de phase et de priorité.</ph>
	
	<p platform="javascript">Le code JavaScript dans le moteur d’exécution AIR utilise cette méthode pour enregistrer des écouteurs d’événements définis par les API AIR. Pour d’autres événements JavaScript (tels que l’événement <codeph>onload</codeph> de l’objet <codeph>body</codeph> DOM), vous pouvez utiliser des techniques de gestion d’événements standard, comme vous le feriez pour le contenu exécuté dans le navigateur.</p>
	
	<p>Après l’enregistrement d’un écouteur d’événement, vous ne pouvez plus modifier sa priorité par d’autres appels de <codeph>addEventListener()</codeph>. Pour modifier la priorité d’un écouteur, vous devez d’abord appeler <codeph>removeListener()</codeph>. Vous pouvez ensuite réenregistrer l’écouteur avec le nouveau niveau de priorité. </p>
	
	<p>N’oubliez pas qu’une fois l’écouteur enregistré, tous les prochains appels de <codeph>addEventListener()</codeph> avec une valeur <codeph>type</codeph> ou <codeph>useCapture</codeph> différente entraîneront la création d’un autre enregistrement d’écouteur. <ph platform="actionscript">Si, par exemple, vous enregistrez un écouteur dans lequel la propriété <codeph>useCapture</codeph> est définie sur <codeph>true</codeph>, il écoute uniquement pendant la phase de capture. Si vous appelez <codeph>addEventListener()</codeph> à l’aide du même objet écouteur, mais en définissant <codeph>useCapture</codeph> sur <codeph>false</codeph>, vous obtenez deux écouteurs distincts : l’un qui écoute pendant la phase de capture et l’autre qui écoute pendant les phases cible et de propagation vers le haut (bubbling).</ph>
	</p>
	
	<p platform="actionscript">Il est impossible d’enregistrer un écouteur d’événement uniquement pour la phase cible ou la phase de propagation vers le haut. Ces deux phases sont associées pendant l’enregistrement car la propagation vers le haut s’applique uniquement aux ancêtres du nœud cible.</p>
	
	<p>Si vous n’avez plus besoin d’un écouteur d’événements, supprimez-le en appelant <codeph>removeEventListener()</codeph>, afin d’éviter tout problème de mémoire. Les écouteurs d’événement ne sont pas automatiquement supprimés de la mémoire, car le nettoyeur de mémoire ne supprime pas l’écouteur tant que l’objet de distribution existe (à moins que le paramètre <codeph>useWeakReference</codeph> ne soit défini sur <codeph>true</codeph>).</p>
		
	<p>Lors de la copie d’une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés ne sont pas pris en compte (si le nouveau nœud nécessite un écouteur d’événement, vous devez associer celui-ci après la création du nœud). Toutefois, si vous déplacez une occurrence d’EventDispatcher, les écouteurs d’événement qui lui sont associés la suivent.</p>
	
	
	<p platform="actionscript">Si un écouteur d’événement est enregistré sur un nœud alors qu’un événement est en cours de traitement sur ce nœud, l’écouteur n’est pas déclenché pendant la phase actuelle, mais il peut l’être pendant une phase ultérieure du flux d’événements, telle que la phase de propagation vers le haut (bubbling).</p>
	
	<p platform="actionscript">Si un écouteur d’événement est supprimé d’un nœud sur lequel un événement est en cours de traitement, il est cependant déclenché par les actions en cours. Une fois supprimé, l’écouteur d’événement n’est plus jamais appelé (à moins d’être réenregistré à des fins de traitement ultérieur). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:close"><apiName>close</apiName><shortdesc>
	 Ferme l’opération de chargement en cours.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Ferme l’opération de chargement en cours. Toute opération de chargement en cours prend immédiatement fin. Si aucune URL n’est en cours de transmission, une erreur de flux non valide est renvoyée.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:load"><apiName>load</apiName><shortdesc>
	 Envoie et charge les données à partir de l’URL spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les objets <codeph>URLRequest.requestHeader</codeph> ne devraient pas contenir certains en-têtes de requête HTTP interdits. Pour plus d’informations, voir la description de la classe URLRequestHeader.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire pour les raisons suivantes : 1) <ph platform="actionscript">Flash Player ou </ph>Adobe AIR ne peut pas convertir le paramètre <codeph>URLRequest.data</codeph> du format UTF8 au format MBCS. Cette erreur est concernée si l’objet URLRequest transmis à la méthode <codeph>load()</codeph> est configuré pour exécuter une opération <codeph>GET</codeph> et si <codeph>System.useCodePage</codeph> est réglé sur <codeph>true</codeph>. 2) <ph platform="actionscript">Flash Player ou </ph>Adobe AIR ne peut pas allouer de mémoire aux données <codeph>POST</codeph>. Cette erreur est concernée si l’objet URLRequest transmis à <codeph>load</codeph> est configuré pour exécuter une opération <codeph>POST</codeph>.
	 
	 </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Les fichiers non approuvés au niveau local ne peuvent pas communiquer avec Internet. Pour contourner ce problème, reclassifiez le fichier en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
     
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>La valeur du paramètre de requête ou de la propriété <codeph>URLRequest.url</codeph> de l’objet URLRequest transmis est <codeph>null</codeph>.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Objet URLRequest indiquant l’URL à télécharger.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Envoie et charge les données à partir de l’URL spécifiée. Les données peuvent être reçues sous forme de texte, de données binaires brutes ou de variables d’URL codées, selon la valeur définie pour la propriété <codeph>dataFormat</codeph>. Vous remarquerez que la valeur par défaut de la propriété <codeph>dataFormat</codeph> correspond à text. Si vous souhaitez envoyer des données à l’URL spécifiée, définissez la propriété <codeph>data</codeph> dans l’objet URLRequest.
	 
	 <p><b>Remarque :</b> si un fichier en cours de chargement contient des caractères non-ASCII (comme dans les langues autres que l’anglais), nous vous recommandons d’enregistrer le fichier avec codage UTF-8 ou UTF-16, plutôt que sous un format non-Unicode, ASCII par exemple.</p>
	 
	 <p> Un fichier SWF du sandbox local avec système de fichiers risque de ne pas charger des données depuis une ressource située dans le sandbox réseau, ni lui en fournir.</p> 
	  
	 <p> Par défaut, le fichier SWF appelant et l’URL chargée doivent se trouver dans le même domaine. Par exemple, un fichier SWF à l’adresse www.adobe.com peut charger uniquement des données provenant de sources situées aussi à l’adresse www.adobe.com. Pour charger des données à partir d’un autre domaine, placez un fichier de régulation d’URL sur le serveur hébergeant les données.</p>
	 
      <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     <p> Dans Flash Player versions 10 et ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête « content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul>
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p>Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     
	 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
	 
     <ul>
     
     
	 <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i>.</li>
	 
	 <li>Le <xref href="http://www.adobe.com/go/fp9_0_security_fr" scope="external">Livre blanc sur la sécurité de Flash Player 9</xref></li>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
	 
	 </apiDesc><example conref="examples\URLLoader_loadExample.as"> Dans l’exemple suivant, un fichier XML est chargé et le contenu des premiers arguments de son élément s’affiche dans un champ de texte.
 
 <p>Un objet <codeph>URLRequest</codeph> est créé pour identifier l’emplacement du fichier XML, qui pour cet exemple est dans le même répertoire que le fichier SWF. Le fichier est chargé dans un bloc <codeph>try...catch</codeph> pour capturer toute erreur pouvant survenir (ici nous capturons les erreurs <codeph>SecurityError</codeph>). Si un événement <codeph>IO_ERROR</codeph> survient, la méthode <codeph>errorHandler()</codeph> est invoquée et écrit un message d’erreur dans le champ de texte <codeph>xmlTextField</codeph>. Une fois le fichier XML reçu et placé dans la propriété de données de l’objet URLLoader <codeph>loader</codeph>, l’événement <codeph>Event.COMPLETE</codeph> est distribué et la méthode <codeph>loaderCompleteHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>loaderCompleteHandler()</codeph>, un bloc <codeph>try...catch</codeph> est utilisé pour capturer toute erreur d’analyse pouvant survenir lors de la conversion des données chargées depuis le fichier en objet XML. La méthode <codeph>readNodes()</codeph> passe de façon récursive à travers tous les éléments des noeuds du document XML et ajoute le champ de texte <codeph>xmlTextField</codeph> avec la liste des premiers attributs de tous les éléments.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.xml.*;
    import flash.events.IOErrorEvent;
  
    public class URLLoader_loadExample extends Sprite {
        private var xmlTextField:TextField = new TextField();
        private var externalXML:XML;    
        private var loader:URLLoader;

        public function URLLoader_loadExample() {
            var request:URLRequest = new URLRequest("xmlFile.xml");

            loader = new URLLoader();
            
            try {
                loader.load(request);
            }
            catch (error:SecurityError)
            {
                trace("A SecurityError has occurred.");
            }

             loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);

            xmlTextField.x = 10;
            xmlTextField.y = 10;
            xmlTextField.background = true;
            xmlTextField.autoSize = TextFieldAutoSize.LEFT;

            addChild(xmlTextField);
        }

        private function loaderCompleteHandler(event:Event):void {

                try {
                    externalXML = new XML(loader.data);
                    readNodes(externalXML);    
                } catch (e:TypeError) {
                    trace("Could not parse the XML file.");
                }
        }

        private function readNodes(node:XML):void {

                for each (var element:XML in node.elements()) {
                    xmlTextField.appendText(element.attributes()[0] + "\n");

                    readNodes(element);
                }    
        }

        private function errorHandler(e:IOErrorEvent):void {
            xmlTextField.text = "Had problem loading the XML File.";
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequest/requestHeaders"><linktext>URLRequest.requestHeaders</linktext></link><link href="flash.net.xml#URLRequest/data"><linktext>URLRequest.data</linktext></link><link href="flash.net.xml#URLRequest/digest"><linktext>URLRequest.digest</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué après le chargement effectif de données.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le chargement de données a réussi.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Si l’accès s’effectue via HTTP et que l’environnement Flash Player actuel permet l’obtention des codes d’état, il se peut que vous receviez ces événements en plus des événements <codeph>complete</codeph> ou <codeph>error</codeph>.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Si l’accès s’effectue via HTTP et que l’environnement Flash Player actuel permet l’obtention des codes d’état, il se peut que vous receviez ces événements en plus des événements complete ou error.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>L’opération de chargement n’a pas pu aboutir.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>L’opération de chargement n’a pu se terminer.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque des données sont reçues pendant l’opération de téléchargement.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué à la réception des données au fur et à mesure du téléchargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Une opération de chargement a tenté d’extraire des données à partir d’un serveur situé en dehors du sandbox de sécurité de l’appelant. Vous pouvez contourner le problème en utilisant un fichier de régulation au niveau du serveur.
	 </apiDesc></adobeApiEventDetail><shortdesc>Une opération de chargement a tenté d’extraire des données d’un serveur situé hors du sandbox de sécurité de l’appelant.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Une opération de chargement a tenté de charger un fichier SWZ (un composant de la plateforme Adobe), mais le certificat n’est pas valide ou le digest ne correspond pas au composant.
	 </apiDesc></adobeApiEventDetail><shortdesc>Une opération de chargement a tenté de charger un fichier SWZ (un composant de la plateforme Adobe), mais le certificat n’est pas valide ou le digest ne correspond pas au composant.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué au commencement d’une opération de chargement.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué au commencement d’une opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué si un appel de la méthode <codeph>load()</codeph> tente d’accéder aux données via HTTP et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué si un appel de la méthode load() tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:URLLoader:bytesLoaded"><apiName>bytesLoaded</apiName><shortdesc>
	 Indique le nombre d’octets chargés jusqu’ici au cours du chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Indique le nombre d’octets chargés jusqu’ici au cours du chargement.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:bytesTotal"><apiName>bytesTotal</apiName><shortdesc>
	 Indique le nombre total d’octets dans les données téléchargées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Indique le nombre total d’octets dans les données téléchargées. Cette propriété contient 0 lorsque le chargement est en cours et est renseignée au terme de ce dernier. Egalement, si un en-tête Content-Length est manquant, bytesTotal sera indéterminé.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:data"><apiName>data</apiName><shortdesc>
	 Données reçues par le biais de l’opération de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
	 Données reçues par le biais de l’opération de chargement. Cette propriété n’est renseignée qu’à la fin du chargement. Le format des données varie en fonction du paramétrage de la propriété <codeph>dataFormat</codeph> :
	 
	 <p>Si la propriété <codeph>dataFormat</codeph> est <codeph>URLLoaderDataFormat.TEXT</codeph>, les données reçues représentent une chaîne qui contient le texte du fichier chargé.</p>
	 
	 <p>Si la propriété <codeph>dataFormat</codeph> est <codeph>URLLoaderDataFormat.BINARY</codeph>, les données reçues représentent un objet ByteArray qui contient des données binaires brutes.</p>
	 
	 <p>Si la propriété <codeph>dataFormat</codeph> est <codeph>URLLoaderDataFormat.VARIABLES</codeph>, les données reçues représentent un objet URLVariables qui contient des variables d’URL codées.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link><link href="flash.net.xml#URLLoader/dataFormat"><linktext>URLLoader.dataFormat</linktext></link></related-links></apiValue><apiValue id="flash.net:URLLoader:dataFormat"><apiName>dataFormat</apiName><shortdesc>
	 Contrôle si les données téléchargées sont reçues sous forme de texte (URLLoaderDataFormat.TEXT), de données binaires brutes (URLLoaderDataFormat.BINARY) ou de variables de code URL (URLLoaderDataFormat.VARIABLES).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>URLLoaderDataFormat.TEXT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Contrôle si les données téléchargées sont reçues sous forme de texte (<codeph>URLLoaderDataFormat.TEXT</codeph>), de données binaires brutes (<codeph>URLLoaderDataFormat.BINARY</codeph>) ou de variables d’URL codées (<codeph>URLLoaderDataFormat.VARIABLES</codeph>).
	 
	 <p>Si la valeur de la propriété <codeph>dataFormat</codeph> est <codeph>URLLoaderDataFormat.TEXT</codeph>, les données reçues représentent une chaîne qui contient le texte du fichier chargé.</p>
	 
	 <p>Si la valeur de la propriété <codeph>dataFormat</codeph> est <codeph>URLLoaderDataFormat.BINARY</codeph>, les données reçues représentent un objet ByteArray qui contient les données binaires brutes.</p>
	 
	 <p>Si la valeur de la propriété <codeph>dataFormat</codeph> est <codeph>URLLoaderDataFormat.VARIABLES</codeph>, les données reçues représentent un objet URLVariables qui contient les variables d’URL codées.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
 
 La classe NetStreamPlayOptions spécifie les diverses options pouvant être transmises à la méthode NetStream.play2().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>La classe NetStreamPlayOptions spécifie les diverses options pouvant être transmises à la méthode NetStream.play2(). 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 La classe NetStreamPlayOptions spécifie les diverses options pouvant être transmises à la méthode <codeph>NetStream.play2()</codeph>. Vous pouvez transmettre un objet NetStreamPlayOptions à <codeph>play2()</codeph>, et les propriétés de la classe spécifient les différentes options. La principale utilisation de cette classe consiste à implémenter dynamiquement des transitions entre des flux, soit pour basculer vers d’autres flux de même contenu codés avec des débits différents, soit pour basculer vers un autre contenu dans une liste de lecture.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamPlayOptions:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
     
     Crée un objet NetStreamPlayOptions pour spécifier les options transmises à la méthode NetStream.play2().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     
     Crée un objet NetStreamPlayOptions pour spécifier les options transmises à la méthode <codeph>NetStream.play2()</codeph>. 
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiConstructor><apiValue id="flash.net:NetStreamPlayOptions:len"><apiName>len</apiName><shortdesc>
    Durée de la lecture, en secondes, du flux spécifié dans streamName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Durée de la lecture, en secondes, du flux spécifié dans streamName.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Durée de la lecture, en secondes, du flux spécifié dans <codeph>streamName</codeph>. La valeur par défaut est -1, et signifie que Flash Player lit un flux en direct jusqu’à ce qu’il ne soit plus disponible ou lit un flux enregistré jusqu’à la fin. Si vous transmettez 0 pour <codeph>len</codeph>, Flash Player lit l’unique image située à <codeph>start</codeph> secondes du début d’un flux enregistré (en supposant que <codeph>start</codeph> est égal ou supérieur à 0).
    <p>Si vous transmettez un nombre positif pour <codeph>len</codeph>, Flash Player lit un flux en direct pendant <codeph>len</codeph> secondes lorsqu’il devient disponible, ou lit un flux enregistré pendant <codeph>len</codeph> secondes (si le flux se termine avant <codeph>len</codeph> secondes, la lecture prend fin en même temps que le flux).</p> 
    <p>Si vous transmettez un nombre négatif autre que -1 pour <codeph>len</codeph>, Flash Player interprète la valeur comme s’il s’agissait de -1.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/start"><linktext>start</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:oldStreamName"><apiName>oldStreamName</apiName><shortdesc>
    Nom de l’ancien flux ou du flux à partir duquel s’effectue la transition.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Nom de l’ancien flux ou du flux à partir duquel s’effectue la transition. Lorsque la méthode <codeph>NetStream.play2()</codeph> n’est utilisée que pour lire un flux (sans effectuer de transition), la valeur de cette propriété doit être null ou undefined. Sinon, spécifiez le flux à partir duquel s’effectue la transition.   
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/streamName"><linktext>streamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:start"><apiName>start</apiName><shortdesc>
    Instant de départ, en secondes, pour streamName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Instant de départ, en secondes, pour streamName.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Instant de départ, en secondes, pour <codeph>streamName</codeph>. Les valeurs valides sont -2, -1 et 0.
    
    <p>La valeur par défaut de <codeph>start</codeph> est -2, ce qui signifie que Flash Player tente d’abord de lire le flux en direct spécifié dans <codeph>streamName</codeph>. Lorsque aucun flux en direct portant ce nom n’est détecté, Flash Player lit le flux enregistré spécifié dans <codeph>streamName</codeph>. Lorsque aucun flux en direct ou enregistré n’est détecté, Flash Player ouvre un flux en direct nommé <codeph>streamName</codeph>, même lorsque personne ne publie sur ce dernier. Lorsque quelqu’un démarre une publication sur ce flux, Flash Player commence à le lire.</p>
    
    <p>Si vous transmettez -1 pour <codeph>start</codeph>, Flash Player ne lit que le flux en direct spécifié dans <codeph>streamName</codeph>. Lorsque aucun flux en direct n’est détecté, Flash Player l’attend indéfiniment si <codeph>len</codeph> est défini sur -1 ; si <codeph>len</codeph> est défini sur une autre valeur, Flash Player attend pendant <codeph>len</codeph> secondes avant de commencer la lecture du prochain élément dans la liste.</p>
    
    <p> Si vous transmettez 0 ou un nombre positif pour <codeph>start</codeph>, Flash Player lit uniquement un flux enregistré nommé <codeph>streamName</codeph>, en commençant à <codeph>start</codeph> secondes à partir du début du flux. Si aucun flux enregistré n’est détecté, Flash Player commence immédiatement la lecture du prochain élément dans la liste de lecture.</p>
    
    <p>Si vous transmettez un nombre négatif autre que -1 ou -2 pour <codeph>start</codeph>, Flash Player interprète la valeur comme s’il s’agissait de -2.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/len"><linktext>len</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:streamName"><apiName>streamName</apiName><shortdesc>
    Nom du nouveau flux vers lequel doit s’effectuer la transition ou à lire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Nom du nouveau flux vers lequel doit s’effectuer la transition ou à lire. Lorsque <codeph>oldStreamName</codeph> est null ou undefined, un appel à <codeph>NetStream.play2()</codeph> commence simplement la lecture de <codeph>streamName</codeph>. Si <codeph>oldStreamName</codeph> est spécifié, un appel à <codeph>NetStream.play2()</codeph> entraîne une transition de <codeph>oldStreamName</codeph> vers <codeph>streamName</codeph> avec le mode de transition spécifié dans la propriété <codeph>transition</codeph>. 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/oldStreamName"><linktext>oldStreamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:transition"><apiName>transition</apiName><shortdesc>
    Mode dans lequel le streamName est lu ou transité vers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Mode dans lequel le streamName est lu ou transité vers.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Mode dans lequel le <codeph>streamName</codeph> est lu ou transité vers. Les valeurs possibles sont des constantes de la classe NetStreamPlayTransitions. Selon si la méthode <codeph>Netstream.play2()</codeph> est appelée pour lire ou faire transiter un flux, le mode de transition entraîne des comportement différents. Pour plus d’informations sur les modes de transition, voir la classe NetStreamPlayTransitions.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyOutput"><apiName>IDynamicPropertyOutput</apiName><shortdesc>
	 Cette interface contrôle la sérialisation des propriétés dynamiques des objets dynamiques.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Cette interface contrôle la sérialisation des propriétés dynamiques des objets dynamiques. Utilisez cette interface avec l’interface IDynamicPropertyWriter et la propriété <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>.
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyOutput:flash.net:IDynamicPropertyOutput:writeDynamicProperty"><apiName>writeDynamicProperty</apiName><shortdesc>
		 Ajoute une propriété dynamique à la sortie binaire d’un objet sérialisé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la propriété. Vous pouvez utiliser ce paramètre soit pour indiquer le nom d’une propriété existante de l’objet dynamique, soit pour créer une nouvelle propriété.  
		 
		 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Valeur à écrire dans la propriété spécifiée.
		 
         </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ajoute une propriété dynamique à la sortie binaire d’un objet sérialisé. Lorsque l’objet est ensuite lu (à l’aide d’une méthode telle que <codeph>readObject</codeph>), il contient la nouvelle propriété. Cette méthode vous permet d’exclure des propriétés d’objets dynamiques de la sérialisation, d’écrire des valeurs dans les propriétés des objets dynamiques ou de créer de nouvelles propriétés pour des objets dynamiques.
		 
         </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLVariables"><apiName>URLVariables</apiName><shortdesc>
 
 La classe URLVariables vous permet de transférer des variables entre une application et un serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, constructor
</keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 La classe URLVariables vous permet de transférer des variables entre une application et un serveur. Utilisez les objets URLVariables avec des méthodes de la classe URLLoader, avec la propriété <codeph>data</codeph> de la classe URLRequest et des fonctions de package flash.net.
 
 </apiDesc><example conref="examples\URLVariablesExample.as"> L’exemple suivant ouvre l’application distante hébergée à l’adresse http://www.[yourDomain].com/application.jsp dans une nouvelle fenêtre de navigateur et transmet à l’application des données relatives à une session utilisateur, capturées dans un objet URLVariables. 
  
 <p>Vous trouverez ci-dessous des extraits de l’exemple :</p>
 <ol>
    <li>La fonction constructeur crée une occurrence de URLRequest nommée <codeph>request</codeph>, en utilisant l’URL de l’application distante comme paramètre.</li>
    <li>Un objet URLVariables est créé et des valeurs sont attribuées à deux de ses propriétés.</li>
    <li>L’objet URLVariables est affecté à la propriété <codeph>data</codeph> de l’objet URLRequest.</li>
    <li>L’exemple appelle <codeph>navigateToURL</codeph>, qui ouvre une nouvelle fenêtre de navigateur vers l’URL de l’application distante.</li>
 </ol>
 <p> <b>Remarque :</b> pour exécuter l’exemple, l’URL de l’application distante de l’exemple doit être remplacée par une URL opérationnelle. En outre, du code serveur serait nécessaire pour traiter les informations capturées par Flash Player dans l’objet URLVariables.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLVariables:URLVariables"><apiName>URLVariables</apiName><shortdesc>
	 Crée un nouvel objet URLVariables.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chaîne codée au format URL contenant des paires nom/valeur.
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un nouvel objet URLVariables. Vous transmettez des objets URLVariables à la propriété <codeph>data</codeph> des objets URLRequest.
	 
	 <p>Si vous appelez le constructeur URLVariables avec une chaîne, la méthode <codeph>decode()</codeph> est appelée automatiquement pour convertir la chaîne en propriétés de l’objet URLVariables.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:URLVariables:decode"><apiName>decode</apiName><shortdesc>
	 Convertit la chaîne de variables en propriétés de l’objet URLVariables spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.decode, decode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le paramètre source doit être une chaîne de requête codée au format URL et contenant des paires nom/valeur.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne de requête codée au format URL et contenant des paires nom/valeur.	 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Convertit la chaîne de variables en propriétés de l’objet URLVariables spécifié.
	 <p>Cette méthode est utilisée en interne par les événements URLVariables. La plupart des utilisateurs n’a pas besoin d’appeler cette méthode directement.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLVariables:toString"><apiName>toString</apiName><shortdesc>
	 Renvoie une chaîne contenant toutes les variables énumérables, au format de l’application de codage du contenu MIME/x-www-form-urlencoded.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.toString, toString
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne codée au format URL contenant des paires nom/valeur.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Renvoie une chaîne contenant toutes les variables énumérables, au format de l’application de codage du contenu MIME<i>/x-www-form-urlencoded</i>.
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyWriter"><apiName>IDynamicPropertyWriter</apiName><shortdesc>
     Cette interface s’utilise avec l’interface IDynamicPropertyOutput pour contrôler la sérialisation des propriétés dynamiques des objets dynamiques.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
     Cette interface s’utilise avec l’interface IDynamicPropertyOutput pour contrôler la sérialisation des propriétés dynamiques des objets dynamiques. Pour l’utiliser, affectez un objet qui implémente l’interface IDynamicPropertyWriter dans la propriété <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>.
      
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyWriter:flash.net:IDynamicPropertyWriter:writeDynamicProperties"><apiName>writeDynamicProperties</apiName><shortdesc>
         Ecrit le nom et la valeur d’un objet IDynamicPropertyOutput dans un objet doté de propriétés dynamiques.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet dans lequel écrire.
		 </apiDesc></apiParam><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.net:IDynamicPropertyOutput</apiOperationClassifier><apiDesc>Objet IDynamicPropertyOutput contenant le nom et la valeur à écrire dynamiquement dans l’objet.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Ecrit le nom et la valeur d’un objet IDynamicPropertyOutput dans un objet doté de propriétés dynamiques. Si la propriété <codeph>ObjectEncoding.dynamicPropertyWriter</codeph> est définie, cette méthode est appelée pour chaque objet doté de propriétés dynamiques. 
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLRequestDefaults"><apiName>URLRequestDefaults</apiName><shortdesc>
 La classe URLRequestDefaults inclut des propriétés statiques que vous pouvez utiliser pour définir les valeurs par défaut des propriétés de la classe URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe URLRequestDefaults inclut des propriétés statiques que vous pouvez utiliser pour définir les valeurs par défaut des propriétés de la classe URLRequest. Elle comprend également une méthode statique, <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>, qui vous permet de définir les informations d’authentification par défaut des requêtes. La classe URLRequest définit les informations devant être utilisées dans une requête HTTP. 
 
 <p>Les propriétés définies dans un objet URLRequest remplacent les propriétés statiques définies pour la classe URLRequestDefaults.</p>
 
 <p>Les paramètres de la classe URLRequestDefault ne s’appliquent qu’au contenu du domaine d’application de l’appelant, à une exception près : les paramètres définis lors de l’appel de <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> s’appliquent à tous les domaines d’application dans l’application en cours d’exécution.</p>
 
 <p>Seul le contenu Adobe<sup>®</sup> AIR<sup>®</sup> s’exécutant dans le sandbox de sécurité de l’application peut utiliser la classe URLRequestDefaults. L’utilisation d’autres contenus renvoie une exception SecurityError lors de l’accès aux membres ou aux propriétés de cette classe.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><apiOperation id="flash.net:URLRequestDefaults:setLoginCredentialsForHost"><apiName>setLoginCredentialsForHost</apiName><shortdesc>
	Définit le nom d’utilisateur et le mot de passe par défaut de l’hôte sélectionné.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>hostname</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Le nom d’hôte auxquels sont appliqués le nom d’utilisateur et le mot de passe. Il peut s’agir d’un domaine, tel que <codeph>"www.example.com"</codeph>, ou d’un nom de domaine et d’un numéro de port, par exemple <codeph>"www.example.com:80"</codeph>. Notez que <codeph>"example.com"</codeph>, <codeph>"www.example.com"</codeph> et <codeph>"sales.example.com"</codeph> sont considérés comme hôtes uniques. 
	
	</apiDesc></apiParam><apiParam><apiItemName>user</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom d’utilisateur par défaut à utiliser lors de l’authentification d’une requête pour l’hôte spécifié.
	
	</apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Mot de passe par défaut à utiliser lors de l’authentification d’une requête pour l’hôte spécifié.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Définit le nom d’utilisateur et le mot de passe par défaut de l’hôte sélectionné. Ces paramètres s’appliquent aux objets URLRequest dans tous les domaines d’application de l’application, pas seulement à ceux du domaine d’application de l’objet appelant cette méthode (tandis que les propriétés statiques de la classe URLRequest s’appliquent uniquement au domaine d’application de l’appelant). Ceci permet une connexion au contenu de l’application (quel que soit le domaine d’application du contenu) lorsqu’une autre partie de l’application se connecte.
	
	<p><i>Remarque concernant les applications fonctionnant sous Mac OS :</i> lorsque vous appelez cette méthode sous Mac OS, l’application utilise ces informations d’identification pour l’hôte spécifié tant que celle-ci est ouverte, même si vous appelez par la suite la méthode <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> pour le même hôte. Cependant, si un serveur rejette les informations d’identification spécifiées par cette méthode, l’appel suivant à la méthode <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> (pour le même hôte) est reconnu.</p>
	
	<p><i>Remarque :</i> cette méthode ne s’applique pas aux objets URLRequest utilisés lors du chargement de fichiers ou dans des requêtes RTMP.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLRequestDefaults:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	Paramètre par défaut de la propriété authenticate des objets URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Paramètre par défaut de la propriété <codeph>authenticate</codeph> des objets URLRequest. La définition de la propriété <codeph>authenticate</codeph> dans un objet URLRequest annule ce paramètre par défaut.
	
	<p><i>Remarque :</i> ce paramètre ne s’applique pas aux objets URLRequest utilisés lors du chargement de fichiers ou dans des requêtes RTMP.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/authenticate"><linktext>URLRequest.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	Paramètre par défaut de la propriété cacheResponse des objets URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Paramètre par défaut de la propriété <codeph>cacheResponse</codeph> des objets URLRequest. La définition de la propriété <codeph>cacheResponse</codeph> dans un objet URLRequest annule ce paramètre par défaut. Si la valeur correspond à <codeph>true</codeph>, l’application AIR utilise par défaut le cache HTTP du système d’exploitation. Ce paramètre ne s’applique pas aux objets URLRequest utilisés lors du chargement de fichiers ou dans des requêtes RTMP.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/cacheResponse"><linktext>URLRequest.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	Paramètre par défaut de la propriété followRedirects des objets URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Paramètre par défaut de la propriété <codeph>followRedirects</codeph> des objets URLRequest. La définition de la propriété <codeph>followRedirects</codeph> dans un objet URLRequest annule ce paramètre par défaut. Ce paramètre ne s’applique pas aux objets URLRequest utilisés lors du chargement de fichiers ou dans des requêtes RTMP.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/followRedirects"><linktext>URLRequest.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	Paramètre par défaut de la propriété manageCookies des objets URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Paramètre par défaut de la propriété <codeph>manageCookies</codeph> des objets URLRequest. La définition de la propriété <codeph>manageCookies</codeph> dans un objet URLRequest annule ce paramètre par défaut.
	
	<p><i>Remarque :</i> ce paramètre ne s’applique pas aux objets URLRequest utilisés lors du chargement de fichiers ou dans des requêtes RTMP.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/manageCookies"><linktext>URLRequest.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:useCache:get"><apiName>useCache</apiName><shortdesc>
	Paramètre par défaut de la propriété useCache des objets URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Paramètre par défaut de la propriété <codeph>useCache</codeph> des objets URLRequest. La définition de la propriété <codeph>useCache</codeph> dans un objet URLRequest annule ce paramètre par défaut. Ce paramètre ne s’applique pas aux objets URLRequest utilisés lors du chargement de fichiers ou dans des requêtes RTMP.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/useCache"><linktext>URLRequest.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	Paramètre par défaut de la propriété userAgent des objets URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Paramètre par défaut de la propriété <codeph>userAgent</codeph> des objets URLRequest. La définition de la propriété <codeph>userAgent</codeph> dans un objet URLRequest annule ce paramètre par défaut.
	
	<p>Il s’agit également de la chaîne userAgent par défaut de tous les objets HTMLLoader (utilisés lors de l’appel de la méthode <codeph>load()</codeph> de l’objet HTMLLoader). La définition de la propriété <codeph>userAgent</codeph> de l’objet HTMLLoader annule le paramètre <codeph>URLRequestDefaults.userAgent</codeph>.</p>
	
	<p>Cette valeur par défaut varie selon le système d’exploitation du moteur d’exécution (par exemple, Mac OS, Linux ou Windows), ainsi que du langage et de la version du moteur d’exécution, comme le montrent les exemples suivants :</p>
	
	<ul>
	
		<li><codeph>"Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5"</codeph></li>
		<li><codeph>"Mozilla/5.0 (Windows; U; en) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5"</codeph></li>
     <li><codeph>"Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5"</codeph></li>
	
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/userAgent"><linktext>flash.net.URLRequest.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.net:getClassByAlias"><apiName>getClassByAlias</apiName><shortdesc>
     Recherche une classe pour laquelle un alias a été enregistré par le biais d’un appel de la méthode registerClassAlias().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>includeExample examples\GetClassByAliasExample.as -noswf
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’alias n’avait pas été enregistré.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Classe associée à l’alias indiqué. Si elle est introuvable, une exception est renvoyée.
     
     </apiDesc><apiOperationClassifier>Class</apiOperationClassifier></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Alias à rechercher.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Recherche une classe pour laquelle un alias a été enregistré par le biais d’un appel de la méthode <codeph>registerClassAlias()</codeph>.
     <p>Cette méthode n’interagit pas avec la méthode <codeph>flash.utils.getDefinitionByName()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#/registerClassAlias()"><linktext>registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:navigateToURL"><apiName>navigateToURL</apiName><shortdesc>
     Ouvre ou remplace une fenêtre dans l’application qui héberge le conteneur Flash Player (en règle générale, un navigateur).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
     are not supported by URLLoader.navigate.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La propriété <codeph>digest</codeph> de l’objet <codeph>request</codeph> n’est pas définie sur <codeph>null</codeph>. Vous devez définir la propriété <codeph>digest</codeph> d’un objet URLRequest uniquement lorsque vous appelez la méthode <codeph>URLLoader.load()</codeph> pour charger un fichier SWZ (composant de la plateforme Adobe).
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Dans Flash Player (et dans le contenu d’un sandbox non-applicatif dans Adobe AIR), cette erreur est renvoyée dans les cas suivants :
     <ul>
       <li>Les fichiers SWF locaux non approuvés ne peuvent pas communiquer avec Internet. Pour contourner ce problème, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.</li>
     
       <li>Une opération de navigation a tenté d’évaluer une pseudo-URL de script, mais le document la contenant (en règle générale, un document HTML dans un navigateur) se trouve sur un sandbox auquel vous n’avez pas accès. Pour éviter ce cas de figure, spécifiez <codeph>allowScriptAccess="always"</codeph> dans le document conteneur.</li>
     
       <li>Vous ne pouvez pas naviguer dans les fenêtres spéciales <codeph>"_self"</codeph>, <codeph>"_top"</codeph> ou <codeph>"_parent"</codeph> si votre fichier SWF figure sur une page HTML qui règle <codeph>allowScriptAccess</codeph> sur <codeph>"none"</codeph> ou sur <codeph>"sameDomain"</codeph> alors que les fichiers HTML et SWF n’appartiennent pas au même domaine.</li>
     
       <li>Vous ne pouvez pas naviguer, à partir d’un fichier SWF se trouvant sur le sandbox local avec système de fichiers, dans une fenêtre dont le nom n’est pas le nom par défaut.</li>
     
      <li>Vous ne pouvez pas vous connecter aux ports généralement réservés. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>. </li>
     
     </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si la méthode n’est pas appelée en réponse à l’action d’un utilisateur, notamment à un événement de type souris ou pression de touche. Cette condition ne s’applique qu’au contenu dans Flash Player et au contenu d’un sandbox non-applicatif dans Adobe AIR.
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Objet URLRequest indiquant l’URL à atteindre.
     
     <p><ph platform="actionscript">Pour le contenu s’exécutant dans Adobe AIR, lors de</ph><ph platform="javascript">Lors de</ph> l’utilisation de la fonction <codeph>navigateToURL()</codeph>, le moteur d’exécution traite un objet URLRequest qui utilise la méthode POST (objet dont la propriété <codeph>method</codeph> est définie sur <codeph>URLRequestMethod.POST</codeph>) comme s’il utilisait la méthode GET.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Fenêtre de navigateur ou cadre HTML dans lequel afficher le document désigné par le paramètre <codeph>request</codeph>. Vous pouvez entrer le nom d’une fenêtre spécifique ou utiliser l’une des valeurs suivantes :
     <ul>
     <li><codeph>"_self"</codeph> indique le cadre qui est actif dans la fenêtre ouverte.</li>
     <li><codeph>"_blank"</codeph> indique une nouvelle fenêtre.</li>
     <li><codeph>"_parent"</codeph> indique le parent du cadre actif.</li>
     <li><codeph>"_top"</codeph> désigne le cadre de plus haut niveau dans la fenêtre ouverte.</li>
     </ul>
     <p>Si vous ne renseignez pas la valeur de ce paramètre, une fenêtre vide est créée. Dans le lecteur autonome, vous pouvez spécifier une nouvelle fenêtre (<codeph>"_blank"</codeph>) ou une fenêtre nommée. Les autres valeurs ne sont pas applicables.</p>
     
     <p platform="actionscript"><b>Remarque :</b> si le code d’un fichier SWF s’exécutant dans le sandbox local avec système de fichiers appelle la fonction <codeph>navigateToURL()</codeph> et spécifie un nom de fenêtre personnalisé pour le paramètre <codeph>window</codeph>, le nom de la fenêtre est transféré en tant que nom aléatoire. Le format du nom est <codeph>"_flashXXXXXXXX"</codeph>, où chaque X représente un chiffre hexadécimal aléatoire. Au sein de la même session (jusqu’à ce que vous fermiez la fenêtre du navigateur), si vous rappelez la fonction et spécifiez le même nom pour le paramètre <codeph>window</codeph>, la même chaîne aléatoire est utilisée.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     <ph platform="actionscript">Ouvre ou remplace une fenêtre dans l’application qui héberge le conteneur Flash Player (en règle générale, un navigateur). Dans Adobe AIR, la fonction ouvre une URL dans le navigateur Web par défaut du système</ph><ph platform="javascript">Ouvre une URL dans le navigateur Web par défaut du système.</ph>
     
	 	<p>  <b><i>Remarque de sécurité importante </i></b> </p>
     	<p>Les développeurs transmettent souvent des valeurs d’URL à la fonction <codeph>navigateToURL()</codeph> obtenues à partir de source externes, telles que FlashVars. Il est possible que des pirates informatiques tentent de manipuler ces sources externes, notamment par programmation croisée. Par conséquent, les développeurs doivent valider toutes les URL avant de les transmettre à la fonction. </p>
     	
     <p>Il existe plusieurs façons de valider correctement les données d’URL selon l’utilisation des URL dans l’application. L’une des techniques de validation de données les plus courantes consiste à vérifier que l’URL appartient au modèle d’URL adéquat. Par exemple, l’autorisation non intentionnelle d’URL javascript: peut entraîner des manipulations par programmation croisée. Vous pouvez également vérifier que l’URL se trouve dans votre domaine afin de vous assurer que les personnes qui pratiquent l’hameçonnage ne puissent pas utiliser le fichier SWF comme redirecteur ouvert. Pour plus de sécurité, vous pouvez par ailleurs choisir de valider le chemin de l’URL et de vérifier que l’URL est conforme aux RFC.</p>
     
     <p platform="actionscript">Le code suivant montre un exemple simple de validation de données : toute URL ne commençant pas par http:// ou https:// est rejetée et les URL sont analysées afin de vérifier qu’elles se trouvent dans votre nom de domaine. Il est possible que cet exemple ne soit pas valable pour toutes les applications Web ; vous devez donc évaluer s’il est nécessaire de procéder à des vérifications supplémentaires. </p>
	 
     	<codeblock platform="actionscript">
     // AS3 Regular expression pattern match for URLs that start with http:// and https:// plus your domain name.
     function checkProtocol (flashVarURL:String):Boolean {
        // Get the domain name for the SWF if it is not known at compile time.
        // If the domain is known at compile time, then the following two lines can be replaced with a hard coded string.
        var my_lc:LocalConnection = new LocalConnection();
        var domainName:String = my_lc.domain;
        // Build the RegEx to test the URL.
        // This RegEx assumes that there is at least one "/" after the
        // domain. http://www.mysite.com will not match.
        var pattern:RegExp = new RegExp("^http[s]?\:\\/\\/([^\\/]+)\\/");
        var result:Object = pattern.exec(flashVarURL);
        if (result == null || result[1] != domainName || flashVarURL.length >= 4096) {
          return (false);
        }
        return (true);
     }  
     
     	</codeblock>
	 <p platform="actionscript">Dans le cas d’un contenu <i>local</i> s’exécutant dans un navigateur, les appels à la méthode <codeph>navigateToURL()</codeph> qui spécifient un pseudo-protocole <codeph>"javascript:"</codeph> (via un objet <codeph>URLRequest</codeph> transmis en tant que premier paramètre) ne sont autorisés que si le fichier SWF et la page Web qui le contient (le cas échéant) se trouvent dans le sandbox de sécurité approuvé localement. Certains navigateurs ne prennent pas en charge l’utilisation du protocole javascript avec la méthode <codeph>navigateToURL()</codeph>. Envisagez plutôt d’utiliser la méthode <codeph>call()</codeph> de l’API <codeph>ExternalInterface</codeph> pour appeler les méthodes JavaScript dans la page HTML.</p>
     
      <p platform="actionscript">Dans Flash Player et dans les sandbox non-applicatifs d’Adobe AIR, vous ne pouvez pas utiliser les ports habituellement réservés. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     <p platform="actionscript">Dans Flash Player versions 10 et ultérieures s’exécutant dans un navigateur, il est possible que vous ne puissiez pas utiliser cette méthode par programmation pour ouvrir une fenêtre contextuelle. Certains navigateurs (et configurations de navigateur) peuvent bloquer les fenêtres contextuelles ; il n’est donc pas possible de garantir l’ouverture de toutes les fenêtres contextuelles. Toutefois, pour un résultat optimal, utilisez cette méthode pour ouvrir une fenêtre contextuelle uniquement dans le code qui s’exécute comme conséquence directe de l’action d’un utilisateur (par exemple, un événement de type clic de souris ou pression de touche).</p>
     
     <p platform="actionscript"> Dans Flash Player versions 10 et ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête « content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul platform="actionscript">
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p platform="actionscript">Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     
     <p platform="actionscript">Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul platform="actionscript">
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
     
     </apiDesc><example conref="examples\NavigateToURLExample.as"> L’exemple suivant ouvre l’URL http://www.adobe.com dans une nouvelle fenêtre de navigateur et transmet au serveur Web des données relatives à une session utilisateur, capturées dans un objet URLVariables.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class NavigateToURLExample extends Sprite {

        public function NavigateToURLExample() {
            var url:String = "http://www.adobe.com";
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "Your Name";
            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            try {            
                navigateToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.external.xml#ExternalInterface/call()"><linktext>flash.external.ExternalInterface.call()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:registerClassAlias"><apiName>registerClassAlias</apiName><shortdesc>
     Préserve la classe (type) d’un objet lors de son codage au format AMF (Action Message Format).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Indique si l’un ou l’autre des paramètres est réglé sur <codeph>null</codeph>.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Alias à utiliser.
     </apiDesc></apiParam><apiParam><apiItemName>classObject</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>Classe associée à l’alias indiqué.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Préserve la classe (type) d’un objet lors de son codage au format AMF (Action Message Format). Lorsque vous codez un objet au format AMF, cette fonction enregistre l’alias de sa classe, ce qui vous permet de la récupérer lors du décodage de l’objet. Si le contexte d’encodage n’a pas enregistré d’alias pour la classe d’un objet, celui-ci est codé en tant qu’objet anonyme. De même, si l’alias n’est pas enregistré dans le contexte de décodage, un objet anonyme est créé au décodage.
     
     <p>Toutes les classes LocalConnection, ByteArray, SharedObject, NetConnection et NetStream codent les objets au format AMF.</p>
     
     <p>Il n’est pas nécessaire que les contextes utilisent une même classe pour un alias. Ils peuvent changer de classe intentionnellement, à condition que la classe de destination contienne tous les membres sérialisés par la classe source.</p>
     
     </apiDesc><example conref="examples\RegisterClassAliasExample.as"> Cet exemple utilise la fonction <codeph>registerClassAlias()</codeph> pour enregistrer un alias (<codeph>com.example.eg</codeph>) pour la classe ExampleClass. Un alias étant enregistré pour la classe, l’objet peut être désérialisé en tant qu’occurrence de la classe ExampleClass, et le code renvoie <codeph>true</codeph>. Si l’appel de <codeph>registerClassAlias()</codeph> était supprimé, le code renverrait <codeph>false</codeph>. 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.registerClassAlias;
    import flash.utils.ByteArray;

    public class RegisterClassAliasExample extends Sprite {
        public function RegisterClassAliasExample() {
            registerClassAlias("com.example.eg", ExampleClass);
            var eg1:ExampleClass = new ExampleClass();
            var ba:ByteArray = new ByteArray();
            ba.writeObject(eg1);
            ba.position = 0;
            var eg2:* = ba.readObject();
            trace(eg2 is ExampleClass); // true
        }
    }
}

class ExampleClass {}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>Classe ObjectEncoding</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:sendToURL"><apiName>sendToURL</apiName><shortdesc>
     Envoie une requête d’URL à un serveur, mais ne tient pas compte de la réponse.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
         are not supported by URLLoader.send.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les fichiers SWF locaux et non approuvés ne peuvent pas communiquer avec Internet. Pour contourner ce problème, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Vous ne pouvez pas vous connecter aux ports généralement réservés. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Objet URLRequest indiquant l’URL à laquelle envoyer des données.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
     Envoie une requête d’URL à un serveur, mais ne tient pas compte de la réponse.
     <p>Pour examiner la réponse du serveur, utilisez plutôt la méthode <codeph>URLLoader.load()</codeph>.</p>
     
      <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     <p>Vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</p>
	 
     <p> Dans Flash Player versions 10 et ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête « content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul>
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p>Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     
     <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul>
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
         
         </apiDesc><example conref="examples\SendToURLExample.as"> L’exemple suivant transmet des données relatives à une session utilisateur, capturées dans un objet URLVariables, à l’application qui se trouve à l’adresse http://www.yourDomain.com/application.jsp.
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.net.URLVariables;
    import flash.net.sendToURL;

    public class SendToURLExample extends Sprite {

        public function SendToURLExample() {
            var url:String = "http://www.yourDomain.com/application.jsp";
            var variables:URLVariables = new URLVariables();
            variables.sessionId = new Date().getTime();
            variables.userLabel = "Your Name";

            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            trace("sendToURL: " + request.url + "?" + request.data);
            try {
                sendToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiClassifier id="flash.net:Responder"><apiName>Responder</apiName><shortdesc>
 La classe Responder fournit un objet utilisé dans NetConnection.call() pour gérer les valeurs renvoyées par le serveur selon la réussite ou l’échec de certaines opérations.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Responder fournit un objet utilisé dans <codeph>NetConnection.call()</codeph> pour gérer les valeurs renvoyées par le serveur selon la réussite ou l’échec de certaines opérations. Lors de l’utilisation de <codeph>NetConnection.call()</codeph>, il se peut que vous rencontriez une erreur d’opération réseau spécifique à l’opération en cours ou une erreur liée à l’état actuel de la connexion. Les erreurs d’opération ciblent l’objet Responder et non l’objet NetConnection pour faciliter le traitement des erreurs.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links><apiConstructor id="flash.net:Responder:Responder"><apiName>Responder</apiName><shortdesc>
	 Crée un objet Responder.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>result</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Fonction invoquée si l’appel du serveur aboutit et renvoie un résultat.
	 </apiDesc></apiParam><apiParam><apiItemName>status</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiData>null</apiData><apiDesc>Fonction appelée si le serveur renvoie une erreur.
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet Responder. Vous transmettez un objet Responder à la méthode <codeph>NetConnection.call()</codeph> pour gérer les valeurs renvoyées par le serveur. Vous pouvez transmettre la valeur <codeph>null</codeph> pour l’un et/ou l’autre des paramètres.
	 
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.net:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
 Un objet URLRequestHeader encapsule un en-tête de requête HTTP unique et se compose d’une paire nom/valeur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Un objet URLRequestHeader encapsule un en-tête de requête HTTP unique et se compose d’une paire nom/valeur. Les objets URLRequestHeader sont utilisés dans la propriété <codeph>requestHeaders</codeph> de la classe URLRequest.
 
 <p>Dans Adobe<sup>®</sup> AIR, le contenu du sandbox de sécurité de l’application (par exemple, le contenu installé avec l’application AIR) peut utiliser n’importe quel en-tête de requête, sans qu’aucune erreur ne se produise. En revanche, dans le cas de contenu s’exécutant dans Adobe AIR et se trouvant dans un sandbox de sécurité différent <ph outputclass="actionscript">ou dans le cas de contenu s’exécutant dans Flash<sup>®</sup> Player,</ph> l’utilisation de ces en-têtes de requête entraîne le renvoi d’une erreur d’exécution ; en outre, les termes restreints ne sont pas sensibles à la casse (par exemple, <codeph>Get</codeph>, <codeph>get</codeph> et <codeph>GET</codeph> ne sont pas tous autorisés) : </p>
 
 <p>Dans le cas de contenu s’exécutant dans Flash Player ou de contenu s’exécutant dans Adobe AIR hors du sandbox de sécurité de l’application, les en-têtes de requête suivants ne peuvent pas être utilisés et les termes restreints ne sont pas sensibles à la casse (par exemple, <codeph>Get</codeph>, <codeph>get</codeph> et <codeph>GET</codeph> ne sont pas tous autorisés). De même, les termes composés s’appliquent lorsqu’un caractère de soulignement est utilisé (par exemple, <codeph>Content-Length</codeph> et <codeph>Content_Length</codeph> ne sont pas autorisés tous les deux) : </p>
 
 <p><codeph>Accept-Charset</codeph>, <codeph>Accept-Encoding</codeph>, <codeph>Accept-Ranges</codeph>, <codeph>Age</codeph>, <codeph>Allow</codeph>, <codeph>Allowed</codeph>, <codeph>Authorization</codeph>, <codeph>Charge-To</codeph>, <codeph>Connect</codeph>, <codeph>Connection</codeph>, <codeph>Content-Length</codeph>, <codeph>Content-Location</codeph>, <codeph>Content-Range</codeph>, <codeph>Cookie</codeph>, <codeph>Date</codeph>, <codeph>Delete</codeph>, <codeph>ETag</codeph>, <codeph>Expect</codeph>, <codeph>Get</codeph>, <codeph>Head</codeph>, <codeph>Host</codeph>, <codeph>Keep-Alive</codeph>, <codeph>Last-Modified</codeph>, <codeph>Location</codeph>, <codeph>Max-Forwards</codeph>, <codeph>Options</codeph>, <codeph>Origin</codeph>, <codeph>Post</codeph>, <codeph>Proxy-Authenticate</codeph>, <codeph>Proxy-Authorization</codeph>, <codeph>Proxy-Connection</codeph>, <codeph>Public</codeph>, <codeph>Put</codeph>, <codeph>Range</codeph>, <codeph>Referer</codeph>, <codeph>Request-Range</codeph>, <codeph>Retry-After</codeph>, <codeph>Server</codeph>, <codeph>TE</codeph>, <codeph>Trace</codeph>, <codeph>Trailer</codeph>, <codeph>Transfer-Encoding</codeph>, <codeph>Upgrade</codeph>, <codeph>URI</codeph>, <codeph>User-Agent</codeph>, <codeph>Vary</codeph>, <codeph>Via</codeph>, <codeph>Warning</codeph>, <codeph>WWW-Authenticate</codeph>, <codeph>x-flash-version</codeph>.</p>
 
 <p>La longueur des objets URLRequestHeader est limitée. Si la longueur totale d’un objet URLRequestHeader (longueur de la propriété <codeph>name</codeph> et de la propriété <codeph>value</codeph>) ou d’un tableau d’objets URLRequestHeader utilisé dans la propriété <codeph>URLRequest.requestHeaders</codeph> est supérieure à la longueur prise en charge, une exception est renvoyée.</p>
 
 <p>Le contenu s’exécutant dans Adobe AIR définit l’en-tête <codeph>ACCEPT</codeph> de la façon suivante, à moins que vous ne spécifiez un paramètre pour l’en-tête <codeph>ACCEPT</codeph> dans la propriété <codeph>requestHeaders</codeph> de la classe URLRequest :</p>
 
 <codeph>text/xml, application/xml, application/xhtml+xml, text/html;q=0.9, text/plain;q=0.8, image/png, application/x-shockwave-flash, video/mp4;q=0.9, flv-application/octet-stream;q=0.8, video/x-flv;q=0.7, audio/mp4, ~~/~~;q=0.5</codeph>
 <p>Toutes les méthodes qui acceptent des paramètres URLRequest ne prennent pas en charge la propriété <codeph>requestHeaders</codeph> ; consultez la documentation de la méthode que vous appelez. Par exemple, les méthodes <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph> ne prennent pas en charge la propriété <codeph>URLRequest.requestHeaders</codeph>.</p>
 <p>Du fait des limites des navigateurs, les en-têtes de requête HTTP personnalisées ne sont prises en charge que pour les requêtes <codeph>POST</codeph>, pas pour les requêtes <codeph>GET</codeph>.</p>  
 
 </apiDesc><example conref="examples\URLRequestHeaderExample.as"> L’exemple suivant ajoute un seul en-tête de requête HTTP <codeph>header</codeph> au tableau de la propriété <codeph>requestHeaders</codeph>. L’en-tête indique que l’application doit transférer la requête au serveur d’origine, même si elle en possède une copie mise en cache.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.net.URLRequestHeader;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequestHeaderExample extends Sprite {
        public function URLRequestHeaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var header:URLRequestHeader = new URLRequestHeader("pragma", "no-cache");
            var request:URLRequest = new URLRequest("http://www.[yourdomain].com/greeting.cfm");
            request.data = new URLVariables("name=John+Doe");
            request.method = URLRequestMethod.POST;
            request.requestHeaders.push(header);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLRequestHeader:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
	 Crée un objet URLRequestHeader qui encapsule un en-tête de requête HTTP unique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Nom d’en-tête de requête HTTP (<codeph>Content-Type</codeph> ou <codeph>SOAPAction</codeph>, par exemple).
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Valeur associée à la propriété <codeph>name</codeph> (<codeph>text/plain</codeph>, par exemple).
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un objet URLRequestHeader qui encapsule un en-tête de requête HTTP unique. Les objets URLRequestHeader sont utilisés dans la propriété <codeph>requestHeaders</codeph> de la classe URLRequest.
     
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:URLRequestHeader:name"><apiName>name</apiName><shortdesc>
	 Nom d’en-tête de requête HTTP (tel que Contenu-Type ou SOAPAction).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Nom d’en-tête de requête HTTP (<codeph>Content-Type</codeph> ou <codeph>SOAPAction</codeph>, par exemple).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestHeader:value"><apiName>value</apiName><shortdesc>
	 Valeur associée à la propriété name (telle que text/plain).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur associée à la propriété <codeph>name</codeph> (<codeph>text/plain</codeph>, par exemple).
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequestMethod"><apiName>URLRequestMethod</apiName><shortdesc>
 La classe URLRequestMethod fournit des valeurs qui spécifient si l’objet URLRequest doit utiliser la méthode POST ou GET pour envoyer des données à un serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe URLRequestMethod fournit des valeurs qui spécifient si l’objet URLRequest doit utiliser la méthode <codeph>POST</codeph> ou <codeph>GET</codeph> pour envoyer des données à un serveur.
 
 </apiDesc><example conref="examples\URLRequestMethodExample.as"> L’exemple suivant charge et affiche les données détectées dans un fichier texte local. Il assure également le suivi des informations de gestion des événements.
 
 <p><b>Remarque :</b>pour exécuter cet exemple, placez un fichier nommé example.txt dans le même répertoire que votre fichier SWF. Il doit s’agir d’un fichier de texte contenant simplement quelques mots ou lignes de texte.
 </p>
 <p>Le code de l’exemple effectue les opérations suivantes :</p>
 <ol>
    <li>La fonction constructeur crée une occurrence de URLLoader nommée <codeph>loader</codeph>.</li>
    <li>L’objet <codeph>loader</codeph> est transmis à la méthode <codeph>configureListeners()</codeph>, qui ajoute des écouteurs à chacun des événements URLLoader pris en charge.</li>
  <li>Une occurrence de URLRequest appelée <codeph>request</codeph> est créée. Elle représente le nom du fichier à charger.</li>
  <li>La propriété <codeph>method</codeph> de la requête est définie sur <codeph>URLRequestMethod.POST</codeph>.</li>
    <li>L’objet <codeph>request</codeph> est ensuite transmis à la méthode <codeph>loader.load()</codeph>, qui charge le fichier texte.</li>
  <li>Lorsque l’URLLoader a terminé de chargé le fichier texte, l’événement <codeph>Event.COMPLETE</codeph> se produit et déclenche la méthode <codeph>completeHandler()</codeph>. La méthode <codeph>completeHandler()</codeph> recherche simplement la propriété <codeph>data</codeph>, qui représente le contenu du fichier.</li>
 </ol>
<codeblock>


package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestMethodExample extends Sprite {

        public function URLRequestMethodExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("example.txt");
            
            request.method = URLRequestMethod.POST;
            loader.load(request);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link></related-links><apiValue id="flash.net:URLRequestMethod:DELETE"><apiName>DELETE</apiName><shortdesc>
	 Indique que l’objet URLRequest correspond à DELETE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>DELETE</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’objet URLRequest correspond à <codeph>DELETE</codeph>.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:GET"><apiName>GET</apiName><shortdesc>
	 Indique que l’objet URLRequest correspond à GET.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>GET</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’objet URLRequest correspond à <codeph>GET</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:HEAD"><apiName>HEAD</apiName><shortdesc>
	 Indique que l’objet URLRequest correspond à HEAD.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>HEAD</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’objet URLRequest correspond à <codeph>HEAD</codeph>.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:OPTIONS"><apiName>OPTIONS</apiName><shortdesc>
	 Indique que l’objet URLRequest correspond à OPTIONS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>OPTIONS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’objet URLRequest correspond à <codeph>OPTIONS</codeph>.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:POST"><apiName>POST</apiName><shortdesc>
	 Indique que l’objet URLRequest correspond à POST.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>POST</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’objet URLRequest correspond à <codeph>POST</codeph>.
	 
	 <p><i>Remarque :</i> <ph platform="actionscript">pour le contenu s’exécutant dans Adobe AIR, lors de</ph><ph platform="javascript">lors de</ph> l’utilisation de la fonction <codeph>navigateToURL()</codeph>, le moteur d’exécution traite un objet URLRequest qui utilise la méthode POST (objet dont la propriété <codeph>method</codeph> est définie sur <codeph>URLRequestMethod.POST</codeph>) comme s’il utilisait la méthode GET.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:PUT"><apiName>PUT</apiName><shortdesc>
	 Indique que l’objet URLRequest correspond à PUT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>PUT</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’objet URLRequest correspond à <codeph>PUT</codeph>.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 La classe FileReferenceList permet aux utilisateurs de sélectionner un ou plusieurs fichiers à charger.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReferenceList
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Permet de charger un ou plusieurs fichiers.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe FileReferenceList permet aux utilisateurs de sélectionner un ou plusieurs fichiers à charger. Un objet FileReferenceList représente un groupe de fichiers locaux présents dans le disque de l’utilisateur sous forme de tableau d’objets FileReference. Pour obtenir des informations détaillées et les principales caractéristiques relatives aux objets et à la classe FileReference, que vous utilisez avec FileReferenceList, voir la classe FileReference.
 
 <p>Pour utiliser la classe FileReferenceList :</p>
 <ul>
 <li>Instanciez la classe : <codeph>var myFileRef = new FileReferenceList();</codeph></li>
 <li>Appelez la méthode <codeph>FileReferenceList.browse()</codeph>, pour afficher une boîte de dialogue dans laquelle l’utilisateur peut choisir un ou plusieurs fichiers à charger : <codeph>myFileRef.browse();</codeph></li>
 <li>Après l’appel de la méthode <codeph>browse()</codeph>, la propriété <codeph>fileList</codeph> de l’objet FileReferenceList est renseignée à l’aide d’un tableau d’objets FileReference.</li>
 <li>Appelez <codeph>FileReference.upload()</codeph> sur chaque élément du tableau <codeph>fileList</codeph>.</li>
 </ul>
 
 <p>La classe FileReferenceList comprend une méthode <codeph>browse()</codeph> et une propriété <codeph>fileList</codeph> pour travailler avec plusieurs fichiers. Lors de l’exécution d’un appel à la méthode <codeph>FileReferenceList.browse()</codeph>, la lecture du fichier SWF s’interrompt dans les versions autonomes et externes de Flash Player et AIR pour Linux, et Mac OS X version 10.1 et antérieures.</p>
 
 </apiDesc><example conref="examples\FileReferenceListExample.as"> L’exemple suivant indique comment utiliser des événements pour gérer le chargement de plusieurs fichiers. La classe CustomFileReferenceList étend FileReferenceList et comprend un événement <codeph>complete</codeph>, distribué au chargement de chaque fichier que contient l’objet FileReferenceList. L’événement <codeph>LIST_COMPLETE</codeph> de la classe FileReferenceListExample est distribué après le chargement de tous les fichiers de l’objet FileReferenceList.
 
 <p>Pour exécuter cet exemple, placez un script conçu pour accepter un chargement de fichiers à l’adresse http://www.[yourDomain].com/yourUploadHandlerScript.cfm. Selon l’emplacement de votre fichier SWF et la destination des fichiers à charger, vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash<sup>®</sup> Player pour autoriser ce fichier à accéder au réseau. Si le serveur de chargement est distant et que vous exécutez cet exemple depuis votre ordinateur de bureau, assurez-vous que le serveur contienne un fichier crossdomain.xml.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.FileReferenceList;
 
    public class FileReferenceListExample extends Sprite {
        public static var LIST_COMPLETE:String = "listComplete";
        public function FileReferenceListExample() {
            initiateFileUpload();
        }

        private function initiateFileUpload():void {
            var fileRef:CustomFileReferenceList = new CustomFileReferenceList();
            fileRef.addEventListener(FileReferenceListExample.LIST_COMPLETE, listCompleteHandler);
            fileRef.browse(fileRef.getTypes());
        }

        private function listCompleteHandler(event:Event):void {
            trace("listCompleteHandler");
        }
    }
}
 
import flash.events.*;
import flash.net.FileReference;
import flash.net.FileReferenceList;
import flash.net.FileFilter;
import flash.net.URLRequest;
 
class CustomFileReferenceList extends FileReferenceList {
    private var uploadURL:URLRequest;
    private var pendingFiles:Array;

    public function CustomFileReferenceList() {
        uploadURL = new URLRequest();
        uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
        initializeListListeners();
    }

    private function initializeListListeners():void {
        addEventListener(Event.SELECT, selectHandler);
        addEventListener(Event.CANCEL, cancelHandler);
    }

    public function getTypes():Array {
        var allTypes:Array = new Array();
        allTypes.push(getImageTypeFilter());
        allTypes.push(getTextTypeFilter());
        return allTypes;
    }
 
    private function getImageTypeFilter():FileFilter {
        return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
    }
 
    private function getTextTypeFilter():FileFilter {
        return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
    }
 
    private function doOnComplete():void {
        var event:Event = new Event(FileReferenceListExample.LIST_COMPLETE);
        dispatchEvent(event);
    }
 
    private function addPendingFile(file:FileReference):void {
        trace("addPendingFile: name=" + file.name);
        pendingFiles.push(file);
        file.addEventListener(Event.OPEN, openHandler);
        file.addEventListener(Event.COMPLETE, completeHandler);
        file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
        file.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        file.upload(uploadURL);
    }
 
    private function removePendingFile(file:FileReference):void {
        for (var i:uint; i &lt; pendingFiles.length; i++) {
            if (pendingFiles[i].name == file.name) {
                pendingFiles.splice(i, 1);
                if (pendingFiles.length == 0) {
                    doOnComplete();
                }
                return;
            }
        }
    }
 
    private function selectHandler(event:Event):void {
        trace("selectHandler: " + fileList.length + " files");
        pendingFiles = new Array();
        var file:FileReference;
        for (var i:uint = 0; i &lt; fileList.length; i++) {
            file = FileReference(fileList[i]);
            addPendingFile(file);
        }
    }
 
    private function cancelHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("cancelHandler: name=" + file.name);
    }
 
    private function openHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("openHandler: name=" + file.name);
    }
 
    private function progressHandler(event:ProgressEvent):void {
        var file:FileReference = FileReference(event.target);
        trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
    }
 
    private function completeHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("completeHandler: name=" + file.name);
        removePendingFile(file);
    }
 
    private function httpErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("httpErrorHandler: name=" + file.name);
    }
 
    private function ioErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("ioErrorHandler: name=" + file.name);
    }
 
    private function securityErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("securityErrorHandler: name=" + file.name + " event=" + event.toString());
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 Distribué lorsque l’utilisateur sélectionne un ou plusieurs fichiers à charger dans la boîte de dialogue de recherche de fichiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the usage of the <code>select</code> event.
 <listing version="2.0">
 import flash.net.FileReferenceList;
 import flash.net.FileReference;
 
 var listener:Object = new Object();
 
 listener.onSelect = function(fileRefList:FileReferenceList) {
 	trace("onSelect");
 	var list:Array = fileRefList.fileList;
 	var item:FileReference;
 	for(var i:Number = 0; i &lt; list.length; i++) {
 		item = list[i];
 		trace("name: " + item.name);
 		trace(item.addListener(this));
 		item.upload("http://www.yourdomain.com/");
 	}
 }
 
 listener.onComplete = function(file:FileReference):void {
 	trace("onComplete: " + file.name);
 }
 
 var fileRef:FileReferenceList = new FileReferenceList();
 fileRef.addListener(listener);
 fileRef.browse();
 </listing>
 </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur sélectionne un ou plusieurs fichiers à charger dans la boîte de dialogue de recherche de fichiers (cette boîte de dialogue s’ouvre quand vous appelez la méthode <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> ou <codeph>FileReference.download()</codeph>). Lorsque l’utilisateur sélectionne un fichier et confirme l’opération (par exemple, en cliquant sur Enregistrer), l’objet <codeph>FileReferenceList</codeph> est renseigné par les objets FileReference représentant les fichiers sélectionnés par l’utilisateur.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Distribué lorsque l’utilisateur ferme la boîte de dialogue de recherche de fichiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’utilisateur ferme la boîte de dialogue de recherche de fichiers (cette boîte de dialogue s’ouvre quand vous appelez la méthode <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> ou <codeph>FileReference.download()</codeph>).
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:FileReferenceList:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 	 Crée un nouvel objet FileReferenceList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReferenceList</code> object,
	 iterates over each selected file, and outputs their names.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var arr:Array = fileRefList.fileList;
	 	for(var i:Number = 0; i &lt; arr.length; i++) {
	 		trace("name: " + arr[i].name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
  	 
  	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 	 Crée un nouvel objet FileReferenceList. Tout objet FileReferenceList reste vide tant que vous n’avez pas appelé pour lui la méthode <codeph>browse()</codeph> et que l’utilisateur n’a pas sélectionné de fichiers. Quand vous appelez <codeph>browse()</codeph> sur l’objet FileReference, sa propriété <codeph>fileList</codeph> est renseignée par un tableau d’objets <codeph>FileReference</codeph>.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReferenceList:browse"><apiName>browse</apiName><shortdesc>
	 Affiche une boîte de dialogue de recherche de fichiers dans laquelle l’utilisateur peut sélectionner un ou plusieurs fichiers locaux à charger.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample><pre>
	 // ask the user to choose an image file for upload
	 var fileRef = new FileReference();
	 if (fileRef.browse(["Images", "jpg;gif;png", "Flash Movies", "swf"])) {
	   trace("Opened " + fileRef.name);
	 } else {
	   trace("User canceled");
	 }
	 </pre>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse FileReference ou FileReferenceList est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) Un paramètre du fichier mms.cfg de l’utilisateur bloque cette opération. 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Une exception est renvoyée si le tableau <codeph>typeFilter</codeph> contient des objets FileFilter incorrectement formatés. Pour plus d’informations sur le formatage correct des filtres, voir la documentation FileFilter.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si la méthode n’est pas appelée en réponse à l’action d’un utilisateur, notamment à un événement de type souris ou pression de touche.
     
	  
	  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si les paramètres sont valides et que la boîte de dialogue de recherche de fichiers est ouverte.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau d’occurrences de FileFilter utilisé pour filtrer les fichiers qui s’affichent dans la boîte de dialogue. Si vous omettez ce paramètre, tous les fichiers s’affichent. Pour plus d’informations, voir la classe <xref href="FileFilter.html">FileFilter</xref>. 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Affiche une boîte de dialogue de recherche de fichiers dans laquelle l’utilisateur peut sélectionner des fichiers locaux à charger.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Affiche une boîte de dialogue de recherche de fichiers dans laquelle l’utilisateur peut sélectionner un ou plusieurs fichiers locaux à charger. La boîte de dialogue est spécifique au système d’exploitation de l’utilisateur.
	 
	 <p platform="actionscript">Dans Flash Player versions 10 et ultérieures, l’appel de cette méthode aboutit uniquement en réponse à un événement utilisateur (par exemple, un événement de type clic de souris ou pression de touche). Dans les autres cas, Flash Player renvoie une erreur à l’appel de cette méthode.</p>
	 
	 <p>Lorsque vous appelez cette méthode et que l’utilisateur réussit à sélectionner des fichiers, la propriété <codeph>fileList</codeph> de cet objet FileReferenceList est renseignée par un tableau d’objets FileReference, à raison d’un objet pour chaque fichier sélectionné par l’utilisateur. Par la suite, à chaque appel de la méthode FileReferenceList.browse(), la propriété <codeph>FileReferenceList.fileList</codeph> est réinitialisée en fonction des fichiers sélectionnés par l’utilisateur dans la boîte de dialogue.</p>
	 
	 <p>Le paramètre <codeph>typeFilter</codeph> vous permet de déterminer les fichiers répertoriés dans la boîte de dialogue.</p>
	 
	 <p>Une seule session <codeph>FileReference.browse()</codeph>, <codeph>FileReference.download()</codeph> ou <codeph>FileReferenceList.browse()</codeph> peut être effectuée à la fois sur un objet FileReferenceList (car une seule boîte de dialogue peut être ouverte à la fois).</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference"><linktext>Classe FileReference</linktext></link><link href="flash.net.xml#FileFilter"><linktext>FileFilter, classe</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Appelé lorsque l’utilisateur est parvenu à sélectionner un élément à charger dans la boîte de dialogue.
	 </apiDesc></adobeApiEventDetail><shortdesc>Appelé quand l’utilisateur réussit à sélectionner un élément à charger dans la boîte de dialogue.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Appelé lorsque l’utilisateur quitte la boîte de dialogue en cliquant sur Annuler ou en la fermant.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Appelé quand l’utilisateur quitte la boîte de dialogue en cliquant sur Annuler ou en la fermant.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReferenceList:fileList:get"><apiName>fileList</apiName><shortdesc>
	 Un tableau d’objets FileReference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example demonstrates the <code>fileList</code> property.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 import flash.net.FileReference;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var list:Array = fileRefList.fileList;
	 	var item:FileReference;
	 	for(var i:Number = 0; i &lt; list.length; i++) {
	 		item = list[i];
	 		trace("name: " + item.name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
	 
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>Un tableau d’objets FileReference.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Tableau d’objets <codeph>FileReference</codeph>.
	 
	 <p>Quand la méthode <codeph>FileReferenceList.browse()</codeph> est appelée et que l’utilisateur a sélectionné un ou plusieurs fichiers dans la boîte de dialogue ouverte par la méthode <codeph>browse()</codeph>, cette propriété est renseignée par un tableau d’objets FileReference qui représentent les fichiers que l’utilisateur a sélectionnés. Vous pouvez ensuite utiliser ce tableau pour charger les fichiers par le biais de la méthode <codeph>FileReference.upload()</codeph>. Vous devez charger les fichiers un par un.</p>
	 
	 <p>La propriété <codeph>fileList</codeph> est renseignée à nouveau à chaque appel de la méthode browse() sur cet objet FileReferenceList.</p>
	 
	 <p>Les propriétés des objets <codeph>FileReference</codeph> sont décrites dans la documentation relative à la classe FileReference.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileReference"><apiName>FileReference</apiName><shortdesc>
  La classe FileReference permet de charger et télécharger des fichiers entre l’ordinateur d’un utilisateur et un serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReference, FileReference.browse, FileReference.download, FileReference.create, browse, download, create
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  La classe FileReference permet de charger et télécharger des fichiers entre l’ordinateur d’un utilisateur et un serveur. Une boîte de dialogue du système d’exploitation invite l’utilisateur à sélectionner un fichier pour le charger ou à choisir un emplacement pour le télécharger. Chaque objet FileReference fait référence à un seul fichier sur le disque dur de l’utilisateur et inclut des propriétés contenant des informations sur la taille, le type, le nom, la date de création, la date de modification et le type de créateur (Macintosh uniquement) du fichier. 
  
  <p><b>Remarque :</b> dans Adobe AIR, la classe File, qui étend la classe FileReference, offre davantage de fonctionnalités et moins de restrictions de sécurité que la classe FileReference.</p>
  
  <p>Les occurrences de FileReference sont créées de diverses manières :</p>
  <ul>
  <li>Lorsque vous utilisez l’opérateur <codeph>new</codeph> avec le constructeur FileReference : <codeph>var myFileReference = new FileReference();</codeph></li>
  
  <li>Lorsque vous appelez la méthode <codeph>FileReferenceList.browse()</codeph>, ce qui crée un tableau d’objets FileReference.</li>
  </ul>
  
  <p>Pendant une opération de chargement, toutes les propriétés d’un objet FileReference sont renseignées par des appels des méthodes <codeph>FileReference.browse()</codeph> ou <codeph>FileReferenceList.browse()</codeph>. Pendant une opération de téléchargement, la propriété <codeph>name</codeph> est renseignée lors de la distribution de l’événement <codeph>select</codeph>. Toutes les autres propriétés sont renseignées lors de la distribution de l’événement <codeph>complete</codeph>.</p>
  
  <p>La méthode <codeph>browse()</codeph> ouvre une boîte de dialogue du système d’exploitation qui invite l’utilisateur à sélectionner un fichier en vue de le charger. La méthode <codeph>FileReference.browse()</codeph> permet à l’utilisateur de choisir un seul fichier ; la méthode <codeph>FileReferenceList.browse()</codeph> lui permet d’en sélectionner plusieurs. Lorsque l’appel de la méthode <codeph>browse()</codeph> a réussi, appelez la méthode <codeph>FileReference.upload()</codeph> pour charger un seul fichier à la fois. La méthode <codeph>FileReference.download()</codeph> invite l’utilisateur à sélectionner un emplacement pour enregistrer le fichier et initialise le téléchargement à partir d’une URL distante.</p>
  
  <p>Les classes FileReference et FileReferenceList ne vous permettent pas de définir un emplacement de fichier par défaut pour la boîte de dialogue générée par les méthodes <codeph>browse()</codeph> et <codeph>download()</codeph>. L’emplacement par défaut indiqué dans la boîte de dialogue est le dernier dossier parcouru, dans la mesure où il est possible de déterminer cet emplacement, ou le Bureau. Les classes ne vous permettent pas d’accéder aux fichiers transférés en lecture ou en écriture. Elles ne permettent pas au fichier SWF qui a initié le chargement ou le téléchargement d’accéder au fichier chargé ou à l’emplacement du fichier sur le disque de l’utilisateur.</p>
  
  <p>Par ailleurs, les classes FileReference et FileReferenceList ne proposent pas de méthode d’authentification. Pour les serveurs ayant besoin d’une authentification, vous pouvez télécharger des fichiers avec le plug-in de navigation de Flash<sup>®</sup> Player, mais le chargement (sur tous les lecteurs) et le téléchargement (sur les lecteurs autonomes ou externes) échouent. Utilisez les écouteurs d’événement FileReference afin de déterminer si les opérations ont réussi, ou non, et pour traiter les erreurs.</p>
  
  <p>Dans le cas de contenus s’exécutant dans <ph platform="actionscript">Flash Player ou </ph>Adobe AIR hors du sandbox de sécurité de l’application, les opérations de chargement ou de téléchargement permettent d’accéder uniquement aux fichiers de leur propre domaine et de tous les domaines spécifiés par un fichier de régulation d’URL. Si le contenu qui initialise le chargement ou le téléchargement n’appartient pas au même domaine que le serveur de fichiers, placez un fichier de régulation dans ce dernier.</p>
  
  <p>Notez que lors de la publication dans Flash Player 10, les nouvelles fonctionnalités ajoutées au lecteur ne vous permettent d’exécuter qu’une seule opération à la fois : <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> ou <codeph>FileReference.save()</codeph>. Dans le cas contraire, Flash Player renvoie une erreur d’exécution (code 2174). Utilisez <codeph>FileReference.cancel()</codeph> pour arrêter une opération en cours. Cette restriction s’applique uniquement à Flash Player 10. Cette restriction sur l’exécution simultanée de plusieurs opérations ne s’applique pas aux versions précédentes de Flash Player.</p>
  
  <p platform="actionscript">Pendant l’exécution des appels aux méthodes <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph>, la lecture du fichier SWF s’interrompt dans les versions autonomes et externes de Flash Player et AIR pour Linux, et Mac OS X version 10.1 et antérieures.</p>
  
  <p platform="actionscript">Flash Player envoie la requête HTTP <codeph>POST</codeph> suivante, par exemple, à un script côté serveur en l’absence de paramètres :
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  
  <p platform="actionscript">Flash Player envoie la requête HTTP <codeph>POST</codeph> suivante si l’utilisateur spécifie les paramètres <codeph>api_sig</codeph>, <codeph>api_key</codeph> et <codeph>auth_token</codeph> :
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_sig"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_key"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="auth_token"
  
  XXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  </apiDesc><example conref="examples\FileReferenceExample.as"> L’exemple suivant affiche le format de données et l’état d’un fichier chargé à l’exécution.  
 <p> <b>Remarque :</b> pour exécuter cet exemple, modifiez la propriété uploadURL.url pour qu’elle pointe sur une URL réelle, au lieu de l’adresse fictive de l’exemple. L’URL doit pointer sur un fichier nommé <codeph>yourUploadHandlerScript.cfm</codeph> dans le répertoire Web racine de l’URL spécifiée. Selon votre configuration, vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash Player pour autoriser ce fichier à accéder au réseau.
 </p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileFilter;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReferenceExample extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReferenceExample() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            configureListeners(file);
            file.browse(getTypes());
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
            dispatcher.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA,uploadCompleteDataHandler);
        }

        private function getTypes():Array {
            var allTypes:Array = new Array(getImageTypeFilter(), getTextTypeFilter());
            return allTypes;
        }

        private function getImageTypeFilter():FileFilter {
            return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
        }

        private function getTextTypeFilter():FileFilter {
            return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function uploadCompleteDataHandler(event:DataEvent):void {
            trace("uploadCompleteData: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReferenceList"><linktext>flash.net.FileReferenceList</linktext></link><link href="flash.filesystem.xml#File"><linktext>flash.filesystem.File</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference_flash.events.DataEvent.UPLOAD_COMPLETE_DATA_uploadCompleteData"><apiName>uploadCompleteData</apiName><shortdesc>
    Distribué après réception des données par le serveur suite à un chargement réussi.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.UPLOAD_COMPLETE_DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
    Distribué après réception des données par le serveur suite à un chargement réussi. Cet événement n’est pas distribué si le serveur ne renvoie pas les données.
    </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
	 Distribué si un appel de la méthode upload() ou uploadUnencoded() tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Distribué si un appel de la méthode <codeph>upload()</codeph> ou <codeph>uploadUnencoded()</codeph> tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête. 
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link><link href="flash.net.xml#FileReference/uploadUnencoded()"><linktext>uploadUnencoded()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
     Distribué lorsqu’un chargement échoue et qu’il existe un code d’état HTTP décrivant l’échec. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Distribué lorsqu’un chargement échoue et qu’il existe un code d’état HTTP décrivant l’échec. L’événement <codeph>httpStatus</codeph> est distribué et suivi de l’événement <codeph>ioError</codeph>.
     
     <p>L’événement <codeph>httpStatus</codeph> est uniquement distribué en cas d’échec d’un chargement. Dans le cas de contenu s’exécutant dans Flash Player, cet événement ne s’applique pas aux échecs de téléchargement. Si un téléchargement échoue en raison d’une erreur HTTP, l’erreur est signalée en tant qu’erreur d’E/S.</p>
     
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
	Distribué lorsque l’utilisateur sélectionne un fichier à charger ou télécharger dans la ﻿﻿﻿boîte de dialogue de recherche de fichiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Distribué lorsque l’utilisateur sélectionne un fichier à charger ou télécharger dans la boîte de dialogue de recherche de fichiers (cette boîte de dialogue s’ouvre quand vous appelez la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph>). Lorsque l’utilisateur sélectionne un fichier et confirme l’opération (par exemple, en cliquant sur OK), les propriétés de l’objet FileReference sont renseignées.
    
    <p>Dans le cas de contenu s’exécutant <ph platform="actionscript">dans Flash Player ou </ph>hors du sandbox de sécurité de l’application<ph platform="actionscript"> dans le moteur d’exécution Adobe AIR</ph>, l’événement <codeph>select</codeph> fonctionne légèrement différemment selon la méthode qui l’appelle. Lorsque l’événement <codeph>select</codeph> est distribué après un appel à <codeph>browse()</codeph>, <ph platform="actionscript">Flash Player </ph>ou l’application AIR peut lire toutes les propriétés de l’objet FileReference, car le fichier choisi se trouve dans le système de fichiers local. Lorsque l’événement <codeph>select</codeph> se produit après un appel à <codeph>download()</codeph>, <ph platform="actionscript">Flash Player ou </ph>l’application AIR peut uniquement lire la propriété <codeph>name</codeph>, car le fichier n’a pas encore été téléchargé dans le système de fichiers local au moment où l’événement <codeph>select</codeph> se produit. Une fois le fichier téléchargé et l’événement <codeph>complete</codeph> distribué, <ph platform="actionscript">Flash Player ou </ph>l’application AIR peut lire toutes les autres propriétés de l’objet FileReference.</p>
    
    </apiDesc><example conref="examples\FileReference_event_select.as"> L’exemple suivant illustre l’utilisation de l’objet événement <codeph>select</codeph>. Pour exécuter cet exemple, modifiez la propriété <codeph>downloadURL.url</codeph> de sorte qu’elle pointe vers un domaine et un fichier réels, au lieu de l’adresse fictive http://www.[yourDomain].com/SomeFile.pdf. Il se peut que vous deviez également compiler le fichier SWF en réglant Sécurité de lecture locale sur Accès au réseau uniquement ou mettre à jour les paramètres de sécurité de Flash Player de façon à permettre un accès réseau à ce fichier. Pour que cet exemple s’exécute à partir de votre bureau, un fichier crossdomain.xml doit également résider sur votre serveur. Si la fonction <codeph>ioErrorHandler()</codeph> est déclenchée, vous devrez probablement mettre à jour la définition de la propriété <codeph>uploadURL</codeph> avec une URL valide configurée pour recevoir les chargements.
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_select extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReference_event_select() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            file.addEventListener(Event.SELECT, selectHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.browse();
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
     Distribué lorsqu’un appel de la méthode FileReference.upload() ou FileReference.download() tente de charger un fichier sur un serveur ou d’extraire un fichier d’un serveur qui se trouve hors du sandbox de sécurité de l’appelant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Distribué lorsqu’un appel de la méthode <codeph>FileReference.upload()</codeph> ou <codeph>FileReference.download()</codeph> tente de charger un fichier sur un serveur ou d’extraire un fichier d’un serveur qui se trouve hors du sandbox de sécurité de l’appelant. En règle générale, la valeur de la propriété text qui décrit l’erreur spécifique qui s’est produite correspond à <codeph>securitySandboxError</codeph>. Le fichier SWF effectuant l’appel a peut-être tenté d’accéder à un fichier SWF hors de son domaine et sans l’autorisation nécessaire. Vous pouvez tenter de remédier à cette erreur à l’aide d’un fichier de régulation d’URL.
     
     <p>Dans Adobe AIR, le contenu du sandbox de sécurité de l’application n’est pas soumis à ces restrictions de sécurité.</p>
     
	 <p>Dans Adobe AIR, le contenu du sandbox de sécurité de l’application n’est pas soumis à ces restrictions de sécurité.</p>
	 
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
	Distribué régulièrement pendant l’opération de chargement ou de téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Distribué régulièrement pendant l’opération de chargement ou de téléchargement. L’événement <codeph>progress</codeph> est distribué pendant que Flash Player transmet des octets à un serveur, et il est déclenché régulièrement pendant la transmission, même si, au final, elle n’aboutit pas. Pour déterminer si la transmission du fichier est entièrement terminée, et à quel moment, écoutez l’événement <codeph>complete</codeph>.
    
    <p>Il arrive que des événements <codeph>progress</codeph> ne soient pas reçus. Lorsque le fichier transmis est très petit ou lorsque le chargement ou le téléchargement se déroule très rapidement, par exemple, il se peut qu’aucun événement <codeph>progress</codeph> ne soit distribué.</p>
    
    <p>La progression du chargement d’un fichier ne peut pas être déterminée sur les plateformes Macintosh avec version antérieure à OS X 10.3. L’événement <codeph>progress</codeph> est appelé au cours du chargement, mais la valeur de la propriété <codeph>bytesLoaded</codeph> de l’événement progress correspond à -1, ce qui indique que la progression ne peut pas être identifiée.</p>
    
    </apiDesc><example conref="examples\FileReference_event_progress.as"> L’exemple suivant illustre l’utilisation de l’objet événement <codeph>progress</codeph>. Pour exécuter cet exemple, modifiez la propriété <codeph>downloadURL.url</codeph> pour qu’elle pointe sur une URL et un domaine existants, au lieu de l’adresse http://www fictive.[votreDomaine].com/SomeFile.pdf. Vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash Player pour autoriser ce fichier à accéder au réseau.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_progress extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_progress() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.download(downloadURL, fileName);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
        
        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/event:complete"><linktext>FileReference.complete</linktext></link><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
	Distribué au début d’une opération de chargement ou de téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>open</code> event.
    It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onOpen = function(file:FileReference):void {
      trace("onOpen: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Distribué au début d’une opération de chargement ou de téléchargement.
    
    
    </apiDesc><example conref="examples\FileReference_download.as"> L’exemple suivant illustre l’emploi de l’objet événement <codeph>download</codeph>. Pour exécuter cet exemple, modifiez la propriété <codeph>downloadURL.url</codeph> pour qu’elle pointe sur une URL et un domaine existants, au lieu de l’adresse http://www fictive.[votreDomaine].com/SomeFile.pdf. Vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash Player pour autoriser ce fichier à accéder au réseau.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
	Distribué lors de l’échec de l’opération de chargement ou de téléchargement. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>ioError</code> event. 
    Note that for simplicity, none of the other event types are used in this
    example.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onIOError = function(file:FileReference):void {
      trace("onIOError");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download("http://www.adobe.com/NonExistentFile.pdf", "NonExistentFile.pdf");
    
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Distribué lors de l’échec de l’opération de chargement ou de téléchargement. Un transfert de fichiers peut échouer pour l’une des raisons suivantes :
    
    <ul>
    <li>Une erreur d’entrée/sortie se produit lors de la lecture, l’écriture ou la transmission du fichier.</li>
    <li><ph platform="actionscript">Le fichier SWF</ph><ph platform="javascript">L’application AIR</ph> tente de charger un fichier sur un serveur nécessitant une authentification (un nom d’utilisateur et un mot de passe, par exemple). Au cours du chargement, <ph platform="actionscript">Flash Player ou </ph>Adobe AIR ne permet pas aux utilisateurs d’entrer des mots de passe. Si <ph platform="actionscript">un fichier SWF</ph><ph platform="javascript">une application AIR</ph> tente de charger un fichier sur un serveur nécessitant une authentification, le chargement échoue.</li>
    <li><ph platform="actionscript">Le fichier SWF</ph><ph platform="javascript">L’application AIR</ph> tente de télécharger un fichier à partir d’un serveur nécessitant une authentification, dans le lecteur autonome ou externe. Au cours du téléchargement, les lecteurs autonomes et externes ne permettent pas aux utilisateurs d’entrer des mots de passe. Si <ph platform="actionscript">un fichier SWF</ph><ph platform="javascript">une application AIR</ph> dans ces lecteurs tente de charger un fichier à partir d’un serveur nécessitant une authentification, le téléchargement échoue. <ph platform="actionscript">Le téléchargement de fichiers réussit uniquement via les lecteurs avec contrôle ActiveX et plug-in de navigation, ainsi que dans le moteur d’exécution Adobe AIR.</ph></li>
    <li>La valeur transmise au paramètre <codeph>url</codeph> dans la méthode <codeph>upload()</codeph> contient un protocole non valide. Les protocoles valides sont HTTP et HTTPS.</li>
    </ul>
    
    <p platform="actionscript"><b>Important :</b> seules les applications s’exécutant dans un navigateur (via le module de navigation ou le contrôle ActiveX), ainsi que le contenu s’exécutant dans Adobe AIR, peuvent proposer une boîte de dialogue pour inviter l’utilisateur à s’authentifier avec un nom d’utilisateur et un mot de passe, et ceci uniquement pour les téléchargements. Le transfert de fichiers échoue si le chargement est effectué à l’aide du plug-in ou du contrôle ActiveX de Flash Player, ou si un chargement/téléchargement est effectué par le biais du lecteur autonome ou externe.</p>
    
    </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	Distribué à la fin d’un téléchargement ou lorsqu’un chargement génère le code d’état HTTP 200.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows usage of the <code>complete</code> event 
    listener. It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onComplete = function(file:FileReference):void {
      trace("onComplete: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Distribué à la fin d’un téléchargement ou lorsqu’un chargement génère le code d’état HTTP 200. Dans le cas d’un téléchargement, cet événement est distribué lorsque <ph platform="actionscript">Flash Player ou </ph>Adobe AIR achève la totalité du téléchargement du fichier dans le disque. Dans le cas d’un chargement, cet événement est distribué lorsque <ph platform="actionscript">Flash Player ou </ph>Adobe AIR reçoit le code d’état HTTP 200 du serveur recevant la transmission.
    
    </apiDesc><example conref="examples\FileReference_event_complete.as"> L’exemple suivant illustre l’utilisation de l’objet événement <codeph>complete</codeph>. Pour exécuter cet exemple, modifiez la propriété <codeph>downloadURL.url</codeph> pour qu’elle pointe sur une URL et un domaine existants, au lieu de l’adresse http://www fictive.[votreDomaine].com/SomeFile.pdf. Vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash Player pour autoriser ce fichier à accéder au réseau.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_complete extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_complete() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
	Distribué lorsqu’un chargement ou un téléchargement de fichiers est annulé par l’utilisateur via la boîte de dialogue de recherche de fichiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example traces a message if the user dismisses the file-
    browsing dialog box. This method
    is triggered only if the user selects Cancel or presses the escape key after
    the dialog box opens.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onCancel = function(file:FileReference):void {
      trace("onCancel");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    if(!fileRef.download(url, "FlashPlatform.pdf")) {
      trace("dialog box failed to open.");
    }
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Distribué lorsqu’un chargement ou un téléchargement de fichiers est annulé par l’utilisateur via la boîte de dialogue de recherche de fichiers. Flash Player ne distribue pas cet événement si l’utilisateur annule un chargement ou un téléchargement selon un autre procédé (en fermant le navigateur ou en arrêtant l’application active).
    
    </apiDesc><example conref="examples\FileReference_event_cancel.as"> L’exemple suivant illustre l’utilisation de l’objet événement <codeph>download</codeph>. Pour exécuter cet exemple, modifiez la propriété <codeph>downloadURL.url</codeph> pour qu’elle pointe sur une URL et un domaine existants, au lieu de l’adresse http://www fictive.[votreDomaine].com/SomeFile.pdf. Vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash Player pour autoriser ce fichier à accéder au réseau.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_cancel extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_cancel() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(Event.CANCEL, cancelHandler);
            file.download(downloadURL, fileName);
        }
        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:FileReference:FileReference"><apiName>FileReference</apiName><shortdesc>
    Crée un nouvel objet FileReference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReference</code> object and 
    initiates the download of a pdf file.
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    listener.onComplete = function(file:FileReference) {
      trace("onComplete : " + file.name);
    }
    
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    
    </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
    Crée un nouvel objet FileReference. Quand il est renseigné, un objet FileReference représente un fichier du disque local de l’utilisateur.
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReference:browse"><apiName>browse</apiName><shortdesc>
    Affiche une boîte de dialogue de recherche de fichiers dans laquelle l’utilisateur peut sélectionner un fichier à charger.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>browse, FileReference.browse
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse FileReference ou FileReferenceList est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) Un paramètre du fichier mms.cfg de l’utilisateur bloque cette opération.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Une exception est renvoyée si le tableau <codeph>typeFilter</codeph> contient des objets FileFilter incorrectement formatés. Pour plus d’informations sur le format correct des objets FileFilter, voir la classe <xref href="FileFilter.html">FileFilter</xref>.
  
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si la méthode n’est pas appelée en réponse à l’action d’un utilisateur, notamment à un événement de type souris ou pression de touche.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si les paramètres sont valides et que la boîte de dialogue de recherche de fichiers est ouverte.  
  
  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Tableau d’occurrences de FileFilter utilisé pour filtrer les fichiers qui s’affichent dans la boîte de dialogue. Si vous omettez ce paramètre, tous les fichiers s’affichent. Pour plus d’informations, voir la classe <xref href="FileFilter.html">FileFilter</xref>.
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Affiche une boîte de dialogue de recherche de fichiers dans laquelle l’utilisateur peut sélectionner un fichier à charger. La boîte de dialogue est spécifique au système d’exploitation de l’utilisateur. L’utilisateur peut sélectionner un fichier dans l’ordinateur local ou dans d’autres systèmes, via un chemin UNC sur Windows, par exemple.
    
    <p><b>Remarque :</b> la classe File, disponible dans Adobe AIR, comprend des méthodes permettant d’accéder à des boîtes de dialogue de sélection de systèmes de fichiers plus spécifiques. Ces méthodes sont les suivantes : <codeph>File.browseForDirectory()</codeph>, <codeph>File.browseForOpen()</codeph>, <codeph>File.browseForOpenMultiple()</codeph>et <codeph>File.browseForSave()</codeph>.</p>
    
    <p>Lorsque vous appelez cette méthode et que l’utilisateur réussit à sélectionner un fichier, les propriétés de l’objet FileReference sont renseignées par les propriétés de ce fichier. <codeph/> Une seule session <codeph>browse()</codeph> ou <codeph>download()</codeph> peut être effectuée à la fois (car une seule boîte de dialogue peut être appelée à la fois).</p>
    
    <p>Le paramètre <codeph>typeFilter</codeph> vous permet de déterminer les fichiers répertoriés dans la boîte de dialogue.</p>
    
    <p platform="actionscript">Dans Flash Player 10 et Flash Player 9 Mise à jour 5, l’appel de cette méthode aboutit uniquement en réponse à un événement utilisateur (par exemple, un événement de type clic de souris ou pression de touche). Dans les autres cas, Flash Player renvoie une exception Error à l’appel de cette méthode.</p>
    
    <p platform="actionscript">Notez que lors de la publication dans Flash Player 10, les nouvelles fonctionnalités ajoutées au lecteur ne vous permettent d’exécuter qu’une seule opération à la fois : <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> ou <codeph>FileReference.save()</codeph>. Dans le cas contraire, Flash Player renvoie une erreur d’exécution (code 2174). Utilisez <codeph>FileReference.cancel()</codeph> pour arrêter une opération en cours. Cette restriction s’applique uniquement à Flash Player 10. Cette restriction sur l’exécution simultanée de plusieurs opérations ne s’applique pas aux versions précédentes de Flash Player.</p> 
    
  </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/event:select"><linktext>select, événement</linktext></link><link href="flash.net.xml#FileReference/event:cancel"><linktext>cancel, événement</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForDirectory().xml"><linktext>File.browseForDirectory()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpen().xml"><linktext>File.browseForOpen()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpenMultiple().xml"><linktext>File.browseForOpenMultiple()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForSave().xml"><linktext>File.browseForSave()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur parvient à sélectionner un élément dans le sélecteur de fichiers.
  </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne un élément dans la boîte de dialogue de recherche de fichiers.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur annule le chargement du fichier dans la fenêtre de recherche de fichiers.
  
  </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur annule la fenêtre de recherche de fichiers réservée aux chargements de fichiers.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:cancel"><apiName>cancel</apiName><shortdesc>
  Annule une opération de chargement ou de téléchargement en cours sur cet objet FileReference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>cancel, FileReference.cancel
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Annule le chargement ou le téléchargement en cours.
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Annule une opération de chargement ou de téléchargement en cours sur cet objet FileReference. L’appel de cette méthode n’entraîne pas la distribution de l’événement <codeph>cancel</codeph>. Celui-ci n’est distribué que si l’utilisateur annule l’opération en fermant la boîte de dialogue de sélection des fichiers à charger ou télécharger.
  
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:FileReference:download"><apiName>download</apiName><shortdesc>
    Affiche une boîte de dialogue permettant à l’utilisateur de télécharger un fichier à partir d’un serveur distant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) La valeur transmise à <codeph>request</codeph> ne contient ni un chemin ni un protocole valide. 3) Le nom de fichier à télécharger contient des caractères interdits. 4) Un paramètre du fichier mms.cfg de l’utilisateur bloque cette opération.
    
    	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Tout contenu non approuvé au niveau local ne peut pas communiquer avec Internet. Pour contourner cette restriction, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé. Cette exception est renvoyée, accompagnée d’un message indiquant le nom de fichier et l’URL qui ne sont pas accessibles en raison des restrictions relatives à la sécurité des fichiers locaux.
    
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
    
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si <codeph>url.data</codeph> est de type ByteArray, une exception est renvoyée. Lorsqu’il est utilisé avec les méthodes <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph>, <codeph>url.data</codeph> peut uniquement être de type URLVariables ou String.
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire pour les raisons suivantes : 1) Flash Player ne peut pas convertir le paramètre <codeph>URLRequest.data</codeph> du format UTF8 au format MBCS. Cette erreur se produit si l’objet URLRequest transmis à la méthode <codeph>FileReference.download()</codeph> est configuré pour exécuter une opération GET et si <codeph>System.useCodePage</codeph> est réglé sur <codeph>true</codeph>. 2) Flash Player ne peut pas allouer de mémoire aux données <codeph>POST</codeph>. Cette erreur se produit si l’objet URLRequest transmis à la méthode <codeph>FileReference.download()</codeph> est configuré pour exécuter une opération <codeph>POST</codeph>.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Si la méthode n’est pas appelée en réponse à l’action d’un utilisateur, notamment à un événement de type souris ou pression de touche.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>L’objet URLRequest. La propriété <codeph>url</codeph> de l’objet URLRequest doit contenir l’URL du fichier à télécharger sur l’ordinateur local. Si la valeur de ce paramètre est <codeph>null</codeph>, une exception est renvoyée. La propriété <codeph>requestHeaders</codeph> de l’objet URLRequest est ignorée ; les en-têtes de requête HTTP personnalisés ne sont pas pris en charge dans les chargements et les téléchargements. Pour envoyer des paramètres <codeph>POST</codeph> ou GET au serveur, réglez la valeur de <codeph>URLRequest.data</codeph> sur vos paramètres et <codeph>URLRequest.method</codeph> sur <codeph>URLRequestMethod.POST</codeph> ou <codeph>URLRequestMethod.GET</codeph>.
    
    	<p platform="actionscript">Dans certains navigateurs, la longueur des chaînes d’URL est limitée. Une longueur supérieure à 256 caractères peut échouer avec certains navigateurs ou serveurs.</p>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de fichier par défaut affiché dans la boîte de dialogue pour le fichier à télécharger. Les caractères suivants sont interdits dans cette chaîne : / \ : ~~ ? " &lt; > | %
    <p>Si vous omettez ce paramètre, le nom de fichier de l’URL distante est analysé et utilisé par défaut. </p>
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Affiche une boîte de dialogue permettant à l’utilisateur de télécharger un fichier à partir d’un serveur distant. <ph platform="actionscript">Flash Player n’impose pas de restrictions au niveau de la taille des fichiers chargés ou téléchargés ; en revanche, le lecteur prend en charge des chargements ou des téléchargements de 100 Mo au maximum.</ph>
    
    <p>La méthode <codeph>download()</codeph> ouvre d’abord une boîte de dialogue du système d’exploitation demandant à l’utilisateur d’entrer un nom de fichier et de sélectionner l’emplacement où enregistrer le fichier dans l’ordinateur local. Quand l’utilisateur choisit un emplacement et confirme le téléchargement (en cliquant sur Enregistrer, par exemple), celui-ci commence sur le serveur distant. Les écouteurs reçoivent des événements indiquant la progression du téléchargement, ainsi que sa réussite ou son échec. Pour déterminer l’état de la boîte de dialogue et de l’opération de téléchargement après avoir appelé la méthode <codeph>download()</codeph>, votre code doit écouter les événements tels que <codeph>cancel</codeph>, <codeph>open</codeph>, <codeph>progress</codeph> et <codeph>complete</codeph>.
    </p>
    
    <p>Les fonctions <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph> ne sont pas bloquantes. Elles sont renvoyées après leur appel, avant la fin de la transmission de fichiers. En outre, si l’objet FileReference sort de son domaine, tout chargement ou téléchargement qui n’est pas encore terminé sur cet objet est annulé à ce moment-là. Veillez à ce que l’objet FileReference demeure dans son domaine pendant toute la durée prévue du chargement ou du téléchargement.</p>
    
    <p>Une fois le fichier téléchargé, les propriétés de l’objet FileReference sont renseignées par les propriétés du fichier local. L’événement <codeph>complete</codeph> est distribué si le téléchargement aboutit.</p>
    
    <p>Une seule session <codeph>browse()</codeph> ou <codeph>download()</codeph> peut être effectuée à la fois (car une seule boîte de dialogue peut être appelée à la fois).</p>
    
    <p>Cette méthode prend en charge le téléchargement de tout type de fichier, via HTTP ou HTTPS.</p>
    
     <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
    
    <p><b>Remarque</b> : Si votre serveur requiert l’authentification des utilisateurs, seuls les fichiers SWF s’exécutant dans un navigateur (c’est-à-dire avec le plug-in de navigation ou un contrôle ActiveX), peuvent fournir une boîte de dialogue qui demande à l’utilisateur son identifiant et son mot de passe d’authentification, ceci uniquement pour les téléchargements. Le transfert de fichiers échoue si le chargement est effectué à l’aide du plug-in ou d’un contrôle ActiveX, ou si un chargement/téléchargement est effectué par le biais du lecteur autonome ou externe.</p>
    
    <p>Lorsque vous employez cette méthode <ph platform="javascript">dans le contenu d’un sandbox de sécurité autre que celui de l’application</ph>, tenez compte du modèle de sécurité <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph> suivant : </p>
    
    <ul>
    <li>Les opérations de chargement sont interdites si le fichier SWF appelant se trouve dans un sandbox local non approuvé.</li>
    
    <li>Par défaut, l’accès entre les sandbox est refusé. Un site Web peut autoriser l’accès à une ressource en ajoutant un fichier de régulation d’URL.</li>
    
    <li platform="actionscript">Vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</li>
    
    <li platform="actionscript">Dans Flash Player 10 et Flash Player 9 Mise à jour 5, l’appel de cette méthode aboutit uniquement en réponse à un événement utilisateur (par exemple, un événement de type clic de souris ou pression de touche). Dans les autres cas, Flash Player renvoie une exception Error à l’appel de cette méthode.</li>
    
    </ul>
    
    <p>Néanmoins, <ph platform="actionscript">dans Adobe AIR,</ph> le contenu du sandbox de sécurité<codeph> de l’application </codeph>(contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
    
    <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
    
    <ul>
           
    <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
    
    <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
    
    <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i></li>
    
    <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
    
    </ul>
    
    <p>Notez que lors de la publication dans Flash Player 10, les nouvelles fonctionnalités ajoutées au lecteur ne vous permettent d’exécuter qu’une seule opération à la fois : <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> ou <codeph>FileReference.save()</codeph>. Dans le cas contraire, Flash Player renvoie une erreur d’exécution (code 2174). Utilisez <codeph>FileReference.cancel()</codeph> pour arrêter une opération en cours. Cette restriction s’applique uniquement à Flash Player 10. Cette restriction sur l’exécution simultanée de plusieurs opérations ne s’applique pas aux versions précédentes de Flash Player.</p> 
	
    </apiDesc><example conref="examples\FileReference_download.as"> L’exemple suivant illustre l’emploi de l’objet événement <codeph>download</codeph>. Pour exécuter cet exemple, modifiez la propriété <codeph>downloadURL.url</codeph> pour qu’elle pointe sur une URL et un domaine existants, au lieu de l’adresse http://www fictive.[votreDomaine].com/SomeFile.pdf. Vous aurez peut-être besoin de compiler le fichier SWF avec l’option Protection de lecture locale définie sur Accéder au réseau seulement ou de mettre à jour vos paramètres de sécurité Flash Player pour autoriser ce fichier à accéder au réseau.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:download_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué au début d’une opération de téléchargement.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lors du démarrage d’une opération de téléchargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué régulièrement pendant l’opération de téléchargement.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué régulièrement pendant le téléchargement du fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération de téléchargement de fichier aboutit.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué en cas de réussite de l’opération de téléchargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur ferme la boîte de dialogue.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur ferme la boîte de dialogue.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur sélectionne un fichier à télécharger dans la boîte de dialogue. 
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne un fichier à télécharger dans la boîte de dialogue.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un téléchargement échoue en raison d’une erreur de sécurité.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un téléchargement échoue en raison d’une erreur de sécurité.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué pour l’une des raisons suivantes :
    <ul>
    <li>Une erreur d’entrée/de sortie se produit pendant la lecture ou la transmission du fichier.</li>
    	<li>Le contenu SWF s’exécutant dans les versions autonome et externe de Flash Player tente de télécharger un fichier depuis un serveur nécessitant une authentification. Au cours du téléchargement, les lecteurs autonomes et externes ne permettent pas aux utilisateurs d’entrer des mots de passe. Si un fichier SWF présent dans ces lecteurs tente de télécharger un fichier à partir d’un serveur nécessitant une authentification, le téléchargement échoue. Le téléchargement de fichiers réussit uniquement via les lecteurs avec contrôle ActiveX et plug-in de navigation.</li>
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué pour l’une des raisons suivantes : Une erreur d’entrée/sortie se produit pendant la lecture ou la transmission du fichier. Le contenu SWF s’exécutant dans les versions autonome et externe de Flash Player tente de télécharger un fichier depuis un serveur nécessitant une authentification.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:load"><apiName>load</apiName><shortdesc>
    Démarre le chargement d’un fichier local sélectionné par un utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>load, FileReference.load
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse FileReference ou FileReferenceList est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) Un paramètre du fichier mms.cfg de l’utilisateur bloque cette opération.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire si l’application ne peut pas allouer de mémoire pour le fichier. Le fichier peut être trop volumineux ou la quantité de mémoire disponible insuffisante.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Démarre le chargement d’un fichier local.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Démarre le chargement d’un fichier local sélectionné par un utilisateur. <ph platform="actionscript">Flash Player n’impose pas de restrictions au niveau de la taille des fichiers chargés, téléchargés ou enregistrés, mais officiellement prend en charge des tailles de 100 Mo au maximum. Pour le contenu s’exécutant dans Flash Player, vous devez appeler la méthode <codeph>FileReference.browse()</codeph> ou <codeph>FileReferenceList.browse()</codeph> avant d’appeler la méthode <codeph>load()</codeph>. Néanmoins, le contenu exécuté dans AIR dans le sandbox de l’application peut appeler la méthode <codeph>load()</codeph> d’un objet File sans appeler au préalable la méthode <codeph>browse()</codeph> (la classe File d’AIR étend la classe FileReference).</ph>
    
    <p>Les écouteurs reçoivent des événements indiquant la progression du chargement, ainsi que sa réussite ou son échec. Bien que vous puissiez utiliser l’objet FileReferenceList permettant aux utilisateurs un choix multiple de fichiers à charger, vous devez charger les fichiers un par un. Pour charger les fichiers un par un, parcourez en boucle le tableau <codeph>FileReferenceList.fileList</codeph> des objets FileReference.</p>
    
    <p>Adobe AIR comprend également la classe FileStream, qui propose davantage d’options de lecture de fichiers.</p>
    
    <p>Les fonctions <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> et <codeph>FileReference.save()</codeph> ne sont pas bloquantes. Elles sont renvoyées après leur appel, avant la fin de la transmission de fichiers. En outre, si l’objet FileReference sort de son domaine, toute transaction qui n’est pas encore terminée sur cet objet est annulée à ce moment-là. Veillez à ce que l’objet FileReference demeure dans son domaine pendant toute la durée prévue du chargement, téléchargement ou enregistrement.</p>
    
    <p>Si le téléchargement du fichier aboutit, son contenu est stocké en tant que tableau d’octets dans la propriété <codeph>data</codeph> de l’objet FileReference.</p>
    
    <p platform="actionscript">Il faut tenir compte des considérations de sécurité suivantes :</p>
    
    <ul platform="actionscript">
    <li>Les opérations de chargement sont interdites si le fichier SWF appelant se trouve dans un sandbox local non approuvé.</li>
    <li>Par défaut, l’accès entre les sandbox est refusé. Un site Web peut autoriser l’accès à une ressource en ajoutant un fichier de régulation interdomaines.</li>
    <li>Vous pouvez empêcher un fichier d’utiliser cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui comporte le contenu SWF.</li>
    </ul>
    
    <p platform="actionscript">Toutefois, ces considérations ne s’appliquent pas au contenu AIR dans le sandbox de l’application.</p>
    
    <p>Notez que lors de la publication dans Flash Player 10 ou AIR 1.5, une seule des opérations suivantes peut être exécutée à la fois : <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. Dans le cas contraire, l’application renvoie une erreur d’exécution (code 2174). Utilisez <codeph>FileReference.cancel()</codeph> pour arrêter une opération en cours. Cette restriction s’applique uniquement à Flash Player 10 et AIR 1.5. Les versions antérieures de Flash Player ou AIR ne sont pas concernées par cette restriction sur l’exécution simultanée de plusieurs opérations.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/data"><linktext>FileReference.data</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>flash.filesystem.FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lors du démarrage d’une opération de chargement.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lors du démarrage d’une opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué régulièrement pendant le chargement du fichier.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué régulièrement pendant le chargement du fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération de chargement de fichier aboutit.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’opération de chargement de fichier aboutit.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Invoqué si le chargement échoue du fait d’une erreur d’entrée/sortie lors de la lecture ou de l’écriture du fichier par l’application.
    
    </apiDesc></adobeApiEventDetail><shortdesc>Invoqué si le chargement échoue du fait d’une erreur d’entrée/sortie lors de la lecture ou de l’écriture du fichier par l’application.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:save"><apiName>save</apiName><shortdesc>
    Ouvre une boîte de dialogue qui permet à l’utilisateur d’enregistrer un fichier dans le système de fichiers local.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) Le nom de fichier à télécharger contient des caractères interdits. 3) Un paramètre du fichier mms.cfg de l’utilisateur bloque cette opération.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si <codeph>data</codeph> n’est pas de type ByteArray et ne dispose pas d’une méthode <codeph>toString()</codeph>, une exception est renvoyée. Si <codeph>data</codeph> n’est pas de type XML et ne dispose pas d’une méthode <codeph>toXMLString()</codeph>, une exception est renvoyée.
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Si la méthode n’est pas appelée en réponse à l’action d’un utilisateur, notamment à un événement de type souris ou pression de touche.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire si Flash Player ne peut pas allouer de la mémoire pour le fichier. Le fichier peut être trop volumineux ou la quantité de mémoire disponible insuffisante.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>data</apiItemName><apiType value=""/><apiDesc>Données à enregistrer. Les données peuvent être de divers formats et sont traitées de façon appropriée :
    <ul>
    <li>Si la valeur est <codeph>null</codeph>, l’application renvoie une exception ArgumentError.</li> 
    <li>Si cette valeur est une chaîne, les données sont enregistrées sous forme de fichier texte UTF-8.</li>
    <li platform="actionscript">Si cette valeur est XML, les données sont écrites dans un fichier texte au format XML et la mise en forme est préservée.</li> 
    <li>Si cette valeur est un objet ByteArray, les données sont écrites textuellement dans un fichier de données.</li> 
    <li>Si la valeur ne correspond à aucune des descriptions ci-dessus, la méthode <codeph>save()</codeph> appelle la méthode <codeph>toString()</codeph> de l’objet pour convertir les données en chaîne, puis enregistre les données sous forme de fichier texte. En cas d’échec, l’application renvoie une exception AurgmentError.</li> 
    </ul>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Nom de fichier par défaut affiché dans la boîte de dialogue pour le fichier à enregistrer. Les caractères suivants sont interdits dans cette chaîne : / \ : ~~ ? " &lt; > | %
    <p><ph platform="javascript">Dans Flash Player, si vous omettez ce paramètre, le nom de fichier reste vide par défaut.</ph> Si un objet File appelle cette méthode, le nom de fichier correspond à celui du fichier que l’objet File référence (la classe File d’AIR étend la classe FileReference).</p>
    
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    Ouvre une boîte de dialogue qui permet à l’utilisateur d’enregistrer un fichier dans le système de fichiers local. <ph platform="actionscript">Flash Player n’impose pas de restrictions au niveau de la taille des fichiers chargés, téléchargés ou enregistrés, mais officiellement le lecteur prend en charge des tailles de 100 Mo au maximum.</ph>
    
    <p>La méthode <codeph>save()</codeph> ouvre d’abord une boîte de dialogue du système d’exploitation demandant à l’utilisateur d’entrer un nom de fichier et de sélectionner l’emplacement où l’enregistrer dans l’ordinateur local. Lorsque l’utilisateur sélectionne un emplacement et confirme l’enregistrement (par exemple en cliquant sur Enregistrer), le processus d’enregistrement commence. Les écouteurs reçoivent des événements indiquant la progression de l’enregistrement, ainsi que sa réussite ou son échec. Pour déterminer l’état de la boîte de dialogue et de l’opération d’enregistrement après avoir appelé la méthode <codeph>save()</codeph>, votre code doit écouter les événements tels que <codeph>cancel</codeph>, <codeph>open</codeph>, <codeph>progress</codeph> et <codeph>complete</codeph>.
    </p>
    
    <p>Adobe AIR comprend également la classe FileStream, qui propose davantage d’options d’enregistrement de fichiers au niveau local.</p>
    
    <p>Les fonctions <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> et <codeph>FileReference.save()</codeph> ne sont pas bloquantes. Elles sont renvoyées après leur appel, avant la fin de la transmission de fichiers. En outre, si l’objet FileReference sort de son domaine, toute transaction qui n’est pas encore terminée sur cet objet est annulée à ce moment-là. Veillez à ce que l’objet FileReference demeure dans son domaine pendant toute la durée prévue du chargement, téléchargement ou enregistrement.</p>
    
    <p>Une fois le fichier enregistré, les propriétés de l’objet FileReference sont renseignées avec les propriétés du fichier local. L’événement <codeph>complete</codeph> est distribué si l’enregistrement aboutit.</p>
    
    <p>Une seule session <codeph>browse()</codeph> ou <codeph>save()</codeph> peut être effectuée à la fois (car une seule boîte de dialogue peut être appelée à la fois).</p>
    
    <p platform="actionscript">Dans Flash Player, l’appel de cette méthode aboutit uniquement en réponse à un événement utilisateur (par exemple, un événement de type clic de souris ou pression de touche). Dans les autres cas, Flash Player renvoie une exception Error à l’appel de cette méthode. Le contenu AIR s’exécutant dans le sandbox de l’application n’est pas soumis à cette restriction.</p>
    
    </apiDesc><example conref="examples\FileReference_save.as"> L’exemple suivant enregistre le contenu saisi dans un champ de texte dans un fichier. L’exemple crée un champ de texte modifiable (<codeph>MyTextField</codeph>) et un autre champ de texte non modifiable (<codeph>MyButtonField</codeph>) pour servir de « bouton » afin de répondre à un clic de souris. L’utilisateur peut modifier le premier champ de texte et cliquer sur le bouton pour enregistrer le contenu du champ de texte dans un fichier local. Le gestionnaire d’événement de type clip de souris <codeph>clickhandler</codeph> utilise la méthode <codeph>FileReference.save(),</codeph> (pour un objet FileReference appelé <codeph>MyFileReference</codeph>) pour ouvrir une boîte de dialogue sur le système d’exploitation de l’utilisateur afin que ce dernier puisse enregistrer le contenu dans un fichier local avec le nom attribué.
<codeblock>
var MyTextField:TextField = new TextField();
var MyButtonField:TextField = new TextField();
var MyFile:FileReference = new FileReference();

MyTextField.border = true;
MyTextField.type = TextFieldType.INPUT;

MyButtonField.background = true;
MyButtonField.backgroundColor = 0x339933;
MyButtonField.x = 150;
MyButtonField.height = 20;
MyButtonField.text = "Click here to save";

addChild(MyTextField);
addChild(MyButtonField);
MyButtonField.addEventListener(MouseEvent.CLICK, clickhandler);

function clickhandler(e:MouseEvent): void {
    MyFile.save(MyTextField.text);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/load()"><linktext>FileReferenceList.load()</linktext></link><link href="flash.net.xml#FileReferenceList/data"><linktext>FileReferenceList.data</linktext></link><link href="flash.net.xml#FileReferenceList/upload"><linktext>FileReferenceList.upload</linktext></link><link href="flash.net.xml#FileReferenceList/download"><linktext>FileReferenceList.download</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:save_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué au début d’une opération de téléchargement.
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lors du démarrage d’une opération de téléchargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué régulièrement pendant l’opération de téléchargement.
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué régulièrement pendant le téléchargement du fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération de téléchargement de fichier aboutit.
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué en cas de réussite de l’opération de téléchargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur ferme la boîte de dialogue.
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur ferme la boîte de dialogue.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’utilisateur sélectionne un fichier à télécharger dans la boîte de dialogue. 
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque l’utilisateur sélectionne un fichier à télécharger dans la boîte de dialogue.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué si une erreur d’entrée/sortie se produit pendant la lecture ou la transmission du fichier.
    
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué si une erreur d’entrée/sortie se produit pendant la lecture ou la transmission du fichier.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:upload"><apiName>upload</apiName><shortdesc>
    Procède au chargement d’un fichier sélectionné par un utilisateur sur un serveur distant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>upload, FileReference.upload
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les fichiers SWF locaux non approuvés ne peuvent pas communiquer avec Internet. Pour contourner cette restriction, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé. Cette exception est renvoyée, accompagnée d’un message indiquant le nom du fichier local et l’URL qui ne sont pas accessibles.
    
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
     
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse FileReference ou FileReferenceList est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) Le paramètre URL n’est pas un chemin ou un protocole valide. Les chargements de fichiers doivent utiliser HTTP, les téléchargements FTP ou HTTP. 3) Le paramètre <codeph>uploadDataFieldName</codeph> est réglé sur <codeph>null</codeph>. 4) Un paramètre du fichier mms.cfg de l’utilisateur bloque cette opération.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Le paramètre <codeph>uploadDataFieldName</codeph> est une chaîne vide. 2) Le paramètre <codeph>url.data</codeph> est de type ByteArray. Lorsqu’il est utilisé avec les méthodes <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph>, le paramètre <codeph>url.data</codeph> peut uniquement être de type URLVariables ou String. 3) Dans le moteur d’exécution AIR (sandbox de sécurité de l’application), la méthode de l’objet URLRequest n’est ni GET ni POST (utilisez plutôt <codeph>uploadEncoded()</codeph>).
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire pour les raisons suivantes : 1) Flash Player ne peut pas convertir le paramètre <codeph>URLRequest.data</codeph> du format UTF8 au format MBCS. Cette erreur se produit si l’objet URLRequest transmis à <codeph>FileReference.upload()</codeph> est configuré pour exécuter une opération GET et si <codeph>System.useCodePage</codeph> est réglé sur <codeph>true</codeph>. 2) Flash Player ne peut pas allouer de mémoire aux données <codeph>POST</codeph>. Cette erreur est applicable si l’objet URLRequest transmis à <codeph>FileReference.upload()</codeph> est configuré pour exécuter une opération <codeph>POST</codeph>.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>L’objet URLRequest. La propriété <codeph>url</codeph> de cet objet doit contenir l’URL du script serveur configuré pour traiter le chargement via les appels HTTP <codeph>POST</codeph>. Dans certains navigateurs, la longueur des chaînes d’URL est limitée. Une longueur supérieure à 256 caractères peut échouer avec certains navigateurs ou serveurs. Si la valeur de ce paramètre est <codeph>null</codeph>, une exception est renvoyée. La propriété <codeph>requestHeaders</codeph> de l’objet URLRequest est ignorée ; les en-têtes de requête HTTP personnalisés ne sont pas pris en charge dans les chargements et les téléchargements. 
     
    <p>L’URL peut être de type HTTP ou, pour les chargements sécurisés, de type HTTPS. Pour utiliser HTTPS, entrez une URL HTTPS dans le paramètre <codeph>url</codeph>. Si vous ne spécifiez pas de numéro de port dans le paramètre <codeph>url</codeph>, le port 80 pour HTTP et le port 443 pour HTTPS sont utilisés par défaut.</p>
    
    <p>Pour envoyer des paramètres <codeph>POST</codeph> or <codeph>GET</codeph> au serveur, réglez la propriété <codeph>data</codeph> de l’objet URLRequest sur vos paramètres et la propriété <codeph>method</codeph> sur <codeph>URLRequestMethod.POST</codeph> ou <codeph>URLRequestMethod.GET</codeph>.</p>
    
    
    </apiDesc></apiParam><apiParam><apiItemName>uploadDataFieldName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>Filedata</apiData><apiDesc>Nom de champ qui précède les données du fichier dans l’opération de chargement <codeph>POST</codeph>. La valeur de <codeph>uploadDataFieldName</codeph> doit être chaîne non vide et dont la valeur n’est pas null. Par défaut, la valeur de <codeph>uploadDataFieldName</codeph> correspond à <codeph>Filedata</codeph>, comme illustré dans l’exemple de requête <codeph>POST</codeph> ci-dessous :
    <pre>
    Content-Type: multipart/form-data; boundary=AaB03x
    --AaB03x 
    Content-Disposition: form-data; name="Filedata"; filename="example.jpg" 
    Content-Type: application/octet-stream
    ... contents of example.jpg ... 
    --AaB03x-- 
    </pre>
    
    </apiDesc></apiParam><apiParam><apiItemName>testUpload</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Paramètre permettant de demander le chargement d’un fichier de test. Si la valeur de <codeph>testUpload</codeph> est <codeph>true</codeph>, pour les fichiers supérieurs à 10 Ko, Flash Player tente de charger un fichier test <codeph>POST</codeph> avec une valeur Content-Length de 0. Le chargement de test vérifie si le chargement du fichier réel peut réussir et si l’authentification du serveur se passera bien, le cas échéant. Seuls les lecteurs Windows prennent en charge les chargements de test.
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Procède au chargement d’un fichier sur un serveur distant.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Procède au chargement d’un fichier sélectionné par un utilisateur sur un serveur distant. <ph platform="actionscript">Flash Player n’impose pas de restrictions au niveau de la taille des fichiers chargés ou téléchargés ; en revanche, le lecteur prend en charge des chargements/téléchargements de 100 Mo au maximum.</ph> Vous devez appeler la méthode <codeph>FileReference.browse()</codeph> ou <codeph>FileReferenceList.browse()</codeph> avant d’appeler cette méthode.
    
    <p>Les écouteurs reçoivent des événements indiquant la progression du chargement, ainsi que sa réussite ou son échec. Bien que vous puissiez employer l’objet FileReferenceList pour permettre aux utilisateurs de sélectionner plusieurs fichiers à charger, vous devez charger ces fichiers un par un. Pour ce faire, exécutez une itération dans le tableau <codeph>FileReferenceList.fileList</codeph> des objets FileReference.</p>
    
    <p>Les fonctions <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph> ne sont pas bloquantes. Elles sont renvoyées après leur appel, avant la fin de la transmission de fichiers. En outre, si l’objet FileReference sort de son domaine, tout chargement ou téléchargement qui n’est pas encore terminé sur cet objet est annulé à ce moment-là. Veillez à ce que l’objet FileReference demeure dans son domaine pendant toute la durée prévue du chargement ou du téléchargement.</p>
    
    <p>Le fichier est chargé dans l’URL transmise dans le paramètre <codeph>url</codeph>. L’URL doit être un script serveur configuré pour accepter les chargements. Flash Player charge les fichiers à l’aide de la méthode HTTP <codeph>POST</codeph>. Le script serveur qui gère le chargement doit attendre une requête <codeph>POST</codeph> comportant les éléments suivants :</p>
    <ul>
    <li><codeph>Content-Type</codeph> de <codeph>multipart/form-data</codeph></li>
    <li>Un élément <codeph>Content-Disposition</codeph> avec un attribut <codeph>name</codeph> défini sur <codeph>Filedata</codeph> par défaut et <codeph>filename</codeph> réglé sur le nom du fichier d’origine</li>
    <li>Le contenu binaire du fichier</li></ul>
    
     <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
    
    <p>Vous trouverez un exemple de requête <codeph>POST</codeph> dans la description du paramètre <codeph>uploadDataFieldName</codeph>. Vous pouvez envoyer les paramètres <codeph>POST</codeph> ou <codeph>GET</codeph> au serveur à l’aide de la méthode <codeph>upload()</codeph>. Consultez la description du paramètre <codeph>request</codeph>.</p>
    
    <p>Si le paramètre <codeph>testUpload</codeph> est réglé sur <codeph>true</codeph> et que la taille du fichier à charger est supérieure à 10 Ko environ, sous Windows, Flash Player envoie d’abord une opération <codeph>POST</codeph> de test vide, avant le fichier lui-même, pour vérifier si la transmission est susceptible d’aboutir. Flash Player envoie ensuite une seconde opération <codeph>POST</codeph> contenant le fichier lui-même. Si la taille du fichier est inférieure à 10 Ko, Flash Player exécute une seule opération <codeph>POST</codeph> contenant le fichier lui-même. Sous Macintosh, Flash Player n’exécute pas d’opérations de chargement <codeph>POST</codeph> de test.</p>
    
    <p><b>Remarque</b> : si votre serveur requiert l’authentification des utilisateurs, seuls les fichiers SWF s’exécutant dans un navigateur (c’est-à-dire avec le plug-in de navigation ou un contrôle ActiveX), peuvent fournir une boîte de dialogue qui demande à l’utilisateur son identifiant et son mot de passe d’authentification, ceci uniquement pour les téléchargements. Le transfert de fichiers échoue si le chargement est effectué à l’aide du plug-in ou d’un contrôle ActiveX, ou si un chargement/téléchargement est effectué par le biais du lecteur autonome ou externe.</p>
    
    <p>Lorsque vous employez cette méthode <ph platform="javascript">dans le contenu d’un sandbox de sécurité autre que celui de l’application</ph>, tenez compte du modèle de sécurité <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph> suivant : </p>
    
    
    <ul>
    <li>Les opérations de chargement sont interdites si le fichier SWF appelant se trouve dans un sandbox local non approuvé.</li>
    
    <li>Par défaut, l’accès entre les sandbox est refusé. Un site Web peut autoriser l’accès à une ressource en ajoutant un fichier de régulation d’URL.</li>
    
	<li platform="actionscript">Vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</li>
    
    </ul>
    
    <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
    
	<p>Pour plus d’informations, voir les références suivantes :</p>
    
    <ul>
    
    <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
    
    <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
    
    <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i></li>
    
    <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
    </ul>
    <p>Notez que lors de la publication dans Flash Player 10, les nouvelles fonctionnalités ajoutées au lecteur ne vous permettent d’exécuter qu’une seule opération à la fois : <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> ou <codeph>FileReference.save()</codeph>. Dans le cas contraire, Flash Player renvoie une erreur d’exécution (code 2174). Utilisez <codeph>FileReference.cancel()</codeph> pour arrêter une opération en cours. Cette restriction s’applique uniquement à Flash Player 10. Cette restriction sur l’exécution simultanée de plusieurs opérations ne s’applique pas aux versions précédentes de Flash Player.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:upload_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lors du démarrage d’une opération de chargement.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lors du démarrage d’une opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué régulièrement pendant l’opération de chargement de fichier.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué régulièrement pendant le chargement du fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération de chargement de fichier aboutit.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué en cas de réussite de l’opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué après réception des données par le serveur suite à un chargement de fichier réussi.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le serveur envoie des données après la réussite d’un chargement de fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un chargement échoue en raison d’une violation de sécurité.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un chargement échoue en raison d’une violation de la sécurité.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un chargement échoue en raison d’une erreur HTTP.
	
 	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un chargement échoue en raison d’une erreur HTTP.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>L’opération de chargement aboutit et le serveur renvoie une URL de réponse, ainsi que des en-têtes de réponse.
	
    </apiDesc></adobeApiEventDetail><shortdesc>L’opération de chargement aboutit et le serveur renvoie une URL de réponse, ainsi que des en-têtes de réponse.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Invoqué dans l’un des cas suivants :
    <ul>
    <li>Le chargement échoue à la suite d’une erreur d’entrée/de sortie survenue au cours de la lecture, de l’écriture ou de la transmission du fichier par <ph platform="actionscript">Flash Player ou </ph>Adobe AIR.</li>
    <li>Le chargement échoue en raison d’une tentative de chargement d’un fichier vers un serveur nécessitant une authentification (un nom d’utilisateur et un mot de passe, par exemple). Lors du chargement, les utilisateurs ne peuvent pas entrer des mots de passe.</li>
    <li>Le chargement échoue car le paramètre <codeph>url</codeph> contient un protocole non valide. La méthode <codeph>FileReference.upload()</codeph> doit utiliser HTTP ou HTTPS.</li>
    
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>Appelée dans l’un des cas suivants : Le chargement échoue en raison d’une erreur d’entrée/sortie survenue pendant la lecture, l’écriture ou la transmission du fichier par Flash Player ou Adobe AIR. Le chargement échoue en raison d’une tentative de chargement d’un fichier vers un serveur nécessitant une authentification (un nom d’utilisateur et un mot de passe, par exemple).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:uploadUnencoded"><apiName>uploadUnencoded</apiName><shortdesc>
    Lance le chargement d’un fichier dans une URL sans aucun encodage.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les fichiers SWF locaux non approuvés ne peuvent pas communiquer avec Internet. Pour contourner cette restriction, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé. Cette exception est renvoyée, accompagnée d’un message indiquant le nom du fichier local et l’URL qui ne sont pas accessibles.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Renvoyé dans les cas suivants : 1) Une autre session browse FileReference ou FileReferenceList est en cours. Il est impossible d’exécuter plusieurs sessions de recherche de fichiers simultanément. 2) Le paramètre URL n’est pas un chemin ou un protocole valide. Le chargement des fichiers doit se faire via HTTP.
	
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>L’objet URLRequest. La propriété <codeph>url</codeph> de cet objet doit contenir l’URL du script serveur configuré pour traiter le chargement via les appels HTTP <codeph>POST</codeph>. Dans certains navigateurs, la longueur des chaînes d’URL est limitée. Une longueur supérieure à 256 caractères peut échouer avec certains navigateurs ou serveurs. Si la valeur de ce paramètre est <codeph>null</codeph>, une exception est renvoyée.  
	 
	<p>L’URL peut être de type HTTP ou, pour les chargements sécurisés, de type HTTPS. Pour utiliser HTTPS, entrez une URL HTTPS dans le paramètre <codeph>url</codeph>. Si vous ne spécifiez pas de numéro de port dans le paramètre <codeph>url</codeph>, le port 80 pour HTTP et le port 443 pour HTTPS sont utilisés par défaut.</p>
	
	<p>Pour envoyer des paramètres <codeph>POST</codeph> ou <codeph>GET</codeph> au serveur, réglez la propriété <codeph>data</codeph> de l’objet URLRequest sur vos paramètres, et la propriété <codeph>method</codeph> sur <codeph>URLRequestMethod.POST</codeph> ou <codeph>URLRequestMethod.GET</codeph>.</p>
   	
    </apiDesc></apiParam><apiTipTexts><apiTipText>Procède au chargement d’un fichier sur un serveur distant sans encodage. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Lance le chargement d’un fichier dans une URL sans aucun encodage. Tandis que la méthode <codeph>upload()</codeph> convertit le fichier en enveloppe de données de formulaire, la méthode <codeph>uploadUnencoded()</codeph> transmet le contenu du fichier tel quel dans le corps de la requête HTTP. Utilisez la méthode uploadUnencoded() si les données que vous souhaitez envoyer sont déjà codées dans un format pris en charge par le serveur de réception. En règle générale, la méthode <codeph>uploadeUnencoded()</codeph> est utilisée avec la méthode <codeph>HTTP/WebDAV PUT</codeph>.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lors du démarrage d’une opération de chargement.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lors du démarrage d’une opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué régulièrement pendant l’opération de chargement de fichier.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué régulièrement pendant le chargement du fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsque l’opération de chargement de fichier aboutit.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué en cas de réussite de l’opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué après réception des données par le serveur suite à un chargement de fichier réussi.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsque le serveur envoie des données après la réussite d’un chargement de fichier.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un chargement échoue en raison d’une violation de sécurité.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un chargement échoue en raison d’une violation de la sécurité.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lorsqu’un chargement échoue en raison d’une erreur HTTP.
	
 	</apiDesc></adobeApiEventDetail><shortdesc>Distribué lorsqu’un chargement échoue en raison d’une erreur HTTP.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>L’opération de chargement aboutit et le serveur renvoie une URL de réponse, ainsi que des en-têtes de réponse.
	
	</apiDesc></adobeApiEventDetail><shortdesc>L’opération de chargement aboutit et le serveur renvoie une URL de réponse, ainsi que des en-têtes de réponse.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Invoqué dans l’un des cas suivants :
    <ul>
	<li>Le chargement échoue à la suite d’une erreur d’entrée/de sortie survenue au cours de la lecture, de l’écriture ou de la transmission du fichier par Adobe AIR.</li>
	<li>Le chargement échoue en raison d’une tentative de chargement d’un fichier vers un serveur nécessitant une authentification (un nom d’utilisateur et un mot de passe, par exemple). Lors du chargement, les utilisateurs ne peuvent pas entrer des mots de passe.</li>
	<li>Le chargement échoue car le paramètre <codeph>url</codeph> contient un protocole non valide. La méthode <codeph>FileReference.upload()</codeph> doit utiliser HTTP ou HTTPS.</li>
	</ul>
	
	</apiDesc></adobeApiEventDetail><shortdesc>Appelée dans l’un des cas suivants : Le chargement échoue en raison d’une erreur d’entrée/sortie survenue pendant la lecture, l’écriture ou la transmission du fichier par Adobe AIR. Le chargement échoue en raison d’une tentative de chargement d’un fichier vers un serveur nécessitant une authentification (un nom d’utilisateur et un mot de passe, par exemple).</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReference:creationDate:get"><apiName>creationDate</apiName><shortdesc>
    Date de création du fichier dans le disque local.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creationDate, FileReference.creationDate
    
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>Si l’appel de la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué. Dans ce cas, la valeur de la propriété <codeph>creationDate</codeph> correspond à <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>S’il est impossible d’accéder aux informations relatives au fichier, une exception indiquant qu’une erreur d’E/S s’est produite sur un fichier est renvoyée.
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Obtient la date de création du fichier en tant qu’objet Date.
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Date de création du fichier dans le disque local. Si l’objet n’a pas été renseigné, l’appel effectué pour obtenir la valeur de cette propriété renvoie <codeph>null</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:creator:get"><apiName>creator</apiName><shortdesc>
    Type de créateur Macintosh du fichier, uniquement utilisé dans les versions Mac OS antérieures à Mac OS X.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creator, FileReference.creator
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Sous Macintosh, si l’appel de la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué. Dans ce cas, la valeur de la propriété <codeph>creator</codeph> correspond à <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Type de créateur Macintosh.
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Type de créateur Macintosh du fichier, uniquement utilisé dans les versions Mac OS antérieures à Mac OS X. Sous Windows ou Linux, cette propriété est <codeph>null</codeph>. Si l’objet FileReference n’a pas été renseigné, l’appel effectué pour obtenir la valeur de cette propriété renvoie <codeph>null</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:data:get"><apiName>data</apiName><shortdesc>
    L’objet ByteArray représentant les données du fichier chargé après l’aboutissement d’un appel de la méthode load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
    </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>Si l’appel de la méthode <codeph>load()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué. Dans ce cas, la valeur de la propriété <codeph>data</codeph> est <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’ouverture ou la lecture du fichier est impossible, ou qu’une autre erreur d’accès au fichier survient, une exception indiquant qu’une erreur d’entrée ou de sortie s’est produite dans le fichier est renvoyée. Dans ce cas, la valeur de la propriété <codeph>data</codeph> est <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Données chargées du fichier, sous forme de ByteArray.
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    L’objet ByteArray représentant les données du fichier chargé après l’aboutissement d’un appel de la méthode <codeph>load()</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:extension:get"><apiName>extension</apiName><shortdesc>
	 Extension du fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si la référence n’est pas initialisée.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Extension du fichier.
	 
	 <p>L’extension d’un fichier correspond à la partie du nom qui suit le point final (« . »), sans inclure ce dernier. Si le nom du fichier ne comporte aucun point, l’extension est <codeph>null</codeph>.</p>
	 
	 <p><i>Remarque :</i> vous devez utiliser la propriété <codeph>extension</codeph> pour déterminer le type d’un fichier ; n’utilisez pas les propriétés <codeph>creator</codeph> et <codeph>type</codeph>. Ces propriétés<codeph> </codeph>sont<codeph> </codeph>en effet déconseillées, car elles s’appliquent à d’anciennes versions de Mac OS.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileReference:modificationDate:get"><apiName>modificationDate</apiName><shortdesc>
   Date de la dernière modification du fichier dans le disque local.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>modificationDate, FileReference.modificationDate
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>Si l’appel de la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué. Dans ce cas, la valeur de la propriété <codeph>modificationDate</codeph> correspond à <codeph>null</codeph>.
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>S’il est impossible d’accéder aux informations relatives au fichier, une exception indiquant qu’une erreur d’E/S s’est produite sur un fichier est renvoyée.
   
   </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Obtient la date de modification du fichier en tant qu’objet Date.
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   Date de la dernière modification du fichier dans le disque local. Si l’objet FileReference n’a pas été renseigné, l’appel effectué pour obtenir la valeur de cette propriété renvoie <codeph>null</codeph>.
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:name:get"><apiName>name</apiName><shortdesc>
   Nom du fichier dans le disque local.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
   </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si l’appel de la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué.
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Obtient le nom du fichier sous forme de chaîne.
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   Nom du fichier dans le disque local. Si l’objet FileReference n’a pas été renseigné (via un appel valide à <codeph>FileReference.download()</codeph> ou à <codeph> FileReference.browse()</codeph>), Flash Player renvoie une erreur lorsque vous tentez d’obtenir la valeur de cette propriété.
   <p>Toutes les propriétés d’un objet FileReference sont renseignées par appel de la méthode <codeph>browse()</codeph>. A la différence des autres propriétés FileReference, si vous appelez la méthode <codeph>download()</codeph>, la propriété <codeph>name</codeph> est renseignée lors de la distribution de l’événement <codeph>select</codeph>.</p>
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:size:get"><apiName>size</apiName><shortdesc>
  Taille du fichier dans le disque local, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Si l’appel de la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Si l’ouverture ou la lecture du fichier est impossible, ou qu’une autre erreur d’accès au fichier survient, une exception indiquant qu’une erreur d’entrée ou de sortie s’est produite dans le fichier est renvoyée.
  
  </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>La taille du fichier en octets.
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Taille du fichier dans le disque local, en octets. <ph platform="actionscript">Si la propriété <codeph>size</codeph> est définie sur 0, une exception est renvoyée.</ph>
  
  <p platform="actionscript"><i>Remarque :</i> dans la version initiale d’ActionScript 3.0, la propriété <codeph>size</codeph> était définie en tant qu’objet uint, qui prenait en charge des fichiers pouvant atteindre 4 Go. Elle est désormais désignée comme objet Number afin de prendre en charge des fichiers plus volumineux. </p>
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:type:get"><apiName>type</apiName><shortdesc>
  Type de fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>type, FileReference.type
  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si l’appel de la méthode <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> ou <codeph>FileReference.download()</codeph> n’a pas abouti, une exception est renvoyée, accompagnée d’un message indiquant que des fonctions ont été appelées dans un ordre incorrect ou qu’un appel antérieur a échoué. Dans ce cas, la valeur de la propriété <codeph>type</codeph> correspond à <codeph>null</codeph>.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Récupère le type ou l’extension du fichier.
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Type de fichier. 
  
  <p>Sous Windows ou Linux, cette propriété correspond à l’extension de fichier. Sous Macintosh, cette propriété correspond au type de fichier à quatre caractères, uniquement utilisé dans les versions de Mac OS antérieures à Mac OS X. Si l’objet FileReference n’a pas été renseigné, un appel permettant d’obtenir la valeur de cette propriété renvoie <codeph>null</codeph>.</p>
    
	<p>Sous Windows, Linux et Mac OS X, l’extension du fichier, c’est-à-dire la partie de la propriété <codeph>name</codeph> qui suit la dernière occurrence du point (.), permet d’identifier le type de fichier.</p>
	
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObjectFlushStatus"><apiName>SharedObjectFlushStatus</apiName><shortdesc>
 La classe SharedObjectFlushStatus fournit des valeurs pour le code renvoyé par un appel à la méthode SharedObject.flush().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SharedObjectFlushStatus fournit des valeurs pour le code renvoyé par un appel à la méthode <codeph>SharedObject.flush()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links><apiValue id="flash.net:SharedObjectFlushStatus:FLUSHED"><apiName>FLUSHED</apiName><shortdesc>
 Indique que la purge s’est bien terminée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>flushed</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Indique que la purge s’est bien terminée.
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObjectFlushStatus:PENDING"><apiName>PENDING</apiName><shortdesc>
 Indique que l’utilisateur a été invité à augmenter l’espace disque pour l’objet partagé avant la purge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pending</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Indique que l’utilisateur a été invité à augmenter l’espace disque pour l’objet partagé avant la purge.
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequest"><apiName>URLRequest</apiName><shortdesc>
  La classe URLRequest capture toutes les informations dans une même requête HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The above include is not a mistake, but rather code re-use.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  La classe URLRequest capture toutes les informations dans une même requête HTTP. Les objets URLRequest sont transmis aux méthodes <codeph>load()</codeph> des classes Loader, URLStream et URLLoader et autres opérations de chargement pour lancer les téléchargements d’URL. Ils sont également transmis aux méthodes <codeph>upload()</codeph> et <codeph>download()</codeph> de la classe FileReference.
 
  <p platform="actionscript">Un fichier SWF du sandbox local avec système de fichiers risque de ne pas charger des données depuis une ressource située dans le sandbox réseau, ni lui en fournir. </p>
 
  <p>Par défaut, le fichier <ph platform="actionscript">SWF </ph>appelant et l’URL chargée doivent se trouver dans le même domaine. Par exemple, un fichier <ph platform="actionscript">SWF </ph>à l’adresse www.adobe.com peut charger uniquement des données provenant de sources situées également à l’adresse www.adobe.com. <ph platform="actionscript">Pour charger des données à partir d’un autre domaine, placez un fichier de régulation d’URL sur le serveur hébergeant les données.</ph></p>
 
  <p> Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité de l’application (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité. Dans le cas de contenu s’exécutant dans Adobe AIR, les fichiers du sandbox de sécurité de l’application peuvent accéder aux URL à l’aide de l’un des modèles d’URL suivants :</p>

  <p platform="javascript"> Les fichiers situés dans le domaine de sécurité de l’application (fichiers installés avec l’application AIR), peuvent accéder aux URL en utilisant l’un des modèles d’URL suivants :</p>
 
 <ul>
 
  <li><codeph>http</codeph> et <codeph>https</codeph> </li>
 
  <li><codeph>file</codeph> </li>
 
  <li><codeph>app-storage</codeph> </li>
 
  <li><codeph>à partir</codeph> </li>
 
 </ul>
 
  <p>Le contenu <ph platform="actionscript">qui s’exécute dans Adobe AIR et </ph>qui n’est pas dans le sandbox de sécurité de l’application observe les mêmes restrictions que le contenu qui s’exécute dans le navigateur<ph platform="actionscript"> (dans Flash Player)</ph>, et le chargement est régi par le domaine du contenu<ph platform="actionscript"> et par les autorisations accordées dans les fichiers de régulation d’URL</ph>.</p>
 
 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
 
 <ul>
 
 <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i></li>
 
  <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\URLRequestExample.as"> L’exemple suivant crée un nouvel objet Loader et lui transmet un objet URLRequest contenant le chemin vers un fichier XML. Si le chargement réussit, un événement <codeph>complete</codeph> est distribué et les données du fichier XML sont écrites dans le résultat. Des gestionnaires d’événement supplémentaires capturent d’autres événements, y compris des événements d’erreur.
 <p>Pour exécuter cet exemple, placez un fichier nommé XMLFile.xml dans le même répertoire que votre fichier SWF.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestExample extends Sprite {

        public function URLRequestExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("XMLFile.xml");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequestDefaults"><linktext>URLRequestDefaults</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>Classe HTMLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLRequest:URLRequest"><apiName>URLRequest</apiName><shortdesc>
     Crée un objet URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>URL à demander. Vous pourrez définir l’URL ultérieurement à l’aide de la propriété <codeph>url</codeph>.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un objet URLRequest. Si <codeph>System.useCodePage</codeph> correspond à <codeph>true</codeph>, la requête est codée via la page de code système, plutôt que le format Unicode. Si <codeph>System.useCodePage</codeph> correspond à <codeph>false</codeph>, la requête est codée via le format Unicode, plutôt que la page de code système.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.system.xml#System/useCodePage"><linktext>flash.system.System.useCodePage</linktext></link></related-links></apiConstructor><apiValue id="flash.net:URLRequest:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	Indique si les requêtes d’authentification doivent être traitées (true) ou non (false) pour cette requête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Indique si les requêtes d’authentification de cette requête doivent être traitées (<codeph>true</codeph>) ou non (<codeph>false</codeph>). Si la valeur est <codeph>false</codeph>, les requêtes d’authentification renvoient une erreur HTTP.  
	
	<p>Les méthodes d’authentification prises en charge sont les suivantes :</p>
    
	<ul>
	
		<li>Windows : authentification HTTP de base/Digest, authentification intégrée de Windows (authentifications NTLM et Kerberos comprises), authentification de certificats SSL.</li>
    
		<li>Mac : authentification HTTP de base/Digest, NTLM, authentification de certificats SSL.</li>
	
	</ul>
	
	<p><b>Remarque </b>: les méthodes <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> et <codeph>HTMLLoader.load()</codeph> ne prennent pas en charge la propriété <codeph>URLRequest.authenticate</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/authenticate"><linktext>flash.net.URLRequestDefaults.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	Indique si les données de réponse satisfaisantes doivent être mises en mémoire cache pour cette requête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Indique si les données de réponse satisfaisantes doivent être mises en mémoire cache pour cette requête. Lorsque la valeur <codeph>true</codeph> est définie, l’application AIR utilise le cache HTTP du système d’exploitation.
	
	<p><b>Remarque </b>: la méthode <codeph>HTMLLoader.load()</codeph> ne prend pas en charge la propriété <codeph>URLRequest.cacheResponse</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/cacheResponse"><linktext>flash.net.URLRequestDefaults.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:contentType:get"><apiName>contentType</apiName><shortdesc>
     Type MIME du contenu dans la propriété data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Type MIME du contenu dans la propriété <codeph>data</codeph>.
     
     <p>La valeur par défaut est <codeph>application/x-www-form-urlencoded</codeph>.</p>
     
     <p><b>Remarque </b>: les méthodes <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> et <codeph>HTMLLoader.load()</codeph> ne prennent pas en charge la propriété <codeph>URLRequest.contentType</codeph>.</p>
     
     <p>Lors de l’envoi d’une requête POST, les valeurs des propriétés <codeph>contentType</codeph> et <codeph>data</codeph> doivent correctement correspondre. La valeur de la propriété <codeph>contentType</codeph> explique aux serveurs comment interpréter la valeur de la propriété <codeph>data.</codeph> </p>
     
     <ul> 
     <li>Si la valeur de la propriété <codeph>data</codeph> est un objet URLVariables, la valeur de <codeph>contentType</codeph> doit être <codeph>application/x-www-form-urlencoded</codeph>. </li>
     
     <li> Si la valeur de la propriété <codeph>data</codeph> est d’un autre type, la valeur de <codeph>contentType</codeph> doit indiquer le type des données POST à envoyer (données binaires ou de chaîne contenues dans la valeur de la propriété <codeph>data).</codeph> </li>
     
     <li>Pour <codeph>FileReference.upload()</codeph>, le Content-Type de la requête est automatiquement défini sur <codeph>multipart/form-data</codeph>, et la valeur de la propriété <codeph>contentType</codeph> est ignorée.</li>
     </ul>
     
     <p> Dans Flash Player versions 10 et ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête « content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul>
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p>Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/data"><linktext>data</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:data:get"><apiName>data</apiName><shortdesc>
     Objet contenant des données à transmettre avec la demande d’URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Objet contenant des données à transmettre avec la demande d’URL. 
     
     <p>Cette propriété s’utilise en combinaison avec la propriété <codeph>method</codeph>. Lorsque la valeur de la propriété <codeph>method</codeph> est <codeph>GET</codeph>, la valeur de <codeph>data</codeph> est ajoutée à la valeur de <codeph>URLRequest.url</codeph>, avec une syntaxe de chaîne de requête HTTP. Lorsque la valeur de la propriété <codeph>method</codeph> est <codeph>POST</codeph> (ou autre que <codeph>GET</codeph>), la valeur de <codeph>data</codeph> est transmise dans le corps de la requête HTTP.</p>
     
     <p>L’API URLRequest offre une prise en charge <codeph>POST</codeph> binaire et gère les variables de code URL, ainsi que les chaînes. Les objets de données peuvent être des objets ByteArray, URLVariables ou String.</p>
     
     <p>L’utilisation des données varie en fonction du type d’objet :</p>
     
     <ul>
     
         <li>Si l’objet est de type ByteArray, les données binaires correspondantes sont utilisées en tant que données <codeph>POST</codeph>. <codeph>GET</codeph> ne gère pas les données de type ByteArray. En outre, ces données ne sont pas prises en charge par <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph>.</li>
     
         <li>Si l’objet est de type URLVariables et que la méthode est <codeph>POST</codeph>, les variables sont codées au format <i>x-www-form-urlencoded</i> et la chaîne résultante sert de données <codeph>POST</codeph>. Un appel de <codeph>FileReference.upload()</codeph> constitue une exception : les variables sont incluses en tant que champs distincts dans un envoi <codeph>multipart/form-data</codeph>.</li>
     
      <li>Si l’objet est de type URLVariables et que la méthode correspond à <codeph>GET</codeph>, l’objet définit des variables à envoyer avec l’objet URLRequest.</li>
     
         <li>Dans tous les autres cas, l’objet est converti en une chaîne, qui est utilisée comme données <codeph>POST</codeph> ou <codeph>GET</codeph>.</li>
     
     </ul>
     
     <p>Les données ne sont pas envoyées tant qu’une méthode, telle que <codeph>navigateToURL()</codeph> ou <codeph>FileReference.upload()</codeph>, utilise l’objet URLRequest.</p>
     
     <p><b>Remarque</b> : la valeur de <codeph>contentType</codeph> doit correspondre au type de données défini dans la propriété <codeph>data</codeph>. Consultez la remarque de la description de la propriété <codeph>contentType</codeph>.</p>
     
     </apiDesc><example conref="examples\URLVariablesExample.as"> L’exemple suivant ouvre l’application distante hébergée à l’adresse http://www.[yourDomain].com/application.jsp dans une nouvelle fenêtre de navigateur et transmet à l’application des données relatives à une session utilisateur, capturées dans un objet URLVariables. 
  
 <p>Vous trouverez ci-dessous des extraits de l’exemple :</p>
 <ol>
    <li>La fonction constructeur crée une occurrence de URLRequest nommée <codeph>request</codeph>, en utilisant l’URL de l’application distante comme paramètre.</li>
    <li>Un objet URLVariables est créé et des valeurs sont attribuées à deux de ses propriétés.</li>
    <li>L’objet URLVariables est affecté à la propriété <codeph>data</codeph> de l’objet URLRequest.</li>
    <li>L’exemple appelle <codeph>navigateToURL</codeph>, qui ouvre une nouvelle fenêtre de navigateur vers l’URL de l’application distante.</li>
 </ol>
 <p> <b>Remarque :</b> pour exécuter l’exemple, l’URL de l’application distante de l’exemple doit être remplacée par une URL opérationnelle. En outre, du code serveur serait nécessaire pour traiter les informations capturées par Flash Player dans l’objet URLVariables.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/method"><linktext>URLRequest.method</linktext></link><link href="flash.net.xml#URLRequestMethod"><linktext>URLRequestMethod</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.net.xml#URLRequest/contentType"><linktext>contentType</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:digest:set"><apiName>digest</apiName><shortdesc>
     Chaîne qui identifie de façon unique le composant de la plateforme Adobe signé devant être enregistré dans (ou extrait de) la mémoire cache de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Le résumé fourni ne correspond pas à celui du fichier extrait à partir du fichier signé téléchargé ou du fichier signé chargé hors de la mémoire cache. L’application renvoie également cette erreur si le résumé fourni est de longueur incorrecte ou s’il contient des caractères non valides (non hexadécimaux).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Chaîne qui identifie de façon unique le composant de la plateforme Adobe signé devant être enregistré dans (ou extrait de) la mémoire cache de Flash Player. <ph platform="actionscript">Un composant de la plateforme Adobe est un fichier signé (un fichier SWZ) qui renferme le contenu SWF mis en cache de façon permanente sur l’ordinateur d’un utilisateur. Tous les fichiers SWZ sont signés par Adobe. Un résumé correspond à un seul fichier mis en cache ; si vous modifiez ce fichier de quelque manière que ce soit, son résumé risque de subir des modifications imprévisibles. L’utilisation d’un résumé vous permet de vérifier le fichier mis en cache dans plusieurs domaines. Deux fichiers possédant le même résumé correspondent au même fichier ; ce n’est pas le cas lorsque deux fichiers possèdent des résumés différents. Il est pratiquement impossible de créer un fichier pour « espionner » un résumé et prétendre en être un autre. </ph><ph platform="javascript">Cette propriété s’applique au contenu SWF uniquement ; elle ne s’applique pas au code JavaScript s’exécutant dans AIR.</ph>
     
     <p platform="actionscript">Le résumé est basé sur un algorithme Digest sécurisé SHA-256 (64 caractères en notation hexadécimale).</p>
     
     <p platform="actionscript">Par exemple, le kit de développement Flex comprend un fichier SWZ pour le cadre d’application Flex (et il fournit la chaîne digest pour ce fichier SWZ). Vous pouvez envoyer ce fichier SWZ au serveur Web et le charger dans votre fichier SWF (à l’aide de la méthode <codeph>load()</codeph> d’un objet URLLoader). Si l’ordinateur de l’utilisateur final possède déjà le fichier SWZ mis en cache correspondant, l’application l’utilise (un fichier SWZ « correspond » lorsque son <codeph>digest</codeph> correspond à celui que vous avez fourni). Dans le cas contraire, l’application télécharge le fichier SWZ à partir de l’URL que vous avez spécifiée. </p>
     
     <p platform="actionscript">Définissez le paramètre <codeph>digest</codeph> uniquement dans un objet URLRequest utilisé lors d’un appel de la méthode <codeph>URLLoader.load()</codeph> en vue de charger un fichier SWZ. Si la propriété <codeph>digest</codeph> d’un objet URLRequest est définie alors qu’elle est utilisée dans d’autres méthodes, l’application émet une exception IOError.</p>
     
     </apiDesc><example conref="examples\URLRequest_digest.as"> L’exemple suivant charge un fichier distant dans la mémoire cache. Une fois le chargement terminé, le tableau d’octets contient le fichier actuel (et non le fichier signé). L’exemple suivant termine l’opération de chargement en appelant <codeph>loadBytes()</codeph> :
<codeblock>
 
var myURLReq:URLRequest = new URLRequest();
myURLReq.url = "http://yourdomain/users/jdoe/test01/_rsc/Automated/AssetCaching_rsc/test01/rsl.swz";
myURLReq.digest = "3B0AA28C7A990385E044D80F5637FB036317BB41E044D80F5637FB036317BB41";
var myURLLoader:URLLoader = new URLLoader();
myURLLoader.dataFormat = URLLoaderDataFormat.BINARY;
myURLLoader.addEventListener("complete", onC);

myURLLoad.load(myURLReq);

function onC(e) {
    var someLoader:Loader = new Loader();
    addChild(someLoader);
    someLoader.loadBytes((ByteArray)(myURLLoad.data)); 
}

</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	Indique si des redirections sont utilisées (true) ou non (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Indique si des redirections sont utilisées (<codeph>true</codeph>) ou non (<codeph>false</codeph>). 
	
	<p><b>Remarque </b>: les méthodes <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> et <codeph>HTMLLoader.load()</codeph> ne prennent pas en charge la propriété <codeph>URLRequest.followRedirects</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/followRedirects"><linktext>URLRequestDefaults.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	Indique si la pile de protocole HTTP doit gérer les cookies pour cette requête. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true 
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Indique si la pile de protocole HTTP doit gérer les cookies pour cette requête. Lorsque la valeur <codeph>true</codeph> est définie, les cookies sont ajoutés à la requête et les cookies de réponse sont pris en compte. Si la valeur <codeph>false</codeph> est définie, les cookies ne sont <i>pas</i> ajoutés à la requête et les cookies de réponse ne sont <i>pas</i> pris en compte ; toutefois, les utilisateurs peuvent gérer eux-mêmes les cookies en manipulant directement l’en-tête. 
	
	<p>Sous Mac OS, les cookies sont partagés avec Safari. Pour supprimer les cookies sous Mac OS :</p>
	
	<ol>
		<li>Ouvrez Safari.</li>
      <li>Choisissez Safari > Préférences, puis cliquez sur le panneau Sécurité.</li>
      <li>Cliquez sur le bouton Afficher les cookies.</li>
		<li>Cliquez sur le bouton Tout supprimer.</li>
	</ol>
	
	<p>Pour supprimer les cookies sous Windows :</p>
	
	<ol>
		<li>Dans la boîte de dialogue Propriétés Internet, cliquez sur l’onglet Général.</li>
		<li>Cliquez sur le bouton Supprimer les cookies. </li>
	</ol>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/manageCookies"><linktext>flash.net.URLRequestDefaults.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:method:get"><apiName>method</apiName><shortdesc>
     Spécifie la méthode de soumission du formulaire HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Si le paramètre <codeph>value</codeph> n’est pas <codeph>URLRequestMethod.GET</codeph> ou <codeph>URLRequestMethod.POST</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>URLRequestMethod.GET
     
     </apiDefaultValue></apiValueDef><apiDesc>
     Spécifie la méthode de soumission du formulaire HTTP. 
     
     <p><ph platform="actionscript">Dans le cas de contenu SWF s’exécutant dans Flash Player (dans le navigateur), cette propriété est limitée à des opérations GET ou POST, et les valeurs valides sont <codeph>URLRequestMethod.GET</codeph> ou <codeph>URLRequestMethod.POST</codeph>.</ph></p>
     
     <p><ph platform="actionscript">Dans le cas de contenu s’exécutant dans Adobe AIR, vous</ph><ph platform="javascript">Vous</ph> pouvez utiliser n’importe quelle valeur de chaîne si le contenu se trouve dans le sandbox de sécurité de l’application. Dans le cas contraire, <ph platform="actionscript">notamment dans le cas de contenu s’exécutant dans Flash Player, </ph>vous pouvez utiliser uniquement les opérations GET ou POST<ph platform="javascript"> et les valeurs correctes sont <codeph>URLRequestMethod.GET</codeph> ou <codeph>URLRequestMethod.POST</codeph></ph>.</p>
     
     <p><ph platform="actionscript">Pour le contenu s’exécutant dans Adobe AIR, lors de</ph><ph platform="javascript">Lors de</ph> l’utilisation de la fonction <codeph>navigateToURL()</codeph>, le moteur d’exécution traite un objet URLRequest qui utilise la méthode POST (objet dont la propriété <codeph>method</codeph> est définie sur <codeph>URLRequestMethod.POST</codeph>) comme s’il utilisait la méthode GET.</p>
     
     <p><ph platform="actionscript"><b>Remarque :</b> dans le cas d’une exécution dans Flash Player et si la forme référencée n’a pas de corps, Flash Player utilise automatiquement une opération GET, même si la méthode est définie sur <codeph>URLRequestMethod.POST</codeph>. Il est donc conseillé de toujours inclure un corps factice pour être certain que la méthode correcte soit utilisée.</ph></p>
     
     </apiDesc><example conref="examples\URLRequest_method.as"> L’exemple suivant ouvre l’application distante hébergée à l’adresse http://www.[yourDomain].com/application.jsp dans une nouvelle fenêtre de navigateur et transmet à l’application des données relatives à une session utilisateur, capturées dans un objet URLVariables. Il définit explicitement la valeur de la propriété <codeph>URLRequest.method</codeph> sur <codeph>URLRequestMethod.POST</codeph>.
 <p>Vous trouverez ci-dessous des extraits de l’exemple :</p>
 <ol>
    <li>La fonction constructeur crée une occurrence de URLRequest nommée <codeph>request</codeph>, en utilisant l’URL de l’application distante comme paramètre.</li>
    <li>Un objet URLVariables est créé et des valeurs sont attribuées à deux de ses propriétés.</li>
    <li>L’objet URLVariables est affecté à la propriété <codeph>data</codeph> de l’objet URLRequest.</li>
  <li>La valeur de la propriété <codeph>URLRequest.method</codeph> est définie sur <codeph>URLRequestMethod.POST</codeph>.</li>
    <li>L’exemple appelle <codeph>navigateToURL</codeph>, qui ouvre une nouvelle fenêtre de navigateur vers l’URL de l’application distante.</li>
 </ol>
 <p> <b>Remarque :</b> pour exécuter l’exemple, l’URL de l’application distante de l’exemple doit être remplacée par une URL opérationnelle. En outre, du code serveur serait nécessaire pour traiter les informations capturées par Flash Player dans l’objet URLVariables.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequest_method extends Sprite {

        public function URLRequest_method() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            request.method = URLRequestMethod.POST;
            
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequestMethod"><linktext>Classe URLRequestMethod</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:requestHeaders:get"><apiName>requestHeaders</apiName><shortdesc>
     Tableau d’en-tête de requête HTTP à ajouter à la fin de la requête HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Tableau d’en-tête de requête HTTP à ajouter à la fin de la requête HTTP. Le tableau se compose d’objets URLRequestHeader. Tous les objets du tableau doivent être de type URLRequestHeader et contenir une chaîne de nom et une chaîne de valeur, comme suit : 
     <codeblock>
     var rhArray:Array = new Array(new URLRequestHeader("Content-Type", "text/html"));
     </codeblock>
     
     <p><ph platform="actionscript">Flash Player et le moteur d’exécution AIR imposent</ph><ph platform="javascript">Le moteur d’exécution AIR impose </ph> certaines restrictions sur les en-têtes de requêtes. Pour plus d’informations, voir la description de la classe URLRequestHeader.</p>
     
     <p>Toutes les méthodes qui acceptent des paramètres URLRequest ne prennent pas en charge la propriété <codeph>requestHeaders</codeph> ; consultez la documentation de la méthode que vous appelez. Par exemple, les méthodes <codeph>FileReference.upload()</codeph> et <codeph>FileReference.download()</codeph> ne prennent pas en charge la propriété <codeph>URLRequest.requestHeaders</codeph>.</p>
     <p>Du fait des limites des navigateurs, les en-têtes de requête HTTP personnalisées ne sont prises en charge que pour les requêtes <codeph>POST</codeph>, pas pour les requêtes <codeph>GET</codeph>.</p> 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:url:get"><apiName>url</apiName><shortdesc>
     URL à demander.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     URL à demander. 
     
     <p>Veillez à coder tous les caractères définis comme non fiables dans le document Uniform Resource Locator (http://www.faqs.org/rfcs/rfc1738.html) ou ceux réservés dans le modèle URL de l’objet URLRequest (s’ils ne sont pas utilisés comme caractères réservés). Utilisez <codeph>"%25"</codeph> comme symbole du pourcentage (%) et <codeph>"%23"</codeph> comme signe numérique (#), comme dans l’exemple suivant :<codeph> "http://www.example.com/orderForm.cfm?item=%23B-3&amp;discount=50%25"</codeph>.</p>
     
      <p>Par défaut, l’URL doit être dans le même domaine que le fichier appelant, sauf si le contenu s’exécute dans le sandbox de sécurité de l’application<ph platform="actionscript"> Adobe AIR</ph>. <ph platform="actionscript">Pour charger des données à partir d’un autre domaine, placez un fichier de régulation d’URL dans le serveur qui héberge les données</ph>. Pour plus d’informations, voir la description de la classe URLRequest.</p>
     
     <p><ph platform="actionscript">Dans le cas de contenu s’exécutant dans Adobe AIR, les fichiers</ph><ph platform="javascript">Fichiers</ph> situés dans le sandbox de sécurité de l’application, à savoir les fichiers installés avec l’application AIR, peuvent accéder aux URL à l’aide de l’un des modèles URL suivants :</p>
     
     <ul>
     
      <li><codeph>http</codeph> et <codeph>https</codeph> </li>
     
      <li><codeph>file</codeph> </li>
     
      <li><codeph>app-storage</codeph> </li>
     
      <li><codeph>à partir</codeph> </li>
     
     </ul>
     
     <p><b>Remarque :</b> IPv6 (Internet Protocol version 6) est pris en charge<ph platform="actionscript"> dans AIR et dans Flash Player 9.0.115.0 et versions ultérieures</ph>. IPv6 est une version du protocole IP (Internet Protocol) qui prend en charge les adresses 128 bits (amélioration du protocole IPv4 précédent qui prend en charge les adresses 32 bits). Vous devrez peut-être activer IPv6 sur vos interfaces de mise en réseau. Pour plus d’informations, voir l’Aide du système d’exploitation hébergeant les données. Si IPv6 est pris en charge sur le système hébergeant, vous pouvez spécifier des adresses littérales IPv6 numériques dans les URL entre crochets ([])<ph platform="actionscript">, comme suit</ph> : </p>
     
     <ph platform="actionscript">
     <pre>
     rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]:1935/test
     </pre>
     </ph>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:useCache:get"><apiName>useCache</apiName><shortdesc>
	Indique si le cache local doit être consulté avant que URLRequest récupère les données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Indique si le cache local doit être consulté avant que URLRequest récupère les données. 
	
	<p><b>Remarque </b>: la méthode <codeph>HTMLLoader.load()</codeph> ne prend pas en charge la propriété <codeph>URLRequest.useCache</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/useCache"><linktext>flash.net.URLRequestDefaults.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	Indique la chaîne agent utilisateur à utiliser dans la requête HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>L’appelant ne se trouve pas dans le sandbox de sécurité de l’application AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Indique la chaîne agent utilisateur à utiliser dans la requête HTTP. 
	
	<p platform="actionscript">La valeur par défaut correspond à la même chaîne agent utilisateur utilisée par Flash Player, différente dans Mac, Linux et Windows.</p>
	
	<p><i>Remarque :</i> cette propriété n’a pas d’incidence sur la chaîne agent utilisateur lors de l’utilisation de l’objet URLRequest avec la méthode <codeph>load()</codeph> d’un objet HTMLLoader. Pour définir la chaîne userAgent d’un objet HTMLLoader, définissez la propriété <codeph>userAgent</codeph> de l’objet HTMLLoader ou la propriété statique <codeph>URLRequestDefaults.userAgent</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/userAgent"><linktext>flash.net.URLRequestDefaults.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileFilter"><apiName>FileFilter</apiName><shortdesc>
 La classe FileFilter permet d’indiquer quels fichiers du système utilisateur sont répertoriés dans la boîte de dialogue de recherche de fichiers qui s’affiche lors de l’appel de la méthode FileReference.browse(), de la méthode FileReferenceList.browse(), ou d’une méthode de recherche d’un objet File, FileReference ou FileReferenceList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe FileFilter permet d’indiquer quels fichiers du système utilisateur sont répertoriés dans la boîte de dialogue de recherche de fichiers qui s’affiche lors de l’appel de la méthode <codeph>FileReference.browse()</codeph>, de la méthode <codeph>FileReferenceList.browse()</codeph>, ou d’une méthode de recherche d’un objet File, FileReference ou FileReferenceList. Les occurrences de FileFilter sont transmises à la méthode comme une valeur du paramètre facultatif <codeph>typeFilter</codeph>. Si vous utilisez une occurrence de FileFilter, les extensions et les types de fichiers qu’elle ne spécifie pas sont omis. En d’autres termes, les utilisateurs ne peuvent pas les sélectionner. Si aucun objet FileFilter n’est transmis à la méthode, tous les fichiers sont répertoriés dans la boîte de dialogue.
 
 <p>Vous pouvez utiliser les occurrences de FileFilter de deux façons :</p>
 
 <ul>
 
   <li>Une description avec les extensions de fichier uniquement.</li>
 
   <li>Une description avec les extensions de fichier et les types de fichiers Macintosh.</li>
 
 </ul>
 
 <p>Ces deux formats ne sont pas interchangeables dans le même appel de la méthode browse. Vous devez utiliser l’un ou l’autre.</p>
 
 <p>Vous pouvez transmettre une ou plusieurs occurrences de FileFilter à la méthode browse, comme dans l’exemple suivant :</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFileReference:FileReference = new FileReference();
 myFileReference.browse([imagesFilter, docFilter]);
 </codeblock>
 
 <p platform="actionscript">Dans le cas d’une application AIR :</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile:File = new File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <codeblock platform="javascript">
 var imagesFilter = new air.FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter = new air.FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile = new air.File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <p>La liste des extensions dans la propriété <codeph>FileFilter.extension</codeph> est utilisée pour filtrer les fichiers affichés dans la boîte de dialogue de recherche de fichiers. Cette liste n’est pas réellement affichée dans la boîte de dialogue. Pour afficher les types de fichiers aux utilisateurs, vous devez énumérer les types de fichiers dans la chaîne descriptive, ainsi que dans la liste d’extensions. Sous Windows et Linux, la chaîne descriptive est affichée dans la boîte de dialogue (elle n’est pas utilisée sous Macintosh <sup>®</sup>). Sous Macintosh, une liste de types de fichier Macintosh est utilisée pour filtrer les fichiers, si vous la fournissez. Si elle n’est pas fournie, la liste d’extensions de fichier est utilisée par défaut. </p> 
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:FileFilter:FileFilter"><apiName>FileFilter</apiName><shortdesc>
	 Crée une occurrence de FileFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>description</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne de description qui s’affiche lorsque les utilisateurs sélectionnent des fichiers à charger.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Liste des extensions indiquant quels formats de fichier s’affichent lorsque les utilisateurs sélectionnent des fichiers à charger.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>macType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Liste des types de fichiers Macintosh indiquant ceux qui s’affichent lorsque les utilisateurs sélectionnent des fichiers à charger. Si aucune valeur n’est transmise, ce paramètre est réglé sur <codeph>null</codeph>.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée une occurrence de FileFilter.
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:FileFilter:description:get"><apiName>description</apiName><shortdesc>
	 Chaîne de description du filtre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Chaîne de description du filtre. La description apparaît à l’utilisateur dans la boîte de dialogue qui s’affiche lors d’un appel de <codeph>FileReference.browse()</codeph> ou <codeph>FileReferenceList.browse()</codeph>. Elle contient une chaîne, telle que <codeph>Images (~~.gif, ~~.jpg, ~~.png)</codeph>, qui indique à l’utilisateur les types de fichiers qu’il peut charger ou télécharger. Sachez que les types de fichiers qui sont pris en charge par cet objet FileReference sont stockés dans la propriété <codeph>extension</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:extension:get"><apiName>extension</apiName><shortdesc>
	 Liste d’extensions de fichier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Liste d’extensions de fichier. Cette liste répertorie les types de fichiers à afficher dans la boîte de dialogue de recherche de fichiers (la liste n’apparaît pas à l’utilisateur, qui voit uniquement la valeur de la propriété <codeph>description</codeph>). La propriété <codeph>extension</codeph> contient une liste d’extensions de fichier délimitées par des points-virgules et précédées d’un caractère générique (~~), comme suit : <codeph>~~.jpg;~~.gif;~~.png</codeph>.
	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:macType:get"><apiName>macType</apiName><shortdesc>
	 Liste de types de fichiers Macintosh.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Liste de types de fichiers Macintosh. Cette liste répertorie les types de fichiers à afficher dans la boîte de dialogue de recherche de fichiers (la liste n’apparaît pas à l’utilisateur, qui voit uniquement la valeur de la propriété <codeph>description</codeph>). La propriété <codeph>macType</codeph> contient une liste de types de fichiers Macintosh délimités par des points-virgules, comme suit : <codeph>JPEG;jp2_;GIFF</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStream"><apiName>NetStream</apiName><shortdesc>
 La classe NetStream ouvre une connexion en flux continu unidirectionnel entre une application AIR ou Flash Player et Flash Media Server, ou entre une application AIR ou Flash Player et le système de fichiers local.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe NetStream ouvre une connexion en flux continu unidirectionnel entre une application AIR <ph platform="actionscript">ou Flash Player </ph>et Flash Media Server, ou entre une application AIR <ph platform="actionscript">ou Flash Player </ph>et le système de fichiers local. Un objet NetStream est un canal dans un objet NetConnection. Ce canal peut publier un flux, à l’aide de <codeph>NetStream.publish()</codeph>, ou s’abonner à un flux publié et recevoir des données, à l’aide de <codeph>NetStream.play()</codeph>. Vous pouvez publier ou lire des données en direct (en temps réel) et des données préalablement enregistrées. Vous pouvez également appeler la méthode <codeph>NetStream.send()</codeph> afin d’envoyer des messages textuels à tous les clients abonnés.
 
 <p platform="actionscript">La lecture de fichiers vidéo externes offre plusieurs avantages par rapport à l’intégration de vidéo dans un fichier SWF : amélioration des performances et de la gestion de la mémoire, indépendance par rapport aux cadences vidéo et SWF, etc. </p>
 
 <p>Adobe AIR, ainsi que Flash Player 9.0.115.0 et versions ultérieures prennent en charge les fichiers dérivés du format conteneur MPEG-4 standard, notamment F4V, MP4, M4A, MOV, MP4V, 3GP et 3G2, si ceux-ci contiennent des données vidéo H.264 et/ou des données audio codées HEAAC v2. H.264 produit une qualité vidéo supérieure à un débit inférieur par rapport au même profil d’encodage dans Sorenson ou On2. HE-AAC v2 est une extension de AAC (format audio standard défini dans la norme vidéo MPEG-4) qui utilise les techniques Spectral Band Replication (SBR) et Parametric Stereo (PS) pour un codage plus efficace à des débits lents. Pour plus d’informations sur les codecs et les formats de fichiers pris en charge, voir <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> et <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.</p>
 
 <p><b>Procédure pour la publication et la lecture de flux :</b></p>
 
 <ol>
 <li>Créez un objet NetConnection.</li>
 <li>Appelez la méthode <codeph>NetConnection.connect()</codeph> pour connecter l’occurrence de l’application au serveur.</li>
 <li>Créez un objet NetStream pour créer un flux au sein de la connexion.</li>
 <li>Pour saisir, coder et publier des données audio et vidéo, appelez les méthodes <codeph>NetStream.attachAudio()</codeph> et <codeph>NetStream.attachCamera()</codeph>.</li>
 <li>Appelez la méthode <codeph>NetStream.publish()</codeph> pour attribuer au flux continu un nom unique et envoyer les données en continu au serveur afin que d’autres puissent les recevoir. Vous pouvez aussi enregistrer les données au fur et à mesure que vous les publiez afin que les utilisateurs puissent les lire ultérieurement.</li>
 <li>Appelez la méthode <codeph>NetStream.play()</codeph> pour lire un flux en direct ou un flux enregistré. Transmettez à la méthode <codeph>play()</codeph> le nom de la chaîne transmise à la méthode <codeph>publish()</codeph>.</li>
 </ol>
 
 <p><b>Utilisation des images-clés de données avec Flash Media Server :</b> après avoir créé les objets NetConnection et NetStream, vous pouvez utiliser <codeph>NetStream.send()</codeph> pour ajouter des métadonnées aux données audio et vidéo en direct au fur et à mesure que vous les diffusez en continu au serveur. Les métadonnées peuvent être des informations comme la hauteur ou la largeur d’une vidéo, sa durée, le nom de son auteur, etc. Pour définir les métadonnées, utilisez le nom de gestionnaire spécial <codeph>@setDataFrame</codeph> comme premier argument de la méthode <codeph>NetStream.send()</codeph>.</p>
 
 <p><b>Réception de données à partir d’un flux Flash Media Server, d’un fichier F4V progressif ou d’un fichier FLV progressif :</b> les fichiers F4V, FLV et Flash Media Server peuvent envoyer des objets événement contenant des données à des points de données spécifiques pendant la diffusion ou la lecture. Vous pouvez gérer les données d’un flux ou d’un fichier FLV pendant la lecture de deux manières :</p>
 
 <ul><li>Associez une propriété client à un gestionnaire d’événement pour recevoir l’objet de données. Utilisez la propriété <codeph>NetStream.client</codeph> pour affecter un objet appelant des fonctions de gestion de données spécifiques. L’objet affecté à la propriété <codeph>NetStream.client</codeph> peut écouter les points de données suivants : <codeph>onCuePoint()</codeph>, <codeph>onImageData()</codeph>, <codeph>onMetaData()</codeph>, <codeph>onPlayStatus()</codeph>, <codeph>onTextData()</codeph> et <codeph>onXMPData()</codeph>. Ecrivez ensuite des procédures au sein de ces fonctions pour gérer l’objet de données renvoyé par le flux ou le fichier FLV pendant la lecture. Pour plus d’informations, voir la propriété <codeph>NetStream.client</codeph>.</li>
 <li>Associez une propriété client à une sous-classe de la classe NetStream, puis écrivez un gestionnaire d’événement pour recevoir l’objet de données. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li></ul>
 
 <p><b>Remarque :</b> pour envoyer des données par l’intermédiaire d’un fichier audio, tel qu’un fichier MP3, utilisez la classe Sound pour associer le fichier audio à un objet Sound. Ensuite, utilisez la propriété <codeph>Sound.id3</codeph> pour lire les métadonnées dans le fichier audio.</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> L’exemple suivant utilise un objet Video avec les classes NetConnection et NetStream pour charger et lire un fichier FLV. Pour exécuter cet exemple, vous avez besoin d’un fichier FLV dont le nom et l’emplacement correspondent avec la variable transmise à <codeph>videoURL</codeph> ; dans ce cas, un fichier FLV appelé Video.flv et stocké dans le même répertoire que le fichier SWF.
 <p>Dans cet exemple, le code qui crée les objets Video et NetStream et appelle les méthodes <codeph>Video.attachNetStream()</codeph> et <codeph>NetStream.play()</codeph> est placé dans une fonction de gestionnaire. Le gestionnaire n’est appelé que si la tentative de connexion à l’objet NetConnection a réussi ; c’est-à-dire lorsque l’événement <codeph>netStatus</codeph> renvoie un objet <codeph>info</codeph> avec une propriété <codeph>code</codeph> qui indique la réussite de l’opération. Il est recommandé d’attendre l’établissement d’une connexion avant d’appeler la méthode <codeph>NetStream.play()</codeph>. </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video"><linktext>flash.media.Video</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream_flash.events.DRMStatusEvent.DRM_STATUS_drmStatus"><apiName>drmStatus</apiName><shortdesc>
 Distribué lorsque la lecture du contenu chiffré à l’aide de la gestion des droits numériques (DRM) commence, c’est-à-dire lorsque l’utilisateur est authentifié et autorisé à lire le contenu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMStatusEvent.DRM_STATUS</apiEventType><adobeApiEventClassifier>flash.events.DRMStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque la lecture du contenu chiffré à l’aide de la gestion des droits numériques (DRM) commence, c’est-à-dire lorsque l’utilisateur est authentifié et autorisé à lire le contenu.
 <p>
 L’objet DRMStatusEvent contient des informations concernant le bon : possibilité d’accéder au contenu hors connexion, date d’expiration du bon ou fin d’affichage du contenu, entre autres.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMStatusEvent"><linktext>flash.events.DRMStatusEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMErrorEvent.DRM_ERROR_drmError"><apiName>drmError</apiName><shortdesc>
 Distribué lorsqu’un objet NetStream qui tente de lire un fichier chiffré à l’aide de la gestion des droits numériques (DRM) rencontre une erreur de type DRM.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMErrorEvent.DRM_ERROR</apiEventType><adobeApiEventClassifier>flash.events.DRMErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet NetStream qui tente de lire un fichier chiffré à l’aide de la gestion des droits numériques (DRM) rencontre une erreur de type DRM. Par exemple, un objet DRMErrorEvent est distribué lorsque l’autorisation utilisateur échoue. Il est en effet possible que l’utilisateur n’ait pas acquis les droits nécessaires à l’affichage du contenu ou que le fournisseur de contenu ne prenne pas en charge l’application d’affichage.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMErrorEvent"><linktext>flash.events.DRMErrorEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE_drmAuthenticate"><apiName>drmAuthenticate</apiName><shortdesc>
 Distribué lorsqu’un objet NetStream tente de lire un fichier chiffré à l’aide de la gestion des droits numériques (DRM) nécessitant l’obtention d’informations d’identification pour authentifier l’utilisateur avant la lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE</apiEventType><adobeApiEventClassifier>flash.events.DRMAuthenticateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet NetStream tente de lire un fichier chiffré à l’aide de la gestion des droits numériques (DRM) nécessitant l’obtention d’informations d’identification pour authentifier l’utilisateur avant la lecture. 
 
 <p>
 Utilisez la méthode <codeph>setDRMAuthenticationCredentials()</codeph> de l’objet NetStream pour authentifier l’utilisateur. Si l’authentification de l’utilisateur échoue, l’application relance l’authentification et distribue un nouvel événement DRMAuthenticateEvent pour l’objet NetStream.
 </p>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onDRMContentData"><apiName>onDRMContentData</apiName><shortdesc>
 Etablit un écouteur pour répondre lorsque AIR extrait les métadonnées de contenu DRM intégrées dans un fichier multimédia.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Etablit un écouteur pour répondre lorsque AIR extrait les métadonnées de contenu DRM intégrées dans un fichier multimédia.
 
 <p>Un objet DRMContentData contient les informations nécessaires à l’obtention du voucher requis pour lire un fichier multimédia protégé par DRM. Utilisez la classe DRMManager pour télécharger le voucher avec ces informations.</p>
 
 <p><codeph>onDRMContentData</codeph> est en fait une propriété de l’objet <codeph>NetStream.client</codeph>. Bien qu’elle ne soit pas un événement, elle est répertoriée dans la section Events, car elle correspond à un événement data lors du préchargement des données intégrées depuis un fichier multimédia local. Pour plus d’informations, voir la description de la classe NetStream. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher pour écouter ou traiter <codeph>onDRMContentData</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 <ul>
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
 </ul>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.xml#NetStream/preloadEmbeddedData()"><linktext>preloadEmbeddedData()</linktext></link><link href="flash.net.drm.xml#DRMManager"><linktext>flash.net.drm.DRMManager</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onPlayStatus"><apiName>onPlayStatus</apiName><shortdesc>
 Etablit un écouteur pour qu’il réponde lorsque un objet NetStream a terminé la lecture d’un flux.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Etablit un écouteur pour qu’il réponde lorsque un objet NetStream a terminé la lecture d’un flux. L’objet événement associé fournit des informations autres que ce renvoie l’événement <codeph>netStatus</codeph>. Vous pouvez utiliser cette propriété pour déclencher des actions dans votre code lorsqu’un objet NetStream est passé d’un flux continu à un autre dans une liste de lecture (ce qu’indique l’objet d’informations <codeph>NetStream.Play.Switch</codeph>) ou lorsque l’objet NetStream a terminé la lecture du flux continu (ce qu’indique l’objet d’informations <codeph>NetStream.Play.Complete</codeph>). 
 
 <p><codeph>onPlayStaus</codeph> est en fait une propriété de l’objet <codeph>NetStream.client</codeph>. Ce n’est pas un événement, mais il est listé dans la section Events car il répond à un événement de données, soit lorsqu’il diffuse avec Flash Media Server, soit lors de la lecture d’un fichier FLV. Pour plus d’informations, voir la description de la classe NetStream. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher pour écouter ou traiter <codeph>onPlayStatus</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 
 <ul>
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
    
 </ul>
 
 <p>Cet événement peut renvoyer un objet d’informations doté des propriétés suivantes :</p>
 
 <adobetable class="innertable">
  
  
  
   
 <tgroup cols="3"><thead><row><entry>Propriété du code</entry><entry>Propriété de niveau</entry><entry>Signification</entry></row></thead><tbody><row>
    <entry><codeph>NetStream.Play.Switch</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>L’abonné passe d’un flux continu à un autre dans une liste de lecture.</entry>
  </row><row>
    <entry><codeph>NetStream.Play.Complete</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>La lecture est terminée.</entry>
  </row><row>
    <entry><codeph>NetStream.Play.TransitionComplete</codeph></entry>
    <entry><codeph>"status"</codeph></entry>
    <entry>L’abonné bascule vers un nouveau flux en résultat du basculement du débit du flux.</entry>
  </row></tbody></tgroup></adobetable>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.events.xml#NetStatusEvent/NET_STATUS"><linktext>flash.events.NetStatusEvent.NET_STATUS</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onCuePoint"><apiName>onCuePoint</apiName><shortdesc>
 Etablit un écouteur pour qu’il réponde lorsqu’un point de repère intégré est atteint pendant la lecture d’un fichier vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Etablit un écouteur pour qu’il réponde lorsqu’un point de repère intégré est atteint pendant la lecture d’un fichier vidéo. Vous pouvez utiliser l’écouteur pour déclencher des actions dans votre code lorsque le fichier vidéo atteint un point de repère spécifique. Ceci vous permet de synchroniser d’autres actions dans votre application avec les événements de lecture vidéo. Pour plus d’informations sur les formats des fichiers vidéo pris en charge par Flash Media Server, voir <xref href="http://www.adobe.com/go/learn_fms_fileformats_fr" scope="external">www.adobe.com/go/learn_fms_fileformats_fr</xref>.

 
 <p><codeph>onCuePoint</codeph> est en fait une propriété de l’objet <codeph>NetStream.client</codeph>. Ce n’est pas un événement, mais il est listé dans la section Events car il répond à un événement de données, soit lorsqu’il diffuse avec Flash Media Server, soit lors de la lecture d’un fichier FLV. Pour plus d’informations, voir la description de la classe NetStream. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher pour écouter ou traiter <codeph>onCuePoint</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 
 <ul>
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
    
 </ul>
 
 <p>L’écouteur d’événement associé est déclenché après un appel de la méthode <codeph>NetStream.play()</codeph>, mais avant que la tête de lecture vidéo n’ait avancé.</p>
 
 <p>Il est possible d’imbriquer les types de point de repère suivants dans un fichier vidéo :</p>
 
 <ul>
 <li>Un point de repère de navigation spécifie, au sein du fichier vidéo, une image-clé à laquelle correspond la propriété <codeph>time</codeph> du point de repère. Les points de repère de navigation sont souvent utilisés comme signets ou points d’entrée pour permettre aux utilisateurs de parcourir le fichier vidéo.</li>
 
 <li>Un point de repère d’événement est spécifié par un minutage, que celui-ci corresponde ou non à une image-clé spécifique. Un point de repère d’événement représente généralement dans le fichier vidéo un minutage auquel il se produit un événement qui pourrait être utilisé pour déclencher d’autres événements d’application.</li>
 </ul>
 
 <p>L’objet événement <codeph>onCuePoint</codeph> possède les propriétés suivantes :</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Propriété</entry><entry>Description</entry></row></thead><tbody><row>
   <entry><codeph>name</codeph></entry>
   <entry>Nom attribué au point de repère lors de son imbrication dans le fichier vidéo.</entry></row><row>
   <entry><codeph>paramètres</codeph></entry>
   <entry>Tableau associatif de chaînes constituées de paires nom/valeur spécifiées pour ce point de repère. Il est possible d’utiliser toute chaîne valide pour le paramètre de nom ou de valeur.</entry>
 </row><row>
   <entry><codeph>time</codeph></entry>
   <entry>Durée (en secondes) jusqu’au point de repère qui survient dans le fichier vidéo au cours de la lecture.</entry>
 </row><row>
   <entry><codeph>type</codeph></entry>
   <entry>Type de point de repère atteint, navigation ou événement.</entry>
 </row></tbody></tgroup></adobetable>
 
 <p>Vous pouvez définir des points de repère dans un fichier vidéo lorsque vous encodez initialement celui-ci ou lorsque vous importez un clip vidéo dans l’outil de programmation de Flash à l’aide de l’assistant d’importation vidéo.</p>
 
 <p>L’événement <codeph>onMetaData</codeph> extrait également des informations sur les points de repère d’un fichier vidéo. Toutefois, l’événement <codeph>onMetaData</codeph> extrait des informations sur tous les points de repère avant le début de la lecture du fichier. L’événement <codeph>onCuePoint</codeph> extrait des informations sur un seul point de repère, au minutage spécifié pour ce point au cours de la lecture.</p>
 
 <p>En règle générale, pour que votre code réagisse à un certain point de repère au moment où il se produit, utilisez l’événement <codeph>onCuePoint</codeph> pour déclencher une action dans votre code.</p>
 
 <p>Vous pouvez utiliser la liste de points de repère fournie à l’événement <codeph>onMetaData</codeph> pour permettre à l’utilisateur de commencer à lire la vidéo à des points prédéfinis du flux vidéo. Transmettez la valeur de la propriété <codeph>time</codeph> du point de repère à la méthode <codeph>NetStream.seek()</codeph> pour lire la vidéo à partir de ce dernier.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onTextData"><apiName>onTextData</apiName><shortdesc>
  Etablit un écouteur pour qu’il réponde lorsque Flash Player reçoit des données texte intégrées dans un fichier multimédia en cours de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Etablit un écouteur pour qu’il réponde lorsque Flash Player reçoit des données texte intégrées dans un fichier multimédia en cours de lecture. Les données texte sont au format UTF-8 et peuvent contenir des informations sur la mise en forme basées sur la spécification Timed Text 3GP.
  <p><codeph>onTextData</codeph> est en fait une propriété de l’objet <codeph>NetStream.client</codeph>. Ce n’est pas un événement, mais il est listé dans la section Events car il répond à un événement de données, soit lorsqu’il diffuse avec Flash Media Server, soit lors de la lecture d’un fichier FLV. Pour plus d’informations, voir la description de la classe NetStream. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher pour écouter ou traiter <codeph>onTextData</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 
 <ul>
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
    
 </ul>
 
 <p>L’écouteur d’événement associé est déclenché après un appel de la méthode <codeph>NetStream.play()</codeph>, mais avant que la tête de lecture vidéo n’ait avancé.</p>
  
  <p>L’objet d’événement onTextData contient une propriété pour chaque partie de données texte.</p>
  
  </apiDesc><example conref="examples\OnTextDataExample.as"> Le code de cet exemple utilise la propriété <codeph>Netstream.client</codeph> pour gérer les fonctions de rappel pour <codeph>onTextData</codeph> et <codeph>onImageData</codeph>. La fonction <codeph>onImageDataHandler()</codeph> utilise l’objet d’événement onImageData <codeph>imageData</codeph> pour stocker le tableau d’octets. Et la fonction <codeph>onTextDataHandler()</codeph> utilise l’objet d’événement onTextData <codeph>textData</codeph> pour stocker les morceaux de données texte (chaque morceau de données est une propriété de l’objet <codeph>textData</codeph>).
 <p>Vous devez remplacer l’emplacement <codeph>« yourURL »</codeph> de votre code par un emplacement réel conduisant vers un fichier multimédia avec métadonnées d’image ou de texte.</p>
 <p> Vous pouvez également gérer les données de texte et d’images à l’aide d’une classe personnalisée. Reportez-vous à l’article <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Gestion des métadonnées et des points de repères dans Flash Video</xref> pour plus d’informations et d’exemples.</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onImageData"><apiName>onImageData</apiName><shortdesc>
 Etablit un écouteur pour qu’il réponde lorsque Flash Player reçoit des données d’images sous forme de tableau d’octets intégré dans un fichier multimédia en cours de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Etablit un écouteur pour qu’il réponde lorsque Flash Player reçoit des données d’images sous forme de tableau d’octets intégré dans un fichier multimédia en cours de lecture. Les données d’image peuvent produire du contenu JPEG, PNG ou GIF. Utilisez la méthode <codeph>flash.display.Loader.loadBytes()</codeph> pour charger le tableau d’octets dans un objet d’affichage.
 <p><codeph>onImageData</codeph> est en fait une propriété de l’objet <codeph>NetStream.client</codeph>. Ce n’est pas un événement, mais il est listé dans la section Events car il répond à un événement de données, soit lorsqu’il diffuse avec Flash Media Server, soit lors de la lecture d’un fichier FLV. Pour plus d’informations, voir la description de la classe NetStream. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher pour écouter ou traiter <codeph>onImageData</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 
 <ul>
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
    
 </ul>
 
 <p>L’écouteur d’événement associé est déclenché après un appel de la méthode <codeph>NetStream.play()</codeph>, mais avant que la tête de lecture vidéo n’ait avancé.</p>
 
 <p>L’objet d’événement onImageData contient les données d’images sous la forme d’un tableau d’octets envoyé par l’intermédiaire d’un canal de données AMF0.</p>
 
 </apiDesc><example conref="examples\OnTextDataExample.as"> Le code de cet exemple utilise la propriété <codeph>Netstream.client</codeph> pour gérer les fonctions de rappel pour <codeph>onTextData</codeph> et <codeph>onImageData</codeph>. La fonction <codeph>onImageDataHandler()</codeph> utilise l’objet d’événement onImageData <codeph>imageData</codeph> pour stocker le tableau d’octets. Et la fonction <codeph>onTextDataHandler()</codeph> utilise l’objet d’événement onTextData <codeph>textData</codeph> pour stocker les morceaux de données texte (chaque morceau de données est une propriété de l’objet <codeph>textData</codeph>).
 <p>Vous devez remplacer l’emplacement <codeph>« yourURL »</codeph> de votre code par un emplacement réel conduisant vers un fichier multimédia avec métadonnées d’image ou de texte.</p>
 <p> Vous pouvez également gérer les données de texte et d’images à l’aide d’une classe personnalisée. Reportez-vous à l’article <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Gestion des métadonnées et des points de repères dans Flash Video</xref> pour plus d’informations et d’exemples.</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onMetaData"><apiName>onMetaData</apiName><shortdesc>
 Etablit un écouteur pour qu’il réponde lorsque Flash Player reçoit une description intégrée à la vidéo en cours de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Etablit un écouteur pour qu’il réponde lorsque Flash Player reçoit une description intégrée à la vidéo en cours de lecture. Pour plus d’informations sur les formats des fichiers vidéo pris en charge par Flash Media Server, voir <xref href="http://www.adobe.com/go/learn_fms_fileformats_fr" scope="external">www.adobe.com/go/learn_fms_fileformats_fr</xref>.
 
 <p><codeph>onMetaData</codeph> est en fait une propriété de l’objet <codeph>NetStream.client</codeph>. Ce n’est pas un événement, mais il est listé dans la section Events car il répond à un événement de données, soit lorsqu’il diffuse avec Flash Media Server, soit lors de la lecture d’un fichier FLV. Pour plus d’informations, voir la description de la classe NetStream et de la propriété <codeph>NetStream.client</codeph>. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher, pour écouter ou traiter <codeph>onMetaData</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 
 <ul>
 
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
 
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
    
 </ul>
 
 <p>L’utilitaire Flash Video Exporter (version 1.1 ou supérieure) intègre la durée de la vidéo, sa date de création, les débits et d’autres informations dans le fichier vidéo. Différents encodeurs vidéo intègrent différents jeux de métadonnées.</p>
 
 <p>L’écouteur d’événement associé est déclenché après un appel de la méthode <codeph>NetStream.play()</codeph>, mais avant que la tête de lecture vidéo n’ait avancé.</p>
 
 <p>Dans la plupart des cas, la valeur de durée intégrée dans les métadonnées du flux se rapproche de la durée réelle, mais n’est pas exacte. En d’autres termes, elle ne correspond pas toujours à la valeur de la propriété <codeph>NetStream.time</codeph> lorsque la tête de lecture est à la fin du flux vidéo.</p>
 <p>L’objet événement transmis au gestionnaire d’événement onMetaData contient une propriété pour chaque élément de données.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onXMPData"><apiName>onXMPData</apiName><shortdesc>
 Définit un écouteur pour qu’il réponde lorsque Flash Player reçoit des informations spécifiques à XMP (Extensible Metadata Platform) d’Adobe, intégrées à la vidéo lue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Définit un écouteur pour qu’il réponde lorsque Flash Player reçoit des informations spécifiques à XMP (Extensible Metadata Platform) d’Adobe, intégrées à la vidéo lue. Pour plus d’informations sur les formats des fichiers vidéo pris en charge par Flash Media Server, voir <xref href="http://www.adobe.com/go/learn_fms_fileformats_fr" scope="external">www.adobe.com/go/learn_fms_fileformats_fr</xref>.
 
 <p><codeph>onXMPData</codeph> est en réalité une propriété de l’objet <codeph>NetStream.client</codeph>. Ce n’est pas un événement, mais il est listé dans la section Events car il répond à un événement de données, soit lorsqu’il diffuse avec Flash Media Server, soit lors de la lecture d’un fichier FLV. Pour plus d’informations, voir la description de la classe NetStream et de la propriété <codeph>NetStream.client</codeph>. Vous ne pouvez pas utiliser la méthode <codeph>addEventListener()</codeph>, ni toute autre méthode EventDispatcher, pour écouter ou traiter <codeph>onMetaData</codeph> comme un événement. Vous devez en revanche définir une fonction de rappel unique et l’associer directement à l’un des objets suivants :</p>
 
 <ul>
  <li>Objet auquel fait référence la propriété <codeph>client</codeph> d’une occurrence de NetStream.</li>    
  <li>Occurrence d’une sous-classe de NetStream. NetStream est une classe scellée, ce qui signifie qu’il est impossible d’ajouter des propriétés ou des méthodes à un objet NetStream à l’exécution. Vous pouvez cependant créer une sous-classe de NetStream et définir votre gestionnaire d’événements dans la sous-classe ou faire de celle-ci une sous-classe dynamique et ajouter la fonction de gestionnaire d’événement à une de ses occurrences.</li>
    
 </ul>
 
 <p>L’écouteur d’événement associé est déclenché après un appel de la méthode <codeph>NetStream.play()</codeph>, mais avant que la tête de lecture vidéo n’ait avancé.</p>
 
 <p>L’objet transmis à la fonction de gestion d’événement <codeph>onXMPData()</codeph> a une propriété <codeph>data</codeph>, qui correspond à une chaîne. La chaîne est générée à partir d’un champ UUID de premier niveau (l’UUID 128 bits du champ de premier niveau est <codeph>BE7ACFCB-97A9-42E8-9C71-999491E3AFAC</codeph>). Ce champ UUID de premier niveau contient un document XML représenté sous forme de chaîne UTF-8 terminée par un octet nul.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Distribué lorsqu’un objet NetStream publie son état ou signale une erreur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet NetStream publie son état ou signale une erreur. L’événement <codeph>netStatus</codeph> renferme une propriété <codeph>info</codeph> composée d’un objet d’informations contenant des informations spécifiques sur l’événement, telles que la réussite ou l’échec d’une tentative de connexion.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération réseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération réseau. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif. Cet événement est distribué lorsqu’un serveur appelle une méthode non définie sur le client.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>NetStream.onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>NetStream.onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Distribué lorsque l’application tente de lire un fichier chiffré à l’aide de la gestion des droits numériques (DRM) en appelant la méthode NetStream.play().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque l’application tente de lire un fichier chiffré à l’aide de la gestion des droits numériques (DRM) en appelant la méthode <codeph>NetStream.play()</codeph>. La valeur de la propriété du code d’état est la suivante : <codeph>"DRM.encryptedFLV"</codeph>. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:NetStream:NetStream"><apiName>NetStream</apiName><shortdesc>
 	 Crée un flux de diffusion en continu qui permet de lire des fichiers vidéo à l’aide de l’objet NetConnection spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>L’occurrence de NetConnection n’est pas connectée.
 	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>connection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>Objet NetConnection.
     </apiDesc></apiParam><apiParam><apiItemName>peerID</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>connectToFMS</apiData><apiDesc>Ce paramètre est facultatif. Il est disponible à partir de la version 10 de Flash Player. Définissez la valeur sur <codeph>NetStream.CONNECT_TO_FMS</codeph> pour une connexion à FMS. Pour publier directement sur des homologues (P2P), spécifiez <codeph>NetStream.DIRECT_CONNECTIONS</codeph>. Pour lancer directement la lecture depuis un homologue donné, spécifiez l’identité de ce dernier (voir <codeph>NetConnection.nearID</codeph> et <codeph>NetConnection.farID</codeph>). La valeur de la propriété <codeph>NetConnection.protocol</codeph> doit être <codeph>"rtmfp"</codeph> si le paramètre <codeph>peerID</codeph> est défini sur un homologue. Le paramètre <codeph>peerID</codeph> est ignoré pour les connexions non RTMFP. ActionScript utilise la valeur par défaut <codeph>"connectToFMS"</codeph> du paramètre <codeph>peerID</codeph> pour capturer le moment où une valeur nulle est transmise en tant que paramètre à la méthode NetStream(), par programmation.
     <p>Toutefois, le paramètre <codeph>peerID</codeph> étant facultatif, le code suivant continue de fonctionner pour une lecture progressive sur une connexion client/serveur :</p>
     <codeblock>
     new NetStream(nc:NetConnection);
     </codeblock>
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Crée un flux de diffusion en continu qui permet de lire des fichiers vidéo à l’aide de l’objet NetConnection spécifié. 
     
     <p>
     Pour plus d’informations sur les codecs et les formats de fichiers pris en charge, voir <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> et <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.
     </p>
	 
 	 </apiDesc><example conref="examples\NetStreamExample_constructor.as"> Le code suivant illustre une connexion permettant de télécharger et d’afficher, progressivement, une vidéo affectée à la variable <codeph>videoURL</codeph> :
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect(null);
            var my_ns:NetStream = new NetStream(my_nc);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example><example conref="examples\NetStreamExample_constructor2.as"> Le code suivant illustre une connexion permettant de diffuser et d’afficher une vidéo (affectée à la variable <codeph>videoURL</codeph>) sur une occurrence de Flash Media Server distante spécifiée dans la commande <codeph>connect()</codeph> :
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect("rtmp://www.yourfmsserver.com/someappname");
            var my_ns:NetStream = new NetStream(my_nc, NetStream.CONNECT_TO_FMS);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>flash.media.Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/CONNECT_TO_FMS"><linktext>CONNECT_TO_FMS</linktext></link><link href="flash.net.xml#NetStream/DIRECT_CONNECTIONS"><linktext>DIRECT_CONNECTIONS</linktext></link><link href="flash.net.xml#NetConnection/nearID"><linktext>flash.net.NetConnection.nearID</linktext></link><link href="flash.net.xml#NetConnection/farID"><linktext>flash.net.NetConnection.farID</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetStream:attachAudio"><apiName>attachAudio</apiName><shortdesc>
	 Spécifie un flux audio en continu envoyé via un objet NetStream, à partir d’un objet Microphone transmis en tant que source.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiDefaultValue>"null" 
	 </apiDefaultValue><apiParam><apiItemName>microphone</apiItemName><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier><apiDesc>Source du flux audio à transmettre.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie un flux audio en continu envoyé via un objet NetStream, à partir d’un objet Microphone transmis en tant que source. Cette méthode n’est accessible qu’à l’éditeur du flux continu spécifié.
	 
	 <p>La méthode <codeph>attachAudio</codeph> est conçue pour une utilisation avec Flash Media Server. Cette méthode est souvent appelée par un utilisateur qui envoie des données audio en direct (ou des données vidéo en direct avec son) depuis un ordinateur client vers le serveur.
	 </p>
	 
	 <p>Vous pouvez appeler cette méthode avant ou après la méthode <codeph>publish()</codeph> et le démarrage réel de la transmission. Les abonnés qui souhaitent entendre le son doivent appeler la méthode <codeph>NetStream.play()</codeph>. Réglez la propriété <codeph>rate</codeph> du microphone afin qu’elle corresponde à celle du périphérique de capture audio, puis définissez le seuil de silence via la méthode <codeph>setSilenceLevel()</codeph>. Vous pouvez contrôler les propriétés audio (volume et balance) de ce flux audio audio via la propriété <codeph>soundTransform</codeph> de l’objet du microphone.</p>
     <codeblock>
     var conn:NetConnection = new NetConnection();
     conn.connect("rtmp://server.domain.com/path");
     var stream:NetStream = new NetStream(conn);
     var live_mic:Microphone = Microphone.get();
     live_mic.rate = 8;
     live_mic.setSilenceLevel(20,200);
     var soundTrans:SoundTransform = new SoundTransform();
     soundTrans.volume = 6;
     live_mic.soundTransform = soundTrans;
     stream.attachAudio(live_mic);
     stream.publish("mic_stream","live")
     </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:attachCamera"><apiName>attachCamera</apiName><shortdesc>
	 Démarre la capture vidéo à partir de la caméra ou arrête la capture si theCamera est défini sur null.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>theCamera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>Source de la transmission vidéo. Les valeurs supportées sont un objet Camera (qui amorce la capture vidéo) et <codeph>null</codeph>. Si vous utilisez la valeur <codeph>null</codeph>, l’application interrompt la capture vidéo et tous les autres paramètres que vous envoyez sont ignorés. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>snapshotMilliseconds</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Spécifie si le flux vidéo est continu, une image unique ou une série d’images uniques utilisées pour créer une séquence en accéléré.
	 
	 <ul>
     <li>Si vous omettez ce paramètre, l’application capture toutes les données vidéo jusqu’à ce que vous transmettiez la valeur <codeph>null</codeph> à <codeph>attachCamera</codeph>.</li>
	 <li>Si vous transmettez 0, l’application capture une seule image vidéo. Utilisez cette valeur pour transmettre des « instantanés » dans un flux préexistant. <ph platform="actionscript">Flash Player ou </ph>AIR interprète les arguments non valides, négatif ou non numériques comme valeur 0.</li>
     <li>Si vous transmettez une valeur positive, l’application capture une image vidéo unique, puis ajoute une pause de la durée spécifiée en suffixe sur l’instantané. Utilisez cette valeur pour créer des effets d’accéléré.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Démarre la capture vidéo à partir de la caméra ou arrête la capture si <codeph>theCamera</codeph> est défini sur <codeph>null</codeph>. Cette méthode n’est accessible qu’à l’éditeur du flux continu spécifié. 
	 
     <p>Cette méthode est conçue pour une utilisation avec Flash Media Server. Pour plus d’informations, voir la description de la classe.</p>
	 
	 <p> Une fois la source vidéo associée, vous devez appeler <codeph>NetStream.publish()</codeph> pour commencer la transmission. Les abonnés qui souhaitent afficher la vidéo doivent appeler les méthodes <codeph>NetStream.play()</codeph> et <codeph>Video.attachCamera()</codeph> pour afficher la vidéo sur la scène.</p>
	 
	 <p>Vous pouvez utiliser <codeph>snapshotMilliseconds</codeph> pour envoyer un instantané unique (avec valeur 0) ou une série d’instantanés, soit une séquence en accéléré (time lapse), en spécifiant un nombre positif qui ajoute à la source vidéo le nombre indiqué de millisecondes. Ce nombre étend la durée d’affichage du message vidéo. Si vous appelez <codeph>attachCamera()</codeph> à plusieurs reprises en définissant une valeur positive pour <codeph>snapshotMilliseconds</codeph>, la séquence d’instantanés et les millisecondes supplémentaires en alternance créent une séquence en accéléré. Vous pouvez, par exemple, capturer une image par jour et l’ajouter à la fin du fichier vidéo. Lorsqu’un abonné lit le fichier, chaque image s’affiche pendant le nombre spécifié de millisecondes, puis l’image suivante apparaît.</p>
	 
	 <p>Le paramètre <codeph>snapshotMilliseconds</codeph> n’a pas le même objectif que le paramètre <codeph>fps</codeph>, que vous pouvez définir à l’aide de la méthode <codeph>Camera.setMode()</codeph>. Lorsque vous spécifiez <codeph>snapshotMilliseconds</codeph>, vous contrôlez le temps qui s’écoule entre les images enregistrées. Lorsque vous spécifiez <codeph>fps</codeph> à l’aide de <codeph>Camera.setMode()</codeph>, vous contrôlez le temps qui s’écoule à l’enregistrement et à la lecture.</p>
	 
	 <p>Imaginons, par exemple, que vous voulez capturer 100 instantanés, à raison d’un instantané toutes les 5 minutes. Deux solutions s’offrent à vous :</p>
     
	 <ul>
	 <li>Vous pouvez émettre une commande <codeph>NetStream.attachCamera(myCamera, 500)</codeph> à 100 reprises, toutes les 5 minutes. L’enregistrement prend 500 minutes, mais le fichier résultant est lu en 50 secondes (100 images, 500 millisecondes entre elles).</li> 
	 
	 <li>Vous pouvez émettre une commande <codeph>Camera.setMode()</codeph> en réglant <codeph>fps</codeph> sur 1/300 (une image toutes les 300 secondes, autrement dit, toutes les 5 minutes), puis une commande <codeph>NetStream.attachCamera(source)</codeph>, en laissant la caméra capturer des images en continu pendant 500 minutes. Il faudra 500 minutes pour lire le fichier produit ; en d’autres termes autant que pour l’enregistrer, chaque image étant affichée pendant 5 minutes.</li>
	 </ul>
     
	 <p>Ces deux techniques capturent les mêmes 500 images et les deux sont utiles. Votre choix doit être déterminé principalement par le type de lecture souhaité. Dans le second cas, par exemple, vous pourriez enregistrer du son en même temps. Par ailleurs, les deux fichiers feraient environ la même taille.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:close"><apiName>close</apiName><shortdesc>
	 Arrête la lecture des données du flux, définit la propriété time sur 0 et met le flux à disposition.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Arrête la lecture des données du flux, définit la propriété <codeph>time</codeph> sur 0 et met le flux à disposition. Cette méthode supprime également la copie locale d’un fichier vidéo téléchargé via HTTP. Même si l’application supprime la copie locale du fichier qu’il crée, une copie peut subsister dans le répertoire cache. Si vous devez empêcher toute mise en cache ou tout stockage local du fichier vidéo, utilisez Flash Media Server.
     
     <p>
     Avec Flash Media Server, cette méthode est invoquée implicitement lorsque vous appelez <codeph>NetStream.play()</codeph> depuis un flux de publication ou <codeph>NetStream.publish()</codeph> depuis un flux d’abonnement. Veuillez noter que :
     </p>
     
     <ul>
     <li>
     Si <codeph>close()</codeph> est appelée depuis un flux de publication, le flux arrête la publication et l’éditeur peut alors utiliser ce flux dans un autre but. Les abonnés ne reçoivent plus aucun élément publié sur ce flux, car ce dernier a arrêté la publication. 
     </li>
     <li>
     Si <codeph>close()</codeph> est appelée depuis un flux d’abonnement, le flux arrête la lecture pour l’abonné et ce dernier peut utiliser ce flux dans un autre but. Les autres abonnés ne sont pas affectés.
     </li>
     <li>
     Vous pouvez arrêter la lecture d’un flux d’abonnement sans fermer le flux ou modifier le type de flux en utilisant <codeph>flash.net.NetStream.play(false)</codeph>.
     </li>
     </ul>
     
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/publish()"><linktext>publish()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:onPeerConnect"><apiName>onPeerConnect</apiName><shortdesc>
	 
     Invoqué lorsqu’un flux d’homologue éditeur correspond à un flux d’homologue abonné.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscriber</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 
     Invoqué lorsqu’un flux d’homologue éditeur correspond à un flux d’homologue abonné. Avant que l’abonné ne soit connecté à l’éditeur, appelez cette méthode pour permettre au code ActionScript de contrôler l’accès en vue d’une publication homologue à homologue. Le code suivant montre un exemple de création d’une fonction de rappel pour cette méthode :
     <codeblock>
	 var c:Object = new Object;
	 c.onPeerConnect = function(subscriber:NetStream):Boolean {
	 if (accept)
	 	return true;
	  else
	      return false;
	  };
	  m_netStream.client = c;
     </codeblock>
     
     <p>Si l’éditeur homologue n’implémente pas cette méthode, tous les homologues sont autorisés à lire tout contenu publié.</p>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:pause"><apiName>pause</apiName><shortdesc>
	 Interrompt la lecture d’un flux vidéo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.pause, pause
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Interrompt la lecture d’un flux vidéo. L’appel de cette méthode n’a aucune incidence si la vidéo est déjà en pause. Pour reprendre la lecture d’une vidéo après une pause, appelez <codeph>resume()</codeph>. Pour basculer entre la pause et la lecture (en commençant par mettre la vidéo en pause, puis en reprenant la lecture), appelez <codeph>togglePause()</codeph>.
	 
	 <p>Depuis Flash Player 9.0.115.0, le lecteur n’efface plus la mémoire tampon lors de l’appel de <codeph>NetStream.pause()</codeph>. Avant Flash Player 9.0.115.0, le lecteur attendait le remplissage du tampon avant de reprendre la lecture, ce qui entraînait souvent des retards.</p>
	 
	 <p>En cas d’interruption unique, la propriété <codeph>NetStream.bufferLength</codeph> possède une limite de 60 secondes ou de deux fois la valeur de <codeph>NetStream.bufferTime</codeph> (la limite supérieure est prise en compte). Par exemple, si la propriété <codeph>bufferTime</codeph> est de 20 secondes, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la propriété <codeph>NetStream.bufferLength</codeph> corresponde à la valeur la plus élevée de 20~~2 (c’est-à-dire 40), ou à la valeur 60 ; dans ce cas, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la valeur de <codeph>bufferLength</codeph> corresponde à 60. Si la propriété <codeph>bufferTime</codeph> est de 40 secondes, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la propriété <codeph>bufferLength</codeph> corresponde à la valeur la plus élevée de 40~~2 (c’est-à-dire 80), ou à la valeur 60 ; dans ce cas, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la valeur de <codeph>bufferLength</codeph> corresponde à 80.</p>
	 
	 <p>La propriété <codeph>bufferLength</codeph> possède en outre une limite absolue. Si un appel à <codeph>pause()</codeph> provoque l’augmentation de <codeph>bufferLength</codeph> de plus de 600 secondes, ou la valeur de plus élevée de <codeph>bufferTime</codeph> ~~ 2, Flash Player efface le contenu de la mémoire tampon et remet à zéro <codeph>bufferLength</codeph>. Par exemple, si la propriété <codeph>bufferTime</codeph> est de 120 secondes, Flash Player efface le contenu de la mémoire tampon si la propriété <codeph>bufferLength</codeph> atteint 600 secondes ; si <codeph>bufferTime</codeph> est de 360 secondes, Flash Player efface le contenu de la mémoire tampon si <codeph>bufferLength</codeph> atteint 720 secondes.</p>
	 
	 <p><b>Conseil </b>: vous pouvez utiliser <codeph>NetStream.pause()</codeph> dans le code pour mettre les données en mémoire tampon pendant que les spectateurs regardent une annonce publicitaire, par exemple, puis annuler l’interruption lorsque la vidéo principale démarre.</p>
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:play"><apiName>play</apiName><shortdesc>
     Lit les fichiers multimédias.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>"at"see flash.media.Video#attachVideo()  This method no longer exists.  Replace with new method.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les fichiers SWF locaux et non approuvés ne peuvent pas communiquer avec Internet. Pour contourner cette restriction, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Il est nécessaire de spécifier au moins un paramètre.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>L’objet NetStream n’est pas valide. Cela peut être dû à un échec de NetConnection.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Emplacement du fichier multimédia à lire en tant que chaîne, propriété <codeph>URLRequest.url</codeph> ou variable référençant l’un ou l’autre. Dans <ph platform="actionscript">Flash Player et dans le contenu </ph>AIR hors du sandbox de sécurité de l’application, vous pouvez lire les fichiers vidéo locaux stockés dans le même répertoire que le fichier SWF ou dans un sous-répertoire. Vous ne pouvez toutefois pas naviguer vers un répertoire de niveau supérieur.
	 
	 <p>
	 Avec Flash Media Server, <codeph>play()</codeph> prends les arguments suivants :
	 </p>
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Nom</entry><entry>Obligatoire</entry><entry>Description</entry></row></thead><tbody><row>
	   <entry><codeph>name:Object</codeph></entry>
	   <entry>Obligatoire </entry>
       <entry> Nom d’un fichier enregistré, un identifiant des données en direct publiées par <codeph>NetStream.publish()</codeph> ou <codeph>false</codeph>. Si <codeph>false</codeph>, le flux arrête la lecture et tout paramètre supplémentaire est ignoré. Pour plus d’informations sur la syntaxe du nom de fichier, voir le tableau répertoriant les formats de fichier ci-après.</entry>
	 </row><row>
	   <entry><codeph>start:Number</codeph></entry>
	   <entry>Facultatif</entry>
	   <entry> Renvoie l’instant de départ, en secondes. Les valeurs autorisées sont -2, -1, 0 ou un nombre positif. La valeur par défaut est -2, qui recherche un flux en direct, puis un flux enregistré, et ouvre un flux en direct lorsqu’il ne trouve ni l’un ni l’autre. Si -1, lit uniquement un flux en direct. Si 0 ou un nombre positif, lit un flux enregistré en commençant par <codeph>start</codeph> en secondes.
	   </entry>
	 </row><row>
	   <entry> <codeph>len:Number</codeph> </entry>
	   <entry> Facultatif si <codeph>start</codeph> est spécifié. </entry>
	   <entry> Durée de la lecture, en secondes. Les valeurs autorisées sont -1, -0 ou un nombre positif. La valeur par défaut est -1, qui lit un flux en direct ou enregistré jusqu’à la fin. Si 0, lit une unique image de <codeph>start</codeph> secondes par rapport au début d’un flux enregistré. S’il s’agit d’un nombre positif, lit un flux en direct ou enregistré pendant <codeph>len</codeph> secondes.
	   </entry>
	 </row><row>
	   <entry> <codeph>reset:Object</codeph> </entry>
	   <entry> Facultatif si <codeph>len</codeph> est spécifié. </entry>
	   <entry> Indique si une liste de lecture doit être effacée. La valeur par défaut est 1 ou <codeph>true</codeph>, qui efface tous les appels <codeph>play</codeph> précédents et lit <codeph>name</codeph> immédiatement. Si 0 ou <codeph>false</codeph>, ajoute le flux dans une liste de lecture. Si 2, conserve la liste de lecture et renvoie tous les messages du flux en une seule opération, plutôt que par intervalles. Si 3, efface la liste de lecture et renvoie tous les messages du flux en une seule opération.  </entry>
	 </row></tbody></tgroup></adobetable>
	 
     <p>
     Vous pouvez lire les formats de fichier décrits dans le tableau suivant. La syntaxe varie selon le format de fichier.</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Format de fichier</entry><entry>Syntaxe</entry><entry>Exemple</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>Spécifiez le nom du flux en tant que chaîne, sans extension de nom de fichier.</entry>
     <entry><codeph>ns.play("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 ou ID3</entry>
     <entry>Spécifiez le nom du flux en tant que chaîne, avec le préfixe <codeph>mp3:</codeph> ou <codeph>id3:</codeph> et sans extension de nom de fichier.</entry>
     <entry><codeph>ns.play("mp3:mymp3stream");</codeph> <codeph>ns.play("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>Fichiers basés sur le format MPEG-4 (F4V et MP4, entre autres)</entry>
      <entry>Spécifiez le nom du flux en tant que chaîne, avec le préfixe <codeph>mp4:</codeph> avec ou sans extension de nom de fichier. Le préfixe indique au serveur que le fichier contient des données vidéo H.264 et des données audio AAC au format conteneur MPEG-4 Part 14. Si le fichier sur le serveur possède une extension de nom de fichier, spécifiez-en une. Si une extension de nom de fichier a été précisée dans la méthode <codeph>publish()</codeph>, spécifiez-en une.</entry>
     <entry><codeph>ns.play("mp4:myvideo.f4v")</codeph> <codeph>ns.play("mp4:myvideo.mp4")</codeph> <codeph>ns.play("mp4:myvideo")</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit les fichiers multimédias. 
     
     <p>
     Pour plus d’informations sur les codecs et les formats de fichiers pris en charge, voir <xref href="http://www.adobe.com/go/hardware_scaling_fr" scope="external">http://www.adobe.com/go/hardware_scaling_fr</xref> et <xref href="http://www.adobe.com/go/learn_fms_fileformats_fr" scope="external">www.adobe.com/go/learn_fms_fileformats_fr</xref>.</p>
     
	 <p>Pour visualiser les données vidéo, créez un objet Video et appelez la méthode <codeph>Video.attachNetStream()</codeph>. Pour diffuser des données audio en continu à partir d’un microphone, utilisez la méthode <codeph>NetStream.attachAudio()</codeph>. Utilisez l’objet Microphone pour contrôler certains aspects du son.</p>
	 
	 <p>Appelez la méthode <codeph>DisplayObjectContainer.addChild()</codeph> pour ajouter le son à un objet de la liste d’affichage. Vous pouvez ensuite créer un objet Sound pour contrôler certains aspects du son. Pour plus d’informations, voir la méthode <codeph>DisplayObjectContainer.addChild()</codeph>.</p>
	 
	 <p>Si le fichier vidéo est introuvable, l’objet <codeph>NetStatusEvent</codeph> est distribué.</p>
	 
     <p>Lorsque vous utilisez cette méthode sans Flash Media Server, il existe certaines contraintes de sécurité. Un fichier , placé dans le sandbox local approuvé ou local avec accès au réseau, peut charger et lire un fichier vidéo à partir du sandbox distant. Cependant, il ne peut pas accéder aux données de ce fichier distant sans une autorisation explicite, accordée sous forme de fichier de régulation d’URL. <ph platform="actionscript">Vous pouvez en outre empêcher un fichier SWF s’exécutant dans Flash Player d’utiliser cette méthode ; pour cela, vous devez définir le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui comporte le contenu SWF.</ph></p>
	 
      <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
      <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
	 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
	 
     <ul>
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     <li>Propriété <codeph>Netstream.checkPolicyFile</codeph>.</li>
     </ul>
     
	 
     </apiDesc><example><b>Flash Media Server</b> Cet exemple lit un fichier F4V enregistré, en commençant au début, pendant 100 secondes au maximum : Pour les fichiers MPEG-4 possédant sur le serveur une extension de nom de fichier, spécifiez-en une dans la méthode <codeph>play()</codeph>. 
	 <codeblock>
     ns.play("mp4:record1.f4v", 0, 100, true);
	 </codeblock>
	 
	 </example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>DisplayObjectContainer.addChild()</linktext></link><link href="flash.net.xml#NetStream/checkPolicyFile"><linktext>checkPolicyFile</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream:play_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lors d’une tentative de lecture d’un fichier chiffré à l’aide de la gestion des droits numériques (DRM). La valeur de la propriété <codeph>code</codeph> est <codeph>"DRM.encryptedFLV"</codeph>.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lors d’une tentative de lecture d’un fichier chiffré à l’aide de la gestion des droits numériques (DRM).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetStream:play2"><apiName>play2</apiName><shortdesc>
     Commence la lecture des fichiers multimédia, avec plusieurs options de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
     Commence la lecture des fichiers multimédia, avec plusieurs options de lecture.
     
     <p>Cette méthode est une version améliorée de <codeph>NetStream.play()</codeph>. Comme la méthode <codeph>play()</codeph>, la méthode <codeph>play2()</codeph> commence la lecture d’un fichier multimédia ou met des fichiers multimédia en file d’attente pour créer une liste de lecture. Lorsqu’elle est utilisée avec Flash Media Server, elle peut également demander au serveur de basculer vers un autre fichier multimédia. La transition est transparente dans l’application client.</p> 
     
     <p>Utilisez la méthode <codeph>play2()</codeph> pour basculer vers un flux de même contenu chiffré avec des débits différents ou pour changer de flux à partir d’une liste de lecture. Utilisez la classe <codeph>NetStreamInfo</codeph> pour gérer les conditions du réseau et changer de flux en fonction des données. Vous pouvez également changer de flux pour des clients ayant des capacités différentes. On appelle <i>diffusion dynamique en continu</i> l’utilisation d’ActionScript pour changer de flux. Pour plus d’informations, recherchez « diffusion dynamique en continu » dans le « Guide du développeur d’Adobe Flash Media Server » à l’adresse <xref href="http://www.adobe.com/go/learn_fms_devguide_en">www.adobe.com/go/learn_fms_devguide_fr</xref>. Adobe a conçu une classe ActionScript personnalisée appelée DynamicStream qui étend la classe NetStream. Vous pouvez utiliser la classe DynamicStream pour implémenter la diffusion dynamique en continu dans une application au lieu d’écrire votre propre code afin de détecter les conditions du réseau. Même si vous choisissez d’écrire votre propre code de diffusion dynamique en continu, consultez la classe DynamicStream pour obtenir un exemple d’implémentation. Téléchargez la classe et la documentation correspondante à l’adresse suivante : <xref href="http://www.adobe.com/go/fms_tools">www.adobe.com/go/fms_tools_fr</xref>.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:preloadEmbeddedData"><apiName>preloadEmbeddedData</apiName><shortdesc>
	 Extrait les métadonnées DRM d’un fichier multimédia enregistré localement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier><apiDesc>Un objet NetStreamPlayOptions décrivant les options à utiliser lors du traitement du fichier de contenu.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Extrait les métadonnées DRM d’un fichier multimédia enregistré localement.
	 
	 <p>Utilisez tout d’abord <codeph>preloadEmbeddedMetaData()</codeph> lors du téléchargement et de la mise en mémoire cache des vouchers DRM nécessaires à la lecture hors ligne. Lorsque des métadonnées DRM intégrées sont détectées dans un fichier multimédia, un objet DRMContentData est transmis à la fonction <codeph>onDRMContentData</codeph> du client NetStream. Cet objet DRMContentData contient les informations nécessaires à l’obtention du voucher requis pour lire le contenu. Transmettez DRMContentDataObject à la méthode DRMManager <codeph>loadVoucher()</codeph> pour télécharger le voucher.</p>
	 
	 <p>Les étapes pour précharger un voucher DRM sont les suivantes :</p>
	 <ul>
	 <li>
	 <p>Créez un nouvel objet NetStream pour précharger les métadonnées.</p>
	 </li>
	 <li>Affectez une fonction de rappel à la propriété <codeph>onDRMContentData</codeph> du <codeph>client</codeph> NetStream.</li>
	 <li>Créez un nouvel objet NetStreamPlayOptions, puis définissez la propriété <codeph>streamName</codeph> sur la chaîne URL du fichier vidéo local.</li>
	 <li>Appelez <codeph>preloadEmbeddedMetadata()</codeph>, tout en transmettant l’objet NetStreamPlayOptions.</li>
	 <li>En réponse au rappel <codeph>onDRMContentData</codeph>, appelez la méthode <codeph>loadVoucher()</codeph> de DRMManager, tout en transmettant l’objet DRMContentData. Si la propriété <codeph>authenticationMethod</codeph> de l’objet DRMContentData est définie sur la valeur <codeph>userNameAndPassWord</codeph>, vous devez authentifier l’utilisateur sur le serveur de droits multimédias avant de charger le voucher.</li>
	 <li>Fermez l’objet NetStream avant le préchargement.</li> 
	 </ul>
	 
	 <p><b>Remarque :</b> si vous utilisez le même objet NetStream pour précharger les métadonnées et lire le contenu, vous devez attendre l’appel de <codeph>onPlayStatus</codeph> généré par l’opération de préchargement avant de commencer la lecture.</p>
	 
	 <p>Les vouchers téléchargés sont stockés dans une mémoire cache locale. La lecture de contenu en ligne permet également de télécharger et de mettre en cache les vouchers. Lors de la visualisation d’un fichier dont le contenu est protégé par DRM, un voucher mis en cache est automatiquement récupéré à partir du magasin local. Utilisez DRMManager pour gérer la mémoire cache du voucher.</p>
	   
	 <p><b>Remarques :</b> le préchargement des métadonnées DRM via une connexion HTTP, HTTPS ou RTMP n’est pas pris en charge. Vous ne pouvez précharger des métadonnées qu’à partir de fichiers enregistrés sur le systèmes de fichiers.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/event:onDRMContentData"><linktext>onDRMContentData</linktext></link><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.drm.xml#DRMManager/loadVoucher()"><linktext>flash.net.drm.DRMManager.loadVoucher()</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:publish"><apiName>publish</apiName><shortdesc>
	 Envoie des données audio, vidéo et des messages texte en diffusion continue d’un client au Flash Media Server, en enregistrant éventuellement le flux continu pendant la transmission.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chaîne identifiant le flux continu. Les clients qui s’abonnent à ce flux continu doivent transmettre le même nom lorsqu’ils appellent <codeph>NetStream.play()</codeph>. N’ajoutez pas une « / » après le nom du flux. Par exemple, n’utilisez pas le nom de flux <codeph>"bolero/"</codeph>. 
     
     <p>
     Vous pouvez publier des fichiers aux formats décrits dans le tableau suivant. La syntaxe varie selon le format de fichier.</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Format de fichier</entry><entry>Syntaxe</entry><entry>Exemple</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>Spécifiez le nom du flux en tant que chaîne, sans extension de nom de fichier.</entry>
     <entry><codeph>ns.publish("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 ou ID3</entry>
     <entry>Spécifiez le nom du flux en tant que chaîne, avec le préfixe <codeph>mp3:</codeph> ou <codeph>id3:</codeph> et sans extension de nom de fichier.</entry>
     <entry><codeph>ns.publish("mp3:mymp3stream");</codeph> <codeph>ns.publish("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>Fichiers basés sur le format MPEG-4 (F4V et MP4, entre autres)</entry>
     <entry>Spécifiez le nom du flux en tant que chaîne, avec le préfixe <codeph>mp4:</codeph> avec ou sans extension de nom de fichier. Le préfixe indique au serveur que le fichier contient des données vidéo H.264 et des données audio AAC au format conteneur MPEG-4 Part 14. </entry>
     <entry><codeph>ns.publish("mp4:myvideo.f4v")</codeph> <codeph>ns.publish("mp4:myvideo.mp4");</codeph> <codeph>ns.publish("mp4:myvideo");</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>     
	 
	 </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chaîne spécifiant le mode de publication du flux continu. Les valeurs supportées sont <codeph>record</codeph>, <codeph>append</codeph> et <codeph>live</codeph>. La valeur par défaut est <codeph>live</codeph>.
	 <ul>
	 <li>Si vous transmettez "<codeph>record</codeph>", Flash Media Server publie et enregistre des données en direct, qu’il place dans un nouveau fichier dont le nom correspond à la valeur transmise au paramètre <codeph>name</codeph>. Si le fichier existe déjà, il est remplacé.</li>
	 <li>Si vous transmettez "<codeph>append</codeph>", Flash Media Server publie et enregistre des données en direct, qu’il ajoute à un fichier dont le nom correspond à la valeur transmise au paramètre <codeph>name</codeph>. Si aucun fichier correspondant au paramètre <codeph>name</codeph> n’est détecté, un fichier est créé. </li>
	 <li>Si vous omettez ce paramètre ou utilisez "<codeph>live</codeph>", Flash Media Server publie des données en direct sans les enregistrer. Si un fichier dont le nom correspond à la valeur transmise au paramètre <codeph>name</codeph> existe, il est supprimé.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Envoie des données audio, vidéo et des messages texte en diffusion continue d’un client au Flash Media Server, en enregistrant éventuellement le flux continu pendant la transmission. Cette méthode n’est accessible qu’à l’éditeur du flux continu spécifié.
	 
	 <p>Vous pouvez enregistrer des fichiers au format FLV ou MPEG-4. Si vous enregistrez un fichier au format MPEG-4, vous devez utiliser un outil d’aplatissement pour modifier ou lire le fichier dans une autre application. Pour télécharger l’outil, voir <xref href="http://www.adobe.com/go/fms_tools_fr" scope="external">www.adobe.com/go/fms_tools_fr</xref>.</p>
     
     <p>N’utilisez pas cette méthode pour lire un flux continu ayant déjà été publié et enregistré. Pour lire un flux continu, appelez la méthode <codeph>NetStream.play()</codeph>.</p>
	 
	 <codeblock platform="actionscript">
	 var subscribeNS:NetStream = new NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var subscribeNS = new air.NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
     <p>Lorsque Flash Media Server enregistre un flux continu, il crée un fichier et l’enregistre dans un sous-répertoire du répertoire de l’application situé sur le serveur. Chaque flux est stocké dans un répertoire dont le nom correspond au nom de l’occurrence de l’application transmis à <codeph>NetConnection.connect()</codeph>. Le serveur crée ces répertoires automatiquement. Le code suivant, par exemple, établit la connexion à l’application « lectureseries » et enregistre un flux nommé « lecture ». Le fichier « lecture.flv » est enregistré dans le répertoire applications/lectureseries/streams/_definst_ :
     </p>
     
     <codeblock platform="actionscript">
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <p>L’exemple suivant illustre la connexion à une autre occurrence de la même application. Le fichier « lecture.flv » est enregistré dans le répertoire /applications/lectureseries/streams/monday :</p>
     
     <codeblock>
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
   	 
	 <p>Cette méthode distribue un objet <codeph>NetStatusEvent</codeph>. Si, par exemple, une personne publie déjà un flux continu en utilisant le nom spécifié, l’objet <codeph>NetStatusEvent</codeph> est distribué avec une propriété <codeph>code</codeph> correspondant à <codeph>"NetStream.Publish.BadName"</codeph>. Pour plus d’informations, voir l’objet <codeph>NetStatusEvent</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>NetConnection.connect()</linktext></link><link href="" invalidHref="flash.net.xml#NetStatusEvent/info"><linktext>NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:receiveAudio"><apiName>receiveAudio</apiName><shortdesc>
	 Indique si les données audio entrantes sont lues dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Spécifie si les données audio entrantes sont lues dans le flux (<codeph>true</codeph>) ou non (<codeph>false</codeph>). La valeur par défaut est <codeph>true</codeph>. 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique si les données audio entrantes sont lues dans le flux continu. Cette méthode n’est accessible qu’aux clients abonnés au flux continu spécifié, et non à l’éditeur de ce dernier.
	 
     <p>Cette méthode est conçue à l’origine pour une utilisation avec Flash Media Server. Pour plus d’informations, voir la description de la classe.</p> 
	 
	 <p>Vous pouvez appeler cette méthode avant ou après la méthode <codeph>NetStream.play()</codeph> et le démarrage réel de la transmission. Vous pouvez, par exemple, associer ces méthodes à un bouton sur lequel l’utilisateur clique pour désactiver et activer le son du flux continu audio entrant.</p>
	 
	 <p>Si le flux continu spécifié contient uniquement des données audio, la transmission de la valeur <codeph>false</codeph> à cette méthode interdit toute incrémentation additionnelle de <codeph>NetStream.time</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideo"><apiName>receiveVideo</apiName><shortdesc>
	 Indique si les données vidéo entrantes sont lues dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Indique si les données vidéo entrantes de ce flux sont lues (<codeph>true</codeph>) ou non (<codeph>false</codeph>). La valeur par défaut est <codeph>true</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique si les données vidéo entrantes sont lues dans le flux continu. Cette méthode n’est accessible qu’aux clients abonnés au flux continu spécifié, et non à l’éditeur de ce dernier.
	 
     <p>Cette méthode est conçue à l’origine pour une utilisation avec Flash Media Server. Pour plus d’informations, voir la description de la classe.</p>
	 
	 <p>Vous pouvez appeler cette méthode avant ou après la méthode <codeph>NetStream.play()</codeph> et le démarrage réel de la transmission. Vous pouvez, par exemple, associer ces méthodes à un bouton sur lequel l’utilisateur appuie pour afficher ou masquer le flux vidéo entrant.</p>
	 
	 <p>Si le flux continu spécifié contient uniquement des données vidéo, la transmission de la valeur <codeph>false</codeph> à cette méthode interdit toute incrémentation additionnelle de <codeph>NetStream.time</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideoFPS"><apiName>receiveVideoFPS</apiName><shortdesc>
	 Indique la cadence d’images des données vidéo entrantes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>FPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Indique le nombre d’images par seconde lors de la lecture des données vidéo entrantes.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Indique la cadence d’images des données vidéo entrantes. Cette méthode n’est accessible qu’aux clients abonnés au flux continu spécifié, et non à l’éditeur de ce dernier.
	 
     <p>Cette méthode est conçue à l’origine pour une utilisation avec Flash Media Server. Pour plus d’informations, voir la description de la classe.</p>
	 
	 <p>Vous pouvez appeler cette méthode avant ou après la méthode <codeph>NetStream.play()</codeph> et le démarrage réel de la transmission. Par exemple, vous pouvez associer ces méthodes à un champ de texte afin que l’utilisateur puisse définir la cadence d’images des données vidéo entrantes.</p>
     
     <p>Pour interrompre la réception des données vidéo, transmettez la valeur 0 au paramètre FPS. Pour déterminer la cadence d’images actuelle, utilisez <codeph>NetStream.currentFPS</codeph>.</p>
     
     <p>Si vous transmettez une valeur au paramètre <codeph>FPS</codeph> en vue de limiter la cadence d’images de la vidéo, Flash Media Server tente de réduire la cadence tout en préservant l’intégrité de la vidéo. Le serveur envoie le nombre d’images minimum afin de satisfaire la cadence désirée entre deux images-clés. Notez toutefois que les images intermédiaires doivent être envoyées conjointement ; dans le cas contraire, la vidéo risque d’être corrompue. Par conséquent, le nombre d’images souhaité est envoyé immédiatement et conjointement après une image-clé. Etant donné que les images ne sont pas distribuées uniformément, le mouvement entre images uniques est homogène, mais des interruptions apparaissent entre les séquences d’images. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:resetDRMVouchers"><apiName>resetDRMVouchers</apiName><shortdesc>
     Supprime toutes les données du voucher de gestion de droits numériques (DRM) mises en cache localement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, resetDRMVouchers
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Les données du voucher ne peuvent pas être supprimées.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Supprime toutes les données du voucher de gestion de droits numériques (DRM) mises en cache localement.
     <p>
     L’application doit à nouveau télécharger les vouchers requis depuis le serveur de droits multimédias afin que l’utilisateur puisse accéder au contenu protégé. Appeler cette fonction équivaut à appeler la fonction <codeph>resetDRMVouchers()</codeph> de l’objet DRMManager.</p>
     
     </apiDesc><example conref="examples\NetStream.resetDRMVouchers.1.as"> L’exemple suivant réinitialise tous les vouchers DRM :
<codeblock>

NetStream.resetDRMVouchers();
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.drm.xml#DRMManager/resetDRMVouchers()"><linktext>flash.net.drm.DRMManager.resetDRMVouchers()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:resume"><apiName>resume</apiName><shortdesc>
	 Reprend la lecture d’un flux vidéo en pause.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Reprend la lecture d’un flux vidéo en pause. Si la vidéo est en cours de lecture, l’appel de cette méthode n’a aucun effet.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:seek"><apiName>seek</apiName><shortdesc>
	 
	 Recherche l’image-clé (également appelée Image-I dans l’industrie vidéo) la plus proche de l’emplacement spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.seek, seek
	 
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Valeur de temps approximative, en secondes, à atteindre dans un fichier vidéo. Avec Flash Media Server, si la propriété <codeph>&lt;EnhancedSeek></codeph> est définie sur <codeph>true</codeph> dans le fichier de configuration Application.xml (configuration par défaut), le serveur génère une image-clé au <codeph>décalage</codeph>. 
	 
	 <ul>
	   <li>Pour revenir au début du flux continu, transmettez 0 pour <codeph>offset</codeph>.</li>
	   <li>Pour effectuer une recherche en partant du début du flux continu, transmettez le nombre de secondes à appliquer. Par exemple, pour placer la tête de lecture à 15 secondes du début (ou sur l’image-clé avant 15 secondes), utilisez <codeph>myStream.seek(15)</codeph>.</li>
	   <li>Pour faire une recherche par rapport à la position actuelle, transmettez <codeph>NetStream.time + n</codeph> ou <codeph>NetStream.time - n</codeph> pour rechercher <codeph>n</codeph> secondes vers l’avant ou l’arrière, par rapport à la position actuelle. Par exemple, pour revenir en arrière de 20 secondes par rapport à la position actuelle, utilisez <codeph>NetStream.seek(NetStream.time - 20)</codeph>.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Recherche l’image-clé (également appelée Image-I dans l’industrie vidéo) la plus proche de l’emplacement spécifié. L’image-clé est placée à un décalage, en secondes, depuis le début du flux. 
	 
     <p>
     Les flux vidéo sont généralement encodés avec deux types d’image, les images-clés (ou images I) et les images P. Une image-clé contient l’ensemble de l’image, alors qu’une image P est une image intérimaire qui fournit des informations vidéo supplémentaires entre les images-clé. Un flux vidéo présente généralement une image-clé toutes les 10 à 50 images. 
     </p>
     
     <p>
     Sur Flash Media Server, le comportement de <codeph>seek()</codeph> est contrôlé par la valeur de l’élément <codeph>EnhancedSeek</codeph> du fichier de configuration <codeph>Application.xml</codeph>.
     </p>
     
     <p>
     Si la valeur de <codeph>EnhancedSeek</codeph> est <codeph>false</codeph>, le serveur utilise le mode de recherche normal. En mode de recherche normal, le serveur commence la diffusion en continu à partir de l’image-clé la plus proche. Par exemple, si une vidéo présente des images-clés à 0 et 10 secondes, une recherche de 4 secondes entraîne un démarrage de la lecture à 4 secondes via l’image-clé placée à 0 secondes. La vidéo demeure figée jusqu’à ce qu’elle atteigne la prochaine image-clé placée à 10 secondes. Pour améliorer les recherches, vous devez réduire l’intervalle des images-clés. En mode de recherche normal, vous ne pouvez pas démarrer la vidéo à un point placé entre les images-clés.
     </p>
     
     <p>
     Si <codeph>EnhancedSeek</codeph> est <codeph>true</codeph>, valeur par défaut, le serveur génère une nouvelle image-clé au niveau du <codeph>décalage</codeph> en fonction de l’image-clé précédente et de toute image P intermédiaire. Cela crée toutefois une charge de traitement élevée sur le serveur et une distorsion peut survenir dans l’image-clé générée. Si le codec vidéo est On2, l’image-clé située avant le point de recherche et toute image P située entre l’image-clé et le point de recherche sont envoyées au client.
     </p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:send"><apiName>send</apiName><shortdesc>
	 Envoie un message sur le flux publié à tous les clients abonnés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>handlerName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Message à envoyer ; également le nom du gestionnaire ActionScript qui reçoit le message. Le nom du gestionnaire ne peut avoir qu’un seul niveau (autrement dit, il ne peut pas être au format parent/enfant) et est relatif à l’objet flux. N’utilisez pas un terme réservé comme nom du gestionnaire. Par exemple, l’attribution du nom <codeph>close</codeph> au gestionnaire entraîne l’échec de la méthode. Avec Flash Media Server, utilisez <codeph>@setDataFrame</codeph> pour ajouter une image-clé de métadonnées à un flux en direct ou <codeph>@clearDataFrame</codeph> pour supprimer une image-clé.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Les arguments facultatifs peuvent être de n’importe quel type. Ils sont sérialisés et envoyés via la connexion, et le gestionnaire de destination les reçoit dans le même ordre. Si un paramètre représente un objet circulaire (une liste liée qui est circulaire, par exemple), l’utilitaire de sérialisation gère correctement les références. Avec Flash Media Server, si <codeph>@setDataFrame</codeph> est le premier argument, utilisez <codeph>onMetaData</codeph> comme second argument ; pour le troisième argument, transmettez une occurrence de <codeph>Object</codeph> ou <codeph>Array</codeph> possédant les métadonnées définies comme propriétés. Voir le <xref href="http://www.adobe.com/go/learn_fms_devguide_fr" scope="external">Flash Media Server Developer Guide</xref> pour obtenir une liste des noms de propriété suggérés. Avec <codeph>@clearDataFrame</codeph> comme premier argument, utilisez <codeph>onMetaData</codeph> comme second argument et pas de troisième argument.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Envoie un message sur le flux publié à tous les clients abonnés. Cette méthode n’est disponible que pour l’éditeur du flux spécifié et est conçue pour une utilisation avec Flash Media Server. Pour traiter et répondre à ce message, créer un gestionnaire sur l’objet <codeph>NetStream</codeph>, par exemple <codeph>ns.HandlerName</codeph>.
     
     <p>
     <ph platform="actionscript">Flash Player ou </ph>AIR ne sérialise pas les méthodes ni leurs données, les variables de prototype d’objet ou les variables non énumérables. Pour les objets d’affichage, <ph platform="actionscript">Flash Player </ph>AIR sérialise le chemin, mais pas les données.
	 </p>
	 
	 <p>
	 Vous pouvez appeler la méthode <codeph>send()</codeph> pour ajouter des images-clés de données à un flux en direct envoyé à Flash Media Server. Une image-clé de données est un message ajouté à un flux en direct par un éditeur. Les images-clés de données sont généralement utilisées pour ajouter des métadonnées à un flux en direct avant la capture des données pour le flux à partir de la caméra et du microphone. Un éditeur peut à tout moment ajouter une image-clé de données pendant la publication du flux. L’image-clé de données est enregistrée dans la mémoire du serveur tant que l’éditeur y est connecté. 
	 </p>
	 <p>
	 Les clients abonnés au flux en direct avant l’ajout d’une image-clé de données reçoivent cette image-clé dès son ajout. Les clients qui s’abonnent au flux en direct après l’ajout de l’image-clé reçoivent cette image-clé lorsqu’ils s’abonnent.
	 </p>
	 <p>
	 Pour ajouter une image-clé de métadonnées dans un flux en direct envoyé à Flash Media Server, utilisez <codeph>@setDataFrame</codeph> comme nom de gestionnaire, suivi de deux arguments supplémentaires, tels que :
	 </p>
	 
	 <codeblock platform="actionscript">
	 var ns:NetStream = new NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var ns = new air.NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <p>
	 L’argument <codeph>@setDataFrame</codeph> fait référence à un gestionnaire spécial intégré au Flash Media Server. L’argument <codeph>onMetaData</codeph> est le nom d’une fonction de rappel de votre application client qui écoute l’événement <codeph>onMetaData</codeph> et récupère les métadonnées. Le troisième élément, <codeph>metaData</codeph>, est une occurrence de <codeph>Object</codeph> ou <codeph>Array</codeph> dont les propriétés définissent les valeurs des métadonnées. Les éditeurs doivent définir des noms de propriété que les abonnés puissent comprendre facilement ; voir le <xref href="http://www.adobe.com/go/learn_fms_devguide_en" scope="external">Flash Media Server Developer Guide</xref> pour obtenir une liste des noms de propriété.
	 </p>
	 
	 <p>Utilisez <codeph>@clearDataFrame</codeph> pour effacer une image-clé de métadonnées déjà définie dans le flux :
	 </p>
	 <codeblock>
	 ns.send("@clearDataFrame", "onMetaData");
	 </codeblock>
	 
	 
	 </apiDesc><example conref="examples\NetStream.send.1.as"> L’exemple suivant crée deux objets <codeph>NetStream</codeph>. L’un est utilisé pour publier un flux en direct sur le serveur, l’autre s’abonne au flux.
<codeblock>
package {
   import flash.display.Sprite;
   import flash.net.NetConnection;
   import flash.net.NetStream;
   import flash.events.NetStatusEvent;
   import flash.media.Video;
   import flash.utils.setTimeout;

 
   public class TestExample extends Sprite
   {
     var nc:NetConnection = new NetConnection();
     var ns1:NetStream;
     var ns2:NetStream;
     var vid:Video = new Video(300,300);
     var obj:Object = new Object();
 
     public function TestExample() {
        nc.objectEncoding = 0;
        nc.addEventListener("netStatus", onNCStatus);
        nc.connect("rtmp://localhost/FlashVideoApp");
        addChild(vid); 
     }
  
     function onNCStatus(event:NetStatusEvent):void {
       switch (event.info.code) {
           case "NetConnection.Connect.Success":
               trace("You've connected successfully");
               ns1 = new NetStream(nc);
               ns2 = new NetStream(nc);
               
               ns1.client = new CustomClient();
               ns1.publish("dummy", "live");
    
               ns2.play("dummy");
               ns2.client = new CustomClient();
               vid.attachNetStream(ns2);
               setTimeout(sendHello, 3000);
               break;
              
           case "NetStream.Publish.BadName":
               trace("Please check the name of the publishing stream" );
               break;
        }   
     }

     function sendHello():void {
         ns1.send("myFunction", "hello");
     }       
   }
 }
 
 class CustomClient {
    public function myFunction(event:String):void {
       trace(event);
    }
 }
</codeblock></example><example conref="examples\NetStream.send.2.as"> L’exemple suivant crée des métadonnées et les ajoute à un flux en direct :
<codeblock>
private function netStatusHandler(event:NetStatusEvent):void {
     switch (event.info.code) {  
        case "NetStream.Publish.Start":
            var metaData:Object = new Object();
            metaData.title = "myStream";
            metaData.width = 400;
            metaData.height = 200;
            ns.send("&amp;#64;setDataFrame", "onMetaData", metaData);
            ns.attachCamera( Camera.getCamera() );
            ns.attachAudio( Microphone.getMicrophone() );        
    }
}
</codeblock></example><example conref="examples\NetStream.send.3.as"> Pour répondre à une image-clé de données ajoutée à une vidéo, le client doit définir un gestionnaire d’événement <codeph>onMetaData</codeph>. Le gestionnaire d’événement <codeph>onMetaData</codeph> n’est pas enregistré avec <codeph>addEventListener()</codeph>, mais correspond à une fonction de rappel nommée <codeph>onMetaData</codeph>, par exemple :
<codeblock>
 public function onMetaData(info:Object):void {
    trace("width: " + info.width);
    trace("height: " + info.height);
 }
</codeblock></example><example conref="examples\NetStream.send.4.as"> Cet exemple décrit la création d’une liste de lecture sur le serveur :
<codeblock>
 // Create a NetStream for playing
 var my_ns:NetStream = new NetStream(my_nc);
 my_video.attachNetStream(my_ns);
 
 // Play the stream record1
 my_ns.play("record1", 0, -1, true);
 
 // Switch to the stream live1 and play for 5 seconds.  
 // Since reset is false, live1 will start to play after record1 is done.
 my_ns.play("live1", -1 , 5, false);
</codeblock></example><example conref="examples\NetStream.send.5.as"> Si le fichier vidéo enregistré contient uniquement des messages de données, vous pouvez soit le lire à la vitesse à laquelle il a été enregistré à l’origine, soit obtenir tous les messages de données en une seule opération.
<codeblock>
 //To play at normal speed
 var my_ns:NetStream = new NetStream(my_nc);
 my_ns.play("log", 0, -1);
 
 //To get the data messages all at once
 my_ns.play("log", 0, -1, 3);
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:setDRMAuthenticationCredentials"><apiName>setDRMAuthenticationCredentials</apiName><shortdesc>
     Définit les informations d’authentification de la gestion des droits numériques nécessaires à l’affichage du contenu chiffré sous-jacent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, setDRMAuthenticationCredentials
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>userName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom d’utilisateur valide.
     </apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Mot de passe correspond au nom d’utilisateur fournit.
     </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne indiquant le type d’informations d’authentification fournit. Les valeurs valides sont <codeph>"drm"</codeph> et <codeph>"proxy"</codeph>. La valeur par défaut est <codeph>"drm"</codeph>.
     <ul>
     <li>Dans le cas d’une authentification <codeph>"drm"</codeph>, les informations d’identification fournies sont authentifiées par rapport à Flash Media Rights Management Server (FMRMS).</li>
     <li>Dans le cas d’une authentification <codeph>"proxy"</codeph>, les informations d’identification fournies sont authentifiées par rapport au serveur proxy et doivent correspondre avec celles requises par ce dernier. Par exemple, l’option <codeph>"proxy"</codeph> permet à une société d’authentifier l’application par rapport au serveur proxy avant que l’utilisateur n’accède à Internet. A moins qu’une authentification anonyme soit utilisée, après l’authentification proxy, l’utilisateur doit encore authentifier par rapport à FMRMS afin d’obtenir le bon et lire le contenu. Vous pouvez à nouveau faire appel à la méthode <codeph>setDRMAuthenticationcredentials()</codeph>, avec l’option <codeph>"drm"</codeph>, pour l’authentification par rapport à FMRMS.</li>
     </ul>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Définit les informations d’authentification de la gestion des droits numériques nécessaires à l’affichage du contenu chiffré sous-jacent.
     <p>
     La méthode <codeph>setDRMAuthenticationCredentials()</codeph> doit fournir des informations d’identification qui correspondent à celles reconnues et approuvées par le fournisseur de contenu ou le serveur proxy. Ces informations d’identification sont les mêmes que celles dont l’utilisateur a besoin pour obtenir l’autorisation d’afficher le contenu.
     </p>
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:togglePause"><apiName>togglePause</apiName><shortdesc>
	 Interrompt ou reprend la lecture d’un flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Interrompt ou reprend la lecture d’un flux continu. Lorsque vous appelez cette méthode pour la première fois, la lecture est interrompue ; au prochain appel, la lecture reprend. Vous pouvez par exemple utiliser cette méthode pour permettre aux utilisateurs d’interrompre ou de reprendre la lecture par pression d’un seul bouton.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetStream:CONNECT_TO_FMS"><apiName>CONNECT_TO_FMS</apiName><shortdesc>
     Objet statique utilisé comme paramètre pour le constructeur d’une occurrence de NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>connectToFMS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Objet statique utilisé comme paramètre pour le constructeur d’une occurrence de NetStream. Il s’agit de la valeur par défaut du second paramètre du constructeur NetStream ; il n’est pas utilisé par l’application pour la lecture progressive. Lorsqu’il est utilisé, ce paramètre oblige le constructeur à se connecter à une occurrence de Flash Media Server.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:DIRECT_CONNECTIONS"><apiName>DIRECT_CONNECTIONS</apiName><shortdesc>
     Crée une connexion d’éditeur homologue à homologue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>directConnections</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Crée une connexion d’éditeur homologue à homologue. Transmet cette chaîne pour le deuxième paramètre (facultatif) au constructeur d’une occurrence de NetStream. Avec cette chaîne, une application peut créer une connexion NetStream dans le but de publier du contenu audio et vidéo vers des clients.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:bufferLength:get"><apiName>bufferLength</apiName><shortdesc>
	 Nombre de secondes de données enregistrées dans la mémoire tampon.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bufferLength, bufferLength
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre de secondes de données enregistrées dans la mémoire tampon. Vous pouvez utiliser cette propriété conjointement avec <codeph>bufferTime</codeph> pour estimer le niveau de remplissage du tampon ; par exemple, pour indiquer ce niveau à un utilisateur qui attend la fin du chargement des données dans le tampon.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bufferTime:set"><apiName>bufferTime</apiName><shortdesc>
	 Spécifie la durée de la mise en mémoire tampon des messages avant que l’affichage du flux ne commence.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.setBufferTime, setBufferTime
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la durée de la mise en mémoire tampon des messages avant que l’affichage du flux ne commence. Par exemple, pour vous assurer que la lecture du flux continu ne soit pas interrompue pendant les 15 premières secondes, définissez <codeph>bufferTime</codeph> sur 15. L’application ne commence la lecture du flux continu que 15 secondes après la mise en mémoire tampon des données.
	 
	 <p>La valeur par défaut est 0.1 (un dixième de seconde). Pour déterminer le nombre de secondes actuellement dans la mémoire tampon, utilisez la propriété <codeph>bufferLength</codeph>.</p>
	 
     <p><b>Remarque :</b> pour éviter toute distorsion lors de la diffusion de contenu préenregistré (pas en direct), ne définissez pas la valeur de <codeph>Netstream.bufferTime</codeph> sur 0. Par défaut, l’application utilise un tampon d’entrée pour le contenu préenregistré qui met les données en file d’attente et lit le fichier correctement. Pour le contenu préenregistré, utilisez le paramétrage par défaut ou augmentez la durée du tampon.</p>
     
     <p>Depuis Flash Player 9.0.115.0, le lecteur n’efface plus la mémoire tampon lors de l’appel de <codeph>NetStream.pause()</codeph>. Avant Flash Player 9.0.115.0, le lecteur attendait le remplissage du tampon avant de reprendre la lecture, ce qui entraînait souvent des retards.</p>
     	 
     	 <p>En cas d’interruption unique, la propriété <codeph>NetStream.bufferLength</codeph> possède une limite de 60 secondes ou de deux fois la valeur de <codeph>NetStream.bufferTime</codeph> (la limite supérieure est prise en compte). Par exemple, si la propriété <codeph>bufferTime</codeph> est de 20 secondes, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la propriété <codeph>NetStream.bufferLength</codeph> corresponde à la valeur la plus élevée de 20~~2 (c’est-à-dire 40), ou à la valeur 60 ; dans ce cas, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la valeur de <codeph>bufferLength</codeph> corresponde à 60. Si la propriété <codeph>bufferTime</codeph> est de 40 secondes, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la propriété <codeph>bufferLength</codeph> corresponde à la valeur la plus élevée de 40~~2 (c’est-à-dire 80), ou à la valeur 60 ; dans ce cas, Flash Player effectue la mise en mémoire tampon jusqu’à ce que la valeur de <codeph>bufferLength</codeph> corresponde à 80.</p>
     	 
     	 <p>La propriété <codeph>bufferLength</codeph> possède en outre une limite absolue. Si un appel à <codeph>pause()</codeph> provoque l’augmentation de <codeph>bufferLength</codeph> de plus de 600 secondes, ou la valeur de plus élevée de <codeph>bufferTime</codeph> ~~ 2, Flash Player efface le contenu de la mémoire tampon et remet à zéro <codeph>bufferLength</codeph>. Par exemple, si la propriété <codeph>bufferTime</codeph> est de 120 secondes, Flash Player efface le contenu de la mémoire tampon si la propriété <codeph>bufferLength</codeph> atteint 600 secondes ; si <codeph>bufferTime</codeph> est de 360 secondes, Flash Player efface le contenu de la mémoire tampon si <codeph>bufferLength</codeph> atteint 720 secondes.</p>
     	 
     	 <p><b>Conseil </b>: vous pouvez utiliser <codeph>NetStream.pause()</codeph> dans le code pour mettre les données en mémoire tampon pendant que les spectateurs regardent une annonce publicitaire, par exemple, puis annuler l’interruption lorsque la vidéo principale démarre.</p>
     	 
     	 <p>Pour plus d’informations sur le nouveau comportement d’interruption, voir la page <xref href="http://www.adobe.com/go/learn_fms_smartpause_fr" scope="external">http://www.adobe.com/go/learn_fms_smartpause_fr</xref>.</p>
     <p>
     <b>Flash Media Server</b>. Le comportement du tampon varie en fonction de la définition de la durée du tampon : sur un flux de publication ou sur un flux d’abonnement. Dans le cas d’un flux de publication, <codeph>bufferTime</codeph> spécifie la durée pendant laquelle le tampon sortant peut croître avant que l’application ne commence à abandonner des images. Dans le cas d’une connexion haut débit, la durée du tampon n’est pas un problème : les données sont envoyées presque aussi rapidement que ce que l’application peut les mettre en mémoire tampon. Dans le cas d’une connexion bas débit, toutefois, il peut exister une différence considérable entre la vitesse à laquelle l’application place les données en mémoire tampon et celle à laquelle il peut les envoyer au client. 
     </p>
     
     <p>
     Dans le cas d’un flux d’abonnement, <codeph>bufferTime</codeph> spécifie le délai pendant lequel les données entrantes doivent être mises en mémoire tampon avant que l’affichage du flux ne commence. Par exemple, si vous voulez vous assurer que la lecture du flux soit ininterrompue au cours des 15 premières secondes, définissez <codeph>bufferTime</codeph> sur 15 ; Flash commencera la lecture du flux uniquement 15 secondes après la mise en mémoire tampon des données.
     </p>
     
     <p>
     Lors de la lecture d’un flux enregistré, si <codeph>bufferTime</codeph> est défini sur zéro, Flash le définit sur une faible valeur (environ 10 millisecondes). Si des flux en direct sont ensuite lus (par exemple depuis une liste de lecture), cette durée de tampon persiste. Cela signifie que <codeph>bufferTime</codeph> demeure non nul pour le flux. 
     </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#bufferTime/bufferLength"><linktext>bufferLength</linktext></link><link href="" invalidHref="flash.net.xml#bufferTime/time"><linktext>time</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 Nombre d’octets de données ayant été chargés dans l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesLoaded, bytesLoaded
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’octets de données ayant été chargés dans l’application. Vous pouvez utiliser cette propriété conjointement avec <codeph>bytesTotal</codeph> pour estimer le niveau de remplissage du tampon ; par exemple, pour indiquer ce niveau à un utilisateur qui attend la fin du chargement des données dans le tampon.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesTotal"><linktext>bytesTotal</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 Taille totale, en octets, du fichier chargé dans l’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesTotal, bytesTotal
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Taille totale, en octets, du fichier chargé dans l’application.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:checkPolicyFile:get"><apiName>checkPolicyFile</apiName><shortdesc>
	 Spécifie si l’application doit tenter de télécharger un fichier de régulation interdomaines à partir du serveur du fichier vidéo chargé avant de commencer à charger ce dernier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si l’application doit tenter de télécharger un fichier de régulation interdomaines à partir du serveur du fichier vidéo chargé avant de commencer à charger ce dernier. Cette propriété est applicable lorsque vous utilisez un objet NetStream pour télécharger progressivement des données vidéo (fichiers autonomes) ou lorsque vous chargez des fichiers se trouvant en dehors du domaine du fichier appelant. Cette propriété n’est pas prise en compte lorsque vous utilisez un objet NetStream pour obtenir une ressource RTMP.
	 
     <p>Définissez cette propriété sur <codeph>true</codeph> lorsque vous chargez un fichier vidéo qui se trouve hors du domaine du fichier SWF appelant et qu’il vous est nécessaire d’utiliser la méthode <codeph>BitmapData.draw()</codeph> pour accéder à la vidéo au niveau des pixels. Si vous appelez <codeph>BitmapData.draw()</codeph> sans définir la propriété <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> au chargement, vous risquez d’obtenir une exception <codeph>SecurityError</codeph> car le fichier de régulation requis n’a pas été téléchargé.</p>
	 
	 <p>Si vous n’avez pas besoin d’accéder à la vidéo que vous chargez au niveau des pixels, il est préférable de ne pas régler <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>. La recherche d’un fichier de régulation consomme de la bande passante et risque de retarder le début du téléchargement.</p>
	 
	 <p>Lorsque vous appelez la méthode <codeph>NetStream.play()</codeph> en définissant <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>, <ph platform="actionscript">Flash Player ou </ph>le moteur d’exécution AIR doit télécharger un fichier de régulation interdomaines approprié ou déterminer qu’un tel fichier n’existe pas, avant de commencer à télécharger l’objet spécifié dans votre appel de <codeph>NetStream.play()</codeph>. Pour vérifier l’existence d’un fichier de régulation, <ph platform="actionscript">Flash Player ou </ph>le moteur d’exécution AIR effectue les actions suivantes, dans l’ordre indiqué :</p>
	 
	 <ol>
	 
     <li>L’application examine les fichiers de régulation préalablement téléchargés.</li>
	 
	 <li>L’application tente de télécharger tout fichier de régulation en attente spécifié dans les appels de la méthode <codeph>Security.loadPolicyFile()</codeph>.</li>
	 
	 <li>L’application tente de télécharger un fichier de régulation à partir de l’emplacement par défaut qui correspond à l’URL que vous avez transmise à <codeph>NetStream.play()</codeph>, à savoir <codeph>/crossdomain.xml</codeph> sur le même serveur que cette URL.</li>
	 
	 </ol>
	 
	 <p>Dans tous les cas, <ph platform="actionscript">Flash Player ou </ph>le moteur d’exécution AIR exige que le serveur du fichier vidéo héberge un fichier de régulation approprié, que ce dernier permette d’accéder à l’objet à l’adresse URL que vous avez transmise à <codeph>play()</codeph> sur la base de l’emplacement du fichier de régulation, et qu’il autorise le domaine du fichier de code appelant à accéder au fichier vidéo par le biais d’une ou plusieurs balises <codeph>&lt;allow-access-from></codeph>.</p>
	 
	 <p>Si vous définissez <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>, l’application attend la vérification du fichier de régulation avant de télécharger la vidéo. Avant de manipuler les données vidéo au niveau des pixels, en appelant <codeph>BitmapData.draw()</codeph>, par exemple, attendez d’avoir reçu de votre objet NetStream des événements <codeph>onMetaData</codeph> ou <codeph>NetStatus</codeph>.</p>
	 
	 <p>Si vous définissez <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> et qu’il n’existe aucun fichier de régulation approprié, vous ne recevez pas de message d’erreur tant que vous n’effectuez pas une opération nécessitant un tel fichier, auquel cas l’application renvoie une exception SecurityError.</p>
	 
	 <p>Servez-vous de <codeph>checkPolicyFile</codeph> avec précaution si vous téléchargez un fichier vidéo à partir d’une URL qui utilise des redirections HTTP côté serveur. L’application tente d’extraire les fichiers de régulation correspondant à l’URL spécifiée à l’origine dans <codeph>NetStream.play()</codeph>. Si le fichier final provient d’une URL différente suite à des redirections HTTP, les fichiers de régulation initialement téléchargés peuvent ne pas être applicables à l’URL finale du fichier , autrement dit l’URL qui doit faire l’objet des mesures de sécurité.</p>
	 
	 <p>Pour plus d’informations sur les fichiers de régulation, voir le chapitre « Sécurité de Flash Player » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link><link href="flash.net.xml#NetStream/event:netStatus"><linktext>netStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:client:get"><apiName>client</apiName><shortdesc>
     Spécifie l’objet sur lequel les méthodes de rappel sont invoquées pour traiter la diffusion ou les données des fichiers FLV.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>La propriété <codeph>client</codeph> doit être définie sur un objet non null.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Spécifie l’objet sur lequel les méthodes de rappel sont invoquées pour traiter la diffusion ou les données des fichiers FLV. L’objet par défaut correspond à <codeph>this</codeph>, l’objet NetStream en cours de création. Si vous réglez la propriété <codeph>client</codeph> sur un autre objet, les méthodes de rappel sont appelées sur celui-ci. L’objet <codeph>NetStream.client </codeph> peut appeler les fonctions suivantes et recevoir un objet de données associé : <codeph>onCuePoint()</codeph>, <codeph>onImageData()</codeph>, <codeph>onMetaData()</codeph>, <codeph>onPlayStatus()</codeph>, <codeph>onTextData()</codeph> et <codeph>onXMPData()</codeph>.
     <p><b>Pour associer la propriété <codeph>client</codeph> à un gestionnaire d’événement :</b></p>
     <p><ol><li>Créez un objet et affectez-le à la propriété <codeph>client</codeph> de l’objet NetStream :
     <codeblock>
     var customClient:Object = new Object();
     my_netstream.client = customClient;
     </codeblock>
     </li>
     <li>Affectez une fonction de gestionnaire pour l’événement de données désiré en tant que propriété de l’objet client :
     <codeblock>
     customClient.onImageData = onImageDataHandler;           
     </codeblock>
     </li>
     <li>Ecrivez la fonction de gestionnaire pour recevoir l’objet d’événement de données, tel que :
     <codeblock>
      public function onImageDataHandler(imageData:Object):void {
              trace("imageData length: " + imageData.data.length);
      }
     </codeblock></li>
     </ol></p>
     <p>Lorsque les données sont transmises via le flux ou au cours de la lecture, l’objet événement de données (dans ce cas l’objet <codeph>imageData</codeph>) est renseigné avec les données. Reportez-vous à la description de <codeph>onImageData</codeph>, qui inclut un exemple complet d’objet affecté à la propriété <codeph>client</codeph>.</p>
     <p><b>Pour associer la propriété <codeph>client</codeph> à une sous-classe :</b></p>
     <p><ol><li>Créez une sous-classe avec une fonction de gestionnaire pour recevoir l’objet événement de données :
     <codeblock>
     class CustomClient {
        public function onMetaData(info:Object):void {
            trace("metadata: duration=" + info.duration + " framerate=" + info.framerate);
     }
     </codeblock>
     </li>
     <li>Affectez une occurrence de la sous-classe à la propriété <codeph>client</codeph> de l’objet NetStream :
     <codeblock>
     my_netstream.client = new CustomClient();
     </codeblock>
     </li>
     </ol></p>     
     <p>Lorsque les données sont transmises via le flux ou au cours de la lecture, l’objet événement de données (dans ce cas l’objet <codeph>info</codeph>) est renseigné avec les données. Reportez-vous à l’exemple de classe proposé à la fin de la classe NetStream, qui illustre l’affectation d’une occurrence de sous-classe à la propriété <codeph>client</codeph>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>
	 Nombre d’images affichées par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.currentFPS, currentFPS
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’images affichées par seconde. Si vous exportez des fichiers vidéo pour les lire sur différents systèmes, vous pouvez vérifier cette valeur pendant le test afin de déterminer la compression à appliquer lors de l’exportation du fichier.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farID:get"><apiName>farID</apiName><shortdesc>
     Identifiant de l’extrémité connectée à cette occurrence de NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Identifiant de l’extrémité connectée à cette occurrence de <codeph>NetStream</codeph>. Cette propriété n’est définie que pour les connexions RTMFP.
     
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     Valeur choisie réellement par l’autre extrémité de ce flux, unique pour cette connexion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur choisie réellement par l’autre extrémité de ce flux, unique pour cette connexion. Cette valeur apparaît à l’autre extrémité du flux en tant que valeur <codeph>nearNonce</codeph>. Cette propriété n’est définie que pour les connexions RTMFP.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:info:get"><apiName>info</apiName><shortdesc>
     Renvoie un objet NetStreamInfo dont les propriétés contiennent des statistiques sur la qualité de service.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.net:NetStreamInfo</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie un objet NetStreamInfo dont les propriétés contiennent des statistiques sur la qualité de service. L’objet est un instantané de l’état en cours. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo"><linktext>NetStreamInfo</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:liveDelay:get"><apiName>liveDelay</apiName><shortdesc>
	 Nombre de secondes de données enregistrées dans le tampon du flux abonné en mode en direct (sans mise en mémoire tampon).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Property
	 
	 </category></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre de secondes de données enregistrées dans le tampon du flux abonné en mode en direct (sans mise en mémoire tampon). Cette propriété spécifie l’actuel délai de transmission réseau (retard).
	 
	 <p>Cette propriété est surtout conçue pour une utilisation avec un serveur, tel que Flash Media Server. Pour plus d’informations, voir la description de la classe.</p>
	 
	 <p>Vous pouvez extraire la valeur de cette propriété pour évaluer approximativement la qualité de transmission du flux continu, et la communiquer à l’utilisateur. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:maxPauseBufferTime:set"><apiName>maxPauseBufferTime</apiName><shortdesc>
     Spécifie la durée de la mise en tampon des messages pendant le mode pause, en secondes.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie la durée de la mise en tampon des messages pendant le mode pause, en secondes. Cette propriété peut être utilisée pour limiter le volume de mise en mémoire tampon pendant le mode pause. Dès que la valeur <codeph>NetStream.bufferLength</codeph> atteint cette limite, la mise en mémoire tampon s’arrête. Si cette valeur n’est pas définie, la limite par défaut est de 60 secondes ou correspond à deux fois la valeur de <codeph>NetStream.bufferTime</codeph> sur chaque pause (la valeur la plus élevée est prise en compte).
     </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#maxPauseBufferTime/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     Valeur choisie réellement par cette extrémité du flux, unique pour cette connexion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur choisie réellement par cette extrémité du flux, unique pour cette connexion. Cette valeur apparaît à l’autre extrémité du flux en tant que valeur <codeph>farNonce</codeph>. Cette propriété n’est définie que pour les connexions RTMFP.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 Encodage d’objet (version AMF) de cet objet NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Encodage d’objet (version AMF) de cet objet NetStream. L’objet NetStream hérite de sa valeur <codeph>objectEncoding</codeph> de l’objet NetConnection associé. Il est important de comprendre cette propriété si votre fichier SWF ActionScript 3.0 doit communiquer avec des serveurs antérieurs à Flash Player 9. Pour plus d’informations, voir la description de la propriété <codeph>objectEncoding</codeph> dans la classe NetConnection.
	 
	 <p>La valeur de cette propriété varie selon la nature du flux continu, local ou distant. Les flux locaux, dans lesquels <codeph>null</codeph> a été transmis à la méthode <codeph>NetConnection.connect()</codeph>, renvoient la valeur de <codeph>NetConnection.defaultObjectEncoding</codeph>. Les flux distants, pour lesquels vous êtes connecté(e) à un serveur, renvoient l’encodage d’objet de la connexion au serveur.</p>
	 
	 <p>Si vous tentez de lire cette propriété sans être connecté ou si vous tentez de la modifier, l’application renvoie une exception.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:peerStreams:get"><apiName>peerStreams</apiName><shortdesc>
	 
     Objet qui détient toutes les occurrences NetStream d’abonnement qui écoutent cette occurrence de NetStream de publication.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 
     Objet qui détient toutes les occurrences NetStream d’abonnement qui écoutent cette occurrence de NetStream de publication.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Contrôle le son dans l’objet NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Contrôle le son dans l’objet NetStream. Pour plus d’informations, voir la description de la classe SoundTransform.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:time:get"><apiName>time</apiName><shortdesc>
	 Position de la tête de lecture, en secondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.time, time
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Position de la tête de lecture, en secondes.
	 <p>
	 <b>Flash Media Server</b> Dans le cas d’un flux d’abonnement, nombre de secondes pendant lequel le flux a été lu. Dans le cas d’un flux de publication, nombre de secondes pendant lequel le flux a été publié. Ce nombre est précis au millième près ; multipliez-le par 1000 pour obtenir le nombre de millisecondes pendant lequel le flux a été lu.
	 </p>
	 <p>
	 Dans le cas d’un flux d’abonnement, si le serveur cesse d’envoyer des données et que le flux demeure ouvert, la valeur de la propriété <codeph>time</codeph> cesse d’avancer. Lorsque le serveur recommence à envoyer des données, la valeur continue d’avancer là où elle s’est arrêtée (c’est-à-dire lorsque le serveur a cessé l’envoi des données). 
	 </p>
	 <p>
     La valeur de la propriété <codeph>time</codeph> continue d’avancer lorsque le flux bascule d’un élément de la liste de lecture à un autre. Cette propriété est définie sur 0 lorsque <codeph>NetStream.play()</codeph> est appelé avec <codeph>reset</codeph> défini sur <codeph>1</codeph> ou sur <codeph>true</codeph>, ou lorsque <codeph>NetStream.close()</codeph> est appelé. 
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
 La classe LocalConnection vous permet de créer un objet LocalConnection capable d’invoquer une méthode dans un autre objet LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe LocalConnection vous permet de créer un objet LocalConnection capable d’invoquer une méthode dans un autre objet LocalConnection. La communication peut avoir lieu :
 
 <ul>
 		<li>au sein d’un fichier SWF unique ;</li>
 		<li>entre plusieurs fichiers SWF ;</li>
 		<li>entre le contenu (de type SWF ou HTML) des applications AIR ;</li>
		<li>entre le contenu (de type SWF ou HTML) d’une application AIR et le contenu SWF s’exécutant dans un navigateur.</li>
 </ul>
 
 <p>Les connexions locales autorisent ce type de communication entre les fichiers SWF sans passer par <codeph>fscommand()</codeph> ni JavaScript. Les objets LocalConnection ne peuvent communiquer qu’avec les fichiers s’exécutant sur un même ordinateur client, mais peuvent s’exécuter dans diverses applications ; un fichier s’exécutant dans un navigateur et un autre dans Adobe AIR, par exemple. </p>
 
 <p platform="actionscript">Les objets LocalConnection créés dans ActionScript 3.0 peuvent communiquer avec les objets LocalConnection créés dans ActionScript 1.0 ou 2.0. L’inverse est également vrai : les objets LocalConnection créés dans ActionScript 1.0 ou 2.0 peuvent communiquer avec les objets LocalConnection créés dans ActionScript 3.0. Flash Player gère automatiquement les communications entre les objets LocalConnection de versions différentes.</p>
 
 <p>Pour comprendre comment utiliser les objets LocalConnection afin de permettre les communications entre deux fichiers, il est utile d’identifier les commandes utilisées dans chaque fichier. Un fichier est appelé fichier <i>d’envoi</i>. Il contient la méthode à appeler. Le fichier d’envoi doit contenir un objet LocalConnection et un appel de la méthode <codeph>send()</codeph>. L’autre fichier est dit <i>de réception</i>. Il s’agit de celui qui appelle la méthode. Le fichier de réception doit contenir un autre objet LocalConnection et un appel de la méthode <codeph>connect()</codeph>.</p>
 
 <p>L’utilisation des méthodes <codeph>send()</codeph> et <codeph>connect()</codeph> varie selon que les fichiers se trouvent dans un même domaine, dans des domaines différents avec des noms prévisibles, ou dans des domaines différents avec des noms imprévisibles ou dynamiques. Les paragraphes ci-après décrivent ces trois situations et présentent des exemples de code pour chacune d’elles.</p>
 
 <p><b>Même domaine</b>. La manière la plus simple d’utiliser un objet LocalConnection est d’autoriser la communication uniquement entre les objets LocalConnection appartenant au même domaine, car les communications intra-domaine sont autorisées par défaut. Lorsque deux fichiers d’un même domaine communiquent, vous n’avez pas besoin d’implémenter des mesures de sécurité particulières. Vous transmettez simplement la même valeur pour le paramètre <codeph>connectionName</codeph> aux deux méthodes <codeph>connect()</codeph> et <codeph>send()</codeph> :</p>
 
 <p><adobeimage alt="Chargement depuis le même domaine" href="../../images/localconnection_samedomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.connect('myConnection');

// sendingLC is in http://www.domain.com/sending.swf
// myMethod() is defined in sending.swf
sendingLC.send('myConnection', 'myMethod');
</codeblock>
 <p><b>Domaines différents avec des noms prévisibles</b>. Lorsque deux fichiers SWF de domaines différents communiquent, vous devez autoriser les échanges entre ces derniers en appelant la méthode <codeph>allowDomain()</codeph>. Vous devez aussi qualifier le nom de la connexion dans la méthode <codeph>send()</codeph> à l’aide du nom du domaine de l’objet LocalConnection de réception :</p>
 
 <p><adobeimage alt="Chargement depuis des domaines distincts" href="../../images/localconnection_differentdomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('www.anotherdomain.com');
receivingLC.connect('myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('www.domain.com:myConnection', 'myMethod');
</codeblock>
 
 <p><b>Domaines différents avec des noms imprévisibles</b>. Il se peut que vous souhaitiez accroître la portabilité interdomaines du fichier contenant l’objet LocalConnection de réception. Pour éviter de spécifier le nom de domaine dans la méthode <codeph>send()</codeph> tout en indiquant que les objets LocalConnection d’envoi et de réception ne se trouvent pas dans le même domaine, faites précéder le nom de connexion d’un caractère de soulignement (_) dans les appels de <codeph>connect()</codeph> et <codeph>send()</codeph>. Pour autoriser les échanges entre les deux domaines, appelez la méthode <codeph>allowDomain()</codeph> et transmettez les domaines à partir desquels vous voulez autoriser les appels LocalConnection. Vous pouvez aussi transmettre l’argument générique (~~) pour autoriser les appels en provenance de tous les domaines :</p>
 
 <p><adobeimage alt="Chargement à partir de noms de domaine inconnus" href="../../images/localconnection_unknowndomains.gif"/></p>
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('~~');
receivingLC.connect('_myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('_myConnection', 'myMethod');
</codeblock>
 
 <p>Vous pouvez utiliser les objets LocalConnection pour envoyer et recevoir des données au sein d’un même fichier, mais ce n’est pas l’implémentation la plus répandue.</p>
 
 <p>Pour plus d’informations sur les méthodes <codeph>send()</codeph> et <codeph>connect()</codeph>, voir description du paramètre <codeph>connectionName</codeph> dans les entrées de <codeph>LocalConnection.send()</codeph> et <codeph>LocalConnection.connect()</codeph>. Voir également les entrées de <codeph>allowDomain()</codeph> et <codeph>domain</codeph>.</p>
 
 </apiDesc><example conref="examples\LocalConnectionSenderExample.as"> Cet exemple comprend deux classes ActionScript qui doivent être compilées dans deux fichiers SWF distincts :
 
 <p>Une occurrence de LocalConnection est créée dans le fichier SWF LocalConnectionSenderExample. Lorsque l’utilisateur appuie sur le bouton, la méthode <codeph>call()</codeph> est utilisée pour appeler la méthode <codeph>lcHandler</codeph> dans le fichier SWF contenant le nom de connexion « myConnection » et le contenu de TextField est transmis en tant que paramètre.</p>
 
 <p>Une occurrence de LocalConnection est créée dans le fichier SWF LocalConnectionReceiverExample et la méthode<codeph>connect()</codeph> est appelée pour désigner ce fichier SWF comme destinataire des messages adressés à la connexion « myConnection ». En outre, cette classe comprend une méthode publique intitulée <codeph>lcHandler()</codeph>. Il s’agit de la méthode appelée par le fichier SWF LocalConnectionSenderExample. Lorsqu’elle est appelée, le texte reçu en tant que paramètre est ajouté à TextField sur la scène.</p>
 
 <p><b>Remarque :</b> pour tester l’exemple, chargez les deux fichiers SWF simultanément sur le même ordinateur.</p>
<codeblock>

// Code in LocalConnectionSenderExample.as
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.net.LocalConnection;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.StatusEvent;
    import flash.text.TextFieldAutoSize;

    public class LocalConnectionSenderExample extends Sprite {
        private var conn:LocalConnection;
        
        // UI elements
        private var messageLabel:TextField;
        private var message:TextField;
        private var sendBtn:Sprite;
        
        public function LocalConnectionSenderExample() {
            buildUI();
            sendBtn.addEventListener(MouseEvent.CLICK, sendMessage);
            conn = new LocalConnection();
            conn.addEventListener(StatusEvent.STATUS, onStatus);
        }
        
        private function sendMessage(event:MouseEvent):void {
            conn.send("myConnection", "lcHandler", message.text);
        }
        
        private function onStatus(event:StatusEvent):void {
            switch (event.level) {
                case "status":
                    trace("LocalConnection.send() succeeded");
                    break;
                case "error":
                    trace("LocalConnection.send() failed");
                    break;
            }
        }
        
        private function buildUI():void {
            const hPadding:uint = 5;
            // messageLabel
            messageLabel = new TextField();
            messageLabel.x = 10;
            messageLabel.y = 10;
            messageLabel.text = "Text to send:";
            messageLabel.autoSize = TextFieldAutoSize.LEFT;
            addChild(messageLabel);
            
            // message
            message = new TextField();
            message.x = messageLabel.x + messageLabel.width + hPadding;
            message.y = 10;
            message.width = 120;
            message.height = 20;
            message.background = true;
            message.border = true;
            message.type = TextFieldType.INPUT;
            addChild(message);
            
            // sendBtn
            sendBtn = new Sprite();
            sendBtn.x = message.x + message.width + hPadding;
            sendBtn.y = 10;
            var sendLbl:TextField = new TextField();
            sendLbl.x = 1 + hPadding;
            sendLbl.y = 1;
            sendLbl.selectable = false;
            sendLbl.autoSize = TextFieldAutoSize.LEFT;
            sendLbl.text = "Send";
            sendBtn.addChild(sendLbl);
            sendBtn.graphics.lineStyle(1);
            sendBtn.graphics.beginFill(0xcccccc);
            sendBtn.graphics.drawRoundRect(0, 0, (sendLbl.width + 2 + hPadding + hPadding), (sendLbl.height + 2), 5, 5);
            sendBtn.graphics.endFill();
            addChild(sendBtn);
        }
    }
}
</codeblock></example><example conref="examples\LocalConnectionReceiverExample.as"><codeblock>
// Code in LocalConnectionReceiverExample.as
package {
    import flash.display.Sprite;
    import flash.net.LocalConnection;
    import flash.text.TextField;

    public class LocalConnectionReceiverExample extends Sprite {
        private var conn:LocalConnection;
        private var output:TextField;
        
        public function LocalConnectionReceiverExample()     {
            buildUI();
            
            conn = new LocalConnection();
            conn.client = this;
            try {
                conn.connect("myConnection");
            } catch (error:ArgumentError) {
                trace("Can't connect...the connection name is already being used by another SWF");
            }
        }
        
        public function lcHandler(msg:String):void {
            output.appendText(msg + "\n");
        }
        
        private function buildUI():void {
            output = new TextField();
            output.background = true;
            output.border = true;
            output.wordWrap = true;
            addChild(output);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Distribué lorsqu’un objet LocalConnection publie son état.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet LocalConnection publie son état. Si <codeph>LocalConnection.send()</codeph> aboutit, la valeur de la propriété <codeph>level</codeph> de l’objet événement <codeph>status</codeph> correspond à <codeph>"status"</codeph>. Dans le cas contraire, la propriété <codeph>level</codeph> correspond à <codeph>"error"</codeph>. Si le fichier de réception refuse la connexion, l’appel peut échouer sans que le fichier d’envoi n’en soit averti. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>LocalConnection.send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué si un appel de LocalConnection.send() tente d’envoyer des données à un autre sandbox de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de <codeph>LocalConnection.send()</codeph> tente d’envoyer des données à un autre sandbox de sécurité.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:LocalConnection:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
	 Crée un objet LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how receiving and sending files create LocalConnnection objects. 
	 The two files can use the same name or different names for their respective LocalConnection objects. 
	 In this example they use different names.
	 
	 <listing>
	 // Code in the receiving file
	 this.createTextField("result_txt", 1, 10, 10, 100, 22);
	 result_txt.border = true;
	 var receiving_lc:LocalConnection = new LocalConnection();
	 receiving_lc.methodToExecute = function(param1:Number, param2:Number) {
	   result_txt.text = param1+param2;
	 };
	 receiving_lc.connect("lc_name");
	 </listing>
	 
	 <p>The following file sends the request to the first file.</p>
	 
	 <listing>
	 // Code in the sending file
	 var sending_lc:LocalConnection = new LocalConnection();
	 sending_lc.send("lc_name", "methodToExecute", 5, 7);
	 </listing>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Crée un objet LocalConnection. Les objets LocalConnection vous permettent d’activer les communications entre différents fichiers s’exécutant sur un même ordinateur client.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:LocalConnection:allowDomain"><apiName>allowDomain</apiName><shortdesc>
	 Spécifie un ou plusieurs domaines qui peuvent envoyer des appels LocalConnection à cette occurrence de LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Change the first example in the listing.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres spécifiés doivent être des chaînes réglées sur une valeur autre que null.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs chaînes qui nomment les domaines à partir desquels les appels LocalConnection seront autorisés. Ce paramètre est associé à deux cas spéciaux :
	 
	 <ul>
	   <li>Vous pouvez spécifier le caractère générique « ~~ » pour autoriser les appels en provenance de tous les domaines.</li>
	 
	   <li>Vous pouvez spécifier la chaîne <codeph>localhost</codeph> pour autoriser les appels de ce fichier à partir de fichiers installés localement. <ph platform="actionscript">Dans Flash Player 8, des restrictions de sécurité relatives aux fichiers locaux ont été introduites. Par défaut, un fichier SWF s’exécutant dans Flash Player autorisé à accéder à Internet n’a pas accès au système de fichiers local. Dans Flash Player, si vous spécifiez <codeph>localhost</codeph>, tout fichier SWF local peut accéder à ce fichier SWF.</ph> </li>
	 
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie un ou plusieurs domaines qui peuvent envoyer des appels LocalConnection à cette occurrence de LocalConnection.
	 
	 <p>Vous ne pouvez pas utiliser cette méthode pour permettre aux fichiers hébergés à l’aide d’un protocole sécurisé (HTTPS) d’autoriser un accès à partir de fichiers hébergés avec des protocoles non sécurisés ; vous devez pour cela utiliser la méthode <codeph>allowInsecureDomain()</codeph>.</p> 
	 
	 <p>Vous pouvez utiliser cette méthode pour faire en sorte qu’un fichier enfant issu d’un domaine différent puisse effectuer des appels LocalConnection vers le fichier parent, sans connaître le domaine final dont émanera le fichier enfant. Cela peut se produire, par exemple, lorsque vous utilisez des redirections d’équilibrage de charge ou des serveurs tiers. Dans ce cas, vous pouvez utiliser la propriété <codeph>url</codeph> de l’objet LoaderInfo utilisé avec le chargement de sorte que le domaine s’utilise avec la méthode <codeph>allowDomain()</codeph>. Par exemple, si vous chargez un fichier enfant à l’aide d’un objet Loader, à l’issue du chargement, vous pouvez vérifier la propriété <codeph>contentLoaderInfo.url</codeph> de l’objet Loader et analyser le domaine à travers la chaîne URL complète. Si vous procédez ainsi, veillez à attendre la fin du chargement du fichier, car la valeur de la propriété <codeph>contentLoaderInfo.url</codeph> ne sera correcte et définitive qu’une fois le fichier entièrement chargé. </p> 
	 
	 <p>Le cas contraire peut aussi se présenter : vous pouvez créer un fichier enfant qui souhaite accepter les appels LocalConnection émanant de son parent, mais qui ignore le domaine de ce dernier. Dans ce cas, mettez en œuvre cette méthode en vérifiant si l’argument de domaine correspond au domaine de la propriété <codeph>loaderInfo.url</codeph> dans le fichier chargé. Encore une fois, vous devez analyser le domaine à partir de l’adresse URL complète de <codeph>loaderInfo.url</codeph>. Dans ce cas, il n’est pas nécessaire d’attendre la fin du chargement du fichier parent ; le parent sera déjà chargé lorsque celui de l’enfant commencera.</p> 
	 
	 <p platform="actionscript">Lorsque vous employez cette méthode, tenez compte du modèle de sécurité de Flash Player. Par défaut, un objet LocalConnection est associé au sandbox du fichier qui l’a créé et les appels interdomaines des objets LocalConnection sont interdits, à moins que vous n’appeliez la méthode <codeph>LocalConnection.allowDomain()</codeph> dans le fichier de réception. Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
	 
	 <p platform="actionscript">Pour plus d’informations, voir les références suivantes :</p>
	 
     <ul platform="actionscript">
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
	 <p platform="actionscript"><b>Remarque</b> : le format de la méthode <codeph>allowDomain()</codeph> n’est plus le même que dans ActionScript 1.0 et 2.0. Dans ces versions, <codeph>allowDomain</codeph> était une méthode de rappel que vous implémentiez. Dans ActionScript 3.0, <codeph>allowDomain()</codeph> est une méthode intégrée de LocalConnection que vous appelez. Le fonctionnement de la nouvelle version de <codeph>allowDomain()</codeph> est similaire à celui de <codeph>flash.system.Security.allowDomain()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowInsecureDomain()"><linktext>flash.net.LocalConnection.allowInsecureDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
	 Spécifie un ou plusieurs domaines qui peuvent envoyer des appels LocalConnection à cet objet LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Seems like a security note is in order here.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les paramètres spécifiés doivent être des chaînes réglées sur une valeur autre que null.
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs chaînes qui nomment les domaines à partir desquels les appels LocalConnection seront autorisés. Ce paramètre est associé à deux cas spéciaux :
	 <ul>
	   <li>Vous pouvez spécifier le caractère générique « ~~ » pour autoriser les appels en provenance de tous les domaines. « ~~ » exclut les hôtes locaux.</li>
	   <li>Vous pouvez spécifier la chaîne <codeph>localhost</codeph> pour autoriser les appels de ce fichier SWF à partir de fichiers SWF installés localement. Dans Flash Player 8, des restrictions de sécurité relatives aux fichiers SWF locaux ont été introduites. Un fichier SWF autorisé à accéder à Internet n’a pas accès au système de fichiers local. Si vous spécifiez <codeph>localhost</codeph>, tout fichier SWF local peut accéder à ce fichier SWF. N’oubliez pas que vous devez également désigner le fichier SWF appelant comme fichier SWF local avec accès au réseau lors de la programmation.</li>
	 </ul>
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie un ou plusieurs domaines qui peuvent envoyer des appels LocalConnection à cet objet LocalConnection.  
	 
	 <p>Le fonctionnement des méthodes <codeph>allowInsecureDomain()</codeph> et <codeph>allowDomain()</codeph> est identique, mais la méthode <codeph>allowInsecureDomain()</codeph> permet en outre aux fichiers de source non HTTPS d’envoyer des appels LocalConnection à des fichiers SWF de source HTTPS. Cette différence n’a d’importance que si vous appelez la méthode <codeph>allowInsecureDomain()</codeph> à partir d’un fichier chargé via HTTPS. Vous devez appeler la méthode <codeph>allowInsecureDomain()</codeph> même si vous franchissez une limite non HTTPS/HTTPS au sein du même domaine. Par défaut, les appels de LocalConnection entre les fichiers non HTTPS et les fichiers HTTPS sont systématiquement interdits, même au sein d’un même domaine.</p>
	 
	 <p>L’appel de <codeph>allowInsecureDomain()</codeph> est déconseillé, car il risque de compromettre la sécurité offerte par HTTPS. Lorsque vous chargez un fichier via HTTPS, vous avez la quasi-certitude qu’il ne sera pas altéré pendant sa mise en circulation dans le réseau. Si vous autorisez ensuite un fichier non HTTPS à effectuer des appels de LocalConnection vers le fichier HTTPS, vous acceptez des appels en provenance d’un fichier qui a pu être altéré pendant son transport. Vous devez donc redoubler de vigilance, car vous ne pouvez pas vous fier à l’authenticité des appels LocalConnection que reçoit votre fichier HTTPS.</p>
	 
	 <p>Par défaut, les fichiers hébergés via le protocole HTTPS sont accessibles uniquement aux autres fichiers hébergés également par l’intermédiaire du protocole HTTPS. Cette implémentation préserve l’intégrité fournie par le protocole HTTPS.</p>
	 
	 <p>Il n’est pas recommandé d’utiliser cette méthode pour annuler le comportement par défaut car elle compromet la sécurité HTTPS. Cependant, vous devrez peut-être l’utiliser, par exemple, si vous devez autoriser l’accès aux fichiers SWF publiés pour Flash Player 9 ou version ultérieure via HTTPS à partir de fichiers SWF publiés pour Flash Player 6 ou version antérieure via HTTP.</p>
	 
	 <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
	 
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:close"><apiName>close</apiName><shortdesc>
	 Ferme (déconnecte) un objet LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’occurrence de LocalConnection n’est pas connectée, elle ne peut donc pas être fermée.
	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Ferme (déconnecte) un objet LocalConnection. Appelez cette commande lorsque vous ne souhaitez plus que l’objet accepte de commandes, par exemple, lorsque vous souhaitez exécuter une commande <codeph>connect()</codeph> en utilisant le même paramètre <codeph>connectionName</codeph> dans un autre fichier SWF.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:connect"><apiName>connect</apiName><shortdesc>
	 Prépare un objet LocalConnection à recevoir des commandes à partir d’une commande send() (qui a appelé l’objet LocalConnection d’envoi).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.connect, connect
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La valeur transmise au paramètre <codeph>connectionName</codeph> ne doit pas être nulle.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire pour trois raisons : 1) La valeur de chaîne transmise au paramètre <codeph>connectionName</codeph> était nulle. Utilisez une valeur non nulle. 2) La valeur transmise au paramètre <codeph>connectionName</codeph> contenait un deux-points (:). Les deux-points sont des caractères spéciaux utilisés pour séparer le super-domaine de la chaîne <codeph>connectionName</codeph> dans la méthode <codeph>send()</codeph>, pas dans la méthode <codeph>connect()</codeph>. 3) L’occurrence de LocalConnection est déjà connectée.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne correspondant au nom de connexion spécifié dans la commande <codeph>send()</codeph> qui souhaite communiquer avec l’objet LocalConnection de réception. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Prépare un objet LocalConnection à recevoir des commandes à partir d’une commande <codeph>send()</codeph> (l’<i>objet LocalConnection d’envoi</i>). L’objet utilisé avec cette commande est appelé l’<i>objet LocalConnection de réception</i>. Les objets de réception et d’envoi doivent s’exécuter sur le même ordinateur client.
	 
	 <p>Pour éviter tout conflit, définissez les méthodes associées à l’objet LocalConnection de réception avant d’appeler cette méthode, comme illustré dans l’exemple de la classe LocalConnection. </p>
	 
	 <p>Par défaut, l’argument <codeph>connectionName</codeph> devient <codeph>"<i>superdomain</i>:connectionName"</codeph>, <codeph><i>superdomain</i></codeph> représentant le super-domaine du fichier qui contient la commande <codeph>connect()</codeph>. Par exemple, si le fichier contenant l’objet LocalConnection de réception se trouve à l’adresse www.someDomain.com, <codeph>connectionName</codeph> devient <codeph>"someDomain.com:connectionName"</codeph>. (si un fichier s’exécutant dans Flash Player se trouve sur l’ordinateur client, la valeur affectée au <codeph>superdomain</codeph> est <codeph>"localhost"</codeph>).</p>
	 
	 <p>Dans le cas de contenu s’exécutant dans le sandbox de sécurité <codeph>application</codeph> dans Adobe AIR (contenu installé avec l’application AIR), le moteur d’exécution remplace le super-domaine par la chaîne <codeph>app#</codeph> suivie de l’ID correspondant à l’application AIR (défini dans le fichier descripteur de l’application). Par exemple, l’argument <codeph>connectionName</codeph> d’une application dont l’ID est <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> devient <codeph>"app#com.example.air.MyApp:connectionName"</codeph>.</p>
	 
	 <p>De même, par défaut, Flash Player ne permet à l’objet LocalConnection de réception de n’accepter que les commandes provenant d’objets LocalConnection d’envoi dont le nom de connexion correspond également à une valeur <codeph>"</codeph><codeph><i>superdomain</i></codeph><codeph>:connectionName"</codeph>. De cette manière, Flash Player facilite la communication entre les fichiers situés dans un même domaine.</p>
	 
	 <p>Si vous implémentez une communication uniquement entre des fichiers appartenant au même domaine, spécifiez pour <codeph>connectionName</codeph> une chaîne qui ne commence pas par un caractère de soulignement (_) et qui ne spécifie pas un nom de domaine (par exemple, <codeph>"myDomain:connectionName"</codeph>). Utilisez cette même chaîne dans la méthode <codeph>connect(connectionName)</codeph>.</p>
	 
	 <p>Si vous implémentez des communications entre des fichiers de domaines différents, la spécification pour <codeph>connectionName</codeph> d’une chaîne qui commence par un caractère de soulignement (_) accroît la portabilité interdomaines du fichier associé à l’objet LocalConnection de réception. Les cas de figure possibles sont les suivants :</p>
	 
	 <ul>
	 
	   <li>Si la chaîne dédiée à l’argument <codeph>connectionName</codeph> ne commence pas par un caractère de soulignement (_), un préfixe suivi de deux points est ajouté au super-domaine (par exemple, <codeph>"myDomain:connectionName"</codeph>). Vous avez ainsi la garantie que votre connexion n’entrera pas en conflit avec les connexions de même nom dans d’autres domaines. Cependant, tous les objets LocalConnection d’envoi doivent spécifier ce super-domaine (par exemple, <codeph>"myDomain:connectionName"</codeph>). Si le fichier associé à l’objet LocalConnection de réception est déplacé dans un autre domaine, Flash Player modifie le préfixe afin qu’il reflète le nouveau super-domaine (par exemple, <codeph>« anotherDomain:connectionName »</codeph>). Tous les objets LocalConnection d’envoi doivent être modifiés manuellement pour pointer vers le nouveau super-domaine.</li>
	 
	   <li>Si la chaîne dédiée à l’argument <codeph>connectionName</codeph>commence par un caractère de soulignement (par exemple, <codeph>"_connectionName"</codeph>), aucun préfixe n’est ajouté à la chaîne. Les objets LocalConnection de réception et d’envoi utilisent donc des chaînes identiques pour <codeph>connectionName</codeph>. Si l’objet de réception utilise <codeph>allowDomain()</codeph> pour spécifier que les connexions seront acceptées à partir de tous les domaines, le fichier contenant l’objet LocalConnection de réception peut être déplacé dans un autre domaine, sans qu’il soit nécessaire de modifier les objets LocalConnection d’envoi.</li>
	 </ul>
	 
	 <p>Pour plus d’informations, voir la présentation de la classe et la section consacrée au paramètre <codeph>connectionName</codeph> de la méthode <codeph>send()</codeph>, ainsi que les entrées de <codeph>allowDomain()</codeph> et <codeph>domain</codeph>.</p>
	 
	 <p><b>Remarque : </b>les deux-points sont utilisés en tant que caractères spéciaux pour séparer le super-domaine de la chaîne <codeph>connectionName</codeph>. Toute chaîne associée à <codeph>connectionName</codeph> contenant deux-points n’est pas valide.</p>
	 
	 <p>Si vous employez cette méthode<ph platform="javascript"> dans le contenu d’un sandbox de sécurité autre que celui de l’application</ph>, tenez compte du modèle de sécurité <ph platform="actionscript">Flash Player</ph><ph platform="javascript">AIR</ph>. Par défaut, un objet LocalConnection est associé au sandbox du fichier qui l’a créé et les appels interdomaines des objets LocalConnection sont interdits, à moins que vous n’appeliez la méthode <codeph>LocalConnection.allowDomain()</codeph> dans le fichier de réception. <ph platform="actionscript">Vous pouvez empêcher un fichier d’utiliser cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui comporte le contenu SWF.</ph> Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
	 
	 <p>Pour plus d’informations, voir les références suivantes :</p>
	 
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:send"><apiName>send</apiName><shortdesc>
	 Appelle la méthode nommée methodName sur une connexion établie à l’aide de la méthode connect(connectionName) (l’objet LocalConnection de réception).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.send, send
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La valeur de <codeph>connectionName</codeph> ou de <codeph>methodName</codeph> est nulle. Transmettez des valeurs non nulles à ces paramètres.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire pour l’une des raisons suivantes : 1) La valeur de <codeph>connectionName</codeph> ou de <codeph>methodName</codeph> est une chaîne vide. Transmettez des chaînes valides pour ces paramètres. 2) La méthode spécifiée dans <codeph>methodName</codeph> est limitée. 3) Le message sérialisé envoyé est trop volumineux (plus de 40 Ko).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Correspond au nom de connexion spécifié dans la commande <codeph>connect()</codeph> qui souhaite communiquer avec l’objet LocalConnection d’envoi. 	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>methodName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la méthode à appeler dans l’objet LocalConnection de réception. Les noms de méthode suivants entraînent l’échec de la commande : <codeph>send</codeph>, <codeph>connect</codeph>, <codeph>close</codeph>, <codeph>allowDomain</codeph>, <codeph>allowInsecureDomain</codeph>, <codeph>client</codeph> et <codeph>domain</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Paramètres facultatifs supplémentaires à transmettre à la méthode spécifiée. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Appelle la méthode nommée <codeph>methodName</codeph> sur une connexion établie à l’aide de la méthode <codeph>connect(</codeph><codeph>connectionName</codeph><codeph>)</codeph> (l’objet LocalConnection de réception). L’objet utilisé avec cette commande est appelé <i>objet LocalConnection d’envoi</i>. Les fichiers SWF qui contiennent les objets d’envoi et de réception doivent s’exécuter sur le même ordinateur client.
	 
	 <p>La quantité de données que vous pouvez transmettre en tant que paramètres à cette commande est limitée à 40 Ko. Si <codeph>send()</codeph> émet une <codeph>ArgumentError</codeph> mais que votre syntaxe est correcte, tentez de répartir les requêtes <codeph>send()</codeph> dans plusieurs commandes, chacune comportant moins de 40 Ko de données.</p>
	 
	 <p>Comme nous l’avons vu à la rubrique <codeph>connect()</codeph>, le super-domaine actuel est ajouté à <codeph>connectionName</codeph> par défaut. Si vous implémentez la communication entre différents domaines, vous devez définir <codeph>connectionName</codeph> dans les objets LocalConnection d’envoi et de réception de sorte que le super-domaine actuel ne soit pas ajouté à <codeph>connectionName</codeph>. Pour ce faire, procédez de l’une des deux façons suivantes :</p>
	 
	 <ul>
	   <li>Placez un caractère de soulignement (_) au début de <codeph>connectionName</codeph> dans les objets LocalConnection d’envoi et de réception. Dans le fichier contenant l’objet de réception, utilisez <codeph>LocalConnection.allowDomain()</codeph> pour spécifier que des connexions seront acceptées de tous les domaines. Cette implémentation vous permet de stocker vos fichiers d’envoi et de réception dans n’importe quel domaine.</li>
	 
	   <li>Intégrez le super-domaine à <codeph>connectionName</codeph> dans l’objet LocalConnection d’envoi, par exemple, <codeph>myDomain.com:myConnectionName</codeph>. Dans l’objet de réception, utilisez <codeph>LocalConnection.allowDomain()</codeph> pour spécifier que les connexions à partir du super-domaine spécifié seront acceptées (dans ce cas, myDomain.com) ou que les connexions de tous les domaines seront acceptées.</li>
	 </ul>
	 
	 <p><b>Remarque :</b> vous ne pouvez pas spécifier de super-domaine dans <codeph>connectionName</codeph> dans l’objet LocalConnection de réception ; vous ne pouvez le faire que dans celui d’envoi.</p>
	 
	 <p>Si vous employez cette méthode <ph platform="javascript">dans le contenu d’un sandbox de sécurité autre que celui de l’application</ph>, tenez compte du modèle de sécurité <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph>. Par défaut, un objet LocalConnection est associé au sandbox du fichier qui l’a créé et les appels interdomaines des objets LocalConnection sont interdits, à moins que vous n’appeliez la méthode <codeph>LocalConnection.allowDomain()</codeph> dans le fichier de réception. Dans le cas de contenu SWF s’exécutant dans le navigateur, vous pouvez empêcher un fichier d’utiliser cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF. Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p> 
	 
	 <p>Pour plus d’informations, voir les références suivantes :</p>
	 
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection:send_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>La méthode <codeph>LocalConnection.send()</codeph> a tenté de communiquer avec un fichier SWF appartenant à un sandbox de sécurité auquel le code effectuant l’appel n’a pas accès. Vous pouvez contourner ce problème dans l’implémentation de la méthode <codeph>LocalConnection.allowDomain()</codeph> du récepteur.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>LocalConnection.send() a tenté de communiquer avec un fichier SWF appartenant à un sandbox de sécurité auquel le code appelant n’a pas accès.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection:send_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Si la valeur de la propriété <codeph>level</codeph> correspond à <codeph>"status"</codeph>, l’appel a abouti. Si elle correspond à <codeph>"error"</codeph>, l’appel a échoué. L’appel peut échouer si le fichier SWF de réception refuse la connexion.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Si la valeur de la propriété level correspond à « status », l’appel a abouti. Si elle correspond à « error », l’appel a échoué.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:LocalConnection:client:get"><apiName>client</apiName><shortdesc>
	 Indique l’objet sur lequel des méthodes de rappel sont appelées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>La propriété <codeph>client</codeph> ne peut pas être réglée sur l’objet null. 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Indique l’objet sur lequel des méthodes de rappel sont appelées. L’objet par défaut correspond à <codeph>this</codeph>, la connexion locale en cours de création. Si vous réglez la propriété <codeph>client</codeph> sur un autre objet, les méthodes de rappel sont appelées sur celui-ci.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:LocalConnection:domain:get"><apiName>domain</apiName><shortdesc>
	 Chaîne représentant le domaine de l’emplacement du fichier actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.domain, domain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Chaîne représentant le domaine de l’emplacement du fichier actuel. 
	 
	 <p>Dans le cas de contenu s’exécutant dans le sandbox de sécurité de l’<codeph>application</codeph> dans Adobe AIR (contenu installé avec l’application AIR), le moteur d’exécution remplace le super-domaine par la chaîne <codeph>app#</codeph> suivie de l’ID correspondant à l’application AIR (défini dans le fichier descripteur de l’application). Par exemple, l’argument <codeph>connectionName</codeph> d’une application dont l’ID est <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> devient <codeph>« app#com.example.air.MyApp:connectionName »</codeph>.</p>
	 
	 <p>Dans les fichiers SWF publiés pour Flash Player 9 ou version ultérieure, la chaîne renvoyée correspond au domaine exact du fichier, y compris aux sous-domaines. Par exemple, si le fichier se trouve à l’adresse www.adobe.com, cette commande renvoie <codeph>"www.adobe.com"</codeph>. </p>
	 
	 <p>Si le fichier actuel est un fichier local résidant sur l’ordinateur client et s’exécutant dans Flash Player, cette commande renvoie <codeph>"localhost"</codeph>.</p>
	 
	 <p>Les emplois les plus courants de cette propriété consistent à inclure le nom de domaine de l’objet LocalConnection d’envoi en tant que paramètre de la méthode que vous comptez appeler dans l’objet LocalConnection de réception, ou conjointement avec <codeph>LocalConnection.allowDomain()</codeph> pour accepter les commandes issues d’un domaine spécifique. Si vous autorisez uniquement la communication entre les objets LocalConnection appartenant au même domaine, vous n’aurez probablement pas besoin d’utiliser cette propriété.</p>
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiValue><apiValue id="flash.net:LocalConnection:isPerUser:get"><apiName>isPerUser</apiName><shortdesc>  
     Indique si le domaine de l’objet LocalConnection est limité à l’utilisateur actuel (true) ou s’il est accessible à tous les utilisateurs sur le poste de travail (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
     </apiDefaultValue></apiValueDef><apiDesc>  
     Indique si le domaine de l’objet LocalConnection est limité à l’utilisateur actuel (<codeph>true</codeph>) ou s’il est accessible à tous les utilisateurs sur le poste de travail (<codeph>false</codeph>). Cette propriété affecte uniquement le contenu s’exécutant sous Mac OS X ; les autres plates-formes ignorent ce paramètre. Les connexions sur les systèmes d’exploitation Windows et Linux sont toujours par utilisateur. Dans Flash Player 10.0.22 et les versions antérieures, et dans AIR 1.5.1 et les versions antérieures, tous les objets LocalConnection sous Mac OS X ont un domaine global. Définissez toujours cette propriété sur <codeph>true</codeph>, à moins que vous ayez besoin de conserver la compatibilité avec les versions précédentes. Dans les futures versions, la valeur par défaut de cette propriété peut changer à <codeph>true</codeph>.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
 
 La classe NetStreamInfo spécifie les diverses statistiques de Qualité de Service (QOS) liées à un objet NetStream et le tampon de flux sous-jacent pour l’audio, la vidéo et les données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 La classe NetStreamInfo spécifie les diverses statistiques de Qualité de Service (QOS) liées à un objet NetStream et le tampon de flux sous-jacent pour l’audio, la vidéo et les données. Un objet NetStreamInfo est renvoyé en réponse à l’appel de <codeph>NetStream.info</codeph>, qui prend un instantané de l’état QOS actuel et fournit les statistiques QOS via les propriétés NetStreamInfo.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamInfo:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
    Usage interne uniquement ; son utilisation n’est pas recommandée.</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>curBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>byteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>maxBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>playbackBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>droppedFrames</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>srtt</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioLossRate</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef><apiDesc>
    Usage interne uniquement ; son utilisation n’est pas recommandée. Seul le moteur d’exécution peut créer des objets NetStreamInfo.
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:NetStreamInfo:toString"><apiName>toString</apiName><shortdesc>
     Renvoie une valeur de texte donnant la liste des propriétés de l’objet NetStreamInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne contenant les valeurs des propriétés de l’objet NetStreamInfo.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Renvoie une valeur de texte donnant la liste des propriétés de cet objet NetStreamInfo.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Renvoie une valeur de texte donnant la liste des propriétés de l’objet NetStreamInfo.
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:NetStreamInfo:SRTT:get"><apiName>SRTT</apiName><shortdesc>
	 Spécifie la durée approximative de la session NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la durée approximative de la session NetStream. Cette valeur ne renvoie une valeur valide que pour les flux RTMFP et renvoie 0 pour les flux RTMP. Pour plus d’informations, voir la documentation de Flash Media Server.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferByteLength:get"><apiName>audioBufferByteLength</apiName><shortdesc>
	 Fournit la taille du tampon audio Netstream, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fournit la taille du tampon audio Netstream, en octets. La propriété spécifie la taille du tampon pour les données audio du support de diffusion en continu, en direct et enregistré. Cette propriété est similaire à <codeph>Netstream.bytesLoaded</codeph>, utilisée dans les téléchargements progressifs. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferLength:get"><apiName>audioBufferLength</apiName><shortdesc>
	 Fournit la taille du tampon audio Netstream, en secondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fournit la taille du tampon audio Netstream, en secondes. Cette propriété étend la propriété <codeph>NetStream.bufferLength</codeph> et fournit la durée du tampon, en particulier pour les données audio. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioByteCount:get"><apiName>audioByteCount</apiName><shortdesc>
	 Spécifie le nombre total d’octets audio arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le nombre total d’octets audio arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée. Vous pouvez utiliser cette valeur pour calculer la cadence des données audio entrantes, en utilisant la mesure de votre choix, et en créant une horloge et en calculant la différence entre les valeurs des appels successifs à l’horloge. Vous pouvez également utiliser <codeph>audioBytesPerSecond</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/audioBytesPerSecond"><linktext>audioBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:audioBytesPerSecond:get"><apiName>audioBytesPerSecond</apiName><shortdesc>
	 Spécifie la cadence à laquelle le tampon audio NetStream est rempli, en octets par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la cadence à laquelle le tampon audio NetStream est rempli, en octets par seconde. La valeur est calculée en tant que moyenne des données audio reçues au cours de la dernière seconde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioLossRate:get"><apiName>audioLossRate</apiName><shortdesc>
	 Spécifie la perte audio de la session NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la perte audio de la session NetStream. Cette valeur ne renvoie une valeur valide que pour les flux RTMFP et renvoie 0 pour les flux RTMP. La perte audio est le rapport entre les messages perdus et le total des messages.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:byteCount:get"><apiName>byteCount</apiName><shortdesc>
	 Spécifie le nombre total d’octets audio arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le nombre total d’octets audio arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée. Vous pouvez utiliser cette valeur pour calculer la cadence des données entrantes, en utilisant la mesure de votre choix, et en créant une horloge et en calculant la différence entre les valeurs des appels successifs à l’horloge. Vous pouvez également utiliser <codeph>currentBytesPerSecond</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/currentBytesPerSecond"><linktext>currentBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:currentBytesPerSecond:get"><apiName>currentBytesPerSecond</apiName><shortdesc>
	 Spécifie la cadence à laquelle le tampon Netstream est rempli, en octets par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la cadence à laquelle le tampon Netstream est rempli, en octets par seconde. La valeur est calculée en tant que moyenne des données reçues au cours de la dernière seconde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferByteLength:get"><apiName>dataBufferByteLength</apiName><shortdesc>
	 Fournit la taille du tampon de données Netstream, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fournit la taille du tampon de données Netstream, en octets. La propriété spécifie la taille du tampon pour les messages de données su support de diffusion en continu, en direct et enregistré. Cette propriété est similaire à <codeph>Netstream.bytesLoaded</codeph>, utilisée dans les téléchargements progressifs. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferLength:get"><apiName>dataBufferLength</apiName><shortdesc>
	 Fournit la taille du tampon des données Netstream, en secondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fournit la taille du tampon des données Netstream, en secondes. Cette propriété étend la propriété <codeph>NetStream.bufferLength</codeph> et fournit la durée du tampon, en particulier pour les messages de données.  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataByteCount:get"><apiName>dataByteCount</apiName><shortdesc>
	 Spécifie le nombre total d’octets de messages de données arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le nombre total d’octets de messages de données arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée. Vous pouvez utiliser cette valeur pour calculer la cadence des messages de données entrants, en utilisant la mesure de votre choix, et en créant une horloge et en calculant la différence entre les valeurs des appels successifs à l’horloge. Vous pouvez également utiliser <codeph>dataBytesPerSecond</codeph>. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/dataBytesPerSecond"><linktext>dataBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:dataBytesPerSecond:get"><apiName>dataBytesPerSecond</apiName><shortdesc>
	 Spécifie la cadence à laquelle le tampon de données NetStream est rempli, en octets par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la cadence à laquelle le tampon de données NetStream est rempli, en octets par seconde. La valeur est calculée en tant que moyenne des messages de données reçus au cours de la dernière seconde.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:droppedFrames:get"><apiName>droppedFrames</apiName><shortdesc>
	 Renvoie le nombre d’images vidéo abandonnées dans la session de lecture NetStream en cours.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Renvoie le nombre d’images vidéo abandonnées dans la session de lecture NetStream en cours. 
	 <p>Dans le cas de téléchargement de flux enregistrés ou progressifs, si la vidéo est de qualité ou de résolution élevée, le décodeur peut être en retard dans le décodage du nombre requis d’images par seconde s’il ne dispose pas des ressources CPU système adéquates. En flux continu en direct, le tampon abandonne les images vidéo si le retard devient trop important. Cette propriété spécifie le nombre d’images abandonnées et non présentées normalement.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:maxBytesPerSecond:get"><apiName>maxBytesPerSecond</apiName><shortdesc>
	 Spécifie la cadence maximale à laquelle le tampon NetStream est rempli, en octets par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la cadence maximale à laquelle le tampon NetStream est rempli, en octets par seconde. Cette valeur fournit des informations sur la capacité du réseau du client sur la base des derniers messages reçus par l’objet <codeph>NetStream</codeph>. Selon la taille du tampon spécifié dans <codeph>NetStream.bufferTime</codeph> et la bande passante disponible sur le client, Flash Media Server remplit le tampon en rafales. Cette propriété fournit la cadence maximale à laquelle le tampon du client est rempli.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:playbackBytesPerSecond:get"><apiName>playbackBytesPerSecond</apiName><shortdesc>
	 Renvoie la cadence de lecture du flux, en octets par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Renvoie la cadence de lecture du flux, en octets par seconde. Le tampon de lecture peut contenir diverses listes de lecture. Cette propriété fournit la cadence de lecture correspondant le mieux au débit du flux en cours de lecture.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferByteLength:get"><apiName>videoBufferByteLength</apiName><shortdesc>
	 Fournit la taille du tampon vidéo Netstream, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fournit la taille du tampon vidéo Netstream, en octets. La propriété spécifie la taille du tampon pour les données vidéo du support de diffusion en continu, en direct et enregistré. Cette propriété est similaire à <codeph>Netstream.bytesLoaded</codeph>, utilisée dans les téléchargements progressifs. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferLength:get"><apiName>videoBufferLength</apiName><shortdesc>
	 Fournit la taille du tampon vidéo Netstream, en secondes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Fournit la taille du tampon vidéo Netstream, en secondes. Cette propriété étend la propriété <codeph>NetStream.bufferLength</codeph> et fournit la durée du tampon en secondes, en particulier pour les données vidéo. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoByteCount:get"><apiName>videoByteCount</apiName><shortdesc>
	 Spécifie le nombre total d’octets vidéo arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le nombre total d’octets vidéo arrivés en file d’attente, quelle que soit la quantité déjà lue ou vidée. Vous pouvez utiliser cette valeur pour calculer la cadence des données vidéo entrantes, en utilisant la mesure de votre choix, et en créant une horloge et en calculant la différence entre les valeurs des appels successifs à l’horloge. Vous pouvez également utiliser <codeph>videoBytesPerSecond</codeph>. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/videoBytesPerSecond"><linktext>videoBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:videoBytesPerSecond:get"><apiName>videoBytesPerSecond</apiName><shortdesc>
	 Spécifie la cadence à laquelle le tampon vidéo NetStream est rempli, en octets par seconde.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie la cadence à laquelle le tampon vidéo NetStream est rempli, en octets par seconde. La valeur est calculée en tant que moyenne des données vidéo reçues au cours de la dernière seconde.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLStream"><apiName>URLStream</apiName><shortdesc>
 La classe URLStream offre un accès de bas niveau pour le téléchargement des URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe URLStream offre un accès de bas niveau pour le téléchargement des URL. Les données sont mises à la disposition du code dès le début de leur téléchargement. Il n’est donc pas nécessaire d’attendre la fin du téléchargement du fichier comme avec URLLoader. La classe URLStream vous permet également de fermer un flux continu avant la fin du téléchargement. Le contenu du fichier téléchargé est disponible sous forme de données binaires brutes.
 
 <p>Les opérations de lecture dans URLStream ne sont pas bloquantes. Cela signifie que vous devez utiliser la propriété <codeph>bytesAvailable</codeph> pour déterminer si suffisamment de données sont disponibles avant de tenter de les lire. Si les données disponibles sont insuffisantes, une exception <codeph>EOFError</codeph> est renvoyée.</p>
 
 <p>Toutes les données binaires sont codées par défaut au format BE (gros-boutiste), l’octet le plus significatif étant en première position.</p>
 
 <p>Les règles de sécurité qui s’appliquent au téléchargement d’URL avec la classe URLStream sont identiques à celles appliquées aux objets URLLoader. Il est possible de télécharger les fichiers de régulation, si nécessaire. Les règles de sécurité des fichiers locaux sont appliquées et des avertissements de sécurité sont générés, si besoin est.</p>

 
 </apiDesc><example conref="examples\URLStreamExample.as"> L’exemple suivant charge un fichier SWF et analyse la première partie de son en-tête pour indiquer les informations relatives à la compression et au numéro de version. 
 <p>Pour exécuter l’exemple, placez un fichier intitulé URLStreamExample.swf dans le même répertoire que vos fichiers SWF.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.*;
    import flash.events.*;
    import flash.net.URLRequest;
    import flash.net.URLStream;

    public class URLStreamExample extends Sprite {
        private static const ZLIB_CODE:String = "CWS";
        private var stream:URLStream;

        public function URLStreamExample() {
            stream = new URLStream();
            var request:URLRequest = new URLRequest("URLStreamExample.swf");
            configureListeners(stream);
            try {
                stream.load(request);
            } catch (error:Error) {
                trace("Unable to load requested URL.");
            }
        }

        private function configureListeners(dispatcher:EventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function parseHeader():void {
            trace("parseHeader");
            trace("isCompressed: " + isCompressed());
            trace("version: " + stream.readByte());
        }

        private function isCompressed():Boolean {
            return (stream.readUTFBytes(3) == ZLIB_CODE);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
            parseHeader();
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:Event):void {
            trace("progressHandler: " + event);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><adobeApiEvent id="flash.net:URLStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Distribué lorsque des données sont reçues pendant l’opération de téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué à la réception des données au fur et à mesure du téléchargement. Les données reçues peuvent être lues immédiatement à l’aide des méthodes de la classe URLStream.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Distribué lors du démarrage d’une opération de chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lors du démarrage d’une opération de chargement.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’un chargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée/sortie entraînant l’échec d’un chargement. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 Distribué si un appel de la méthode URLStream.load() tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>URLStream.load()</codeph> tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête. 
 
 <p>Si un objet URLStream s’inscrit à un événement <codeph>httpStatusEvent</codeph>, les réponses aux erreurs sont livrées, même s’il s’agit de contenu. Par conséquent, au lieu de distribuer un événement <codeph>ioError</codeph>, l’objet URLStream distribue des événements <codeph>progress</codeph> et <codeph>complete</codeph> lorsque les données d’erreur sont chargées dans l’objet URLStream.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Distribué si un appel de la méthode URLStream.load() tente d’accéder aux données via HTTP, et si Flash Player ou Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>URLStream.load()</codeph> tente d’accéder aux données via HTTP, et si <ph platform="actionscript">Flash Player ou</ph> Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête (certains environnements de navigateur ne sont pas capables de fournir cette information). Vous remarquerez que <codeph>httpStatus</codeph> (le cas échéant) sera envoyé avant (et en complément de) tout événement <codeph>complete</codeph> ou <codeph>error</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué si un appel de la méthode URLStream.load() tente de charger des données d’un serveur en dehors d’un sandbox de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>URLStream.load()</codeph> tente de charger des données d’un serveur en dehors d’un sandbox de sécurité.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Distribué lorsque le chargement de données aboutit. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque le chargement de données a abouti. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:URLStream:close"><apiName>close</apiName><shortdesc>
     Ferme immédiatement le flux continu et annule le téléchargement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La fermeture du flux continu s’est révélée impossible ou ce flux n’a pas été ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Ferme immédiatement le flux continu et annule le téléchargement. Après l’appel de la méthode <codeph>close()</codeph>, aucune donnée ne peut être lue dans le flux continu.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:load"><apiName>load</apiName><shortdesc>
     Amorce le téléchargement de l’URL spécifiée dans le paramètre request.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les objets <codeph>URLRequest.requestHeader</codeph> ne devraient pas contenir certains en-têtes de requête HTTP interdits. Pour plus d’informations, voir la description de la classe URLRequestHeader.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Cette erreur peut se produire pour les raisons suivantes :
     
     <ol>
     
     <li>Flash Player ou Adobe AIR ne peut pas convertir le paramètre <codeph>URLRequest.data</codeph> du format UTF8 au format MBCS. Cette erreur est concernée si l’objet URLRequest transmis à la méthode <codeph>load()</codeph> est configuré pour exécuter une opération <codeph>GET</codeph> et si <codeph>System.useCodePage</codeph> est réglé sur <codeph>true</codeph>. </li>
     
     <li>Flash Player ou Adobe AIR ne peut pas allouer de mémoire aux données <codeph>POST</codeph>. Cette erreur est applicable si l’objet URLRequest transmis à load est configuré pour exécuter une opération <codeph>POST</codeph>.</li></ol>
     
     </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Les fichiers SWF non approuvés au niveau local ne peuvent pas communiquer avec Internet. Pour contourner ce problème, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Objet URLRequest indiquant l’URL à télécharger. Si la valeur de ce paramètre ou la propriété <codeph>URLRequest.url</codeph> de l’objet URLRequest transmis correspondent à <codeph>null</codeph>, l’application renvoie une erreur de pointeur Null.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Commence le téléchargement de l’URL spécifiée dans le paramètre <codeph>request</codeph>.
     
     <p><b>Remarque</b> : si un fichier en cours de chargement contient des caractères non-ASCII (comme s’en trouvent dans de nombreuses langues autres que l’anglais), nous vous recommandons d’enregistrer le fichier en utilisant le codage UTF-8 ou UTF-16, plutôt que sous un format non-Unicode, ASCII par exemple.</p>
     
     <p>Si le chargement échoue immédiatement, une exception IOError ou SecurityError (erreur de sécurité de fichier local comprise) décrivant l’échec est renvoyée. Dans le cas contraire, un événement <codeph>open</codeph> est distribué si le téléchargement de l’URL démarre correctement ou un événement d’erreur est distribué en cas d’erreur.</p>
     
     <p>Par défaut, le fichier SWF appelant et l’URL chargée doivent se trouver dans le même domaine. Par exemple, un fichier SWF à l’adresse www.adobe.com peut charger uniquement des données provenant de sources situées aussi à l’adresse www.adobe.com. Pour charger des données à partir d’un autre domaine, placez un fichier de régulation d’URL sur le serveur hébergeant les données.</p>
     
      <p platform="actionscript">Dans Flash Player, vous ne pouvez pas vous connecter à des ports normalement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     <p platform="actionscript">Dans Flash Player, vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</p>
     
     <p platform="actionscript"> Dans Flash Player 10 et versions ultérieures, et dans AIR 1.5 et versions ultérieures, si vous utilisez un Content-Type en plusieurs parties (par exemple « multipart/form-data ») qui contient un chargement (indiqué par un paramètre « filename » dans un en-tête «content-disposition » au sein du corps POST), l’opération POST est soumise aux règles de sécurité appliquées aux chargements :</p>
	 <ul platform="actionscript">
	 <li>L’opération POST doit être effectuée en réponse à l’action d’un utilisateur, comme un clic de souris ou la pression d’une touche.</li>
	 <li>Si l’opération POST se fait entre plusieurs domaines (la cible POST ne se trouve pas sur le même serveur que le fichier SWF qui envoie la demande POST), le serveur cible doit fournir un fichier de régulation d’URL qui permette l’accès interdomaines.</li>
	 </ul>
     <p platform="actionscript">Par ailleurs, la syntaxe de tous les Content-Type en plusieurs parties doit être correcte (selon la norme RFC2046). Si la syntaxe s’avère incorrecte, l’opération POST est soumise aux règles de sécurité appliquées aux chargements.</p>
     
     <p platform="actionscript">Le contenu AIR dans des sandbox non-applicatifs est également soumis à ces règles. Cependant, dans Adobe AIR, le contenu du sandbox de l’application (contenu installé avec l’application AIR) n’est pas soumis à ces limites de sécurité.</p>
     
     <p platform="actionscript">Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     <ul platform="actionscript">
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     <li>La section « Présentation de la sécurité dans AIR » du chapitre « Bien démarrer avec Adobe AIR » du manuel <i>Développement d’applications AIR</i></li>
     
     </ul>
     
     <p>Dans AIR, un objet URLRequest peut enregistrer l’événement d’état <codeph>httpResponse</codeph>. Contrairement à l’événement <codeph>httpStatus</codeph>, l’événement <codeph>httpResponseStatus</codeph> est renvoyé avant toute donnée de réponse. De plus, l’événement <codeph>httpResponseStatus</codeph> inclut des valeurs pour les propriétés <codeph>responseHeaders</codeph> et <codeph>responseURL</codeph> (qui ne sont pas définies pour un événement <codeph>httpStatus</codeph>. Notez que <codeph>httpResponseStatus</codeph> (le cas échéant) est envoyé avant (et en complément de) tout événement <codeph>complete</codeph> ou <codeph>error</codeph>. 
     </p>
     
     
     <p>S’il <i>existe</i> un écouteur d’événement <codeph>httpResponseStatus</codeph>, le corps du message de réponse est <i>toujours</i> envoyé. En outre, le code d’état de la réponse HTTP distribue toujours un événement <codeph>complete</codeph>, qu’il indique un message de réussite ou un message d’erreur.</p> 
     
     <p><ph platform="actionscript">Dans AIR, s’il</ph><ph platform="javascript">S’il</ph> n’existe <i>pas</i> d’écouteur d’événement <codeph>httpResponseStatus</codeph>, le comportement varie selon la version <ph platform="actionscript">du fichier SWF</ph><ph platform="javascript">d’AIR</ph> :</p>
     
     <ul>
     
         <li><ph platform="actionscript">Pour le contenu SWF 9</ph><ph platform="javascript">Dans un fichier AIR dont le descripteur d’application spécifie AIR 1.0 ou 1.1 comme version du moteur d’exécution</ph>, le corps du message de réponse HTTP est envoyé <i>uniquement si</i> le code d’état de la réponse HTTP indique que l’opération a réussi. Dans le cas contraire (si le code indique une erreur), le corps du message n’est pas envoyé et l’objet URLRequest distribue un événement IOError.</li>
     
         <li><ph platform="actionscript">Pour le contenu SWF 10</ph><ph platform="javascript">Dans un fichier AIR dont le descripteur d’application spécifie AIR 1.5 comme version du moteur d’exécution</ph>, le corps du message de réponse HTTP est <i>toujours</i> envoyé. En cas d’erreur, l’objet URLRequest distribue un événement IOError.</li>
     
     </ul>
     
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:URLStream:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué après le chargement effectif de données. S’il existe un écouteur d’événement <codeph>httpResponseStatus</codeph>, l’objet URLRequest distribue également un événement <codeph>complete</codeph>, que le code d’état de la réponse HTTP indique une réussite <i>ou</i> une erreur.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Distribué après le chargement effectif de données.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Si l’accès s’effectue par HTTP<ph platform="actionscript"> et que l’environnement actuel permet l’obtention des codes d’état</ph>, il se peut que vous receviez ces événements en plus des événements <codeph>complete</codeph> ou <codeph>error</codeph>.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Si l’accès s’effectue par HTTP et que l’environnement actuel permet l’obtention des codes d’état, il se peut que vous receviez ces événements en plus des événements complete ou error.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué si un appel de la méthode <codeph>load()</codeph> tente d’accéder aux données via HTTP et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête. 
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué si un appel de la méthode load() tente d’accéder aux données via HTTP, et si Adobe AIR est capable de détecter et de renvoyer le code d’état de la requête.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>L’opération de chargement n’a pas pu aboutir.
     
     </apiDesc></adobeApiEventDetail><shortdesc>L’opération de chargement n’a pu se terminer.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Distribué lors du démarrage d’une opération de chargement.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Distribué lors du démarrage d’une opération de chargement.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Une opération de chargement a tenté d’extraire des données à partir d’un serveur situé en dehors du sandbox de sécurité de l’appelant. Vous pouvez contourner le problème en utilisant un fichier de régulation au niveau du serveur.
     </apiDesc></adobeApiEventDetail><shortdesc>Une opération de chargement a tenté d’extraire des données d’un serveur situé hors du sandbox de sécurité de l’appelant.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:URLStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     Lit une valeur booléenne dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur <codeph>true</codeph> est renvoyée si l’octet n’est pas nul, <codeph>false</codeph> dans le cas contraire.
     
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit une valeur booléenne dans le flux continu. Un seul octet est lu, et la valeur <codeph>true</codeph> est renvoyée s’il n’est pas nul, <codeph>false</codeph> dans le cas contraire.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readByte"><apiName>readByte</apiName><shortdesc>
     Lit un octet signé dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur est comprise entre -128 et 127.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un octet signé dans le flux continu.
     <p>La valeur renvoyée est comprise entre -128 et 127.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readBytes"><apiName>readBytes</apiName><shortdesc>
     Lit les octets length des données dans le flux.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray dont les données doivent être lues.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décalage associé à <codeph>bytes</codeph> en fonction duquel la lecture des données doit commencer. La valeur par défaut est 0.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre d’octets à lire. La valeur par défaut, 0, entraîne la lecture de toutes les données disponibles.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit le nombre d’octets de données spécifié par le paramètre <codeph>length</codeph> dans le flux. Les octets sont lus dans l’objet ByteArray spécifié par le paramètre <codeph>bytes</codeph>, à partir des octets <codeph>offset</codeph> dans l’objet ByteArray.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readDouble"><apiName>readDouble</apiName><shortdesc>
     Lit un nombre à virgule flottante avec deux décimales, conforme à IEEE 754, dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à deux décimales, conforme à IEEE 754, dans le flux continu.
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un nombre à virgule flottante avec deux décimales, conforme à IEEE 754, dans le flux continu.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readFloat"><apiName>readFloat</apiName><shortdesc>
     Lit un nombre à virgule flottante et à une décimale, conforme à IEEE 754, dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à une décimale, conforme à IEEE 754, dans le flux continu.
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un nombre à virgule flottante et à une décimale, conforme à IEEE 754, dans le flux continu.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readInt"><apiName>readInt</apiName><shortdesc>
     Lit un entier signé de 32 bits dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur est comprise entre -2147483648 et 2147483647.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier signé de 32 bits dans le flux continu.
     <p>La valeur renvoyée est comprise entre -2147483648 et 2147483647.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     Lit une chaîne à plusieurs octets de longueur spécifiée à partir du flux d’octets et à l’aide du jeu de caractères désigné.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLStream, URLStream.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne au format UTF-8.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire dans le flux d’octets.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne désignant le le jeu de caractères à utiliser pour interpréter les octets. Parmi les chaînes de jeu de caractères supportées figurent <codeph>"shift_jis"</codeph>, <codeph>"CN-GB"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>.    
	 
     <p><b>Remarque :</b> si la valeur du paramètre <codeph>charSet</codeph> n’est pas reconnue par le système actuel, l’application utilise la page de code par défaut du système comme jeu de caractères. Par exemple, une valeur pour le paramètre <codeph>charSet</codeph>, comme dans <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> qui utilise <codeph>01</codeph> au lieu de <codeph>1</codeph> pourra éventuellement fonctionner sur votre poste de développement, mais pas sur un autre poste. Sur l’autre ordinateur, l’application utilisera la page de code par défaut du système.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit une chaîne à plusieurs octets de longueur spécifiée à partir du flux d’octets et à l’aide du jeu de caractères désigné.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readObject"><apiName>readObject</apiName><shortdesc>
     Lit dans le socket un objet codé au format AMF (Action Message Format).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet désérialisé.
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     Lit dans le socket un objet codé au format AMF (Action Message Format).
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiOperation><apiOperation id="flash.net:URLStream:readShort"><apiName>readShort</apiName><shortdesc>
     Lit un entier signé de 16 bits dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur est comprise entre -32768 et 32767.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier signé de 16 bits dans le flux continu.
     <p>La valeur renvoyée est comprise entre -32768 et 32767.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTF"><apiName>readUTF</apiName><shortdesc>
     Lit une chaîne UTF-8 dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8.
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit une chaîne UTF-8 dans le flux continu. La chaîne doit être précédée d’un caractère non signé indiquant la longueur en octets.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     Lit une séquence d’octets UTF-8 length dans le flux et renvoie une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8 de longueur spécifiée, générée par la représentation des caractères sous forme d’octets.
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Séquence d’octets UTF-8.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Lit une séquence d’octets UTF-8 <codeph>length</codeph> dans le flux et renvoie une chaîne.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     Lit un octet non signé dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>

     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur est comprise entre 0 et 255.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un octet non signé dans le flux continu.
     <p>La valeur renvoyée est comprise entre 0 et 255. </p>     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     Lit un entier de 32 bits non signé dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur est comprise entre 0 et 4294967295.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier de 32 bits non signé dans le flux continu.
     <p>La valeur renvoyée est comprise entre 0 et 4294967295. </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     Lit un entier de 16 bits non signé dans le flux continu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Les données à lire sont insuffisantes. Si un fichier SWF local déclenche un avertissement de sécurité, Flash Player ne met pas les données URLStream à la disposition d’ActionScript. Dans ce cas, la propriété <codeph>bytesAvailable</codeph> renvoie 0 même si les données ont été reçues, et les éventuelles méthodes de lecture renvoient une exception EOFError.</ph> <ph platform="javascript">Cette erreur s’applique au contenu SWF ; elle ne se produit pas dans le code JavaScript s’exécutant dans AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Une erreur d’E/S s’est produite dans le flux continu ou ce dernier n’est pas ouvert.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur est comprise entre 0 et 65535.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Lit un entier de 16 bits non signé dans le flux continu.
     <p>La valeur renvoyée est comprise entre 0 et 65535. </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     Renvoie le nombre d’octets de données disponibles pour la lecture dans le tampon de saisie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie le nombre d’octets de données disponibles pour la lecture dans le tampon de saisie. Votre code doit appeler la propriété <codeph>bytesAvailable</codeph> pour garantir que les données disponibles sont suffisantes, avant leur lecture à l’aide d’une des méthodes <codeph>read</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:connected:get"><apiName>connected</apiName><shortdesc>
     Indique si l’objet URLStream est actuellement connecté.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si l’objet URLStream est actuellement connecté. Un appel de cette propriété renvoie la valeur <codeph>true</codeph> si l’objet URLStream est connecté, <codeph>false</codeph> dans le cas contraire.     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:endian:get"><apiName>endian</apiName><shortdesc>
     Indique l’ordre d’octet des données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     Indique l’ordre d’octet des données. Les valeurs possibles sont <codeph>Endian.BIG_ENDIAN</codeph> ou <codeph>Endian.LITTLE_ENDIAN</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:URLStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Contrôle la version du format AMF (Action Message Format) utilisé lors de l’écriture ou de la lecture d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Contrôle la version du format AMF (Action Message Format) utilisé lors de l’écriture ou de la lecture d’un objet.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>Classe ObjectEncoding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObject"><apiName>SharedObject</apiName><shortdesc>
 La classe SharedObject est utilisée pour lire et stocker des quantités limitées de données sur l’ordinateur d’un utilisateur ou sur un serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, shared object, constructor
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SharedObject est utilisée pour lire et stocker des quantités limitées de données sur l’ordinateur d’un utilisateur ou sur un serveur. Les objets partagés permettent le partage en temps réel de plusieurs fichiers et objets SWF clients qui sont stockés en permanence sur l’ordinateur local ou sur un serveur distant. Les objets partagés locaux sont identiques aux cookies des navigateurs et les objets partagés distants sont identiques aux périphériques de transfert de données en temps réel. Pour utiliser des objets partagés distants, vous avez besoin d’Adobe Flash Media Server.
 
 <p>Utilisez des objets partagés lorsque vous devez :</p>
 
 <ul>
 
 <li><b>Conserver la persistance locale</b>. Il s’agit de la méthode la plus simple pour utiliser un objet partagé. Elle ne requiert pas Flash Media Server. Par exemple, vous pouvez appeler <codeph>SharedObject.getLocal()</codeph> pour créer un objet partagé dans une application, par exemple une calculatrice avec mémoire. Lorsque l’utilisateur ferme la calculatrice, Flash Player enregistre la dernière valeur dans un objet partagé dans l’ordinateur de l’utilisateur. Lors de sa prochaine exécution, la calculatrice contiendra la valeur précédente. En revanche, si vous réglez les propriétés de l’objet partagé sur <codeph>null</codeph> avant la fermeture de la calculatrice, lors de sa prochaine exécution, elle ne contiendra aucune valeur. Un autre exemple de conservation de la persistance locale consiste à assurer le suivi des préférences utilisateur ou d’autres données pour un site Web complexe, tel que l’enregistrement des articles lus par un utilisateur dans un site d’actualités. Le suivi de ces informations vous permet de différencier l’affichage des articles déjà lus de ceux qui sont nouveaux ou non lus. Le stockage de ces informations dans l’ordinateur de l’utilisateur réduit la charge du serveur.</li>
 
 <li><b>Stockage et partage des données sur Flash Media Server</b>. Un objet partagé peut stocker des données sur le serveur pour que d’autres clients les y récupèrent. Par exemple, appelez <codeph>SharedObject.getRemote()</codeph> pour créer un objet partagé distant, tel qu’une liste téléphonique, persistant sur le serveur. Chaque fois qu’un client modifie l’objet partagé, les données modifiées sont mises à la disposition de tous les clients actuellement connectés à l’objet ou qui s’y connectent ultérieurement. Si l’objet est également persistant localement et qu’un client change ses données alors qu’il n’est pas connecté au serveur, les données sont copiées dans l’objet partagé distant dès que le client se connecte à cet objet.</li>
 
 <li><b>Partage des données en temps réel</b>. Un objet partagé peut partager des données en temps réel entre plusieurs clients. Vous pouvez, par exemple, ouvrir un objet partagé distant qui stocke la liste des utilisateurs connectés à une salle de conversation accessible à tous les clients connectés à l’objet. Lorsqu’un utilisateur entre dans la salle de conversation ou en sort, l’objet est mis à jour et la liste révisée des utilisateurs de la salle est visible par tous les clients connectés à l’objet.</li>
 
 </ul>
 
 <p> Pour créer un objet partagé local, appelez <codeph>SharedObject.getLocal()</codeph>. Pour créer un objet partagé distant, appelez <codeph>SharedObject.getRemote()</codeph>.</p> 
 
 <p> A la fermeture d’une application, les objets partagés sont <i>purgés</i> ou écrits sur un disque. Vous pouvez également appeler la méthode <codeph>flush()</codeph> pour écrire explicitement les données sur un disque.</p>
 
 <p><b>Eléments importants relatifs à l’espace disque local.</b> Les objets partagés locaux possèdent certaines restrictions dont vous devez absloment tenir compte lors de la conception de votre application. Certains fichiers SWF ne sont pas autorisés à écrire des objets partagés locaux et certaines données stockées dans des objets partagés locaux sont parfois supprimées à votre insu. Les utilisateurs de Flash Player peuvent gérer l’espace disque disponible pour des domaines spécifiques ou l’ensemble des domaines. Lorsque des utilisateurs réduisent la quantité d’espace disque disponible, certains objets locaux partagés risquent d’être supprimés. Les utilisateurs de Flash Player disposent également de contrôles de confidentialité qui peuvent empêcher les domaines tiers (autres que celui figurant dans la barre d’adresse du navigateur) de lire ou d’écrire des objets partagés locaux.</p>
 
 <p><b>Remarque</b> : les fichiers SWF stockés et exécutés sur un ordinateur local, et non à partir d’un serveur distant, peuvent toujours écrire des objets partagés par un tiers sur un disque. Pour plus d’informations sur les objets partagés par un tiers, voir <xref href="http://www.macromedia.com/support/documentation/fr/flashplayer/help/settings_manager03.html" scope="external">Panneau Paramètres globaux d’enregistrement</xref> dans l’aide de Flash Player.</p>
 
 <p>Il est toujours conseillé de vérifier les défaillances relatives à la quantité d’espace disque et au contrôle de la confidentialité des utilisateurs. Effectuez ces vérifications lorsque vous appelez <codeph>getLocal()</codeph> et <codeph>flush()</codeph> :
 
 <ul>
 <li><codeph>SharedObject.getLocal()</codeph> — Flash Player renvoie une exception lors de l’échec d’un appel de cette méthode, par exemple lorsque l’utilisateur a désactivé les objets partagés par un tiers et que le domaine de votre fichier SWF ne correspond pas à celui de la barre d’adresse du navigateur.</li>
 
 <li><codeph>SharedObject.flush()</codeph> — Flash Player renvoie une exception lors de l’échec d’un appel de cette méthode. Il renvoie <codeph>SharedObjectFlushStatus.FLUSHED</codeph> lorsque l’appel aboutit. Il renvoie <codeph>SharedObjectFlushStatus.PENDING</codeph> lorsque de l’espace disque supplémentaire est nécessaire. Flash Player invite l’utilisateur à allouer plus d’espace disque aux informations enregistrées localement. Par la suite, l’événement <codeph>netStatus</codeph> est distribué avec un objet d’informations indiquant si la purge a abouti ou échoué.</li>
 </ul></p>
 
 <p>Si votre fichier SWF tente de créer ou modifier des objets partagés locaux, assurez-vous que le fichier SWF fait au moins 215 pixels de large et 138 pixels de haut (ce qui constitue les dimensions minimales d’affichage de la boîte de dialogue qui suggère à l’utilisateur d’augmenter sa limite locale de stockage des objets partagés locaux). Si votre fichier SWF est inférieur à ces dimensions et si une augmentation de la limite de stockage est nécessaire, <codeph>SharedObject.flush()</codeph> échoue, renvoie <codeph>SharedObjectFlushedStatus.PENDING</codeph> et distribue l’événement <codeph>netStatus</codeph>.</p>
 
 <p>
 <b>Objets partagés distants.</b> Flash Media Server vous permet de créer et d’utiliser des objets partagés distants, partagés en temps réel par tous les clients connectés à votre application. Lorsqu’un client modifie une propriété d’un objet partagé distant, cette propriété est modifiée pour tous les clients connectés. Vous pouvez utiliser des objets partagés distants pour synchroniser des clients, par exemple les utilisateurs d’un jeu multi-joueurs.
 </p>
 
 <p>
 Chaque objet partagé distant possède une propriété <codeph>data</codeph> correspondant à un Objet avec propriétés qui stocke des données. Appelez <codeph>setProperty()</codeph> pour modifier une propriété de l’objet de données. Le serveur met à jour les propriétés, envoie un événement <codeph>sync</codeph>, puis renvoie les propriétés aux clients connectés. 
 </p>
 
 <p>
 Vous pouvez choisir de rendre les objets partagés distants persistant sur le client, sur le serveur ou sur les deux. Par défaut, Flash Player enregistre localement les objets partagés distants persistants dont la taille est inférieure à 100 Ko. Lorsque vous tentez d’enregistrer un objet plus volumineux, Flash Player ouvre une boite de dialogue de stockage local qui permet à l’utilisateur d’autoriser ou d’interdire le stockage local de l’objet partagé. Assurez-vous que la taille de votre scène est d’au moins 215 x 138 pixels ; il s’agit de la taille minimale requise par Flash pour afficher cette boîte de dialogue.
 </p>
 <p>
 Si l’utilisateur sélectionne Autoriser, le serveur enregistre l’objet partagé et distribue un événement <codeph>netStatus</codeph> avec la propriété <codeph>code</codeph> <codeph>SharedObject.Flush.Success</codeph>. Si l’utilisateur sélectionne Refuser, le serveur enregistre l’objet partagé et distribue un événement <codeph>netStatus</codeph> avec la propriété <codeph>code</codeph> <codeph>SharedObject.Flush.Failed</codeph>. 
 </p>
 
 </apiDesc><example conref="examples\SharedObjectExample.as"> Le code suivant crée (et lors des ses prochaines exécutions, récupère) un objet partagé en utilisant l’ID <codeph>"application-name"</codeph>. Lorsqu’un utilisateur clique sur le bouton Enregistrer, la méthode <codeph>saveValue()</codeph> tente d’enregistrer une propriété appelée <codeph>savedValue</codeph> dans la propriété <codeph>data</codeph> de l’objet SharedObject. Si Flash Player doit demander l’autorisation d’enregistrer les données, la méthode<codeph>onFlushStatus()</codeph> est appelée lorsque l’utilisateur accorde ou refuse l’opération. Lorsqu’un utilisateur clique sur le bouton Effacer, la méthode <codeph>clearValue()</codeph> efface la valeur enregistrée dans <codeph>savedValue</codeph>. Au prochain chargement du fichier SWF, la valeur<codeph>undefined</codeph> est récupérée.
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.events.NetStatusEvent;
    import flash.net.SharedObject;
    import flash.net.SharedObjectFlushStatus;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFieldType;
    
    public class SharedObjectExample extends Sprite {
        
        private var mySo:SharedObject;
        
        public function SharedObjectExample() {
            buildUI();
            saveBtn.addEventListener(MouseEvent.CLICK, saveValue);
            clearBtn.addEventListener(MouseEvent.CLICK, clearValue);
            
            mySo = SharedObject.getLocal("application-name");
            output.appendText("SharedObject loaded...\n");
            output.appendText("loaded value: " + mySo.data.savedValue + "\n\n");
        }

         private function saveValue(event:MouseEvent):void {
            output.appendText("saving value...\n");
            mySo.data.savedValue = input.text;
            
            var flushStatus:String = null;
            try {
                flushStatus = mySo.flush(10000);
            } catch (error:Error) {
                output.appendText("Error...Could not write SharedObject to disk\n");
            }
            if (flushStatus != null) {
                switch (flushStatus) {
                    case SharedObjectFlushStatus.PENDING:
                        output.appendText("Requesting permission to save object...\n");
                        mySo.addEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
                        break;
                    case SharedObjectFlushStatus.FLUSHED:
                        output.appendText("Value flushed to disk.\n");
                        break;
                }
            }
            output.appendText("\n");
        }
        
        private function clearValue(event:MouseEvent):void {
            output.appendText("Cleared saved value...Reload SWF and the value should be \"undefined\".\n\n");
            delete mySo.data.savedValue;
        }
        
        private function onFlushStatus(event:NetStatusEvent):void {
            output.appendText("User closed permission dialog...\n");
            switch (event.info.code) {
                case "SharedObject.Flush.Success":
                    output.appendText("User granted permission -- value saved.\n");
                    break;
                case "SharedObject.Flush.Failed":
                    output.appendText("User denied permission -- value not saved.\n");
                    break;
            }
            output.appendText("\n");

            mySo.removeEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
        }
        
        // UI elements
        private var inputLbl:TextField;
        private var input:TextField;
        private var output:TextField;
        private var saveBtn:Sprite;
        private var clearBtn:Sprite;
    
        private function buildUI():void {
            // input label
            inputLbl = new TextField();
            addChild(inputLbl);
            inputLbl.x = 10;
            inputLbl.y = 10;
            inputLbl.text = "Value to save:";
            
            // input TextField
            input = new TextField();
            addChild(input);
            input.x = 80;
            input.y = 10;
            input.width = 100;
            input.height = 20;
            input.border = true;
            input.background = true;
            input.type = TextFieldType.INPUT;
            
            // output TextField
            output = new TextField();
            addChild(output);
            output.x = 10;
            output.y = 35;
            output.width = 250;
            output.height = 250;
            output.multiline = true;
            output.wordWrap = true;
            output.border = true;
            output.background = true;
            
            // Save button
            saveBtn = new Sprite();
            addChild(saveBtn);
            saveBtn.x = 190;
            saveBtn.y = 10;
            saveBtn.useHandCursor = true;
            saveBtn.graphics.lineStyle(1);
            saveBtn.graphics.beginFill(0xcccccc);
            saveBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var saveLbl:TextField = new TextField();
            saveBtn.addChild(saveLbl);
            saveLbl.text = "Save";
            saveLbl.selectable = false;
            
            // Clear button
            clearBtn = new Sprite();
            addChild(clearBtn);
            clearBtn.x = 230;
            clearBtn.y = 10;
            clearBtn.useHandCursor = true;
            clearBtn.graphics.lineStyle(1);
            clearBtn.graphics.beginFill(0xcccccc);
            clearBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var clearLbl:TextField = new TextField();
            clearBtn.addChild(clearLbl);
            clearLbl.text = "Clear";
            clearLbl.selectable = false;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link><link href="flash.net.xml#SharedObject/event:netStatus"><linktext>netStatus</linktext></link></related-links><adobeApiEvent id="flash.net:SharedObject_flash.events.SyncEvent.SYNC_sync"><apiName>sync</apiName><shortdesc>
 Distribué lorsqu’un objet partagé distant a été mis à jour par le serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SyncEvent.SYNC</apiEventType><adobeApiEventClassifier>flash.events.SyncEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet partagé distant a été mis à jour par le serveur.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Distribué lorsqu’une occurrence de SharedObject publie son état ou signale une erreur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une occurrence de SharedObject publie son état ou signale une erreur. L’événement <codeph>netStatus</codeph> renferme une propriété <codeph>info</codeph>, composée d’un objet d’informations contenant des renseignements spécifiques sur l’événement, telles que la réussite ou l’échec d’une tentative de connexion ou la réussite de l’écriture de l’objet partagé dans le disque dur local. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:SharedObject:clear"><apiName>clear</apiName><shortdesc>
     Dans le cas d’un objet partagé local, cette méthode purge toutes les données et supprime l’objet du disque.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.clear, clear
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Dans le cas d’un objet partagé local, cette méthode purge toutes les données et supprime l’objet du disque. La référence à l’objet partagé reste active, mais ses propriétés data sont effacées.
     
     <p>
     Pour les objets partagés distants utilisés avec Flash Media Server, <codeph>clear()</codeph> déconnecte l’objet et purge toutes ses données. Si l’objet partagé est persistant localement, cette méthode le supprime également du disque. La référence à l’objet partagé reste active, mais ses propriétés data sont effacées.
     </p>
      
     
     </apiDesc><example conref="examples\SharedObject_clear.as"> Le code suivant crée (et lors des ses prochaines exécutions, récupère) un objet SharedObject en utilisant l’ID <codeph>hostName</codeph>. Une propriété appelée <codeph>username</codeph> est ajoutée à la propriété data de l’objet SharedObject. La méthode <codeph>clear()</codeph> qui est appelée pour finir, efface toutes les informations ajoutées à l’objet data (dans ce cas, une propriété appelée <codeph>username</codeph>).
<codeblock>

package {
    import flash.net.SharedObject;

    public class SharedObject_clear {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_clear() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            if(mySo.data.username == null) {
                mySo.data.username = username;
                trace("set: " + mySo.data.username); // yourUsername
            }
            else {
                mySo.clear();
                trace("cleared: " + mySo.data.username); // undefined
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:close"><apiName>close</apiName><shortdesc>
     Ferme la connexion entre un objet partagé distant et le serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Ferme la connexion entre un objet partagé distant et le serveur. Si un objet partagé distant est persistant localement, l’utilisateur peut modifier la copie locale de l’objet après l’appel de cette méthode. Toute modification apportée à l’objet local est envoyée au serveur à la prochaine connexion de l’utilisateur à l’objet partagé distant.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:connect"><apiName>connect</apiName><shortdesc>
     Se connecte à un objet partagé distant sur un serveur par l’intermédiaire d’un objet NetConnection spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: On FMS, can connect to a shared object, but cannot pass a message as a second param.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Flash Player n’a pas réussi à se connecter à l’objet partagé distant spécifié. Assurez-vous que l’occurrence de NetConnection est valide et connectée, et que l’objet partagé distant a été créé sur le serveur.
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>myConnection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>Objet NetConnection qui utilise le protocole RTMP (Real-Time Messaging Protocol), tel qu’un objet NetConnection utilisé pour communiquer avec Flash Media Server.
     
     </apiDesc></apiParam><apiParam><apiItemName>params</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chaîne définissant le message à transmettre à l’objet partagé distance sur le serveur. Ne peut pas être utilisé avec Flash Media Server.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Se connecte à un objet partagé distant sur un serveur par l’intermédiaire d’un objet NetConnection spécifié. Utilisez cette méthode après un appel à <codeph>getRemote()</codeph>. Lorsque la connexion est réussie, l’événement <codeph>sync</codeph> est distribué.
     
     <p>Avant de tenter d’utiliser un objet partagé distant, commencez par vérifier la présence d’erreurs éventuelles à l’aide d’une instruction <codeph>try..catch..finally</codeph>. Ensuite, écoutez et gérez l’événement <codeph>sync</codeph> avant de modifier l’objet partagé. Toute modification effectuée localement, avant la distribution de l’événement <codeph>sync</codeph>, peut être perdue.
     </p>
     
     <p>
     Appelez la méthode <codeph>connect()</codeph> pour vous connecter à un objet partagé distant, par exemple :
     </p>
     
	 <codeblock platform="actionscript">
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", myNC.uri, false);
     myRemoteSO.connect(myNC);
     </codeblock>
     
	 <codeblock platform="javascript">
	 var myRemoteSO = air.SharedObject.getRemote("mo", myNC.uri, false);
	 myRemoteSO.connect(myNC);
	 </codeblock>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link><link href="flash.net.xml#SharedObject/event:sync"><linktext>sync</linktext></link><link href="../../statements.html#try..catch..finally"><linktext>try..catch..finally</linktext></link><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:flush"><apiName>flush</apiName><shortdesc>
     Ecrit immédiatement un objet partagé persistant localement dans un fichier local.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.flush, flush
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Flash Player ne peut pas écrire l’objet partagé sur le disque. Cette erreur est susceptible de se produire si l’utilisateur a interdit définitivement le stockage des informations locales pour les objets de ce domaine.
      
     
     <p><b>Remarque :</b> un contenu local peut toujours écrire sur un disque des objets partagés en provenance de domaines tiers (autres que celui de la barre d’adresse actuelle du navigateur), même s’il est interdit à un domaine tiers d’écrire des objets partagés sur un disque.</p>
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>L’une des valeurs suivantes :
     <ul>
     <li><codeph>SharedObjectFlushStatus.PENDING</codeph> : l’utilisateur a autorisé l’enregistrement des informations locales pour les objets de ce domaine, mais l’espace affecté est insuffisant pour enregistrer l’objet. Flash Player invite l’utilisateur à affecter davantage d’espace. Pour laisser croître l’espace de l’objet partagé lorsqu’il est enregistré, et éviter ainsi le renvoi de la valeur <codeph>SharedObjectFlushStatus.PENDING</codeph>, transmettez une valeur pour <codeph>minDiskSpace</codeph>.
     </li>
     
     <li><codeph>SharedObjectFlushStatus.FLUSHED</codeph> : l’objet partagé a bien été écrit dans un fichier du disque local.</li>
     </ul>
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>minDiskSpace</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Quantité minimale d’espace disque, en octets, à allouer à cet objet.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ecrit immédiatement un objet partagé persistant localement dans un fichier local. Si vous n’utilisez pas cette méthode, Flash écrit l’objet partagé dans un fichier lorsque la session d’objet partagé se termine, c’est-à-dire lorsque le fichier SWF est fermé, lorsque l’objet partagé est effacé par l’outil de nettoyage de la mémoire car il n’est plus associé à aucune référence ou lorsque vous appelez <codeph>SharedObject.clear()</codeph> ou <codeph>SharedObject.close()</codeph>. 
     
     <p>Si cette méthode renvoie <codeph>SharedObjectFlushStatus.PENDING</codeph>, Flash Player ouvre une boîte de dialogue demandant à l’utilisateur d’augmenter la quantité d’espace disque disponible pour les objets de ce domaine. Pour ménager un espace permettant à la taille de l’objet partagé de croître lors d’un enregistrement ultérieur, évitant ainsi des valeurs renvoyées de <codeph>PENDING</codeph>, transmettez une valeur à <codeph>minDiskSpace</codeph>. Lorsque Flash Player tente d’écrire le fichier, il recherche le nombre d’octets transmis à <codeph>minDiskSpace</codeph> plutôt que l’espace nécessaire à l’enregistrement de l’objet partagé à sa taille actuelle. </p>
     
     <p>Par exemple, si vous pensez qu’un objet partagé atteindra une taille maximale de 500 octets, même s’il est au départ beaucoup plus petit, transmettez 500 à <codeph>minDiskSpace</codeph>. Le cas échéant, Flash demandera à l’utilisateur d’affecter 500 octets d’espace disque à l’objet partagé. Une fois que l’utilisateur affecte l’espace nécessaire, Flash ne demande pas davantage d’espace lors des prochaines tentatives de purge de l’objet (tant que sa taille ne dépasse pas les 500 octets). </p>
     
     <p>Une fois que l’utilisateur a répondu dans la boîte de dialogue, cette méthode est de nouveau appelée. Un événement <codeph>netStatus</codeph> est distribué avec une propriété <codeph>code</codeph> <codeph>SharedObject.Flush.Success</codeph> ou <codeph>SharedObject.Flush.Failed</codeph>.
     </p>
     
     </apiDesc><example conref="examples\SharedObject_flush.as"> Le code suivant crée (et lors des ses prochaines exécutions, récupère) un objet SharedObject en utilisant l’ID <codeph>hostName</codeph>. Une propriété appelée <codeph>username</codeph> est ajoutée à la propriété data de l’objet SharedObject. La méthode <codeph>flush()</codeph> est appelée. Une vérification détermine ensuite si la chaîne <codeph>pending</codeph> ou une valeur booléenne <codeph>true</codeph> ou <codeph>false</codeph> a été renvoyée. N’oubliez pas que toutes les occurrences ouvertes de SharedObject sont automatiquement purgées à la fermeture de l’occurrence actuelle de Flash Player.
<codeblock>
package {
    import flash.net.SharedObject;

    public class SharedObject_flush {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_flush() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            mySo.data.username = username;
            var flushResult:Object = mySo.flush();
            trace("flushResult: " + flushResult);
            trace(mySo.data.username); // yourUsername
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/clear()"><linktext>clear()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:getLocal"><apiName>getLocal</apiName><shortdesc>
  Renvoie une référence à un objet partagé persistant localement qui est disponible uniquement pour le client actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, constructor, SharedObject.getLocal, getLocal, get
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Flash Player ne peut pas créer l’objet partagé pour une raison quelconque. Cette erreur est susceptible de se produire si la création d’objets partagés persistants et le stockage de contenu Flash en provenance de tiers sont interdits (ceci ne s’applique pas au contenu local). Les utilisateurs peuvent interdire les objets partagés persistants de tiers dans le panneau Paramètres globaux d’enregistrement du Gestionnaire de paramètres, situé à l’adresse <xref href="http://www.adobe.com/support/documentation/fr/flashplayer/help/settings_manager03.html" scope="external">http://www.adobe.com/support/documentation/fr/flashplayer/help/settings_manager03.html</xref>.
  
  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Référence à un objet partagé qui est persistant localement et disponible uniquement pour le client actuel. Si Flash Player ne peut pas créer ni localiser l’objet partagé (par exemple, si <codeph>localPath</codeph> a été spécifié mais que son répertoire n’existe pas), cette méthode renvoie une exception.
  
  </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’objet. Le nom peut comporter des barres obliques (<codeph>/</codeph>) ; par exemple, <codeph>work/addresses</codeph> est un nom admissible. Les espaces ne sont pas autorisés dans un nom d’objet partagé, ainsi que les caractères suivants :   
  <pre>
  ~ % &amp; \ ; : " ' , &lt; > ? # 
  </pre>
  
  </apiDesc></apiParam><apiParam><apiItemName>localPath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Chemin complet ou partiel du fichier SWF qui a créé l’objet partagé, et qui détermine l’endroit où l’objet partagé sera stocké localement. Si vous omettez ce paramètre, le chemin complet est utilisé. 
   
  </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Détermine si l’accès à cet objet partagé est limité aux fichiers SWF reçus via une connexion HTTPS. Si votre fichier SWF est reçu via HTTPS, la valeur de ce paramètre a les effets suivants :
  <ul>
  <li>Si ce paramètre est défini sur <codeph>true</codeph>, Flash Player crée un nouvel objet partagé sécurisé ou obtient une référence à un objet partagé sécurisé existant. Cet objet sécurisé partagé peut uniquement être lu par des fichiers SWF ou écrit dans des fichiers SWF reçus via des HTTPS appelant <codeph>SharedObject.getLocal()</codeph> avec le paramètre <codeph>secure</codeph> défini sur <codeph>true</codeph>.</li>
  <li>Si ce paramètre est défini sur <codeph>false</codeph>, Flash Player crée un objet partagé ou obtient une référence à un objet partagé existant, qui peut être lu ou écrit par des fichiers SWF reçus via des connexions autres que HTTPS.</li>
  </ul>
  <p>Si votre fichier SWF est reçu via une connexion autre que HTTPS et que vous tentez de définir ce paramètre sur <codeph>true</codeph>, la création d’un nouvel objet partagé (ou l’accès à un objet partagé sécurisé précédemment créé) échoue et <codeph>null</codeph> est renvoyé. Quelle que soit la valeur de ce paramètre, les objets partagés créés sont comptabilisés dans la quantité d’espace disque total autorisée pour un domaine.</p>
  
  <p>Le diagramme suivant indique comment utiliser le paramètre <codeph>secure</codeph> :</p>
  <p><adobeimage alt="Diagramme d’un objet partagé sécurisé" href="../../images/secureParam.jpg"/></p>
  
  </apiDesc></apiParam></apiOperationDef><apiDesc>
  Renvoie une référence à un objet partagé persistant localement qui est disponible uniquement pour le client actuel. Si l’objet partagé n’existe pas encore, cette méthode en crée un. Si des valeurs transmises à <codeph>getLocal()</codeph> sont incorrectes ou si l’appel échoue, Flash Player renvoie une exception.
  
  <p>Le code suivant illustre la procédure d’attribution à une variable de la référence à l’objet partagé renvoyé :</p>
  <p><codeph>var so:SharedObject = SharedObject.getLocal("savedData");</codeph></p>
  
  <p><b>Remarque :</b> si l’utilisateur a choisi de ne jamais autoriser l’enregistrement local pour ce domaine, l’objet n’est pas enregistré localement, même si une valeur est spécifiée pour <codeph>localPath</codeph>. L’exception à cette règle est le contenu local. Un contenu local peut toujours écrire des objets partagés en provenance de domaines tiers sur un disque (domaines autres que celui de la barre d’adresse actuelle du navigateur), même s’il est interdit à un domaine tiers d’écrire des objets partagés sur un disque.
  </p>
  
  <p>Pour éviter les conflits de noms, Flash examine l’emplacement du fichier SWF qui crée l’objet partagé. Par exemple, si un fichier SWF à l’adresse www.myCompany.com/apps/stockwatcher.swf crée un objet partagé nommé <codeph>portfolio</codeph>, cet objet partagé n’entre pas en conflit avec un autre objet nommé <codeph>portfolio</codeph> qui a été créé par un fichier SWF à l’adresse www.yourCompany.com/photoshoot.swf, étant donné que les fichiers SWF proviennent de répertoires différents. </p>
  
  <p>Bien que le paramètre <codeph>localPath</codeph> soit facultatif, vous devez réfléchir à son utilisation, en particulier si les autres fichiers SWF doivent accéder à l’objet partagé. Si les données dans l’objet partagé sont spécifiques à un fichier SWF qui ne sera pas déplacé dans un autre emplacement, l’utilisation de la valeur par défaut prend alors tout son sens. Si d’autres fichiers SWF nécessitent un accès à l’objet partagé ou si le fichier SWF qui crée l’objet partagé est déplacé ultérieurement, la valeur de ce paramètre peut alors affecter l’accessibilité de l’objet partagé. Par exemple, si vous créez un objet partagé en réglant <codeph>localPath</codeph> sur la valeur par défaut du chemin complet du fichier SWF, aucun autre fichier SWF ne pourra accéder à cet objet partagé. Si vous déplacez par la suite le fichier SWF d’origine dans un autre emplacement, il ne pourra plus accéder aux données déjà enregistrées dans l’objet partagé.</p>
  
  <p>Pour éviter de limiter inopinément l’accès à un objet partagé, utilisez le paramètre <codeph>localpath</codeph>. La meilleure option consiste à définir le paramètre <codeph>localPath</codeph> sur <codeph>/</codeph>. Cette opération rend l’objet partagé accessible à tous les fichiers SWF du domaine, mais augmente la probabilité de conflits de noms avec d’autres objets partagés dans ce domaine. Une autre option, plus restrictive, consiste à faire suivre <codeph>localPath</codeph> de noms de dossier figurant dans le chemin complet du fichier SWF. Prenons l’exemple de l’objet partagé <codeph>portfolio</codeph> créé par le fichier SWF à l’adresse www.myCompany.com/apps/stockwatcher.swf. Vous pouvez régler le paramètre <codeph>localPath</codeph> sur <codeph>/</codeph>, <codeph>/apps</codeph> ou <codeph>/apps/stockwatcher.swf</codeph>. Vous devrez identifier l’option qui offre la meilleure flexibilité à votre application.</p>
  
  <p platform="actionscript">Lorsque vous employez cette méthode, tenez compte du modèle de sécurité suivant :
  
  <ul>
  
    <li>Vous ne pouvez pas accéder à des objets partagés en franchissant les limites sandbox.</li>
    <li>Les utilisateurs peuvent limiter l’accès aux objets partagés via la boîte de dialogue Paramètres de Flash Player ou via le Gestionnaire des paramètres. Par défaut, une application peut créer des objets partagés contenant jusqu’à 100 Ko de données par domaine. Les administrateurs et les utilisateurs peuvent également limiter la capacité à écrire dans le système de fichiers.</li>
  </ul></p>
  
  <p platform="actionscript">Imaginons que vous publiez le contenu de fichiers SWF afin qu’il soit lu sous forme de fichiers locaux (fichiers SWF installés localement ou fichiers EXE) et que vous deviez accéder à un objet partagé spécifique à partir de plusieurs fichiers SWF locaux. Dans ce cas, sachez que, pour ce qui est des fichiers locaux, il est possible d’utiliser deux emplacements différents pour le stockage des objets partagés. Le domaine utilisé dépend des autorisations de sécurité accordées au fichier local qui a créé l’objet partagé. Les fichiers locaux peuvent avoir trois niveaux distincts d’autorisation :
  
  <ol>
    <li>Accès au système de fichiers local uniquement</li>
    <li>Accès au réseau uniquement</li>
    <li>Accès au réseau et au système de fichiers local</li>
  </ol></p>
  
  <p platform="actionscript">Les fichiers locaux pouvant accéder au système de fichiers local (niveau 1 ou 3) stockent leurs objets partagés à un emplacement unique. Les fichiers locaux ne pouvant pas accéder au système de fichiers local (niveau 2) stockent leurs objets partagés dans un autre emplacement.</p>
  
  <p platform="actionscript">Vous pouvez empêcher un fichier SWF d’utiliser cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui comporte le contenu SWF.</p>
  
  <p platform="actionscript">Pour plus d’informations, voir les références suivantes :
  
  <ul>
    <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
    <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
    <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
  </ul></p>
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:getRemote"><apiName>getRemote</apiName><shortdesc>
     Renvoie une référence à un objet partagé sur Flash Media Server auquel plusieurs clients peuvent accéder.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Flash Player ne peut pas créer ni localiser l’objet partagé. Cette situation peut se produire si les paramètres <codeph>remotePath</codeph> et <codeph>persistence</codeph> ont été réglés sur des chemins inexistants.
     
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Référence à un objet pouvant être partagé entre plusieurs clients.
     
     </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de l’objet partagé distant. Le nom peut comporter des barres obliques (); par exemple, work/addresses est un nom admissible. Les espaces ne sont pas autorisés dans un nom d’objet partagé, ainsi que les caractères suivants :
     <pre>    ~ % &amp; \ ; :  " ' , > ? ? #</pre>
     
     </apiDesc></apiParam><apiParam><apiItemName>remotePath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>URI du serveur sur lequel sera stocké l’objet partagé. Cette URI doit être identique à celle de l’objet NetConnection transmis à la méthode <codeph>connect()</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>persistence</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si les attributs des propriétés data de l’objet partagé sont persistants localement et/ou à distance. Ce paramètre peut également indiquer l’emplacement de stockage local de l’objet partagé. Les valeurs possibles sont les suivantes :
     <ul><li>La valeur <codeph>false</codeph> indique que l’objet partagé n’est pas persistant dans le client ou le serveur.</li>
     <li>La valeur <codeph>true</codeph> indique que l’objet partagé est persistant dans le serveur uniquement.</li>
     <li>Un chemin d’accès local partiel ou complet à l’objet partagé indique que ce dernier est persistant dans le client et le serveur. Dans le client, il est stocké dans le chemin spécifié. Sur le serveur, il est stocké dans un sous-répertoire du répertoire de l’application.</li>
     </ul>
     
     <p><b>Remarque :</b> si l’utilisateur a choisi de ne jamais autoriser l’enregistrement local pour ce domaine, l’objet n’est pas enregistré localement, même si un chemin local est spécifié à des fins de persistance. Pour plus d’informations, voir la description de la classe.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Détermine si l’accès à cet objet partagé est limité aux fichiers SWF reçus via une connexion HTTPS. Pour plus d’informations, voir la description du paramètre <codeph>secure</codeph> dans la section consacrée à la méthode <codeph>getLocal</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Renvoie une référence à un objet partagé sur Flash Media Server auquel plusieurs clients peuvent accéder. Si l’objet partagé distant n’existe pas encore, cette méthode en crée un. 
     
     <p>
     Pour créer un objet partagé distant, appelez <codeph>getRemote()</codeph>, puis <codeph>connect()</codeph> pour connecter l’objet partagé distant au serveur, comme suit :</p>
     
	 <codeblock platform="actionscript">
     var nc:NetConnection = new NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
     
	 <codeblock platform="javascript">
     var nc = new air.NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
	 
     <p>
     Pour confirmer la synchronisation des copies locale et distante de l’objet partagé, écoutez et gérez l’événement <codeph>sync</codeph>. Tous les clients qui souhaitent partager cet objet doivent transmettre les mêmes valeurs pour les paramètres <codeph>name</codeph> et <codeph>remotePath.</codeph> 
     </p> 
     
     <p>Pour créer un objet partagé accessible au client actuel uniquement, utilisez <codeph>SharedObject.getLocal()</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:send"><apiName>send</apiName><shortdesc>
     Diffuse un message à tous les clients connectés à l’objet partagé distant, y compris au client qui a envoyé le message.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Needs better documentation, examples.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Un ou plusieurs arguments : chaîne identifiant le message, le nom d’une ou de plusieurs fonctions de gestionnaire à joindre à l’objet partagé et des paramètres facultatifs de tout type. Le nom du gestionnaire ne peut avoir qu’un seul niveau (autrement dit, il ne peut pas être au format parent/enfant) et est relatif à l’objet partagé. Les arguments sont sérialisés et envoyés via la connexion, et le gestionnaire de destination les reçoit dans le même ordre. Si un paramètre représente un objet circulaire (une liste liée qui est circulaire, par exemple), l’utilitaire de sérialisation gère correctement les références.
     
     <p><b>Remarque</b> : n’utilisez pas un terme réservé comme nom de fonction. <codeph>myRemoteSO.send("close")</codeph>, par exemple, se soldera par un échec.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Diffuse un message à tous les clients connectés à l’objet partagé distant, y compris au client qui a envoyé le message. Pour traiter le message et y répondre, créez une fonction de rappel associée à l’objet partagé.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:setDirty"><apiName>setDirty</apiName><shortdesc>
     Indique au serveur que la valeur d’une propriété a changé dans l’objet partagé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The AS2 player automatically marks properties dirty as they are changed.
          The FMS server, however, requires an explicit setProperty() call to indicate when a property
          of data has changed.
     
          AS3 does not support auto-dirtying the properties, so we are introducing setDirty() to explicitly
          indicate when a property has changed, and setProperty() to match the method provided with the server.
     
          It's probably best to read the FMS Actionscript reference (search for SharedObject.setProperty at
          www.adobe.com) before writing this documentation, as the details should be similar.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la propriété qui a changé.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Indique au serveur que la valeur d’une propriété a changé dans l’objet partagé. Cette méthode marque les propriétés comme <i>dirty</i>, ce qui signifie qu’elles ont été modifiées.
     
     <p>
     Pour créer les propriétés d’un objet partagé, appelez <codeph>SharedObject.setProperty()</codeph>. 
     </p>
      
     <p>
     La méthode <codeph>SharedObject.setProperty()</codeph> implémente <codeph>setDirty()</codeph>. Dans la plupart des cas, par exemple lorsque la valeur d’une propriété est de type primitif, comme String ou Number, appelez <codeph>setProperty()</codeph> plutôt que <codeph>setDirty()</codeph>. En revanche, lorsque la valeur d’une propriété est un objet qui contient ses propres propriétés, appelez <codeph>setDirty()</codeph> pour indiquer la modification d’une valeur dans l’objet.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (propriété côté client)</linktext></link><link href="flash.net.xml#SharedObject/setProperty()"><linktext>setProperty()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:setProperty"><apiName>setProperty</apiName><shortdesc>
     Met à jour la valeur d’une propriété dans un objet partagé et indique cette modification au serveur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la propriété de l’objet partagé.
     </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur de la propriété (objet ActionScript) ou <codeph>null</codeph> pour supprimer la propriété. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Met à jour la valeur d’une propriété dans un objet partagé et indique cette modification au serveur. La méthode <codeph>setProperty()</codeph> marque explicitement les propriétés comme modifiées (dirty).
     
     <p>Pour plus d’informations sur les objets partagés distants, voir la <xref href="http://www.adobe.com/go/learn_fms_docs_en">Documentation de Flash Media Server</xref>.</p>
     
     <p><b>Remarque :</b> La méthode <codeph>SharedObject.setProperty()</codeph> implémente la méthode <codeph>setDirty()</codeph>. Dans la plupart des cas, par exemple lorsque la valeur d’une propriété est de type primitif, comme String ou Number, utilisez <codeph>setProperty()</codeph> plutôt que <codeph>setDirty()</codeph>. En revanche, lorsque la valeur de la propriété est un objet qui contient ses propres propriétés, utilisez <codeph>setDirty()</codeph> pour indiquer la modification d’une valeur dans l’objet. De façon générale, il est conseillé d’appeler <codeph>setProperty()</codeph> plutôt que <codeph>setDirty()</codeph>, car <codeph>setProperty()</codeph> ne met à jour la valeur d’une propriété que lorsqu’elle a changé, tandis que <codeph>setDirty()</codeph> impose la synchronisation à tous les clients abonnés.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (propriété côté client)</linktext></link></related-links></apiOperation><apiValue id="flash.net:SharedObject:client:get"><apiName>client</apiName><shortdesc>
     Indique l’objet sur lequel des méthodes de rappel sont appelées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>La propriété <codeph>client</codeph> ne peut pas être réglée sur l’objet null.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indique l’objet sur lequel des méthodes de rappel sont appelées. L’objet par défaut est <codeph>this</codeph>. Si vous réglez la propriété client sur un autre objet, les méthodes de rappels sont appelées sur celui-ci.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:data:get"><apiName>data</apiName><shortdesc>
     Ensemble des attributs affectés à la propriété data de l’objet. Ces attributs peuvent être partagés et stockés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.data, data
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Ensemble des attributs affectés à la propriété <codeph>data</codeph> de l’objet. Ces attributs peuvent être partagés et stockés. Chaque attribut peut être un objet d’un quelconque type ActionScript ou JavaScript : tableau, nombre, valeur booléenne, ByteArray, XML, etc. Par exemple, les lignes suivantes affectent des valeurs à différents aspects d’un objet partagé :
     
	 <codeblock platform="actionscript">
     var items_array:Array = new Array(101, 346, 483);
     var currentUserIsAdmin:Boolean = true;
     var currentUserName:String = "Ramona";
     
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.data.itemNumbers = items_array;
     my_so.data.adminPrivileges = currentUserIsAdmin;
     my_so.data.userName = currentUserName;
     
     for (var prop in my_so.data) {
       trace(prop+": "+my_so.data[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var items_array = new Array(101, 346, 483);
	 var currentUserIsAdmin = true;
	 var currentUserName = "Ramona";
	 
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.data.itemNumbers = items_array;
	 my_so.data.adminPrivileges = currentUserIsAdmin;
	 my_so.data.userName = currentUserName;
	 
	 for (var prop in my_so.data) {
	   trace(prop+": "+my_so.data[prop]);
	 }
	 </codeblock>
     
     <p>Tous les attributs de la propriété <codeph>data</codeph> d’un objet partagé sont enregistrés si l’objet est persistant, et l’objet partagé contient les informations suivantes :</p>
     
     <codeblock>
     userName: Ramona
     adminPrivileges: true
     itemNumbers: 101,346,483
     </codeblock>
     
     <p><b>Remarque :</b> n’affectez pas directement de valeurs à la propriété <codeph>data</codeph> d’un objet partagé, tel que dans <codeph>so.data = someValue</codeph> car Flash Player ignore ces affectations.</p>
     
     <p>Pour supprimer des attributs pour des objets partagés locaux, utilisez un code tel que <codeph>delete so.data.attributeName</codeph>. La définition d’un attribut sur <codeph>null</codeph> ou <codeph>undefined</codeph> pour un objet partagé local ne supprime pas l’attribut.</p>
     
     <p>Pour créer des valeurs <i>privées</i> pour un objet partagé, valeurs qui ne sont disponibles que pour l’occurrence du client alors que l’objet est utilisé et qui ne sont pas enregistrées avec l’objet lorsqu’il est fermé, créez des propriétés qui ne sont pas nommées <codeph>data</codeph> pour les enregistrer, comme l’illustre l’exemple suivant :</p>
     
	 <codeblock platform="actionscript">
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.favoriteColor = "blue";
     my_so.favoriteNightClub = "The Bluenote Tavern";
     my_so.favoriteSong = "My World is Blue";
     
     for (var prop in my_so) {
       trace(prop+": "+my_so[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.favoriteColor = "blue";
	 my_so.favoriteNightClub = "The Bluenote Tavern";
	 my_so.favoriteSong = "My World is Blue";
	 
	 for (var prop in my_so) {
	   trace(prop+": "+my_so[prop]);
	 }
	 </codeblock>
     
     <p>L’objet partagé contient les données suivantes :</p>
     <codeblock>
     favoriteSong: My World is Blue
     favoriteNightClub: The Bluenote Tavern
     favoriteColor: blue
     data: [object Object]
     </codeblock>
     
     <p>
     Dans le cas d’objets partagés distants utilisés avec un serveur, tous les attributs de la propriété <codeph>data</codeph> sont accessibles à tous les clients connectés à l’objet partagé, et tous les attributs sont enregistrés si l’objet est persistant. Lorsqu’un client modifie la valeur d’un attribut, tous les clients voient ensuite la nouvelle valeur.
     </p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
     Encodage d’objet par défaut (version AMF) de tous les objets partagés locaux créés dans le fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Encodage d’objet par défaut (version AMF) de tous les objets partagés locaux créés dans le fichier SWF. Lorsque les objets partagés locaux sont écrits sur le disque, la propriété <codeph>SharedObject.defaultObjectEncoding</codeph> indique la version AMF (Action Message Format) devant être utilisée : format ActionScript 3.0 (AMF3) ou format ActionScript 1.0 ou 2.0 (AMF0).
     
     <p>Pour plus d’informations sur l’encodage des objets, y compris sur les différences d’encodage des objets partagés selon qu’ils sont locaux ou distants, voir la description de la propriété <codeph>objectEncoding</codeph>.</p>
     
     <p>La valeur par défaut de <codeph>SharedObject.defaultObjectEncoding</codeph> stipule l’utilisation du format ActionScript 3.0 (AMF3). Pour écrire des objets partagés locaux qui doivent être lus par des fichiers SWF ActionScript 2.0 ou 1.0, réglez <codeph>SharedObject.defaultObjectEncoding</codeph> sur <codeph>flash.net.ObjectEncoding.AMF0</codeph> afin qu’elle utilise le format ActionScript 1.0 ou ActionScript 2.0, au début de votre script, avant de créer les objets. Tous les objets partagés locaux créés ultérieurement utiliseront l’encodage AMF0 et pourront interagir avec du contenu plus ancien. Après la création des objets partagés locaux, il est impossible de modifier leur valeur <codeph>objectEncoding</codeph> correspondante en définissant <codeph>SharedObject.defaultObjectEncoding</codeph>.</p>
     
     <p>Pour configurer l’encodage objet par objet, plutôt que pour la totalité des objets partagés créés par le fichier SWF, définissez la propriété <codeph>objectEncoding</codeph> de l’objet concerné.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/objectEncoding"><linktext>Propriété objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>Classe ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Encodage d’objet (version AMF) de cet objet partagé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Vous avez tenté de définir la valeur de la propriété <codeph>objectEncoding</codeph> pour un objet partagé distant. Cette propriété est en lecture seule pour les objets partagés distants car sa valeur est déterminée par l’occurrence de NetConnection associée.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Encodage d’objet (version AMF) de cet objet partagé. Lors de l’écriture d’un objet partagé local sur le disque, la propriété <codeph>objectEncoding</codeph> indique la version AMF (Action Message Format) devant être utilisée : format ActionScript 3.0 (AMF3) ou format ActionScript 1.0 ou 2.0 (AMF0). 
     
     <p>L’encodage d’objet est géré différemment selon que l’objet partagé est local ou distant.</p>
     <ul>
     <li><b>Objets partagés locaux</b>. Vous pouvez extraire ou définir la valeur de la propriété <codeph>objectEncoding</codeph> des objets partagés locaux. La valeur de la propriété <codeph>objectEncoding</codeph> a une incidence sur le formatage utilisé pour <i>écrire</i> l’objet local partagé. Si l’objet local partagé doit pouvoir être lu par des fichiers SWF ActionScript 2.0 ou 1.0, réglez <codeph>objectEncoding</codeph> sur <codeph>ObjectEncoding.AMF0</codeph>. Flash Player peut lire les objets partagés locaux AMF0 même si l’encodage d’objet écrit au format AMF3. En d’autres termes, si vous utilisez la valeur par défaut de cette propriété, <codeph>ObjectEncoding.AMF3</codeph>, votre fichier SWF peut néanmoins lire les objets partagés créés par les fichiers ActionScript 2.0 ou 1.0.
     </li>
     
     <li><b>Objets partagés distants</b>. Lorsqu’il est connecté au serveur, un objet partagé distant hérite de son paramètre <codeph>objectEncoding</codeph> de l’occurrence de NetConnection associée (utilisée pour la connexion à l’objet partagé distant). Lorsqu’il n’est pas connecté au serveur, un objet partagé distant hérite du paramètre <codeph>defaultObjectEncoding</codeph> de l’occurrence de NetConnection associée. Comme la valeur de la propriété <codeph>objectEncoding</codeph> de l’objet partagé distant est déterminée par l’occurrence de NetConnection, cette propriété est en lecture seule pour les objets partagés distants.
     </li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:size:get"><apiName>size</apiName><shortdesc>
     Taille actuelle de l’objet partagé, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.getSize, getSize
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Taille actuelle de l’objet partagé, en octets.
     
     <p>Flash calcule la taille d’un objet partagé en examinant toutes ses propriétés data ; plus un objet a de propriétés data, plus l’estimation de sa taille prend du temps. L’estimation de la taille de l’objet peut monopoliser beaucoup de temps de traitement. Il est donc recommandé d’éviter cette méthode à moins d’en avoir réellement besoin.</p>
     
     </apiDesc><example conref="examples\SharedObject.size.1.as"> Le code suivant crée un objet SharedObject en utilisant l’ID <codeph>"thehobbit"</codeph>. Une propriété appelée <codeph>username</codeph> est ajoutée à la propriété data de l’objet SharedObject. Le code assure ensuite le suivi de la propriété <codeph>size</codeph>, ce qui a pour effet de renvoyer la valeur indiquée.
<codeblock>

import flash.net.SharedObject;

// if these get copied or not
var mySo:SharedObject = SharedObject.getLocal("thehobbit");
mySo.data.username = "bilbobaggins";
trace(mySo.size); // 55
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:fps:set"><apiName>fps</apiName><shortdesc>
     Indique la fréquence, en secondes, d’envoi au serveur des modifications apportées à un client.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: The info is relevant for Flash Media Server, but not Flex.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Indique la fréquence, en secondes, d’envoi au serveur des modifications apportées à un client. 
     
     <p>Cette méthode vous permet de contrôler le trafic entre le client et le serveur. Si la connexion entre le client et le serveur est relativement lente, par exemple, réglez <codeph>fps</codeph> sur une valeur peu élevée. Inversement, si le client est connecté à une application multi-utilisateurs et que la vitesse des échanges est primordiale, réglez <codeph>fps</codeph> sur une valeur relativement élevée.</p>
     
     <p>La définition de <codeph>fps</codeph> déclenchera un événement <codeph>sync</codeph> et actualisera toutes les modifications sur le serveur. Pour actualiser le serveur manuellement, définissez <codeph>fps</codeph> sur 0.</p>
     
     <p>Les modifications ne sont envoyées au serveur qu’après la diffusion de l’événement <codeph>sync</codeph>. En d’autres termes, si le serveur réagit lentement, l’envoi des mises à jour risque d’être moins fréquent que ne le spécifie la valeur de cette propriété. </p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoaderDataFormat"><apiName>URLLoaderDataFormat</apiName><shortdesc>
 La classe URLLoaderDataFormat fournit des valeurs qui déterminent le mode de réception des données téléchargées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe URLLoaderDataFormat fournit des valeurs qui déterminent le mode de réception des données téléchargées.
 
 </apiDesc><example conref="examples\URLLoaderDataFormatExample.as"> L’exemple suivant utilise la classe URLLoaderDataFormatExample pour afficher le format de données et l’état d’un fichier chargé à l’exécution. Pour ce faire, exécutez la procédure suivante :
 <ol>
  <li>Le constructeur de classe crée une occurrence d’URLLoader nommée <codeph>loader</codeph> et une occurrence d’URLRequest nommée <codeph>request</codeph>, correspondant à l’emplacement et au nom du fichier à charger.</li>
  <li>L’objet <codeph>loader</codeph> est transmis à la méthode <codeph>configureListeners()</codeph>, qui ajoute des écouteurs à chacun des événements URLLoader pris en charge :
  <ul>
      <li><codeph>completeHandler()</codeph> : détecte l’événement <codeph>complete</codeph>, distribué après le chargement réussi de TextFile.txt.</li>
      <li><codeph>openHandler()</codeph> : détecte l’événement <codeph>open</codeph>, distribué au démarrage du téléchargement (vers le lecteur) de TextFile.txt.</li>
      <li><codeph>progressHandler()</codeph> : détecte les événements <codeph>progress</codeph>, distribués à la réception des données au fur et à mesure du téléchargement.</li>
      <li><codeph>securityErrorHandler()</codeph> : détecte les événements <codeph>securityError</codeph>, distribués en cas d’accès au fichier texte au moyen d’un paramètre de sécurité de lecture locale incorrect.</li>  
      <li><codeph>httpStatusHandler()</codeph> : détecte les événements <codeph>httpStatusHandler</codeph> qui ne seraient pas distribués dans ce cas, puisque TextFile.txt est un fichier local.</li>
      <li><codeph>ioErrorHandler()</codeph> : détecte les événements <codeph>ioError</codeph>, déclenchés uniquement en cas de problème grave lié au fichier (s’il est manquant, par exemple).</li>  
  </ul></li>
  <li>L’objet <codeph>request</codeph> est ensuite transmis à la méthode <codeph>loader.load()</codeph> qui charge le fichier texte en mémoire à l’aide d’un objet <codeph>DisplayObject</codeph>.</li>
 </ol>
 <p> <b>Remarques :</b>
 <ul>
  <li>Vous devrez compiler le fichier SWF en réglant « Sécurité de lecture locale » sur « Accès aux fichiers locaux uniquement ».
  </li>
  <li>Pour exécuter cet exemple, il est nécessaire de placer un fichier intitulé TextFile.txt dans le même répertoire que votre fichier SWF. Pour que cet exemple identifie des fichiers binaires ou des fichiers de données codés au format URL, vous devez fournir un fichier au format correct et remplacer TextFile.txt par le nom et l’emplacement du nouveau fichier.</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderDataFormatExample extends Sprite {
        private var source:String = "TextFile.txt";
        private var dataFormat:String = URLLoaderDataFormat.TEXT;
        
        public function URLLoaderDataFormatExample () {
            var loader:URLLoader = new URLLoader();
            loader.dataFormat = dataFormat;
            configureListeners(loader);
            var request:URLRequest = new URLRequest(source);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Error loading requested document: " + source);
            }
        }

        private function configureListeners(dispatcher:URLLoader):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            switch(loader.dataFormat) {
                case URLLoaderDataFormat.TEXT :
                    trace("completeHandler (text): " + loader.data);
                    break;
                case URLLoaderDataFormat.BINARY :
                    trace("completeHandler (binary): " + loader.data);
                    break;
                case URLLoaderDataFormat.VARIABLES :
                    trace("completeHandler (variables): " + loader.data);
                    break;
            }
        }

        private function httpStatusHandler(event:Event):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.net:URLLoaderDataFormat:BINARY"><apiName>BINARY</apiName><shortdesc>
	 Indique que les données téléchargées doivent être reçues en tant que données binaires brutes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que les données téléchargées doivent être reçues en tant que données binaires brutes.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:TEXT"><apiName>TEXT</apiName><shortdesc>
	 Indique que les données téléchargées doivent être reçues au format texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que les données téléchargées doivent être reçues au format texte.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:VARIABLES"><apiName>VARIABLES</apiName><shortdesc>
	 Indique que les données téléchargées doivent être reçues en tant que variables de code URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>variables</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que les données téléchargées doivent être reçues en tant que variables de code URL.
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayTransitions"><apiName>NetStreamPlayTransitions</apiName><shortdesc>
 
 La classe NetStreamPlayTransitions spécifie les chaînes valides pouvant être utilisées avec la propriété NetStreamPlayOptions.transition.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 La classe NetStreamPlayTransitions spécifie les chaînes valides pouvant être utilisées avec la propriété NetStreamPlayOptions.transition. Ces chaînes contrôlent le comportement utilisé pour effectuer une transition vers un nouveau flux ou pour lire un flux, selon le mode de transition utilisé.
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links><apiValue id="flash.net:NetStreamPlayTransitions:APPEND"><apiName>APPEND</apiName><shortdesc>
	 
	 Ajoute le flux à une liste de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Ajoute le flux à une liste de lecture. Ce mode est similaire à la méthode <codeph>NetStream.play()</codeph> avec l’indicateur <codeph>reset</codeph> défini sur <codeph>false</codeph>.
	 
	 <p>Dans ce mode, Flash Media Server place en file d’attente le flux spécifié dans <codeph>NetStreamPlayOptions.streamName</codeph> à la fin de la liste de lecture et ignore le paramètre <codeph>NetStreamPlayOptions.oldStreamName</codeph>.</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:RESET"><apiName>RESET</apiName><shortdesc>
	 
	 Efface tout appel de lecture précédent et lit immédiatement le flux spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reset</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Efface tout appel de lecture précédent et lit immédiatement le flux spécifié. Ce mode est similaire à la méthode <codeph>NetStream.play()</codeph> avec l’indicateur <codeph>reset</codeph> défini sur <codeph>true</codeph> (comportement par défaut de <codeph>NetStream.play()</codeph>).
	 
	 <p>Dans ce mode, le flux en cours de lecture est abandonné et la lecture du flux spécifié dans <codeph>NetStreamPlayOptions.streamName</codeph> commence. Le paramètre <codeph>NetStreamPlayOptions.oldStreamName</codeph> est ignoré.</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:STOP"><apiName>STOP</apiName><shortdesc>
	 
	 Arrête la lecture des flux d’une liste de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>stop</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Arrête la lecture des flux d’une liste de lecture. Ce mode est similaire à la méthode <codeph>NetStream.play(false)</codeph>. Il arrête et réinitialise la liste de lecture.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWAP"><apiName>SWAP</apiName><shortdesc>
	 Remplace un flux de contenu par un autre flux de contenu et conserve le reste de la liste de lecture.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>swap</apiData><apiType value=""/></apiValueDef><apiDesc>
	 Remplace un flux de contenu par un autre flux de contenu et conserve le reste de la liste de lecture.
	 
	 <p>Comme <codeph>SWITCH</codeph>, ce mode remplace le flux spécifié dans <codeph>NetStreamPlayOptions.oldStreamName</codeph> par celui spécifié dans <codeph>NetStreamPlayOptions.streamName</codeph>. Le reste de la liste de lecture est conservé. Dans ce mode, Flash Media Server ne fait aucune hypothèse quant au contenu des flux et les traite comme un contenu différent. Si <codeph>oldStreamName</codeph> n’a pas encore été envoyé, le serveur effectue le basculement au niveau de la limite du flux est envoie les bits de <codeph>streamName</codeph> à partir du début. Si le serveur a déjà commencé à envoyer les bits de <codeph>oldStreamName</codeph>, il ne bascule pas sur <codeph>streamName</codeph> et envoie un événement <codeph>NetStream.Play.Failed</codeph>.</p>
	 
	 <p>Utilisez ce mode si les flux entre lesquels vous souhaitez basculer ne sont pas reliés entre eux et si leur contenu ou leurs longueurs diffèrent. La permutation d’une valeur commerciale avec une autre basée sur le suivi des utilisateurs et les statistiques d’affichage des valeurs commerciales passées en est un exemple.</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWITCH"><apiName>SWITCH</apiName><shortdesc>
	 Passe de la lecture d’un flux à un autre, en général entre des flux de même contenu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>switch</apiData><apiType value=""/></apiValueDef><apiDesc>
	 Passe de la lecture d’un flux à un autre, en général entre des flux de même contenu. Spécifiez les flux vers lesquels doit s’effectuer le basculement dans <codeph>NetStreamPlayOptions.oldStreamName</codeph> et <codeph>NetStreamPlayOptions.streamName</codeph>. 
	 
	 <p>Utilisez ce mode lorsque vous souhaitez basculer vers un flux de même contenu, mais codé avec un autre débit ou une autre résolution. Par exemple, utilisez ce mode lorsque l’application place les flux en file d’attente dans une liste de lecture ou lit un flux unique avec un débit particulier, puis s’aperçoit que la disponibilité de la bande passante ou la capacité de traitement est inférieure ou supérieure aux exigences du flux. L’application peut alors actualiser les flux avec leurs versions de débit supérieur ou inférieur.</p>
	 
	 <p>Dans ce mode, Flash Media Server fait des hypothèses quant à la relation entre les flux <codeph>oldStreamName</codeph> et <codeph>streamName</codeph>. Le serveur suppose que les flux contiennent le même contenu et ont le même intervalle d’images-clés mais des résolutions ou des débits différents.</p>
	 
	 <p>Lorsqu’une liste de lecture a été mise en file d’attente et que <codeph>oldStreamName</codeph> est un des flux de la liste de lecture ou est en cours de lecture, <codeph>oldStreamName</codeph> est remplacé par <codeph>streamName</codeph>.</p>
	 
	 <p>Si <codeph>oldStreamName</codeph> est null ou undefined, ou s’il n’est pas détecté dans la liste de lecture, le serveur passe à <codeph>streamName</codeph> au niveau du prochain point logique, pour assurer un basculement transparent.</p>
	 
	 <p>Pour passer d’un flux à un autre de contenu différent, utilisez plutôt le mode <codeph>RESET</codeph>.</p>
	 
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetConnection"><apiName>NetConnection</apiName><shortdesc>
 La classe NetConnection crée une connexion bidirectionnelle entre une application Flash Player ou AIR une application AIR et une application Flash Media Server, ou entre une application Flash Player ou AIR une application AIR et un serveur d’application exécutant Flash Remoting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection, Video, Responder
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe NetConnection crée une connexion bidirectionnelle entre <ph platform="actionscript">une application Flash Player ou AIR</ph> une application <ph platform="javascript">AIR</ph> et une application Flash Media Server, ou entre une application <ph platform="actionscript">Flash Player ou AIR</ph> une <ph platform="javascript">application AIR</ph> et un serveur d’application exécutant Flash Remoting. Un objet NetConnection est similaire à un canal entre le client et le serveur. Utilisez des objets NetStream pour envoyer des flux à travers ce canal. 
 <p>Créez un objet Responder et transmettez-le comme paramètre pour <codeph>NetConnection.call()</codeph> afin de gérer les valeurs renvoyées par le serveur en fonction de la réussite ou de l’échec de certaines opérations.</p>  
 <p>
 Sans Flash Media Server, vous pouvez utiliser la classe NetConnection pour lire des fichiers vidéo et MP3 depuis un système de fichiers local ou un serveur Web.
 </p>
 
 <p>
 Pour plus d’informations sur les codecs et les formats de fichier pris en charge, voir la page <xref href="http://www.adobe.com/go/hardware_scaling_fr" scope="external">http://www.adobe.com/go/hardware_scaling_fr</xref>, ainsi que la <xref href="http://www.adobe.com/support/documentation/fr" scope="external">documentation de Flash Media Server</xref>.
 </p>
 
 <p>Lorsque vous employez la classe NetConnection, tenez compte du modèle de sécurité suivant :</p>
 
 <ul>
 <li>Le chargement et la lecture d’un fichier audio ou vidéo sont interdits si le fichier appelant se trouve sur un sandbox réseau et que le fichier à charger est local.</li>
 
 	<li>Par défaut, le chargement et la lecture d’un fichier audio ou vidéo sont interdits si le fichier appelant est local, et tente de charger et de lire un fichier distant. Pour que cette opération soit possible, un utilisateur doit accorder une autorisation explicite.</li>
 </ul>
 
 <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
 
 <p>Pour plus d’informations, voir les références suivantes :</p>
 
 <ul>
 
 <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 
 <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li> 
 </ul>
 
 
 <p platform="actionscript"><b>Remarque</b> : Cette classe, qui était dynamique dans ActionScript 2.0, est maintenant scellée. Pour écrire des méthodes de rappel pour cette classe, vous pouvez soit étendre celle-ci et définir les méthodes de rappel dans votre sous-classe, soit utiliser la propriété <codeph>client</codeph> pour faire référence à un objet et définir les méthodes de rappel pour cet objet.</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> L’exemple suivant utilise un objet Video avec les classes NetConnection et NetStream pour charger et lire un fichier FLV. Pour exécuter cet exemple, vous avez besoin d’un fichier FLV dont le nom et l’emplacement correspondent avec la variable transmise à <codeph>videoURL</codeph> ; dans ce cas, un fichier FLV appelé Video.flv et stocké dans le même répertoire que le fichier SWF.
 <p>Dans cet exemple, le code qui crée les objets Video et NetStream et appelle les méthodes <codeph>Video.attachNetStream()</codeph> et <codeph>NetStream.play()</codeph> est placé dans une fonction de gestionnaire. Le gestionnaire n’est appelé que si la tentative de connexion à l’objet NetConnection a réussi ; c’est-à-dire lorsque l’événement <codeph>netStatus</codeph> renvoie un objet <codeph>info</codeph> avec une propriété <codeph>code</codeph> qui indique la réussite de l’opération. Il est recommandé d’attendre l’établissement d’une connexion avant d’appeler la méthode <codeph>NetStream.play()</codeph>. </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.net.xml#NetConnection/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Distribué lorsqu’un objet NetConnection publie son état ou signale une erreur. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet NetConnection publie son état ou signale une erreur. L’événement <codeph>netStatus</codeph> renferme une propriété <codeph>info</codeph> composée d’un objet d’informations contenant des informations spécifiques sur l’événement, telles que la réussite ou l’échec d’une tentative de connexion. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Distribué si un appel de NetConnection.call() tente d’établir une connexion à un serveur situé hors du sandbox de sécurité de l’appelant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué si un appel de la méthode <codeph>NetConnection.call()</codeph> tente d’établir une connexion à un serveur situé en dehors du sandbox de sécurité de l’appelant.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Distribué lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération réseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’il se produit une erreur d’entrée ou de sortie entraînant l’échec d’une opération réseau. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’une erreur est renvoyée de manière asynchrone ; autrement dit, lorsqu’elle provient du code asynchrone natif. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:NetConnection:NetConnection"><apiName>NetConnection</apiName><shortdesc>
     Crée un objet NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>See the example for <code>connect()</code>.
     
     </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Crée un objet NetConnection. Appelez <codeph>connect()</codeph> pour établir une connexion.
     
	 <p>Si une application doit communiquer avec des serveurs antérieurs à Flash Player 9, il est possible que vous deviez définir la propriété <codeph>objectEncoding</codeph> de l’objet NetConnection.</p>
     
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>flash.net.NetConnection.connect()</linktext></link><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>objectEncoding</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetConnection:addHeader"><apiName>addHeader</apiName><shortdesc>
     Ajoute un en-tête de contexte à la structure du paquet AMF (Action Message Format).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>IMD: This method can be used in the client Flash Player for Flash Remoting
     and Flex apps. It is also a server side method used by Flash Media Server apps.
     
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Identifie l’en-tête et les données de l’objet ActionScript connexes.
     
     </apiDesc></apiParam><apiParam><apiItemName>mustUnderstand</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>La valeur <codeph>true</codeph> indique que le serveur doit interpréter et traiter cet en-tête avant de gérer tout en-tête ou message suivant.
     </apiDesc></apiParam><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Tout objet ActionScript.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Ajoute un en-tête de contexte à la structure du paquet AMF (Action Message Format). Par la suite, cet en-tête est envoyé avec chaque paquet AMF. Si vous appelez <codeph>NetConnection.addHeader()</codeph> en utilisant le même nom, le nouvel en-tête remplace l’en-tête existant et subsiste pendant toute la durée de l’objet NetConnection. Vous pouvez supprimer un en-tête en appelant <codeph>NetConnection.addHeader()</codeph> avec le nom de l’en-tête pour supprimer un objet non défini.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetConnection:call"><apiName>call</apiName><shortdesc>
     Invoque une commande ou une méthode sur Flash Media Server ou sur un serveur d’application exécutant Flash Remoting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Méthode spécifiée au format <codeph>[objectPath/]method</codeph>. Par exemple, la commande <codeph>someObject/doSomething</codeph> demande au serveur distant d’invoquer la méthode <codeph>clientObject.someObject.doSomething()</codeph> avec tous les paramètres <codeph>... arguments</codeph> facultatifs. Si le chemin de l’objet n’est pas fourni, la méthode <codeph>clientObject.doSomething()</codeph> est invoquée au niveau du serveur distant.
     <p>
     Avec Flash Media Server, <codeph>command</codeph> est le nom d’une fonction définie dans le script côté serveur d’une application. Si le script coté serveur est placé au niveau de la racine du répertoire de l’application, vous n’avez pas besoin d’utiliser un chemin d’objet avant <codeph>command</codeph>.
     </p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiDesc>Objet facultatif utilisé pour gérer les valeurs renvoyées par le serveur. Il est possible de définir deux méthodes pour l’objet Responder afin de gérer le résultat renvoyé : <codeph>result</codeph> et <codeph>status</codeph>. Si une erreur est renvoyée, la méthode <codeph>status</codeph> est appelée ; <codeph>result</codeph> est appelée dans tous les autres cas. Si l’objet Responder est en mesure de traiter les erreurs liées à des opérations spécifiques, l’objet NetConnection répond aux erreurs liées à l’état de connexion.
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Les arguments facultatifs peuvent être de n’importe quel type ActionScript, y compris une référence à un autre objet ActionScript. Lorsque la méthode spécifiée dans le paramètre <codeph>command</codeph> est exécutée sur le serveur d’application distant, ces arguments lui sont transmis.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Invoque une commande ou une méthode sur Flash Media Server ou sur un serveur d’application exécutant Flash Remoting. Avant d’appeler <codeph>NetConnection.call()</codeph>, vous devez appeler <codeph>NetConnection.connect()</codeph> pour vous connecter au serveur. Vous devez créer une fonction côté serveur à transmettre à cette méthode. 
     
      <p>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection:call_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Un appel a tenté de communiquer avec un serveur situé en dehors du sandbox de sécurité de l’appelant. Vous pouvez contourner ce problème en utilisant un fichier de régulation sur le serveur.
     </apiDesc></adobeApiEventDetail><shortdesc>Un appel a tenté d’établir une communication avec un serveur situé hors du sandbox de sécurité de l’appelant.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetConnection:close"><apiName>close</apiName><shortdesc>
     Ferme la connexion ouverte localement ou au serveur et distribue un événement netStatus en réglant la propriété code sur NetConnection.Connect.Closed.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Ferme la connexion ouverte localement ou au serveur et distribue un événement <codeph>netStatus</codeph> en réglant la propriété <codeph>code</codeph> sur <codeph>NetConnection.Connect.Closed</codeph>.
     
     <p>
     Cette méthode déconnecte tous les objets NetStream qui s’exécutent sur la connexion. Toutes les données en attente qui n’ont pas encore été envoyées sont abandonnées (pour clore les flux locaux ou de serveur sans fermer la connexion, utilisez <codeph>NetStream.close()</codeph>). Si vous fermez la connexion et que vous souhaitez ensuite en créer une nouvelle, vous devez créer un nouvel objet NetConnection et rappeler la méthode <codeph>connect()</codeph>.
     </p>
     
     <p>La méthode <codeph>close</codeph> déconnecte également tous les objets partagés distants qui s’exécutent sur la connexion. Vous n’avez toutefois pas besoin de recréer l’objet partagé pour vous reconnecter. Pour rétablir la connexion à l’objet partagé, il vous suffit en effet d’appeler la méthode <codeph>SharedObject.connect()</codeph>. Par ailleurs, les données de l’objet partagé qui étaient en file d’attente lorsque vous avez émis <codeph>NetConnection.close()</codeph> sont envoyées après la reconnexion à l’objet.</p>
     
     <p>
     Avec Flash Media Server, la meilleure pratique de développement consiste à appeler <codeph>close()</codeph> lorsque le client n’a plus besoin de la connexion au serveur. L’appel à <codeph>close()</codeph> est le moyen le plus rapide pour nettoyer les connexions non utilisées. Vous pouvez configurer le serveur pour qu’il ferme automatiquement les connexions inactives comme mesure de sauvegarde. Pour plus d’informations, voir le <i><xref href="http://www.adobe.com/support/documentation/fr" scope="external">Guide d’administration et de configuration de Flash Media Server</xref></i>. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetConnection:connect"><apiName>connect</apiName><shortdesc>
     Crée une connexion bidirectionnelle entre une application Flash Player ou AIR une application AIR et une application Flash Media Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection.connect, connect
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>L’URI transmis au paramètre <codeph>command</codeph> est incorrectement formaté.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>La connexion a échoué. Ce peut être le cas si vous appelez <codeph>connect()</codeph> à partir d’un gestionnaire d’événements <codeph>netStatus</codeph>, ce qui n’est pas autorisé.
     
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Les fichiers locaux avec système de fichiers ne peuvent pas communiquer avec Internet. Pour éviter ce problème, reclassifiez le fichier SWF en tant que fichier local avec accès au réseau ou en tant que fichier approuvé.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Si vous tentez de vous connecter à un port généralement réservé. Vous trouverez la liste complète des ports bloqués au chapitre « Restriction des API de réseau » du manuel <i>Programmation avec ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Définissez ce paramètre sur <codeph>null</codeph> si vous vous connectez à un fichier vidéo sur l’ordinateur local. Dans le cas d’une connexion à un serveur, définissez ce paramètre sur l’URI de l’application qui contient le fichier vidéo sur le serveur. Utilisez la syntaxe suivante (les éléments entre crochets sont facultatifs) :
     
     <p><codeph>protocole:[//hôte][:port]/nomapp[/nomOcc]</codeph></p>
     
     <p>Pour une connexion à Flash Media Server, utilisez le protocole <codeph>rtmp</codeph>, <codeph>rtmpe</codeph>, <codeph>rtmps</codeph>, <codeph>rtmpt</codeph>, <codeph>rtmpte</codeph> ou <codeph>rtmfp</codeph>. Si la connexion est réussie, un événement <codeph>netStatus</codeph> présentant une propriété <codeph>code</codeph> <codeph>NetConnection.Connect.Success</codeph> est renvoyé. Définissez la propriété <codeph>NetStatusEvent.info</codeph> pour la liste de tous les codes d’événement renvoyés en réponse à l’appel <codeph>connect()</codeph>.
     </p>
     
     <p>Si le fichier est desservi par l’hôte dans lequel le serveur est installé, vous pouvez omettre le paramètre <codeph>host</codeph>. Si vous omettez le paramètre <codeph>instanceName</codeph>, <ph platform="actionscript">Flash Player ou </ph>Adobe AIR se connecte à l’occurrence par défaut de l’application.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Paramètres facultatifs de tout type à transmettre à l’application spécifiée dans <codeph>command</codeph>. Avec Flash Media Server, les arguments supplémentaires sont transmis au gestionnaire d’événements <codeph>application.onConnect()</codeph> dans le code côté serveur de l’application. Vous devez définir et gérer les arguments dans <codeph>onConnect()</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Crée une connexion bidirectionnelle entre <ph platform="actionscript">une application Flash Player ou AIR</ph><ph platform="javascript">une application AIR</ph> et une application Flash Media Server. Un objet NetConnection est similaire à un canal entre le client et le serveur. Utilisez des objets NetStream pour envoyer des flux à travers ce canal. Pour plus d’informations sur les codecs et formats des fichiers vidéo pris en charge par Flash Media Server, voir la documentation de <xref href="http://www.adobe.com/support/documentation/fr" scope="external">Flash Media Server</xref>.
     
     <p>
     Sans Flash Media Server, appelez <codeph>NetConnection</codeph> pour lire des fichiers vidéo et MP3 depuis un système de fichiers local ou un serveur Web. Pour plus d’informations sur les codecs et les formats de fichier pris en charge, reportez-vous à l’adresse <xref href="http://www.adobe.com/go/hardware_scaling_fr" scope="external">http://www.adobe.com/go/hardware_scaling_fr</xref>.
     </p>
     
     <p>
     Crée une connexion bidirectionnelles entre <ph platform="actionscript">une application Flash Player ou AIR</ph><ph platform="javascript">une application AIR</ph> et un serveur d’application exécutant le service Flash Remoting. Utilisez la classe NetServices pour appeler des fonctions et renvoyer les résultats des serveurs d’application via un objet NetConnection. Pour plus d’informations, voir la <xref href="http://www.adobe.com/support/documentation/fr" scope="external">documentation de Flash Remoting</xref>. 
     </p>
     
	 <p>Lorsque vous employez cette méthode, tenez compte du modèle de sécurité suivant :</p>
     
     <ul>
      <li>Par défaut, <ph platform="actionscript">Flash Player ou </ph>AIR refuse l’accès entre les sandbox. Un site Web peut autoriser l’accès à une ressource à l’aide d’un fichier de régulation d’URL. </li>
     
      <li>Votre application peut refuser l’accès à une ressource du serveur. Dans une application Flash Media Server, vous devez ajouter du code côté serveur pour refuser l’accès. Pour plus d’informations, voir la documentation de Flash Media Server. </li> 
     
      <li>Vous ne pouvez pas utiliser <codeph>NetConnection.connect()</codeph> si le fichier appelant se trouve dans le sandbox local avec système de fichiers.</li>
     
      <li>Vous ne pouvez pas vous connecter aux ports généralement réservés. Pour obtenir une liste complète des ports bloqués, voir « Restriction des API de réseau » dans le <ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref></ph> du manuel <i>Programmation avec ActionScript 3.0</i>. </li>
     
     <li>Vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</li>
     
     </ul>
     
	 <p>Néanmoins, dans Adobe AIR, le contenu du sandbox de sécurité <codeph>application</codeph> (contenu installé avec l’application AIR) n’est pas soumis à ces restrictions de sécurité.</p>
	 
     <p>Pour plus d’informations, voir les références suivantes :</p>
     
     <ul>
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
     <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     </ul>
     
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetConnection:client:get"><apiName>client</apiName><shortdesc>
     Indique l’objet sur lequel appeler des méthodes de rappel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>La propriété <codeph>client</codeph> ne peut pas être réglée sur l’objet null. 
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indique l’objet sur lequel appeler des méthodes de rappel. La valeur par défaut correspond à cette occurrence de NetConnection. Si vous réglez la propriété <codeph>client</codeph> sur un autre objet, les méthodes de rappels seront appelées sur celui-ci.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connected:get"><apiName>connected</apiName><shortdesc>
	 Indique si l’application est connectée (true) ou non (false) à un serveur par le biais d’une connexion RTMP continue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si l’application est connectée (<codeph>true</codeph>) ou non (<codeph>false</codeph>) à un serveur par le biais d’une connexion RTMP continue. Lorsqu’il est connecté via HTTP, cette propriété est <codeph>false</codeph>, sauf dans le cas d’une connexion aux services Flash Remoting sur un serveur d’application, auquel cas la propriété est <codeph>true</codeph>. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connectedProxyType:get"><apiName>connectedProxyType</apiName><shortdesc>
     Type de proxy utilisé pour réussir à appeler NetConnection.connect() pour Flash Media Server : « none », « HTTP », « HTTPS » ou « CONNECT ».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Une tentative d’accès à cette propriété a été effectuée alors que l’occurrence de NetConnection n’était pas connectée. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Type de proxy utilisé pour réussir à appeler <codeph>NetConnection.connect()</codeph> pour Flash Media Server : <codeph>"none"</codeph>, <codeph>"HTTP"</codeph>, <codeph>"HTTPS"</codeph> ou <codeph>"CONNECT"</codeph>. La valeur est <codeph>"none"</codeph> si la connexion ne passe pas par un tunnel, <codeph>"HTTP"</codeph> si la connexion passe par un tunnel via HTTP, <codeph>"HTTPS"</codeph> si la connexion passe par un tunnel via HTTPS et <codeph>"CONNECT"</codeph> si la connexion passe par un tunnel via la méthode HTTP CONNECT.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 L’encodage d’objet par défaut des objets NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 L’encodage d’objet par défaut des objets NetConnection. Lorsqu’un objet est écrit ou lu à partir de données binaires, la propriété <codeph>objectEncoding</codeph> indique la version AMF (Action Message Format) utilisée pour sérialiser les données : le format ActionScript 3.0 ( <codeph>ObjectEncoding.AMF3</codeph> ) ou le format ActionScript 1.0 et ActionScript 2.0 ( <codeph>ObjectEncoding.AMF0</codeph>). 
     
     <p>La valeur par défaut est <codeph>ObjectEncoding.AMF3</codeph>. La modification de <codeph>NetConnection.defaultObjectEncoding</codeph> n’a aucune incidence sur les occurrences existantes de NetConnection. Elle affecte uniquement les occurrences créées ultérieurement.</p>
     
     <p>Pour définir l’encodage d’un objet séparément (plutôt que de définir l’encodage de tous les objets de l’application), réglez la propriété <codeph>objectEncoding</codeph> de l’objet NetConnection.</p>
     
     <p>Pour plus d’informations, voir la description de la propriété <codeph>objectEncoding</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farID:get"><apiName>farID</apiName><shortdesc>
     Identifiant de l’occurrence de Flash Media Server à laquelle cette occurrence de Flash Player ou Adobe AIR est connectée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Identifiant de l’occurrence de Flash Media Server à laquelle cette occurrence de Flash Player ou Adobe AIR est connectée. Cette propriété est significative uniquement pour les connexions RTMFP. La valeur de cette propriété est disponible uniquement après l’établissement d’une connexion RTMFP.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/nearID"><linktext>nearID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     Valeur choisie par Flash Media Server, unique pour cette connexion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur choisie par Flash Media Server, unique pour cette connexion. Cette valeur apparaît pour le serveur comme sa valeur <codeph>client.nearNonce</codeph>. Cette valeur est définie uniquement pour les connexions RTMFP, RTMPE et RTMPTE.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:maxPeerConnections:get"><apiName>maxPeerConnections</apiName><shortdesc>
     Nombre total de connexions d’homologue entrantes et sortantes que cette occurrence de Flash Player ou Adobe AIR autorise.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Nombre total de connexions d’homologue entrantes et sortantes que cette occurrence de Flash Player ou Adobe AIR autorise. La valeur par défaut est 8. 
     <p>Cette valeur ne fait pas la distinction entre les connexions d’éditeurs et d’abonnés. Si cette valeur est réduite alors que des connexions d’homologue sont en cours, la nouvelle valeur n’affecte que les nouvelles connexions entrantes. Les connexions existantes ne sont pas abandonnées.</p>
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:nearID:get"><apiName>nearID</apiName><shortdesc>
     Identifiant de cette occurrence de Flash Player ou Adobe AIR pour cette occurrence de NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Identifiant de cette occurrence de Flash Player ou Adobe AIR pour cette occurrence de NetConnection. Cette propriété est significative uniquement pour les connexions RTMFP.
     
     <p>Chaque occurrence de NetConnection possède une propriété <codeph>nearID</codeph> unique. Aucune occurrence de Flash Player, Adobe AIR ou NetConnection n’a le même identifiant.</p>
     
     <p>Les autres occurrences Flash Player ou Adobe AIR utilisent cet identifiant comme <codeph>peerID</codeph> pour les nouvelles connexions NetStream à ce client. Par la suite, cet identifiant est le <codeph>farID</codeph> dans toutes les occurrences NetStream d’homologue qui se connectent à cette occurrence.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/farID"><linktext>farID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     Valeur choisie par cette occurrence de Flash Player ou Adobe AIR, unique pour cette connexion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Valeur choisie par cette occurrence de Flash Player ou Adobe AIR, unique pour cette connexion. Cette valeur apparaît pour le serveur comme sa valeur <codeph>client.farNonce</codeph>. Cette valeur est définie uniquement pour les connexions RTMFP, RTMPE et RTMPTE.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Encodage de l’objet de cette occurrence de NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Une tentative de définition de la valeur de la propriété <codeph>objectEncoding</codeph> a été effectuée pendant que l’occurrence de NetConnection était connectée.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiException><apiDesc>Cette propriété a été réglée sur une valeur autre que <codeph>ObjectEncoding.AMF0</codeph> ou <codeph>ObjectEncoding.AMF3</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Encodage de l’objet de cette occurrence de NetConnection.
     
     <p>
     Lorsqu’un objet est écrit ou lu à partir de données binaires, la propriété <codeph>objectEncoding</codeph> indique la version Action Message Format utilisée pour sérialiser les données : le format ActionScript 3.0 (<codeph>ObjectEncoding.AMF3</codeph> ) ou le format ActionScript 1.0 et ActionScript 2.0 (<codeph>ObjectEncoding.AMF0</codeph>). Définissez la propriété <codeph>objectEncoding</codeph> pour choisir une version AMF pour une occurrence de NetConnection.
     </p>
     
	 <p>Il est important de comprendre cette propriété si votre application doit communiquer avec des serveurs antérieurs à Flash Player 9. Les trois scénarios suivants sont possibles :
     </p>
     
     <ul>
	 <li>Connexion à un serveur prenant en charge AMF3 (par exemple, Flex Data Services 2 ou Flash Media Server 3). La valeur par défaut de <codeph>defaultObjectEncoding</codeph> est <codeph>ObjectEncoding.AMF3</codeph>. Toutes les occurrences NetConnection créées dans ce fichier utilisent la sérialisation AMF3, afin que vous n’ayez pas à définir la propriété <codeph>objectEncoding</codeph>.</li>
       
     <li>Connexion à un serveur ne prenant pas en charge AMF3 (par exemple, Flash Media Server 2). Dans ce cas, réglez la propriété statique <codeph>NetConnection.defaultObjectEncoding</codeph> sur <codeph>ObjectEncoding.AMF0</codeph>. Toutes les occurrences de NetConnection créées dans ce fichier SWF utilisent la sérialisation AMF0. Il est inutile de définir la propriété <codeph>objectEncoding</codeph>. </li>
     
     <li>Vous vous connectez à plusieurs serveurs utilisant des versions d’encodage différentes. Au lieu d’utiliser <codeph>defaultObjectEncoding</codeph>, réglez l’encodage d’objet connexion par connexion en utilisant pour chacune d’elles la propriété <codeph>objectEncoding</codeph>. Réglez la propriété sur <codeph>ObjectEncoding.AMF0</codeph> pour vous connecter aux serveurs qui utilisent l’encodage AMF0, tels que et Flash Media Server 2, et sur <codeph>ObjectEncoding.AMF3</codeph> pour vous connecter aux serveurs qui utilisent l’encodage AMF3, tels que Flex Data Services 2.</li>
     </ul>
     
     <p>Une fois l’occurrence de NetConnection connectée, sa propriété <codeph>objectEncoding</codeph> est en lecture seule.</p>
     
	 <p>Si vous ne spécifiez pas l’encodage approprié pour vous connecter à un serveur, l’objet NetConnection distribue l’événement <codeph>netStatus</codeph>. La propriété <codeph>NetStatusEvent.info</codeph> contient un objet d’informations dont la propriété <codeph>code</codeph> est réglée sur <codeph>NetConnection.Connect.Failed</codeph>, ainsi qu’une description expliquant que le codage d’objet est incorrect.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:protocol:get"><apiName>protocol</apiName><shortdesc>
     Protocole utilisé pour établir la connexion</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Une tentative d’accès à cette propriété a été effectuée alors que l’occurrence de NetConnection n’était pas connectée. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Protocole utilisé pour établir la connexion Cette propriété est pertinente lorsque Flash Media Server est utilisé. Les valeurs possibles sont les suivantes :
     <ul>
     <li><codeph>"rtmp"</codeph> : RTMP (Real-Time Messaging Protocol)</li>
     <li><codeph>"rtmpe"</codeph> : RTMP crypté</li>
     <li><codeph>"rtmpt"</codeph> : RTMP par tunnelage HTTP</li>
     <li><codeph>"rtmpte"</codeph> : RTMP crypté par tunnelage HTTP</li>
     <li><codeph>"rtmps"</codeph> : RTMP de type HTTPS</li>
     <li><codeph>"rtmfp"</codeph> : RTMFP (Real-Time Media Flow Protocol)</li>
     </ul>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:proxyType:get"><apiName>proxyType</apiName><shortdesc>
     Détermine les méthodes de secours à utiliser lorsque la première tentative de connexion au serveur échoue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5. In the Breeze Add-in, the default value is <code>"best"</code>; if this value
     is not changed, native SSL sockets are used by default, and a fallback
     to other methods is used if necessary. 
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Détermine les méthodes de secours à utiliser lorsque la première tentative de connexion au serveur échoue. Vous devez définir la propriété <codeph>proxyType</codeph> avant d’appeler la méthode <codeph>NetConnection.connect()</codeph>. 
     
     <p>Les valeurs acceptables sont <codeph>"none"</codeph>, <codeph>"HTTP"</codeph>, <codeph>"CONNECT"</codeph> et <codeph>"best"</codeph>.</p>
     
	 <p>La valeur par défaut de cette propriété est <codeph>"none"</codeph>. Si vous ne modifiez pas cette valeur, Flash Player utilise le tunnelage HTTPS pour RTMPS. Si la propriété est définie sur <codeph>"best"</codeph>, le client tente de se connecter via SSL natif. Si la connexion échoue, d’autres méthodes de connexion sont essayées. Si la propriété est définie sur <codeph>"HTTP"</codeph> et qu’une connexion directe échoue, le tunnelage HTTP est utilisé. Si la propriété est définie sur <codeph>"CONNECT"</codeph> et qu’une connexion directe échoue, la méthode de tunnelage <codeph>CONNECT</codeph> est utilisée. En cas d’échec, la connexion n’utilise pas le tunnelage HTTP.</p>
     
     <p>Cette propriété est applicable uniquement lors de l’utilisation de RTMP, RTMPS ou RTMPT. La méthode <codeph>CONNECT</codeph> est réservée aux utilisateurs qui sont connectés au réseau par un serveur proxy.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:unconnectedPeerStreams:get"><apiName>unconnectedPeerStreams</apiName><shortdesc>
     
     Objet qui contient tous les objets NetStream d’homologues abonnés non associés aux objets NetStream de publication.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     
     Objet qui contient tous les objets NetStream d’homologues abonnés non associés aux objets NetStream de publication. Les objets NetStream abonnés associés à des objets NetStream de publication se trouvent dans le tableau <codeph>NetStream.peerStreams</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/peerStreams"><linktext>NetStream.peerStreams</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:uri:get"><apiName>uri</apiName><shortdesc>
     URI transmise à la méthode NetConnection.connect().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     URI transmise à la méthode <codeph>NetConnection.connect()</codeph>. Si <codeph>NetConnection.connect()</codeph> n’a pas été appelée ou si aucune URI n’a été transmise, cette propriété est <codeph>undefined</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:usingTLS:get"><apiName>usingTLS</apiName><shortdesc>
     Indique si une connexion sécurisée a été établie via le protocole TLS (Transport Layer Security) natif plutôt que HTTPS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Une tentative d’accès à cette propriété a été effectuée alors que l’occurrence de NetConnection n’était pas connectée. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Indique si une connexion sécurisée a été établie via le protocole TLS (Transport Layer Security) natif plutôt que HTTPS. Cette propriété n’est valide que si un objet NetConnection est connecté.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>