<?xml version="1.0"?>
<apiPackage id="flash.system"><apiName>flash.system</apiName><apiDetail/><apiClassifier id="flash.system:Security"><apiName>Security</apiName><shortdesc>
 La classe Security permet de spécifier la façon dont le contenu peut communiquer dans différents domaines.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, XMLNode object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Security permet de spécifier la façon dont le contenu peut communiquer dans différents domaines.
 
 </apiDesc><example conref="examples\SecurityExample.as"> L’exemple suivant indique comment un événement <codeph>click</codeph> sur un objet Sprite permet d’afficher le panneau des paramètres de stockage local de la boîte de dialogue Paramètres de Flash Player. Un cadre orange est ajouté à la scène à l’aide de la méthode <codeph>draw()</codeph>. Dans <codeph>draw()</codeph>, un écouteur de l’événement <codeph>click</codeph> est ajouté sous le nom <codeph>clickHandler()</codeph>. Il répond aux événements <codeph>click</codeph> en ouvrant le panneau des paramètres de stockage local de Flash Player.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.*;
    import flash.system.Security;
    import flash.system.SecurityPanel;

    public class SecurityExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 100;

        public function SecurityExample() {
            draw();
        }

        private function draw():void {
            var child:Sprite = new Sprite();
            child.graphics.beginFill(bgColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            child.buttonMode = true;

            var label:TextField = new TextField();
            label.text = "settings";
            label.selectable = false;
            label.mouseEnabled = false;
            child.addChild(label);

            child.addEventListener(MouseEvent.CLICK, clickHandler);
            addChild(child);
        }

        private function clickHandler(event:MouseEvent):void {
            Security.showSettings(SecurityPanel.LOCAL_STORAGE);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.system:Security:allowDomain"><apiName>allowDomain</apiName><shortdesc>
     Permet aux fichiers SWF figurant dans les domaines identifiés d’accéder aux objets et aux variables du fichier SWF qui contient l’appel à allowDomain().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.allowDomain, allowDomain
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>L’appel de cette méthode depuis le code dans le sandbox de sécurité de l’application AIR émet une exception SecurityError. Le contenu situé en dehors du sandbox de sécurité de l’application ne peut pas effectuer la programmation croisée du contenu du sandbox de sécurité de l’application. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs chaînes ou objets URLRequest qui nomment les domaines à partir desquels vous souhaitez autoriser l’accès. Vous pouvez spécifier le domaine spécial « ~~ » pour autoriser l’accès à partir de tous les domaines.  
     
     <p product="flashonly">La spécification de « ~~ » constitue la seule façon d’accéder aux fichiers SWF non locaux à partir des fichiers SWF locaux qui ont été publiés à l’aide du paramètre Accès au réseau uniquement pour l’option Sécurité de lecture locale dans l’outil de programmation Flash.</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Permet aux fichiers SWF et HTML d’accéder aux objets et aux variables du fichier SWF qui procède à l’appel.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <ph platform="actionscript">Permet aux fichiers SWF figurant dans les domaines identifiés d’accéder aux objets et aux variables du fichier SWF qui contient l’appel à <codeph>allowDomain()</codeph>. </ph>
     
     <p platform="javascript">Cette méthode s’applique à la programmation croisée du code ActionScript 3.0 (dans le contenu SWF). Elle ne s’applique pas au code JavaScript s’exécutant dans des applications AIR basées sur HTML.</p>
     
     <p platform="actionscript"><i>Remarque :</i> l’appel de cette méthode depuis le code dans le sandbox de l’application AIR émet une exception SecurityError. Le contenu situé hors du domaine de sécurité de l’application ne peut pas effectuer la programmation croisée du contenu dans le sandbox de l’application. Toutefois, le contenu situé hors du sandbox de l’application peut communiquer avec le contenu du sandbox de sécurité de l’application par un pont sandbox.</p>
     
     <p platform="actionscript">Si deux fichiers SWF sont servis à partir du même domaine, par exemple, http://mysite.com/swfA.swf et http://mysite.com/swfB.swf, alors swfA.swf peut alors analyser et modifier les variables, les objets, les propriétés, les méthodes, etc. dans swfB.swf et swfB.swf peut faire la même chose pour swfA.swf. Ceci est appelé <i>programmation entre plusieurs animations</i> ou <i>programmation croisée</i>.</p>
     
     <p platform="actionscript">Si deux fichiers SWF sont servis à partir de domaines différents, par exemple, http://siteA.com/swfA.swf et http://siteB.com/siteB.swf, puis, par défaut, Flash Player n’autorise pas swfA.swf à créer un script pour swfB.swf, mais pas swfB.swf à créer un script pour swfA.swf. Un fichier SWF transmet des fichiers SWF provenant d’autres domaines en appelant <codeph>Security.allowDomain()</codeph>. Ceci s’appelle <i>programmation de scripts interdomaines</i>. En appelant <codeph>Security.allowDomain("siteA.com")</codeph>, siteB.swf autorise siteA.swf à créer un script le contrôlant.</p>
     
     <p platform="actionscript">Dans tout contexte interdomaines, il est important d’identifier clairement les parties impliquées. Dans le cadre de cette discussion, le côté procédant à la programmation croisée sera appelé <i>partie procédant à l’accès</i> (habituellement le fichier SWF procédant à l’accès) et l’autre côté sera appelé <i>partie cible</i> (généralement le fichier SWF cible). Lorsque siteA.swf crée un script contrôlant siteB.swf, siteA.swf est la partie qui procède à l’accès et siteB.swf la partie réceptrice.</p>
     
     <p platform="actionscript"><adobeimage alt="Diagramme inter-domaines" href="../../images/crossScript_load.jpg"/></p>
     
     <p platform="actionscript">Les autorisations interdomaines établies avec <codeph>allowDomain()</codeph> sont asymétriques. Dans l’exemple précédent, siteA.swf peut créer un script contrôlant siteB.swf, mais siteB.swf ne peut pas créer de script de contrôle de siteA.swf, car siteA.swf n’a pas appelé <codeph>allowDomain()</codeph> pour donner aux fichiers SWF de siteB.com l’autorisation de créer un script de contrôle. Vous pouvez définir des autorisations symétriques en faisant les deux fichiers SWF appeler <codeph>allowDomain()</codeph>.</p>
     
     <p platform="actionscript">En dehors de la protection des fichiers SWF contre les scripts interdomaines provenant d’autres fichiers SWF, Flash Player protège également les fichiers SWF contre ce type de script provenant des fichiers HTML. La programmation HTML vers SWF peut se produire avec des fonctions anciennes du navigateur telles que <codeph>SetVariable</codeph> ou en appelant des fonctions de rappel établies avec <codeph>ExternalInterface.addCallback()</codeph>. Lorsque la programmation HTML vers SWF franchit les domaines, le SWF cible doit également appeler <codeph>allowDomain()</codeph>, comme s’il avait été appelé par un fichier SWF, faute de quoi l’opération échouera.</p>
     
     <p platform="actionscript">La spécification de l’adresse IP en tant que paramètre pour <codeph>allowDomain()</codeph> n’autorise pas l’accès de toutes les parties provenant de l’adresse IP spécifiée. Par contre, elle autorise l’accès uniquement par une partie qui contient l’adresse IP spécifiée dans son URL, et non pas un nom de domaine qui renvoie à cette adresse IP.</p> 
     
     <p platform="actionscript"><b>Différences liées à la version</b></p>
     <p platform="actionscript">Les règles de sécurité interdomaines de Flash Player ont évolué de version en version. Le tableau suivant récapitule les différences.</p>
     
     <adobetable class="innertable" platform="actionscript">
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Versions SWF les plus récentes impliquées dans les opérations de programmation croisée</entry><entry><codeph>allowDomain()</codeph> nécessaire ?</entry><entry><codeph>allowInsecureDomain()</codeph> nécessaire ?</entry><entry>Quel fichier SWF doit appeler <codeph>allowDomain()</codeph> ou <codeph>allowInsecureDomain()</codeph> ?</entry><entry>Qu’est-ce qui peut être spécifié dans <codeph>allowDomain()</codeph> ou <codeph>allowInsecureDomain()</codeph> ?</entry></row></thead><tbody><row>
       <entry align="center">5 ou plus récente</entry>
       <entry>Non</entry>
       <entry align="center">Non</entry>
       <entry align="center">S/O</entry>
       <entry align="center">S/O</entry>
     </row><row>
       <entry align="center">6</entry>
       <entry>Oui, si les super-domaines ne concordent pas</entry>
       <entry align="center">Non</entry>
       <entry>Le fichier SWF en cours d’accès ou tout fichier SWF appartenant au même super-domaine que le fichier SWF en cours d’accès.</entry>
       <entry><ul>
         <li>Domaine de type texte (monsite.com)</li>
         <li>Adresse IP (192.168.1.1)</li>
       </ul></entry>
     </row><row>
       <entry align="center">7</entry>
       <entry>Oui, si les domaines ne concordent pas exactement</entry>
       <entry>Oui, en cas d’accès HTTP vers HTTPS (même si les domaines correspondent exactement)</entry>
       <entry>Le fichier SWF en cours d’accès ou tout fichier SWF appartenant exactement au même domaine que le fichier SWF en cours d’accès.</entry>
       <entry><ul>
         <li>Domaine de type texte (monsite.com)</li>
         <li>Adresse IP (192.168.1.1)</li>
       </ul></entry>
     </row><row>
       <entry align="center">8 ou plus récente</entry>
       <entry>Oui, si les domaines ne concordent pas exactement</entry>
       <entry>Oui, en cas d’accès HTTP vers HTTPS (même si les domaines correspondent exactement)</entry>
       <entry>Fichier SWF cible</entry>
       <entry><ul>
         <li>Domaine de type texte (monsite.com)</li>
         <li>Adresse IP (192.168.1.1)</li>
         <li>Caractère générique (~~)</li>
       </ul></entry>
     </row></tbody></tgroup></adobetable>
      
     <p platform="actionscript">Les versions qui contrôlent le comportement de Flash Player désignent les <i>versions SWF</i> (la version publiée d’un fichier SWF), non pas la version de Flash Player. Par exemple, lorsque Flash Player 8 lit un fichier SWF publié par la version 7, il applique un comportement compatible à la version 7. Cette pratique permet de garantir que les mises à jour du lecteur ne changent pas le comportement de <codeph>Security.allowDomain()</codeph> dans les fichiers SWF déployés.</p>
     
     <p platform="actionscript">La colonne Version du tableau précédent indique la version la plus récente des fichiers SWF lors des opérations de programmation croisée. Le comportement de Flash Player dépend de la version du fichier SWF procédant à l’accès ou du fichier SWF cible, en retenant la version supérieure.</p>
     
     <p platform="actionscript">Les paragraphes suivants fournissent de plus amples informations sur les modifications de sécurité de Flash Player impliquant <codeph>Security.allowDomain()</codeph>.</p>
     
     <p platform="actionscript"><b>Version 5</b>. Il n’y a aucune restriction de programmation de scripts interdomaines.</p>
     
     <p platform="actionscript"><b>Version 6</b>. Des fonctions de sécurité contre la programmation interdomaines ont été introduites. Par défaut, Flash Player empêche la programmation interdomaines, tandis que <codeph>Security.allowDomain()</codeph> l’autorise. Pour déterminer si deux fichiers appartiennent au même domaine, Flash Player utilise le super-domaine de chaque fichier, qui correspond au nom d’hôte exact de l’URL du fichier, moins le premier segment, jusqu’à un minimum de deux segments. Par exemple, le super-domaine de www.mysite.com est mysite.com. Les fichiers SWF de www.mysite.com et store.mysite.com ne peuvent pas se contrôler mutuellement par script sans un appel à <codeph>Security.allowDomain()</codeph>.</p>
     
     <p platform="actionscript"><b>Version 7</b>. Le filtrage de super-domaine est modifié pour obtenir la correspondance exacte des domaines. Deux fichiers ne peuvent se programmer que si les noms d’hôte figurant dans leurs URL sont identiques ; sinon vous devez effectuer un appel à <codeph>Security.allowDomain()</codeph>. Par défaut, les fichiers chargés à partir des URL qui ne sont pas de type HTTPS ne sont plus autorisés à programmer les fichiers chargés à partir des URL HTTPS, même si les fichiers sont chargés à partir d’un domaine rigoureusement identique. Cette restriction permet de protéger les fichiers HTTPS, car un fichier non HTTPS est susceptible d’être modifié sans téléchargement, et tout fichier non HTTPS modifié de façon illicite risque de corrompre un fichier HTTPS, qui serait normalement protégé contre ce type de modification. La méthode <codeph>Security.allowInsecureDomain()</codeph> a été introduite pour permettre aux fichiers SWF HTTPS en cours d’accès de désactiver de façon volontaire cette restriction. Néanmoins, l’utilisation de <codeph>Security.allowInsecureDomain()</codeph> est déconseillée.</p>
     
     <p platform="actionscript"><b>Version 8</b>. Il existe deux grands domaines de modification :</p>
     
     <ul platform="actionscript">
       <li>L’appel de <codeph>Security.allowDomain()</codeph> autorise désormais uniquement les opérations de programmation croisée où le fichier SWF cible correspond au fichier SWF qui a appelé <codeph>Security.allowDomain()</codeph>. En d’autres termes, tout fichier SWF qui appelle désormais <codeph>Security.allowDomain()</codeph> n’autorise que l’accès à lui-même. Dans des versions précédentes, l’appel de <codeph>Security.allowDomain()</codeph> autorisait les opérations de programmation croisée lorsque le fichier SWF cible appartenait au même domaine que le fichier SWF qui a appelé <codeph>Security.allowDomain()</codeph>. L’appel de <codeph>Security.allowDomain()</codeph> ouvrait auparavant l’ensemble du domaine du fichier SWF ayant procédé à l’appel.</li>
     
       <li>Une prise en charge a été ajoutée pour les valeurs des caractères génériques avec <codeph>Security.allowDomain("~~")</codeph> et <codeph>Security.allowInsecureDomain("~~")</codeph>. La valeur caractère générique (~~) autorise les opérations de programmation croisée quel que soit le fichier procédant à l’accès et quelle que soit l’origine de ce dernier. Le caractère générique sert alors d’autorisation globale. Des autorisations génériques sont requises pour activer certains types d’opérations respectant les règles de sécurité des fichiers locaux. De façon plus spécifique, pour qu’un fichier SWF local disposant d’autorisations d’accès réseau pour créer un script de contrôle de fichier SWF sur Internet, le fichier Internet SWF en cours d’accès doit appeler <codeph>Security.allowDomain("~~")</codeph>, ce qui indique que l’origine du fichier SWF local est inconnue (si le fichier SWF Internet cible est chargé à partir d’une URL HTTPS, le fichier SWF Internet doit alors appeler <codeph>Security.allowInsecureDomain("~~")</codeph>).</li>
     </ul>
       
     <p platform="actionscript">De façon exceptionnelle, la situation suivante peut se produire : vous chargez un fichier SWF enfant à partir d’un domaine différent et souhaitez lui permettre de créer un script sur le fichier SWF parent, mais vous ne connaissez pas le domaine final du fichier SWF enfant. Cela peut se produire, par exemple, lorsque vous utilisez des redirections d’équilibrage de charge ou des serveurs tiers.</p>
     
     <p platform="actionscript">Dans ce cas, vous pouvez utiliser la propriété <codeph>url</codeph> de l’objet URLRequest que vous transmettez à <codeph>Loader.load()</codeph>. Par exemple, si vous chargez un fichier SWF dans un fichier SWF parent, vous pouvez accéder à la propriété <codeph>contentLoaderInfo</codeph> de l’objet Loader pour le fichier SWF parent : </p>
     <codeblock platform="actionscript">Security.allowDomain(loader.contentLoaderInfo.url)</codeblock>
     
     <p platform="actionscript">Vous devez attendre le début du chargement du fichier SWF enfant pour obtenir la valeur correcte de la propriété <codeph>url</codeph>. Pour détecter le début du chargement du fichier SWF, exploite l’événement <codeph>progress</codeph>.</p>
     
     <p platform="actionscript">La situation opposée peut également se produire ; en effet, vous pouvez créer un fichier SWF enfant sur lequel son fichier parent pourra créer un script, mais qui ignore le domaine de celui-ci. Dans ce cas, vous pouvez accéder à la propriété <codeph>loaderInfo</codeph> de l’objet d’affichage qui correspond à l’objet racine du fichier SWF. Dans le fichier SWF enfant, appelez <codeph>Security.allowDomain( this.root.loaderInfo.loaderURL)</codeph>. Il n’est pas nécessaire d’attendre la fin du chargement du fichier SWF parent ; le parent sera déjà chargé lorsque celui de l’enfant commencera.</p>
     
     <p platform="actionscript">Si vous procédez à la publication de Flash Player 8 ou une version ultérieure, vous pouvez également traiter ces situations en appelant <codeph>Security.allowDomain("~~")</codeph>. Cependant, il peut parfois s’agir d’un raccourci dangereux, dans la mesure où il autorise tout autre fichier SWF, quel que soit le domaine de ce dernier, à accéder au fichier SWF procédant à l’appel. Il est généralement plus sûr d’utiliser la propriété <codeph>_url</codeph>.</p> 
     
     <p platform="actionscript">Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul platform="actionscript">
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
     
     
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.external.xml#ExternalInterface/addCallback()"><linktext>ExternalInterface.addCallback()</linktext></link><link href="flash.events.xml#Event/COMPLETE"><linktext>flash.events.Event.COMPLETE</linktext></link><link href="flash.display.xml#DisplayObject/parent"><linktext>flash.display.DisplayObject.parent</linktext></link><link href="flash.net.xml#URLRequest/url"><linktext>flash.net.URLRequest.url</linktext></link><link href="flash.system.xml#Security/allowInsecureDomain()"><linktext>allowInsecureDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:Security:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
     Permet aux fichiers SWF et HTML appartenant aux domaines identifiés d’accéder aux objets et variables du fichier SWF effectuant l’appel, hébergé à l’aide du protocole HTTPS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.allowInsecureDomain, allowInsecureDomain
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>L’appel de cette méthode depuis le code dans le sandbox de sécurité de l’application AIR renvoie une exception SecurityError. Le contenu situé en dehors du sandbox de sécurité de l’application ne peut pas effectuer la programmation croisée du contenu du sandbox de sécurité de l’application. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Une ou plusieurs chaînes ou objets URLRequest qui nomment les domaines à partir desquels vous souhaitez autoriser l’accès. Vous pouvez spécifier le domaine spécial « ~~ » pour autoriser l’accès à partir de tous les domaines.  
     
     <p class="flashonly">La spécification de « ~~ » constitue la seule façon d’accéder aux fichiers SWF non locaux à partir des fichiers SWF locaux qui ont été publiés à l’aide du paramètre Accès au réseau uniquement pour l’option Sécurité de lecture locale (Fichier > Paramètres de publication > onglet Flash) dans l’outil de programmation Flash.</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Permet aux fichiers SWF et HTML hébergés à l’aide du protocole HTTPS d’accéder aux objets et aux variables du fichier SWF qui procède à l’appel.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <ph platform="actionscript">Permet aux fichiers SWF et HTML appartenant aux domaines identifiés d’accéder aux objets et variables du fichier SWF appelant, hébergé à l’aide du protocole HTTPS.</ph>
     
     <p platform="javascript">Cette méthode s’applique à la programmation croisée du code ActionScript 3.0 (dans le contenu SWF). Elle ne s’applique pas au code JavaScript s’exécutant dans des applications AIR basées sur HTML.</p>
     
     
     <p platform="actionscript">Flash Player offre la méthode <codeph>allowInsecureDomain()</codeph> pour plus de souplesse, même si l’appel de cette méthode n’est pas recommandé. La transmission d’un fichier par le protocole HTTPS offre plusieurs protections pour vous et vos utilisateurs. Le fait d’appeler <codeph>allowInsecureDomain</codeph> affaiblit l’une de ces protections.</p>
     
     <p platform="actionscript"><i>Remarque :</i> l’appel de cette méthode depuis le code dans le sandbox de l’application AIR émet une exception SecurityError. Le contenu situé hors du domaine de sécurité de l’application ne peut pas effectuer la programmation croisée du contenu dans le sandbox de l’application. Toutefois, le contenu situé hors du sandbox de l’application peut communiquer avec le contenu du sandbox de sécurité de l’application par un pont sandbox.</p>
     
     <p platform="actionscript">Cette méthode fonctionne de la même façon que <codeph>Security.allowDomain()</codeph>, mais elle autorise en outre des opérations où la partie qui procède à l’accès est chargée avec un protocole non HTTPS et la partie cible est chargée avec le protocole HTTPS. A partir de la version 7 de Flash Player, les fichiers non HTTPS ne sont pas autorisés à programmer les fichiers HTTPS. La méthode <codeph>allowInsecureDomain()</codeph> lève cette restriction lorsque le fichier SWF HTTPS cible l’utilise.</p>
     
     <p platform="actionscript">Utilisez <codeph>allowInsecureDomain()</codeph> uniquement pour activer la programmation des fichiers non HTTPS vers les fichiers HTTPS. Utilisez cette méthode pour activer le script lorsque le fichier non HTTPS qui procède à l’accès et le fichier HTTPS qui est accédé sont servis à partir du même domaine. Par exemple, si un fichier SWF sur http://mysite.com doit contrôler par script un fichier SWF sur https://mysite.com. N’utilisez pas cette méthode pour activer les scripts de contrôle entre des fichiers non HTTPS, entre fichiers HTTPS ou de fichiers HTTPS vers des fichiers non HTTPS. Dans ces situations, recourez plutôt à <codeph>allowDomain()</codeph>.</p>
     
     Le scénario suivant illustre la façon dont la méthode <codeph>allowInsecureDomain()</codeph>, si elle n’est pas utilisée avec prudence, risque de compromettre la sécurité.
     
     <p platform="actionscript">Tenez compte du fait que les informations suivantes constituent uniquement l’un des scénarios possibles et sont conçues pour vous aider à comprendre <codeph>allowInsecureDomain()</codeph> par l’intermédiaire d’un exemple réaliste de programmation croisée. Cet exemple ne couvre pas tous les problèmes relatifs à l’architecture de sécurité et doit être utilisé uniquement comme référence générale. Le Centre de développement de Flash Player contient des informations détaillées sur Flash Player et la sécurité. Pour plus d’informations, voir la rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref>.</p>
     
     <p platform="actionscript">Supposons que vous deviez créer un site de commerce électronique qui comprend deux composants : un catalogue, qui ne doit pas nécessairement être sécurisé, dans la mesure où il contient uniquement des informations publiques ; et un composant panier/règlements, qui doit être sécurisé pour protéger les informations financières et personnelles des utilisateurs. Supposons que vous deviez servir le catalogue à partir de http://mysite.com/catalog.swf et le panier à partir de https://mysite.com/cart.swf. Le cahier des charges de votre site exige qu’aucun tiers ne puisse voler les numéros de carte de crédit de votre utilisateur en profitant des faiblesses de votre architecture de sécurité.</p>
     
     <p platform="actionscript">Imaginons qu’un intermédiaire malveillant tente d’intervenir entre le serveur et vos utilisateurs pour s’emparer des numéros de carte de crédit que vos utilisateurs pénètrent dans votre application de panier. L’intermédiaire, peut être un FAI peu scrupuleux, par exemple, ou un administrateur malveillant travaillant dans la même entreprise que certains utilisateurs, ou de façon plus générale, toute personne ayant la possibilité d’afficher ou modifier les paquets réseau transmis sans protection sur Internet, entre vos utilisateurs et vos serveurs. Cette situation n’est pas rare.</p> 
     
     <p platform="actionscript">Si cart.swf utilise HTTPS pour transmettre les informations bancaires aux serveurs, l’intermédiaire ne peut pas voler directement ces informations en détournant les paquets réseau, dans la mesure où la transmission HTTPS est chiffrée. Cependant, l’attaquant utilise une autre technique : modifier le contenu de l’un de vos fichiers SWF pendant sa remise à l’utilisateur, en remplaçant le fichier SWF par une version modifiée qui détourne les informations relatives à l’utilisateur vers un autre serveur.</p>
     
     <p platform="actionscript">Le protocole HTTPS, entre autres, empêche l’application de cette « modification », dans la mesure où non seulement les transmissions HTTPS sont chiffrées mais encore protégées contre les modifications. Si un intermédiaire tente de modifier un paquet, le récepteur détecte la modification et refuse le paquet. Ainsi, l’attaquant ne peut pas modifier cart.swf, dans la mesure où il est transmis par l’intermédiaire du protocole HTTPS.</p>
     
     <p platform="actionscript">Supposons maintenant que vous souhaitiez autoriser les boutons dans catalog.swf, servi par le protocole HTTP, pour ajouter des éléments au panier dans cart.swf, servi par le protocole HTTPS. Pour accomplir ceci, cart.swf appelle <codeph>allowInsecureDomain()</codeph>, ce qui autorise catalog.swf à créer un script de contrôle pour cart.swf. Cette action entraîne une conséquence non intentionnelle : un attaquant pourrait modifier catalog.swf lorsqu’il est téléchargé par l’utilisateur, car catalog.swf est transmis avec le protocole HTTP et n’offre aucune protection contre les modifications. Le fichier catalog.swf modifié par l’attaquant peut désormais programmer cart.swf, dans la mesure où cart.swf contient un appel à <codeph>allowInsecureDomain()</codeph>. Le fichier catalog.swf modifié peut utiliser ActionScript pour accéder aux variables de cart.swf et lire ainsi les informations sur les cartes bancaires et autres données sensibles. Le fichier catalog.swf peut ensuite envoyer ces données au serveur d’un attaquant.</p>
     
     <p platform="actionscript">Naturellement, cette implémentation n’est pas souhaitable, mais vous devez autoriser la programmation croisée entre les deux fichiers SWF de votre site. Voici deux façons de changer la conception de ce site virtuel d’e-commerce afin d’éviter <codeph>allowInsecureDomain()</codeph> :</p>
     
     <ul platform="actionscript">
       <li>Servez tous les fichiers SWF de l’application avec le protocole HTTPS. Il s’agit de la solution la plus simple et la plus fiable. Dans le scénario décrit, vous pouvez servir les fichiers catalog.swf et cart.swf par l’intermédiaire du protocole HTTPS. Vous risquez de consommer un peu plus de bande passante et d’augmenter la charge du processeur du serveur en faisant basculer un fichier tel que catalog.swf du protocole HTTP au protocole HTTPS, ce qui se traduira par une légère augmentation du temps de chargement des applications au niveau de l’utilisateur. Vous devez faire des essais avec des serveurs réels pour déterminer la gravité de ces effets. De manière générale, elle reste cantonnée entre 10 et 20 % et est parfois totalement absente. Vous pouvez généralement améliorer les résultats avec du matériel et des logiciels d’accélération HTTPS sur vos serveurs. L’un des principaux avantage de l’application du protocole HTTPS aux fichiers SWF qui doivent coopérer est que vous pouvez utiliser une URL HTTPS en tant qu’URL principale dans le navigateur de l’utilisateur sans générer d’avertissements de contenu mixtes à partir du navigateur. En outre, l’icône en forme de cadenas devient visible dans le navigateur, ce qui permet d’offrir aux utilisateurs un indicateur de sécurité reconnu.</li>
     
      <li>Utilisez la programmation HTTPS vers HTTP, et non pas HTTP vers HTTPS. Dans le scénario proposé, vous pouvez stocker le contenu du panier de l’utilisateur dans catalog.swf, puis utiliser cart.swf pour gérer le processus de règlement. Lors du règlement, cart.swf pourrait extraire le contenu du panier à partir des variables ActionScript de catalog.swf. La restriction concernant les scripts HTTP vers HTTPS est asymétrique, bien qu’un fichier catalog.swf livré par le protocole HTTP ne puisse pas être autorisé à contrôler par script un fichier cart.swf livré par HTTPS, le fichier cart.swf HTTPS peut créer un script de contrôle du fichier catalog.swf HTTP. Cette approche est plus délicate que l’approche intégralement HTTPS ; vous ne devez pas faire confiance aux fichiers SWF transmis avec le protocole HTTP, qui n’est pas protégé contre les modifications. Par exemple, lorsque cart.swf extrait la variable ActionScript qui décrit le contenu du panier, le code ActionScript de cart.swf ne peut pas être certain que la valeur de cette variable est au format attendu. Vous devez vous assurer que le panier ne contient pas de données non valides qui risquent d’entraîner une action imprévue de cart.swf. Vous devez également accepter le risque qu’un intermédiaire, en modifiant catalog.swf, fournisse des données valides mais inexactes à cart.swf, par exemple en plaçant des éléments dans le caddie de l’utilisateur. La procédure normale de règlement permet d’atténuer ce risque, sans toutefois l’écarter totalement, en affichant le contenu du caddie et le montant total pour approbation par l’utilisateur.</li>
     </ul>
     
     <p platform="actionscript">Les navigateurs Web appliquent la séparation des fichiers HTTPS et non HTTPS depuis de nombreuses années et le scénario ci-dessus illustre l’utilité de cette restriction. Flash Player permet de contourner cette restriction de sécurité lorsque c’est strictement nécessaire, mais analysez les conséquences avant d’y procéder.</p>
     
     <p platform="actionscript">Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul platform="actionscript">
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>allowDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:Security:loadPolicyFile"><apiName>loadPolicyFile</apiName><shortdesc>  
     Recherche un fichier de régulation à l’emplacement spécifié par le paramètre url.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Emplacement de l’URL du fichier de régulation à charger.
     </apiDesc></apiParam><apiTipTexts><apiTipText>Recherche un fichier de régulation à l’emplacement spécifié par le paramètre url.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>  
     Recherche un fichier de régulation à l’emplacement spécifié par le paramètre <codeph>url</codeph>. Adobe AIR et Flash Player utilisent des fichiers de régulation pour déterminer s’ils autorisent des applications à charger des données depuis des serveurs autres que celui sur lequel elles se trouvent. Notez que même si la méthode se nomme <codeph> loadPolicyFile()</codeph>, le fichier n’est pas chargé tant qu’une requête réseau impliquant un fichier de régulation n’est pas créée.
     
	 <p>Avec <codeph>Security.loadPolicyFile()</codeph>, Flash Player ou AIR peut charger les fichiers de régulation à partir d’emplacements aléatoires, comme l’illustre l’exemple suivant :</p>
     
     <codeblock platform="actionscript">
     Security.loadPolicyFile("http://www.example.com/sub/dir/pf.xml");
     </codeblock>
     
     <codeblock platform="javascript">
     air.Security.loadPolicyFile("http://www.example.com/sub/dir/pf.xml");
     </codeblock>
     
     <p>De cette manière, Flash Player ou AIR tente de récupérer un fichier de régulation à partir de l’URL spécifiée. Les autorisations accordées par l’intermédiaire du fichier de régulation s’appliquent à l’ensemble du contenu, au même niveau ou à un niveau inférieur dans la hiérarchie virtuelle des répertoires du serveur. </p>
     
     <p platform="actionscript">Par exemple, selon le code précédent, ces lignes ne renvoient pas d’exception :</p>
     
     <codeblock platform="actionscript"> import flash.net.~~;
     var request:URLRequest = new URLRequest("http://www.example.com/sub/dir/vars.txt");
     var loader:URLLoader = new URLLoader();
     loader.load(request);
     
     var loader2:URLLoader = new URLLoader();
     var request2:URLRequest = new URLRequest("http://www.example.com/sub/dir/deep/vars2.txt");
     loader2.load(request2);
     </codeblock>
     
     <p platform="actionscript">Par contre, le code suivant renvoie une exception de sécurité :</p>
     
     <codeblock platform="actionscript"> import flash.net.~~;
     var request3:URLRequest = new URLRequest("http://www.example.com/elsewhere/vars3.txt");
     var loader3:URLLoader = new URLLoader();
     loader3.load(request3);
     </codeblock>
     
     <p>Vous pouvez utiliser <codeph>loadPolicyFile()</codeph> pour charger un nombre illimité de fichiers de régulation. Dans le cas d’une requête impliquant un fichier de régulation, Flash Player ou AIR attend que le téléchargement des fichiers de régulation soit terminé avant de rejeter une requête. En dernier recours, si aucun des fichiers de régulation spécifiés par <codeph>loadPolicyFile()</codeph> n’autorise la requête, Flash Player ou AIR consulte les emplacements d’origine par défaut.</p>
     
     <p>Lorsqu’il recherche un fichier de régulation maître,. Flash Player attend une réponse du serveur pendant trois secondes. En l’absence d’une réponse, l’application considère qu’il n’existe pas de fichier de régulation maître. Toutefois, si aucune valeur de dépassement de délai par défaut est définie pour les appels à <codeph>loadPolicyFile()</codeph>, Flash Player suppose que le fichier appelé existe et attend aussi longtemps que nécessaire pour le charger. Pour avoir la certitude qu’un fichier de régulation maître est chargé, appelez-le donc explicitement par le biais de <codeph>loadPolicyFile()</codeph>.</p>
     
      <p>Vous ne pouvez pas charger de fichiers de régulation fournis à partir des ports généralement réservés. Pour obtenir une liste complète des ports bloqués, reportez-vous à la rubrique « Restriction des API de réseau » dans le <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external">chapitre relatif à la sécurité</xref> </ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external">chapitre relatif à la sécurité</xref> </ph>du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
     
     <p>L’utilisation du protocole <codeph>xmlsocket</codeph> avec un numéro de port spécifique permet de récupérer directement les fichiers de régulation depuis un serveur XMLSocket, comme l’illustre l’exemple suivant : Les connexions de socket ne sont pas soumises aux restrictions de ports réservés décrites ci-dessus.</p>
     
     <codeblock platform="actionscript">
     Security.loadPolicyFile("xmlsocket://foo.com:414");
     </codeblock>
     
     <codeblock platform="javascript">
     air.Security.loadPolicyFile("xmlsocket://foo.com:414");
     </codeblock>
     
     <p>De cette manière, Flash Player ou AIR peut récupérer un fichier de régulation au niveau du port et de l’hôte spécifiés. Lors de la connexion au port spécifié, Flash Player ou AIR transmet <codeph>&lt;policy-file-request /></codeph>, suivi d’un octet de terminaison <codeph>null</codeph>. Le serveur doit renvoyer un octet null à la fin du fichier de régulation avant de fermer la connexion. Si le serveur ne ferme pas la connexion, Flash Player ou AIR y met fin après avoir reçu l’octet de terminaison <codeph>null</codeph>.</p>
     
     <p platform="actionscript">Vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF.</p>
     
     <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul>
     
     <li product="flex">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
       <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:Security:showSettings"><apiName>showSettings</apiName><shortdesc>
     Affiche le panneau Paramètres de sécurité de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.showSettings(), showSettings()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>panel</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>default</apiData><apiDesc>Une valeur de la classe SecurityPanel qui permet de spécifier le panneau Paramètres de sécurité à afficher. Si vous omettez ce paramètre, <codeph>SecurityPanel.DEFAULT</codeph> est utilisé. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Affiche le panneau Paramètres de sécurité de Flash Player. Cette méthode ne s’applique pas au contenu dans Adobe AIR ; son appel dans une application AIR n’a aucun effet.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#SecurityPanel"><linktext>SecurityPanel</linktext></link></related-links></apiOperation><apiValue id="flash.system:Security:APPLICATION"><apiName>APPLICATION</apiName><shortdesc>
	 Le fichier est exécuté dans une application AIR, et a été installé avec le package (le fichier AIR) pour cette application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>application</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Le fichier est exécuté dans une application AIR, et a été installé avec le package (le fichier AIR) pour cette application. Ce contenu est inclus dans le répertoire des ressources de l’application AIR (où le contenu de l’application est installé).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:LOCAL_TRUSTED"><apiName>LOCAL_TRUSTED</apiName><shortdesc>
     Ce fichier est un fichier local qui a été approuvé par l’utilisateur en utilisant soit le gestionnaire de paramètres de Flash Player, soit un fichier de configuration FlashPlayerTrust.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localTrusted</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ce fichier est un fichier local qui a été approuvé par l’utilisateur en utilisant soit le gestionnaire de paramètres de Flash Player, soit un fichier de configuration FlashPlayerTrust. Ce fichier peut aussi bien lire à partir de sources locales de données que communiquer avec Internet.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:LOCAL_WITH_FILE"><apiName>LOCAL_WITH_FILE</apiName><shortdesc>
     Le fichier est un fichier local qui n’a pas été approuvé par l’utilisateur, et il ne s’agit pas d’un fichier SWF publié avec une désignation de mise en réseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localWithFile</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Le fichier est un fichier local qui n’a pas été approuvé par l’utilisateur, et il ne s’agit pas d’un fichier SWF publié avec une désignation de mise en réseau. Dans Adobe AIR, le fichier local n’est <i>pas</i> dans le répertoire des ressources de l’application ; ce type de fichier est placé dans le sandbox de sécurité de l’application. Ce fichier peut lire à partir de sources locales de données mais ne peut pas communiquer avec Internet.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:LOCAL_WITH_NETWORK"><apiName>LOCAL_WITH_NETWORK</apiName><shortdesc>
	 Le fichier est un fichier local qui n’a pas été approuvé par l’utilisateur, et il s’agit d’un fichier SWF publié avec une désignation de mise en réseau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localWithNetwork</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Le fichier est un fichier local qui n’a pas été approuvé par l’utilisateur, et il s’agit d’un fichier SWF publié avec une désignation de mise en réseau. Le fichier peut communiquer sur Internet mais ne peut pas lire à partir de sources de données locales.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:REMOTE"><apiName>REMOTE</apiName><shortdesc>
     Ce fichier provient d’une URL et fonctionne selon les règles basées sur le domaine du sandbox.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>remote</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Ce fichier provient d’une URL et fonctionne selon les règles basées sur le domaine du sandbox.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:exactSettings:get"><apiName>exactSettings</apiName><shortdesc>
     Détermine la façon dont Flash Player ou AIR sélectionne le domaine à utiliser pour certains paramètres de contenu, ce qui couvre les autorisations relatives à la caméra et au microphone, les quotas de stockage et le stockage d’objets persistants partagés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.exactSettings, exactSettings
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Flash Player ou AIR a déjà utilisé la valeur de <codeph>exactSettings</codeph> au moins une fois pour déterminer les paramètres du lecteur.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Détermine la façon dont Flash Player ou AIR sélectionne le domaine à utiliser pour certains paramètres de contenu, ce qui couvre les autorisations relatives à la caméra et au microphone, les quotas de stockage et le stockage d’objets persistants partagés. Afin que le fichier SWF utilise les mêmes paramètres que dans Flash Player 6, définissez <codeph>exactSettings</codeph> sur <codeph>false</codeph>.
     
     <p platform="javascript">Cette propriété doit être utilisée dans le contenu SWF, et non dans le code JavaScript dans des applications AIR.</p>
     
     <p platform="actionscript">Dans Flash Player 6, le domaine utilisé pour ces paramètres de lecteur était basé sur la partie finale du domaine du fichier SWF. Lorsque le domaine d’un fichier SWF inclut plus de deux segments, tels que www.exemple.com, le premier segment du domaine (« www ») est supprimé et la partie restante du domaine est utilisée : exemple.com. Ainsi, dans Flash Player 6, www.exemple.com et magasin.exemple.com ont en commun le domaine « example.com » pour ces paramètres. de même, www.exemple.co.fr et magasin.exemple.co.fr ont tous les deux recours au domaine exemple.co.fr pour ces paramètres. A compter de Flash Player 7, les paramètres du lecteur sont choisis par défaut en fonction d’un domaine exact de fichier SWF. Par exemple, le fichier SWF de www.exemple.com applique les paramètres du lecteur pour www.exemple.com, et le fichier SWF de magasin.exemple.com utiliserait des paramètres différents pour magasin.exemple.com.</p>
     
     <p platform="actionscript">Lorsque <codeph>Security.exactSettings</codeph> est défini sur <codeph>true</codeph>, Flash Player a recours à des domaines exacts pour les paramètres du lecteur. Lorsqu’il est défini sur <codeph>false</codeph>, Flash Player applique les paramètres de domaine de Flash Player 6. La valeur par défaut de <codeph>exactSettings</codeph> est <codeph>false</codeph>. Si vous modifiez la valeur par défaut de <codeph>exactSettings</codeph>, faites-le avant que tout événement impliquant la sélection de paramètres du lecteur se produise, tel que l’utilisation d’une caméra ou d’un microphone, ou l’extraction d’un objet partagé persistant.</p>
     
     <p platform="actionscript">Si vous avez déjà publié un fichier SWF de version 6 et créé des objets persistants à partir de ce dernier, et si vous devez extraire ces objets partagés persistants à partir de ce fichier SWF après l’avoir porté vers la version 7 ou plus récente (ou à partir d’un autre fichier SWF de version 7 ou plus récente), vous devez définir <codeph>Security.exactSettings</codeph> sur <codeph>false</codeph> avant d’appeler <codeph>SharedObject.getLocal()</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Security:sandboxType:get"><apiName>sandboxType</apiName><shortdesc>
     Indique le type de sandbox de sécurité dans lequel fonctionne le fichier appelant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Indique le type de sandbox de sécurité dans lequel fonctionne le fichier appelant.
     
     <p><codeph>Security.sandboxType</codeph> a l’une des valeurs suivantes :</p>
     
     <ul>
     <li><codeph>remote</codeph> (<codeph>Security.REMOTE</codeph>) —  Ce fichier provient d’une URL Internet et fonctionne selon des règles de sandbox basées sur le domaine.</li>
     <li><codeph>localWithFile</codeph> (<codeph>Security.LOCAL_WITH_FILE</codeph>) — Ce fichier est un fichier local qui n’a pas été approuvé par l’utilisateur, et il ne s’agit pas d’un fichier SWF publié avec une désignation de mise en réseau. Ce fichier peut lire à partir de sources locales de données mais ne peut pas communiquer avec Internet.</li>
     <li><codeph>localWithNetwork</codeph> (<codeph>Security.LOCAL_WITH_NETWORK</codeph>) — Ce fichier SWF est un fichier local qui n’a pas été approuvé par l’utilisateur, et a été publié avec la désignation de mise en réseau. Le fichier SWF peut communiquer sur Internet mais ne peut pas lire à partir de sources de données locales.</li>
     <li><codeph>localTrusted</codeph> (<codeph>Security.LOCAL_TRUSTED</codeph>) — Ce fichier est un fichier local qui a été approuvé par l’utilisateur en utilisant soit le gestionnaire de paramètres de Flash Player, soit un fichier de configuration FlashPlayerTrust. Ce fichier peut aussi bien lire à partir de sources locales de données que communiquer avec Internet.</li>
     <li><codeph>application</codeph> (<codeph>Security.APPLICATION</codeph>) — Ce fichier est exécuté dans une application AIR, et a été installé avec le package (le fichier AIR) pour cette application. Par défaut, les fichiers dans le sandbox de sécurité de l’application AIR peuvent effectuer la programmation croisée de n’importe quel fichier issu de n’importe quel domaine (alors que les fichiers situés en dehors du sandbox de sécurité de l’application AIR peuvent ne pas être autorisés à effectuer la programmation croisée du fichier AIR). Par défaut, les fichiers du sandbox de sécurité de l’application AIR peuvent charger le contenu et les données de n’importe quel domaine. </li>
     
     </ul>
     
     <p>Pour plus d’informations sur la sécurité, voir les références suivantes :</p>
     
     <ul>
     
     <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
     <li product="flash">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
     
    <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
     
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:LoaderContext"><apiName>LoaderContext</apiName><shortdesc>
 La classe LoaderContext fournit des options pour le chargement des fichiers SWF et autres médias à l’aide de la classe Loader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe LoaderContext fournit des options pour le chargement des fichiers SWF et autres médias à l’aide de la classe Loader. La classe LoaderContext est utilisée en tant que paramètre de <codeph>context</codeph> dans les méthodes <codeph>load()</codeph> et <codeph>loadBytes()</codeph> de la classe Loader.
 
 <p>Lors du chargement des fichiers SWF avec la méthode <codeph>Loader.load()</codeph>, vous devez prendre deux décisions : dans quel domaine de sécurité le fichier SWF doit-il être placé et dans quel domaine d’application au sein de ce domaine de sécurité ? Pour plus de détails sur ces choix, voir les sections des propriétés <codeph>applicationDomain</codeph> et <codeph>securityDomain</codeph>.</p>
 
 <p>Lors du chargement d’un fichier SWF avec la méthode <codeph>Loader.loadBytes()</codeph>, vous devez effectuer le même choix de domaine d’application comme pour <codeph>Loader.load()</codeph>, mais il n’est pas nécessaire de spécifier un domaine de sécurité, dans la mesure où <codeph>Loader.loadBytes()</codeph> place toujours le fichier SWF qui est chargé dans le domaine de sécurité du fichier SWF en cours de chargement.</p>
 
 <p>Lors du chargement des images (JPEG, GIF ou PNG) et non pas de fichiers SWF, il n’est pas nécessaire de spécifier un domaine de sécurité ou un domaine d’application, dans la mesure où ces concepts n’ont de sens que pour les fichiers SWF. Par contre, une seule décision est nécessaire : avez-vous besoin d’un accès programmé aux pixels de l’image chargée ? Dans l’affirmative, voir la propriété <codeph>checkPolicyFile. </codeph> Si vous souhaitez appliquer le dégroupage lors du chargement d’une image, utilisez la classe JPEGLoaderContext plutôt que la classe LoaderContext.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link><link href="flash.system.xml#LoaderContext/checkPolicyFile"><linktext>flash.system.LoaderContext.checkPolicyFile</linktext></link><link href="flash.system.xml#LoaderContext/securityDomain"><linktext>flash.system.LoaderContext.securityDomain</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links><apiConstructor id="flash.system:LoaderContext:LoaderContext"><apiName>LoaderContext</apiName><shortdesc>
     Crée un objet LoaderContext avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Spécifie s’il est nécessaire de vérifier l’existence d’un fichier de régulation d’URL avant le chargement de l’objet.
     
     </apiDesc></apiParam><apiParam><apiItemName>applicationDomain</apiItemName><apiOperationClassifier>flash.system:ApplicationDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Spécifie l’objet ApplicationDomain à utiliser pour un objet Loader.
     
     </apiDesc></apiParam><apiParam><apiItemName>securityDomain</apiItemName><apiOperationClassifier>flash.system:SecurityDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Spécifie l’objet SecurityDomain à utiliser pour un objet Loader.
     
	 <p><i>Remarque :</i> le contenu du sandbox de sécurité de l’application air ne peut pas charger le contenu d’autres sandboxes dans son SecurityDomain.</p>
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un objet LoaderContext avec les paramètres spécifiés. Pour compléter les détails de ces paramètres, voir les descriptions des propriétés de cette classe.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links></apiConstructor><apiValue id="flash.system:LoaderContext:allowLoadBytesCodeExecution"><apiName>allowLoadBytesCodeExecution</apiName><shortdesc>
	 Spécifie si vous pouvez utiliser la méthode loadBytes() d’un objet Loader pour charger le contenu avec un code exécutable, tel qu’un fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si vous pouvez utiliser la méthode <codeph>loadBytes()</codeph> d’un objet Loader pour charger le contenu avec un code exécutable, tel qu’un fichier SWF. Avec sa propriété définie sur <codeph>false</codeph> (par défaut), la méthode <codeph>loadBytes()</codeph> est limitée aux opérations sûres, telles que le chargement d’images.
 	 
	 <p>Dans le contenu AIR dans le sandbox de l’application, la valeur par défaut est <codeph>false</codeph>. Dans le contenu hors application, la valeur par défaut est <codeph>true</codeph>.</p>
	 
	 <p><b>Remarque :</b> cette API sera probablement remplacée par une version future de AIR. Lorsque ceci aura lieu, vous devrez ajuster le code afin d’utiliser la nouvelle API et recompiler avant de distribuer une application pour la nouvelle version de AIR.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link></related-links></apiValue><apiValue id="flash.system:LoaderContext:applicationDomain"><apiName>applicationDomain</apiName><shortdesc>
	 Spécifie le domaine d’application à utiliser pour la méthode Loader.load() ou Loader.loadBytes().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>null</apiData><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le domaine d’application à utiliser pour la méthode <codeph>Loader.load()</codeph> ou <codeph>Loader.loadBytes()</codeph>. Utilisez cette propriété uniquement lors du chargement d’un fichier SWF écrit dans ActionScript 3.0 (et non pas une image ou un fichier SWF écrit au format ActionScript 1.0 ou ActionScript 2.0).
	 
	 <p>Tout domaine de sécurité est divisé en un ou plusieurs domaines d’application, représentés par les objets ApplicationDomain. Les domaines d’application n’ont pas de rôle de sécurité ; ils servent à gérer les unités de code ActionScript qui doivent coopérer. Si vous chargez un fichier SWF provenant d’un autre domaine, puis autorisez son placement dans un domaine de sécurité distinct, vous ne pouvez pas contrôler le domaine d’application dans lequel le ficher SWF est placé. Si vous avez spécifié un domaine d’application, ce choix sera ignoré. Cependant, si vous chargez un fichier SWF dans votre propre domaine de sécurité, soit parce que le fichier SWF provient de votre domaine, soit parce que vous l’importez dans votre domaine de sécurité, puis vous pouvez contrôler le domaine d’application du fichier SWF chargé.</p>
	 
	 <p>Vous devez transmettre le domaine d’application à partir de votre propre domaine de sécurité dans <codeph>LoaderContext.applicationDomain</codeph>. Toute tentative de transmission d’un domaine d’application à partir de tout autre domaine de sécurité renvoie une exception <codeph>SecurityError</codeph>.</p>
	 
	 <p>Vous disposez de quatre choix concernant le type de propriété <codeph>ApplicationDomain</codeph> à utiliser :</p>
	 
	 <ul>
	 <li><b>Enfant du domaine d’application du chargeur.</b> La valeur par défaut. Vous pouvez représenter de façon explicite ce choix avec la syntaxe <codeph>new ApplicationDomain(ApplicationDomain.currentDomain)</codeph>. Ceci permet au fichier SWF d’utiliser les classes parent de façon directe, par exemple en écrivant <codeph>new MyClassDefinedInParent()</codeph>. Le parent, cependant, ne permet pas d’utiliser cette syntaxe. Si le parent souhaite utiliser les classes de l’enfant, il doit appeler <codeph>ApplicationDomain.getDefinition()</codeph> pour les extraire. L’avantage de ce choix est que, si l’enfant définit une classe du même nom que la classe qui est déjà définie par le parent, aucune erreur ne se produit ; l’enfant hérite simplement de la définition de cette classe à partir de son parent et toute définition de l’enfant qui entraîne un conflit reste inutilisée, sauf si l’enfant ou le parent appelle la méthode <codeph>ApplicationDomain.getDefinition()</codeph> pour l’extraire.</li>
	 
	 <li><b>Domaine d’application de la classe loader.</b> Employez ce domaine d’application lorsque vous utilisez <codeph>ApplicationDomain.currentDomain</codeph>. Une fois le chargement terminé, le parent et l’enfant peuvent exploiter leurs classes respectives de façon directe. Si l’enfant tente de définir une classe avec le même nom que celle déjà définie par le parent, la classe du parent est utilisée et celle de l’enfant est ignorée.</li>
	 
	 <li><b>Enfant du domaine d’application du système.</b> Utilisez ce domaine d’application lors de l’utilisation de <codeph>new ApplicationDomain(null)</codeph>. Cette opération permet de distinguer les objets de chargement des objets chargés, afin de définir des versions distinctes des classes du même nom, sans conflit ou problèmes de priorité. Seule la méthode <codeph>ApplicationDomain.getDefinition()</codeph> permet aux deux parties de voir les classes de l’autre.</li>
	 
	 <li><b>Enfant d’un autre domaine d’application.</b> De façon occasionnelle, vous pouvez avoir à faire à une hiérarchie de domaines d’application plus complexe. Vous pouvez charger un fichier SWF dans un domaine d’application à partir de votre propre domaine de sécurité. Par exemple, <codeph>new ApplicationDomain(ApplicationDomain.currentDomain.parentDomain.parentDomain)</codeph> charge un fichier SWF dans un nouvel enfant du grand-parent du domaine actuel.</li>
	 </ul>
	 
	 <p>Une fois le chargement terminé, les deux parties (en cours de chargement ou chargées) peuvent avoir à rechercher leur propre domaine d’application, ou le domaine d’application de l’autre partie, afin d’appeler <codeph>ApplicationDomain.getDefinition()</codeph>. Chaque partie peut extraire une référence vers son propre domaine d’application à l’aide de <codeph>ApplicationDomain.currentDomain</codeph>. Le fichier SWF de chargement peut extraire une référence au domaine d’application du fichier SWF à l’aide de <codeph>Loader.contentLoaderInfo.applicationDomain</codeph>. Si le fichier SWF a identifié son mode de chargement, il peut retrouver l’objet ApplicationDomain du fichier SWF en cours de chargement. Par exemple, si l’enfant a été chargé à l’aide de la méthode par défaut, il peut déterminer le domaine d’application du fichier SWF à l’aide de <codeph>ApplicationDomain.currentDomain.parentDomain</codeph>.</p>
	 
	 <p>Pour plus d’informations, voir la section « Classe ApplicationDomain » du chapitre « Environnement du système client » du guide <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.system:LoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 Spécifie si l’application doit tenter de télécharger un fichier de régulation d’URL à partir du serveur de l’objet chargé avant de commencer à charger ce dernier.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si l’application doit tenter de télécharger un fichier de régulation d’URL à partir du serveur de l’objet chargé avant de commencer à charger ce dernier. Cet indicateur s’applique à la méthode <codeph>Loader.load()</codeph>, mais pas à la méthode <codeph>Loader.loadBytes()</codeph>.
	 
	 <p>Définissez cet indicateur sur <codeph>true</codeph> lorsque vous chargez une image (JPEG, GIF ou PNG) en dehors du domaine du fichier SWF qui procède à l’appel et lorsque vous pensez avoir besoin d’accéder au contenu de cette image à partir d’ActionScript. Parmi les exemples d’accès au contenu de l’image, citons le référencement de la propriété <codeph>Loader.content</codeph> pour obtenir un objet Bitmap et l’appel à la méthode <codeph>BitmapData.draw()</codeph> pour obtenir une copie des pixels de l’image chargée. Si vous tentez l’une de ces opérations sans avoir spécifié <codeph>checkPolicyFile</codeph> lors du chargement, vous risquez de subir une exception <codeph>SecurityError</codeph> dans la mesure où le fichier de régulation requis n’a pas encore été téléchargé.</p>
	 
	 <p>Lorsque vous appelez la méthode <codeph>Loader.load()</codeph> avec <codeph>LoaderContext.checkPolicyFile</codeph> défini sur <codeph>true</codeph>, l’application ne commence pas le téléchargement de l’objet spécifié dans <codeph>URLRequest.url</codeph> avant d’avoir téléchargé avec succès un fichier de régulation d’URL adéquat ou déterminé que ce fichier de régulation n’existe pas. Flash Player ou AIR analyse en premier lieu les fichiers de régulation ayant déjà été téléchargés, tente de télécharger tous les fichiers de stratégie en attente spécifiés lors des appels à la méthode <codeph>Security.loadPolicyFile()</codeph>, puis tente de télécharger un fichier de stratégie à l’emplacement par défaut, qui correspond à <codeph>URLRequest.url</codeph>, soit <codeph>/crossdomain.xml</codeph> sur le même serveur que <codeph>URLRequest.url</codeph>. Dans tous les cas, le fichier de régulation donné doit exister à <codeph>URLRequest.url</codeph>, sur la base de l’emplacement du fichier de régulation, et le fichier doit autoriser l’accès par le biais d’une ou plusieurs balises <codeph>&lt;allow-access-from></codeph>.</p>
	 
	 <p>Si vous définissez <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>, le téléchargement principal spécifié dans la méthode <codeph>Loader.load()</codeph> ne charge pas tant que le traitement du fichier de régulation n’est pas complètement terminé. Par conséquent, tant que le fichier de régulation requis existe, dès la réception des événements <codeph>ProgressEvent.PROGRESS</codeph> ou <codeph>Event.COMPLETE</codeph> à partir de la propriété <codeph>contentLoaderInfo</codeph> de votre objet Loader, le téléchargement du fichier de régulation se termine et vous pouvez procéder de façon sûre aux opérations qui nécessitent ce fichier de régulation.</p>
	 
	 <p>Si vous définissez <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> et si aucun fichier de régulation n’est trouvé, vous ne recevrez aucune indication d’erreur jusqu’à ce que vous tentiez une opération qui renvoie une exception <codeph>SecurityError</codeph>. Cependant, lorsque l’objet LoaderInfo distribue un événement <codeph>ProgressEvent.PROGRESS</codeph> ou <codeph>Event.COMPLETE</codeph>, vous pouvez déterminer si un fichier de régulation a été détecté en vérifiant la valeur de la propriété <codeph>LoaderInfo.childAllowsParent</codeph>.</p>
	 
	 <p>Si l’accès au niveau des pixels de l’image en cours de chargement est requis, vous ne pouvez pas définir la propriété <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph>. La vérification d’un fichier de stratégie dans ce cas est contre-productive, dans la mesure où elle risque de retarder le début de votre téléchargement et risque de consommer la bande passante du réseau de façon inutile.</p>
	 
	 <p>Evitez également de définir <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> si vous utilisez la méthode <codeph>Loader.load()</codeph> pour télécharger un fichier SWF. Ceci est dû au fait que les autorisations SWF vers SWF ne sont pas contrôlées par les fichiers de stratégies, mais par la méthode <codeph>Security.allowDomain()</codeph>, ce qui a pour conséquence que <codeph>checkPolicyFile</codeph> n’a pas d’effet lorsque vous chargez le fichier SWF. La vérification d’un fichier de stratégie dans ce cas est contre-productive, dans la mesure où elle risque de retarder le téléchargement du fichier SWF et risque de consommer la bande passante du réseau de façon inutile (Flash Player ou AIR ne peut pas déterminer si votre téléchargement principal sera un fichier SWF ou une image, dans la mesure où le téléchargement du fichier de régulation a lieu avant le téléchargement principal).</p>
	 
	 <p>Si vous téléchargez un objet à partir d’une URL qui peut utiliser des redirections HTTP côté serveur, servez-vous de <codeph>checkPolicyFile</codeph> avec précaution. Les fichiers de régulation sont toujours récupérés de l’URL initiale correspondante que vous spécifiez dans <codeph>URLRequest.url</codeph>. Si l’objet final provient d’une URL différente en conséquence de redirections HTTP, les fichiers de régulation initialement téléchargés peuvent ne pas être applicables à l’URL finale de l’objet, autrement dit l’URL à prendre en compte dans les décisions relatives à la sécurité. Si vous vous trouvez dans cette situation, le code examine la valeur <codeph>LoaderInfo.url</codeph> après avoir reçu un événement <codeph>ProgressEvent.PROGRESS</codeph> ou <codeph>Event.COMPLETE</codeph>, ce qui permet d’obtenir l’URL finale de l’objet. La méthode <codeph>Security.loadPolicyFile()</codeph> est ensuite appelée avec une URL de fichier de régulation basée sur l’URL finale de l’objet. La valeur de <codeph>LoaderInfo.childAllowsParent</codeph> est ensuite vérifiée régulièrement jusqu’à ce qu’elle ait la valeur <codeph>true</codeph>.</p>
	 
     	 <p>Il n’est pas nécessaire que vous définissiez cette propriété pour le contenu AIR s’exécutant dans le sandbox de l’application. Le contenu dans le sandbox de l’application AIR peut appeler la méthode <codeph>BitmapData.draw()</codeph> à l’aide de l’une des images chargées comme source. </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo/childAllowsParent"><linktext>flash.display.LoaderInfo.childAllowsParent</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue><apiValue id="flash.system:LoaderContext:securityDomain"><apiName>securityDomain</apiName><shortdesc>
	 Spécifie le domaine de sécurité à utiliser pour une opération Loader.load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>null</apiData><apiValueClassifier>flash.system:SecurityDomain</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le domaine de sécurité à utiliser pour une opération <codeph>Loader.load()</codeph>. Utilisez cette propriété uniquement lors du chargement d’un fichier SWF (et non pas une image).
	 
 	 <p>Le choix du domaine de sécurité n’a de sens que si vous chargez un fichier SWF pouvant provenir d’un autre domaine (un autre serveur) que le fichier SWF de chargement. Lorsque vous chargez un fichier SWF provenant de votre propre domaine, ce dernier est placé dans votre domaine de sécurité. Cependant, lorsque vous chargez un fichier SWF à partir d’un domaine différent, vous disposez de deux options. Vous pouvez autoriser le placement du fichier SWF chargé dans le domaine de sécurité « naturel », qui est différent de celui du fichier SWF de chargement. Il s’agit de la valeur par défaut. L’autre consiste à spécifier que vous souhaitez placer le fichier SWF chargé dans le même domaine de sécurité que le fichier SWF de chargement, en définissant <codeph>myLoaderContext.securityDomain</codeph> comme égal à <codeph>SecurityDomain.currentDomain</codeph>. Cette opération est appelée <i>chargement en vue de l’importation</i> et est équivalente, pour des raisons de sécurité, à la copie du fichier SWF chargé sur votre propre serveur et à son chargement à partir de cet endroit. Pour que le chargement en vue de l’importation réussisse, le serveur du fichier SWF doit disposer d’un fichier de régulation pour lequel le domaine de chargement du fichier SWF fait partie des domaines de confiance.</p>
	 
	 <p>Vous pouvez transmettre votre propre domaine de sécurité uniquement dans <codeph>LoaderContext.securityDomain</codeph>. Toute tentative de transmission vers un autre domaine de sécurité renvoie une exception <codeph>SecurityError</codeph>.</p>
	 
	 <p>Le contenu du sandbox de sécurité de l’application air ne peut pas charger le contenu d’autres sandboxes dans son SecurityDomain.</p>
     
	 <p>Pour plus d’informations, voir le chapitre « Sécurité » du manuel <i>Programmation avec ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:IMEConversionMode"><apiName>IMEConversionMode</apiName><shortdesc>
 Cette classe contient des constantes à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe contient des constantes à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. La définition de <codeph>conversionMode</codeph> sur <codeph>ALPHANUMERIC_FULL</codeph> ou <codeph>JAPANESE_KATAKANA_FULL</codeph> force le lecteur à utiliser une police complète, tandis que <codeph>ALPHANUMERIC_HALF</codeph> ou <codeph>JAPANESE_KATAKANA_HALF</codeph> utilise une police de demi-largeur.
 </apiDesc></apiClassifierDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links><apiValue id="flash.system:IMEConversionMode:ALPHANUMERIC_FULL"><apiName>ALPHANUMERIC_FULL</apiName><shortdesc>
	 La chaîne « ALPHANUMERIC_FULL » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ALPHANUMERIC_FULL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"ALPHANUMERIC_FULL"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur tous les IME. Utilisez la syntaxe <codeph>IMEConversionMode.ALPHANUMERIC_FULL</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:ALPHANUMERIC_HALF"><apiName>ALPHANUMERIC_HALF</apiName><shortdesc>
	 La chaîne « ALPHANUMERIC_HALF » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ALPHANUMERIC_HALF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"ALPHANUMERIC_HALF"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur tous les IME. Utilisez la syntaxe <codeph>IMEConversionMode.ALPHANUMERIC_HALF</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:CHINESE"><apiName>CHINESE</apiName><shortdesc>
	 La chaîne « CHINESE » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>CHINESE</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"CHINESE"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur les IME chinois simplifié et traditionnel. Utilisez la syntaxe <codeph>IMEConversionMode.CHINESE</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:JAPANESE_HIRAGANA"><apiName>JAPANESE_HIRAGANA</apiName><shortdesc>
	 La chaîne « JAPANESE_HIRAGANA » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>JAPANESE_HIRAGANA</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"JAPANESE_HIRAGANA"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur les IME japonais. Utilisez la syntaxe <codeph>IMEConversionMode.JAPANESE_HIRAGANA</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:JAPANESE_KATAKANA_FULL"><apiName>JAPANESE_KATAKANA_FULL</apiName><shortdesc>
	 La chaîne « JAPANESE_KATAKANA_FULL » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>JAPANESE_KATAKANA_FULL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"JAPANESE_KATAKANA_FULL"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur les IME japonais. Utilisez la syntaxe <codeph>IMEConversionMode.JAPANESE_KATAKANA_FULL</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:JAPANESE_KATAKANA_HALF"><apiName>JAPANESE_KATAKANA_HALF</apiName><shortdesc>
	 La chaîne « JAPANESE_KATAKANA_HALF » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>JAPANESE_KATAKANA_HALF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"JAPANESE_KATAKANA_HALF"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur les IME japonais. Utilisez la syntaxe <codeph>IMEConversionMode.JAPANESE_KATAKANA_HALF</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:KOREAN"><apiName>KOREAN</apiName><shortdesc>
	 La chaîne « KOREAN » à utiliser avec la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>KOREAN</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"KOREAN"</codeph> à utiliser avec la propriété <codeph>IME.conversionMode</codeph>. Cette constante est utilisée sur les IME coréens. Utilisez la syntaxe <codeph>IMEConversionMode.KOREAN</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:UNKNOWN"><apiName>UNKNOWN</apiName><shortdesc>
	 La chaîne « UNKNOWN » qui peut être renvoyée par un appel à la propriété IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>UNKNOWN</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 La chaîne <codeph>"UNKNOWN"</codeph> qui peut être renvoyée par un appel à la propriété <codeph>IME.conversionMode</codeph>. Cette valeur ne peut pas être définie et n’est renvoyée que si le lecteur n’est pas en mesure d’identifier l’IME actif. Utilisez la syntaxe <codeph>IMEConversionMode.UNKNOWN</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:SecurityPanel"><apiName>SecurityPanel</apiName><shortdesc>
 La classe SecurityPanel fournit des valeurs pour spécifier le panneau Paramètres de sécurité à afficher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe SecurityPanel fournit des valeurs pour spécifier le panneau Paramètres de sécurité à afficher.
 
 <p>Cette classe contient des constantes statiques qui sont utilisées avec la méthode <codeph>Security.showSettings()</codeph>. Vous ne pouvez pas créer d’occurrences de la classe SecurityPanel.</p>
 
 </apiDesc><example conref="examples\SecurityExample.as"> L’exemple suivant indique comment un événement <codeph>click</codeph> sur un objet Sprite permet d’afficher le panneau des paramètres de stockage local de la boîte de dialogue Paramètres de Flash Player. Un cadre orange est ajouté à la scène à l’aide de la méthode <codeph>draw()</codeph>. Dans <codeph>draw()</codeph>, un écouteur de l’événement <codeph>click</codeph> est ajouté sous le nom <codeph>clickHandler()</codeph>. Il répond aux événements <codeph>click</codeph> en ouvrant le panneau des paramètres de stockage local de Flash Player.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.*;
    import flash.system.Security;
    import flash.system.SecurityPanel;

    public class SecurityExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 100;

        public function SecurityExample() {
            draw();
        }

        private function draw():void {
            var child:Sprite = new Sprite();
            child.graphics.beginFill(bgColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            child.buttonMode = true;

            var label:TextField = new TextField();
            label.text = "settings";
            label.selectable = false;
            label.mouseEnabled = false;
            child.addChild(label);

            child.addEventListener(MouseEvent.CLICK, clickHandler);
            addChild(child);
        }

        private function clickHandler(event:MouseEvent):void {
            Security.showSettings(SecurityPanel.LOCAL_STORAGE);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.system:SecurityPanel:CAMERA"><apiName>CAMERA</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le panneau Caméra dans la section Paramètres de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.CAMERA, CAMERA
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>camera</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le panneau Caméra dans la section Paramètres de Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le dernier panneau activé par l’utilisateur avant la fermeture de Paramètres de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.DEFAULT, DEFAULT
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le dernier panneau activé par l’utilisateur avant la fermeture de Paramètres de Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:DISPLAY"><apiName>DISPLAY</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le panneau d’affichage dans la section Paramètres de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.DISPLAY, DISPLAY
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>display</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le panneau d’affichage dans la section Paramètres de Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:LOCAL_STORAGE"><apiName>LOCAL_STORAGE</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le panneau des paramètres de stockage local dans la section Paramètres de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.LOCAL_STORAGE, LOCAL_STORAGE
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localStorage</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le panneau des paramètres de stockage local dans la section Paramètres de Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:MICROPHONE"><apiName>MICROPHONE</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le panneau Microphone dans la section Paramètres de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.MICROPHONE, MICROPHONE
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>microphone</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le panneau Microphone dans la section Paramètres de Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:PRIVACY"><apiName>PRIVACY</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le panneau des paramètres de confidentialité dans la section Paramètres de Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.PRIVACY, PRIVACY
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>privacy</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le panneau des paramètres de confidentialité dans la section Paramètres de Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:SETTINGS_MANAGER"><apiName>SETTINGS_MANAGER</apiName><shortdesc>
	 Si transmis à Security.showSettings(), affiche le gestionnaire de paramètres (dans une fenêtre distincte du navigateur).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.SETTINGS_MANAGER, SETTINGS_MANAGER
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>settingsManager</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Si transmis à <codeph>Security.showSettings()</codeph>, affiche le gestionnaire de paramètres (dans une autre fenêtre du navigateur).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:JPEGLoaderContext"><apiName>JPEGLoaderContext</apiName><shortdesc>
 La classe JPEGLoaderContext comprend une propriété permettant d’activer un filtre de dégroupage lors du chargement d’une image JPEG.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.system:LoaderContext</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe JPEGLoaderContext comprend une propriété permettant d’activer un filtre de dégroupage lors du chargement d’une image JPEG. Le filtre de dégroupage améliore la qualité d’une image avec des paramètres de compression plus élevés en lissant les pixels voisins. Pour appliquer le dégroupage lors du chargement d’une image JPEG, créez un objet JPEGLoaderContext, puis définissez la propriété <codeph>deblockingFilter</codeph>. Utilisez ensuite le nom d’objet JPEGLoaderContext en tant que valeur du paramètre <codeph>context</codeph> de la méthode <codeph>load()</codeph> de l’objet Loader utilisée pour charger l’image.
 
 <p>La classe JPEGLoaderContext étend la classe LoaderContext. Définissez la propriété <codeph>checkPolicyFile</codeph> sur <codeph>true</codeph> si vous devez accéder par programmation aux pixels de l’image chargée (par exemple, si vous utilisez la méthode <codeph>BitmapData.draw</codeph>). La définition de la propriété <codeph>checkPolicyFile</codeph> n’est pas nécessaire pour le contenu AIR s’exécutant dans le sandbox de l’application.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiConstructor id="flash.system:JPEGLoaderContext:JPEGLoaderContext"><apiName>JPEGLoaderContext</apiName><shortdesc>
     Crée un objet JPEGLoaderContext avec les paramètres spécifiés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>deblockingFilter</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Spécifie la puissance du filtre de dégroupage. La valeur 1.0 applique un filtre de dégroupage puissant ; la valeur 0.0 désactive le filtre de dégroupage.
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique si Flash Player doit (true) ou non vérifier l’existence d’un fichier de régulation d’URL avant le chargement de l’objet.
     
     </apiDesc></apiParam><apiParam><apiItemName>applicationDomain</apiItemName><apiOperationClassifier>flash.system:ApplicationDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Spécifie l’objet ApplicationDomain à utiliser pour un objet Loader.
     
     </apiDesc></apiParam><apiParam><apiItemName>securityDomain</apiItemName><apiOperationClassifier>flash.system:SecurityDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Spécifie l’objet SecurityDomain à utiliser pour un objet Loader.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un objet JPEGLoaderContext avec les paramètres spécifiés. 
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links></apiConstructor><apiValue id="flash.system:JPEGLoaderContext:deblockingFilter"><apiName>deblockingFilter</apiName><shortdesc> 
	 Spécifie la puissance du filtre de dégroupage. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Spécifie la puissance du filtre de dégroupage. La valeur 1.0 applique un filtre de dégroupage puissant ; la valeur 0.0 désactive le filtre de dégroupage.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.system:ApplicationDomain"><apiName>ApplicationDomain</apiName><shortdesc>
 La classe ApplicationDomain est un conteneur pour les groupes discrets de définitions de classes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Security considerations for application domains are discussed in the 
 applicationDomain property entries of URLRequest and LoaderInfo. 
 
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe ApplicationDomain est un conteneur pour les groupes discrets de définitions de classes. Les domaines d’application sont utilisés pour créer des partitions entre les classes qui appartiennent au même domaine de sécurité. Ils autorisent des définitions multiples de la même classe et permettent aux enfants de recycler les définitions des parents.
 
 <p>Les domaines d’application sont utilisés lorsqu’un fichier SWF externe est chargé à l’aide de la classe Loader. Toutes les définitions ActionScript 3.0 du fichier SWF chargé sont stockées dans le domaine d’application, qui est spécifié par la propriété <codeph>applicationDomain</codeph> de l’objet LoaderContext que vous transmettez en tant que paramètre <codeph>context</codeph> de la méthode <codeph>load()</codeph> ou <codeph>loadBytes()</codeph> de l’objet Loader. L’objet LoaderInfo contient également une propriété <codeph>applicationDomain</codeph> en lecture seule.</p>
 
 <p>L’ensemble du code d’un fichier SWF est défini de sorte à exister dans un domaine d’application. Votre application principale s’exécute dans le domaine d’application en cours. Le domaine du système contient tous les domaines d’application, y compris le domaine en cours ; il contient donc toutes les classes Flash Player.</p>
 
 <p>A l’exception du domaine du système, tous les domaines d’application sont associés à un domaine du parent. Le domaine parent du domaine d’application de votre application principale est le domaine système. Les classes chargées ne sont définies que si leur parent ne les définit pas encore. Vous ne pouvez pas remplacer une définition de classe chargée par une définition plus récente.</p>
 
 <p>Pour obtenir des exemples de domaines d’application, voir le guide <i>Programmation avec ActionScript 3.0</i>.</p>
 
 <p>La fonction constructeur <codeph>ApplicationDomain()</codeph> permet de créer un objet ApplicationDomain.</p>
 
 </apiDesc><example conref="examples\ApplicationDomainExample.as"> L’exemple suivant illustre le chargement de la classe pendant la période d’exécution, ainsi que les différentes façons d’appeler les méthodes publiques d’une classe qui réside dans un autre fichier SWF.
 <p><b>Remarques :</b></p>
 <ul>
    <li>Dans la mesure où la classe ClassLoader charge un fichier SWF, la sécurité locale doit porter au niveau du système de fichiers.</li>
    <li>Pour exécuter cet exemple, vous devez disposer d’un fichier swf appelé RuntimeClasses.swf et présent dans le même dossier que le fichier ApplicationDomainExample.swf.</li>
 </ul>
 
 <p>Commencez par créer le fichier RuntimeClasses.swf à partir du code suivant :</p>
 <codeblock platform="actionscript">
 package {
   import flash.display.Sprite;
   public class RuntimeClasses extends Sprite
   {
     public function RuntimeClasses()
     {}
      
     public function greet():String {
       return("Hello World");
     }
   }
 }
 </codeblock>
 
 <p>Mettez ensuite en œuvre le code suivant :</p>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.errors.IllegalOperationError;
    import flash.events.Event;
    import flash.text.TextField;

    public class ApplicationDomainExample extends Sprite {
        private var loader:ClassLoader;
        private var tf:TextField = new TextField();

        public function ApplicationDomainExample() {
            addChild(tf);

            loader = new ClassLoader();
            loader.addEventListener(ClassLoader.LOAD_ERROR,loadErrorHandler);
            loader.addEventListener(ClassLoader.CLASS_LOADED,classLoadedHandler);
            loader.load("RuntimeClasses.swf");
        }

        private function loadErrorHandler(e:Event):void {
            tf.text = "Load failed";
            throw new IllegalOperationError("Cannot load the specified file.");
        }

        private function classLoadedHandler(e:Event):void {
            var runtimeClassRef:Class = loader.getClass("RuntimeClasses");
            var greeter:Object = new runtimeClassRef();

            tf.text = greeter.greet();
        }
    }
}

import flash.display.Loader;
import flash.errors.IllegalOperationError;
import flash.events.Event;
import flash.events.EventDispatcher;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.net.URLRequest;
import flash.system.ApplicationDomain;
import flash.system.LoaderContext;

class ClassLoader extends EventDispatcher {
    public static var CLASS_LOADED:String = "classLoaded";
    public static var LOAD_ERROR:String = "loadError";
    private var loader:Loader;
    private var swfLib:String;
    private var request:URLRequest;
    private var loadedClass:Class;

    public function ClassLoader() {

        loader = new Loader();
        loader.contentLoaderInfo.addEventListener(Event.COMPLETE,completeHandler);
        loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,ioErrorHandler);
        loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR,securityErrorHandler);
    }

    public function load(lib:String):void {
        swfLib = lib;
        request = new URLRequest(swfLib);
        var context:LoaderContext = new LoaderContext();
        context.applicationDomain=ApplicationDomain.currentDomain;
        loader.load(request,context);
    }

    public function getClass(className:String):Class {
        try {
            return loader.contentLoaderInfo.applicationDomain.getDefinition(className)  as  Class;
        } catch (e:Error) {
            throw new IllegalOperationError(className + " definition not found in " + swfLib);
        }
        return null;
    }

    private function completeHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.CLASS_LOADED));
    }

    private function ioErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }

    private function securityErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }
}
</codeblock></example><example conref="examples\ApplicationDomainExample.2.as"> Si plusieurs fichiers SWF contiennent des classes compilées sous le même nom, mais avec des mises en œuvre différentes, vous pouvez séparer les classes des fichiers SWF chargés de façon externe, comme l’illustre l’exemple suivant. Précédemment, le fichier SWF enfant devait utiliser <codeph>ApplicationDomain.currentDomain</codeph>. Dans ce cas, un nouvel objet <codeph>ApplicationDomain</codeph> est créé, de façon à ce que les propriétés et les méthodes de la classe <codeph>Greeter</codeph> qui sont chargées en deuxième ne remplacent pas les propriétés et les méthodes de la première classe <codeph>Greeter</codeph>. Vous pouvez tester ceci en modifiant la propriété <codeph>context.applicationDomain</codeph> de la méthode <codeph>load</codeph> de <codeph>ClassLoader</codeph>.
 <p><b>Remarques :</b></p>
 <ul>
    <li>Dans la mesure où la classe ClassLoader charge un fichier SWF, la sécurité locale doit porter au niveau du système de fichiers.</li>
    <li>Pour exécuter cet exemple, vous devez disposer de deux fichiers SWF appelés Greeter.swf et présents dans les dossiers « en » et « es ».</li>
 </ul>
 
 <p>Créez un fichier Greeter.as dans le répertoire « en » avec le code suivant :</p>
 <codeblock platform="actionscript">
 package {
    import flash.display.Sprite;
    public class Greeter extends Sprite
    {
        public function Greeter()
        {
        }
        
        public function greet():String {
            return("Good Morning");
        }
    }
 }
 </codeblock>
 <p>Créez ensuite un fichier Greeter.as similaire dans le répertoire « es » :</p>
 
 <codeblock platform="actionscript">
 package {
    import flash.display.Sprite;
    public class Greeter extends Sprite
    {
        public function Greeter()
        {
        }
        
        public function greet():String {
            return("Buenos Dias");
        }
    }
}
 </codeblock>
 
 <p>Compilez les fichiers SWF de ces deux dossiers, puis mettez en œuvre le code suivant :</p>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.errors.IllegalOperationError;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ApplicationDomainExample2 extends Sprite {
        private var spanishGreeterLoader:ClassLoader;
        private var englishGreeterLoader:ClassLoader;
        private var tf:TextField = new TextField();
        private var greetersLoaded:uint = 0;

        public function ApplicationDomainExample2() {
            tf.autoSize = TextFieldAutoSize.LEFT;
            addChild(tf);

            spanishGreeterLoader = new ClassLoader();
            spanishGreeterLoader.addEventListener(ClassLoader.LOAD_ERROR,loadErrorHandler);
            spanishGreeterLoader.addEventListener(ClassLoader.CLASS_LOADED,classLoadedHandler);
            spanishGreeterLoader.load("es/Greeter.swf");
            
            englishGreeterLoader = new ClassLoader();
            englishGreeterLoader.addEventListener(ClassLoader.LOAD_ERROR,loadErrorHandler);
            englishGreeterLoader.addEventListener(ClassLoader.CLASS_LOADED,classLoadedHandler);
            englishGreeterLoader.load("en/Greeter.swf");
        }

        private function loadErrorHandler(e:Event):void {
            tf.text = "Load failed";
            throw new IllegalOperationError("Cannot load the specified file.");
        }

        private function classLoadedHandler(e:Event):void {
            greetersLoaded++;
            if(greetersLoaded == 2) {
                greet();    
            }
        }
        
        private function greet():void {
            var spanishGreeter:Class = spanishGreeterLoader.getClass("Greeter");
            var englishGreeter:Class = englishGreeterLoader.getClass("Greeter");
            var greeter1 = new spanishGreeter();
            var greeter2 = new englishGreeter();
            
            tf.text = greeter1.greet() + "\n" + greeter2.greet();
        }
    }
}

import flash.display.Loader;
import flash.errors.IllegalOperationError;
import flash.events.Event;
import flash.events.EventDispatcher;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.net.URLRequest;
import flash.system.ApplicationDomain;
import flash.system.LoaderContext;

class ClassLoader extends EventDispatcher {
    public static var CLASS_LOADED:String = "classLoaded";
    public static var LOAD_ERROR:String = "loadError";
    private var loader:Loader;
    private var swfLib:String;
    private var request:URLRequest;
    private var loadedClass:Class;

    public function ClassLoader() {

        loader = new Loader();
        loader.contentLoaderInfo.addEventListener(Event.COMPLETE,completeHandler);
        loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,ioErrorHandler);
        loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR,securityErrorHandler);
    }

    public function load(lib:String):void {
        swfLib = lib;
        request = new URLRequest(swfLib);
        var context:LoaderContext = new LoaderContext();
//        context.applicationDomain = ApplicationDomain.currentDomain;
        context.applicationDomain = new ApplicationDomain();
        loader.load(request,context);
    }

    public function getClass(className:String):Class {
        try {
            return loader.contentLoaderInfo.applicationDomain.getDefinition(className)  as  Class;
        } catch (e:Error) {
            throw new IllegalOperationError(className + " definition not found in " + swfLib);
        }
        return null;
    }

    private function completeHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.CLASS_LOADED));
    }

    private function ioErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }

    private function securityErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><apiConstructor id="flash.system:ApplicationDomain:ApplicationDomain"><apiName>ApplicationDomain</apiName><shortdesc>
     Crée un domaine d’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>parentDomain</apiItemName><apiOperationClassifier>flash.system:ApplicationDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Si aucun domaine parent n’est transmis, ce domaine d’application prend le domaine système en tant que parent.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un domaine d’application.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.system:ApplicationDomain:getDefinition"><apiName>getDefinition</apiName><shortdesc>
     Extrait une définition publique du domaine d’application spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>throws SecurityError The definition belongs to a domain to which
     the calling code does not have access.
     
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Aucune définition publique n’existe sous le nom spécifié.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet associé à la définition.
     
     </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Le nom de la définition.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Extrait une définition publique du domaine d’application spécifié. La définition peut appartenir à une classe, un nom d’espace ou une fonction.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:ApplicationDomain:hasDefinition"><apiName>hasDefinition</apiName><shortdesc>
     Vérifie si une définition publique existe au sein du domaine d’application spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur <codeph>true</codeph> si la définition spécifiée existe, <codeph>false</codeph> dans le cas contraire.
     
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Le nom de la définition.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Vérifie si une définition publique existe au sein du domaine d’application spécifié. La définition peut appartenir à une classe, un nom d’espace ou une fonction.
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.system:ApplicationDomain:MIN_DOMAIN_MEMORY_LENGTH:get"><apiName>MIN_DOMAIN_MEMORY_LENGTH</apiName><shortdesc>
	 Extrait la longueur minimale de l’objet de mémoire qui doit être utilisée comme ApplicationDomain.domainMemory.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Extrait la longueur minimale de l’objet de mémoire qui doit être utilisée comme ApplicationDomain.domainMemory.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:ApplicationDomain:currentDomain:get"><apiName>currentDomain</apiName><shortdesc>
     Extrait le domaine d’application actuel où le code est en cours d’exécution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Question: Do you call System.currentDomain? or Loader.currentDomain or request.currentDomain?
     
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier></apiValueDef><apiDesc>
     Extrait le domaine d’application actuel où le code est en cours d’exécution.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:ApplicationDomain:domainMemory:get"><apiName>domainMemory</apiName><shortdesc>
	 Extrait et définit l’objet sur lequel les opérations de mémoire s’appliquent pour tout le domaine au sein de ce ApplicationDomain.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiTipTexts><apiTipText>
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Extrait et définit l’objet sur lequel les opérations de mémoire s’appliquent pour tout le domaine au sein de ce ApplicationDomain.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:ApplicationDomain:parentDomain:get"><apiName>parentDomain</apiName><shortdesc>
     Définit le domaine parent de ce domaine d’application.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier></apiValueDef><apiDesc>
     Définit le domaine parent de ce domaine d’application.
     
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.system:Capabilities"><apiName>Capabilities</apiName><shortdesc>
 La classe Capabilities fournit des propriétés qui décrivent le système et le lecteur qui hébergent un fichier SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 <ph platform="actionscript">La classe Capabilities fournit des propriétés qui décrivent le système et le lecteur qui hébergent un fichier SWF. Par exemple, l’écran d’un téléphone portable peut faire 100 pixels de large, en noir et blanc, alors qu’un écran d’ordinateur peut être de 1 000 pixels carrés et en couleurs. En utilisant l’objet Capabilities pour déterminer le type de périphérique de l’utilisateur, vous pouvez fournir du contenu à autant d’utilisateurs que possible. Lorsque vous connaissez les fonctionnalités du périphérique, vous pouvez demander au serveur d’envoyer les fichiers SWF ou demander au fichier SWF de modifier sa présentation.</ph> <ph platform="javascript">La classe Capabilities fournit des propriétés qui décrivent le système et le moteur d’exécution qui hébergent un contenu HTML (et SWF). En utilisant l’objet Capabilities pour déterminer le type d’ordinateur de l’utilisateur, vous pouvez fournir un contenu approprié à autant d’utilisateurs que possible. Lorsque vous connaissez les fonctionnalités de l’ordinateur, vous pouvez charger le contenu approprié ou utiliser le code pour modifier sa présentation.</ph>
 
 <p>Toutefois, certaines fonctionnalités d’Adobe AIR ne sont pas répertoriés comme propriétés de la classe Capabilities. Il s’agit de propriétés d’autres classes : </p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Propriété</entry><entry>Description</entry></row></thead><tbody><row>
 <entry><codeph>NativeApplication.supportsDockIcon</codeph></entry>
 <entry>Indique si le système d’exploitation prend en charge les icônes d’ancrage système. </entry>
 </row><row>
 <entry><codeph>NativeApplication.supportsMenu</codeph></entry>
 <entry>Indique si le système d’exploitation prend en charge une barre de menus d’application globale.</entry>
 </row><row>
 <entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry>
 <entry>Indique si le système d’exploitation prend en charge les icônes de la barre d’état système.</entry>
 </row><row>
 <entry><codeph>NativeWindow.supportsMenu</codeph></entry>
 <entry>Indique si le système d’exploitation prend en charge les menus de fenêtre. </entry>
 </row><row>
 <entry><codeph>NativeWindow.supportsTransparency</codeph></entry>
 <entry>Indique si le système d’exploitation prend en charge les fenêtres transparentes. </entry>
 </row></tbody></tgroup></adobetable>
 
 <p>N’utilisez <i>pas</i> les classes <codeph>Capabilities.os</codeph> ou <codeph>Capabilities.manufacturer</codeph> pour déterminer une fonctionnalité en fonction du système d’exploitation. Fonder une fonctionnalité sur le système d’exploitation est une mauvaise idée, car cela peut engendrer des problèmes si une application ne prend pas en compte tous les systèmes d’exploitation cible potentiels. En revanche, vous pouvez utiliser la propriété qui correspond à la fonctionnalité pour laquelle vous effectuez le test. </p>
 
 <p>Vous pouvez envoyer des informations sur les capacités, qui sont stockées dans la propriété <codeph>Capabilities.serverString</codeph> en tant que chaîne codée au format URL, à l’aide de la méthode HTTP <codeph>GET</codeph> ou <codeph>POST</codeph>. L’exemple suivant présente une chaîne serveur pour un ordinateur prenant en charge le format MP3 et disposant d’une résolution de 1 600 x 1 200 pixels, qui exécute Windows XP et où un IME est installé :</p>
 
 <pre>A=t&amp;SA=t&amp;SV=t&amp;EV=t&amp;MP3=t&amp;AE=t&amp;VE=t&amp;ACC=f&amp;PR=t&amp;SP=t&amp;
     SB=f&amp;DEB=t&amp;V=WIN%209%2C0%2C0%2C0&amp;M=Adobe%20Windows&amp;
     R=1600x1200&amp;DP=72&amp;COL=color&amp;AR=1.0&amp;OS=Windows%20XP&amp;
     L=en&amp;PT=External&amp;AVD=f&amp;LFD=f&amp;WD=f&amp;IME=t</pre>
 
 <p>Le tableau suivant dresse la liste des propriétés de la classe Capabilities et des chaînes serveur correspondantes :
 <adobetable class="innertable">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   
  
  
  
  
  
  
  
  
 <tgroup cols="2"><thead><row><entry align="left">Propriété de la classe Capabilities</entry><entry align="left">Chaîne serveur</entry></row></thead><tbody><row>
      <entry><codeph>avHardwareDisable</codeph></entry>
      <entry><codeph>AVD</codeph></entry>
  </row><row>
      <entry><codeph>hasAccessibility</codeph></entry>
      <entry><codeph>ACC</codeph></entry>
  </row><row>
      <entry><codeph>hasAudio</codeph></entry>
      <entry><codeph>A</codeph></entry>
  </row><row>
      <entry><codeph>hasAudioEncoder</codeph></entry>
      <entry><codeph>AE</codeph></entry>
  </row><row>
      <entry><codeph>hasEmbeddedVideo</codeph></entry>
      <entry><codeph>EV</codeph></entry>
  </row><row>
      <entry><codeph>hasIME</codeph></entry>
      <entry><codeph>IME</codeph></entry>
  </row><row>
      <entry><codeph>hasMP3</codeph></entry>
      <entry><codeph>MP3</codeph></entry>
  </row><row>
      <entry><codeph>hasPrinting</codeph></entry>
      <entry><codeph>PR</codeph></entry>
  </row><row>
      <entry><codeph>hasScreenBroadcast</codeph></entry>
      <entry><codeph>SB</codeph></entry>
  </row><row>
      <entry><codeph>hasScreenPlayback</codeph></entry>
      <entry><codeph>SP</codeph></entry>
  </row><row>
      <entry><codeph>hasStreamingAudio</codeph></entry>
      <entry><codeph>SA</codeph></entry>
  </row><row>
      <entry><codeph>hasStreamingVideo</codeph></entry>
      <entry><codeph>SV</codeph></entry>
  </row><row>
      <entry><codeph>hasTLS</codeph></entry>
      <entry><codeph>TLS</codeph></entry>
  </row><row>
      <entry><codeph>hasVideoEncoder</codeph></entry>
      <entry><codeph>VE</codeph></entry>
  </row><row>
      <entry><codeph>isDebugger</codeph></entry>
      <entry><codeph>DEB</codeph></entry>
  </row><row>
      <entry><codeph>language</codeph></entry>
      <entry><codeph>L</codeph></entry>
  </row><row>
      <entry><codeph>localFileReadDisable</codeph></entry>
      <entry><codeph>LFD</codeph></entry>
  </row><row>
      <entry><codeph>manufacturer</codeph></entry>
      <entry><codeph>M</codeph></entry>
  </row><row>
      <entry><codeph>maxLevelIDC</codeph></entry>
      <entry><codeph>ML</codeph></entry>
  </row><row>
      <entry><codeph>os</codeph></entry>
      <entry><codeph>OS</codeph></entry>
  </row><row>
      <entry><codeph>pixelAspectRatio</codeph></entry>
      <entry><codeph>AR</codeph></entry>
  </row><row>
      <entry><codeph>playerType</codeph></entry>
      <entry><codeph>PT</codeph></entry>
  </row><row>
      <entry><codeph>screenColor</codeph></entry>
      <entry><codeph>COL</codeph></entry>
  </row><row>
      <entry><codeph>screenDPI</codeph></entry>
      <entry><codeph>DP</codeph></entry>
  </row><row>
      <entry><codeph>screenResolutionX</codeph></entry>
      <entry><codeph>R</codeph></entry>
  </row><row>
      <entry><codeph>screenResolutionY</codeph></entry>
      <entry><codeph>R</codeph></entry>
  </row><row>
      <entry><codeph>version</codeph></entry>
      <entry><codeph>V</codeph></entry>
  </row></tbody></tgroup></adobetable>
 </p>
  
 <p>Il existe également une chaîne de serveur <codeph>WD</codeph> qui indique si lz mode sans fenêtre est désactivé. Le mode sans fenêtre peut être désactivé dans Flash Player en raison d’incompatibilité avec le navigateur Web ou d’un paramètre utilisateur dans le fichier mms.cfg. Il n’existe pas de propriété Capabilities équivalente. </p>
  
 <p>Toutes les propriétés de la classe Capabilities sont accessibles en lecture seule.</p>
 
 </apiDesc><example conref="examples\CapabilitiesExample.as"> L’exemple suivant renvoie simplement les valeurs de l’objet flash.system.Capabilities à l’aide de plusieurs appels de <codeph>trace()</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.system.Capabilities;

    public class CapabilitiesExample extends Sprite {
        public function CapabilitiesExample() {
            showCapabilities();
        }
        
        private function showCapabilities():void {
            trace("avHardwareDisable: " + Capabilities.avHardwareDisable);
            trace("hasAccessibility: " + Capabilities.hasAccessibility);
            trace("hasAudio: " + Capabilities.hasAudio);
            trace("hasAudioEncoder: " + Capabilities.hasAudioEncoder);
            trace("hasEmbeddedVideo: " + Capabilities.hasEmbeddedVideo);
            trace("hasMP3: " + Capabilities.hasMP3);
            trace("hasPrinting: " + Capabilities.hasPrinting);
            trace("hasScreenBroadcast: " + Capabilities.hasScreenBroadcast);
            trace("hasScreenPlayback: " + Capabilities.hasScreenPlayback);
            trace("hasStreamingAudio: " + Capabilities.hasStreamingAudio);
            trace("hasVideoEncoder: " + Capabilities.hasVideoEncoder);
            trace("isDebugger: " + Capabilities.isDebugger);
            trace("language: " + Capabilities.language);
            trace("localFileReadDisable: " + Capabilities.localFileReadDisable);
            trace("manufacturer: " + Capabilities.manufacturer);
            trace("os: " + Capabilities.os);
            trace("pixelAspectRatio: " + Capabilities.pixelAspectRatio);
            trace("playerType: " + Capabilities.playerType);
            trace("screenColor: " + Capabilities.screenColor);
            trace("screenDPI: " + Capabilities.screenDPI);
            trace("screenResolutionX: " + Capabilities.screenResolutionX);
            trace("screenResolutionY: " + Capabilities.screenResolutionY);
            trace("serverString: " + Capabilities.serverString);
            trace("version: " + Capabilities.version);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.system:Capabilities:avHardwareDisable:get"><apiName>avHardwareDisable</apiName><shortdesc>
     Spécifie si l’accès à la caméra et au microphone de l’utilisateur a été interdit (true) ou autorisé (false) par l’administrateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.avHardwareDisable, avHardwareDisable
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie si l’accès à la caméra et au microphone de l’utilisateur a été interdit (<codeph>true</codeph>) ou autorisé (<codeph>false</codeph>) par l’administrateur. La chaîne serveur est <codeph>AVD</codeph>.
     
	 <p>Pour le contenu dans Adobe AIR™, cette propriété s’applique uniquement au contenu des sandboxes de sécurité autres que le sandbox de sécurité de l’application. Le contenu du sandbox de sécurité de l’application peut toujours accéder au microphone et à la caméra de l’utilisateur.</p>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:cpuArchitecture:get"><apiName>cpuArchitecture</apiName><shortdesc>
	 Indique l’architecture UC actuelle de l’ordinateur. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata><asCustoms><oldexample>The following example traces the value of this read-only property:
	 <pre>
	 trace(Capabilities.cpuArchitecture);
	 </pre>
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique l’architecture UC actuelle de l’ordinateur. La propriété <codeph>cpuArchitecture</codeph> peut renvoyer les chaînes suivantes : <codeph>PowerPC</codeph>, <codeph>x86</codeph>, <codeph>SPARC</codeph> et <codeph>ARM</codeph>. La chaîne serveur est <codeph>ARCH</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasAccessibility:get"><apiName>hasAccessibility</apiName><shortdesc>
	 Spécifie si le système prend en charge (true) ou non (false) la communication avec des aides d’accessibilité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasAccessibility, hasAccessibility,
     accessibility
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système prend en charge (<codeph>true</codeph>) ou non (<codeph>false</codeph>) la communication avec des aides d’accessibilité. La chaîne serveur est <codeph>ACC</codeph>. 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/active"><linktext>flash.accessibility.Accessibility.active</linktext></link><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:hasAudio:get"><apiName>hasAudio</apiName><shortdesc>
	 Spécifie si le système est doté de fonctionnalités audio.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasAudio, hasAudio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système est doté de fonctionnalités audio. Cette propriété est toujours définie sur <codeph>true</codeph>. La chaîne serveur est <codeph>A</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasAudioEncoder:get"><apiName>hasAudioEncoder</apiName><shortdesc>
	 Spécifie si le système peut (true) ou ne peut pas (false) coder un flux audio continu, en provenance d’un microphone par exemple.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasAudioEncoder, hasAudioEncoder 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système peut (<codeph>true</codeph>) ou ne peut pas (<codeph>false</codeph>) coder un flux audio continu, en provenance d’un microphone par exemple. La chaîne serveur est <codeph>AE</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasEmbeddedVideo:get"><apiName>hasEmbeddedVideo</apiName><shortdesc>
	 Spécifie si le système prend en charge (true) ou non (false) la vidéo incorporée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasEmbeddedVideo, hasEmbeddedVideo, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système prend en charge (<codeph>true</codeph>) ou non (<codeph>false</codeph>) la vidéo incorporée. La chaîne serveur est <codeph>EV</codeph>. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasIME:get"><apiName>hasIME</apiName><shortdesc>
	 Spécifie si un IME est installé (true) ou non (false) sur le système.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasIME, hasIME, IME 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si un IME est installé (<codeph>true</codeph>) ou non (<codeph>false</codeph>) sur le système. La chaîne serveur est <codeph>IME</codeph>. 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME"><linktext>flash.system.IME</linktext></link><link href="flash.system.xml#System/ime"><linktext>flash.system.System.ime</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:hasMP3:get"><apiName>hasMP3</apiName><shortdesc>
	 Spécifie si le système est équipé (true) ou non (false) d’un décodeur MP3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasMP3, hasMP3, MP3, audio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système est équipé (<codeph>true</codeph>) ou non (<codeph>false</codeph>) d’un décodeur MP3. La chaîne serveur est <codeph>MP3</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasPrinting:get"><apiName>hasPrinting</apiName><shortdesc>
	 Spécifie si le système prend en charge (true) ou non (false) l’impression.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasPrinting, hasPrinting, printing 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système prend en charge (<codeph>true</codeph>) ou non (<codeph>false</codeph>) l’impression. La chaîne serveur est <codeph>PR</codeph>. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasScreenBroadcast:get"><apiName>hasScreenBroadcast</apiName><shortdesc>
	 Spécifie si le système prend en charge (true) ou non (false) le développement d’applications de diffusion à l’écran avec Flash Media Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasScreenBroadcast, hasScreenBroadcast
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système prend en charge (<codeph>true</codeph>) ou non (<codeph>false</codeph>) le développement d’applications de diffusion à l’écran avec Flash Media Server. La chaîne serveur est <codeph>SB</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasScreenPlayback:get"><apiName>hasScreenPlayback</apiName><shortdesc>
	 Spécifie si le système prend en charge (true) ou non (false) la lecture d’applications de diffusion à l’écran avec Flash Media Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasScreenPlayback, hasScreenPlayback
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système prend en charge (<codeph>true</codeph>) ou non (<codeph>false</codeph>) la lecture d’applications de diffusion à l’écran avec Flash Media Server. La chaîne serveur est <codeph>SP</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasStreamingAudio:get"><apiName>hasStreamingAudio</apiName><shortdesc>
	 Spécifie si le système peut (true) ou ne peut pas (false) lire des données audio en diffusion continue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasStreamingAudio, hasStreamingAudio, audio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système peut (<codeph>true</codeph>) ou ne peut pas (<codeph>false</codeph>) lire des données audio en diffusion continue. La chaîne serveur est <codeph>SA</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasStreamingVideo:get"><apiName>hasStreamingVideo</apiName><shortdesc>
	 Spécifie si le système peut (true) ou ne peut pas (false) lire des données vidéo en diffusion continue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasStreamingVideo, hasStreamingVideo, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système peut (<codeph>true</codeph>) ou ne peut pas (<codeph>false</codeph>) lire des données vidéo en diffusion continue. La chaîne serveur est <codeph>SV</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasTLS:get"><apiName>hasTLS</apiName><shortdesc>
	 Spécifie si le système prend en charge les sockets SSL natifs via NetConnection (true) ou non (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasTLS, hasTLS, TLS 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système prend en charge les sockets SSL natifs via NetConnection (<codeph>true</codeph>) ou non (<codeph>false</codeph>). La chaîne serveur est <codeph>TLS</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/connectedProxyType"><linktext>flash.net.NetConnection.connectedProxyType</linktext></link><link href="flash.net.xml#NetConnection/proxyType"><linktext>flash.net.NetConnection.proxyType</linktext></link><link href="flash.net.xml#NetConnection/usingTLS"><linktext>flash.net.NetConnection.usingTLS</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:hasVideoEncoder:get"><apiName>hasVideoEncoder</apiName><shortdesc>
	 Spécifie si le système peut (true) ou ne peut pas (false) coder un flux vidéo continu, en provenance d’une caméra Web par exemple.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasVideoEncoder, hasVideoEncoder
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le système peut (<codeph>true</codeph>) ou ne peut pas (<codeph>false</codeph>) coder un flux vidéo continu, en provenance d’une caméra Web par exemple. La chaîne serveur est <codeph>VE</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:isDebugger:get"><apiName>isDebugger</apiName><shortdesc> 
	 Spécifie si le système est une version débogueur (true) ou une version officielle (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.isDebugger, isDebugger, debugging 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 Spécifie si le système est une version débogueur (<codeph>true</codeph>) ou une version officielle (<codeph>false</codeph>). La chaîne serveur est <codeph>DEB</codeph>. Cette propriété est définie sur <codeph>true</codeph> lorsqu’elle est exécutée dans <ph platform="actionscript">la version débogueur de Flash Player ou </ph>l’application de débogage du lanceur AIR.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:isEmbeddedInAcrobat:get"><apiName>isEmbeddedInAcrobat</apiName><shortdesc>
     Indique si le lecteur est intégré dans un fichier PDF ouvert dans Acrobat 9.0 ou version ultérieure (true) ou non (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.127.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.isEmbeddedInAcrobat, isEmbeddedInAcrobat, Acrobat
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si le lecteur est intégré dans un fichier PDF ouvert dans Acrobat 9.0 ou version ultérieure (<codeph>true</codeph>) ou non (<codeph>false</codeph>).
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:language:get"><apiName>language</apiName><shortdesc>
	 Spécifie le code de langue du système sur lequel s’exécute le contenu.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.language, language
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le code de langue du système sur lequel s’exécute le contenu. La langue est spécifiée sous forme de code de langue à deux lettres minuscules conformément à ISO 639-1. Pour le Chinois, un code de pays à deux lettres majuscules, conformément à ISO 3166, permet de faire la distinction entre le Chinois traditionnel et le Chinois simplifié. Les codes de langue reposent sur les noms anglais de langue : par exemple, <codeph>hu</codeph> correspond au Hongrois (Hungarian).
     
     <p>Sur les systèmes en anglais, cette propriété renvoie uniquement le code de langue (<codeph>en</codeph>) et non pas le code du pays. Sur les systèmes Microsoft Windows, cette propriété renvoie la langue de l’interface utilisateur (UI), qui se rapporte à la langue utilisée pour les menus, boîtes de dialogue, messages d’erreur et fichiers d’aide. Le tableau suivant présente les valeurs possibles :
     
     <adobetable class="innertable">
     
     
     
     
     
         
         
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry align="left">Langue</entry><entry align="left">Valeur</entry></row></thead><tbody><row>
      <entry>Tchèque</entry>
      <entry><codeph>cs</codeph></entry>
     </row><row>
      <entry>Danois</entry>
      <entry><codeph>da</codeph></entry>
     </row><row>
      <entry>Néerlandais</entry>
      <entry><codeph>nl</codeph></entry>
     </row><row>
      <entry>Anglais</entry>
      <entry><codeph>fr</codeph></entry>
     </row><row>
      <entry>Finnois</entry>
      <entry><codeph>fi</codeph></entry>
     </row><row>
      <entry>Français</entry>
      <entry><codeph>fr</codeph></entry>
     </row><row>
      <entry>Allemand</entry>
      <entry><codeph>de</codeph></entry>
     </row><row>
      <entry>Hongrois</entry>
      <entry><codeph>hu</codeph></entry>
     </row><row>
      <entry>Italien</entry>
      <entry><codeph>it</codeph></entry>
     </row><row>
      <entry>Japonais</entry>
      <entry><codeph>ja</codeph></entry>
     </row><row>
      <entry>Coréen</entry>
      <entry><codeph>ko</codeph></entry>
     </row><row>
      <entry>Norvégien</entry>
      <entry><codeph>no</codeph></entry>
     </row><row>
      <entry>Autre/inconnu</entry>
      <entry><codeph>xu</codeph></entry>
     </row><row>
      <entry>Polonais</entry>
      <entry><codeph>pl</codeph></entry>
     </row><row>
      <entry>Portugais</entry>
      <entry><codeph>pt</codeph></entry>
     </row><row>
      <entry>Russe</entry>
      <entry><codeph>ru</codeph></entry>
     </row><row>
      <entry>Chinois simplifié</entry>
      <entry><codeph>zh-CN</codeph></entry>
     </row><row>
      <entry>Espagnol</entry>
      <entry><codeph>es</codeph></entry>
     </row><row>
      <entry>Suédois</entry>
      <entry><codeph>sv</codeph></entry>
     </row><row>
      <entry>Chinois traditionnel</entry>
      <entry><codeph>zh-TW</codeph></entry>
     </row><row>
      <entry>Turc</entry>
      <entry><codeph>tr</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>
	 
	 <p><i>Remarque :</i> la valeur de la propriété <codeph>Capabilities.language</codeph> est limitée aux valeurs possibles de cette liste. Du fait de cette restriction, les applications Adobe AIR doivent utiliser le premier élément du tableau <codeph>Capabilities.languages</codeph> pour connaître la langue d’interface utilisateur principale du système. </p>
	 
     <p>La chaîne serveur est <codeph>L</codeph>.</p>
     
     </apiDesc><example conref="examples\Capabilities_languageExample.as"> Dans l’exemple suivant, le contenu qui s’affiche dépend de la langue du système d’exploitation de l’utilisateur.
 
 <p>La propriété <codeph>Capabilities.language</codeph> renvoie le code de langue ISO 639-1 (dans l’exemple, « en » pour l’anglais). L’instruction <codeph>switch</codeph> vérifie le code de langue et définit le contenu du champ de texte <codeph>myTextField</codeph> sur un message d’accueil propre à la langue. Si le code de langue n’est pas pris en charge par l’exemple, la chaîne d’erreur par défaut est renvoyée.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.system.Capabilities;

    public class Capabilities_languageExample extends Sprite {

        public function Capabilities_languageExample()  {
            var myTextField:TextField = new TextField();         
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            var greetingEnglish:String = "Hello World";
            var greetingGerman:String = "Hallo Welt";
            var greetingFrench:String = "Bonjour Monde";
            var greetingSpanish:String = "Hola Mundo";

            var lang:String = Capabilities.language;
                         
            switch (lang) {
                case "en":
                    myTextField.text = greetingEnglish;
                    break;
                case "de":
                    myTextField.text = greetingGerman;
                    break;
                case "fr":
                    myTextField.text = greetingFrench;
                    break;
                case "es":
                    myTextField.text = greetingSpanish;
                    break;
                default:
                    myTextField.text = "Sorry your system's language is not supported at this time.";               
            }
             
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.system.xml#Capabilities/languages"><linktext>langues</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:languages:get"><apiName>languages</apiName><shortdesc>
	 Tableau de chaînes contenant des informations sur les langues de l’interface utilisateur que l’utilisateur préfère, telles que définies dans le système d’exploitation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Tableau de chaînes contenant des informations sur les langues de l’interface utilisateur que l’utilisateur préfère, telles que définies dans le système d’exploitation. Les chaînes contiennent des balises de langue (et des informations de zone et de script, le cas échéant) définies par RFC4646 (<xref href="http://www.ietf.org/rfc/rfc4646.txt" scope="external">http://www.ietf.org/rfc/rfc4646.txt</xref>) et utilisent le séparateur tiret (par exemple, <codeph>"en-US"</codeph> ou <codeph>"ja-JP"</codeph>). Les langues apparaissent dans le tableau par ordre de préférence, tel que déterminé par les paramètres du système d’exploitation. 
	 
	 <p>Les informations régionales renvoyées dans les chaînes de paramètres régionaux varient en fonction des systèmes d’exploitation. Un système d’exploitation peut renvoyer <codeph>"fr-fr"</codeph>, alors qu’un autre renvoyer simplement <codeph>"fr"</codeph>.</p>
	 
	 <p>La première entrée du tableau renvoyé possède généralement le même identifiant de langue principale que la propriété <codeph>Capabilities.language</codeph>. Par exemple, si <codeph>Capabilities.languages[0]</codeph> est définie sur <codeph>"en-US"</codeph>, la propriété <codeph>language</codeph> est définie sur <codeph>"en"</codeph>. Toutefois, si la propriété <codeph>Capabilities.language</codeph> est définie sur <codeph>"xu"</codeph> (spécifiant une langue inconnue), le premier élément de ce tableau diffère. Pour cette raison, la propriété <codeph>Capabilities.languages[0]</codeph> est en général plus précise que la propriété <codeph>Capabilities.language</codeph>.</p>
	 
	 <p>La chaîne serveur est <codeph>LS</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:localFileReadDisable:get"><apiName>localFileReadDisable</apiName><shortdesc>
     Spécifie si l’accès en lecture au disque dur de l’utilisateur a été interdit (true) ou autorisé (false) par l’administrateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.localFileReadDisable, localFileReadDisable
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie si l’accès en lecture au disque dur de l’utilisateur a été interdit (<codeph>true</codeph>) ou autorisé (<codeph>false</codeph>) par l’administrateur. Pour le contenu dans Adobe AIR, cette propriété s’applique uniquement au contenu des sandboxes de sécurité autres que le sandbox de sécurité de l’application (le contenu dans le sandbox de sécurité de l’application peut toujours lire à partir du système de fichiers). <ph platform="actionscript">Si la propriété est définie sur <codeph>true</codeph>, Flash Player ne peut pas lire de fichiers (y compris le premier fichier de démarrage de Flash Player) sur le disque dur de l’utilisateur.</ph> Si cette propriété est définie sur <codeph>true</codeph>, le contenu AIR situé en dehors du sandbox de sécurité de l’application ne peut pas lire de fichiers sur le disque dur de l’utilisateur. Par exemple, toute tentative de lecture d’un fichier sur le disque dur de l’utilisateur à l’aide des méthodes de chargement échoue si cette propriété est définie sur <codeph>true</codeph>.
	 
	 <p platform="actionscript">La lecture de bibliothèques partagées à l’exécution est également bloquée si cette propriété est définie sur <codeph>true</codeph> ; en revanche, la lecture d’objets partagés localement est autorisée, indépendamment de la valeur de cette propriété.</p>
	 
	 <p>La chaîne serveur est <codeph>LFD</codeph>.</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:manufacturer:get"><apiName>manufacturer</apiName><shortdesc>
	 Spécifie le fabricant de la version active de Flash Player ou du moteur d’exécution AIR, au format « Adobe OSName ».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.manufacturer, manufacturer
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le fabricant <ph platform="actionscript">de la version active de Flash Player ou </ph>du moteur d’exécution AIR, au format <codeph>"Adobe</codeph> <codeph><i>OSName</i>"</codeph>. La valeur de <codeph><i>NomSE</i></codeph> peut être "<codeph>Windows</codeph>", "<codeph>Macintosh</codeph>", "<codeph>Linux</codeph>" ou tout autre nom de système d’exploitation. La chaîne serveur est <codeph>M</codeph>.
     
	 <p>N’utilisez <i>pas</i> la classe <codeph>Capabilities.manufacturer</codeph> pour déterminer une fonctionnalité en fonction du système d’exploitation si une propriété de fonctionnalité plus spécifique existe. Fonder une fonctionnalité sur le système d’exploitation est une mauvaise idée, car cela peut engendrer des problèmes si une application ne prend pas en compte tous les systèmes d’exploitation cible potentiels. En revanche, vous pouvez utiliser la propriété qui correspond à la fonctionnalité pour laquelle vous effectuez le test. Pour plus d’informations, voir la description de la classe Capabilities.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:maxLevelIDC:get"><apiName>maxLevelIDC</apiName><shortdesc>
     Récupère le plus haut niveau IDC H.264 pris en charge par matériel du client.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.maxLevelIDC, maxLevelIDC
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Récupère le plus haut niveau IDC H.264 pris en charge par matériel du client. L’exécution des fichiers multimédia à ce niveau est garantie. Toutefois, il est possible que leur qualité ne soit pas optimale s’ils sont exécutés au niveau le plus élevé. Cette propriété est utile pour les serveurs qui tentent de cibler les capacités d’un client. Grâce à cette propriété, un serveur peut déterminer le niveau de vidéo à envoyer au client.
     
     <p>La chaîne serveur est <codeph>ML</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:os:get"><apiName>os</apiName><shortdesc>
     Spécifie le système d’exploitation actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.os, os
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie le système d’exploitation actuel. La propriété <codeph>os</codeph> peut renvoyer les chaînes suivantes : "<codeph>Windows XP</codeph>", "<codeph>Windows 2000</codeph>", "<codeph>Windows NT</codeph>", "<codeph>Windows 98/ME</codeph>", "<codeph>Windows 95</codeph>", "<codeph>Windows CE</codeph>" (disponible uniquement en version Flash Player SDK et pas en version de bureau), <codeph>"Linux"</codeph> et <codeph>"Mac OS X.Y.Z"</codeph> (où X.Y.Z correspond au numéro de version, par exemple, <codeph>Mac OS 10.5.2</codeph>). La chaîne serveur est <codeph>OS</codeph>.
     
	 <p>N’utilisez <i>pas</i> la classe <codeph>Capabilities.os</codeph> pour déterminer une fonctionnalité en fonction du système d’exploitation si une propriété de fonctionnalité plus spécifique existe. Fonder une fonctionnalité sur le système d’exploitation est une mauvaise idée, car cela peut engendrer des problèmes si une application ne prend pas en compte tous les systèmes d’exploitation cible potentiels. En revanche, vous pouvez utiliser la propriété qui correspond à la fonctionnalité pour laquelle vous effectuez le test. Pour plus d’informations, voir la description de la classe Capabilities.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:pixelAspectRatio:get"><apiName>pixelAspectRatio</apiName><shortdesc> 
     Indique les proportions en pixel de l’écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.pixelAspectRatio, pixelAspectRatio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
     Indique les proportions en pixel de l’écran. La chaîne serveur est <codeph>AR</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:playerType:get"><apiName>playerType</apiName><shortdesc>
	 Spécifie le type d’environnement d’exécution.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.playerType, playerType
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie le type d’environnement d’exécution. Cette propriété peut avoir l’une des valeurs suivantes :
	 
     <ul>
	   <li><codeph>"ActiveX"</codeph> pour le contrôle ActiveX de Flash Player utilisé par Microsoft Internet Explorer</li>
	   <li><codeph>"Desktop"</codeph> pour le moteur d’exécution Adobe AIR (sauf pour le contenu SWF chargé par une page HTML, ayant <codeph>Capabilities.playerType</codeph> réglé sur <codeph>"PlugIn"</codeph>)</li>
	   <li><codeph>"External"</codeph><ph outputclass="flashonly"> pour le lecteur Flash Player autonome ou en mode test</ph></li>
	   <li><codeph>"PlugIn"</codeph> pour le module du navigateur Flash Player (et pour le contenu SWF chargé par une page HTML dans une application AIR)</li>
       <li><codeph>"StandAlone"</codeph> pour le lecteur Flash Player autonome.</li>
     </ul>
     <p>La chaîne serveur est <codeph>PT</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenColor:get"><apiName>screenColor</apiName><shortdesc>
     Permet de spécifier la couleur de l’écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenColor, screenColor
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Permet de spécifier la couleur de l’écran. Cette propriété peut avoir la valeur "<codeph>color</codeph>", "<codeph>gray</codeph>" (pour niveaux de gris) ou "<codeph>bw</codeph>" (pour le noir et blanc). La chaîne serveur est <codeph>COL</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenDPI:get"><apiName>screenDPI</apiName><shortdesc>
     Spécifie la résolution en points par pouce (dpi) de l’écran, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenDPI, screenDPI
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie la résolution en points par pouce (dpi) de l’écran, en pixels. La chaîne serveur est <codeph>DP</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenResolutionX:get"><apiName>screenResolutionX</apiName><shortdesc>
     Spécifie la résolution horizontale maximale de l’écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenResolutionX, screenResolutionY
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Spécifie la résolution horizontale maximale de l’écran. La chaîne serveur est <codeph>R</codeph> (qui renvoie la largeur et la hauteur de l’écran). Cette propriété n’est pas mise à jour avec une résolution d’écran utilisateur mais indique uniquement la résolution au moment du démarrage <ph platform="actionscript">de Flash Player ou </ph>d’une application Adobe AIR. De plus, la valeur indique uniquement le moniteur principal.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenResolutionY:get"><apiName>screenResolutionY</apiName><shortdesc> 
     Spécifie la résolution verticale maximale de l’écran.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenResolutionY, screenResolutionY
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
     Spécifie la résolution verticale maximale de l’écran. La chaîne serveur est <codeph>R</codeph> (qui renvoie la largeur et la hauteur de l’écran). Cette propriété n’est pas mise à jour avec une résolution d’écran utilisateur mais indique uniquement la résolution au moment du démarrage <ph platform="actionscript">de Flash Player ou </ph>d’une application Adobe AIR. De plus, la valeur indique uniquement le moniteur principal.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:serverString:get"><apiName>serverString</apiName><shortdesc> 
     Chaîne codée au format URL qui spécifie des valeurs pour chaque propriété Capabilities.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.serverString, serverString
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
     Chaîne codée au format URL qui spécifie des valeurs pour chaque propriété Capabilities.
	 
     <p>L’exemple suivant illustre une chaîne de code URL :
     <pre>A=t&amp;SA=t&amp;SV=t&amp;EV=t&amp;MP3=t&amp;AE=t&amp;VE=t&amp;ACC=f&amp;PR=t&amp;SP=t&amp;
     SB=f&amp;DEB=t&amp;V=WIN%208%2C5%2C0%2C208&amp;M=Adobe%20Windows&amp;
     R=1600x1200&amp;DP=72&amp;COL=color&amp;AR=1.0&amp;OS=Windows%20XP&amp;
     L=en&amp;PT=External&amp;AVD=f&amp;LFD=f&amp;WD=f</pre></p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:supports32BitProcesses:get"><apiName>supports32BitProcesses</apiName><shortdesc>
     Indique si le système prend en charge l’exécution des traitements 32 bits. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata><asCustoms><oldexample>The following example traces the value of this read-only property:
     <pre>
     trace(Capabilities.supports32BitProcesses);
     </pre>
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si le système prend en charge l’exécution des traitements 32 bits. La chaîne serveur est <codeph>PR32</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:supports64BitProcesses:get"><apiName>supports64BitProcesses</apiName><shortdesc>
     Indique si le système prend en charge l’exécution des traitements 64 bits.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata><asCustoms><oldexample>The following example traces the value of this read-only property:
     <pre>
     trace(Capabilities.supports64BitProcesses);
     </pre>
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Indique si le système prend en charge l’exécution des traitements 64 bits. La chaîne serveur est <codeph>PR64</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:version:get"><apiName>version</apiName><shortdesc> 
	 Indique les informations de version et de plateforme de Flash Player ou Adobe&amp;#xAE; AIR&amp;#xAE;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.version, version
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	 Indique les informations de version et de plateforme de Flash Player ou Adobe<sup>®</sup> AIR<sup>®</sup>. Le format du numéro de version est : <i>platform majorVersion, minorVersion, buildNumber, internalBuildNumber</i>. Les valeurs possibles pour <i>platform</i> sont <codeph>WIN</codeph>, <codeph>MAC</codeph> et <codeph>LNX</codeph>. Vous trouverez ci-dessous quelques exemples d’informations sur la version :
	 
     <pre>
     WIN 9,0,0,0  // Flash Player 9 for Windows
     MAC 7,0,25,0   // Flash Player 7 for Macintosh
	 LNX 9,0,115,0  // Flash Player 9 for Linux
     </pre>
	 
	 <p>N’utilisez <i>pas</i> la classe <codeph>Capabilities.version</codeph> pour déterminer une fonctionnalité en fonction du système d’exploitation si une propriété de fonctionnalité plus spécifique existe. Fonder une fonctionnalité sur le système d’exploitation est une mauvaise idée, car cela peut engendrer des problèmes si une application ne prend pas en compte tous les systèmes d’exploitation cible potentiels. En revanche, vous pouvez utiliser la propriété qui correspond à la fonctionnalité pour laquelle vous effectuez le test. Pour plus d’informations, voir la description de la classe Capabilities.</p>
	 
     <p>La chaîne serveur est <codeph>V</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiOperation id="globalOperation:flash.system:fscommand"><apiName>fscommand</apiName><shortdesc>
 Permet au fichier SWF de communiquer avec Flash Player ou le programme hébergeant Flash Player, tel qu’un navigateur Web.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample><p>In the following example, the <code>fscommand()</code> function sets Flash Player to 
 scale the SWF file to the full monitor screen size when the <code>fullscreen_btn</code> button or 
 <code>unfullscreen_btn</code> is released:</p>
 
 <pre>this.fullscreen_btn.onRelease = function() {
   fscommand("fullscreen", true);
 };
 this.unfullscreen_btn.onRelease = function() {
   fscommand("fullscreen", false);
 };
 </pre>
 
 <p>The following example uses the <code>fscommand()</code> function applied to a button in Flash to 
 open a JavaScript message box in an HTML page. The message itself is sent to JavaScript as the 
 <code>fscommand</code> parameter. </p>
 
 <p>You must add a function to the HTML page that contains the SWF file. This function, 
 <code><i>myDocument</i></code><code>_DoFSCommand</code>, sits in the HTML page and waits for an 
 <code>fscommand()</code> function in Flash. When an <code>fscommand</code> is triggered in Flash 
 (for example, when a user presses the button), the <code>command</code> and <code>args</code> strings 
 are passed to the <code><i>myDocument</i></code><code>_DoFSCommand </code>function. You can use the 
 passed strings in your JavaScript or VBScript code in any way you like. In this example, the function 
 contains a conditional <code>if</code> statement that checks to see if the command string is 
 "<code>messagebox</code>". If it is, a JavaScript alert box (or "message box") opens 
 and displays the contents of the <code>args</code> string.</p>
 
 <pre>function myDocument_DoFSCommand(command, args) {
   if (command == "messagebox") {
      alert(args);
   }
 
 </pre>
 
 <p>In the Flash document, add the <code>fscommand()</code> function to a button:</p>
 
 <pre>fscommand("messagebox", "This is a message box called from within Flash.")
 </pre>
 
 <p>You can also use expressions for the <code>fscommand()</code> function and parameters, as in the 
 following example:</p>
 
 <pre>fscommand("messagebox", "Hello, " + name + ", welcome to our website!")
 </pre>
 
 <p>To test the SWF file, select File > Publish Preview > HTML.</p>
 
 <p><strong>Note: </strong>If you publish your SWF file using the Flash with FSCommand template in the 
 HTML 
 tab of the Publish Settings dialog box, the <code>myDocument_DoFSCommand</code> function is inserted 
 automatically. The SWF file's <code>NAME</code> and <code>ID</code> attributes will be the filename. 
 For example, for the file myDocument.fla, the attributes would be set to <code>myDocument</code>.</p>
 
  
  </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la fonction n’est pas appelée en réponse à l’action d’un utilisateur, notamment à un événement de type clic de souris ou pression de touche.
 
 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne transmise à l’application hôte ou commande passée à Flash Player.
 
 </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Chaîne transmise à l’application hôte ou valeur passée à Flash Player.
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Permet au fichier SWF de communiquer avec Flash Player ou le programme hébergeant Flash Player, tel qu’un navigateur Web. La fonction <codeph>fscommand()</codeph> permet également de transmettre des messages à Director ou à Visual Basic (VB), Visual C++ et autres programmes ayant recours aux contrôles ActiveX.
 
  
 <p>La fonction <codeph>fscommand()</codeph> permet à un fichier SWF de communiquer avec un script dans une page Web. Cependant, l’accès au script est contrôlé par le paramètre <codeph>allowScriptAccess</codeph> de la page Web (vous définissez cet attribut dans le code HTML intégré au fichier SWF, par exemple dans la balise <codeph>PARAM</codeph> pour Internet Explorer ou dans la balise <codeph>EMBED</codeph> pour Netscape). </p>
  <ul>
  
  <li> Lorsque <codeph>allowScriptAccess</codeph>est défini sur <codeph>"sameDomain"</codeph> (par défaut), les scripts sont uniquement autorisés à partir des fichiers SWF qui se trouvent dans le même domaine que la page Web. </li> 
  <li> Lorsque <codeph>allowScriptAccess</codeph> est défini sur <codeph>"always"</codeph>, le fichier SWF peut communiquer avec la page HTML dans laquelle il est intégré, même s’il ne provient pas du même domaine que la page HTML. </li>
  <li>Lorsque l’attribut <codeph>allowScriptAccess</codeph> est défini sur <codeph>"never"</codeph>, le fichier SWF ne peut communiquer avec aucune page HTML. Notez que l’utilisation de cette valeur est déconseillée, voire inutile si vous n’envoyez pas de fichiers SWF non approuvés depuis votre propre domaine. Si vous devez envoyer des fichiers SWF non approuvés, Adobe vous conseille de créer un sous-domaine distinct et d’y placer l’ensemble du contenu non approuvé. </li>
 </ul>
 
 <p>Vous pouvez éviter qu’un fichier SWF n’utilise cette méthode en définissant le paramètre <codeph>allowNetworking</codeph> des balises <codeph>object</codeph> et <codeph>embed</codeph> dans la page HTML qui héberge le contenu SWF. </p>
 
 <p>La fonction <codeph>fscommand()</codeph> n’est pas autorisée si le fichier SWF appelant se trouve dans le système de fichiers local ou dans le Sandbox du réseau local et si la page HTML contenant ce fichier se trouve dans un Sandbox non approuvé.</p>
 
 <p>Pour plus de détails sur la sécurité, voir les sections suivantes :</p>
 <ul>
 
 <li class="flexonly">Le chapitre sur la sécurité <xref href="http://www.adobe.com/go/flex3_progAS3_security_fr" scope="external"/> dans le manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires sur LiveDocs</li>
 <li class="flashonly">Le <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_fr" scope="external"> chapitre relatif à la sécurité</xref> du manuel <i>Programmation avec ActionScript 3.0</i> et les derniers commentaires disponibles dans LiveDocs</li>
 
 <li>La rubrique du Centre des développeurs de Flash Player : <xref href="http://www.adobe.com/go/devnet_security_fr" scope="external">Sécurité</xref></li>
 </ul>
 
 <p>Usage 1 : pour utiliser <codeph>fscommand()</codeph> afin d’envoyer un message à Flash Player, vous devez utiliser les commandes et les paramètres prédéfinis. Le tableau suivant indique les valeurs que vous pouvez spécifier pour les paramètres <codeph>command</codeph> et <codeph>args</codeph> de la fonction <codeph>fscommand()</codeph>. Ces valeurs contrôlent les fichiers SWF lus par Flash Player, y compris les projections (une <i>projection</i> est un fichier SWF enregistré sous un format permettant de l’exécuter en tant qu’application autonome, pouvant être lue sans Flash Player).</p>
 
              <adobetable class="innertable">
                  
                  
                  
                  
                  
                  
                  
                  
              <tgroup cols="3"><thead><row><entry>Commande</entry><entry>Parameter (args)</entry><entry>Rôle</entry></row></thead><tbody><row>
                      <entry><codeph>quit</codeph></entry>
                      <entry>Aucun</entry>
                      <entry>Ferme la projection.</entry>
                  </row><row>
                      <entry><codeph>fullscreen</codeph></entry>
                      <entry><codeph>true</codeph> ou <codeph>false</codeph></entry>
                      <entry>Spécifiez <codeph>true</codeph> pour exécuter Flash Player en mode plein écran. Spécifiez <codeph>false</codeph> pour rétablir le mode d’affichage normal du menu.</entry>
                  </row><row>
                      <entry><codeph>allowscale</codeph></entry> 
                      <entry><codeph>true</codeph> ou <codeph>false</codeph></entry>
                      <entry>Si vous spécifiez <codeph>false</codeph>, le lecteur affiche toujours la taille d’origine du fichier SWF, sans le redimensionner. Si vous spécifiez <codeph>true</codeph>, le fichier SWF adopte l’échelle 100 % du lecteur.</entry>
                  </row><row>
                      <entry><codeph>showmenu</codeph></entry>
                      <entry><codeph>true</codeph> ou <codeph>false</codeph></entry>
                      <entry>Spécifiez <codeph>true</codeph> pour activer le jeu complet d’éléments de menu contextuel. Spécifiez <codeph>false</codeph> pour masquer tous les éléments de menu contextuel, à l’exception de A propos de Flash Player et Paramètres.</entry>
                  </row><row>
                      <entry><codeph>exec</codeph></entry>
                      <entry>Chemin de l’application </entry>
                      <entry>Exécute une application depuis la projection.</entry>
                  </row><row>
                      <entry><codeph>trapallkeys</codeph></entry>
                      <entry><codeph>true</codeph> ou <codeph>false</codeph></entry>
                      <entry>Spécifiez <codeph>true</codeph> pour envoyer tous les événements de touche, y compris les touches de raccourci, au gestionnaire <codeph>onClipEvent(keyDown/keyUp)</codeph> de Flash Player. </entry>
                  </row></tbody></tgroup></adobetable>
 <p>Toutes les commandes qui figurent dans le tableau ne sont pas disponibles dans toutes les applications : 
 <ul>
     <li>Aucune des commandes n’est disponible dans les lecteurs Web.</li> 
     <li>Toutes les commandes sont disponibles dans les applications autonomes, telles que les projections.</li>
     <li>Seuls <codeph>allowscale</codeph> et <codeph>exec</codeph> sont disponibles sur les lecteurs de tests d’animation.</li>
 </ul>
 </p>
 
 <p>La commande <codeph>exec</codeph> ne peut contenir que les caractères compris entre A et Z, a et z, 0 et 9, les caractères point (.) et souligné (_). La commande <codeph>exec</codeph> ne s’exécute que dans le sous-répertoire fscommand. En d’autres termes, si vous utilisez la commande <codeph>exec</codeph> pour appeler une application, cette application doit résider dans un sous-répertoire appelé fscommand. La commande <codeph>exec</codeph> ne fonctionne qu’à partir d’un fichier de projection Flash.</p>
 
 <p>Usage 2 : pour utiliser <codeph>fscommand()</codeph> pour envoyer un message à un langage de programmation tel que JavaScript dans un navigateur Web, vous pouvez transmettre deux paramètres avec les paramètres <codeph>command</codeph> et <codeph>args</codeph>. Ces paramètres peuvent être des chaînes ou des expressions. Ils sont utilisés dans une fonction JavaScript qui gère ou <i>intercepte</i> la fonction <codeph>fscommand()</codeph>. </p>
 
 <p>Dans un navigateur Web, la fonction <codeph>fscommand()</codeph> appelle la fonction JavaScript <codeph>moviename_DoFScommand</codeph>, résidant dans la page Web qui contient le fichier SWF. Pour <codeph>moviename</codeph>, attribuez le nom de l’objet Flash utilisé pour l’attribut <codeph>NAME</codeph> de la balise <codeph>EMBED</codeph> ou la propriété ID de la balise <codeph>OBJECT</codeph>. Si vous attribuez le nom « myMovie » au fichier SWF, la fonction JavaScript <codeph>myMovie_DoFScommand</codeph> est appelée. </p>
 
 <p>Dans la page Web qui contient le fichier SWF, définissez l’attribut <codeph>allowScriptAccess</codeph> de manière à autoriser, ou non, le fichier SWF à accéder à la page Web, selon les descriptions ci-dessus (vous définissez cet attribut dans le code HTML intégré au fichier SWF, par exemple dans la balise <codeph>PARAM</codeph> pour Internet Explorer ou dans la balise <codeph>EMBED</codeph> pour Netscape). </p>
 
 <p>Dans Flash Player versions 10 et ultérieures s’exécutant dans un navigateur, il est possible que vous ne puissiez pas utiliser cette méthode par programmation pour ouvrir une fenêtre contextuelle. Certains navigateurs (et configurations de navigateur) peuvent bloquer les fenêtres contextuelles ; il n’est donc pas possible de garantir l’ouverture de toutes les fenêtres contextuelles. Toutefois, pour un résultat optimal, utilisez cette méthode pour ouvrir une fenêtre contextuelle uniquement dans le code qui s’exécute comme conséquence directe de l’action d’un utilisateur (par exemple, un événement de type clic de souris ou pression de touche).</p>
 
 <p>Usage 3 : la fonction <codeph>fscommand()</codeph> peut envoyer des messages à Director (Macromedia Director d’Adobe). Ces messages sont interprétés par Lingo (le langage de script de Director) comme des chaînes, des événements ou un code Lingo exécutable. Si le message est une chaîne ou un événement, vous devez écrire le code Lingo devant recevoir le message de la fonction <codeph>fscommand()</codeph> et exécuter une action dans Director. Pour plus d’informations, voir le centre de support de Director à l’adresse <xref href="http://www.adobe.com/support/director/" scope="external">www.adobe.com/support/director/</xref>.</p>
 
 <p>Usage 4 : dans VisualBasic, Visual C++ et dans d’autres programmes ayant recours aux contrôles ActiveX, la fonction <codeph>fscommand()</codeph> envoie un événement VB avec deux chaînes qui peut être traité dans le langage de programmation de l’environnement. Pour plus d’informations, utilisez les mots clés « méthode Flash » pour effectuer une recherche dans le centre de support de Flash à l’adresse <xref href="http://www.adobe.com/support/flash/" scope="external">www.adobe.com/support/flash/</xref>.</p>
 <p><b>Remarque :</b> la classe ExternalInterface offre de meilleures fonctionnalités de communication entre JavaScript et ActionScript (Utilisation 2), et entre ActionScript et VisualBasic, Visual C++ ou d’autres programmes pouvant héberger des contrôles ActiveX (Utilisation 4). Vous devriez continuer à utiliser la fonction <codeph>fscommand()</codeph> pour envoyer des messages à Flash Player (Utilisation 1) et à Director (Utilisation 3).</p>
 
 </apiDesc><example conref="examples\FSCommandExample.as"> L’exemple suivant indique comment <codeph>fscommand()</codeph> peut être utilisé pour forcer Flash Player à activer le mode plein écran et bloquer toute tentative de redimensionnement. Un cadre orange est ensuite ajouté à la scène à l’aide de <codeph>draw()</codeph>. Dans <codeph>draw()</codeph>, un écouteur de l’événement <codeph>click</codeph> est ajouté sous le nom <codeph>clickHandler()</codeph>, qui répond aux événements <codeph>click</codeph> en forçant Flash Player à se fermer en effectuant un autre appel à <codeph>fscommand().</codeph>
 
 <p><b>Remarque : </b> cet exemple doit être exécuté avec la version autonome de Flash Player et non pas dans un navigateur Web.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.system.fscommand;
    import flash.events.MouseEvent;

    public class FSCommandExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 100;

        public function FSCommandExample() {
            fscommand("fullscreen", "true");
            fscommand("allowscale", "false");
            draw();
        }

        private function clickHandler(event:MouseEvent):void {
            fscommand("quit");
            trace("clickHandler");
        }

        private function draw():void {
            var child:Sprite = new Sprite();
            child.graphics.beginFill(bgColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            child.buttonMode = true;
            addEventListener(MouseEvent.CLICK, clickHandler);

            var label:TextField = new TextField();
            label.text = "quit";
            label.selectable = false;
            label.mouseEnabled = false;
            child.addChild(label);

            addChild(child);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiClassifier id="flash.system:IME"><apiName>IME</apiName><shortdesc>
 La classe IME permet de manipuler directement l’IME (Input Method Editor) du système d’exploitation sous lequel l’application Flash Player s’exécute sur l’ordinateur client.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Permet de manipuler l’éditeur de méthodes d’entrée (IME) du système d’exploitation.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe IME permet de manipuler directement l’IME (Input Method Editor) du système d’exploitation sous lequel l’application Flash Player s’exécute sur l’ordinateur client. Vous pouvez déterminer si un IME est installé, qu’il soit activé ou non, et quel IME est activé. Vous pouvez désactiver ou activer l’IME dans l’application Flash Player et exécuter d’autres fonctions limitées, selon votre système d’exploitation.
 
 <p>Les IME permettent aux utilisateurs de taper des caractères de texte non ASCII multioctet pour les langues orientales, tels que le Chinois, le Japonais et le Coréen. Pour plus d’informations sur la manipulation des IME, voir la documentation du système d’exploitation pour lequel vous développez des applications. Les sites Web suivants comportent des ressources supplémentaires :
 <ul>
   <li><xref href="http://www.microsoft.com/globaldev/default.mspx" scope="external">http://www.microsoft.com/globaldev/default.mspx</xref></li>
   <li><xref href="http://developer.apple.com/documentation/" scope="external">http://developer.apple.com/documentation/</xref></li>
   <li><xref href="http://java.sun.com" scope="external">http://java.sun.com</xref></li>
  </ul>
  </p>
 
 <p>Si aucun IME n’est actif sur l’ordinateur de l’utilisateur, tout appel aux méthodes ou propriétés IME, autres que <codeph>Capabilities.hasIME</codeph>, échoue. Lorsque vous activez manuellement un IME, les appels ActionScript suivants aux méthodes et aux propriétés IME fonctionnent comme prévu. Par exemple, si vous utilisez un IME japonais, ce dernier doit être activé avant tout appel à la méthode ou la propriété IME.</p>
 
 <p>Le tableau ci-après, indique les plates-formes prises en charge par cette classe :</p>
 
 
 <adobetable class="innertable">
  
 
 
 
  
  
 
  
  
 
 <tgroup cols="4"><thead><row><entry>Fonction</entry><entry>Windows</entry><entry>Mac OSX</entry><entry>Linux</entry></row></thead><tbody><row>
    <entry>Détermine si l’IME est installé : <codeph>Capabilities.hasIME</codeph></entry>
    <entry>Oui</entry>
    <entry>Oui</entry>
    <entry>Oui</entry>
  </row><row>
    <entry>Active ou désactive l’IME : <codeph>IME.enabled</codeph></entry>
    <entry>Oui</entry>
    <entry>Oui</entry>
    <entry>Oui</entry>
  </row><row>
    <entry>Détermine si l’IME est activé ou désactivé : <codeph>IME.enabled</codeph></entry>
    <entry>Oui</entry>
    <entry>Oui</entry>
    <entry>Oui</entry>
  </row><row>
    <entry>Lit ou définit le mode de conversion IME : <codeph>IME.conversionMode</codeph></entry>
    <entry>Oui</entry>
    <entry>Oui ~~~~</entry>
    <entry>Non</entry>
  </row><row>
    <entry>Transmet à l’IME la chaîne à convertir : <codeph>IME.setCompositionString()</codeph></entry>
    <entry>Oui ~~</entry>
    <entry>Non</entry>
    <entry>Non</entry>
  </row><row>
    <entry>Lit dans l’IME la chaîne d’origine avant sa conversion : <codeph>System.ime.addEventListener()</codeph></entry>
    <entry>Oui ~~</entry>
    <entry>Non</entry>
    <entry>Non</entry>
  </row><row>
    <entry>Transmet la requête de conversion à IME : <codeph>IME.doConversion()</codeph></entry>
    <entry>Oui ~~</entry>
    <entry>Non</entry>
    <entry>Non</entry>
  </row></tbody></tgroup></adobetable>
 
 <p>~~ Ces opérations ne sont pas toutes prises en charge par tous les IME de Windows. Seul l’IME japonais les prend toutes en charge.</p>
 
 <p>~~~~ Sur le Macintosh, seul l’IME japonais prend en charge ces méthodes. Les IME d’éditeurs tiers ne les prennent pas en charge.</p>
 <p>La version ActionScript 3.0 de cette classe ne prend pas Macintosh Classic en charge.</p>
 
 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.system:IME_flash.events.IMEEvent.IME_COMPOSITION_imeComposition"><apiName>imeComposition</apiName><shortdesc>
 Distribué lorsqu’un utilisateur a terminé une composition IME et la chaîne de lecture est disponible.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IMEEvent.IME_COMPOSITION</apiEventType><adobeApiEventClassifier>flash.events.IMEEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur a terminé une composition IME et la chaîne de lecture est disponible. Les IME sont généralement utilisées pour saisir du texte exprimé sous forme d’idéogrammes et non pas de lettres, comme pare exemple le Japonais, le Chinois et le Coréen.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.system:IME:compositionAbandoned"><apiName>compositionAbandoned</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="flash.system:IME:compositionSelectionChanged"><apiName>compositionSelectionChanged</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>start</apiItemName><apiOperationClassifier>int</apiOperationClassifier></apiParam><apiParam><apiItemName>end</apiItemName><apiOperationClassifier>int</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="flash.system:IME:doConversion"><apiName>doConversion</apiName><shortdesc>
	 Demande à l’IME de sélectionner le premier candidat pour la chaîne de composition actuelle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>L’appel n’a pas réussi.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Demande à l’IME de sélectionner le premier candidat pour la chaîne de composition actuelle.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:IME:setCompositionString"><apiName>setCompositionString</apiName><shortdesc>
	 Définit la chaîne de composition IME.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need some examples of valid values for the param composition.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>L’appel n’a pas réussi.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>composition</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>La chaîne à envoyer à l’IME.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit la chaîne de composition IME. Lorsque cette chaîne est définie, l’utilisateur peut sélectionner des candidats IME avant d’enregistrer le résultat dans le champ de texte ayant actuellement le focus.
	 <p>Si aucun texte n’a le focus, cette méthode échoue et renvoie une erreur.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.system:IME:conversionMode:get"><apiName>conversionMode</apiName><shortdesc>
	 Mode de conversion de l’IME actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Une tentative de définition a échoué.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Mode de conversion de l’IME actuel. Les valeurs possibles sont les constantes de chaîne de mode IME qui spécifient le mode de conversion :
	 <ul>
	 	<li><codeph>ALPHANUMERIC_FULL</codeph></li>
	 	<li><codeph>ALPHANUMERIC_HALF</codeph></li>
 	 	<li><codeph>CHINESE</codeph></li>
	 	<li><codeph>JAPANESE_HIRAGANA</codeph></li>
	 	<li><codeph>JAPANESE_KATAKANA_FULL</codeph></li>
	 	<li><codeph>JAPANESE_KATAKANA_HALF</codeph></li>
 	 	<li><codeph>KOREAN</codeph></li>
	  <li><codeph>UNKNOWN</codeph> (valeur en lecture seule, ne peut pas être définie)</li>
	 </ul>
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IMEConversionMode/ALPHANUMERIC_FULL"><linktext>flash.system.IMEConversionMode.ALPHANUMERIC_FULL</linktext></link><link href="flash.system.xml#IMEConversionMode/ALPHANUMERIC_HALF"><linktext>flash.system.IMEConversionMode.ALPHANUMERIC_HALF</linktext></link><link href="flash.system.xml#IMEConversionMode/CHINESE"><linktext>flash.system.IMEConversionMode.CHINESE</linktext></link><link href="flash.system.xml#IMEConversionMode/JAPANESE_HIRAGANA"><linktext>flash.system.IMEConversionMode.JAPANESE_HIRAGANA</linktext></link><link href="flash.system.xml#IMEConversionMode/JAPANESE_KATAKANA_FULL"><linktext>flash.system.IMEConversionMode.JAPANESE_KATAKANA_FULL</linktext></link><link href="flash.system.xml#IMEConversionMode/JAPANESE_KATAKANA_HALF"><linktext>flash.system.IMEConversionMode.JAPANESE_KATAKANA_HALF</linktext></link><link href="flash.system.xml#IMEConversionMode/KOREAN"><linktext>flash.system.IMEConversionMode.KOREAN</linktext></link><link href="flash.system.xml#IMEConversionMode/UNKNOWN"><linktext>flash.system.IMEConversionMode.UNKNOWN</linktext></link></related-links></apiValue><apiValue id="flash.system:IME:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Spécifie si l’IME système est activé (true) ou désactivé (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Une tentative de définition a échoué.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Spécifie si l’IME système est activé (<codeph>true</codeph>) ou désactivé (<codeph>false</codeph>). Un IME activé effectue une entrée multi-octets ; un IME désactivé effectue une entrée alphanumérique. 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.system:System"><apiName>System</apiName><shortdesc>
 La classe System regroupe les propriétés liées à certaines opérations qui ont lieu sur l’ordinateur de l’utilisateur, telles que des opérations avec des objets partagés, des paramètres locaux pour les caméras et les microphones, ainsi que l’utilisation du Presse-papiers.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>System, System object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe System regroupe les propriétés liées à certaines opérations qui ont lieu sur l’ordinateur de l’utilisateur, telles que <ph platform="actionscript">des opérations avec des objets partagés, des paramètres locaux pour les caméras et les microphones ainsi que </ph>l’utilisation du Presse-papiers.
 
 <p>Vous trouverez des propriétés et des méthodes supplémentaires dans d’autres classes au sein du package flash.system : les classes Capabilities<ph platform="actionscript">, IME</ph> et Security.</p>
 
 <p>Cette classe contient uniquement des méthodes et des propriétés statiques. Vous ne pouvez pas créer d’occurrences de la classe Système.</p>
 
 </apiDesc><example conref="examples\SystemExample.as"> L’exemple suivant indique comment copier des informations sur la mémoire totale du système dans le Presse-papiers à l’aide d’un appel à <codeph>System.totalMemory</codeph> imbriqué dans un appel à la méthode <codeph>System.setClipboard()</codeph>.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.system.System;

    public class SystemExample extends Sprite {
        public function SystemExample() {
            System.setClipboard("System.totalMemory: " + System.totalMemory);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.system.xml#Security"><linktext>flash.system.Security</linktext></link><link href="flash.events.xml#IMEEvent"><linktext>flash.events.IMEEvent</linktext></link></related-links><apiOperation id="flash.system:System:disposeXML"><apiName>disposeXML</apiName><shortdesc>
	 Rend l’objet XML spécifié immédiatement disponible à des fins de nettoyage. </shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>node</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Référence XML qui doit être mise à disposition à des fins de nettoyage. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Rend l’objet XML spécifié immédiatement disponible à des fins de nettoyage. Cette méthode supprime les connexions parent et enfant entre tous les nœuds pour le nœud XML spécifié. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:System:exit"><apiName>exit</apiName><shortdesc> 
     Ferme Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata><asCustoms><keyword>System, System.exit(), exit()             
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur à transmettre au système d’exploitation. Généralement, si le processus se ferme normalement, la valeur est 0.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc> 
     Ferme Flash Player.
	 
     <p><i>Pour la version débogueur de Flash Player autonome uniquement.</i></p> 
	 
     <p>Les applications AIR doivent appeler la méthode <codeph>NativeApplication.exit()</codeph> pour quitter l’application.</p> 
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/exit()"><linktext>flash.desktop.NativeApplication.exit()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:System:gc"><apiName>gc</apiName><shortdesc>
     Impose le processus de nettoyage de la mémoire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Impose le processus de nettoyage de la mémoire.
	 
     <p><ph platform="actionscript"><i>Pour la version débogueur de Flash Player et des applications AIR uniquement.</i></ph> Dans une application AIR, la méthode <codeph>System.gc()</codeph> est activée uniquement dans le contenu s’exécutant dans l’application de débogage du lanceur AIR (ADL) ou, dans une application installée, dans le contenu du sandbox de sécurité de l’application.</p>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:System:pause"><apiName>pause</apiName><shortdesc> 
     Interrompt Flash Player ou l’application de débogage du lanceur AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata><asCustoms><keyword>System, System.pause(), pause()   
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
     Interrompt <ph platform="actionscript">Flash Player ou </ph>l’application de débogage du lanceur AIR. Après avoir appelé cette méthode, l’application cesse toute activité, sauf la distribution des événements Socket.
	 
     <p platform="actionscript"><i>Pour la version débogueur de Flash Player ou l’application de débogage du lanceur AIR.</i></p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#System/resume()"><linktext>resume()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:System:resume"><apiName>resume</apiName><shortdesc> 
     Redémarre l’application après avoir appelé System.pause().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata><asCustoms><keyword>System, System.resume(), resume()        
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
     Redémarre l’application après avoir appelé <codeph>System.pause()</codeph>.
	 
     <p platform="actionscript"><i>Pour la version débogueur de Flash Player ou l’application de débogage du lanceur AIR.</i></p>  
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#System/pause()"><linktext>pause()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:System:setClipboard"><apiName>setClipboard</apiName><shortdesc>
	 Remplace le contenu du presse-papiers par une chaîne de texte spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>System.setClipboard, setClipboard
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>string</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne au format texte seul à placer dans le Presse-papiers du système, remplaçant son contenu actuel (si ce dernier contient déjà des données).
	 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Remplace le contenu du presse-papiers par une chaîne de texte spécifiée.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Remplace le contenu du presse-papiers par une chaîne de texte spécifiée. Cette méthode fonctionne à partir de n’importe quel contexte de sécurité lorsqu’elle est appelée suite à un événement utilisateur (clic de souris ou pression de touche, par exemple).
	 
	 <p>Cette méthode est fournie pour le contenu SWF s’exécutant dans Flash Player 9. Elle permet uniquement d’ajouter le contenu de la chaîne au Presse-papiers. Le contenu de Flash Player 10 et le contenu dans le sandbox de sécurité de l’application d’une application AIR peuvent appeler la méthode <codeph>Clipboard.setData()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard"><linktext>flash.desktop.Clipboard</linktext></link></related-links></apiOperation><apiValue id="flash.system:System:ime:get"><apiName>ime</apiName><shortdesc>
	 L’IME système installé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:IME</apiValueClassifier></apiValueDef><apiDesc>
	 L’IME système installé. Pour s’inscrire aux événements imeComposition, appelez <codeph>addEventListener()</codeph> sur cette occurrence.
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IMEConversionMode"><linktext>IMEConversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:System:totalMemory:get"><apiName>totalMemory</apiName><shortdesc>
     Quantité de mémoire (en octets) actuellement utilisée par Adobe&amp;#xAE; Flash&amp;#xAE; Player ou Adobe&amp;#xAE; AIR&amp;#xAE;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Add better description and example, unless private, in which case mark as "at"private.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     La quantité de mémoire (en octets) actuellement utilisée par <ph platform="actionscript">Adobe<sup>®</sup> Flash<sup>®</sup> Player ou </ph>Adobe<sup>®</sup> AIR<sup>®</sup>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:System:useCodePage:get"><apiName>useCodePage</apiName><shortdesc>
	 Une valeur booléenne qui indique la page de code à utiliser pour interpréter des fichiers texte externes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>System.useCodepage, useCodepage, Unicode, code page
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Une valeur booléenne qui indique la page de code à utiliser pour interpréter des fichiers texte externes. Lorsque la propriété est définie sur <codeph>false</codeph>, les fichiers texte externes sont interprétés comme de l’Unicode (ces fichiers doivent être codés en Unicode lorsque vous les enregistrez). Lorsque la propriété est définie sur <codeph>true</codeph>, les fichiers texte externes sont interprétés à l’aide de la page de code classique du système d’exploitation exécutant l’application. La valeur par défaut de <codeph>useCodePage</codeph> est <codeph>false</codeph>.
	 
	 <p>Le texte que vous chargez comme fichier externe (à l’aide de <codeph>Loader.load()</codeph>, la classe URLLoader ou URLStream) doit avoir été enregistré comme de l’Unicode pour que l’application le reconnaisse comme tel. Pour coder des fichiers externes comme de l’Unicode, enregistrez les fichiers dans une application qui prend en charge l’Unicode, tel que Notepad sous Windows.</p>
	 
	 <p>Si vous chargez des fichiers externes qui ne sont pas codés en Unicode, définissez <codeph>useCodePage</codeph> sur <codeph>true</codeph>. Ajoutez le code suivant sur la première ligne de code dans le <ph product="flash">premier cadre du </ph>fichier qui charge les données :</p>
	 
	 <pre><codeph>System.useCodePage = true;</codeph></pre>
	 
	 <p>Lorsque ce code est présent, l’application interprète le texte externe à l’aide de la page de code classique du système d’exploitation. Ce code est généralement CP1252 pour un système d’exploitation Windows anglais et Shift-JIS pour un système d’exploitation japonais. <ph platform="actionscript">Si vous définissez <codeph>useCodePage</codeph> sur <codeph>true</codeph>, Flash Player 6 et les versions ultérieures traitent le texte comme Flash Player 5 (Flash Player 5 traitait l’ensemble du texte comme s’il se trouvait dans la page de code classique du système d’exploitation exécutant le lecteur).</ph></p>
	 
	 <p>Si vous définissez <codeph>useCodePage</codeph> sur <codeph>true</codeph>, souvenez-vous que la page de code classique du système d’exploitation exécutant l’application doit inclure les caractères utilisés dans votre fichier de texte externe afin d’afficher le texte. Par exemple, si vous chargez un fichier texte externe contenant des caractères chinois, ceux-ci ne peuvent s’afficher sur un système utilisant la page de code CP1252 car celle-ci ne comprend pas les caractères chinois.</p>
	 
	 <p>Pour que les utilisateurs de toutes les plates-formes puissent afficher les fichiers de texte externes utilisés dans votre application, vous devez coder tous les fichiers de texte externes en Unicode et conserver la propriété <codeph>useCodePage</codeph> définie sur <codeph>false</codeph> par défaut. Ainsi, l’application <ph platform="actionscript">(Flash Player 6 et les versions ultérieures) </ph>interprète le texte comme de l’Unicode.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:SecurityDomain"><apiName>SecurityDomain</apiName><shortdesc>
	La classe SecurityDomain représente le « sandbox » de sécurité actuel, qui est également appelé domaine de sécurité.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	La classe SecurityDomain représente le « sandbox » de sécurité actuel, qui est également appelé domaine de sécurité. En transmettant une occurrence de cette classe à <codeph>Loader.load()</codeph>, vous pouvez demander que le média chargé soit placé dans un sandbox spécifique.
	</apiDesc></apiClassifierDetail><apiValue id="flash.system:SecurityDomain:currentDomain:get"><apiName>currentDomain</apiName><shortdesc>
		Définit le domaine de sécurité actuel.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:SecurityDomain</apiValueClassifier></apiValueDef><apiDesc>
		Définit le domaine de sécurité actuel. 
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links></apiValue></apiClassifier></apiPackage>