<?xml version="1.0"?>
<apiPackage id="flash.text"><apiName>flash.text</apiName><apiDetail/><apiClassifier id="flash.text:TextExtent"><apiName>TextExtent</apiName><shortdesc>
 La classe TextExtent contient des informations relatives aux limites de texte dans un champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextExtent contient des informations relatives aux limites de texte dans un champ de texte. Les objets de cette classe sont renvoyés par la méthode <codeph>TextFormat.getTextExtent</codeph>.
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.text:TextExtent:TextExtent"><apiName>TextExtent</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextExtent:ascent"><apiName>ascent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:descent"><apiName>descent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:height"><apiName>height</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldHeight"><apiName>textFieldHeight</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldWidth"><apiName>textFieldWidth</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:width"><apiName>width</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
	 La classe CSMSettings contient des propriétés à utiliser avec la méthode TextRenderer.setAdvancedAntiAliasingTable() pour mettre en place une modulation continue du trait (CSM).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not functioning correctly. Bug report 193833
	 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe CSMSettings contient des propriétés à utiliser avec la méthode <codeph>TextRenderer.setAdvancedAntiAliasingTable()</codeph> pour mettre en place une modulation continue du trait (CSM). CSM désigne la modulation continue de l’épaisseur du trait et de la netteté des bords.
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links><apiConstructor id="flash.text:CSMSettings:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
     Crée un objet CSMSettings qui enregistre les valeurs de trait pour les paramètres d’anti-aliasing personnalisés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>fontSize</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>La taille, en pixels, pour laquelle les paramètres s’appliquent.
	 </apiDesc></apiParam><apiParam><apiItemName>insideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>La valeur de limite intérieure, au-dessus de laquelle les densités sont définies sur une densité maximale, telle que 255.
	 </apiDesc></apiParam><apiParam><apiItemName>outsideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Une valeur de limite extérieure, sous laquelle les densités sont définies sur zéro.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Crée un objet CSMSettings qui enregistre les valeurs de trait pour les paramètres d’anti-aliasing personnalisés. 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.text:CSMSettings:fontSize"><apiName>fontSize</apiName><shortdesc>
		 La taille, en pixels, pour laquelle les paramètres s’appliquent.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 La taille, en pixels, pour laquelle les paramètres s’appliquent.
		 
		 <p>Le tableau <codeph>advancedAntiAliasingTable</codeph> transmis à la méthode <codeph>setAdvancedAntiAliasingTable()</codeph> peut comporter plusieurs entrées qui spécifient les paramètres CSM pour différentes tailles de police. Cette propriété permet de spécifier la taille de la police à laquelle les autres paramètres s’appliquent.
		 </p>
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:insideCutoff"><apiName>insideCutoff</apiName><shortdesc>
		 La valeur de limite intérieure, au-dessus de laquelle les densités sont définies sur une densité maximale, telle que 255.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 La valeur de limite intérieure, au-dessus de laquelle les densités sont définies sur une densité maximale, telle que 255.
         
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:outsideCutoff"><apiName>outsideCutoff</apiName><shortdesc>
		 Une valeur de limite extérieure, sous laquelle les densités sont définies sur zéro.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Une valeur de limite extérieure, sous laquelle les densités sont définies sur zéro.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextColorType"><apiName>TextColorType</apiName><shortdesc>
La classe TextColorType fournit des valeurs de couleur pour la classe flash.text.TextRenderer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe TextColorType fournit des valeurs de couleur pour la classe flash.text.TextRenderer.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:TextColorType:DARK_COLOR"><apiName>DARK_COLOR</apiName><shortdesc>
    Utilisé par le paramètre colorType de la méthode setAdvancedAntiAliasingTable().</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dark</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Utilisé par le paramètre <codeph>colorType</codeph> de la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>. Utilisez la syntaxe <codeph>TextColorType.DARK_COLOR</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextColorType:LIGHT_COLOR"><apiName>LIGHT_COLOR</apiName><shortdesc>
    Utilisé par le paramètre colorType de la méthode setAdvancedAntiAliasingTable().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>light</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Utilisé par le paramètre <codeph>colorType</codeph> de la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>. Utilisez la syntaxe <codeph>TextColorType.LIGHT_COLOR</codeph>.	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:GridFitType"><apiName>GridFitType</apiName><shortdesc>
La classe GridFitType définit des valeurs pour l’adaptation à la grille dans la classe TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe GridFitType définit des valeurs pour l’adaptation à la grille dans la classe TextField.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:GridFitType:NONE"><apiName>NONE</apiName><shortdesc> 
	Ne définit pas d’adaptation à la grille.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Ne définit pas d’adaptation à la grille. Les lignes horizontales et verticales des glyphes ne sont pas alignées sur la grille de pixels. Cette constante permet de définir la propriété <codeph>gridFitType</codeph> de la classe TextField. Ce paramètre est généralement retenu pour les animations ou les grandes polices. Utilisez la syntaxe <codeph>GridFitType.NONE</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:PIXEL"><apiName>PIXEL</apiName><shortdesc>
	Adapte des lignes horizontales et verticales fortes à la grille de pixels.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Adapte des lignes horizontales et verticales fortes à la grille de pixels. Cette constante permet de définir la propriété <codeph>gridFitType</codeph> de la classe TextField. Ce paramètre fonctionne uniquement pour les champs texte justifiés à gauche et agit comme la constante <codeph>GridFitType.SUBPIXEL</codeph> pour le texte statique. Ce paramètre rend généralement le texte justifié à gauche plus lisible. Utilisez la syntaxe <codeph>GridFitType.PIXEL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:SUBPIXEL"><apiName>SUBPIXEL</apiName><shortdesc>
	Adapte des lignes horizontales et verticales fortes à la grille de sous-pixels des écrans à cristaux liquides.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subpixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Adapte des lignes horizontales et verticales fortes à la grille de sous-pixels des écrans à cristaux liquides (rouge, vert et bleu correspondent à des pixels réels sur un écran à cristaux liquides). Ce paramètre est généralement préférable pour tout texte dynamique aligné à droite ou à gauche et permet d’établir un bon compromis entre les contraintes d’animation et de qualité du texte. Cette constante permet de définir la propriété <codeph>gridFitType</codeph> de la classe TextField. Utilisez la syntaxe <codeph>GridFitType.SUBPIXEL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StaticText"><apiName>StaticText</apiName><shortdesc>
 Cette classe représente les objets MorphShape figurant dans la liste d’affichage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Cette classe représente les objets MorphShape figurant dans la liste d’affichage. Vous ne pouvez pas définir un objet StaticText avec du code ActionScript. Seul l’outil de programmation permet de créer un objet StaticText. Toute tentative de création d’un objet StaticText génère un objet <codeph>ArgumentError</codeph>.
 
 <p>Pour créer une référence à un champ de texte statique existant dans ActionScript 3.0, utilisez une itération sur les éléments de la liste d’affichage. Par exemple, le fragment de code suivant vérifie si la liste d’affichage contient un champ de texte statique et, le cas échéant, l’affecte à une variable :</p>
 
 <codeblock>
 var i:uint;
 for (i = 0; i &lt; this.numChildren; i++) {
     var displayitem:DisplayObject = this.getChildAt(i);
     if (displayitem instanceof StaticText) {
         trace("a static text field is item " + i + " on the display list");
         var myFieldLabel:StaticText = StaticText(displayitem);
         trace("and contains the text: " + myFieldLabel.text);
     }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><apiValue id="flash.text:StaticText:text:get"><apiName>text</apiName><shortdesc>
     Renvoie le texte actuel du champ de texte statique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Renvoie le texte actuel du champ de texte statique. L’outil de programmation permet d’exporter différents objets champ de texte multiple comprenant l’ensemble du texte. Par exemple, pour le texte vertical, l’outil de programmation crée un champ de texte par caractère.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextField"><apiName>TextField</apiName><shortdesc>
 La classe TextField permet de créer des objets d’affichage et de saisie de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>La classe TextField permet de créer des objets d’affichage et de saisie de texte.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextField permet de créer des objets d’affichage et de saisie de texte. Tous les champs texte de saisie et dynamique dans un fichier SWF sont des occurrences de la classe TextField. <ph outputclass="flexonly">Vous pouvez utiliser la classe TextField pour procéder à un rendu de texte de bas niveau. Cependant, dans Flex, vous devez normalement utiliser les contrôles Label, Text, TextArea et TextInput pour traiter le texte.</ph> <ph outputclass="flashonly">Vous pouvez donner un nom d’occurrence à un champ de texte dans l’inspecteur des propriétés, puis utiliser les méthodes et les propriétés de la classe TextField pour la modifier avec ActionScript. Les noms d’occurrence de TextField s’affichent dans l’explorateur d’animations et dans la boîte de dialogue Insérer un chemin cible du panneau Actions.</ph>
 
 <p>Pour créer un champ de texte de façon dynamique, utilisez le constructeur <codeph>TextField()</codeph>.</p>
 
 <p>Les méthodes de la classe TextField permettent de définir, sélectionner et manipuler du texte dans un champ de texte dynamique ou de saisie que vous créez en cours de programmation ou à l’exécution. </p>
 
 <p>ActionScript offre différentes manières de formater vos textes à l’exécution. La classe TextFormat permet de définir le formatage des caractères et des paragraphes pour les objets TextField. Vous pouvez appliquer des styles CSS (Cascading Style Sheets) aux champs texte à l’aide de la propriété <codeph>TextField.styleSheet</codeph> et de la classe StyleSheet. Vous pouvez utiliser le style CSS pour l’appliquer aux balises HTML intégrées, définir de nouvelles balises de format ou appliquer des styles. Vous pouvez affecter du texte au format HTML, qui utilise éventuellement des styles CSS, directement à un champ de texte. Le texte HTML que vous affectez à un champ de texte peut contenir des supports intégrés (clips, fichiers SWF, GIF, PNG et JPEG). Le texte entoure le média intégré comme dans un document HTML dans un navigateur Web. </p>
 
 <p>Flash Player prend en charge un sous-ensemble de balises HTML à utiliser pour formater le texte. Vous trouverez la liste des balises HTML prises en charge dans la description de la propriété <xref href="flasht/text/TextField#htmlText">htmlText</xref>.</p>
 
 </apiDesc><example conref="examples\TextFieldExample.as"> L’exemple suivant a recours à la classe <codeph>TextFieldExample</codeph> pour afficher un message texte. Cette opération s’accomplit de la façon suivante :
 <ol>
  <li>Une propriété <codeph>label</codeph> de type TextField est créée.</li>
  <li>Le constructeur de classe appelle la fonction <codeph>configureLabel()</codeph>.</li>
  <li> La méthode <codeph>configureLabel()</codeph> crée tout d’abord un objet TextField et l’affecte à la propriété <codeph>label</codeph>, puis définit ses paramètres de la façon suivante :
  <ul>
      <li>Justifie le champ de texte à gauche.</li>
      <li>Active le remplissage d’arrière-plan.</li>
      <li>Active la bordure.</li>
  </ul>
  </li>
  <li>La méthode <codeph>configureLabel()</codeph> crée la variable <codeph>format</codeph> et l’affecte à une nouvelle occurrence de TextFormat en définissant ses paramètres de la façon suivante :
  <ul>
      <li>Type de police = Verdana</li>
      <li>Couleur de la police = rouge uni</li>
      <li>Taille de la police = 10</li>
      <li>Soulignement = true</li>
  </ul>
  </li>
  <li>La propriété <codeph>defaultTextFormat</codeph> du champ de texte <codeph>label</codeph> est définie sur <codeph>format</codeph> et l’occurrence de <codeph>label</codeph> est ajoutée à la liste d’affichage, qui affiche tout d’abord un champ de texte vide sur la scène.</li>
 
  <li>Le constructeur définit le texte du champ de texte <codeph>label</codeph> sur <codeph>"Hello world and welcome to the show."</codeph> en appelant la méthode <codeph>setLabel()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFieldExample extends Sprite {
        private var label:TextField;
        private var labelText:String = "Hello world and welcome to the show.";

        public function TextFieldExample() {
            configureLabel();
            setLabel(labelText);
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Flash Player distribue l’événement textInput lorsqu’un utilisateur entre un ou plusieurs caractères de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Flash Player distribue l’événement <codeph>textInput</codeph> lorsqu’un utilisateur entre un ou plusieurs caractères de texte. Différentes méthodes de saisie de texte peuvent générer cet événement, ce qui inclut les claviers standard, les éditeurs de méthode d’entrée (IME), les systèmes de reconnaissance vocale, voire même la copie de texte simple sans formatage ni ajout de style.
 </apiDesc><example conref="examples\TextField_textInput.as"> L’exemple suivant définit deux objets TextField : le premier est un champ de saisie de texte et le deuxième est un champ de texte dynamique. Lorsque vous entrez des caractères dans le premier champ de texte, un événement <codeph>textInput</codeph> est déclenché, le gestionnaire <codeph>textInputHandler()</codeph> est appelé, et les caractères s’affichent dans le second champ de texte. Lorsque vous collez un bloc de texte dans le champ de saisie, le gestionnaire de l’événement copie l’ensemble du bloc dans l’autre champ.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextInputExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();

        public function TextInputExample()
        {
            myTextBox1.type = TextFieldType.INPUT;
            myTextBox1.width = 200;
            myTextBox1.height = 20;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(TextEvent.TEXT_INPUT,textInputHandler);
        }

        public function textInputHandler(event:TextEvent):void
        {
           myTextBox2.text=event.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.SCROLL_scroll"><apiName>scroll</apiName><shortdesc>
 Distribué par un objet TextField après une opération de défilement effectuée par l’utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SCROLL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué par un objet TextField <i>après</i> une opération de défilement effectuée par l’utilisateur. 
 </apiDesc><example conref="examples\TextField_scroll.as"> L’exemple suivant définit deux objets TextField. Deux gestionnaires d’événement sont associés au premier objet TextField. Lorsque vous cliquez dans le premier champ de texte, l’événement <codeph>mouseDown</codeph> est déclenché et le gestionnaire <codeph>mouseDownScroll</codeph> associé est appelé. Le gestionnaire <codeph>mouseDownScroll()</codeph> entraîne le défilement du champ. L’événement <codeph>scroll</codeph> est ensuite déclenché et le gestionnaire <codeph>scrollHandler()</codeph> actualise le second champ de texte pour afficher la position actuelle du défilement.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextScrollExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();
        private var myText:String = "Hello world and welcome to the show. It's really nice to meet you. Take your coat off and stay a while. OK, show is over. Hope you had fun. You can go home now. Don't forget to tip your waiter. There are mints in the bowl by the door. Thank you. Please come again.";

        public function TextScrollExample()
        {
            myTextBox1.text = myText;
            myTextBox1.width = 200;
            myTextBox1.height = 50;
            myTextBox1.multiline = true;
            myTextBox1.wordWrap = true;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;
            myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownScroll);
            myTextBox1.addEventListener(Event.SCROLL, scrollHandler);
        }

        public function mouseDownScroll(event:MouseEvent):void
        {
            myTextBox1.scrollV++;
        }
        public function scrollHandler(event:Event):void
        {
           myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.LINK_link"><apiName>link</apiName><shortdesc>
 Distribué lorsqu’un utilisateur clique sur un hyperlien dans un champ de texte HTML dont l’URL commence par « event: ».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.LINK</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un utilisateur clique sur un hyperlien dans un champ de texte HTML dont l’URL commence par « event: ». La partie de l’URL qui suit « event: » est placée dans la propriété text de l’événement LINK.
 <p><b>Remarque :</b> le comportement par défaut, qui consiste à ajouter du texte au champ de texte, se produit uniquement lorsque Flash Player génère l’événement. Dans ce cas, ceci se produit lorsqu’un utilisateur tente de saisir du texte. Vous ne pouvez pas placer du texte dans un champ de texte en lui envoyant des événements <codeph>textInput</codeph>.</p>
 </apiDesc><example conref="examples\TextField_event_link.as"> Dans l’exemple suivant, la fonction <codeph>playMP3()</codeph> est définie. Un objet TextField nommé <codeph>list</codeph> est créé et renseigné avec du texte HTML. Le texte <codeph>« Track 1 »</codeph> et <codeph>« Track 2 »</codeph> constitue des liens dans le champ de texte. La fonction playMP3() est appelée lorsque l’utilisateur clique sur l’un ou l’autre lien. Le nom du fichier MP3, qui suit la chaîne « event: » dans l’attribut <codeph>href</codeph> de la balise HTML, est transmis à la méthode <codeph>linkHandler()</codeph> en tant que propriété <codeph>text</codeph> de l’objet événement <codeph>link</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;
    import flash.events.TextEvent;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_event_link extends Sprite
    {
        private var myMP3:Sound;
        public function TextField_event_link() {
            myMP3 = new Sound();
            var list:TextField = new TextField();
            list.autoSize = TextFieldAutoSize.LEFT;
            list.multiline = true;
            list.htmlText = "&lt;a href=\"event:track1.mp3\">Track 1&lt;/a>&lt;br>";
            list.htmlText += "&lt;a href=\"event:track2.mp3\">Track 2&lt;/a>&lt;br>";
            addEventListener(TextEvent.LINK, linkHandler);
            addChild(list);
        }
        
        private function playMP3(mp3:String):void {
            try {    
                myMP3.load(new URLRequest(mp3));
                myMP3.play();
            }
            catch(err:Error) {
                trace(err.message);
            }
            myMP3.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }
        
        private function linkHandler(linkEvent:TextEvent):void {
            playMP3(linkEvent.text);
        }
        
        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.CHANGE_change"><apiName>change</apiName><shortdesc>
 Distribué après la modification d’une valeur de contrôle, contrairement à l’événement textInput, qui est distribué avant la modification de la valeur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué après la modification d’une valeur de contrôle, contrairement à l’événement <codeph>textInput</codeph>, qui est distribué avant la modification de la valeur. Contrairement à la version de modèle d’événements W3C DOM de l’événement <codeph>change</codeph>, qui ne distribue l’événement que lorsque le contrôle a perdu le focus, la version ActionScript 3.0 de l’événement <codeph>change</codeph> est distribuée dès que le contrôle change. Par exemple, si un utilisateur tape du texte dans un champ de texte, un événement <codeph>change</codeph> est distribué à chaque pression de touche.
 </apiDesc><example conref="examples\TextField_Event_changeExample.as"> Dans l’exemple suivant, le texte saisi par l’utilisateur (saisie utilisateur) est immédiatement copié (en miroir) dans un autre champ de texte au format de texte différent. 
 
 <p>Deux champs de textes sont créés, l’un pour la saisie de l’utilisateur et l’autre (<codeph>headingTextField</codeph>), pour la copie de cette saisie. Un objet TextFormat est également créé et le format de texte par défaut est attribué au champ de texte <codeph>headingTextField</codeph>. Lorsque le contenu du champ de texte est modifié, la méthode <codeph>changeHandler()</codeph> est invoquée et affecte le contenu du champ de texte <codeph>inputTextField</codeph> au champ de texte <codeph>headingTextField</codeph> (si la méthode a été appelée pour l’événement <codeph>TextEvent.TEXT_INPUT</codeph> et non pour l’événement <codeph>Event.CHANGE</codeph>, le contenu de la saisie de l’utilisateur n’est copié qu’après une nouvelle saisie utilisateur).</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;
    import flash.events.Event;
    
    import flash.events.TextEvent;

    public class TextField_Event_changeExample extends Sprite {
        private var inputTextField:TextField = new TextField(); 
        private var headingTextField:TextField = new TextField(); 
        private var newFormat:TextFormat = new TextFormat();
         
        public function TextField_Event_changeExample() {
            headingTextField.x = 10;
            headingTextField.y = 10;
            headingTextField.height = 30;
            headingTextField.width = 400;
            headingTextField.background = true;
            headingTextField.backgroundColor = 0xF5F5DC;
            headingTextField.selectable = false;
 
            inputTextField.x = 10;
            inputTextField.y = 70;
            inputTextField.height = 20;
            inputTextField.width = 230;
            inputTextField.background = true;
            inputTextField.border = true;
            inputTextField.maxChars = 40;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            inputTextField.addEventListener(Event.CHANGE, changeHandler);

            newFormat.bold = true;
            newFormat.size = 18;
            newFormat.color = 0xFF0000;
            newFormat.align = TextFormatAlign.CENTER;

            headingTextField.defaultTextFormat = newFormat;

            this.addChild(inputTextField);
            this.addChild(headingTextField);
        }

        private function changeHandler(e:Event):void {
            headingTextField.text = inputTextField.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.text:TextField:TextField"><apiName>TextField</apiName><shortdesc>
	Crée une occurrence de TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Crée une occurrence de TextField. Après avoir créé une occurrence de TextField, utilisez la méthode <codeph>addChild()</codeph> ou <codeph>addChildAt()</codeph> de l’objet DisplayObjectContainer parent pour ajouter l’occurrence de TextField à la liste d’affichage.
     <p>La taille par défaut d’un champ de texte est de 100 x 100 pixels.</p>
	 
	 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.text:TextField:appendText"><apiName>appendText</apiName><shortdesc>
	 Ajoute la chaîne spécifiée par le paramètre newText à la fin du texte du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne à ajouter au texte existant.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Ajoute du texte à la fin du texte existant de TextField.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Ajoute la chaîne spécifiée par le paramètre <codeph>newText</codeph> à la fin du texte du champ de texte. Cette méthode est plus efficace que l’affectation d’addition (<codeph>+=</codeph>) pour une propriété <codeph>text</codeph> (telle que <codeph>someTextField.text += moreText</codeph>), notamment pour les champs texte dont le contenu est volumineux.
     
	 </apiDesc><example conref="examples\TextField_appendTextExample.as"> L’exemple suivant affiche l’heure si ce n’est pas le week-end ou le texte « It’s the weekend » si ça l’est. Il compte également le nombre de caractères jusqu’à une certaine position et le nombre de lignes du champ de texte.
 
 <p>Le champ de texte <codeph>outputText</codeph> est défini pour s’adapter automatiquement au texte en se redimensionnant sous forme de texte justifié à gauche via la propriété <codeph>autoSize</codeph>. La propriété <codeph>outputText.text</codeph> écrit la première ligne du contenu et la méthode <codeph>appendText()</codeph> ajoute le reste du contenu (il n’est pas nécessaire de commencer par la propriété <codeph>text</codeph>. La méthode <codeph>appendText()</codeph> peut également être utilisée pour ajouter du texte depuis le début). Le fait de définir la propriété <codeph>text</codeph> une seconde fois remplace le texte d’origine. Utilisez l’opérateur <codeph>+=</codeph> pour ajouter du contenu avec la propriété <codeph>text</codeph>.</p>
 
 <p>L’instruction <codeph>if</codeph> vérifie si la date correspond à un Samedi (6) ou à un Dimanche (0). Si ce n’est pas le cas, la méthode <codeph>toLocaleTimeString()</codeph> renvoie l’heure locale, qui est ajoutée au contenu du champ de texte.</p> 
 
 <p>La propriété <codeph>length</codeph> est utilisée pour lire le nombre de caractères juste avant que la fonction ne soit appelée, et la propriété <codeph>numLines</codeph> compte le nombre de lignes du champ de texte. Notez que les lignes vides comptent dans le nombre de lignes et les espaces vides et les sauts de ligne (\n) sont pris en compte dans la longueur du contenu.</p>   
 
<codeblock>
  package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
 
    public class TextField_appendTextExample extends Sprite {
         
        public function TextField_appendTextExample() {
            var outputText:TextField = new TextField();
            var today:Date = new Date();
                
            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
 
            outputText.text = "WHAT TIME IS IT?" + "\n\n";
 
            if((today.day == 0) || (today.day == 6)) {
                outputText.appendText("It's the weekend.");
                outputText.appendText("\n\n");
           
            } else {
                outputText.appendText("The time is: ");
                outputText.appendText(today.toLocaleTimeString() + ".\n\n");  
            }

            outputText.appendText("Number of characters including line breaks and spaces so far: ");
            outputText.appendText(outputText.length.toString() + "\n");
            outputText.appendText("Number of lines in the outputText: ");
            outputText.appendText(outputText.numLines.toString());   

            this.addChild(outputText);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getCharBoundaries"><apiName>getCharBoundaries</apiName><shortdesc>
	 Renvoie un rectangle qui délimite le caractère.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Un rectangle avec des valeurs <codeph>x</codeph> et <codeph>y</codeph> minimales et maximales qui définissent le cadre de sélection du caractère.
	 
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index de base zéro du caractère (par exemple, la première position est 0, la deuxième position est 1, etc.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie un rectangle qui délimite le caractère.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie un rectangle qui délimite le caractère.
	 
	 </apiDesc><example conref="examples\TextField_getCharBoundariesExample.as"> Dans l’exemple suivant, la méthode <codeph>getCharBoundaries()</codeph> est utilisée pour marquer (mettre en évidence) un caractère sélectionné par l’utilisateur.
 
 <p>La classe définit l’objet Shape <codeph>spotlight</codeph> qui servira à tracer un rectangle autour de chaque caractère sélectionné. Lorsque l’utilisateur clique sur le champ de texte <codeph>myTextField</codeph>, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getCharIndexAtPoint()</codeph> obtient l’index du caractère sur lequel s’effectue le clic à partir des coordonnées <codeph>localX</codeph> et <codeph>localY</codeph> du clic de la souris, lié au <codeph>Sprite</codeph> contenant. La méthode <codeph>getCharIndexAtPoint()</codeph> renvoie <codeph>-1</codeph> si le point (clic de la souris) n’a pas été effectué sur un caractère. Comme le champ de texte peut être plus grand que le texte, l’(<codeph>index</codeph>) du nombre entier renvoyé est vérifié pour s’assurer que l’utilisateur a cliqué sur un caractère. L’entier d’<codeph>index</codeph> est également utilisé par <codeph>getCharBoundaries()</codeph> pour obtenir un objet <codeph>Rectangle</codeph> qui gère la limite du caractère. La méthode <codeph>clear()</codeph> efface tout objet Shape <codeph>spotlight</codeph> précédemment affiché. Un nouveau rectangle, dont la taille correspond aux limites de hauteur et de largeur du caractère, est produit à l’emplacement du caractère (avec un décalage à partir des coordonnées (10, 10)) via les coordonnées x et y du rectangle <codeph>frame</codeph>. Pour mettre le caractère en évidence, l’objet Shape <codeph>spotlight</codeph> est coloré en jaune et l’opacité est définie sur 35 pour cent, de manière à ce que le caractère soit visible. Notez que les espaces sont également considérés comme des caractères.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    import flash.display.Shape;

    public class TextField_getCharBoundariesExample extends Sprite
    {
        private var myTextField:TextField = new TextField();    
        private var spotlight:Shape = new Shape();
        
        public function TextField_getCharBoundariesExample() {
            
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.text = "Selected a character from this text by clicking on it."

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);    
            this.addChild(spotlight);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
 
            if (index != -1) {
                 var frame:Rectangle = myTextField.getCharBoundaries(index);

                spotlight.graphics.clear();    
                spotlight.graphics.beginFill(0xFFFF00, .35);
                spotlight.graphics.drawRect((frame.x + 10), (frame.y + 10), frame.width, frame.height);            
                spotlight.graphics.endFill();
            }
        } 
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getCharIndexAtPoint"><apiName>getCharIndexAtPoint</apiName><shortdesc>
	 Renvoie la valeur d’index de base zéro du caractère au point spécifié par les paramètres x et y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur d’index de base zéro du caractère (par exemple, la première position est 0, la deuxième position est 1, etc.). Renvoie -1 si le point n’est pas au-dessus d’un caractère.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> du caractère.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> du caractère.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie la valeur d’index de base zéro du caractère.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie la valeur d’index de base zéro du caractère au point spécifié par les paramètres <codeph>x</codeph> et <codeph>y</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getCharIndexAtPointExample.as"> Dans l’exemple suivant, lorsqu’un utilisateur clique sur un caractère, ce dernier apparaît en miroir dans un autre champ de texte au-dessus du texte.
 
 <p>Le premier champ de texte gère le texte que l’utilisateur va sélectionner. Pour être certain que l’utilisateur a cliqué sur le texte mais ne l’a pas sélectionné, la propriété <codeph>selectable</codeph> est définie sur false. Lorsque l’utilisateur clique sur le champ de texte <codeph>firstTextField</codeph>, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getCharIndexAtPoint()</codeph> renvoie l’index du caractère à partir des coordonnées <codeph>localX</codeph> et <codeph>localY</codeph> du clic de la souris. Comme le champ de texte peut être plus grand que le texte, l’(<codeph>index</codeph>) du nombre entier renvoyé est vérifié pour s’assurer que l’utilisateur a cliqué sur un caractère (la méthode <codeph>getCharIndexAtPoint()</codeph> renvoie <codeph>-1</codeph> si le point (clic de la souris) n’a pas été effectué sur un caractère). Les coordonnées de la souris sont utilisées pour définir les coordonnées du nouveau champ de texte où le caractère mis en miroir doit apparaître. La couleur du caractère dans le second champ de texte est définie sur rouge. Enfin, le texte du second champ est défini sur le caractère sélectionné, récupéré via la méthode <codeph>charAt()</codeph>. Notez que l’utilisation de la propriété <codeph>text</codeph> à la place de la méthode <codeph>appendText()</codeph> écrasera le caractère dans le second champ de texte au lieu de l’ajouter.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getCharIndexAtPointExample extends Sprite {
        private var firstTextField:TextField = new TextField();    
        private var secondTextField:TextField = new TextField();
        
        public function TextField_getCharIndexAtPointExample() {

            firstTextField.x = 100;
            firstTextField.y = 100; 
            firstTextField.width = 260;
            firstTextField.height = 20;
            firstTextField.border = true;
            firstTextField.background = true;
            firstTextField.selectable = false;
            
            firstTextField.text = "Selected a character from this text by clicking on it."

            firstTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(firstTextField);    
            this.addChild(secondTextField);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = firstTextField.getCharIndexAtPoint(e.localX, e.localY);

            if (index != -1) {
                secondTextField.x = mouseX;
                secondTextField.y =  70;
                secondTextField.border = true;
                secondTextField.selectable = false;
                secondTextField.background = true;
                secondTextField.textColor = 0xFF0000;
                secondTextField.autoSize = TextFieldAutoSize.LEFT;
                secondTextField.text = firstTextField.text.charAt(index);    
            }
        } 
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getFirstCharInParagraph"><apiName>getFirstCharInParagraph</apiName><shortdesc>
	 En fonction d’un caractère d’index, renvoie l’index du premier caractère dans le même paragraphe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le caractère d’index spécifié est hors limites.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur d’index de base zéro du premier caractère dans le même paragraphe.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index de base zéro du caractère (par exemple, le premier caractère est 0, le deuxième caractère est 1, etc.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Valeur d’index de base zéro du caractère.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 En fonction d’un caractère d’index, renvoie l’index du premier caractère dans le même paragraphe.
	 
	 </apiDesc><example conref="examples\TextField_getFirstCharInParagraphExample.as"> Dans l’exemple suivant, une mise en forme de paragraphe est appliquée au contenu du champ de texte. Lorsque l’utilisateur clique sur un paragraphe, le texte de ce dernier est aligné à droite, puis retrouve son format (par défaut) original (aligné à gauche) lorsque l’utilisateur clique de nouveau sur le paragraphe.
 
 <p>Dans le constructeur, le champ de texte <codeph>myTextField</codeph> est défini pour renvoyer le texte à la ligne. La méthode <codeph>getTextFormat</codeph> renvoie le format d’origine du premier caractère du contenu du champ de texte, placé dans l’objet TextFormat <codeph>originalFormat</codeph>. Un nouvel objet TextFormat (<codeph>newFormat</codeph>) est également défini et le format justifié à droite est affecté à sa propriété <codeph>align</codeph>. Lorsque l’utilisateur clique sur le champ de texte, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getCharIndexAtPoint()</codeph> renvoie l’index du caractère à partir des coordonnées <codeph>localX</codeph> et <codeph>localY</codeph> du clic de la souris. La première instruction <codeph>if</codeph> vérifie si l’utilisateur a cliqué sur un caractère. Via l’entier <codeph>clickIndex</codeph> renvoyé par la méthode <codeph>getCharIndexAtPoint()</codeph>, la méthode <codeph>getFirstCharInParagraph()</codeph> renvoie l’index du premier caractère du paragraphe dans lequel l’utilisateur a cliqué. L’index du dernier caractère du paragraphe est déterminé en ajoutant la longueur du paragraphe (via la méthode <codeph>getParagraphLength()</codeph>) à l’index du premier caractère du paragraphe, moins le dernier caractère (<codeph>\n</codeph>). La seconde instruction <codeph>if</codeph> vérifie le format du premier caractère du paragraphe. Si sa valeur d’alignement correspond au format original (justifié à gauche), le nouveau format est appliqué à tous les caractères du paragraphe. Dans le cas contraire, le format du paragraphe est réinitialisé sur son format d’origine. L’alignement, comme la mise en forme telle que les retraits, les puces, les taquets de tabulation et les marges gauches et droites, sont des formats destinés aux paragraphes. Notez qu’une fois que le retour à la ligne ou le saut de ligne est utilisé, la mise en forme ne s’applique qu’à la première ligne du paragraphe si l’argument <codeph>endIndex</codeph> n’est pas défini pour la méthode <codeph>setTextFormat()</codeph>.</p>
     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;

    public class TextField_getFirstCharInParagraphExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        private var originalFormat:TextFormat = new TextFormat();
        private var newFormat:TextFormat = new TextFormat(); 
        
        public function TextField_getFirstCharInParagraphExample() {
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 300; 
            myTextField.background = true;
             
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.\n\n");

            originalFormat = myTextField.getTextFormat(0);

            newFormat.align = TextFormatAlign.RIGHT;

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
  
            this.addChild(myTextField);
        }

        private function clickHandler(e:MouseEvent):void {
            var clickIndex:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
                  
            if(clickIndex != -1) {
                var paragraphFirstIndex:int = myTextField.getFirstCharInParagraph(clickIndex);
                var paragraphEndIndex:int = paragraphFirstIndex + ((myTextField.getParagraphLength(clickIndex) - 1));
            
                if (myTextField.getTextFormat(paragraphFirstIndex).align == originalFormat.align) {
                     myTextField.setTextFormat(newFormat, paragraphFirstIndex, paragraphEndIndex);
                }else {
                     myTextField.setTextFormat(originalFormat, paragraphFirstIndex, paragraphEndIndex);
                }
            } 
        }
    }
}
 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getImageReference"><apiName>getImageReference</apiName><shortdesc>
	 Renvoie une référence DisplayObject pour l’ID donné, pour une image ou un fichier SWF qui a été ajouté à un champ de texte qui applique le format HTML à l’aide de la balise &amp;lt;img&amp;gt;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>L’objet d’affichage qui correspond à l’image ou au fichier SWF possédant l’attribut <codeph>id</codeph> correspondant dans la balise <codeph>&lt;img></codeph> du champ de texte. Pour les médias chargés à partir d’une source externe, cet objet est de type Loader et, une fois chargé, l’objet média devient l’enfant de cet objet Loader. Pour le média intégré dans le fichier SWF, il s’agit de l’objet chargé. S’il n’existe pas de balise <codeph>&lt;img></codeph> avec un paramètre <codeph>id</codeph> correspondant, la méthode renvoie <codeph>null</codeph>.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>L’<codeph>id</codeph> à faire correspondre (dans l’attribut <codeph>id</codeph> de la balise <codeph>&lt;img></codeph>). 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une référence DisplayObject pour l’<codeph>id</codeph> donné, pour une image ou un fichier SWF qui a été ajouté à un champ de texte qui applique le format HTML à l’aide de la balise <codeph>&lt;img></codeph>. La balise <codeph>&lt;img></codeph> est au format suivant :
	 
	 <p><pre><codeph>	&lt;img src = 'filename.jpg' id = 'instanceName' ></codeph></pre></p>
	 
	 </apiDesc><example conref="examples\TextField_getImageReferenceExample.as"> Dans l’exemple suivant, lorsque l’utilisateur clique dans le champ de texte, l’image du champ est définie sur une opacité de 25 pour cent et pivote de 90 degrés par rapport à sa position d’origine. L’image continue à pivoter à chaque clic suivant.
 
 <p>L’image (<codeph>image.jpg</codeph>) est incluse via le code HTML (ici, le fichier image est supposé être dans le même répertoire que le fichier SWF). Un attribut <codeph>id</codeph> doit être défini pour la balise <codeph>img</codeph> pour pouvoir accéder à l’image via la méthode <codeph>getImageReference()</codeph>. La propriété <codeph>htmlText</codeph> est utilisée pour inclure un contenu de chaîne au format HTML. Lorsque l’utilisateur clique sur le champ de texte <codeph>myTextField</codeph>, la méthode <codeph>clickHandler()</codeph> est invoquée.</p> 
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getImageReference()</codeph> renvoie une référence aux images sous forme d’objet <codeph>DisplayObject</codeph>. Cette référence peut être utilisée pour manipuler l’image, comme tout objet <codeph>DisplayObject</codeph>. Ici, les propriétés <codeph>alpha</codeph> (transparence) et <codeph>rotation</codeph> sont définies. La propriété <codeph>transform</codeph> peut également être utilisée pour accéder à la matrice, à la transformation de couleur et aux limites de pixel de l’objet d’affichage. Notez également que <codeph>flash.display.DisplayObject</codeph> doit être importé.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.display.DisplayObject;
    
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getImageReferenceExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        
        public function TextField_getImageReferenceExample()
        {
            var myText1:String = "&lt;p>Here is an image we want to mainpulate: &lt;img src='image.jpg' id='testimage'>&lt;/p>";

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 250;
            myTextField.height = 250;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.border = true;
            myTextField.multiline = true;

            myTextField.htmlText = myText1;
            
            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);
        }
 
        private function clickHandler(e:MouseEvent):void {
            var imageRef:DisplayObject = myTextField.getImageReference("testimage");
 
            imageRef.rotation += 90;
            imageRef.x = 125;
            imageRef.y = 125;
            imageRef.alpha = 0.25;      
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>htmlText</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineIndexAtPoint"><apiName>getLineIndexAtPoint</apiName><shortdesc>
	 Renvoie la valeur d’index de base zéro de la ligne au point spécifié par les paramètres x et y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur d’index de base zéro de la ligne (par exemple, la première ligne est 0, la deuxième ligne est 1, etc.). Renvoie -1 si le point n’est pas au-dessus d’une ligne.
 	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>x</i> de la ligne.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Coordonnée <i>y</i> de la ligne.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Valeur d’index de base zéro de la ligne à un point défini.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie la valeur d’index de base zéro de la ligne au point spécifié par les paramètres <codeph>x</codeph> et <codeph>y</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexAtPointExample.as"> Dans l’exemple suivant, lorsqu’un utilisateur sélectionne une ligne dans le sonnet de Shakespeare, cette ligne est copiée (ajoutée) dans un nouveau champ de texte.   
 
 <p>Dans le constructeur, le champ de texte <codeph>poem</codeph> est défini pour ne pas aller à la ligne (puisqu’il s’agit d’un poème). La propriété <codeph>autoSize</codeph> est également utilisée pour définir le texte de sorte qu’il s’ajuste automatiquement et se redimensionne sous forme de texte justifié à gauche. Le champ de texte <codeph>poemCopy</codeph> est placé sous le champ de texte <codeph>poem</codeph>. Lorsqu’un utilisateur clique sur une des lignes du poème, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getLineIndexAtPoint()</codeph> renvoie l’index de la ligne dans laquelle l’utilisateur a cliqué sur la base des coordonnées <codeph>localX</codeph> et <codeph>localY</codeph> du clic de la souris (comme ici le poème original est adapté à la taille du champ de texte, il n’est pas nécessaire de vérifier la présence d’une erreur de plage (<codeph>RangeError</codeph>) renvoyée par la méthode <codeph>getCharIndexAtPoint()</codeph>). L’index de la ligne est ensuite utilisé pour obtenir le contenu de la ligne sous forme de chaîne avec la méthode <codeph>getLineText()</codeph>, alors ajouté au contenu du champ de texte <codeph>poemCopy</codeph>. La copie peut se poursuivre de façon continue mais, après un certain point, le texte sortira de la plage du champ de texte <codeph>poemCopy</codeph> affichable.</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexAtPointExample extends Sprite {
        private var poem:TextField = new TextField();
        private var poemCopy:TextField = new TextField();
        
        public function TextField_getLineIndexAtPointExample() {
            poem.border = true;
            poem.autoSize = TextFieldAutoSize.LEFT;
            poem.x = 10;
            poem.wordWrap = false;

            poemCopy.height = 250;
            poemCopy.width = 270;
            poemCopy.y = 230;
            poemCopy.x = 10;
            poemCopy.background = true;
            poemCopy.border = true;
            poemCopy.wordWrap = false;
            
            poem.appendText("Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.");

           poem.addEventListener(MouseEvent.CLICK, clickHandler); 

           this.addChild(poem); 
           this.addChild(poemCopy);
        }
    
        private function clickHandler(e:MouseEvent):void {
                var index:int = poem.getLineIndexAtPoint(e.localX, e.localY);
                var s:String;

                s = poem.getLineText(index);
                poemCopy.appendText(s + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineIndexOfChar"><apiName>getLineIndexOfChar</apiName><shortdesc>
	 Renvoie la valeur d’index de base zéro de la ligne qui contient le caractère spécifié par le paramètre charIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le caractère d’index spécifié est hors limites.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur d’index de base zéro de la ligne.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index de base zéro du caractère (par exemple, le premier caractère est 0, le deuxième caractère est 1, etc.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Valeur d’index de base zéro de la ligne qui contient le caractère spécifié par le paramètre <codeph>charIndex</codeph>.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie la valeur d’index de base zéro de la ligne qui contient le caractère spécifié par le paramètre <codeph>charIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexOfCharExample.as"> Dans l’exemple suivant, la méthode <codeph>getLineIndexOfChar()</codeph> renvoie les numéros de ligne des 100ème et 500ème caractères du champ de texte.
 
 <p>Le champ de texte <codeph>myTextField</codeph> est défini pour aller à la ligne et se redimensionner sous forme de texte justifié à gauche. La méthode <codeph>getLineIndexOfChar()</codeph> renvoie l’index de la ligne des index des caractères spécifiés (100 et 500). Ces informations sont ensuite ajoutées après le paragraphe. Notez que comme l’index de la ligne commence à 0, l’index de la ligne (<codeph>index</codeph>) est augmenté de 1 pour obtenir le numéro de ligne. De même, si l’affichage est redimensionné, le numéro de ligne peut changer mais les informations ici demeureront les mêmes puisque la méthode n’est invoquée qu’une seule fois.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexOfCharExample extends Sprite 
    {
        public function TextField_getLineIndexOfCharExample()
        {
            var myTextField:TextField = new TextField();
            
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 200;
            myTextField.background = true;  
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.autoSize = TextFieldAutoSize.LEFT;

            myTextField.appendText("The TextField class is used to create display objects for "
                + "text display and input. All dynamic and input text fields in a SWF file" 
                + "are instances of the TextField class. You can use the TextField class "
                + "to perform low-level text rendering. However, in Flex, you typically use "
                + "the Label, Text, TextArea, and TextInput controls to process text. "  
                + "You can give a text field an instance name in the Property inspector "
                + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                + "Target Path dialog box in the Actions panel.\n\n");

            var index:int = myTextField.getLineIndexOfChar(100);
            myTextField.appendText("100th character is in line: " +  (index + 1) + "\n");
            index = myTextField.getLineIndexOfChar(500);
            myTextField.appendText("500th character is in line: " + (index + 1));

            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineLength"><apiName>getLineLength</apiName><shortdesc>
	 Renvoie le nombre de caractères d’une ligne de texte donnée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineLength, getLineLength
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le numéro de ligne spécifié est hors limites.
	 
 	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre de caractères dans la ligne.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Nombre de lignes pour lesquelles vous souhaitez connaître la longueur.
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie le nombre de caractères d’une ligne de texte donnée.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie le nombre de caractères d’une ligne de texte donnée.
	 
	 </apiDesc><example conref="examples\TextField_getLineLengthExample.as"> Dans l’exemple suivant, une fois que l’utilisateur sélectionne une ligne, la longueur de cette ligne (nombre de caractères) apparaît dans un champ de texte distinct. 
 <p>Sous forme d’illustration, le champ de texte <codeph>myTextField</codeph>, qui affiche le texte à compter, est défini sur <codeph>INPUT</codeph>, ce qui signifie que les utilisateurs peuvent modifier les lignes ou ajouter des lignes entre les lignes ou à la fin (une ligne vide est créée à l’aide du saut de ligne (<codeph>\n</codeph>) à la fin de la dernière ligne). Le champ de texte <codeph>countLines</codeph>, dans lequel apparaît le résultat du comptage de la longueur de ligne, est défini au-dessous du champ de texte <codeph>myTextField</codeph> et son texte n’est pas sélectionnable. Lorsque l’utilisateur clique sur une ligne du champ de texte <codeph>myTextField</codeph>, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getLineIndexAtPoint()</codeph> renvoie l’index de la ligne dans laquelle l’utilisateur a cliqué en utilisant les coordonnées <codeph>localX</codeph> et <codeph>localY</codeph> du clic de la souris. L’instruction <codeph>if</codeph> vérifie si l’utilisateur a cliqué sur un caractère. Dans l’affirmative, la méthode <codeph>getLineLength()</codeph>, à l’aide de l’index de la ligne, renvoie le nombre de caractères présents dans la ligne. Notez que les lignes vides placées entre les lignes incluent le second saut de ligne (<codeph>\n</codeph>) et présente un compte de 1 caractère, alors que le compte de la ligne située après la dernière ligne est de 0. Les espaces comptent également pour un caractère. Les utilisateurs peuvent écrire une nouvelle ligne ou modifier une ligne et obtenir le compte de caractères de la ligne en cliquant sur celle-ci. Si le renvoi à la ligne est utilisé et que l’écran est redimensionné, l’index de la ligne peut changer.</p>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class TextField_getLineLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countLines:TextField = new TextField();  

        public function TextField_getLineLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 350;
            myTextField.height = 150;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.type = TextFieldType.INPUT;
            
            myTextField.appendText("Click on the lines to count its number of characters:\n\n");
            myTextField.appendText("This is a short line.\n");
            myTextField.appendText("This is a longer line than the last line.\n\n");
            myTextField.appendText("This one is even longer than the one before. It has two sentences.\n");

            this.addChild(myTextField);

            countLines.border = true;
            countLines.x = 10;
            countLines.y = 180;
            countLines.height = 30;
            countLines.width = 200;
            countLines.background = true;
            countLines.selectable = false;

           this.addChild(countLines);    

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getLineIndexAtPoint(e.localX, e.localY);
        
            if (index != -1) {
            var lenght:int = myTextField.getLineLength(index);

            countLines.text = "Number of characters in the line is: " + lenght.toString();
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineMetrics"><apiName>getLineMetrics</apiName><shortdesc>
	 Renvoie les informations métriques relatives à une ligne de texte donnée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineMetrics, getLineMetrics
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le numéro de ligne spécifié est hors limites.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Un objet TextLineMetrics.
	 </apiDesc><apiOperationClassifier>flash.text:TextLineMetrics</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Nombre de lignes pour lesquelles vous désirez des informations métriques.
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie les informations métriques relatives à une ligne de texte donnée.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie les informations métriques relatives à une ligne de texte donnée.
	 
	 </apiDesc><example conref="examples\TextField_getLineMetricsExample.as"> L’exemple suivant présente des valeurs de mesures de ligne pour deux lignes de texte mises en forme différemment.
 
 <p>Le texte ajouté correspond à deux lignes à partir de <i>Song of Myself</i> de Walt Whitman. Un nouvel objet TextFormat (<codeph>newFormat</codeph>) est utilisé pour définir le format de la seconde ligne. La première ligne gère le format par défaut. La méthode <codeph>getLineMetrics()</codeph> renvoie un objet <codeph>TextLineMetrics</codeph> pour une ligne spécifique (l’index de la ligne commence à 0). Via les objets TextLineMetrics <codeph>metrics1</codeph> et <codeph>metrics2</codeph> des lignes un et deux, respectivement, les valeurs ascendante, descendante, de hauteur et de poids de la ligne sont récupérées et affichées. Les nombres qui en résultent sont convertis en chaînes mais ne sont pas arrondis. Notez que cette valeur est liée à la ligne et non pas à un caractère spécifique. Elle reflète la plage de caractères d’une ligne. Par exemple, si une ligne présente des caractères différents avec des formats de hauteur différents, le caractère présentant la hauteur la plus élevée détermine la valeur. Cela signifie également que lorsque le format du caractère est modifié, certaines valeurs de mesures peuvent également changer.</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.TextFormat;
 
    public class TextField_getLineMetricsExample extends Sprite {

        public function TextField_getLineMetricsExample() {
            var myTextField:TextField = new TextField();
            var newFormat:TextFormat = new TextFormat(); 

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.wordWrap = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.appendText("A child said What is the grass? fetching it to me with full hands;\n");
            myTextField.appendText("How could I answer the child? I do not know what it is any more than he.\n\n");

            newFormat.size = 14;
            newFormat.font = "Arial";
            newFormat.italic = true;
            myTextField.setTextFormat(newFormat, 67, 139);
               
            var metrics1:TextLineMetrics = myTextField.getLineMetrics(0);
             
            myTextField.appendText("Metrics ascent for the line 1 is: " + metrics1.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics1.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics1.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics1.width.toString() + "\n\n");

            var metrics2:TextLineMetrics = myTextField.getLineMetrics(1);
             
            myTextField.appendText("Metrics ascent for the line 2 is: " + metrics2.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics2.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics2.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics2.width.toString() + "\n");

            addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineOffset"><apiName>getLineOffset</apiName><shortdesc>
	 Renvoie le caractère d’index du premier caractère de la ligne spécifiée par le paramètre lineIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le numéro de ligne spécifié est hors limites.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur d’index basée sur zéro du premier caractère de la ligne.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index de base zéro de la ligne (par exemple, la première ligne est 0, la deuxième ligne est 1, etc.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Valeur d’index basée sur zéro du premier caractère de la ligne.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie l’index du premier caractère de la ligne spécifiée par le paramètre <codeph>lineIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineOffsetExample.as"> L’exemple suivant recherche le premier caractère de la ligne 4, qui change si l’écran (et le champ de texte) est redimensionné.
 
 <p>Le champ de texte <codeph>myTextField</codeph> est défini sur un renvoi à la ligne. Le champ de texte <codeph>countField</codeph> affichera le premier caractère de la ligne 4. Lorsque l’utilisateur clique sur le champ de texte <codeph>myTextField</codeph>, la méthode <codeph>clickHandler()</codeph> est invoquée.</p>
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getLineOffset()</codeph> renvoie l’index du premier caractère dans l’index de ligne 3, correspondant à la quatrième ligne du texte (l’index de la première ligne est 0). La méthode <codeph>charAt()</codeph> est utilisée pour obtenir le caractère à l’aide de l’index du premier caractère de la quatrième ligne. Le contenu du champ de texte <codeph>countField</codeph> est actualisé sur la base de ces informations via la propriété <codeph>text</codeph> du champ de texte <codeph>countField</codeph>. L’utilisation de la propriété <codeph>countField.text</codeph> signifie qu’après chaque clic le contenu du champ de texte <codeph>countField</codeph> est remplacé. Si l’utilisateur redimensionne l’affichage, le contenu est renvoyé à la ligne et le premier caractère de la ligne 4 peut changer. En cas de nouveau clic sur le champ <codeph>myTextField</codeph>, le contenu du champ de texte <codeph>countField</codeph> est mis à jour avec le nouveau premier caractère de la quatrième ligne.</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getLineOffsetExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();
        
        public function TextField_getLineOffsetExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 150;
            myTextField.height = 300;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;

            countField.height = 20;
            countField.width = 200;
            countField.x = 10;
            countField.y = 320;
            countField.selectable = false;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        
            this.addChild(myTextField);
            this.addChild(countField);
        }
    
            private function clickHandler(e:MouseEvent):void {
                var c:String;
                var index:int;
                
                index = myTextField.getLineOffset(3);
                c = myTextField.text.charAt(index);
                countField.text = "The first character of line 4 is: " + c;
            }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineText"><apiName>getLineText</apiName><shortdesc>
	 Renvoie le texte de la ligne spécifiée par le paramètre lineIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le numéro de ligne spécifié est hors limites.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne de texte contenue dans la ligne spécifiée.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index de base zéro de la ligne (par exemple, la première ligne est 0, la deuxième ligne est 1, etc.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Chaîne de texte contenue dans la ligne spécifiée.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie le texte de la ligne spécifiée par le paramètre <codeph>lineIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineTextExample.as"> Dans l’exemple suivant, les numéros de ligne de toutes les occurrences du terme « love » utilisées dans le sonnet de Shakespeare sont identifiés et affichés.
 
 <p>Le champ de texte <codeph>poem</codeph> est défini pour s’adapter automatiquement au texte et se redimensionner sous forme de texte justifié à gauche. La propriété <codeph>wordWrap</codeph> étant définie sur <codeph>false</codeph>, les lignes du poème n’iront pas à la ligne, bien qu’avec l’utilisation de la propriété <codeph>autoSize</codeph>, cela n’est généralement pas un problème. La boucle <codeph>for</codeph> procède à une itération sur les lignes du sonnet via la propriété <codeph>numLines</codeph> du champ de texte. La méthode <codeph>getLineText()</codeph> renvoie le contenu de la ligne sous forme de chaîne (notez que la propriété <codeph>numLines</codeph> renvoie le nombre de lignes en commençant à la ligne 1, alors que pour la méthode <codeph>getLineText()</codeph>, le numéro de lignes commence à 0). A l’aide du modèle d’expression standard (<codeph>/love/i</codeph>), l’instruction <codeph>if</codeph> recherche toute sous-chaîne du mot en majuscule ou en minuscule. Si le modèle est trouvé, la méthode <codeph>search</codeph> renvoie l’index de la première sous-chaîne correspondante, ou renvoie <codeph>-1</codeph> dans le cas contraire (s’il n’y a pas de correspondance). Le numéro de ligne ou le terme « love » a été trouvé (<codeph>(i + 1)</codeph>) est alors placé dans la chaîne <codeph>lineResult</codeph>. La méthode de chaîne convertit l’argument de nombre (<codeph>(i + 1)</codeph>) en chaîne tant qu’il y a un autre argument correspondant à une chaîne («   »). Le résultat de lignes de la recherche comprend les lignes présentant les termes « loved » ou « Love’s ». Si la chaîne « Love was found in lines: » a été ajoutée avant la boucle <codeph>for</codeph>, le terme « Love » de cette ligne aura également été inclus.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
 
    public class TextField_getLineTextExample extends Sprite {
           
        public function TextField_getLineTextExample() {
           var poem:TextField = new TextField();
           var lineResult:String = ""; 
           var pattern:RegExp = /love/i;

            poem.x = 10;
            poem.y = 10;
            poem.background = true;
            poem.wordWrap = false;
            poem.autoSize = TextFieldAutoSize.LEFT;
            
            poem.text = "Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.\n\n";

            for (var i:int = 0; i &lt; poem.numLines; i++) {

                var s:String = poem.getLineText(i);
                        
                if(s.search(pattern) != -1) {
                    lineResult += (i + 1) + " ";
                }
            }

            poem.appendText("Love was found in lines: " + lineResult);
             
            this.addChild(poem);                      
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getParagraphLength"><apiName>getParagraphLength</apiName><shortdesc>
	 En fonction d’un caractère d’index, renvoie la longueur du paragraphe qui contient le caractère donné.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Le caractère d’index spécifié est hors limites.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Renvoie le nombre de caractères du paragraphe.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index de base zéro du caractère (par exemple, le premier caractère est 0, le deuxième caractère est 1, etc.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Valeur d’index de base zéro du caractère.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 En fonction d’un caractère d’index, renvoie la longueur du paragraphe qui contient le caractère donné. La longueur est mesurée à partir du premier caractère du paragraphe (tel que renvoyé par <codeph>getFirstCharInParagraph()</codeph>) et non pas par rapport à l’index de caractères qui a été transmis.
	 
	 </apiDesc><example conref="examples\TextField_getParagraphLengthExample.as"> Dans l’exemple suivant, lorsqu’un utilisateur sélectionne un paragraphe, la longueur du paragraphe et le nombre de caractères « s » qu’il contient s’affichent dans un champ de texte distinct.
 
 <p>Le champ de texte <codeph>myTextField</codeph> affiche les paragraphes que l’utilisateur sélectionne. Lorsque l’utilisateur clique sur le champ de texte, l’événement <codeph>MouseEvent.CLICK</codeph> est distribué et la méthode <codeph>clickHandler()</codeph> est appelée. La longueur du paragraphe et le nombre de caractères « s » s’affichent dans le champ de texte <codeph>countField</codeph>, placées au-dessous du champ de texte <codeph>myTextField</codeph>.</p> 
 
 <p>Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getCharIndexAtPoint()</codeph> renvoie l’index du caractère à partir des coordonnées <codeph>localX</codeph> et <codeph>localY</codeph> du clic de la souris. La première instruction <codeph>if</codeph> vérifie si l’utilisateur a cliqué sur un caractère. La méthode <codeph>getFirstCharInParagraph()</codeph> utilise cet index pour renvoyer l’index du premier caractère du même paragraphe. La longueur du paragraphe renvoyée par la méthode <codeph>getParagraphLength()</codeph> est utilisée avec l’index du premier caractère du paragraphe pour déterminer l’index de la fin du paragraphe. Une boucle <codeph>for</codeph> procède à une itération sur le paragraphe en recherchant le nombre de caractères « s ».</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getParagraphLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();

        public function TextField_getParagraphLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 280;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file" 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField() constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            countField.x = 10;
            countField.y = 300;
            countField.height = 50;
            countField.width = 250;
            countField.background = true;
            countField.selectable = false;

            this.addChild(myTextField);
            this.addChild(countField);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
            
            if(index != -1) {
                var beginParag:int = myTextField.getFirstCharInParagraph(index);
                var paragLength:int = myTextField.getParagraphLength(index);
                var endParag:int = beginParag + paragLength;
                var sCount:uint = 0;

                for (var i:int = beginParag; i &lt;= endParag; i++) {
                    if ((myTextField.text.charAt(i) == "s") || (myTextField.text.charAt(i) == "S")) {
                        sCount++; 
                    }

                countField.text = "Paragraph length is: " + paragLength.toString() + "\n" 
                        + "Number of 's' characters in the paragraph: " + sCount.toString();
                }
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/getFirstCharInParagraph()"><linktext>flash.text.TextField.getFirstCharInParagraph()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getTextFormat"><apiName>getTextFormat</apiName><shortdesc>
	 Renvoie un objet TextFormat qui contient des informations de formatage pour la plage de texte délimitée par les paramètres beginIndex et endIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getTextFormat, getTextFormat
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>La valeur <codeph>beginIndex</codeph> ou <codeph>endIndex</codeph> est hors limite.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet TextFormat qui représente les propriétés de mise en forme du texte spécifié.
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Facultatif ; un entier qui spécifie le début d’une plage de texte au sein du champ de texte.
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Facultatif ; entier qui spécifie la position du premier caractère après la plage de texte souhaitée. Comme prévu, la spécification des valeurs <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>, entraîne la lecture du texte de <codeph>beginIndex</codeph> à <codeph>endIndex-1</codeph>. 
	 
 	 </apiDesc></apiParam><apiTipTexts><apiTipText>Renvoie un objet TextFormat.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Renvoie un objet TextFormat qui contient des informations de formatage pour la plage de texte délimitée par les paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. Seules les propriétés communes à l’ensemble du texte spécifié sont définies dans l’objet TextFormat obtenu. Toute propriété qui est <i>mixed</i>, ce qui signifie qu’elle a différentes valeurs à différents endroits du texte, a la valeur <codeph>null</codeph>.
	 
	 <p>Si vous ne spécifiez pas de valeurs pour ces paramètres, cette méthode s’applique à l’ensemble du texte dans le champ de texte.  </p>
	 
	 <p>Le tableau suivant décrit trois utilisations possibles :</p>
	 
	 <adobetable class="innertable">
	   
	   
	 	 
	   
	 <tgroup cols="2"><thead><row><entry>Utilisation</entry><entry>Description</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.getTextFormat()</codeph></entry>
	 	   <entry>Renvoie un objet TextFormat contenant des informations de mise en forme pour l’ensemble du texte d’un champ de texte. Seules les propriétés communes à l’ensemble du texte d’un champ de texte sont définies dans l’objet TextFormat obtenu. Toute propriété qui est <i>mixed</i>, ce qui signifie qu’elle a différentes valeurs à différents endroits du texte, a la valeur <codeph>null</codeph>.</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number)</codeph></entry>
	     <entry>Renvoie un objet TextFormat contenant une copie du format de texte du caractère à la position <codeph>beginIndex</codeph>.</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number,endIndex:Number)</codeph></entry>
	     <entry>Renvoie un objet TextFormat contenant des informations de mise en forme pour la plage de texte de <codeph>beginIndex</codeph> à <codeph>endIndex-1</codeph>. Seules les propriétés communes à l’ensemble du texte de la plage spécifiée sont définies dans l’objet TextFormat obtenu. Toute propriété qui est mixte (c.-à-d. a différentes valeurs à différents endroits de la plage) a sa valeur définie sur <codeph>null</codeph>.</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example>Consultez l’exemple de la méthode <xref href="TextField.html#getFirstCharInParagraph()">getFirstCharInParagraph()</xref> ou <xref href="TextField.html#setTextFormat()">setTextFormat()</xref> pour une illustration de l’utilisation de la méthode <codeph>getTextFormat()</codeph>. 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:isFontCompatible"><apiName>isFontCompatible</apiName><shortdesc>
	 Renvoie true si une police intégrée est disponible avec les paramètres fontName et fontStyle spécifiés, où Font.fontType est flash.text.FontType.EMBEDDED.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Le paramètre <codeph>fontStyle</codeph> spécifié n’appartient pas à <codeph>flash.text.FontStyle</codeph>.
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph> si une police intégrée compatible est disponible, sinon <codeph>false</codeph>.
	 
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la police intégrée à vérifier.
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Spécifie le style de police à vérifier. Utilisez <codeph>flash.text.FontStyle</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie true si une police intégrée est disponible avec les paramètres <codeph>fontName</codeph> et <codeph>fontStyle</codeph> spécifiés, où <codeph>Font.fontType</codeph> est <codeph>flash.text.FontType.EMBEDDED</codeph>. Depuis Flash Player 10, un fichier SWF peut contenir deux sortes de polices intégrées. Les polices intégrées normales ne sont utilisées qu’avec des objets TextField. Les polices intégrées CFF ne sont utilisées qu’avec les classes flash.text.engine. Les deux types sont différenciés par la propriété <codeph>fontType</codeph> de la classe <codeph>Font</codeph>, renvoyée par la fonction <codeph>enumerateFonts()</codeph>.
	 
	 <p>Un objet TextField ne peut pas utiliser de police de type <codeph>EMBEDDED_CFF</codeph>. Si <codeph>embedFonts</codeph> est défini sur <codeph>true</codeph> et que la seule police disponible au moment de l’exécution avec le nom et le style spécifiés est de type <codeph>EMBEDDED_CFF</codeph>, Flash Player ne peut pas restituer le texte, comme si aucune police n’était disponible avec ce nom et ce style.</p>
	 
	 <p>Si les deux polices <codeph>EMBEDDED</codeph> et <codeph>EMBEDDED_CFF</codeph> sont disponibles avec le même nom et le même style, la police <codeph>EMBEDDED</codeph> est sélectionnée et le texte est restitué avec la police <codeph>EMBEDDED</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link><link href="flash.text.engine.xml#TextBlock/createTextLine"><linktext>flash.text.engine.TextBlock.createTextLine</linktext></link><link href="flash.text.xml#FontType/EMBEDDED_CFF"><linktext>flash.text.FontType.EMBEDDED_CFF</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceSelectedText"><apiName>replaceSelectedText</apiName><shortdesc>
	 Remplace la sélection actuelle par le contenu du paramètre value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.replaceSelectedText, replaceSelectedText
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Cette méthode ne peut pas être appliquée à un champ de texte associé à une feuille de style.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>La chaîne devant remplacer le texte sélectionné.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Remplace la sélection actuelle par le contenu du paramètre value.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Remplace la sélection actuelle par le contenu du paramètre <codeph>value</codeph>. Le texte est inséré au niveau de la sélection actuelle, à l’aide du format de caractère par défaut actuel et du format de paragraphe par défaut. Le texte n’est pas traité en tant que texte HTML.
	 
	 <p>Vous pouvez utiliser la méthode <codeph>replaceSelectedText()</codeph> pour insérer et effacer du texte sans perturber la mise en forme des caractères et de paragraphe du reste du texte.</p>
     <p><b>Remarque :</b> cette méthode ne fonctionne pas lorsqu’une feuille de style est appliquée au champ de texte.</p>
     
	 
	 </apiDesc><example conref="examples\TextField_replaceSelectedTextExample.as"> Dans l’exemple suivant, l’utilisateur efface une partie du texte dans le premier champ de texte en le sélectionnant et remplace un texte sélectionné dans le second champ de texte par la chaîne « NEW TEXT ».
 
 <p>Deux objets TextField différents sont créés et des écouteurs d’événement sont ajoutés pour les événements <codeph>MouseEvent.MOUSE_UP</codeph>. Un relâchement du bouton de la souris survient lorsque l’utilisateur libère le bouton de la souris, événement se produisant généralement après la sélection d’un texte. Notez que le paramètre par défaut d’un champ de texte est que son texte soit sélectionné.</p>
 
 <p>Dans la méthode <codeph>mouseHandler1()</codeph>, lorsqu’un utilisateur libère le bouton de la souris dans le champ de texte <codeph>myTextField1</codeph>, le texte est effacé et remplacé par une chaîne vide. Cela peut continuer jusqu’à ce que tout le texte soit effacé. Dans la méthode <codeph>mouseHandler2()</codeph>, lorsqu’un utilisateur sélectionne du texte dans le champ de texte <codeph>myTextField2</codeph>, les propriétés <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont vérifiées pour voir si des caractères ont été sélectionnés (les propriétés <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> n’ont pas la même valeur si du texte a été sélectionné). Le texte sélectionné est alors remplacé par la chaîne « NEW TEXT ». Cela peut continuer jusqu’à ce que le texte original du second champ de texte soit remplacé par la chaîne « NEW TEXT ».</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;    
    import flash.events.MouseEvent;

    public class TextField_replaceSelectedTextExample extends Sprite {
        private var myTextField1:TextField = new TextField();
        private var myTextField2:TextField = new TextField();
        
        public function TextField_replaceSelectedTextExample() {
            myTextField1.x = 10;
            myTextField1.width = 300;
            myTextField1.height = 50; 
            myTextField1.background = true; 
            myTextField1.border = true;
            myTextField1.text = "Select the text you want to remove from the line.";
            
            myTextField2.x = 10;
            myTextField2.y = 60;
            myTextField2.width = 300;
            myTextField2.height = 50;
            myTextField2.background = true;
            myTextField2.border = true;
            myTextField2.text = "Select the text you want to replace with NEW TEXT.";
            
            myTextField1.addEventListener(MouseEvent.MOUSE_UP, mouseHandler1);
            myTextField2.addEventListener(MouseEvent.MOUSE_UP, mouseHandler2);
            
            this.addChild(myTextField1);
            this.addChild(myTextField2);
        }
        
        private function mouseHandler1(e:MouseEvent):void {
            myTextField1.replaceSelectedText("");
        }

        private function mouseHandler2(e:MouseEvent):void {
            if(myTextField2.selectionBeginIndex != myTextField2.selectionEndIndex) {
                myTextField2.replaceSelectedText("NEW TEXT");    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceText"><apiName>replaceText</apiName><shortdesc>
	 Remplace la plage de caractères que les paramètres beginIndex et endIndex spécifient par le contenu du paramètre newText.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Cette méthode ne peut pas être appliquée à un champ de texte associé à une feuille de style.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>La valeur d’index de base zéro pour la position de début de la plage de remplacement.
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Position d’index de base zéro du premier caractère après la plage de texte désirée.
	 </apiDesc></apiParam><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Texte à utiliser pour remplacer la plage de caractères spécifiée.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Remplace une plage de caractères.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Remplace la plage de caractères que les paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph> spécifient par le contenu du paramètre <codeph>newText. </codeph> Comme prévu, le texte situé entre de <codeph>beginIndex</codeph> et <codeph>endIndex-1</codeph> est remplacé.  
     <p><b>Remarque :</b> cette méthode ne fonctionne pas lorsqu’une feuille de style est appliquée au champ de texte.</p>
     
	 </apiDesc><example conref="examples\TextField_replaceTextExample.as"> L’exemple suivant utilise la méthode <codeph>replaceText()</codeph> pour supprimer, remplacer et insérer du texte dans un champ de texte.
 
 <p>Le champ de texte <codeph>outputText</codeph> est défini pour s’adapter automatiquement au texte et se redimensionner sous forme de texte justifié à gauche. Avec le premier appel de la méthode <codeph>replaceText()</codeph>, la première ligne (« This is the wrong heading ») est remplacée par « THIS IS THE HEADING FOR EVERYONE ». Avec le second appel de la méthode, le texte « CORRECT » est inséré entre « THE » et « HEADING ». Avec le troisième appel de la méthode, les mots « FOR EVERYONE » sont supprimés. Notez qu’à chaque appel de la méthode <codeph>appendText()</codeph>, les index de début et de fin du texte en cours sont modifiés. Ici, seul le texte final (après modification) apparaît.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_replaceTextExample extends Sprite {

        public function TextField_replaceTextExample() {
            var outputText:TextField = new TextField();

            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
            
            outputText.appendText("This is the wrong heading");
            outputText.appendText("\n\n"); 
            outputText.appendText("This is the body of the text.");

            outputText.replaceText(0, 25, "THIS IS THE HEADING FOR EVERYONE");

            outputText.replaceText(12, 12, "CORRECT ");
            
            outputText.replaceText(27, 40, "");
            
           this.addChild(outputText);
         }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:setSelection"><apiName>setSelection</apiName><shortdesc>
	 Définit comme sélectionné le texte désigné par les valeurs d’index des premier et dernier caractères, spécifiés par les paramètres beginIndex et endIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index basée sur zéro du premier caractère de la sélection (par exemple, le premier caractère est 0, le deuxième est 1, etc.).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index basée sur zéro du dernier caractère de la sélection.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Définit une nouvelle sélection de texte.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Définit comme sélectionné le texte désigné par les valeurs d’index des premier et dernier caractères, spécifiés par les paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. Si les valeurs des deux paramètres sont identiques, cette méthode définit le point d’insertion, comme si vous définissiez la propriété <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_setSelectionExample.as"> Dans l’exemple suivant, une plage de texte prédéfinie est sélectionnée lorsque l’utilisateur clique en un endroit quelconque du champ de texte (mettant en surbrillance les mots « TEXT IN ALL CAPS »).
 
 <p>Deux écouteurs d’événement pour le champ de texte <codeph>myTextField</codeph> répondent aux clics de souris et aux relâchements du bouton de la souris par l’utilisateur. Un relâchement du bouton de la souris survient lorsque l’utilisateur libère le bouton de la souris, événement se produisant généralement après la sélection d’un texte. Notez que le paramètre par défaut d’un champ de texte est que son texte soit sélectionné. Lorsque l’utilisateur clique dans le texte, la méthode <codeph>clickHandler()</codeph> est invoquée. Lorsque du texte est sélectionné et que le bouton de la souris est relâché, la méthode <codeph>mouseUpHandler()</codeph> est invoquée.</p>
 
 <p>Dans les deux méthodes <codeph>clickHandler()</codeph> et <codeph>mouseUpHandler()</codeph>, la méthode <codeph>setSelection()</codeph> définit uniquement la sélection des caractères situés entre les index 54 et 70 (TEXT IN ALL CAPS).</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_setSelectionExample extends Sprite
    {
        private var myTextField:TextField = new TextField();

        public function TextField_setSelectionExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS is selected.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            myTextField.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);

            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

        private function mouseUpHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:setTextFormat"><apiName>setTextFormat</apiName><shortdesc>
	 Applique à la partie sélectionnée d’un champ de texte le format spécifié par le paramètre format.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.setTextFormat, setTextFormat
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Cette méthode ne peut pas être appliquée à un champ de texte associé à une feuille de style.
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>La valeur <codeph>beginIndex</codeph> ou <codeph>endIndex</codeph> est hors limite.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier><apiDesc>Un objet TextFormat qui contient des informations de format de caractères et de paragraphes.
	 
     </apiDesc></apiParam><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Facultatif ; entier qui spécifie la position d’index de base zéro indiquant le premier caractère de la plage de texte désirée.
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Facultatif ; entier qui spécifie le premier caractère après la plage de texte désirée. Si vous spécifiez les valeurs <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>, le texte situé entre <codeph>beginIndex</codeph> et <codeph>endIndex-1</codeph> est mis à jour.  
	 
	 <p>
	 <adobetable class="innertable">
	   
	   
	  
	   
	   
	 
	 <tgroup cols="2"><thead><row><entry>Utilisation</entry><entry>Description</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat)</codeph></entry>
	 
	     <entry>Applique les propriétés de <codeph>textFormat</codeph> à l’ensemble du texte dans le champ de texte.</entry>
	   </row><row>
	 
	 <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int)</codeph></entry>
	 
	     <entry>Applique les propriétés de <codeph>textFormat</codeph> au texte qui commence à la position <codeph>beginIndex</codeph>.</entry>
	   </row><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int, endIndex:int)</codeph></entry>
	 	   <entry>Applique les propriétés du paramètre <codeph>textFormat</codeph> à la plage de texte de la position <codeph>beginIndex</codeph> à la position <codeph>endIndex-1</codeph>.</entry>
	   </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>Notez que tout texte inséré manuellement par l’utilisateur, ou remplacé par la méthode <codeph>replaceSelectedText()</codeph>, reçoit la mise en forme par défaut pour un nouveau texte, et non celle spécifiée pour le point d’insertion du texte. Pour définir le formatage par défaut du nouveau texte du champ, appliquez la propriété <codeph>defaultTextFormat</codeph>.</p>
	 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Applique du formatage au texte.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Applique à la partie sélectionnée d’un champ de texte le format spécifié par le paramètre <codeph>format</codeph>. La valeur de <codeph>format</codeph> doit être un objet TextFormat qui spécifie les modifications à apporter au formatage du texte. Seules les propriétés non null de <codeph>format</codeph> sont appliquées au champ de texte. Toute propriété de <codeph>format</codeph> qui est définie sur <codeph>null</codeph> n’est pas appliquée. Par défaut, toutes les propriétés d’un nouvel objet TextFormat créé sont définies sur <codeph>null</codeph>.
     <p><b>Remarque :</b> cette méthode ne fonctionne pas lorsqu’une feuille de style est appliquée au champ de texte.</p>
     
	 <p>La méthode <codeph>setTextFormat()</codeph> modifie la mise en forme de texte appliquée à une plage de caractères ou à l’ensemble du corps de texte d’un champ de texte. Pour appliquer les propriétés de format à l’ensemble du texte du champ, ne spécifiez pas de valeur pour <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. Pour appliquer les propriétés de format à une plage de texte, spécifiez les valeurs des paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. Vous pouvez utiliser la propriété <codeph>length</codeph> pour déterminer les valeurs d’index.</p>
	 
	 <p>Les deux types d’information de formatage d’un objet TextFormat correspondent au formatage au niveau des caractères et au formatage au niveau du paragraphe. Chaque caractère d’un champ de texte peut avoir ses propres paramètres de mise en forme de caractère, tels que le nom et la taille de la police, gras et italique.</p>
	 
	 <p>Pour les paragraphes, le premier caractère du paragraphe est analysé pour les paramètres de mise en forme du paragraphe entier. La marge gauche, la marge droite et le retrait sont des exemples de paramètres de mise en forme de paragraphe.</p>
	 
	 <p>Tout texte inséré manuellement par l’utilisateur, ou remplacé par la méthode <codeph>replaceSelectedText()</codeph>, reçoit la mise en forme par défaut pour un nouveau texte, et non celle spécifiée pour le point d’insertion du texte. Pour définir le formatage par défaut du nouveau texte, utilisez <codeph>defaultTextFormat</codeph>.</p>
	 
	 </apiDesc><example conref="examples\TextField_setTextFormatExample.as"> Dans l’exemple suivant, lorsque l’utilisateur clique sur le texte, le format d’une plage de texte définie, « TEXT IN ALL CAPS », bascule entre le format de texte par défaut et le nouveau format.
 
 <p>Un écouteur d’événement pour le champ de texte <codeph>myTextField</codeph> est ajouté pour répondre aux clics de souris en invoquant la méthode <codeph>clickHandler()</codeph>. Dans la méthode <codeph>clickHandler()</codeph>, la méthode <codeph>getTextFormat()</codeph> renvoie le format en cours d’un caractère (index 55) de la plage de texte prévue, qui est alors placée dans l’objet TextFormat <codeph>currentTextFormat</codeph>. L’instruction<codeph>if</codeph> vérifie le format de texte <codeph>currentTextFormat</codeph> pour voir si le caractère de la plage utilise le nouveau format (la police est définie sur 18). Si ce n’est pas le cas, le nouveau format définit la taille de police sur 18 points, la couleur sur rouge et souligne et met en italique la plage de texte située entre 54 et 70 (TEXT IN ALL CAPS). Si le caractère de la plage utilise le nouveau format, le format de la plage est réinitialisé sur le format par défaut (original) du champ de texte.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;  
    import flash.text.TextFieldAutoSize;  
    import flash.events.MouseEvent;

    public class TextField_setTextFormatExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextField_setTextFormatExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.selectable = false;
            myTextField.background = true;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS changes format.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            newFormat.color = 0xFF0000;
            newFormat.size = 18;
            newFormat.underline = true;
            newFormat.italic = true;
                
            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            var currentTextFormat:TextFormat = myTextField.getTextFormat(55);
            
            if(currentTextFormat.size != 18) {
                myTextField.setTextFormat(newFormat, 54, 70);
            }
            else {
                myTextField.setTextFormat(myTextField.defaultTextFormat);
            }    
        }    
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextField:alwaysShowSelection:get"><apiName>alwaysShowSelection</apiName><shortdesc>
	Lorsque défini sur true et si le champ de texte n’a pas le focus, Flash Player sélectionne le contenu du champ de texte en gris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
    
	</apiDefaultValue></apiValueDef><apiDesc>
	Lorsque défini sur <codeph>true</codeph> et si le champ de texte n’a pas le focus, Flash Player sélectionne le contenu du champ de texte en gris. Lorsque défini sur <codeph>false</codeph> et si le champ de texte n’a pas le focus, Flash Player ne sélectionne pas le contenu du champ de texte.
	
    </apiDesc><example conref="examples\TextField_alwaysShowSelection.as"> Compile et exécute le fichier suivant. Lorsque vous exécutez le fichier, faites glisser pour sélectionner le texte dans chacun des deux champs texte et remarquez les différentes sélections obtenues lorsque vous sélectionnez du texte dans les deux champs (changement de focus) :
<codeblock>

    package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_alwaysShowSelection extends Sprite {
        public function TextField_alwaysShowSelection() {
            var label1:TextField = createCustomTextField(0, 20, 200, 20);
            label1.text = "This text is selected.";
            label1.setSelection(0, 9);
            label1.alwaysShowSelection = true;

            var label2:TextField = createCustomTextField(0, 50, 200, 20);
            label2.text = "Drag to select some of this text.";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x; result.y = y;
            result.width = width; result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:antiAliasType:get"><apiName>antiAliasType</apiName><shortdesc>
	 Type d’anti-aliasing appliqué à ce champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>This example creates two text fields and applies advanced anti-aliasing to the first one
	 only.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "This text uses advanced anti-aliasing.";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "This text uses normal anti-aliasing."
	 my_text2.antiAliasType = "normal";
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Type d’anti-aliasing appliqué.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Type d’anti-aliasing appliqué à ce champ de texte. Utilisez les constantes <codeph>flash.text.AntiAliasType</codeph> pour cette propriété. Vous ne pouvez contrôler cette définition que si la police est intégrée (avec la propriété <codeph>embedFonts</codeph> définie sur <codeph>true</codeph>). Le paramètre par défaut est <codeph>flash.text.AntiAliasType.NORMAL</codeph>.
	 
	 <p>Pour définir les valeurs pour cette propriété, utilisez les valeurs de chaîne suivantes :</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Valeur de chaîne</entry><entry>Description</entry></row></thead><tbody><row>
	 	<entry><codeph>flash.text.AntiAliasType.NORMAL</codeph></entry>
	 	<entry>Applique un anti-aliasing ordinaire au texte. Cette valeur correspond au type d’anti-aliasing utilisé par Flash Player 7 et les versions précédentes.</entry>
	   </row><row>
	   	<entry><codeph>flash.text.AntiAliasType.ADVANCED</codeph></entry>
	 	<entry>Applique un anti-aliasing avancé qui rend le texte plus lisible (cette fonctionnalité est devenue disponible dans Flash Player 8). Anti-aliasing avancé permet d’obtenir une qualité du rendu des polices de petite taille. Cette option convient particulièrement aux applications comportant beaucoup de texte de petite taille. L’anti-aliasing avancé n’est pas recommandé pour les polices de plus de 48 points.</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link><link href="flash.text.xml#TextField/embedFonts"><linktext>flash.text.TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:autoSize:get"><apiName>autoSize</apiName><shortdesc>
	 Commande le dimensionnement et l’alignement automatiques des champs texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.autoSize, autoSize
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Le paramètre <codeph>autoSize</codeph> spécifié n’appartient pas à flash.text.TextFieldAutoSize.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Commande le dimensionnement et l’alignement automatiques des champs texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Commande le dimensionnement et l’alignement automatiques des champs texte. Les valeurs acceptables pour les constantes <codeph>TextFieldAutoSize</codeph> sont : <codeph>TextFieldAutoSize.NONE</codeph> (par défaut), <codeph>TextFieldAutoSize.LEFT</codeph>, <codeph>TextFieldAutoSize.RIGHT</codeph> et <codeph>TextFieldAutoSize.CENTER</codeph>.
	 
	 <p>Si <codeph>autoSize</codeph> est défini sur <codeph>TextFieldAutoSize.NONE</codeph> (par défaut), aucun redimensionnement n’a lieu.</p>
	 
	 <p>Si <codeph>autoSize</codeph> est défini sur <codeph>TextFieldAutoSize.LEFT</codeph>, le texte est alors traité comme du texte cadré à gauche, ce qui signifie que la marge gauche du champ de texte reste fixe et tout redimensionnement d’un champ de texte sur une seule ligne se fera dans la marge de droite. Si le texte contient un saut de ligne (par exemple <codeph>"\n"</codeph> ou <codeph>"\r"</codeph>) le bas est alors également redimensionné pour s’adapter à la ligne suivante du texte. Si <codeph>wordWrap</codeph> est également défini sur <codeph>true</codeph>, seul le bas du champ de texte est redimensionné et le côté droit reste fixe.</p>
	 
	 <p>Si <codeph>autoSize</codeph> est défini sur <codeph>TextFieldAutoSize.RIGHT</codeph>, le texte est alors traité comme du texte cadré à droite, ce qui signifie que la marge droite du champ de texte reste fixe et tout redimensionnement d’un champ de texte sur une seule ligne se fera dans la marge de gauche. Si le texte contient un saut de ligne (par exemple <codeph>"\n" ou "\r")</codeph>) le bas est alors également redimensionné pour s’adapter à la ligne suivante du texte. Si <codeph>wordWrap</codeph> est également défini sur <codeph>true</codeph>, seul le bas du champ de texte est redimensionné et le côté gauche reste fixe.</p>
	 
	 <p>Si <codeph>autoSize</codeph> est défini sur <codeph>TextFieldAutoSize.CENTER</codeph>, le texte est traité comme du texte centré, ce qui signifie que tout redimensionnement d’un champ de texte sur une seule ligne est uniformément réparti sur les marges droite et gauche. Si le texte contient un saut de ligne (par exemple <codeph>"\n"</codeph> ou <codeph>"\r"</codeph>) le bas est alors également redimensionné pour s’adapter à la ligne suivante du texte. Si <codeph>wordWrap</codeph> est également défini sur <codeph>true</codeph>, seul le bas du champ de texte est redimensionné et les côtés gauche et droit restent fixe.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFieldAutoSize"><linktext>flash.text.TextFieldAutoSize</linktext></link><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>flash.text.TextField.wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:background:get"><apiName>background</apiName><shortdesc>
	 Spécifie si le champ de texte a un remplissage d’arrière-plan.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.background, background
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Spécifie si le champ de texte a un remplissage d’arrière-plan. Si <codeph>true</codeph>, le champ de texte a un remplissage d’arrière-plan. Si <codeph>false</codeph>, le champ de texte n’a pas de remplissage d’arrière-plan. La propriété <codeph>backgroundColor</codeph> permet de définir la couleur d’arrière-plan d’un champ de texte.
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/backgroundColor"><linktext>flash.text.TextField.backgroundColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:backgroundColor:get"><apiName>backgroundColor</apiName><shortdesc>
	 Couleur de l’arrière-plan du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.backgroundColor, backgroundColor, background Color
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Couleur de l’arrière-plan du champ de texte. La valeur par défaut est <codeph>0xFFFFFF</codeph> (blanc). Cette propriété peut être extraite ou définie, même s’il n’y a pas encore d’arrière-plan, mais la couleur n’est visible que si la propriété <codeph>background</codeph> du champ de texte est définie sur <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/background"><linktext>flash.text.TextField.background</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:border:get"><apiName>border</apiName><shortdesc>
	 Spécifie si le champ de texte comporte une bordure.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.border, border
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Spécifie si le champ de texte comporte une bordure. Si <codeph>true</codeph>, le champ de texte comporte une bordure. Si <codeph>false</codeph>, le champ de texte ne comporte pas de bordure. La propriété <codeph>borderColor</codeph> permet de définir la couleur de la bordure.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/borderColor"><linktext>flash.text.TextField.borderColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:borderColor:get"><apiName>borderColor</apiName><shortdesc>
	 Couleur de la bordure du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.borderColor, borderColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Couleur de la bordure du champ de texte. La valeur par défaut est <codeph>0x000000</codeph> (noir). Cette propriété peut être extraite ou définie, même s’il n’y a pas encore de bordure, mais la couleur n’est visible que si la propriété <codeph>border</codeph> du champ de texte est définie sur <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/border"><linktext>flash.text.TextField.border</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:bottomScrollV:get"><apiName>bottomScrollV</apiName><shortdesc>
	 Entier (index basé sur 1) qui indique la ligne la plus basse visible dans le champ de texte spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.bottomScrollV, bottomScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Un entier qui correspond à la ligne inférieure d’un champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Entier (index basé sur 1) qui indique la ligne la plus basse visible dans le champ de texte spécifié. Considérez le champ de texte comme une fenêtre sur un bloc de texte. La propriété <codeph>scrollV</codeph> est l’index basé sur 1 de la ligne la plus haute et visible dans la fenêtre.
	 
	 <p>Tout le texte situé entre les lignes désignées par <codeph>scrollV</codeph> et <codeph>bottomScrollV</codeph> est visible dans le champ de texte.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:caretIndex:get"><apiName>caretIndex</apiName><shortdesc>
	 L’index de la position du point d’insertion (caret).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Renvoie la valeur d’index de base zéro du point d’insertion clignotant.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 L’index de la position du point d’insertion (caret). Si aucun point d’insertion ne s’affiche, cette valeur correspond à la position du point d’insertion en cas de restauration du focus sur le champ (il s’agit généralement du dernier emplacement du point d’insertion, ou 0 si le champ n’a pas eu le focus).
	 
	 <p>Les index de plages de sélection sont basés sur zéro (par exemple, la première position est 0, la deuxième position est 1, etc.).</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> Dans cet exemple, une occurrence de TextField est créée et remplie avec du texte. Un écouteur d’événement est affecté de façon à ce que l’utilisateur clique sur TextField, la méthode <codeph>printCursorPosition</codeph> est appelée. Dans ce cas, les valeurs des propriétés <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont renvoyées.
 
 <p>Exécutez cet exemple, puis essayez de cliquer dans TextField pour sélectionner le texte. Cliquez ensuite dans le champ sans sélectionner de texte. Lorsque vous cliquez sur le texte sans faire de sélection, la propriété <codeph>caretIndex</codeph> indique l’emplacement du point d’insertion et les propriétés <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont égales à la valeur de la propriété <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:condenseWhite:get"><apiName>condenseWhite</apiName><shortdesc>
	 Valeur booléenne qui indique si l’espace blanc supplémentaire (espaces, saut de ligne, etc.) est supprimé dans un champ de texte HTML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>textfield, text, HTML
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Valeur booléenne qui spécifie si l’espace blanc supplémentaire est supprimé dans un champ contenant du texte HTML.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur booléenne qui indique si l’espace blanc supplémentaire (espaces, saut de ligne, etc.) est supprimé dans un champ de texte HTML. La valeur par défaut est <codeph>false</codeph>. La propriété <codeph>condenseWhite</codeph> n’affecte que le texte défini avec la propriété <codeph>htmlText</codeph>, pas la propriété <codeph>text</codeph>. Si vous définissez du texte avec la propriété <codeph>text</codeph>, la propriété <codeph>condenseWhite</codeph> est ignorée.
	 
	 <p>Si la propriété <codeph>condenseWhite</codeph> est définie sur <codeph>true</codeph>, utilisez les commandes HTML classiques, telles que <codeph>&lt;BR></codeph> et <codeph>&lt;P></codeph>, pour placer des sauts de ligne dans le champ de texte.</p>
	 
	 <p>Définissez la propriété <codeph>condenseWhite</codeph> avant de définir la propriété <codeph>htmlText</codeph>.</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_condenseWhite.as"> L’exemple suivant révèle la différence entre la définition du paramètre <codeph>condenseWhite</codeph> sur <codeph>false</codeph> et sa définition sur <codeph>true</codeph> :
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_condenseWhite extends Sprite {
        public function TextField_condenseWhite() {
            var tf1:TextField = createCustomTextField(0, 0, 200, 50);
            tf1.condenseWhite = false;
            tf1.htmlText = "keep    on\n\ttruckin'";
            
            var tf2:TextField = createCustomTextField(0, 120, 200, 50);
            tf2.condenseWhite = true;
            tf2.htmlText = "keep    on\n\ttruckin'";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:defaultTextFormat:get"><apiName>defaultTextFormat</apiName><shortdesc>
	 Spécifie le format appliqué au texte qui vient d’être inséré, notamment au texte saisi par un utilisateur ou inséré à l’aide de la méthode replaceSelectedText().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.defaultTextFormat, defaultTextFormat
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:TextFormat</apiValueClassifier><apiException><apiDesc>Cette méthode ne peut pas être appliquée à un champ de texte associé à une feuille de style.
	  
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Spécifie le format du texte qui vient d’être inséré.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie le format appliqué au texte qui vient d’être inséré, notamment au texte saisi par un utilisateur ou inséré à l’aide de la méthode <codeph>replaceSelectedText()</codeph>.
	 
	 <p><b>Remarque :</b> lorsque vous sélectionnez des caractères en vue de les remplacer à l’aide des méthodes <codeph>setSelection()</codeph> et <codeph>replaceSelectedText()</codeph>, la propriété <codeph>defaultTextFormat</codeph> est appliquée uniquement si la totalité du texte (y compris le dernier caractère) a été sélectionnée. Voici un exemple :</p>
	 <pre>
	 var my_txt:TextField new TextField();
	 my_txt.text = "Flash Macintosh version";
	 var my_fmt:TextFormat = new TextFormat();
	 my_fmt.color = 0xFF0000;
	 my_txt.defaultTextFormat = my_fmt;
	 my_txt.setSelection(6,15); // partial text selected - defaultTextFormat not applied
	 my_txt.setSelection(6,23); // text selected to end - defaultTextFormat applied
	 my_txt.replaceSelectedText("Windows version");
	 </pre>
	 
	 <p>Lorsque vous accédez à la propriété <codeph>defaultTextFormat</codeph>, l’objet TextFormat renvoyé voit toutes ses propriétés définies. Aucune propriété n’a la valeur <codeph>null</codeph>.</p>
     <p><b>Remarque :</b> Vous ne pouvez pas définir cette propriété lorsqu’une feuille de style est appliquée au champ de texte.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/replaceSelectedText()"><linktext>flash.text.TextField.replaceSelectedText()</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:displayAsPassword:get"><apiName>displayAsPassword</apiName><shortdesc>
	 Indique si le champ de texte est un champ de texte de mot de passe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.password, password
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Indique si les caractères saisis sont masqués.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Indique si le champ de texte est un champ de texte de mot de passe. Si la valeur de cette propriété est <codeph>true</codeph>, le champ de texte est traité en tant que mot de passe et masque les caractères d’entrée en utilisant les astérisques à la place des caractères. Si <codeph>false</codeph>, le champ de texte n’est pas traité comme un mot de passe. Lorsque le mode mot de passe est activé, les commandes Couper et Copier et leurs raccourcis clavier ne fonctionnent pas. Ce mécanisme de sécurité empêche un utilisateur malhonnête d’utiliser les raccourcis pour découvrir le mot de passe d’un ordinateur sans surveillance.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:embedFonts:get"><apiName>embedFonts</apiName><shortdesc>
	 Spécifie si le rendu doit utiliser des polices vectorielles incorporées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.embedFonts, embedFonts
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Procède au rendu du champ de texte contenant des polices vectorielles ou de périphérique.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Spécifie si le rendu doit utiliser des polices vectorielles incorporées. Si <codeph>false</codeph>, Flash Player restitue le champ de texte à l’aide de polices de périphérique.
	 
	 <p>Si vous définissez la propriété <codeph>embedFonts</codeph> sur <codeph>true</codeph> pour un champ de texte, vous devez spécifier la police du texte par l’intermédiaire de la propriété <codeph>font</codeph> d’un objet TextFormat appliqué au champ de texte. Si la police spécifiée n’est pas intégrée dans le fichier SWF, le texte ne s’affiche pas.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#Font/enumerateFonts()"><linktext>Font.enumerateFonts()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:gridFitType:get"><apiName>gridFitType</apiName><shortdesc>
	 Type d’adaptation à la grille appliqué à ce champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example shows three text fields that use the
	 different <code>flash.text.GridFitType</code> settings.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 9.5, 10, 400, 100);
	 my_text1.text = "this.gridFitType = none";
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "none";
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 9.5, 40, 400, 100);
	 my_text2.text = "this.gridFitType = advanced";
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 9.5, 70, 400, 100);
	 my_text3.text = "this.gridFitType = subpixel";
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "subpixel";
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>pixel
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Type d’adaptation à la grille appliqué.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Type d’adaptation à la grille appliqué à ce champ de texte. Cette propriété s’applique uniquement si la propriété <codeph>flash.text.AntiAliasType</codeph> du champ de texte est définie sur <codeph>flash.text.AntiAliasType.ADVANCED</codeph>.
	 
	 <p>Le type d’adaptation à la grille utilisé détermine si Flash Player force les lignes horizontales et verticales fortes à s’aligner sur une grille de pixels ou sous-pixels, ou pas du tout.</p>
	 
	 <p>Pour la propriété <codeph>flash.text.GridFitType</codeph>, vous pouvez utiliser les valeurs de chaînes suivantes :</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Valeur de chaîne</entry><entry>Description</entry></row></thead><tbody><row>
	     <entry><codeph>flash.text.GridFitType.NONE</codeph></entry>
	     <entry>Ne spécifie pas d’adaptation à la grille. Les lignes horizontales et verticales des glyphes ne sont pas alignées sur la grille de pixels. Ce paramètre est conseillé pour les animations ou les grandes polices.</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.PIXEL</codeph></entry>
	     <entry>Spécifie que les lignes horizontales et verticales fortes sont adaptées à la grille de pixels. Ce paramètre convient uniquement aux champs texte alignés à gauche. Pour utiliser ce paramètre, la propriété <codeph>flash.display.AntiAliasType</codeph> du champ de texte doit être définie sur <codeph>flash.text.AntiAliasType.ADVANCED</codeph>. Ce paramètre rend généralement le texte justifié à gauche plus lisible.</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.SUBPIXEL</codeph></entry>
	     <entry>Spécifie que les lignes horizontales et verticales fortes sont adaptées à la grille de sous-pixels sur les écrans à cristaux liquides. Pour utiliser ce paramètre, la propriété <codeph>flash.text.AntiAliasType</codeph> du champ de texte doit être défini sur <codeph>flash.text.AntiAliasType.ADVANCED</codeph>. Le paramètre <codeph>flash.text.GridFitType.SUBPIXEL</codeph> est généralement préférable pour le texte dynamique aligné à droite ou centré et permet parfois d’établir un bon compromis entre la qualité d’animation et la qualité du texte.</entry>
	   </row></tbody></tgroup></adobetable>
	 
     </apiDesc><example conref="examples\TextField_gridFitType.as"> L’exemple suivant montre trois champs de texte avec des paramètres différents pour la propriété <codeph>gridFitType</codeph>. Lorsque vous utilisez cet exemple, notez la différence de netteté des deux premières lignes. Remarquez également l’utilisation optimale de <codeph>GridFitType.PIXEL</codeph> pour le texte aligné à gauche et de <codeph>GridFitType.SUBPIXEL</codeph> pour le texte aligné à droite.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;

    public class gridFitTypeExample extends Sprite
    {
        public function gridFitTypeExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=12;

    var tf1:TextField = createCustomTextField(0,0,format1,"NONE",TextFieldAutoSize.LEFT,GridFitType.NONE);
    
    var tf2:TextField = createCustomTextField(0,30,format1,"PIXEL",TextFieldAutoSize.LEFT,GridFitType.PIXEL);

    var tf3:TextField = createCustomTextField(300,60,format1,"SUBPIXEL",TextFieldAutoSize.RIGHT,GridFitType.SUBPIXEL);

        }
        private function createCustomTextField(x:Number,y:Number,fm:TextFormat,tl:String,tfs:String,gft:String):TextField 
        {
            var result:TextField = new TextField();
            result.x=x;
            result.y=y;
            result.embedFonts=true;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.text="This text uses a gridFitType of " + tl;
            result.autoSize=tfs;
        result.gridFitType=gft;
            result.setTextFormat(fm);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#GridFitType"><linktext>flash.text.GridFitType</linktext></link><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:htmlText:get"><apiName>htmlText</apiName><shortdesc>
	 Contient la représentation HTML du contenu du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.htmlText, htmlText
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Représentation HTML du contenu du champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Contient la représentation HTML du contenu du champ de texte. 
	 
	 <p>Flash Player prend en charge les balises HTML suivantes :</p>
	 
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 Balise
	 </entry><entry>
	 Description
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 Balise d’ancrage
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;a></codeph> crée un hyperlien et prend en charge les attributs suivants :
	 <ul>
	 
	 <li>
	 <codeph>target</codeph> : Désigne le nom de la fenêtre cible dans laquelle vous chargez la page. Les options incluent <codeph>_self</codeph>, <codeph>_blank</codeph>, <codeph>_parent</codeph> et <codeph>_top</codeph>. L’option <codeph>_self</codeph>spécifie l’image active dans la fenêtre actuelle, <codeph>_blank</codeph> spécifie une nouvelle fenêtre, <codeph>_parent</codeph> spécifie le parent de l’image active et <codeph>_top</codeph> spécifie l’image de plus haut niveau dans la fenêtre active. 
	 </li>
	 
	 <li>
	 <codeph>href</codeph> : spécifie une URL ou un événement <codeph>link</codeph> ActionScript. L’URL peut être absolue ou relative à l’emplacement du fichier SWF qui charge la page. Par exemple, l’URL <codeph>http://www.adobe.com</codeph> constitue une référence absolue, alors que <codeph>/index.html</codeph> est une référence relative. Les URL absolues doivent être précédées du préfixe http:// ; dans le cas contraire, Flash ou AIR les considère comme des URL relatives. Vous pouvez utiliser l’événement <codeph>link</codeph> pour que le lien exécute une fonction ActionScript dans un fichier SWF au lieu d’ouvrir une URL. Pour spécifier un événement <codeph>link</codeph>, utilisez le modèle d’événement plutôt que le modèle http dans votre attribut <codeph>href</codeph>. <codeph>href="event:myText"</codeph> au lieu de <codeph>href="http://myURL"</codeph> en est un exemple ; lorsque l’utilisateur clique sur un lien hypertexte contenant le modèle d’événement, le champ de texte distribue un TextEvent <codeph>link</codeph> avec sa propriété <codeph>text</codeph> définie sur "<codeph>myText</codeph>". Vous pouvez alors créer une fonction ActionScript qui s’exécute chaque fois que le lien TextEvent est distribué. Vous pouvez également définir des styles <codeph>a:link</codeph>, <codeph>a:hover</codeph> et <codeph>a:active</codeph> pour les balises d’ancrage en utilisant les feuilles de style.
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Bold
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;b></codeph> met le texte en gras. Des caractères en gras doivent être disponibles dans la police utilisée.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Break
	 </entry>
	 <entry>
	 La balise <codeph>&lt;br></codeph> introduit un saut de ligne dans le champ de texte. Spécifie que le champ de texte doit être multiligne pour utiliser cette balise.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Font
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;font></codeph> spécifie une police ou une liste de polices pour afficher le texte. La balise font prend en charge les attributs suivants :
	 <ul>
	 
	 <li>
	 <codeph>color</codeph> : Seules les valeurs de couleur hexadécimales (<codeph>#FFFFFF</codeph>) sont prises en charge. 
	 </li>
	 
	 <li>
	 <codeph>face</codeph> : Désigne le nom de la police à utiliser. Comme indiqué dans l’exemple suivant, vous pouvez spécifier des noms de police séparés par des virgules, auquel cas Flash Player sélectionne la première balise disponible. Si la police spécifiée n’est pas installée sur le système informatique local ou si elle n’est pas intégrée dans le fichier SWF, Flash Player sélectionne une police de remplacement. 
	 </li>
	 
	 <li>
	 <codeph>size</codeph> : Désigne la taille de la police. Vous pouvez appliquer des tailles de pixel absolues, telles que 16 ou 18, ou relatives, telles que +2 ou -4. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Image 
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;img></codeph> vous permet d’intégrer des fichiers image (JPEG, GIF, PNG), des fichiers SWF et des clips externes à l’intérieur des champs de texte et des occurrences au sein des champs texte. Le texte se déroule automatiquement autour des images intégrées dans les champs de texte. Vous devez définir le champ de texte sur multiligne pour placer un texte autour d’une image. 
	 
	  <p>La balise <codeph>&lt;img></codeph> prend en charge les attributs suivants : </p>
	 
	 <ul>
	 
	 <li>
	 <codeph>src</codeph> : Spécifie l’URL vers un fichier image ou SWF, ou l’identifiant de liaison pour un symbole de clip dans la bibliothèque. Cet attribut est requis ; tous les autres attributs sont facultatifs. Les fichiers externes (JPEG, GIF, PNG et SWF) ne s’affichent pas tant qu’ils ne sont pas entièrement téléchargés. 
	 </li>
	 
	 <li>
	 <codeph>width</codeph> : Largeur de l’image, du fichier SWF ou du clip inséré, en pixels. 
	 </li>
	 
	 <li>
	 <codeph>height</codeph> : Hauteur de l’image, du fichier SWF ou du clip inséré, en pixels. 
	 </li>
	 
	 <li>
	 <codeph>align</codeph> : Spécifie l’alignement horizontal de l’image intégrée dans le champ de texte. Les valeur valides sont <codeph>left</codeph> et <codeph>right</codeph>. La valeur par défaut est <codeph>left</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>hspace</codeph> : Spécifie l’espace horizontal qui entoure l’image là où aucun texte n’apparaît. La valeur par défaut est 8. 
	 </li>
	 
	 <li>
	 <codeph>vspace</codeph> : Spécifie l’espace vertical qui entoure l’image là où aucun texte n’apparaît. La valeur par défaut est 8.  
	 </li>
	 
	 <li>
	 <codeph>id</codeph> : Spécifie le nom d’une occurrence de clip (créée par Flash Player) contenant l’élément intégré (fichier image, SWF ou clip). Cette approche est utilisée pour contrôler le contenu intégré avec ActionScript. 
	 </li>
	 
	 <li>
	 <codeph>checkPolicyFile</codeph> : spécifie que Flash Player doit rechercher un fichier de régulation d’URL sur le serveur associé au domaine de l’image. En présence d’un fichier de régulation, les fichiers SWF figurant dans les domaines identifiés par ce fichier de régulation peuvent accéder aux données de l’image chargée, par exemple en appelant la méthode <codeph>BitmapData.draw()</codeph> avec cette image en tant que paramètre <codeph>source</codeph>. Pour plus d’informations, consultez le chapitre « Sécurité de Flash Player » du manuel <i>Programmation d’ActionScript 3.0</i>.
	 </li>
	 
	 </ul>
	  <p>Flash affiche le média intégré dans un champ de texte, à sa taille normale. Pour spécifier les dimensions du média à intégrer, utilisez les attributs <codeph>height</codeph> et <codeph>width</codeph> de la balise <codeph>&lt;img></codeph>. </p>
	 
	  <p>En général, une image intégrée dans un champ de texte apparaît sur la ligne qui suit la balise <codeph>&lt;img></codeph>. Cependant, lorsque la balise <codeph>&lt;img></codeph> est le premier caractère dans le champ de texte, l’image apparaît sur la première ligne du champ de texte. </p>
	 
	 <p>Pour le contenu AIR dans le sandbox de sécurité de l’application, AIR ignore les balises <codeph>img</codeph> dans le contenu HTML des objets TextField ActionScript, afin d’éviter les tentatives d’hameçonnage,</p>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Italic
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;i></codeph> affiche le texte entre balises en italiques. Des caractères italiques doivent être disponibles dans la police utilisée.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise List item
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;li></codeph> insère une puce juste avant le texte sur lequel elle porte. <b>Remarque :</b> dans la mesure où Flash Player et AIR ne permettent pas d’identifier les balises de liste triées ou non triées (<codeph>&lt;ol></codeph> et <codeph>&lt;ul></codeph>), ces dernières n’ont aucun effet sur le rendu de la liste. Toutes les listes restent non triées et tous les éléments de la liste sont précédés par des puces.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Paragraphe
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;p></codeph> crée un paragraphe. Le champ de texte doit être défini sur multiligne pour utiliser cette balise. La balise <codeph>&lt;p></codeph> prend en charge les attributs suivants :
	 <ul>
	 
	 <li>
	 align : Détermine l’alignement du texte au sein du paragraphe ; les valeurs valides sont <codeph>left</codeph>, <codeph>right</codeph>, <codeph>justify</codeph> et <codeph>center</codeph>. 
	 </li>
	 
	 <li>
	 class : Spécifie la classe de style CSS définie par un objet flash.text.StyleSheet. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Span
	 </entry>
	 
	 <entry>
	 
	 La balise <codeph>&lt;span></codeph> peut uniquement être utilisée avec les styles de texte CSS. Elle prend en charge l’attribut suivant :
	 
	 <ul>
	 
	 <li>
	 class : spécifie la classe de style CSS définie par un objet flash.text.StyleSheet. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Text format
	 </entry>
	 
	 <entry>
	  <p>La balise <codeph>&lt;textformat></codeph> permet d’utiliser un sous-ensemble de propriétés de formatage des paragraphes de la classe TextFormat dans les champs texte, dont l’interlignage, le retrait, les marges et les taquets de tabulation. Vous pouvez associer des balises <codeph>&lt;textformat></codeph> aux balises HTML intégrées. </p>
	 
	  <p>La balise <codeph>&lt;textformat></codeph> dispose des attributs suivants : </p>
	 <ul>
	 
	 <li>
	 <codeph>blockindent</codeph> : Spécifie l’indentation d’un bloc, en points. Correspond à <codeph>TextFormat.blockIndent</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>indent</codeph> : Spécifie l’indentation, de la marge gauche au premier caractère du paragraphe. Correspond à <codeph>TextFormat.indent</codeph>. Les nombres positifs et négatifs sont acceptables. 
	 </li>
	 
	 <li>
	 <codeph>leading</codeph> : Spécifie l’espace séparant les lignes (espace vertical). Correspond à <codeph>TextFormat.leading</codeph>. Les nombres positifs et négatifs sont acceptables. 
	 </li>
	 
	 <li>
	 <codeph>leftmargin</codeph> : Spécifie la marge gauche du paragraphe, en points. Correspond à <codeph>TextFormat.leftMargin</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>rightmargin</codeph> : Spécifie la marge gauche du paragraphe, en points. Correspond à <codeph>TextFormat.rightMargin</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>tabstops</codeph> : Spécifie des taquets de tabulation personnalisés, sous forme d’un tableau d’entiers non négatifs. Correspond à <codeph>TextFormat.tabStops</codeph>. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Balise Underline
	 </entry>
	 
	 <entry>
	 La balise <codeph>&lt;u></codeph> souligne le texte placé entre les balises.
	 </entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Flash Player et AIR prennent en charge les entités HTML suivantes :</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 Entité
	 </entry><entry>
	 Description
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 
	 &amp;amp;lt;	
	 
	 </entry>
	 
	 <entry>
	 
	 &lt; (Inférieur à)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;gt;	
	 
	 </entry>
	 
	 <entry>
	 
	 > (Supérieur à)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;amp;	
	 
	 </entry>
	 
	 <entry>
	 
	 &amp; (esperluette)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 &amp;amp;quot;	
	 
	 </entry>
	 
	 <entry>
	 
	 " (guillemets doubles)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;apos;	
	 
	 </entry>
	 
	 <entry>
	 
	 ’ (apostrophe, guillemet simple)
	 
	 </entry>
	 
	 </row></tbody></tgroup></adobetable>
	  
	  <p>Flash Player et AIR prennent également en charge les codes de caractères explicites, tels que &amp;#38; (esperluette ASCII) et &amp;#x20AC; (symbole € Unicode). </p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> L’exemple suivant crée un objet TextField appelé <codeph>tf1</codeph> et affecte une chaîne au format HTML à sa propriété <codeph>text</codeph>. Lorsque la propriété <codeph>htmlText</codeph> est suivie, une chaîne au format HTML est renvoyée avec des balises supplémentaires (telles que &lt;P> et &lt;FONT>) qui sont ajoutées de façon automatique par Flash Player. Lorsque la valeur de la propriété <codeph>text</codeph> est suivie, la chaîne non formatée et sans balises HTML s’affiche.
 
 <p>Par comparaison, les mêmes opérations sont exécutées sur un autre objet TextField appelé <codeph>tf2</codeph> et un objet StyleSheet est alors affecté à la propriété <codeph>styleSheet</codeph> de <codeph>tf2</codeph> avant la définition de sa propriété <codeph>htmlText</codeph>. Dans ce cas, lorsque la propriété <codeph>htmlText</codeph> est suivie, elle inclut uniquement le texte HTML qui a été affecté à l’origine à la propriété <codeph>htmlText</codeph>, ce qui indique qu’aucune balise supplémentaire n’a été ajoutée par Flash Player.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/text"><linktext>flash.text.TextField.text</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link><link href="flash.events.xml#TextEvent"><linktext>flash.events.TextEvent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:length:get"><apiName>length</apiName><shortdesc>
	 Nombre de caractères d’un champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.length, length
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Nombre de caractères d’un champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Nombre de caractères d’un champ de texte. Un caractère tel qu’une marque de tabulation (<codeph>\t</codeph>) compte comme un seul caractère.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxChars:get"><apiName>maxChars</apiName><shortdesc>
	 Le nombre maximum de caractères que le champ de texte peut contenir, tels que saisis par un utilisateur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxChars, maxChars
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
	 
	 </apiDefaultValue><apiTipTexts><apiTipText>Nombre maximal de caractères que le champ de texte peut contenir.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Le nombre maximum de caractères que le champ de texte peut contenir, tels que saisis par un utilisateur. Un script peut insérer plus de texte que <codeph>maxChars</codeph> ne le permet ; la propriété <codeph>maxChars</codeph> n’indique que la quantité de texte qu’un utilisateur peut entrer. Si la valeur de la propriété est égale à <codeph>0</codeph>, l’utilisateur peut entrer autant de texte que nécessaire.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxScrollH:get"><apiName>maxScrollH</apiName><shortdesc>
	 Valeur maximale de scrollH.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollH, maxScrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Valeur maximale de scrollH.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur maximale de <codeph>scrollH</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:maxScrollV:get"><apiName>maxScrollV</apiName><shortdesc>
	 Valeur maximale de scrollV.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollV, maxScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Valeur maximale de <codeph>scrollV</codeph>.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur maximale de <codeph>scrollV</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:mouseWheelEnabled:get"><apiName>mouseWheelEnabled</apiName><shortdesc>
	 Valeur booléenne qui indique si Flash Player fait automatiquement défiler les champs texte multiligne lorsque l’utilisateur clique sur le champ de texte et actionne la molette de sa souris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.mouseWheelEnabled, mouseWheelEnabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Indique si Flash Player fait automatiquement défiler les champs texte multiligne.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur booléenne qui indique si Flash Player fait automatiquement défiler les champs texte multiligne lorsque l’utilisateur clique sur le champ de texte et actionne la molette de sa souris. Par défaut, cette valeur est <codeph>true</codeph>. Cette propriété est utile si vous souhaitez empêcher le défilement des champs texte en actionnant la molette de la souris, ou implémenter votre propre défilement de champs texte.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:multiline:get"><apiName>multiline</apiName><shortdesc>
	 Indique si le champ est un champ de texte multiligne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.multiline, multiline
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Indique si le champ de texte est un champ de texte multiligne.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Indique si le champ est un champ de texte multiligne. Si la valeur est <codeph>true</codeph>, le champ de texte est multiligne ; si la valeur est <codeph>false</codeph>, le champ de texte est un champ de texte sur une seule ligne. Dans un champ de type <codeph>TextFieldType.INPUT</codeph>, la valeur <codeph>multiline</codeph> détermine si la touche <codeph>Entrée</codeph> créé une nouvelle ligne (valeur <codeph>false</codeph> et la touche <codeph>Entrée</codeph> est ignorée). Si vous collez du texte dans un objet <codeph>TextField</codeph> avec une valeur <codeph>multiline</codeph> <codeph>false</codeph>, les nouvelles lignes sont éliminées du texte.

	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/numLines"><linktext>numLines</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:numLines:get"><apiName>numLines</apiName><shortdesc>
	 Définit le nombre de lignes de texte d’un champ multiligne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.numLines, numLines
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Définit le nombre de lignes de texte d’un champ multiligne.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Définit le nombre de lignes de texte d’un champ multiligne. Si la propriété <codeph>wordWrap</codeph> est définie sur <codeph>true</codeph>, le nombre de lignes augmente lorsque le texte contient des sauts de ligne.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/multiline"><linktext>multiline</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:restrict:get"><apiName>restrict</apiName><shortdesc>
	 Indique le jeu de caractères qu’un utilisateur peut rentrer dans le champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.restrict, restrict
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>null
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Jeu de caractères qu’un utilisateur peut rentrer dans un champ de texte.
	 

	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Indique le jeu de caractères qu’un utilisateur peut rentrer dans le champ de texte. Si la valeur de la propriété <codeph>restrict</codeph> est <codeph>null</codeph>, vous pouvez entrer n’importe quel caractère. Si la valeur de la propriété <codeph>restrict</codeph> est une chaîne vide, aucun caractère ne peut être entré. Si la valeur de la propriété <codeph>restrict</codeph> est une chaîne de caractères, vous ne pouvez entrer que les caractères dans la chaîne du champ de texte. La chaîne est lue de gauche à droite. Vous pouvez spécifier une plage à l’aide du caractère (-). Seule l’interaction de l’utilisateur est limitée ; un script peut mettre n’importe quel texte dans le champ de texte. <ph outputclass="flashonly">Cette propriété ne se synchronise pas avec les options de polices intégrées de l’inspecteur des propriétés.</ph>
	 
	 <p>Si la chaîne commence par un caret (^), tous les caractères sont initialement acceptés et les caractères suivants de la chaîne sont exclus du jeu de caractères acceptés. Si la chaîne ne commence pas par un caret (^), aucun caractère n’est initialement accepté et les caractères suivants de la chaîne sont inclus dans le jeu de caractères acceptés.</p>
	 
	 <p>L’exemple suivant autorise uniquement les caractères en majuscules, les espaces et les nombres dans le champ de texte :</p>
	 <pre>
	 my_txt.restrict = "A-Z 0-9";
	 </pre>
	 <p>L’exemple suivant exclut uniquement les caractères en minuscules :</p>
	 <pre>
	 my_txt.restrict = "^a-z";
	 </pre>
	 <p>Insérez une barre oblique pour saisir un ^ ou un -. Les séquences acceptables sont \-, \^ ou \\. Si la barre oblique doit être un caractère réel dans la chaîne, vous devez également la faire précéder d’une autre barre oblique dans le code ActionScript. Par exemple, le code suivant inclut uniquement le tiret (-) et le signe circonflexe (^) :</p>
	 <pre>
	 my_txt.restrict = "\\-\\^";
	 </pre>
	 <p>Le caractère ^ peut être utilisé n’importe où dans la chaîne pour faire alterner l’inclusion et l’exclusion des caractères. Le code suivant inclut uniquement des lettres en majuscules, mais exclut la lettre Q en majuscules :</p>
	 <pre>
	 my_txt.restrict = "A-Z^Q";
	 </pre>
	 <p>Vous pouvez utiliser la séquence d’échappement <codeph>\u</codeph> pour créer des chaînes <codeph>restrict</codeph>. Le code suivant inclut uniquement les caractères ASCII allant de 32 à 126 (tilde).</p>
	 <pre>
     my_txt.restrict = "\u0020-\u007E";
	 </pre>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:scrollH:get"><apiName>scrollH</apiName><shortdesc>
	 Position de défilement horizontal actuelle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollH, scrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Position de défilement horizontal actuelle.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Position de défilement horizontal actuelle. Si la propriété <codeph>scrollH</codeph> est 0, le texte ne défile pas horizontalement. Cette valeur de propriété est un entier qui représente la position horizontale en pixels.
	 
	 
	 <p>Les unités du défilement horizontal sont les pixels, alors que les unités du défilement vertical sont les lignes. Le défilement horizontal est mesuré en pixels étant donné que la plupart des polices que vous utilisez sont généralement espacées de façon proportionnelle, c’est-à-dire que les caractères peuvent avoir différentes largeurs. Flash Player procède au défilement vertical par ligne dans la mesure où les utilisateurs préfèrent généralement consulter une ligne entière de texte. Même s’il existe plusieurs polices sur une ligne, la hauteur de la ligne s’adapte à la plus grande police utilisée.</p>
	 
	 <p><b>Remarque : </b> La propriété <codeph>scrollH</codeph> est basée sur zéro, contrairement à la propriété de défilement vertical <codeph>scrollV</codeph> qui est basée sur 1.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/maxScrollH"><linktext>flash.text.TextField.maxScrollH</linktext></link><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:scrollV:get"><apiName>scrollV</apiName><shortdesc>
	 La position verticale du texte dans un champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollV, scroll
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>La position verticale du texte dans un champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 La position verticale du texte dans un champ de texte. La propriété <codeph>scrollV</codeph> est utile pour diriger les utilisateurs vers un paragraphe spécifique dans un long passage ou pour créer des champs texte avec défilement.
	 
	 <p>Les unités du défilement vertical sont des lignes, alors que les unités du défilement horizontal sont des pixels. Si la première ligne qui s’affiche correspond à la première ligne du champ de texte, scrollV est défini sur 1 (non pas sur 0). Le défilement horizontal est mesuré en pixels étant donné que la plupart des polices que vous utilisez sont généralement espacées de façon proportionnelle et les caractères peuvent donc avoir différentes largeurs. Flash procède au défilement vertical par ligne dans la mesure où les utilisateurs préfèrent généralement consulter une ligne entière de texte. Même s’il existe plusieurs polices sur une ligne, la hauteur de la ligne s’adapte à la plus grande police utilisée.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link><link href="flash.text.xml#TextField/maxScrollV"><linktext>flash.text.TextField.maxScrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectable:get"><apiName>selectable</apiName><shortdesc>
	 Une valeur booléenne qui indique si le champ de texte peut être sélectionné.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.selectable, selectable
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
     
         </apiDefaultValue><apiTipTexts><apiTipText>Indique si le champ de texte peut être sélectionné.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Une valeur booléenne qui indique si le champ de texte peut être sélectionné. La valeur <codeph>true</codeph> indique que le texte est sélectionnable. La propriété <codeph>selectable</codeph> détermine si un champ de texte peut être sélectionné et non pas s’il peut être modifié. Un champ de texte dynamique peut être sélectionné, même s’il ne peut pas être modifié. Lorsqu’un champ de texte n’est pas sélectionnable, vous ne pouvez pas sélectionner son texte.
	 
	 <p>Si <codeph>selectable</codeph> est défini sur <codeph>false</codeph>, le texte du champ de texte ne répond pas aux commandes de sélection de la souris ou du clavier, et le texte ne peut pas être copié à l’aide de la commande Copier. Si <codeph>selectable</codeph> est défini sur <codeph>true</codeph>, le texte du champ de texte peut être sélectionné avec la souris ou le clavier, et le texte peut être copié à l’aide de la commande Copier. Vous pouvez sélectionner le texte de cette manière même si le champ de texte est un champ de texte dynamique et non un champ de texte de saisie. </p>
	 
     </apiDesc><example conref="examples\TextField_selectable.as"> L’exemple suivant crée deux champs de texte dynamiques : un champ de texte avec la propriété <codeph>selectable</codeph> définie sur <codeph>true</codeph> et l’autre avec la propriété <codeph>selectable</codeph> définie sur <codeph>false</codeph>. Lorsque vous utilisez cet exemple, essayez de sélectionner le texte de ces champs avec la souris ou le clavier.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class selectableExample extends Sprite
    {
        public function selectableExample()
        {
    var tf1:TextField = createCustomTextField(10, 10);
    tf1.text="This text can be selected";
    tf1.selectable=true;

    var tf2:TextField = createCustomTextField(10, 30);
    tf2.text="This text cannot be selected";
    tf2.selectable=false;
        }

        private function createCustomTextField(x:Number, y:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.autoSize=TextFieldAutoSize.LEFT;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionBeginIndex:get"><apiName>selectionBeginIndex</apiName><shortdesc>
	 Valeur d’index basée sur zéro du premier caractère de la sélection actuelle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Valeur d’index basée sur zéro du premier caractère de la sélection. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur d’index basée sur zéro du premier caractère de la sélection actuelle. Par exemple, le premier caractère est 0, le deuxième est 1, etc. Si aucun texte n’est sélectionné, cette propriété reprend la valeur de <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> Dans cet exemple, une occurrence TextField est créée et remplie avec du texte. Un écouteur d’événement est affecté de façon à ce que l’utilisateur clique sur TextField, la méthode <codeph>printCursorPosition</codeph> est appelée. Dans ce cas, les valeurs des propriétés <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont renvoyées.
 
 <p>Exécutez cet exemple, puis essayez de cliquer dans TextField pour sélectionner le texte. Cliquez ensuite dans le champ sans sélectionner de texte. Lorsque vous cliquez sur le texte sans faire de sélection, la propriété <codeph>caretIndex</codeph> indique l’emplacement du point d’insertion et les propriétés <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont égales à la valeur de la propriété <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionEndIndex:get"><apiName>selectionEndIndex</apiName><shortdesc>
	 Valeur d’index basée sur zéro du dernier caractère de la sélection actuelle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Valeur d’index basée sur zéro du dernier caractère de la sélection.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur d’index basée sur zéro du dernier caractère de la sélection actuelle. Par exemple, le premier caractère est 0, le deuxième est 1, etc. Si aucun texte n’est sélectionné, cette propriété reprend la valeur de <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> Dans cet exemple, une occurrence TextField est créée et remplie avec du texte. Un écouteur d’événement est affecté de façon à ce que l’utilisateur clique sur TextField, la méthode <codeph>printCursorPosition</codeph> est appelée. Dans ce cas, les valeurs des propriétés <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont renvoyées.
 
 <p>Exécutez cet exemple, puis essayez de cliquer dans TextField pour sélectionner le texte. Cliquez ensuite dans le champ sans sélectionner de texte. Lorsque vous cliquez sur le texte sans faire de sélection, la propriété <codeph>caretIndex</codeph> indique l’emplacement du point d’insertion et les propriétés <codeph>selectionBeginIndex</codeph> et <codeph>selectionEndIndex</codeph> sont égales à la valeur de la propriété <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:sharpness:get"><apiName>sharpness</apiName><shortdesc>
	 Netteté des bords du glyphe dans ce champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates three text fields with
	 <code>sharpness</code> set to <code>400</code>, <code>0</code>, and <code>-400</code>.
	 It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 400, 100);
	 my_text1.text = "This text has sharpness set to 400."
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "pixel";
	 my_text1.sharpness = 400;
	 my_text1.setTextFormat(my_format);
         
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 40, 400, 100);
	 my_text2.text = "This text has sharpness set to 0."
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.sharpness = 0;
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 10, 70, 400, 100);
	 my_text3.text = "This text has sharpness set to -400."
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "pixel";
	 my_text3.sharpness = -400;
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
         </apiDefaultValue><apiTipTexts><apiTipText>La netteté des bords des glyphes.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Netteté des bords du glyphe dans ce champ de texte. Cette propriété s’applique uniquement si la propriété <codeph>flash.text.AntiAliasType</codeph> du champ de texte est définie sur <codeph>flash.text.AntiAliasType.ADVANCED</codeph>. La plage de <codeph>sharpness</codeph> est comprise entre -400 et 400. Si vous tentez de définir <codeph>sharpness</codeph> sur une valeur en dehors de cette plage, Flash définit cette propriété sur la valeur valide la plus proche, soit -400 ou 400.
	 
	 </apiDesc><example conref="examples\TextField_sharpness.as"> L’exemple suivant montre l’effet de la modification de la propriété <codeph>sharpness</codeph> d’un objet TextField. Vous devez intégrer la police et définir la propriété <codeph>antiAliasType</codeph> sur <codeph>ADVANCED</codeph>.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class sharpnessExample extends Sprite
    {
        public function sharpnessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-400);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,400);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldSharpness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.sharpness=fldSharpness;
            result..setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:styleSheet:get"><apiName>styleSheet</apiName><shortdesc>
	 Associe une feuille de style au champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet, style sheet, stylesheet
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:StyleSheet</apiValueClassifier><apiTipTexts><apiTipText>Associe une feuille de style au champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Associe une feuille de style au champ de texte. Pour plus d’informations sur la création de feuilles de style, consultez la section sur la classe StyleSheet et le manuel <i>Programmation d’ActionScript 3.0</i>.
	 
	 <p>Vous pouvez modifier la feuille de style associée à un champ de texte à la demande. Si vous modifiez la feuille de style en cours d’utilisation, le champ de texte est redessiné avec la nouvelle feuille de style. Vous pouvez définir la feuille de style sur <codeph>null</codeph> ou <codeph>undefined</codeph> pour ne pas en utiliser. Si la feuille de style en cours d’utilisation est supprimée, le champ de texte est redessiné sans feuille de style. </p>
     <p><b>Remarque :</b> Lorsque la feuille de style est supprimée, le contenu de <codeph>TextField.text</codeph> et <codeph> TextField.htmlText</codeph> se modifie pour intégrer le formatage qui a été appliqué auparavant par la feuille de style. Pour préserver le contenu d’origine de <codeph>TextField.htmlText</codeph> sans le formatage, enregistrez la valeur dans une variable avant de supprimer la feuille de style.</p>
	 
     </apiDesc><example conref="examples\TextField_styleSheet.as"> L’exemple suivant définit un simple objet StyleSheet et l’affecte à un champ de texte avec contenu HTML. Définissez la propriété <codeph>stylesheet</codeph> avant de définir le contenu.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.StyleSheet;

    public class TextStylesheetExample extends Sprite {
        var myLabel:TextField = new TextField();
        var labelText:String = "Hello world.";
        var newStyle:StyleSheet = new StyleSheet();

        public function TextStylesheetExample()
       {
            var styleObj:Object = new Object();
            styleObj.fontWeight = "bold";
            styleObj.color = "#660066";
            newStyle.setStyle(".defStyle", styleObj);

            myLabel.styleSheet=newStyle;
            myLabel.htmlText=labelText;
            addChild(myLabel);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:text:get"><apiName>text</apiName><shortdesc>
	 Une chaîne qui correspond au texte du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.text, text
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Une chaîne qui correspond au texte du champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Une chaîne qui correspond au texte du champ de texte. Les lignes sont séparées par le caractère de retour chariot (<codeph>’\r’</codeph>, ASCII 13). Cette propriété contient du texte non formaté dans le champ de texte, sans balises HTML.
	 
	 <p>Pour obtenir le texte du formulaire HTML, utilisez la propriété <codeph>htmlText</codeph>.</p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> L’exemple suivant crée un objet TextField appelé <codeph>tf1</codeph> et affecte une chaîne au format HTML à sa propriété <codeph>text</codeph>. Lorsque la propriété <codeph>htmlText</codeph> est suivie, une chaîne au format HTML est renvoyée avec des balises supplémentaires (telles que &lt;P> et &lt;FONT>) qui sont ajoutées de façon automatique par Flash Player. Lorsque la valeur de la propriété <codeph>text</codeph> est suivie, la chaîne non formatée et sans balises HTML s’affiche.
 
 <p>Par comparaison, les mêmes opérations sont exécutées sur un autre objet TextField appelé <codeph>tf2</codeph> et un objet StyleSheet est alors affecté à la propriété <codeph>styleSheet</codeph> de <codeph>tf2</codeph> avant la définition de sa propriété <codeph>htmlText</codeph>. Dans ce cas, lorsque la propriété <codeph>htmlText</codeph> est suivie, elle inclut uniquement le texte HTML qui a été affecté à l’origine à la propriété <codeph>htmlText</codeph>, ce qui indique qu’aucune balise supplémentaire n’a été ajoutée par Flash Player.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textColor:get"><apiName>textColor</apiName><shortdesc>
	 Couleur du texte dans un champ de texte, au format hexadécimal.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textColor, textColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiDefaultValue>0 (0x000000)
	 </apiDefaultValue><apiTipTexts><apiTipText>Couleur du texte dans un champ de texte, au format hexadécimal.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Couleur du texte dans un champ de texte, au format hexadécimal. Le système de couleur hexadécimal utilise les six chiffres pour représenter les valeurs de couleur. Chaque chiffre a 16 valeurs ou caractères possibles. La plage de caractères va de 0 à 9, puis de A à F. Par exemple, le noir correspond à <codeph>0x000000</codeph> et le blanc à <codeph>0xFFFFFF</codeph>.
	 
     </apiDesc><example conref="examples\TextField_textColor.as"> Le code ActionScript suivant crée un objet TextField et affecte à la propriété <codeph>textColor</codeph> la couleur rouge (<codeph>0xFF0000</codeph>).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textColor extends Sprite {
        public function TextField_textColor() {
            var tf:TextField = createCustomTextField(10, 10, 100, 300);
            tf.text = "This will be red text";
            tf.textColor = 0xFF0000;            
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:textHeight:get"><apiName>textHeight</apiName><shortdesc>
	 Hauteur du texte en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textHeight, textHeight
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Hauteur du texte en pixels.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Hauteur du texte en pixels.
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> L’exemple suivant crée un objet TextField et lui affecte du texte. Les instructions <codeph>trace</codeph> affichent les valeurs des propriétés <codeph>textWidth</codeph> et <codeph>textHeight</codeph>. Par comparaison, les propriétés <codeph>width</codeph> et <codeph>height</codeph> s’affichent également. (Tenez compte du fait que les valeurs qui s’affichent pour <codeph>textHeight</codeph> et <codeph>textWidth</codeph> dépendent de la police utilisée sur votre ordinateur).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textWidth"><linktext>flash.text.TextField.textWidth</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textWidth:get"><apiName>textWidth</apiName><shortdesc>
	 Largeur du texte en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textWidth, textWidth
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Largeur du texte en pixels.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Largeur du texte en pixels.
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> L’exemple suivant crée un objet TextField et lui affecte du texte. Les instructions <codeph>trace</codeph> affichent les valeurs des propriétés <codeph>textWidth</codeph> et <codeph>textHeight</codeph>. Par comparaison, les propriétés <codeph>width</codeph> et <codeph>height</codeph> s’affichent également. (Tenez compte du fait que les valeurs qui s’affichent pour <codeph>textHeight</codeph> et <codeph>textWidth</codeph> dépendent de la police utilisée sur votre ordinateur).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textHeight"><linktext>flash.text.TextField.textHeight</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:thickness:get"><apiName>thickness</apiName><shortdesc>
	 Epaisseur des bords du glyphe dans ce champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates two text fields and applies a <code>thickness</code> of -200 to one
	 and 200 to the other.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "thickness = 200";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.thickness = 200;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "thickness = -200."
	 my_text2.antiAliasType = "advanced";
	 my_text2.thickness = -200;
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
     
         </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
	 </apiDefaultValue><apiTipTexts><apiTipText>L’épaisseur des bords des glyphes.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Epaisseur des bords du glyphe dans ce champ de texte. Cette propriété s’applique uniquement lorsque <codeph>flash.text.AntiAliasType</codeph> est défini sur <codeph>flash.text.AntiAliasType.ADVANCED</codeph>.
	 
	 <p>La plage de <codeph>thickness</codeph> est comprise entre -200 et 200. Si vous tentez de définir <codeph>thickness</codeph> sur une valeur en dehors de cette plage, cette propriété est définie sur la valeur valide la plus proche, soit -200 ou 200.</p>
	 
     </apiDesc><example conref="examples\TextField_thickness.as"> L’exemple suivant montre l’effet de la modification de la propriété <codeph>thickness</codeph> d’un objet TextField. Vous devez intégrer la police et définir la propriété <codeph>antiAliasType</codeph> sur <codeph>ADVANCED</codeph>.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class thicknessExample extends Sprite
    {
        public function thicknessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-200);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,200);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldThickness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.thickness=fldThickness;
            result.setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:type:get"><apiName>type</apiName><shortdesc>
	 Type du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.type, type
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Le paramètre <codeph>type</codeph> spécifié n’appartient pas à flash.text.TextFieldType.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>dynamic
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Type du champ de texte.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Type du champ de texte. L’une des constantes TextFieldType suivantes : <codeph>TextFieldType.DYNAMIC</codeph>, qui spécifie un champ de texte dynamique, que l’utilisateur ne peut pas modifier, ou <codeph>TextFieldType.INPUT</codeph>, qui spécifie un champ de texte de saisie, que l’utilisateur peut modifier.
	 
     </apiDesc><example conref="examples\TextField_type.as"> L’exemple suivant crée deux champs texte : <codeph>tfDynamic</codeph> et <codeph>tfInput</codeph>. Le texte est entré dans les deux champs texte. Cependant, <codeph>tfDynamic</codeph> voit sa propriété <codeph>type</codeph> définie sur <codeph>TextFieldType.DYNAMIC</codeph>, tandis que <codeph>tfInput</codeph> voit sa propriété <codeph>type</codeph> définie sur <codeph>TextFieldType.INPUT</codeph>, ce qui signifie que l’utilisateur peut modifier le texte de <codeph>tfInput</codeph> mais ne peut que consulter le texte de <codeph>tfDynamic</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_type extends Sprite {
        public function TextField_type() {
            var tfDynamic:TextField = createCustomTextField(10, 10, 100, 20);
            tfDynamic.type = TextFieldType.DYNAMIC;
            tfDynamic.text = "hello";

            var tfInput:TextField = createCustomTextField(10, 45, 100, 20);
            tfInput.type = TextFieldType.INPUT;
            tfInput.text = "world";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextFieldType"><linktext>flash.text.TextFieldType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:useRichTextClipboard:set"><apiName>useRichTextClipboard</apiName><shortdesc>
	 Spécifie si le formatage du texte peut être copié et collé en même temps que le corps du texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le formatage du texte peut être copié et collé en même temps que le corps du texte. Lorsque défini sur <codeph>true</codeph>, Flash Player copie et colle le formatage (tel que les paramètres d’alignement, gras et italique) lorsque vous copiez et collez entre différents champs. Les champs texte d’origine et de destination pour la procédure de copie et collage doivent disposer d’une propriété <codeph>useRichTextClipboard</codeph> définie sur <codeph>true</codeph>. La valeur par défaut est <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_useRichTextClipboard.as"> Cet exemple crée un champ de saisie de texte (<codeph>tf1</codeph>) et deux champs de texte dynamiques (<codeph>tf2</codeph> et <codeph>tf3</codeph>). Le code affecte à chaque champ de texte dynamique un objet TextFormat (police Courier Bold). La propriété <codeph>useRichTextClipboard</codeph> du champ de texte <codeph>tf2</codeph> est définie sur <codeph>false</codeph>. La propriété <codeph>useRichTextClipboard</codeph> du champ de texte <codeph>tf3</codeph> est définie sur <codeph>true</codeph>. Lorsque vous copiez le texte du champ <codeph>tf2</codeph> pour le coller dans le champ <codeph>tf1</codeph>, le texte collé ne reproduit pas la mise en forme. Lorsque vous copiez le texte du champ <codeph>tf3</codeph> (dont la propreté <codeph>useRichTextClipboard</codeph> est définie sur <codeph>true</codeph>) pour le coller dans le champ <codeph>tf1</codeph>, le texte collé reproduit la mise en forme.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;

    public class useRichTextClipboard extends Sprite
    {
        public function useRichTextClipboard()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Courier";
    format1.bold=true;

    var tf1:TextField = createCustomTextField(10, 10, 200, 20);
    tf1.type=TextFieldType.INPUT;
    tf1.useRichTextClipboard=true;

    var tf2:TextField = createCustomTextField(220, 10, 200, 20);
    tf2.text="1.Text loses format";
    tf2.setTextFormat(format1);
    tf2.useRichTextClipboard=false;

    var tf3:TextField = createCustomTextField(220, 50, 200, 20);
    tf3.text="2.Text includes format";
    tf3.setTextFormat(format1);
    tf3.useRichTextClipboard=true;
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:wordWrap:get"><apiName>wordWrap</apiName><shortdesc>
	 Valeur booléenne indiquant si le champ de texte comporte un retour à la ligne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.wordWrap, wordWrap
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Indique si le champ de texte autorise ou non le retour à la ligne.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Valeur booléenne indiquant si le champ de texte comporte un retour à la ligne. Si la valeur de <codeph>wordWrap</codeph> est <codeph>true</codeph>, le champ de texte comporte un retour à la ligne ; si la valeur est <codeph>false</codeph>, le champ de texte ne comporte pas de retour à la ligne. La valeur par défaut est <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_wordWrap.as"> L’exemple suivant révèle la différence entre la définition du paramètre <codeph>wordWrap</codeph> sur <codeph>true</codeph> et sa définition sur <codeph>false</codeph> : Deux occurrences TextField sont créées, dont le contenu est trop important pour leur largeur. La propriété <codeph>wordWrap</codeph> du premier (appelée <codeph>tfWrap</codeph>) est définie sur <codeph>true</codeph>. Elle est définie sur <codeph>false</codeph> pour le deuxième (<codeph>tfNoWrap</codeph>).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_wordWrap extends Sprite {
        public function TextField_wordWrap() {
            var tfWrap:TextField = createCustomTextField(10, 10, 100, 100);
            tfWrap.wordWrap = true;
            tfWrap.text = "(wordWrap = true):\nThis is very long text that will certainly extend beyond the width of this text field";

            var tfNoWrap:TextField = createCustomTextField(10, 150, 100, 100);
            tfNoWrap.wordWrap = false;
            tfNoWrap.text = "(wordWrap = false):\nThis is very long text that will certainly extend beyond the width of this text field";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 La classe TextFormat représente les informations de mise en forme de caractères.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Insure the above example is correct and meets example standards
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Crée le formatage de texte pour les champs texte.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextFormat représente les informations de mise en forme de caractères. Utilisez la classe TextFormat pour personnaliser la mise en forme des champs texte. Vous pouvez formater le texte des champs statiques et dynamiques. Les propriétés de la classe TextFormat s’appliquent aux polices de périphérique et intégrées. Cependant, pour les polices intégrées, le texte en gras et en italique nécessite en fait des polices spécifiques. Pour afficher du texte en gras ou en italiques avec une police intégrée, vous devez intégrer les variations en gras et en italiques de cette police.
 
 <p> Vous devez utiliser le constructeur <codeph>new TextFormat()</codeph> pour créer un objet TextFormat avant de définir les propriétés. Lorsque vous appliquez un objet TextFormat à un champ de texte avec la propriété <codeph>TextField.defaultTextFormat</codeph> ou la méthode <codeph>TextField.setTextFormat()</codeph>, seules ses propriétés définies sont appliquées. Utilisez la propriété <codeph>TextField.defaultTextFormat</codeph> pour appliquer une mise en forme AVANT d’ajouter du texte au <codeph>TextField</codeph>, et la méthode <codeph>setTextFormat()</codeph> pour ajouter une mise en forme APRES avoir ajouté du texte au <codeph>TextField</codeph>. Les propriétés TextFormat ont la valeur <codeph>null</codeph> par défaut, dans la mesure où Flash Player applique son propre format par défaut en l’absence de valeurs pour ces propriétés. Le format par défaut que Flash Player utilise pour chaque propriété (si sa valeur est <codeph>null</codeph>) prend la forme suivante :</p>
 
 <adobetable class="innertable">
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="1"><tbody><row><entry>align = « left »</entry></row><row><entry>blockIndent = 0</entry></row><row><entry>bold = false</entry></row><row><entry>bullet = false</entry></row><row><entry>color = 0x000000</entry></row><row><entry>font = « Times New Roman » (la police par défaut est Times sur le Mac Système X)</entry></row><row><entry>indent = 0</entry></row><row><entry>italic = false</entry></row><row><entry>kerning = false</entry></row><row><entry>leading = 0</entry></row><row><entry>leftMargin = 0</entry></row><row><entry>letterSpacing = 0</entry></row><row><entry>rightMargin = 0</entry></row><row><entry>size = 12</entry></row><row><entry>tabStops = [] (tableau vide)</entry></row><row><entry>target = "" (chaîne vide)</entry></row><row><entry>underline = false</entry></row><row><entry>url = "" (chaîne vide)</entry></row></tbody></tgroup></adobetable>
 
 <p>La mise en forme par défaut de chaque propriété figure également dans la description des propriétés.</p>
 
 </apiDesc><example conref="examples\TextFormatExample.as"> L’exemple suivant crée la classe TextFieldExample pour afficher un message texte à l’emplacement par défaut (x = 0, y = 0). Cette opération se déroule selon la procédure suivante :
 <ol>
  <li>Une propriété <codeph>label</codeph> de type TextField est créée.</li>
  <li>Le constructeur de classe appelle la fonction <codeph>configureLabel()</codeph>.</li>
  <li>La fonction <codeph>configureLabel()</codeph> crée tout d’abord un objet TextField et l’affecte à <codeph>label</codeph>, puis définit ses paramètres de la façon suivante :
  <ul>
      <li>Justifie le champ de texte à gauche ;</li>
      <li>Active le remplissage d’arrière-plan ;</li>
      <li>Active la bordure.</li>
  </ul>
  </li>
  <li>Ensuite, la méthode <codeph>configureLable()</codeph> crée la variable locale <codeph>format</codeph> et l’affecte à une nouvelle occurrence de TextFormat en définissant ses paramètres de la façon suivante :
  <ul>
      <li>Type de police = Verdana</li>
      <li>Couleur de la police = rouge uni</li>
      <li>Taille de la police = 10</li>
      <li>Soulignement = true</li>
  </ul>
  </li>
  <li>La propriété <codeph>defaultTextFormat</codeph> de l’étiquette est définie sur <codeph>format</codeph>, et l’occurrence <codeph>label</codeph> vient s’ajouter à la liste d’affichage, qui affiche tout d’abord un champ de texte sans texte (sous forme de petit cadre avec un fond blanc) sur la scène.</li>
  <li>Enfin (au niveau du constructeur), le texte de l’étiquette est défini sur « Hello World and welcome to the show », aux coordonnées x = 0, y = 0 en appelant <codeph>setLabel()</codeph>.</li>
 </ol>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFormatExample extends Sprite {
        private var label:TextField;

        public function TextFormatExample() {
            configureLabel();
            setLabel("Hello World and welcome to the show");
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link></related-links><apiConstructor id="flash.text:TextFormat:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 	 Crée un objet TextFormat avec les propriétés spécifiées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat
 	 
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Le nom de la police du texte sous forme de chaîne.
 	 </apiDesc></apiParam><apiParam><apiItemName>size</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Un entier qui indique la taille, en pixels.
 	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>La couleur du texte qui utilise ce format. Nombre contenant trois composants RVB 8 bits ; par exemple, 0xFF0000 correspond au rouge et 0x00FF00 au vert.
 	 </apiDesc></apiParam><apiParam><apiItemName>bold</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur booléenne qui spécifie si le texte est en gras.
 	 </apiDesc></apiParam><apiParam><apiItemName>italic</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur booléenne qui spécifie si le texte est en italiques.
 	 </apiDesc></apiParam><apiParam><apiItemName>underline</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Valeur booléenne qui spécifie si le texte est souligné.
 	 </apiDesc></apiParam><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>URL correspondant à l’hyperlien du texte de ce format de texte. Si l’<codeph>url</codeph> est une chaîne vide, le texte ne comporte pas d’hyperlien.
 	 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Fenêtre cible dans laquelle s’affiche l’hyperlien. Si la fenêtre cible est une chaîne vide, le texte s’affiche dans la fenêtre cible par défaut <codeph>_self</codeph>. Si le paramètre <codeph>url</codeph> est défini sur une chaîne vide ou sur la valeur <codeph>null</codeph>, vous pouvez obtenir ou définir cette propriété, mais la propriété n’aura aucun effet.
 	 </apiDesc></apiParam><apiParam><apiItemName>align</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>L’alignement du paragraphe, en tant que valeur TextFormatAlign.
 	 </apiDesc></apiParam><apiParam><apiItemName>leftMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Indique la marge gauche du paragraphe, en pixels.
 	 </apiDesc></apiParam><apiParam><apiItemName>rightMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Indique la marge droite du paragraphe, en pixels.
 	 </apiDesc></apiParam><apiParam><apiItemName>indent</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Entier indiquant l’indentation à appliquer de la marge gauche au premier caractère du paragraphe.
 	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Nombre qui indique le montant d’interlignage vertical entre les lignes.
 	 
   	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Crée un objet TextFormat avec les propriétés spécifiées. Vous pouvez modifier les propriétés de l’objet TextFormat pour modifier le format des champs texte.
	 
 	 <p>Tout paramètre peut être défini sur <codeph>null</codeph> pour indiquer qu’il n’est pas défini. Tous les paramètres sont facultatifs ; tous les paramètres omis sont traités comme <codeph>null</codeph>.</p>
  	 
 	 </apiDesc><example conref="examples\TextFormat_constructorExample.as"> Dans l’exemple suivant, un utilisateur peut sélectionner dans une liste diverses options de mise en forme du texte pour les appliquer au contenu d’un autre champ de texte. Si l’utilisateur clique sur le contenu du champ de texte, la mise en forme retrouve son format par défaut (original).
 
 <p>Le champ de texte <codeph>formatTextField</codeph> présente la liste de toutes les options des propriétés de la classe TextField (à l’exception de <codeph>kerning</codeph>) sur une ligne distincte. Lorsqu’un utilisateur clique sur une ligne du champ de texte <codeph>formatTextField</codeph>, la méthode <codeph>formatTextFieldClickHandler()</codeph> est déclenchée.</p> 
 
 <p>La méthode <codeph>formatTextFieldClickHandler()</codeph> appelle la méthode <codeph>TextField.getLineIndexAtPoint()</codeph> pour obtenir l’index de la ligne sur lequel l’utilisateur a cliqué, puis la méthode <codeph>TextField.getLineText()</codeph> pour obtenir le contenu de la ligne. L’instruction switch vérifie le contenu de la ligne et définit une propriété de l’objet TextFormat <codeph>newformat</codeph> en conséquence. La méthode <codeph>setTextFormat()</codeph> définit ensuite le format de texte du champ de texte <codeph>contentTextField</codeph> sur le nouveau format. En cliquant sur les différentes lignes <codeph>formatTextField</codeph>, un utilisateur peut appliquer une autre mise en forme au champ de texte <codeph>contentTextField</codeph> (le paramètre tab est un tableau qui définit un taquet de tabulation distinct pour chaque tabulation de la ligne). Si la ligne <codeph>url</codeph> ou <codeph>target</codeph> est sélectionnée, l’utilisateur doit cliquer sur le champ de texte <codeph>contentTextField</codeph> pour activer le lien et afficher le contenu de l’URL cible (page d’accueil Flex). La valeur par défaut de la propriété <codeph>target</codeph> est « _self », ce qui signifie que le contenu s’affiche dans la fenêtre active lorsque l’utilisateur sélectionne la ligne <codeph>url</codeph>. Pour utiliser la propriété <codeph>target</codeph>, une URL doit déjà être définie dans la propriété <codeph>url</codeph>.</p>
 
 <p>Si un utilisateur clique sur le champ de texte <codeph>contentTextField</codeph>, la méthode <codeph>contentTextFieldClickHandler()</codeph> est déclenchée, ce qui définit le format du champ et l’objet TextFormat <codeph>newFormat</codeph> sur le format par défaut (original) du champ de texte. Cette opération supprime toutes les modifications de mise en forme effectuées par l’utilisateur.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormatAlign;
    
    public class TextFormat_constructorExample extends Sprite {
        private var contentTextField:TextField = new TextField();
        private var formatTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextFormat_constructorExample() {
            contentTextField.x = 10;
            contentTextField.y = 10;
            contentTextField.background = true;
            contentTextField.border = true;
            contentTextField.multiline = true;
            contentTextField.wordWrap = true;
            contentTextField.selectable = false;
            contentTextField.width = 250;
            contentTextField.height = 120; 
  
            contentTextField.htmlText = "&lt;p>The TextFormat class represents character formatting "
                + "information. Use the TextFormat class to create specific text formatting "
                + "for text fields." + 
                " &lt;/p>&lt;br>" + "\tTab One" + "\tTab Two&lt;br>";
              
            formatTextField.x = 10;
            formatTextField.y = 140;
            formatTextField.background = true;
            formatTextField.border = true;
            formatTextField.autoSize = TextFieldAutoSize.LEFT;
            
            formatTextField.text = "align: right\n" + "blockIndent: 10 pixels\n" + "bold:\n" + "bullet:\n" + "color: red\n"
                                + "font: Arial\n" + "indent: 20 pixels\n" + "italic:\n" + "leading: 5 spaces\n" 
                                + "leftMargin: 20 pixels\n" + "letterSpacing: 4 pixels\n" + "rightMargin: 20 pixels\n" 
                                + "size: 16 point\n" + "target: new window\n" + "tabStops: 50 and 150 pixel\n" 
                                + "underline:\n" + "url: Adobe Flex page\n";

            formatTextField.addEventListener(MouseEvent.CLICK, formatTextFieldClickHandler);
            
            contentTextField.addEventListener(MouseEvent.CLICK, contentTextFieldClickHandler);
            
            this.addChild(contentTextField);
            this.addChild(formatTextField);
        }

        private function formatTextFieldClickHandler(e:MouseEvent):void {
                var value:String= "";
                var i:uint = 0;
                var index:int = formatTextField.getLineIndexAtPoint(e.localX, e.localY);
                var line:String = formatTextField.getLineText(index);;

                line = line.substr(0, (line.indexOf(":")));

                switch(line) {
                    case "align":
                        newFormat.align = TextFormatAlign.RIGHT;
                        break;
                    case "blockIndent":
                        newFormat.blockIndent = 10;
                        break;
                    case "bold":
                        newFormat.bold = true;
                        break;
                    case "bullet":
                        newFormat.bullet = true;
                        break;
                    case "color":
                        newFormat.color = 0xFF0000;        
                        break;
                    case "font":
                        newFormat.font = "Arial";
                        break;
                    case "indent":
                        newFormat.indent = 20;
                        break;
                    case "italic":
                        newFormat.italic = true;
                        break;
                    case "leading":
                        newFormat.leading = 5;
                        break;
                    case "leftMargin":
                        newFormat.leftMargin = 20;
                        break;
                    case "letterSpacing":
                        newFormat.letterSpacing = 4;
                        break;
                    case "rightMargin":
                        newFormat.rightMargin = 20;
                        break;
                    case "size":
                        newFormat.size = 16;
                        break;
                    case "tabStops":                
                        newFormat.tabStops = [50, 150];
                        break;
                    case "target":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        newFormat.target = "_blank";
                        break;    
                    case "underline":
                        newFormat.underline = true;
                        break;
                    case "url":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        break;
                }    

                contentTextField.setTextFormat(newFormat);
        }

        private function contentTextFieldClickHandler(e:MouseEvent):void {
            contentTextField.setTextFormat(contentTextField.defaultTextFormat);
            newFormat = contentTextField.defaultTextFormat;
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextFormat:align:get"><apiName>align</apiName><shortdesc>
	 Indique l’alignement du paragraphe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.align, align
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Le paramètre <codeph>align</codeph> spécifié n’appartient pas à flash.text.TextFormatAlign.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>TextFormatAlign.LEFT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Indique l’alignement du paragraphe. Les valeurs valides sont des constantes TextFormatAlign.
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormatAlign"><linktext>flash.text.TextFormatAlign</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:blockIndent:get"><apiName>blockIndent</apiName><shortdesc>
	 Indique l’indentation du bloc en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.blockIndent, blockIndent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Indique l’indentation du bloc en pixels. L’indentation d’un bloc est appliquée à l’ensemble d’un bloc de texte ; c’est-à-dire à toutes les lignes du texte. Par contraste, l’indentation normale (<codeph>TextFormat.indent</codeph>) affecte seulement la première ligne de chaque paragraphe. Si cette propriété est <codeph>null</codeph>, l’objet TextFormat ne spécifie pas l’indentation d’un bloc (l’indentation de bloc est de 0).
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
 	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bold:get"><apiName>bold</apiName><shortdesc>
	 Spécifie si le texte est en gras.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bold, bold
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie si le texte est en gras. La valeur par défaut est <codeph>null</codeph>, ce qui signifie qu’aucune police en gras n’est utilisée. Si la valeur est <codeph>true</codeph>, le texte est en gras.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bullet:get"><apiName>bullet</apiName><shortdesc>
	 Indique que le texte fait partie d’une liste à puces.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bullet, bullet
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que le texte fait partie d’une liste à puces. Dans une liste à puces, chaque paragraphe du texte apparaît en retrait. A gauche de la première ligne de chaque paragraphe, le symbole d’une puce s’affiche. La valeur par défaut est <codeph>null</codeph>, ce qui signifie qu’aucune liste à puces n’est utilisée.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:color:get"><apiName>color</apiName><shortdesc>
	 Indique la couleur du texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.color, color
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Indique la couleur du texte. Nombre contenant trois composants RVB 8 bits ; par exemple, 0xFF0000 correspond au rouge et 0x00FF00 au vert. La valeur par défaut est <codeph>null</codeph>, ce qui signifie que Flash Player utilise la couleur noire (0x000000).
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:font:get"><apiName>font</apiName><shortdesc>
	 Nom de la police pour du texte dans ce format de texte, sous forme de chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.font, font
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Nom de la police pour du texte dans ce format de texte, sous forme de chaîne. La valeur par défaut est <codeph>null</codeph>, ce qui signifie que Flash Player utilise la police Times New Roman pour le texte.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:indent:get"><apiName>indent</apiName><shortdesc>
	 Indique l’indentation à appliquer de la marge gauche au premier caractère du paragraphe.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.indent, indent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Indique l’indentation à appliquer de la marge gauche au premier caractère du paragraphe. La valeur par défaut est <codeph>null</codeph>, ce qui indique qu’aucune indentation n’est utilisée.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/blockIndent"><linktext>flash.text.TextFormat.blockIndent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:italic:get"><apiName>italic</apiName><shortdesc>
	 Indique si le texte concerné par ce format doit être en italiques.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.italic, italic
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si le texte concerné par ce format doit être en italiques. La valeur par défaut est <codeph>null</codeph>, ce qui signifie qu’aucun caractère ne sera en italiques.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:kerning:get"><apiName>kerning</apiName><shortdesc>
	 Valeur booléenne indiquant si le crénage est activé (true) ou désactivé (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur booléenne indiquant si le crénage est activé (<codeph>true</codeph>) ou désactivé (<codeph>false</codeph>). Le crénage modifie le nombre de pixels séparant chaque paire de caractères pour améliorer la lisibilité et ne doit être employé que si nécessaire, dans les titres en grande police, par exemple. Le crénage est supporté uniquement pour les polices incorporées. 
	 
	 <p>Certaines polices, telles que Verdana, et les polices à espacement fixe, telles que Courier New, ne prennent pas en charge le crénage.</p>
	 
	 <p>La valeur par défaut est <codeph>null</codeph>, ce qui signifie que le crénage est désactivé.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leading:get"><apiName>leading</apiName><shortdesc>
	 Entier représentant le montant d’espace vertical (appelé interlignage) entre les lignes.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leading, leading
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Entier représentant le montant d’espace vertical (appelé <i>leading</i>) entre les lignes. La valeur par défaut est <codeph>null</codeph>, ce qui indique que le montant d’interlignage est défini sur 0.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leftMargin:get"><apiName>leftMargin</apiName><shortdesc>
	 Marge gauche du paragraphe, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leftMargin, leftMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Marge gauche du paragraphe, en pixels. La valeur par défaut est <codeph>null</codeph>, ce qui indique que la marge gauche est de 0 pixels.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:letterSpacing:get"><apiName>letterSpacing</apiName><shortdesc>
     Nombre représentant la quantité d’espace répartie uniformément entre tous les caractères.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Nombre représentant la quantité d’espace répartie uniformément entre tous les caractères. Cette valeur spécifie le nombre de pixels à ajouter après chaque caractère. La valeur par défaut est <codeph>null</codeph>, ce qui signifie que les lettres sont séparées par 0 pixels. Vous pouvez utiliser des valeurs décimales telles que <codeph>1.75</codeph>.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:rightMargin:get"><apiName>rightMargin</apiName><shortdesc>
	 Marge droite du paragraphe, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.rightMargin, rightMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Marge droite du paragraphe, en pixels. La valeur par défaut est <codeph>null</codeph>, ce qui indique que la marge droite est de 0 pixels.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:size:get"><apiName>size</apiName><shortdesc>
	 La taille en pixels de ce format de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.size, size
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 La taille en pixels de ce format de texte. La valeur par défaut est <codeph>null</codeph>, ce qui signifie qu’une taille de 12 pixels est utilisée.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:tabStops:get"><apiName>tabStops</apiName><shortdesc>
	 Spécifie des taquets de tabulation personnalisés, sous forme d’un tableau d’entiers non négatifs.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.tabStops, tabStops
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Spécifie des taquets de tabulation personnalisés, sous forme d’un tableau d’entiers non négatifs. Chaque taquet de tabulation est spécifié en pixels. Si des taquets de tabulation personnalisés ne sont pas spécifiés (<codeph>null</codeph>), le taquet de tabulation par défaut est 4 (largeur moyenne de caractère).
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:target:get"><apiName>target</apiName><shortdesc>
	 Indique la fenêtre cible dans laquelle s’affiche l’hyperlien.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.target, target
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique la fenêtre cible dans laquelle s’affiche l’hyperlien. Si la fenêtre cible est une chaîne vide, le texte s’affiche dans la fenêtre cible par défaut <codeph>_self</codeph>. Vous pouvez choisir un nom personnalisé ou l’un des quatre noms suivants : <codeph>_self</codeph> spécifie l’image active dans la fenêtre actuelle, <codeph>_blank</codeph> spécifie une nouvelle fenêtre, <codeph>_parent</codeph> spécifie le parent de l’image active et <codeph>_top</codeph> spécifie l’image de plus haut niveau dans la fenêtre active. Si la propriété <codeph>TextFormat.url</codeph> est une chaîne vide ou <codeph>null</codeph>, vous pouvez obtenir ou définir cette propriété, mais la propriété n’aura aucun effet.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/url"><linktext>flash.text.TextFormat.url</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:underline:get"><apiName>underline</apiName><shortdesc>
	 Indique si le texte qui utilise ce format texte est souligné (true) ou non (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.underline, underline
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Indique si le texte qui utilise ce format texte est souligné (<codeph>true</codeph>) ou non (<codeph>false</codeph>). Ce soulignement est similaire à celui créé par la balise <codeph>&lt;U></codeph> mais ce dernier n’est pas un vrai soulignement, étant donné qu’il ne saute pas correctement les lettres à jambage. La valeur par défaut est <codeph>null</codeph>, ce qui indique qu’aucune partie du texte n’est soulignée.
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété . 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:url:get"><apiName>url</apiName><shortdesc>
	 Indique l’URL cible du texte concerné par ce format.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.url, url
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique l’URL cible du texte concerné par ce format. Si la propriété <codeph>url</codeph> est une chaîne vide, le texte ne comporte pas d’hyperlien. La valeur par défaut est <codeph>null</codeph>, ce qui indique que le texte ne comporte pas d’hyperlien.
	 <p><b>Remarque :</b> le texte et le format qui lui est associé doit être défini avec la propriété <codeph>htmlText</codeph> pour que l’hyperlien fonctionne.</p>
	 
	 </apiDesc><example>Consultez l’exemple <xref href="TextFormat.html#TextFormat()">TextFormat() constructor</xref> pour une illustration de l’utilisation de cette propriété. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextDisplayMode"><apiName>TextDisplayMode</apiName><shortdesc>
 La classe TextDisplayMode regroupe les valeurs qui contrôlent l’anti-aliasing des sous-pixels du système d’anti-aliasing avancé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextDisplayMode regroupe les valeurs qui contrôlent l’anti-aliasing des sous-pixels du système d’anti-aliasing avancé. 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/displayMode"><linktext>flash.text.TextRenderer.displayMode</linktext></link></related-links><apiValue id="flash.text:TextDisplayMode:CRT"><apiName>CRT</apiName><shortdesc>
	 Force Flash Player à afficher l’anti-aliasing en niveaux de gris.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>crt</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Force Flash Player à afficher l’anti-aliasing en niveaux de gris. Si ce paramètre prévient la coloration du texte, certains utilisateurs pourront néanmoins le trouver flou.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Permet à Flash Player de choisir entre les modes LCD et CRT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Permet à Flash Player de choisir entre les modes LCD et CRT.	
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:LCD"><apiName>LCD</apiName><shortdesc> 
	 Force Flash Player à utiliser le paramètre LCD d’anti-aliasing de sous-pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lcd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	 Force Flash Player à utiliser le paramètre LCD d’anti-aliasing de sous-pixels. Selon la police et le matériel, ce paramètre peut entraîner une résolution de texte plus élevées ou des couleurs plus nombreuses.
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:AntiAliasType"><apiName>AntiAliasType</apiName><shortdesc>
La classe AntiAliasType fournit les valeurs d’anti-aliasing de la classe flash.text.TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe AntiAliasType fournit les valeurs d’anti-aliasing de la classe flash.text.TextField.
</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:AntiAliasType:ADVANCED"><apiName>ADVANCED</apiName><shortdesc>
	Permet d’appliquer un anti-aliasing avancé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>advanced</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Permet d’appliquer un anti-aliasing avancé. L’anti-alias avancé offre un rendu de très haute qualité pour les polices de petite taille. Il est préférable de l’utiliser avec les applications comprenant une grande quantité de texte de petite taille. L’anti-aliasing avancé n’est pas recommandé pour les très grandes polices, soit plus de 48 points. Cette constante s’applique à la propriété <codeph>antiAliasType</codeph> de la classe TextField. Utilisez la syntaxe <codeph>AntiAliasType.ADVANCED</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:AntiAliasType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	Définit l’anti-aliasing sur l’anti-aliasing qui est appliqué par Flash Player 7 et ses versions plus anciennes.</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit l’anti-aliasing sur l’anti-aliasing qui est appliqué par Flash Player 7 et ses versions plus anciennes. Ce paramètres est recommandé pour les applications qui ne comportent pas beaucoup de texte. Cette constante s’applique à la propriété <codeph>antiAliasType</codeph> de la classe TextField. Utilisez la syntaxe <codeph>AntiAliasType.NORMAL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:FontType"><apiName>FontType</apiName><shortdesc>
	 La classe FontType contient les constantes énumérées « embedded » et « device » pour la propriété fontType de la classe Font.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 La classe FontType contient les constantes énumérées <codeph>"embedded"</codeph> et <codeph>"device"</codeph> pour la propriété <codeph>fontType</codeph> de la classe Font. 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#Font/fontType"><linktext>flash.text.Font.fontType</linktext></link></related-links><apiValue id="flash.text:FontType:DEVICE"><apiName>DEVICE</apiName><shortdesc>
		 Indique qu’il s’agit d’une police de périphérique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>device</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique qu’il s’agit d’une police de périphérique. Le fichier SWF s’affiche à l’aide des polices installées sur le système.
		 
		 <p>L’utilisation de polices de périphérique réduit la taille des fichiers d’animation, car les données relatives à la police ne figurent pas dans le fichier. Les polices de périphérique sont souvent préférables pour afficher le texte à un petit format, dans la mesure où le texte anti-aliasé peut être légèrement flou pour les petites tailles. Les polices de périphérique sont également préférables pour les grands blocs de texte, tels que le texte à défilement.</p>
		 
		 <p>Les champs texte qui utilisent des polices de périphérique ne peuvent pas s’afficher de la même façon sur différents systèmes et différentes plates-formes, car ils utilisent les polices installées sur le système. Pour la même raison, les polices de périphérique ne sont pas anti-aliasées et peuvent sembler pixélisées pour les grandes tailles.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED"><apiName>EMBEDDED</apiName><shortdesc>
		 Indique qu’il s’agit d’une police intégrée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embedded</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique qu’il s’agit d’une police intégrée. Les polices vectorielles sont intégrées dans le fichier SWF publié.
		 
		 <p>Les champs texte qui recourent à des polices intégrées sont toujours affichés dans la police choisie, que cette police soit installée ou non sur le système de lecture. D’autre part, les champs de texte qui utilisent des polices intégrées sont toujours anti-aliasés (lissés). Vous pouvez sélectionner le montant d’anti-aliasing à appliquer à l’aide de la propriété <codeph>TextField.antiAliasType</codeph>.</p>
		 
		 <p>L’un des principaux désavantages des polices intégrées est qu’elles augmentent la taille du fichier SWF.</p>
		 
		 <p>Les polices de type <codeph>EMBEDDED</codeph> ne peuvent être utilisées que par l’objet TextField. Si les classes flash.text.engine doivent utiliser une telle police, elles reviennent aux polices de périphériques.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED_CFF"><apiName>EMBEDDED_CFF</apiName><shortdesc>
		 Indique qu’il s’agit d’une police intégrée CFF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embeddedCFF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Indique qu’il s’agit d’une police intégrée CFF. Les polices vectorielles et un sous-ensemble des tables OpenType sont intégrés dans le fichier SWF publié.
		 
		 <p>Le texte qui utilise des polices CFF intégrées est toujours affiché dans la police choisie, que cette police soit ou non installée sur le système de lecture. D’autre part, le texte qui utilise des polices CFF intégrées est toujours anti-aliasé (lissé) par Flash Player. Vous pouvez choisir le mode de rendu et les conseils pour une police CFF intégrée à l’aide des propriétés <codeph>flash.text.engine.FontDescription.renderingMode</codeph> et <codeph>flash.text.engine.FontDescription.cffHinting</codeph>.</p>
		 
		 <p>L’un des principaux désavantages des polices CFF intégrées est qu’elles augmentent la taille du fichier SWF. Toutefois, les polices CFF intégrées sont généralement de 20 % à 30 % plus petites que les polices intégrées ordinaires.</p>
		 
		 <p>Les polices de type <codeph>EMBEDDED_CFF</codeph> ne peuvent être utilisées que par les classes flash.text.engine. Un objet TextField obligé d’utiliser une telle police ne pourra pas effectuer le rendu.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormatAlign"><apiName>TextFormatAlign</apiName><shortdesc>
 La classe TextFormatAlign fournit des valeurs pour l’alignement du texte de la classe TextFormat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextFormatAlign fournit des valeurs pour l’alignement du texte de la classe TextFormat.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links><apiValue id="flash.text:TextFormatAlign:CENTER"><apiName>CENTER</apiName><shortdesc>
	 Constante ; centre le texte dans le champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Constante ; centre le texte dans le champ de texte. Utilisez la syntaxe <codeph>TextFormatAlign.CENTER</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:JUSTIFY"><apiName>JUSTIFY</apiName><shortdesc>
	 Constante ; justifie le texte au sein du champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>justify</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Constante ; justifie le texte au sein du champ de texte. Utilisez la syntaxe <codeph>TextFormatAlign.JUSTIFY</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
	 Constante ; aligne le texte à gauche dans le champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Constante ; aligne le texte à gauche dans le champ de texte. Utilisez la syntaxe <codeph>TextFormatAlign.LEFT</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
	 Constante ; aligne le texte à droite dans le champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Constante ; aligne le texte à droite dans le champ de texte. Utilisez la syntaxe <codeph>TextFormatAlign.RIGHT</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:Font"><apiName>Font</apiName><shortdesc>
 La classe Font permet de gérer des polices intégrées dans les fichiers SWF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Font permet de gérer des polices intégrées dans les fichiers SWF. Les polices intégrées sont représentées en tant que sous-classes de la classe Font. La class Font est actuellement utile pour rechercher des informations sur les polices intégrées. Vous ne pouvez pas modifier une police à l’aide de cette classe. Vous ne pouvez pas utiliser la classe Font pour charger les polices externes ou pour créer une occurrence de l’objet Font lui-même. Utilisez la classe Font en tant que classe de base abstraite.
 
 </apiDesc></apiClassifierDetail><apiOperation id="flash.text:Font:enumerateFonts"><apiName>enumerateFonts</apiName><shortdesc> 
    Détermine s’il faut fournir la liste des polices intégrées actuellement disponibles.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Liste des polices disponibles sous forme de tableau d’objets Font.
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>enumerateDeviceFonts</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Indique s’il est préférable de limiter la liste aux polices intégrées actuellement disponibles. Si défini sur <codeph>true</codeph>, la liste de l’ensemble des polices, aussi bien de périphérique qu’intégrées, est renvoyée. Si défini sur <codeph>false</codeph>, seules les polices intégrées sont renvoyées.
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
    Détermine s’il faut fournir la liste des polices intégrées actuellement disponibles.
        </apiDesc><example conref="examples\Font.enumerateFonts.1.as"> Cet exemple appelle en premier lieu la méthode statique <codeph>Font.enumerateFonts()</codeph> pour obtenir la liste des polices de périphérique et intégrées. Ensuite, il trie le tableau d’objets Font qui en résulte en fonction de la propriété <codeph>fontName</codeph>.
 
 <p>Ensuite, l’exemple indique comment appeler la méthode <codeph>Font.enumerateFonts()</codeph> avec le paramètre <codeph>enumerateDeviceFonts</codeph> défini sur false. Le tableau qui en résulte inclut uniquement les objets Font intégrés (si vous exécutez ce code à partir d’une application qui ne contient pas de polices intégrées, le tableau <codeph>embeddedFonts</codeph> est vide).</p>
<codeblock>
 
import flash.text.Font;

var allFonts:Array = Font.enumerateFonts(true);
allFonts.sortOn("fontName", Array.CASEINSENSITIVE);

var embeddedFonts:Array = Font.enumerateFonts(false);
embeddedFonts.sortOn("fontName", Array.CASEINSENSITIVE);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:hasGlyphs"><apiName>hasGlyphs</apiName><shortdesc> 
        Détermine si la chaîne fournie peut s’afficher à l’aide de la police en vigueur.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur <codeph>true</codeph> si la chaîne spécifiée peut s’afficher complètement à l’aide de cette police.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>La chaîne à tester par rapport à la police actuelle.
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
        Détermine si la chaîne fournie peut s’afficher à l’aide de la police en vigueur.
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:registerFont"><apiName>registerFont</apiName><shortdesc> 
	Enregistre une classe de police dans la liste globale de polices.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>Classe à ajouter à la liste globale de polices.
	</apiDesc></apiParam></apiOperationDef><apiDesc> 
	Enregistre une classe de police dans la liste globale de polices.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.text:Font:fontName:get"><apiName>fontName</apiName><shortdesc> 
	Le nom de la police intégrée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Le nom de la police intégrée. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:Font:fontStyle:get"><apiName>fontStyle</apiName><shortdesc> 
	Style de la police.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Style de la police. Cette valeur peut correspondre à l’une des valeurs définies dans la classe FontStyle.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link></related-links></apiValue><apiValue id="flash.text:Font:fontType:get"><apiName>fontType</apiName><shortdesc> 
	Type de police.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Type de police. Cette valeur peut correspondre à l’une des constantes définies dans la classe FontType.
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontType"><linktext>flash.text.FontType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextRenderer"><apiName>TextRenderer</apiName><shortdesc>
 La classe TextRenderer permet d’exploiter la fonction avancée d’anti-aliasing des polices incorporées.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>-- Class sample changed due to bug 193833
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Contrôle l’anti-aliasing des polices intégrées.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextRenderer permet d’exploiter la fonction avancée d’anti-aliasing des polices incorporées. L’anti-aliasing avancé permet d’obtenir un rendu très précis des polices de petite taille. Utilisez l’anti-aliasing avancé avec les applications comportant beaucoup de texte de petite taille. Adobe ne recommande pas l’utilisation de l’anti-aliasing avancé pour les polices de très grande taille (supérieures à 48 points). L’anti-aliasing avancé est disponible uniquement à partir de Flash Player 8.
 
 <p>Pour définir l’anti-aliasing avancé sur un champ de texte, définissez la propriété <codeph>antiAliasType</codeph> de l’occurrence de TextField.</p>
 
 <p>L’anti-aliasing avancé offre une modulation continue du trait (CSM) qui s’applique à la fois à l’épaisseur du trait et à la netteté des bords. En tant que fonctionnalité avancée, vous pouvez utiliser la méthode <codeph>setAdvancedAntiAliasingTable()</codeph> pour définir des paramètres pour des tailles de caractères et de polices spécifiques.</p>
 
 </apiDesc><example conref="examples\TextRendererExample2.as"> L’exemple suivant crée la classe TextRendererExample pour fournir des exemples visuels de paramètres d’anti-aliasing avancé avec des tailles de police petites et grandes. Avant de tester cet exemple, vous devez intégrer une police. Si vous utilisez Flex, intégrez une police de la manière suivante :
 <ol>
    <li>Placez la police Georgia, nommée georgia.ttf, dans le même répertoire que ce fichier AS.</li>
    <li>Ajoutez les lignes suivantes immédiatement en dessous de la définition de classe :</li>
    <li><codeph>[Embed(source="georgia.ttf", fontFamily="Georgia")]</codeph></li>
    <li><codeph>private var embeddedFont:String;</codeph></li>
 </ol>
 Si vous utilisez Flash, intégrez une police de la manière suivante :
 <ol>
     <li>Placez un champ de texte sur la scène et sélectionnez-le.</li>
     <li>Dans l’inspecteur des propriétés, définissez la police de ce champ de texte sur Georgia</li>
     <li>Dans l’inspecteur des propriétés, appuyez sur « Intégrer... » et sélectionnez « Tout »</li>
 </ol>
 <p> <b>Remarques :</b>
  <ul>
     <li>vous devrez compiler le fichier SWF en réglant « Sécurité de lecture locale » sur « Accès aux fichiers locaux uniquement ».</li>
    </ul>
 </p>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.text.*;
    
    public class TextRendererExample2 extends Sprite {

        private var gutter:int = 10;

        public function TextRendererExample2() {
            createTextField(8,AntiAliasType.NORMAL);
            createTextField(8,AntiAliasType.ADVANCED);
            createTextField(24,AntiAliasType.NORMAL);
            createTextField(24,AntiAliasType.ADVANCED);
        }
            
        private function createTextField(fontSize:Number,antiAliasType:String):TextField {
            var tf:TextField = new TextField();
            tf.embedFonts = true;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.antiAliasType = antiAliasType;
            tf.defaultTextFormat = getTextFormat(fontSize);
            tf.selectable = false;
            tf.mouseEnabled = true;
            tf.text = "The quick brown fox jumped over the lazy dog.";
            if(numChildren > 0) {
                var sibling:DisplayObject = getChildAt(numChildren - 1);
                tf.y = sibling.y + sibling.height + gutter;
            }
            addChild(tf);
            return tf;
        }
        
        private function getTextFormat(fontSize:Number):TextFormat {
            var format:TextFormat = new TextFormat();
            format.size = fontSize;
            format.font = "Georgia";
            return format;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links><apiOperation id="flash.text:TextRenderer:setAdvancedAntiAliasingTable"><apiName>setAdvancedAntiAliasingTable</apiName><shortdesc>
	 Définit un tableau de recherche personnalisé de la modulation continue du trait (CSM) pour une police.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two anti-alias entries and two text fields to 
	 illustrate them. For this example to work, the SWF file must have a shared font embedded with a linkage identifier of <code>
	 "myArial"</code>. 
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library.</li>
	 <li>Click the Library options menu in the upper-right corner of the Library.</li>
	 <li>Select New Font from the pop-up menu.</li>
	 <li>Name the font <b>myArial</b>.</li>
	 <li>Select Arial from the font pop-up menu.</li>
	 <li>Click OK.</li>
	 <li>Right-click the newly created font, and select Linkage.</li>
	 <li>Select the Export for ActionScript check box.</li>
	 <li>Click OK to accept the default identifier, myArial.</li>
	 </ol>
	 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 
	 var antiAliasEntry_1 = {fontSize:24, insideCutoff:1.61, outsideCutoff:-3.43};
	 var antiAliasEntry_2 = {fontSize:48, insideCutoff:0.8, outsideCutoff:-0.8};
	 var arialTable:Array = new Array(antiAliasEntry_1, antiAliasEntry_2);
	 
	 var lbl_1:TextField = createLabel(0, 0, 300, 100, 24);
	 var lbl_2:TextField = createLabel(0, 100, 300, 100, 48);
	 
	 TextRenderer.setAdvancedAntiAliasingTable("Arial", "none", "dark", arialTable);
	 
	 function createLabel(x:Number, y:Number, width:Number, height:Number, fontSize:Number):TextField {
	 var depth:Number = this.getNextHighestDepth();
	 
	 var tmpTxt = this.createTextField("txt_" + depth, depth, x, y, width, height);
	 tmpTxt.antiAliasType = "advanced";
	 tmpTxt.gridFitType = "pixel";
	 tmpTxt.border = true;
	 tmpTxt.text = "Hello World";
	 tmpTxt.embedFonts = true;
	 tmpTxt.setTextFormat(getTextFormat(fontSize));
	 return tmpTxt;
	 }
	 
	 function getTextFormat(fontSize:Number):TextFormat {
	 	var tf:TextFormat = new TextFormat();
	 	tf.align = "center";
	 	tf.size = fontSize;
	 	tf.font = "myArial";
	 	return tf;
	 }
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom de la police pour laquelle vous appliquez des paramètres.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Le style de police indiqué en utilisant l’une des valeurs de la classe flash.text.FontStyle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Cette valeur détermine si le trait doit être sombre ou clair. Utilisez l’une des valeurs de la classe flash.text.TextColorType. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>advancedAntiAliasingTable</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Un tableau d’un ou de plusieurs objets CSMSettings pour la police spécifiée. Chaque objet contient les propriétés suivantes :
	 
	 <ul>
	 
	   <li><codeph>fontSize.</codeph></li>
	   <li><codeph>insideCutOff</codeph></li>
	   <li><codeph>outsideCutOff</codeph></li>
	 
	 </ul>
	 
	 <p>Le tableau <codeph>advancedAntiAliasingTable</codeph> peut comporter plusieurs entrées qui spécifient les paramètres CSM pour différentes tailles de police.</p>
	 
	 <p>La <codeph>fontSize</codeph> est la taille, en pixels, pour laquelle les paramètres s’appliquent.</p>
	 
	 <p>L’anti-aliasing avancé a recours aux champs de distance échantillonnés de façon adaptative (ADF) pour représenter les contours qui déterminent un glyphe. Flash Player applique une valeur butoir externe (<codeph>outsideCutOff</codeph>), en-deçà de laquelle les densités sont définies sur zéro, et une valeur butoir interne (<codeph>insideCutOff</codeph>), au-delà de laquelle les densités sont limitées à une valeur donnée (telle que 255). Entre ces deux valeurs, la fonction de mappage est une courbe linéaire allant de zéro, pour la valeur butoir externe, jusqu’à la valeur de densité maximum définie pour la valeur butoir interne.</p>
	 
	 <p>Le réglage des valeurs butoir externe et interne affecte l’épaisseur du trait et la netteté des bords. L’espacement séparant ces deux paramètres est comparable au double du rayon du filtre des méthodes classiques d’anti-aliasing ; un espacement étroit fournit un bord plus net, tandis qu’un espacement plus large donne un bord plus doux, plus filtré. Lorsque l’espacement est nul, l’image de densité résultante est un bitmap à deux niveaux. Lorsque l’espacement est très large, le bord de l’image de densité résultante est assez semblable à celui d’une aquarelle.</p>
	 
	 <p>De manière générale, les utilisateurs préfèrent les bords nets à fort contraste pour les petites tailles et des bords plus doux pour le texte animé et les polices de grande taille. </p>
	 
	 <p>La valeur butoir externe correspond généralement à une valeur négative, tandis que la valeur interne a une valeur positive. Leur point intermédiaire est proche de zéro. Le réglage de ces paramètres pour décaler le point intermédiaire vers l’infini négatif augmente l’épaisseur du trait, tandis que son décalage vers l’infini positif la réduit. Assurez-vous que la valeur butoir externe soit toujours inférieure ou égale à la valeur interne.</p>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Définit un tableau de recherche personnalisé de la modulation continue du trait (CSM) pour une police. Flash Player tente de détecter le CSM le plus adapté à la police. Si vous n’êtes pas satisfait par le CSM fourni par Flash Player, vous pouvez personnaliser votre propre CSM à l’aide de la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link><link href="flash.text.xml#TextColorType"><linktext>flash.text.TextColorType</linktext></link><link href="flash.text.xml#CSMSettings"><linktext>CSMSettings</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextRenderer:displayMode:get"><apiName>displayMode</apiName><shortdesc> 
	 Contrôle la restitution de texte sur lequel l’anti-aliasing avancé est défini.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>"default"
	 </apiDefaultValue></apiValueDef><apiDesc> 
	 Contrôle la restitution de texte sur lequel l’anti-aliasing avancé est défini. La qualité visuelle du texte est très subjective, et même si Flash Player tente d’appliquer les meilleurs paramètres aux différentes conditions d’affichage, certains concepteurs opteront pour un aspect différent de rendu de leur texte. Ainsi, l’utilisation de <codeph>displayMode</codeph> permet au concepteur de remplacer le choix des sous-pixels effectué par Flash Player et d’obtenir une cohérence visuelle, indépendamment du matériel de l’utilisateur. Utilisez les valeurs de la classe TextDisplayMode pour définir cette propriété.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextDisplayMode"><linktext>Classe TextDisplayMode</linktext></link></related-links></apiValue><apiValue id="flash.text:TextRenderer:maxLevel:get"><apiName>maxLevel</apiName><shortdesc>
	 Le niveau de qualité des champs de distance échantillonnés de façon adaptative (ADF) à appliquer pour l’anti-aliasing avancé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example specifies the <code>maxLevel</code> value for the entire
	 SWF file, and then displays a text field with the value set. For the 
	 text in this example to display correctly, there must be a font symbol available with
	 a linkage identifier of <code>"CustomFont"</code>. 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 TextRenderer.maxLevel = 3;
	 
	 var txtFormat:TextFormat = new TextFormat();
	 txtFormat.font = "CustomFont";
	 txtFormat.size = 64;
	 
	 var label:TextField = this.createTextField("label", this.getNextHighestDepth(), 10, 10, 500, 100);
	 label.setNewTextFormat(txtFormat);
	 label.text = "Hello World";
	 label.embedFonts = true;
	 trace("TextRenderer.maxLevel: " + TextRenderer.maxLevel);
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>4
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Le niveau de qualité des champs de distance échantillonnés de façon adaptative (ADF) à appliquer pour l’anti-aliasing avancé. Les seules valeurs acceptables sont 3, 4 et 7. 
	 
	 <p>L’anti-aliasing avancé a recours aux ADF pour représenter les contours qui déterminent un glyphe. Plus la qualité est élevée, plus les structures ADF consomment de la mémoire cache. Une valeur de <codeph>3</codeph> occupe le moins d’espace mémoire possible, mais débouche sur la qualité moindre. Les polices de plus grande taille nécessitent davantage d’espace en mémoire cache ; pour les polices dont la taille est de 64 pixels, le niveau de qualité passe de <codeph>3</codeph> à <codeph>4</codeph> ou de <codeph>4</codeph> à <codeph>7</codeph>, à moins que ce niveau ne soit déjà défini sur <codeph>7</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
 La classe TextLineMetrics contient des informations sur la position du texte et les unités de mesure d’une ligne de texte dans un champ de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Contient des informations sur la position du texte et les unités de mesure d’une ligne de texte dans un champ de texte.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe TextLineMetrics contient des informations sur la position du texte et les unités de mesure d’une <i>ligne de texte</i> dans un champ de texte. Toutes les mesures sont en pixels. Les objets de cette classe sont renvoyés par la méthode <codeph>flash.text.TextField.getLineMetrics()</codeph>.
 <p>Pour les mesures liées au champ de texte qui contient la ligne de texte (par exemple, la mesure de la « hauteur du champ de texte » dans le diagramme), consultez la section flash.text.TextField. </p>
 
 <p>Le diagramme suivant indique les points et les unités de mesure d’un champ de texte et la ligne de texte contenu par le champ de texte :</p>
 <p>
 <adobeimage alt="Image illustrant des mesures de texte" href="../../images/text-metrics.jpg"/></p>
 
 </apiDesc><example conref="examples\TextLineMetricsExample.as"> L’exemple suivant crée les classes TextLineMetricsExample et LineMetricsReader pour imprimer un message dans Flash Player à l’aide d’un objet XML. Cette opération se déroule selon la procédure suivante :
 <ol>
  <li>Crée une propriété appelée <codeph>label</codeph> de type TextField.</li>
  <li>Le constructeur appelle <codeph>configureAssets()</codeph>, qui effectue les opérations suivantes :
  <ul>
      <li>Aligne la scène sur la partie supérieure gauche et sans redimensionnement.</li>
      <li>Crée un objet TextField appelé <codeph>label</codeph>.</li>
      <li>Active la couleur d’arrière-plan de <codeph>label</codeph> et définit la couleur sur blanc.</li>
      <li>Permet au texte de <codeph>label</codeph> de couvrir plusieurs lignes avec la fonctionnalité de retour automatique à la ligne.</li>
      <li>Affecte le résultat d’un appel à <codeph>getLabelText()</codeph> à la propriété <codeph>text</codeph> de <codeph>label</codeph>. La méthode <codeph>getLabelText()</codeph> crée une variable de type XML et l’affecte à un nœud XML appelé <codeph>body</codeph>, qui est ensuite rempli avec une phrase longue.</li>
      <li>Ajoute <codeph>label</codeph> à la liste d’affichage à l’aide de <codeph>addChild()</codeph>.</li>
  </ul>
  </li>
  <li>Une méthode qui écoute les événements <codeph>resize</codeph> qui s’exécutent sur la scène est ensuite ajoutée en appelant <codeph>resizeHandler()</codeph>. Dès que la taille de la fenêtre Flash Player change, un événement <codeph>RESIZE</codeph> est distribué et produit les effets suivants : 
  <ul>
      <li><codeph>draw()</codeph> est appelée pour s’assurer que <codeph>label</codeph> s’affiche au centre de la scène et est entouré par un tampon de 10 pixels.</li>
      <li><codeph>setTimeout()</codeph> exécute ensuite <codeph>showMetrics()</codeph> après un bref délai. Le délai est ajouté car les unités de mesure de la ligne ne sont mises à jour que lorsque l’événement <codeph>RESIZE</codeph> s’est terminé et que l’opération d’actualisation de la scène est terminée.</li>
      <li><codeph>showMetrics()</codeph> affecte une variable TextLineMetrics appelée <codeph>metrics</codeph> au résultat d’un appel à <codeph>getLineMetrics()</codeph> et cette variable est ensuite transmise à une nouvelle occurrence de LineMetricsReader appelée <codeph>reader</codeph>. Les deux variables sont ensuite utilisées au sein d’appels à <codeph>trace()</codeph> pour imprimer la première et unique ligne de <codeph>label</codeph> et les informations fournies par l’occurrence LineMetricsReader par l’intermédiaire de sa méthode <codeph>toString()</codeph>.</li>
  </ul>
  </li>
  <li>Le constructeur entraîne une distribution unique de l’événement <codeph>resize</codeph> pour forcer <codeph>label</codeph> à se dessiner correctement lorsque le fichier SWF est chargé en premier.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.utils.setTimeout;

    public class TextLineMetricsExample extends Sprite {
        private var gutter:int = 10;
        private var label:TextField;

        public function TextLineMetricsExample() {
            configureAssets();
            configureListeners();
            resizeHandler(new Event(Event.RESIZE));
        }

        private function showMetrics():void {
            var metrics:TextLineMetrics = label.getLineMetrics(0);
            var reader:LineMetricsReader = new LineMetricsReader(metrics);
            trace("lineText: " + label.getLineText(0));
            trace("metrics: " + reader);
        }

        private function configureAssets():void {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            label = new TextField();
            label.background = true;
            label.backgroundColor = 0xFFFFFF;
            label.multiline = true;
            label.wordWrap = true;
            label.text = getLabelText();
            addChild(label);
        }

        private function configureListeners():void {
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function resizeHandler(event:Event):void {
            draw();
            setTimeout(showMetrics, 100);
        }

        private function draw():void {
            label.x = gutter;
            label.y = gutter;
            label.width = stage.stageWidth - (gutter * 2);
            label.height = stage.stageHeight - (gutter * 2);
        }

        private function getLabelText():String {
            var text:XML = &lt;body>The Flex product line enables developers to build rich Internet applications that blend the responsiveness of desktop software, the cross-platform reach of the web, and the expressiveness of the Flash Platform.&lt;/body>
            return text.toString();
        }
    }
}

import flash.text.TextLineMetrics;

class LineMetricsReader {
    private var metrics:TextLineMetrics;

    public function LineMetricsReader(metrics:TextLineMetrics) {
        this.metrics = metrics;
    }

    public function toString():String {
        return "[TextLineMetrics ascent:" + metrics.ascent
            + ", descent:" + metrics.descent
            + ", leading:" + metrics.leading
            + ", width:" + metrics.width
            + ", height:" + metrics.height
            + ", x:" + metrics.x
            + "]";
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:TextLineMetrics:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
	 Crée un objet TextLineMetrics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Position gauche du premier caractère, en pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Largeur du texte des lignes sélectionnées (pas nécessairement la totalité du texte), en pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Hauteur du texte des lignes sélectionnées (pas nécessairement la totalité du texte), en pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Longueur depuis la hauteur de la ligne de base jusqu’à celle du haut de la ligne, en pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Longueur depuis la profondeur de la ligne de base jusqu’à celle du bas de la ligne, en pixels.
	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Mesure de la distance verticale entre les lignes de texte.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Contient des informations sur la position du texte et les unités de mesure d’une ligne de texte dans un champ de texte.
  	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Crée un objet TextLineMetrics. L’objet TextLineMetrics contient des informations sur les unités de mesure d’une ligne de texte dans un champ de texte. Les objets de cette classe sont renvoyés par la méthode <codeph>flash.text.TextField.getLineMetrics()</codeph>.
	 <p>Consultez le diagramme de la présentation de cette classe pour mettre les propriétés en contexte.</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link><link href="flash.text.xml#TextField/getLineMetrics()"><linktext>flash.text.TextField.getLineMetrics()</linktext></link></related-links></apiConstructor><apiValue id="flash.text:TextLineMetrics:ascent"><apiName>ascent</apiName><shortdesc>
	 La valeur ascendante du texte est la longueur depuis la hauteur de la ligne de base jusqu’à celle du haut de la ligne, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>including accents? is it really the line or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 La valeur ascendante du texte est la longueur depuis la hauteur de la ligne de base jusqu’à celle du haut de la ligne, en pixels. Consultez la mesure « Ascendante » du diagramme de présentation pour cette classe.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:descent"><apiName>descent</apiName><shortdesc>
	 La valeur descendante du texte est la longueur de la ligne de base à la partie la plus basse de la ligne, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>is it really the line? or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 La valeur descendante du texte est la longueur de la ligne de base à la partie la plus basse de la ligne, en pixels. Consultez la mesure « Descendante » du diagramme de présentation pour cette classe.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:height"><apiName>height</apiName><shortdesc>
	 Valeur de hauteur du texte des lignes sélectionnées (pas nécessairement la totalité du texte), en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur de hauteur du texte des lignes sélectionnées (pas nécessairement la totalité du texte), en pixels. La hauteur de la ligne de texte n’inclut pas la hauteur de la marge de reliure. Consultez la mesure « Hauteur de ligne » du diagramme de présentation pour cette classe.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:leading"><apiName>leading</apiName><shortdesc>
	 La valeur d’interlignage est la mesure de la distance verticale entre les lignes de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 La valeur d’interlignage est la mesure de la distance verticale entre les lignes de texte. Consultez la mesure « Interlignage » du diagramme de présentation pour cette classe.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:width"><apiName>width</apiName><shortdesc>
	 La valeur width correspond à la largeur du texte des lignes sélectionnées (pas nécessairement la totalité du texte), en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 La valeur width correspond à la largeur du texte des lignes sélectionnées (pas nécessairement la totalité du texte), en pixels. La largeur de la ligne de texte est différente de la largeur du champ de texte. La largeur de la ligne de texte se calcule par rapport à la largeur du champ de texte, moins une marge de reliure de 4 pixels (2 pixels de chaque côté). Consultez la mesure « Largeur de la ligne de texte » du diagramme de présentation pour cette classe.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:x"><apiName>x</apiName><shortdesc>
	 Valeur x de la position gauche du premier caractère, en pixels.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Valeur x de la position gauche du premier caractère, en pixels. Cette valeur inclut les largeurs de la marge, de l’indentation (le cas échéant) et de la marge de reliure. Consultez la section « Position x de la ligne de texte » du diagramme de présentation pour cette classe.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Présentation de la classe TextLineMetrics</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
 La classe StyleSheet permet de créer un objet feuille de style contenant des règles de formatage de texte pour la taille et la couleur de la police ainsi que d’autres styles de formatage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet class, built-in class, style sheet, stylesheet
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Permet de créer un objet StyleSheet.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe StyleSheet permet de créer un objet feuille de style contenant des règles de formatage de texte pour la taille et la couleur de la police ainsi que d’autres styles de formatage. Vous pouvez ensuite appliquer des styles définis par une feuille de style à un objet TextField qui contient du texte au format HTML ou XML. Le texte contenu dans l’objet TextField est ensuite automatiquement mis en forme en fonction des styles de balises définis par l’objet StyleSheet. Vous pouvez utiliser des styles de texte pour définir de nouvelles balises de formatage, redéfinir des balises HTML intégrées ou créer des classes de style qui peuvent être appliquées à certaines balises HTML.
 
 <p>Pour appliquer des styles à un objet TextField, attribuez l’objet feuille de style à une propriété <codeph>styleSheet</codeph>.</p>
 <p><b>Remarque :</b> tout champ de texte associé à une feuille de style n’est pas modifiable. En d’autres termes, un champ de texte dont la propriété <codeph>type</codeph> est définie sur <codeph>TextFieldType.INPUT</codeph> applique la feuille de style au texte par défaut du champ de texte, qui à partir de ce moment ne peut plus être modifié par l’utilisateur. Préférez la classe TextFormat pour affecter des styles aux champs de saisie.</p> 
 
 <p>Flash Player prend en charge un sous-ensemble de propriétés dans le cadre de la spécification CSS1 d’origine (<xref href="http://www.w3.org/TR/REC-CSS1" scope="external">www.w3.org/TR/REC-CSS1</xref>). Le tableau suivant présente les propriétés et les valeurs supportées de la feuille de style en cascade (CSS) et les noms de propriétés ActionScript correspondants (chaque nom de propriété ActionScript est tiré du nom de propriété CSS correspondant. Si le nom contient un trait d’union, le trait d’union est omis et le caractère suivant est une majuscule).</p>
 
 <adobetable class="innertable">
 
   
 
   
 
   
 
   
 
   
 
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
 <tgroup cols="3"><thead><row><entry>Propriété CSS</entry><entry>Propriété ActionScript</entry><entry>Utilisation et valeurs prises en charge</entry></row></thead><tbody><row>
     <entry><codeph>color</codeph></entry>
     <entry><codeph>color</codeph></entry>
     <entry>Seules les valeurs hexadécimales de couleur sont supportées. Les couleurs nommées (comme <codeph>blue</codeph>) ne sont pas prises en charge. Les couleurs sont écrites au format suivant : <codeph>#FF0000</codeph>.</entry>
   </row><row>
     <entry><codeph>display</codeph></entry>
     <entry><codeph>display</codeph></entry>
     <entry>Les valeurs supportées sont <codeph>inline</codeph>, <codeph>block</codeph> et <codeph>none</codeph>.</entry>
   </row><row>
     <entry><codeph>font-family</codeph></entry>
     <entry><codeph>fontFamily</codeph></entry>
     <entry>Liste des polices à utiliser, séparées par des virgules, classées par ordre de choix décroissant. Tous les noms de familles de polices peuvent être utilisés. Si vous spécifiez un nom de police générique, il est converti dans la police de périphérique appropriée. Les conversions de police suivantes sont disponibles : <codeph>mono</codeph> est converti en <codeph>_typewriter</codeph>, <codeph>sans-serif</codeph> en <codeph>_sans</codeph> et <codeph>serif</codeph> en <codeph>_serif</codeph>.</entry>
   </row><row>
     <entry><codeph>font-size</codeph></entry>
     <entry><codeph>fontSize.</codeph> </entry>
     <entry>Seule la partie numérique de la valeur est utilisée. Les unités (px, pt) ne sont pas analysées. Les pixels et les points sont équivalents.</entry>
   </row><row>
     <entry><codeph>font-style</codeph></entry>
     <entry><codeph>fontStyle</codeph></entry>
     <entry>Les valeurs reconnues sont <codeph>normal</codeph> et <codeph>italic</codeph>.</entry>
   </row><row>
     <entry><codeph>font-weight</codeph></entry>
     <entry><codeph>fontWeight</codeph></entry>
     <entry>Les valeurs reconnues sont <codeph>normal</codeph> et <codeph>bold</codeph>.</entry>
   </row><row>
     <entry><codeph>crénage</codeph></entry>
     <entry><codeph>crénage</codeph></entry>
     <entry>Les valeurs reconnues sont <codeph>true</codeph> et <codeph>false</codeph>. Le crénage est supporté uniquement pour les polices incorporées. Certaines polices, telles que Courier New, ne supportent pas le crénage. La propriété de crénage n’est supportée que dans les fichiers SWF créés dans Windows, pas dans les fichiers SWF créés sur Macintosh. Cependant, ces fichiers SWF peuvent être lus dans des versions de Flash Player autres que Windows et le crénage s’applique encore.</entry>
   </row><row>
     <entry><codeph>leading</codeph></entry>
     <entry><codeph>leading</codeph></entry>
     <entry>La quantité d’espace répartie uniformément entre les lignes. La valeur spécifie le nombre de pixels à ajouter après chaque ligne. Une valeur négative comprime l’espace entre les lignes. Seule la partie numérique de la valeur est utilisée. Les unités (px, pt) ne sont pas analysées. Les pixels et les points sont équivalents.</entry>
   </row><row>
     <entry><codeph>letter-spacing</codeph></entry>
     <entry><codeph>letterSpacing</codeph></entry>
     <entry>La quantité d’espace répartie uniformément entre les caractères. La valeur spécifie le nombre de pixels à ajouter après chaque caractère. Une valeur négative comprime l’espace entre les caractères. Seule la partie numérique de la valeur est utilisée. Les unités (px, pt) ne sont pas analysées. Les pixels et les points sont équivalents.</entry>
   </row><row>
     <entry><codeph>margin-left</codeph></entry>
     <entry><codeph>marginLeft</codeph></entry>
     <entry>Seule la partie numérique de la valeur est utilisée. Les unités (px, pt) ne sont pas analysées. Les pixels et les points sont équivalents. </entry>
   </row><row>
     <entry><codeph>margin-right</codeph></entry>
     <entry><codeph>marginRight</codeph></entry>
     <entry>Seule la partie numérique de la valeur est utilisée. Les unités (px, pt) ne sont pas analysées. Les pixels et les points sont équivalents.</entry>
   </row><row>
     <entry><codeph>text-align</codeph></entry>
     <entry><codeph>textAlign</codeph></entry>
     <entry>Les valeurs reconnues sont <codeph>left</codeph>, <codeph>center</codeph>, <codeph>right</codeph> et <codeph>justify</codeph>.</entry>
   </row><row>
     <entry><codeph>text-decoration</codeph></entry>
     <entry><codeph>textDecoration</codeph></entry>
     <entry>Les valeurs reconnues sont <codeph>none</codeph> et <codeph>underline</codeph>.</entry>
   </row><row>
     <entry><codeph>text-indent</codeph></entry>
     <entry><codeph>textIndent</codeph></entry>
     <entry>Seule la partie numérique de la valeur est utilisée. Les unités (px, pt) ne sont pas analysées. Les pixels et les points sont équivalents. </entry>
   </row></tbody></tgroup></adobetable> 
 
 <p><ph outputclass="flexonly">Vous pouvez utiliser la classe StyleSheet pour procéder à un rendu de texte de bas niveau. Cependant, dans Flex, vous devez normalement utiliser les contrôles Label, Text, TextArea et TextInput pour traiter le texte.</ph></p>
 
 
 </apiDesc><example conref="examples\StyleSheetExample.as"> L’exemple suivant crée une feuille de style et applique une police en gras et rouge au style du titre.
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class StyleSheetExample extends Sprite {

        public function StyleSheetExample() {
            var style:StyleSheet = new StyleSheet();

            var heading:Object = new Object();
            heading.fontWeight = "bold";
            heading.color = "#FF0000";

            var body:Object = new Object();
            body.fontStyle = "italic";

            style.setStyle(".heading", heading);
            style.setStyle("body", body);

            var label:TextField = new TextField();
            label.styleSheet = style;
            label.htmlText = "&lt;body>&lt;span class='heading'>Hello &lt;/span>World...&lt;/body>";
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:StyleSheet:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
	 Crée un objet StyleSheet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet, constructor
	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Crée un objet StyleSheet.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#StyleSheet/getStyle()"><linktext>flash.text.StyleSheet.getStyle()</linktext></link></related-links></apiConstructor><apiOperation id="flash.text:StyleSheet:clear"><apiName>clear</apiName><shortdesc>
	 Supprime l’ensemble des styles de l’objet feuille de style spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.clear, clear
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Supprime l’ensemble des styles de l’objet feuille de style spécifié.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:getStyle"><apiName>getStyle</apiName><shortdesc> 
	 Renvoie une copie de l’objet style associé au style spécifié appelé styleName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyle, getStyle
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Un objet.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne qui spécifie le nom du style à extraire.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc> 
	 Renvoie une copie de l’objet style associé au style spécifié appelé <codeph>styleName</codeph>. Si aucun objet style n’est associé à <codeph>styleName</codeph>, <codeph>null</codeph> est renvoyé.
	 
	 </apiDesc><example>Consultez l’exemple de la méthode <xref href="StyleSheet.html#parseCSS()">parseCSS()</xref> ou <xref href="StyleSheet.html#transform()">transform()</xref> pour une illustration de l’utilisation de la méthode <codeph>getStyle()</codeph>. 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#StyleSheet/setStyle()"><linktext>flash.text.StyleSheet.setStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:StyleSheet:parseCSS"><apiName>parseCSS</apiName><shortdesc>
	 Analyse le CSS dans CSSText et charge la feuille de style en même temps.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.parseCSS, parseCSS
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>CSSText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Le texte CSS à analyser (une chaîne).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Analyse le CSS dans cssText et charge la feuille de style en même temps.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Analyse le CSS dans <codeph>CSSText</codeph> et charge la feuille de style en même temps. Si l’un des styles de <codeph>CSSText</codeph> existe déjà dans <codeph>styleSheet</codeph>, les propriétés de <codeph>styleSheet</codeph> sont conservées et seules celles de <codeph>CSSText</codeph> sont ajoutées ou modifiées dans <codeph>styleSheet</codeph>.
	 
	 <p>Pour développer la capacité d’analyse CSS d’origine, vous pouvez annuler cette méthode en créant une sous-classe de la classe StyleSheet.</p>
	 
	 </apiDesc><example conref="examples\StyleSheet_parseCSSExample.as"> Dans l’exemple suivant, lorsqu’un utilisateur clique sur le fichier de texte, les styles CSS, chargés à partir d’un fichier, sont appliqués au contenu.
 
 <p>Dans le constructeur, un champ de texte multiligne est créé et son contenu est défini sur une chaîne au format HTML (le titre HTML et les balises Span ne sont pas rendus tant que le style CSS n’est pas appliqué). Un objet <codeph>URLRequest</codeph> est créé pour identifier l’emplacement du fichier CSS ; pour cet exemple, ce fichier se trouve dans le même répertoire que le fichier SWF. Le fichier est chargé avec un objet <codeph>URLLoader</codeph>. Deux écouteurs d’événement sont ajoutés pour l’objet URLLoader <codeph>loader</codeph>. Si une erreur d’E/S survient, la méthode <codeph>errorHandler()</codeph> est invoquée et affiche un message d’erreur dans le champ de texte. Une fois toutes les données reçues et placées dans la propriété data de l’objet URLLoader <codeph>loader</codeph>, la méthode <codeph>loaderCompleteHandler()</codeph> est invoquée. Cette méthode analyse les styles CSS à partir des données chargées depuis le fichier et renseigne l’objet StyleSheet <codeph>sheet</codeph> avec les définitions de style.</p>
 
 <p>Lorsque l’utilisateur clique sur le champ de texte, la méthode <codeph>clickHandler()</codeph> est appelée. L’instruction if de la méthode <codeph>clickHandler()</codeph> s’assure que le chargement du fichier est terminé avant d’appliquer la feuille de style au champ de texte. Pour que la feuille de style prenne effet, la propriété <codeph>htmlText</codeph> doit être réaffectée au contenu après que la feuille de style ait été affectée au champ de texte. Les valeurs des propriétés CSS <codeph>font-family</codeph> et <codeph>color</codeph> de la balise de titre sont également ajoutées au contenu du champ de texte (les valeurs de ces propriétés seront « undefined » si les valeurs de la feuille de style n’ont pas pris effet).</p> 
 
 <p>L’exemple suivant est un contenu de fichier CSS qui peut être utilisé avec cet exemple. Avant d’exécuter cet exemple, créez un fichier texte, copiez dans ce dernier le contenu CSS suivant, puis enregistrez le fichier sous le nom <codeph>test.css</codeph> et placez-le dans le même répertoire que le fichier SWF.</p>
 
 <pre>
   p {
      font-family: Times New Roman, Times, _serif;
      font-size: 14;
       font-Style: italic;
        margin-left: 10;  
   }
   h1 {
      font-family: Arial, Helvetica, _sans;
      font-size: 20;
      font-weight: bold;
   }
   .bluetext {
      color: #0000CC;
   }
 </pre>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class StyleSheet_parseCSSExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var field:TextField = new TextField();
        private var exampleText:String = "&lt;h1>This is a headline&lt;/h1>"
                    + "&lt;p>This is a line of text. &lt;span class='bluetext'>" 
                    + "This line of text is colored blue.&lt;/span>&lt;/p>";
        private var sheet:StyleSheet = new StyleSheet();
        private var cssReady:Boolean = false;

        public function StyleSheet_parseCSSExample() {
            field.x = 10;
            field.y = 10;
            field.background = true;
            field.multiline = true;
            field.autoSize = TextFieldAutoSize.LEFT;
            field.htmlText = exampleText;

            field.addEventListener(MouseEvent.CLICK, clickHandler);
            
            addChild(field);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            field.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            sheet.parseCSS(loader.data);
            cssReady = true;
        }

        public function clickHandler(e:MouseEvent):void {

            if (cssReady) {
                field.styleSheet = sheet;
                field.htmlText = exampleText;
                
                var style:Object = sheet.getStyle("h1");
                field.htmlText += "&lt;p>Headline font-family is: " + style.fontFamily + "&lt;/p>";
                field.htmlText += "&lt;p>Headline color is: " + style.color + "&lt;/p>";  

            } else {
                field.htmlText = "Couldn't apply the CSS styles.";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:setStyle"><apiName>setStyle</apiName><shortdesc>
	 Ajoute un nouveau style avec le nom spécifié à l’objet feuille de style.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example adds a style named <code>emphasized</code> to the 
	 StyleSheet <code>myStyleSheet</code>. The style includes two style properties: <code>color</code> 
	 and <code>fontWeight</code>. The style object is defined with the <code>{}</code> operator.
	 <pre><code>
	 myStyleSheet.setStyle("emphasized", {color:'#000000',fontWeight:'bold'});
	 </code></pre>
	 
	 <p>You could also create a style object using an instance of the Object class, and 
	 then pass that object (<code>styleObj</code>) as 
	 the <code>style</code> parameter, as the next example shows:</p>
	 <listing version="2.0">
	 import TextField.StyleSheet;
	 var my_styleSheet:StyleSheet = new StyleSheet();
	 
	 var styleObj:Object = new Object();
	 styleObj.color = "#000000";
	 styleObj.fontWeight = "bold";
	 my_styleSheet.setStyle("emphasized", styleObj);
	 delete styleObj;
	 
	 var styleNames_array:Array = my_styleSheet.getStyleNames();
	 for (var i=0;i&lt;styleNames_array.length;i++) {
	 	var styleName:String = styleNames_array[i];
	 	var thisStyle:Object = my_styleSheet.getStyle(styleName);
	 	trace(styleName);
	 	for (var prop in thisStyle) {
	 		trace("\t"+prop+": "+thisStyle[prop]);
	 	}
	 	trace("");
	 }
	 </listing>
	 <p><span class="flashonly">The following information appears in the Output 
	 panel:</span><span class="flexonly">The following information writes to the 
	 log file:</span></p>
	 <pre><code>
	 emphasized
	   fontWeight: bold
	   color: #000000
	 </code></pre>
	 
	 <p><strong>Note: </strong>Because Flash Player creates a copy of the style object
	 you pass to <code>setStyle()</code>, the <code> delete styleObj</code> command in the 
	 code example reduces memory usage by deleting the original style object passed to 
	 <code>setStyle()</code>.</p>
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne qui spécifie le nom du style à ajouter à la feuille de style.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>styleObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Un objet qui décrit le style, ou <codeph>null</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ajoute un nouveau style avec le nom spécifié à l’objet feuille de style. Si le style nommé n’existe pas déjà dans la feuille de style, il est ajouté. Si le style nommé n’existe pas déjà dans la feuille de style, il est remplacé. Si le paramètre <codeph>styleObject</codeph> est <codeph>null</codeph>, le style nommé est supprimé.
	 
	 <p>Flash Player crée une copie de l’objet style que vous transmettez à cette méthode.</p>
	 
	 <p>Vous trouverez une liste des styles supportés dans le tableau de description de la classe StyleSheet.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:transform"><apiName>transform</apiName><shortdesc>
	 Développe la capacité d’analyse du fichier CSS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.transform, transform
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet TextFormat contenant le résultat du mappage des règles CSS en propriétés de format de texte.
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>formatObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Objet qui décrit le style, contenant des règles de style en tant que propriétés de l’objet, ou <codeph>null</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Développe la capacité d’analyse du fichier CSS. Les développeurs avancés peuvent annuler cette méthode en développant la classe StyleSheet. 
	 
	 </apiDesc><example conref="examples\StyleSheet_transformExample.as"> Cet exemple utilise la méthode <codeph>transform()</codeph> pour appliquer un style à partir d’un fichier CSS à un objet TextFormat pour un champ de texte.
 
 <p>Les styles CSS sont généralement utilisés pour mettre en forme du contenu HTML. Toutefois, via la méthode <codeph>transform()</codeph> d’un objet StyleSheet, des styles CSS peuvent être affectés à un objet TextFormat, puis appliqués à n’importe quel champ de texte.</p> 
 
 <p>Les objets <codeph>URLRequest</codeph> et <codeph>URLLoader</codeph> sont utilisés pour charger le fichier CSS. Un écouteur d’événement est ajouté pour l’événement <codeph>Event.COMPLETE</codeph>, qui survient après que toutes les données ont été reçues et placées dans la propriété data de l’objet URLLoader <codeph>loader</codeph>. La méthode <codeph>loaderCompleteHandler()</codeph> analyse ensuite le CSS à partir des données chargées depuis le fichier et renseigne l’objet StyleSheet <codeph>sheet</codeph> avec les styles. La méthode <codeph>getStyle()</codeph> de la feuille de style récupère les styles de paragraphe HTML, qui sont ensuite attribués à l’objet TextFormat <codeph>cssFormat</codeph> via la méthode <codeph>transform()</codeph> de la feuille de style. Enfin, le format de texte par défaut du champ de texte <codeph>inputField</codeph> est défini sur le nouveau format de texte <codeph>cssFormat</codeph>.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldType;
    import flash.events.IOErrorEvent;
    import flash.events.Event;

    public class StyleSheet_transformExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var inputField:TextField = new TextField();
        private var sheet:StyleSheet = new StyleSheet();

        public function StyleSheet_transformExample() {
            inputField.x = 10;
            inputField.y = 10;
            inputField.background = true;
            inputField.width = 300;
            inputField.height = 200;
            inputField.wordWrap = true;
            inputField.multiline = true;    
            inputField.type = TextFieldType.INPUT;

            addChild(inputField);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            inputField.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            var cssFormat:TextFormat = new TextFormat();
            sheet.parseCSS(loader.data);
            var style:Object = sheet.getStyle("p");
            cssFormat = sheet.transform(style);
            inputField.defaultTextFormat = cssFormat;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:StyleSheet:styleNames:get"><apiName>styleNames</apiName><shortdesc>
	 Tableau qui contient les noms (sous formes de chaînes) de tous les styles enregistrés dans cette feuille de style.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyleNames, getStyleNames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>Renvoie les noms de tous les styles enregistrés dans cette feuille de style.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Tableau qui contient les noms (sous formes de chaînes) de tous les styles enregistrés dans cette feuille de style.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextSnapshot"><apiName>TextSnapshot</apiName><shortdesc> 
 Les objets TextSnapshot permettent de travailler avec du texte statique dans un clip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Les objets TextSnapshot permettent de travailler avec du texte statique dans un clip. Vous pouvez les utiliser, par exemple, pour mettre en forme du texte avec une plus grande précision que celle permise par un texte dynamique, mais le texte est toujours en lecture seule.
 
 <p>Vous n’utilisez pas de constructeur pour créer un objet TextSnapshot ; il est renvoyé par la propriété <codeph>flash.display.DisplayObjectContainer.textSnapshot</codeph>.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/textSnapshot"><linktext>flash.display.DisplayObjectContainer.textSnapshot</linktext></link></related-links><apiOperation id="flash.text:TextSnapshot:findText"><apiName>findText</apiName><shortdesc>
	 Recherche l’objet TextSnapshot spécifié et renvoie la position de la première occurrence de textToFind figurant au niveau de ou après beginIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.findText, findText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>La position dans l’index de base zéro de la première occurrence du texte spécifié, ou -1.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Spécifie le point de départ pour la recherche du texte spécifié.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>textToFind</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Spécifie le texte à rechercher. Si vous spécifiez un littérale de chaîne au lieu d’une variable de type String, mettez la chaîne entre guillemets.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>caseSensitive</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Spécifie si la casse du texte doit correspondre à celle de la chaîne de <codeph>textToFind</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Recherche l’objet TextSnapshot spécifié et renvoie la position de la première occurrence de <codeph>textToFind</codeph> figurant au niveau de ou après <codeph>beginIndex</codeph>. Si <codeph>textToFind</codeph> n’est pas détecté, la méthode renvoie <codeph>-1</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelected"><apiName>getSelected</apiName><shortdesc>
	 Renvoie une valeur booléenne qui spécifie si un objet TextSnapshot contient du texte sélectionné dans la plage spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelected, getSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Valeur booléenne indiquant si, dans la plage donnée, au moins un caractère a été sélectionné par la méthode <codeph>setSelected()</codeph> correspondante (<codeph>true</codeph>) ; sinon, <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Indique la position du premier caractère à examiner. Les valeurs valides pour <codeph>beginIndex</codeph> vont de <codeph>0</codeph> à <codeph>TextSnapshot.charCount - 1</codeph>. Si <codeph>beginIndex</codeph> est une valeur négative, <codeph>0</codeph> est utilisé.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur supérieure à l’index du dernier caractère à examiner. Les valeurs valides de <codeph>endIndex</codeph> sont comprises entre <codeph>0</codeph> et <codeph>charCount</codeph>. Le caractère indexé par le paramètre <codeph>endIndex</codeph> n’est pas inclus dans la chaîne extraite. Si ce paramètre est omis, <codeph>charCount</codeph> est utilisé. Lorsque cette valeur est inférieure ou égale à la valeur de <codeph>beginIndex</codeph>, <codeph>beginIndex + 1</codeph> est utilisé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une valeur booléenne qui spécifie si un objet TextSnapshot contient du texte sélectionné dans la plage spécifiée. 
	 
	 <p>Pour rechercher tous les caractères, transmettez une valeur <codeph>0</codeph> pour <codeph>start</codeph> et <codeph>charCount</codeph> (ou un grand nombre quelconque) pour <codeph>end</codeph>. Pour rechercher un seul caractère, transmettez au paramètre <codeph>end</codeph> une valeur égale au paramètre <codeph>start</codeph> plus un.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelectedText"><apiName>getSelectedText</apiName><shortdesc>
	 Renvoie une chaîne qui contient tous les caractères spécifiés par la méthode setSelected() correspondante.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelectedText, getSelectedText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne qui contient tous les caractères spécifiés par la commande <codeph>setSelected()</codeph> correspondante.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Une valeur booléenne qui spécifie si des caractères de nouvelle ligne sont insérés dans la chaîne renvoyée, le cas échéant. La valeur par défaut est <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une chaîne qui contient tous les caractères spécifiés par la méthode <codeph>setSelected()</codeph> correspondante. Si aucun caractère n’est spécifié par la méthode <codeph>setSelected()</codeph>, une chaîne vide est renvoyée.
	 
	 <p>Si vous transmettez <codeph>true</codeph> pour <codeph>includeLineEndings</codeph>, des caractères de nouvelle ligne sont insérés dans la chaîne de renvoi et cette dernière peut être plus longue que la plage d’entrée. Si <codeph>includeLineEndings</codeph> est <codeph>false</codeph> ou omis, la méthode renvoie le texte sélectionné sans ajouter de caractères.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getSelected()"><linktext>flash.text.TextSnapshot.getSelected()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getText"><apiName>getText</apiName><shortdesc>
	 Renvoie une chaîne qui contient tous les caractères spécifiés par les paramètres beginIndex et endIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getText, getText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne contenant les caractères dans la plage spécifiée, ou une chaîne vide si aucun caractère n’est détecté dans la plage spécifiée.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Indique la position du premier caractère à inclure dans la chaîne renvoyée. Les valeurs valides pour <codeph>beginIndex</codeph> vont de <codeph>0</codeph> à <codeph>charCount - 1</codeph>. Si <codeph>beginIndex</codeph> est une valeur négative, <codeph>0</codeph> est utilisé.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur supérieure à l’index du dernier caractère à examiner. Les valeurs valides de <codeph>endIndex</codeph> sont comprises entre <codeph>0</codeph> et <codeph>charCount</codeph>. Le caractère indexé par le paramètre <codeph>endIndex</codeph> n’est pas inclus dans la chaîne extraite. Si ce paramètre est omis, <codeph>charCount</codeph> est utilisé. Lorsque cette valeur est inférieure ou égale à la valeur de <codeph>beginIndex</codeph>, <codeph>beginIndex + 1</codeph> est utilisé.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Valeur booléenne qui spécifie si les caractères de nouvelle ligne sont insérés (<codeph>true</codeph>) ou s’ils ne sont pas insérés (<codeph>false</codeph>) dans la chaîne renvoyée. La valeur par défaut est <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une chaîne qui contient tous les caractères spécifiés par les paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. Si aucun caractère n’est sélectionné, une chaîne vide est renvoyée. 
	 
	 <p>Pour renvoyer tous les caractères, transmettez une valeur <codeph>0</codeph> pour <codeph>beginIndex</codeph> et <codeph> charCount</codeph> (ou un grand nombre quelconque) pour <codeph>endIndex</codeph>. Pour renvoyer un seul caractère, transmettez une valeur de <codeph>beginIndex + 1</codeph> pour <codeph>endIndex</codeph>. </p>
	 
	 <p>Si vous transmettez une valeur <codeph>true</codeph> pour <codeph>includeLineEndings</codeph>, des caractères de nouvelle ligne sont insérés dans la chaîne renvoyée à l’emplacement jugé nécessaire. Dans ce cas, la chaîne renvoyée risque de dépasser la plage de saisie. Si <codeph>includeLineEndings</codeph> est <codeph>false</codeph> ou omis, le texte sélectionné est renvoyé sans caractères supplémentaires.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getTextRunInfo"><apiName>getTextRunInfo</apiName><shortdesc>
	 Renvoie un tableau d’objets contenant des informations sur un segment de texte.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Un tableau d’objets dans lequel chaque objet contient des informations sur un caractère spécifique qui est contenu dans la plage de caractères spécifiée par les paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. Chaque objet contient les onze propriétés suivantes :
	 <ul>
	 
	  	<li><codeph>indexInRun</codeph> Index d’entiers à base zéro du caractère (par rapport à l’ensemble de la chaîne plutôt qu’au segment de texte sélectionné).</li>
	 
	  	<li><codeph>selected</codeph> Valeur booléenne indiquant si le caractère est sélectionné comme <codeph>true</codeph> ; <codeph>false</codeph> dans le cas contraire.</li>
	 
	  	<li><codeph>font</codeph> Le nom de la police de caractère.</li>
	 
	  	<li><codeph>color</codeph> La valeur combinée alpha et couleur du caractère. Les deux premiers nombres hexadécimaux représentent la valeur alpha, les autres nombres représentent la valeur couleur.</li>
	 
	  	<li><codeph>height</codeph> La hauteur des caractères, en pixels.</li>
	 
	  	<li><codeph>matrix_a</codeph>, <codeph>matrix_b</codeph>, <codeph>matrix_c</codeph>, <codeph>matrix_d</codeph>, <codeph>matrix_tx</codeph> et <codeph>matrix_ty</codeph> Valeurs de la matrice qui définit la transformation géométrique du caractère. La matrice d’un texte normal, droit est toujours de la forme <codeph>[1 0 0 1 x y]</codeph>, où <codeph>x</codeph> et <codeph>y</codeph> sont les positions du caractère dans le clip parent, indépendamment de la hauteur du texte. La matrice se trouve dans le système de coordonnées du clip parent et ne contient aucune transformations susceptibles de se trouver sur ce clip même (ou son parent). </li>
	 
	 	<li><codeph>corner0x</codeph>, <codeph>corner0y</codeph>, <codeph>corner1x</codeph>, <codeph>corner1y</codeph>, <codeph>corner2x</codeph>, <codeph>corner2y</codeph>, <codeph>corner3x</codeph> et <codeph>corner3y</codeph> Les coins du cadre de sélection du caractère, en fonction du système de coordonnées du clip parent. Ces valeurs ne sont disponibles que si la police utilisée par le caractère est intégrée dans le fichier SWF.</li>
	 
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>La valeur d’index du premier caractère dans une la plage de caractères d’un objet TextSnapshot.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>La valeur d’index du dernier caractère dans une la plage de caractères d’un objet TextSnapshot.
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie un tableau d’objets contenant des informations sur un segment de texte. Chaque objet correspond à un caractère dans la plage de caractères spécifiée par les deux paramètres de méthode. 
	 
	 <p><b>Remarque : </b> L’utilisation de la méthode <codeph>getTextRunInfo()</codeph> pour une plage de texte volumineuse peut générer le renvoi d’un objet volumineux. Adobe recommande de limiter la plage de texte définie par les paramètres <codeph>beginIndex</codeph> et <codeph>endIndex</codeph>. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>Classe Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:hitTestTextNearPos"><apiName>hitTestTextNearPos</apiName><shortdesc>
	 Permet de déterminer lequel des caractères contenus dans un objet TextSnapshot se trouve sur ou est proche des coordonnées spécifiées x, y du clip contenant le texte dans l’objet TextSnapshot.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.hitTestTextNearPos, hitTestTextNearPos
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre représentant la valeur d’index du caractère qui est le plus proche des coordonnées <codeph>x</codeph>, <codeph>y</codeph> spécifiées. Renvoie <codeph>-1</codeph> si aucun caractère n’est détecté ou si la police ne contient pas d’informations métriques de caractères.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui représente la coordonnée <codeph>x</codeph> du clip qui contient le texte.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre qui représente la coordonnée <codeph>y</codeph> du clip qui contient le texte.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>maxDistance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre qui représente la distance maximale de <codeph>x</codeph>, <codeph>y</codeph> dans laquelle une recherche de texte peut être lancée. Cette distance est mesurée à partir du point central de chaque caractère. La valeur par défaut est <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Permet de déterminer lequel des caractères contenus dans un objet TextSnapshot se trouve sur ou est proche des coordonnées spécifiées <codeph>x</codeph>, <codeph>y</codeph> du clip contenant le texte dans l’objet TextSnapshot.
	 
	 <p>Si vous omettez ou transmettez une valeur <codeph>0</codeph> pour <codeph>maxDistance</codeph>, l’emplacement spécifié par les coordonnées <codeph>x</codeph>, <codeph>y</codeph> doit se trouver à l’intérieur du cadre de sélection de l’objet TextSnapshot. 
	 </p>
	 
	 <p>Cette méthode fonctionne correctement uniquement pour les polices qui incluent des informations métriques de caractères ; par défaut cependant, l’outil de programmation Flash n’inclut pas ces informations pour les champs de texte statique. <ph outputclass="flashonly">Par conséquent, il se peut que la méthode renvoie <codeph>-1</codeph> au lieu d’une valeur d’index. Pour garantir qu’une valeur d’indexation est renvoyée, vous pouvez forcer l’outil de programmation Flash à inclure les informations métriques de caractères pour une police. Pour ce faire, ajoutez un champ de texte dynamique qui utilise cette police, sélectionnez les options des caractères pour ce champ de texte dynamique et spécifiez que les polices vectorielles doivent être intégrées pour au moins un caractère (le choix des caractères spécifiés et la présence ou non des caractères utilisés dans les champs de texte statique en question importent peu)</ph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/x"><linktext>flash.display.DisplayObject.x</linktext></link><link href="flash.display.xml#DisplayObject/y"><linktext>flash.display.DisplayObject.y</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelectColor"><apiName>setSelectColor</apiName><shortdesc>
	 Spécifie la couleur à utiliser lors de la mise en surbrillance des caractères qui ont été sélectionnés avec la méthode setSelected().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelectColor, setSelectColor
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>hexColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFF00</apiData><apiDesc>La couleur utilisée pour la bordure placée autour des caractères qui ont été sélectionnés avec la commande <codeph>setSelected()</codeph> correspondante, exprimée au format hexadécimal (0x<i>RRGGBB</i>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie la couleur à utiliser lors de la mise en surbrillance des caractères qui ont été sélectionnés avec la méthode <codeph> setSelected()</codeph>. La couleur est toujours opaque ; vous ne pouvez pas spécifier de valeur de transparence.
	 
	 <p>Cette méthode fonctionne correctement uniquement pour les polices qui incluent des informations métriques de caractères ; par défaut cependant, l’outil de programmation Flash n’inclut pas ces informations pour les champs de texte statique. Par conséquent, il se peut que la méthode renvoie <codeph>-1</codeph> au lieu d’une valeur d’index.<ph outputclass="flashonly"> Pour garantir qu’une valeur d’index est renvoyée, vous pouvez forcer l’outil de programmation Flash à inclure les informations métriques de caractères pour une police. Pour ce faire, ajoutez un champ de texte dynamique qui utilise cette police, sélectionnez les options des caractères pour ce champ de texte dynamique et spécifiez que les polices vectorielles doivent être intégrées pour au moins un caractère (le choix des caractères spécifiés et la présence ou non des caractères utilisés dans les champs de texte statique en question importent peu).</ph></p>	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelected"><apiName>setSelected</apiName><shortdesc>
	 Spécifie une plage de caractères dans un objet TextSnapshot à sélectionner ou désélectionner.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelected, setSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Indique la position du premier caractère à sélectionner. Les valeurs valides pour <codeph>beginIndex</codeph> vont de <codeph>0</codeph> à <codeph>charCount - 1</codeph>. Si <codeph>beginIndex</codeph> est une valeur négative, <codeph>0</codeph> est utilisé.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier qui correspond à 1+ l’index du dernier caractère à examiner. Les valeurs valides de <codeph>end</codeph> sont comprises entre <codeph>0</codeph> et <codeph>charCount</codeph>. Le caractère indexé par le paramètre <codeph>end</codeph> n’est pas inclus dans la chaîne extraite. Si vous omettez ce paramètre, <codeph>TextSnapshot.charCount</codeph> est utilisé. Si la valeur de <codeph>beginIndex</codeph> est inférieure ou égale à la valeur <codeph>endIndex</codeph>, <codeph>beginIndex + 1</codeph> est utilisée.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>select</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Une valeur booléenne qui spécifie si le texte doit être sélectionné (<codeph>true</codeph>) ou désélectionné (<codeph>false</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Spécifie une plage de caractères dans un objet TextSnapshot à sélectionner ou désélectionner. Les caractères qui sont sélectionnés sont dessinés sur fond de rectangle coloré, correspondant au cadre de sélection du caractère. La couleur du cadre de sélection est défini par <codeph>setSelectColor()</codeph>.
	 
	 <p>Pour sélectionner ou désélectionner tous les caractères, transmettez la valeur <codeph>0</codeph> pour <codeph>beginIndex</codeph> et <codeph>charCount</codeph> (ou un grand nombre quelconque) pour <codeph>endIndex</codeph>. Pour spécifier un seul caractère, transmettez une valeur de <codeph>start + 1</codeph> pour <codeph>endIndex</codeph>. </p>
	 
	 <p>Les caractères étant individuellement marqués comme sélectionnés, vous pouvez appeler cette méthode plusieurs fois pour sélectionner plusieurs caractères ; c’est-à-dire, l’utilisation de cette méthode ne désélectionne pas les autres caractères qui ont été définis par cette méthode.</p>
	 
	 <p>Le rectangle de couleur qui indique qu’une sélection s’affiche uniquement pour les polices qui incluent des informations sur les unités de mesure des caractères. Par défaut, Flash n’inclut pas ces informations pour les champs texte statiques. Dans la plupart des cas, ce comportement signifie que le texte qui est sélectionné ne semblera pas sélectionné à l’écran.<ph outputclass="flashonly"> Pour garantir que l’ensemble du texte sélectionné s’affiche comme tel, vous pouvez forcer l’outil de programmation Flash à inclure les informations métriques de caractères pour une police. Pour ce faire, ajoutez un champ de texte dynamique qui utilise cette police, sélectionnez les options des caractères pour ce champ de texte dynamique et spécifiez que les polices vectorielles doivent être intégrées pour au moins un caractère. Le choix des caractères spécifiés et la présence ou non des caractères utilisés dans les champs de texte statique en question importent peu.</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/setSelectColor()"><linktext>flash.text.TextSnapshot.setSelectColor()</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextSnapshot:charCount:get"><apiName>charCount</apiName><shortdesc>
	 Nombre de caractères dans un objet TextSnapshot.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.charCount, charCount, count
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre de caractères dans un objet TextSnapshot.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldAutoSize"><apiName>TextFieldAutoSize</apiName><shortdesc>
La classe TextFieldAutoSize énumère les valeurs constantes utilisées lors de la définition de la propriété autoSize de la classe TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe TextFieldAutoSize énumère les valeurs constantes utilisées lors de la définition de la propriété <codeph>autoSize</codeph> de la classe TextField. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link></related-links><apiValue id="flash.text:TextFieldAutoSize:CENTER"><apiName>CENTER</apiName><shortdesc> 
	Spécifie que le texte doit être traité comme centré.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Spécifie que le texte doit être traité comme centré. Tout redimensionnement d’une ligne de champ de texte est réparti de façon égale à droite et à gauche. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:LEFT"><apiName>LEFT</apiName><shortdesc> 
	Spécifie que le texte doit être traité comme justifié à gauche, ce qui signifie que le côté gauche du champ de texte reste fixe et que tout ajustement de la longueur de ligne se fait à droite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Spécifie que le texte doit être traité comme justifié à gauche, ce qui signifie que le côté gauche du champ de texte reste fixe et que tout ajustement de la longueur de ligne se fait à droite. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:NONE"><apiName>NONE</apiName><shortdesc> 
	
	Spécifie qu’aucun redimensionnement ne doit se produire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	
	Spécifie qu’aucun redimensionnement ne doit se produire.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:RIGHT"><apiName>RIGHT</apiName><shortdesc> 
	Spécifie que le texte doit être traité comme justifié à droite, ce qui signifie que le côté droit du champ de texte reste fixe et que tout ajustement de la longueur de ligne se fait à gauche.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Spécifie que le texte doit être traité comme justifié à droite, ce qui signifie que le côté droit du champ de texte reste fixe et que tout ajustement de la longueur de ligne se fait à gauche. 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:FontStyle"><apiName>FontStyle</apiName><shortdesc>
La classe FontStyle fournit les valeurs de la classe TextRenderer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe FontStyle fournit les valeurs de la classe TextRenderer.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:FontStyle:BOLD"><apiName>BOLD</apiName><shortdesc>
    Définit le style gras d’une police pour le paramètre fontStyle dans la méthode setAdvancedAntiAliasingTable().</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bold</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Définit le style gras d’une police pour le paramètre <codeph>fontStyle</codeph> dans la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>. Utilisez la syntaxe <codeph>FontStyle.BOLD</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:BOLD_ITALIC"><apiName>BOLD_ITALIC</apiName><shortdesc>
    Définit le style combiné, gras et italiques, d’une police pour le paramètre fontStyle dans la méthode setAdvancedAntiAliasingTable().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>boldItalic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Définit le style combiné, gras et italiques, d’une police pour le paramètre <codeph>fontStyle</codeph> dans la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>. Utilisez la syntaxe <codeph>FontStyle.BOLD_ITALIC</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:ITALIC"><apiName>ITALIC</apiName><shortdesc>
    Définit le style italiques d’une police pour le paramètre fontStyle dans la méthode setAdvancedAntiAliasingTable().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>italic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Définit le style italiques d’une police pour le paramètre <codeph>fontStyle</codeph> dans la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>. Utilisez la syntaxe <codeph>FontStyle.ITALIC</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:REGULAR"><apiName>REGULAR</apiName><shortdesc>
    Définit le style ordinaire d’une police pour le paramètre fontStyle dans la méthode setAdvancedAntiAliasingTable().</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>regular</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Définit le style ordinaire d’une police pour le paramètre <codeph>fontStyle</codeph> dans la méthode <codeph>setAdvancedAntiAliasingTable()</codeph>. Utilisez la syntaxe <codeph>FontStyle.REGULAR</codeph>.. 
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldType"><apiName>TextFieldType</apiName><shortdesc>
La classe TextFieldType énumère les valeurs constantes utilisées lors de la définition de la propriété type de la classe TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
La classe TextFieldType énumère les valeurs constantes utilisées lors de la définition de la propriété <codeph>type</codeph> de la classe TextField. 


</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/type"><linktext>flash.text.TextField.type</linktext></link></related-links><apiValue id="flash.text:TextFieldType:DYNAMIC"><apiName>DYNAMIC</apiName><shortdesc> 
	Utilisé pour spécifier un champ de texte dynamique.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dynamic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Utilisé pour spécifier un champ de texte <codeph>dynamic</codeph>. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldType:INPUT"><apiName>INPUT</apiName><shortdesc> 
	Utilisé pour spécifier un champ de texte de saisie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>input</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Utilisé pour spécifier un champ de texte de type <codeph>input</codeph>. 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>