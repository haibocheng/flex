<?xml version="1.0"?>
<apiPackage id="flash.utils"><apiName>flash.utils</apiName><apiDetail/><apiClassifier id="flash.utils:Proxy"><apiName>Proxy</apiName><shortdesc>
 La classe Proxy permet de contourner le comportement par défaut des opérations ActionScript (notamment pour l’extraction et la modification des propriétés) effectuées sur un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Proxy permet de contourner le comportement par défaut des opérations ActionScript (notamment pour l’extraction et la modification des propriétés) effectuées sur un objet.
 
 <p>La classe Proxy ne possède pas de constructeur et il n’est pas recommandé de l’instancier. Utilisez la classe Proxy en tant que sous-classe pour bloquer des méthodes telles que <codeph>getProperty</codeph> et fournir un comportement personnalisé. Si vous tentez d’utiliser une méthode de la classe Proxy sans la bloquer, une exception est renvoyée.</p>
 <p>N’oubliez pas que, si votre propre code bloque les méthodes de la classe Proxy, des exceptions risquent d’être renvoyées non intentionnellement. Le renvoi d’exceptions lors de l’utilisation de ces méthodes est source de problèmes, car le code appelant (qui utilise des opérateurs tels que <codeph>in</codeph>, <codeph>is</codeph>, <codeph>delete</codeph>, etc.) ne s’attend pas à des exceptions. A moins d’être certain que la méthode de remplacement ne renvoie pas d’exceptions, Adobe recommande l’utilisation d’instructions <codeph>try..catch</codeph> de part et d’autre de votre implémentation de la classe Proxy afin d’éviter les erreurs irrémédiables lorsque les opérateurs appellent vos méthodes. Exemple : </p> 
 <codeblock>
 dynamic class MyProxy extends Proxy {
     flash_proxy override function callProperty(name:~~, ...rest):~~ {
       try {
         // custom code here
       }
       catch (e:Error) {
         // respond to error here
       }
 }   
 </codeblock>
 
 <p>La classe Proxy remplace les fonctionnalités <codeph>Object.__resolve</codeph> et <codeph>Object.addProperty</codeph> d’ActionScript 2.0, qui ne sont plus disponibles dans ActionScript 3.0. La fonctionnalité <codeph>Object.addProperty()</codeph> vous permet de créer dynamiquement les méthodes get et set dans ActionScript 2.0. Bien que ActionScript 3.0 fournisse les méthodes get et set à la compilation, il est impossible d’en affecter une dynamiquement à un objet sans utiliser la classe Proxy.</p>
 
 <p>Pour éviter les doublons des espaces de nom <codeph>public</codeph>, les méthodes de la classe Proxy sont dans l’espace de noms <codeph>flash_proxy</codeph>.</p>
 
 <p>Si les méthodes de la classe Proxy nécessitent un argument <codeph>name</codeph>, <codeph>name</codeph> peut correspondre à un objet String ou QName (sous réserve d’utiliser les espaces de nom).</p>
 
 </apiDesc><example conref="examples\ProxyExample.as"><codeblock>
package {
    import flash.display.Sprite;

    public class ProxyExample extends Sprite {
        public function ProxyExample() {
            var arr:ProxyArray = new ProxyArray();
            arr.push(1);
            arr.push(-2);
            arr.push(3);
            arr.push(4);
            arr.push("five");
            
            trace(arr.length); // 5
            trace(arr[0]);     // 1
            trace(arr[1]);     // -2
            trace(arr[2]);     // 3
            trace(arr[3]);     // 4

            trace(arr.sum());  // 6

            arr.clear();
            trace(arr); // (empty string)
            
            arr[0] = "zero";
            trace(arr); // zero
        }
    }
}

import flash.utils.Proxy;
import flash.utils.flash_proxy;

dynamic class ProxyArray extends Proxy {
    private var _item:Array;

    public function ProxyArray() {
        _item = new Array();
    }

    override flash_proxy function callProperty(methodName:*, ... args):* {
        var res:*;
        switch (methodName.toString()) {
            case 'clear':
                _item = new Array();
                break;
            case 'sum':
                var sum:Number = 0;
                for each (var i:* in _item) {
                    // ignore non-numeric values
                    if (!isNaN(i)) {
                        sum += i;
                    }
                }
                res = sum;
                break;
            default:
                res = _item[methodName].apply(_item, args);
                break;
        }
        return res;
    }

    override flash_proxy function getProperty(name:*):* {
        return _item[name];
    }

    override flash_proxy function setProperty(name:*, value:*):void {
        _item[name] = value;
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.utils:Proxy:flash_proxy:callProperty"><apiName>callProperty</apiName><shortdesc>
	 Bloque le comportement de la propriété d’un objet susceptible d’être appelée en tant que fonction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Valeur renvoyée par la méthode appelée.
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la méthode invoquée.
	 </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Tableau qui spécifie les arguments à la méthode appelée.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bloque le comportement de la propriété d’un objet susceptible d’être appelée en tant que fonction. Lorsqu’une méthode de l’objet est invoquée, cette méthode est appelée. Bien que certains objets puissent être appelés en tant que fonctions, certaines propriétés d’objets peuvent également l’être. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Spécification ECMA-262, édition 3, section 15</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:deleteProperty"><apiName>deleteProperty</apiName><shortdesc>
	 Bloque la requête de suppression d’une propriété.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Si la propriété a été supprimée, <codeph>true</codeph> ; dans le cas contraire, <codeph>false</codeph>.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la propriété à supprimer.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bloque la requête de suppression d’une propriété. Lorsqu’une propriété est supprimée par l’opérateur <codeph>delete</codeph>, cette méthode est appelée pour effectuer la suppression. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../operators.html#delete"><linktext>opérateur delete</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Spécification ECMA-262, édition 3, section 8.6.2.5</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:getDescendants"><apiName>getDescendants</apiName><shortdesc>
	 Bloque l’utilisation de l’opérateur descendant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Résultats de l’opérateur <codeph>descendant</codeph>.
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la propriété à rechercher en descendant dans l’objet.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bloque l’utilisation de l’opérateur <codeph>descendant</codeph>. Lorsque l’opérateur <codeph>descendant</codeph> est utilisé, cette méthode est invoquée.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../operators.html#descendant_accessor"><linktext>Opérateur descendant</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Spécification E4X</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:getProperty"><apiName>getProperty</apiName><shortdesc>
     Bloque toute requête de valeur d’une propriété.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Propriété spécifiée, ou <codeph>undefined</codeph> si elle est introuvable.
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la propriété à extraire.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Bloque toute requête de valeur d’une propriété. Si la propriété est introuvable, la méthode renvoie <codeph>undefined</codeph>. Pour plus d’informations sur ce comportement, voir la spécification ECMA-262, édition 3, section 8.6.2.1.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../statements.html#get"><linktext>Instruction get</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Spécification ECMA-262, édition 3, section 8.6.2.1.</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:hasProperty"><apiName>hasProperty</apiName><shortdesc>
	 Bloque une requête pour vérifier si un objet possède une propriété spécifique identifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si la propriété existe, <codeph>false</codeph> dans le cas contraire.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la propriété à vérifier.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bloque une requête pour vérifier si un objet possède une propriété spécifique identifiée. 
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/hasOwnProperty()"><linktext>Object.hasOwnProperty()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Spécification ECMA-262, édition 3, section 8.6.2.4</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:isAttribute"><apiName>isAttribute</apiName><shortdesc>
	 Vérifie si le QName fourni est également marqué comme attribut.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’argument associé à <codeph>name</codeph> est un QName également marqué comme attribut.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la propriété à vérifier.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Vérifie si le QName fourni est également marqué comme attribut. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#QName"><linktext>Classe QName</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextName"><apiName>nextName</apiName><shortdesc>
	 Permet l’énumération par numéro d’index des propriétés de l’objet traité par proxy pour extraire les noms de propriété.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Nom de la propriété
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur de l’index de base zéro de la propriété de l’objet.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Permet l’énumération par numéro d’index des propriétés de l’objet traité par proxy pour extraire les noms de propriété. Vous ne pouvez cependant pas énumérer les propriétés de la classe Proxy elles-mêmes. Cette fonction prend en charge l’implémentation des boucles <codeph>for...in</codeph> et <codeph>for each..in</codeph> dans l’objet pour extraire les noms requis.
	 <p>Exemple (code extrait de <codeph>Proxy.nextNameIndex()</codeph>) :</p>
     <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
     </codeblock>
 	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextNameIndex()"><linktext>Proxy.nextNameIndex()</linktext></link><link href="flash.utils.xml#Proxy/nextValue()"><linktext>Proxy.nextValue()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextNameIndex"><apiName>nextNameIndex</apiName><shortdesc>
	 Permet l’énumération par numéro d’index des propriétés de l’objet traité par proxy.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Valeur de l’index de la propriété.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’index basée sur zéro qui indique le début de l’énumération.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Permet l’énumération par numéro d’index des propriétés de l’objet traité par proxy. Vous ne pouvez cependant pas énumérer les propriétés de la classe Proxy elles-mêmes. Cette fonction prend en charge l’implémentation des boucles <codeph>for...in</codeph> et <codeph>for each..in</codeph> dans l’objet pour récupérer les valeurs d’index des propriétés.
	 <p>Exemple :</p>
	 <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
	 </codeblock>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextName()"><linktext>Proxy.nextName()</linktext></link><link href="flash.utils.xml#Proxy/nextValue()"><linktext>Proxy.nextValue()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextValue"><apiName>nextValue</apiName><shortdesc>
 	 Permet l’énumération par numéro d’index des propriétés de l’objet traité par proxy pour extraire les valeurs de propriété.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Valeur de la propriété.
	 </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur de l’index de base zéro de la propriété de l’objet.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
 	 Permet l’énumération par numéro d’index des propriétés de l’objet traité par proxy pour extraire les valeurs de propriété. Vous ne pouvez cependant pas énumérer les propriétés de la classe Proxy elles-mêmes. Cette fonction prend en charge l’implémentation des boucles <codeph>for...in</codeph> et <codeph>for each..in</codeph> dans l’objet pour extraire les valeurs requises.
	 
	 <p>Exemple (code extrait de <codeph>Proxy.nextNameIndex()</codeph>) :</p>
     <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
     </codeblock>   
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextNameIndex()"><linktext>Proxy.nextNameIndex()</linktext></link><link href="flash.utils.xml#Proxy/nextName()"><linktext>Proxy.nextName()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:setProperty"><apiName>setProperty</apiName><shortdesc>
	 Bloque un appel de modification de la valeur d’une propriété.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Nom de la propriété à modifier.
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Valeur à affecter à la propriété.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Bloque un appel de modification de la valeur d’une propriété. Si la propriété est introuvable, cette méthode crée une propriété avec le nom et la valeur spécifiés. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../statements.html#set"><linktext>Instruction set</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Spécification ECMA-262, édition 3, section 8.6.2.2.</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.utils:ByteArray"><apiName>ByteArray</apiName><shortdesc>
 La classe ByteArray comporte des méthodes et des propriétés permettant d’optimiser la lecture, l’écriture et la manipulation des données binaires.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe ByteArray comporte des méthodes et des propriétés permettant d’optimiser la lecture, l’écriture et la manipulation des données binaires.
 
 <p><i>Remarque :</i> la classe ByteArray s’adresse aux développeurs chevronnés qui doivent accéder aux données au niveau des octets.</p>
 
 <p>Les données en mémoire correspondent à un tableau contracté (la représentation la plus compacte du type de données) d’octets, mais une occurrence de la classe ByteArray peut être manipulée avec les opérateurs <codeph>[]</codeph> (accès au tableau). Ces données peuvent également être lues et écrites sous forme de fichier en mémoire, en utilisant des méthodes similaires à celles des classes URLStream et Socket.</p>
 
 <p>En outre, la technologie zlib de compression/décompression est prise en charge, de même que la sérialisation d’objet AMF (Action Message Format).</p>
 
 <p>Exemples d’utilisation de la classe ByteArray :
 
 <ul>
 
  <li>Création d’un protocole personnalisé pour établir une connexion à un serveur</li>
 
  <li>Ecriture de votre propre URLEncoder/URLDecoder</li>
 
  <li platform="actionscript">Ecriture de votre propre paquet AMF/Remoting</li>
 
  <li>Optimisation de la taille de vos données à l’aide de types de données</li>
 
 	 <li>Utilisation des données binaires chargées à partir d’un fichier dans Adobe<sup>®</sup> AIR<sup>®</sup>.</li>
 
 </ul>
 </p>
 
 </apiDesc><example conref="examples\ByteArrayExample.as"> L’exemple suivant utilise la classe <codeph>ByteArrayExample</codeph> pour écrire une valeur booléenne et la représentation à virgule flottante à deux décimales de pi dans un tableau d’octets. Cette opération se déroule selon la procédure suivante :
 <ol>
     <li>Déclarez une nouvelle occurrence de l’objet <codeph>byteArr</codeph>.</li>
     <li>Ecrivez la valeur équivalente en octets de la valeur booléenne <codeph>false</codeph>, puis vérifiez la longueur et relisez-la.</li>
     <li>Ecrivez la valeur à virgule flottante à double décimale de la valeur mathématique de pi.</li>
     <li>Relisez chacun des neuf octets écrits dans le tableau d’octets.</li>
 </ol>
 
 <p><b>Remarque : </b> lorsque la méthode <codeph>trace()</codeph> est appelée sur un octet, elle imprime l’équivalent décimal des octets stockés dans le tableau d’octets.</p>
 
 <p>Vous remarquerez qu’un segment de code est ajouté à la fin pour vérifier les erreurs de fin de fichier et s’assurer que la lecture du flux d’octets ne dépasse pas la fin.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class ByteArrayExample extends Sprite {        
        public function ByteArrayExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            trace(byteArr.length);            // 1
            trace(byteArr[0]);            // 0

            byteArr.writeDouble(Math.PI);
            trace(byteArr.length);            // 9
            trace(byteArr[0]);            // 0
            trace(byteArr[1]);            // 64
            trace(byteArr[2]);            // 9
            trace(byteArr[3]);            // 33
            trace(byteArr[4]);            // 251
            trace(byteArr[5]);            // 84
            trace(byteArr[6]);            // 68
            trace(byteArr[7]);            // 45
            trace(byteArr[8]);            // 24
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean() == false); // true
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());        // 3.141592653589793
            }
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);            // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="../../operators.html#array_access"><linktext>[] (accès au tableau)</linktext></link><link href="flash.net.xml#Socket"><linktext>Classe Socket</linktext></link><link href="flash.net.xml#URLStream"><linktext>Classe URLStream</linktext></link></related-links><apiConstructor id="flash.utils:ByteArray:ByteArray"><apiName>ByteArray</apiName><shortdesc>
 Crée une occurrence de ByteArray qui représente un tableau d’octets contracté, afin de vous permettre d’utiliser les méthodes et propriétés de cette classe pour optimiser les flux et le stockage de vos données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 Crée une occurrence de ByteArray qui représente un tableau d’octets contracté, afin de vous permettre d’utiliser les méthodes et propriétés de cette classe pour optimiser les flux et le stockage de vos données.
 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.utils:ByteArray:clear"><apiName>clear</apiName><shortdesc> 
	 Efface le contenu du tableau d’octets et réinitialise les propriétés length et position sur 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 Efface le contenu du tableau d’octets et réinitialise les propriétés <codeph>length</codeph> et <codeph>position</codeph> sur 0. L’appel à cette méthode libère explicitement la mémoire utilisée par l’occurrence de ByteArray.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:compress"><apiName>compress</apiName><shortdesc>
	 Compresse le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.compress, compress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>algorithm</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Algorithme de compression à utiliser lors de la compression. Les valeurs valides sont définies comme constantes dans la classe CompressionAlgorithm. Par défaut, le format zlib est utilisé. <ph platform="actionscript">Ce paramètre n’est reconnu que dans le cas de contenu s’exécutant dans Adobe AIR. Flash Player ne prend en charge que l’algorithme par défaut, zlib, et renvoie une exception si vous tentez de transmettre une valeur pour ce paramètre.</ph> Appeler <codeph> compress(<ph platform="javascript">air.</ph>CompressionAlgorithm.DEFLATE) </codeph> revient à appeler la méthode <codeph>deflate()</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Compresse le tableau d’octets. Tout le tableau d’octets est compressé. Dans le cas de contenu s’exécutant dans Adobe AIR, vous pouvez spécifier un algorithme de compression en transmettant une valeur (définie dans la classe CompressionAlgorithm) en tant que paramètre <codeph>algorithm</codeph>. <ph platform="actionscript">Flash Player prend uniquement en charge l’algorithme par défaut, zlib.</ph>
	 
	 <p>Après l’appel, la propriété <codeph>length</codeph> de l’objet ByteArray est définie sur la nouvelle longueur. La propriété <codeph>position</codeph> est définie à la fin du tableau d’octets.</p>
	 
	 <p>Le format de données compressé zlib est décrit à l’adresse <xref href="http://www.ietf.org/rfc/rfc1950.txt" scope="external">http://www.ietf.org/rfc/rfc1950.txt</xref>.</p>
	 
	 <p>L’algorithme de compression deflate est décrit à l’adresse <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>L’algorithme de compression deflate est utilisé dans plusieurs formats de compression, notamment zlib, gzip, certaines implémentations zip, etc. Lorsque vous compressez les données avec l’un de ces formats de compression, les données compressées (par exemple, le fichier .zip) incluent non seulement la version compressée des données originales, mais également les informations de métadonnées. Exemples de types de métadonnées inclus dans divers formats de fichier : nom de fichier, date/heure de modification du fichier, taille du fichier original, commentaires, données du total de contrôle, etc.</p>
	 
	 <p>Par exemple, lorsqu’un objet ByteArray est compressé à l’aide de l’algorithme zlib, l’objet ByteArray résultant est structuré dans un format spécifique. Certains octets contiennent des métadonnées sur les données compressées, alors que d’autres contiennent la version compressée actuelle des données originales de l’objet ByteArray. Comme l’indique la spécification du format de données compressées zlib, ces octets (c’est-à-dire la partie contenant la version compressée des données originales) sont compressées à l’aide de l’algorithme deflate. Par conséquent, ces octets sont identiques au résultat de l’appel de <codeph>compress(<ph outputclass="javascript">air.</ph>CompressionAlgorithm.DEFLATE)</codeph> sur le ByteArray original. Notez toutefois que l’appel de <codeph>compress(<ph outputclass="javascript">air.</ph>CompressionAlgorithm.ZLIB)</codeph> inclut les métadonnées supplémentaires, alors que <codeph>compress(<ph platform="javascript">air.</ph>CompressionAlgorithm.DEFLATE)</codeph> n’inclut que la version compressée des données ByteArray originales et rien de plus.</p>
	 
	 <p>Si vous souhaitez utiliser le format deflate pour compresser les données d’une occurrence de ByteArray dans un format spécifique, tel que gzip ou zip, l’appel de la méthode <codeph>compress(<ph platform="javascript">air.</ph>CompressionAlgorithm.DEFLATE)</codeph> ne suffit pas. Vous devez créer un objet ByteArray structuré en tenant compte de la spécification du format de compression, et notamment des métadonnées appropriées, ainsi que des données compressées obtenues à l’aide du format deflate. De la même façon, pour décoder les données compressées dans un format tel que gzip ou zip, l’appel de la méthode <codeph>uncompress(<ph platform="javascript">air.</ph>CompressionAlgorithm.DEFLATE)</codeph> sur ces données ne suffit pas. Vous devez tout d’abord séparer les métadonnées des données compressées, puis utiliser le format deflate pour décompresser les données compressées.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/uncompress()"><linktext>uncompress()</linktext></link><link href="flash.utils.xml#CompressionAlgorithm"><linktext>flash.utils.CompressionAlgorithm</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:deflate"><apiName>deflate</apiName><shortdesc>
	 Compresse le tableau d’octets à l’aide de l’algorithme de compression deflate.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Compresse le tableau d’octets à l’aide de l’algorithme de compression deflate. Tout le tableau d’octets est compressé.
	 
	 <p>Après l’appel, la propriété <codeph>length</codeph> de l’objet ByteArray est définie sur la nouvelle longueur. La propriété <codeph>position</codeph> est définie à la fin du tableau d’octets.</p>
	 
	 <p>L’algorithme de compression deflate est décrit à l’adresse <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>Si vous souhaitez utiliser le format deflate pour compresser les données d’une occurrence de ByteArray dans un format spécifique, tel que gzip ou zip, l’appel de la méthode <codeph>deflate()</codeph> ne suffit pas. Vous devez créer un objet ByteArray structuré en tenant compte de la spécification du format de compression, et notamment des métadonnées appropriées, ainsi que des données compressées obtenues à l’aide du format deflate. De la même façon, pour décoder les données compressées dans un format tel que gzip ou zip, l’appel de la méthode <codeph>inflate()</codeph> ne suffit pas. Vous devez tout d’abord séparer les métadonnées des données compressées, puis utiliser le format deflate pour décompresser les données compressées.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/inflate()"><linktext>inflate()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:inflate"><apiName>inflate</apiName><shortdesc>
	 Décompresse le tableau d’octets à l’aide de l’algorithme de compression deflate.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.uncompress, uncompress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ces données ne sont pas des données compressés valides, car elles n’ont pas été compressées avec l’algorithme utilisé lors de la compression.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Décompresse le tableau d’octets à l’aide de l’algorithme de compression deflate. Le tableau d’octets doit avoir été compressé à l’aide du même algorithme. 
	 
	 <p>Après l’appel, la propriété <codeph>length</codeph> de l’objet ByteArray est définie sur la nouvelle longueur. La propriété <codeph>position</codeph> est définie sur 0.</p>
	 
	 <p>L’algorithme de compression deflate est décrit à l’adresse <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>Pour décoder les données compressées dans un format qui utilise l’algorithme de compression deflate (données au format gzip ou zip, par exemple), l’appel de la méthode <codeph>inflate()</codeph> pour un objet ByteArray contenant les données de format de compression ne suffit pas. Vous devez tout d’abord séparer les métadonnées faisant partie du format de données compressées des données compressées actuelles. Pour obtenir de plus amples informations, reportez-vous à description de la méthode <codeph>compress()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/deflate()"><linktext>deflate()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	 Lit une valeur booléenne dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readBoolean, readBoolean
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Renvoie <codeph>true</codeph> si l’octet correspond à une valeur autre que zéro, <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit une valeur booléenne dans le flux d’octets. Un seul octet est lu, et la valeur <codeph>true</codeph> est renvoyée s’il n’est pas nul, <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readByte"><apiName>readByte</apiName><shortdesc>
	 Lit un octet signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readByte, readByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier compris entre -128 et 127.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un octet signé dans le flux d’octets.
	 <p>La valeur renvoyée est comprise entre -128 et 127.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readBytes"><apiName>readBytes</apiName><shortdesc>
	 Lit le nombre d’octets de données spécifié par le paramètre length dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readBytes, readBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray dont les données doivent être lues.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décalage (position) en <codeph>octets</codeph> auquel les données lues doivent être écrites.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre d’octets à lire. La valeur 0 (par défaut) provoque la lecture de toutes les données disponibles.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lit le nombre d’octets de données spécifié par le paramètre <codeph>length</codeph> dans le flux d’octets. Les octets sont lus dans l’objet ByteArray spécifié par le paramètre <codeph>bytes</codeph> et sont écrits dans l’objet ByteArray cible en commençant à la position spécifiée par <codeph>offset</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readDouble"><apiName>readDouble</apiName><shortdesc>
	 Lit un nombre à virgule flottante à deux décimales (64 bits), conforme à IEEE 754, dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readDouble, readDouble
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à deux décimales (64 bits).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un nombre à virgule flottante à deux décimales (64 bits), conforme à IEEE 754, dans le flux d’octets.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readFloat"><apiName>readFloat</apiName><shortdesc>
	 Lit un nombre à virgule flottante à une décimale (32 bits), conforme à IEEE 754, dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readFloat, readFloat
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à une décimale (32 bits).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un nombre à virgule flottante à une décimale (32 bits), conforme à IEEE 754, dans le flux d’octets.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readInt"><apiName>readInt</apiName><shortdesc>
	 Lit un entier de 32 bits signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readInt, readInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier signé de 32 bits compris entre -2147483648 et 2147483647.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier de 32 bits signé dans le flux d’octets.
	 
         <p>La valeur renvoyée est comprise entre -2147483648 et 2147483647.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	 Lit une chaîne à plusieurs octets de longueur spécifiée à partir du flux d’octets et à l’aide du jeu de caractères désigné.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readMultiByte, readMultiByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne au format UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire dans le flux d’octets.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne désignant le le jeu de caractères à utiliser pour interpréter les octets. Parmi les chaînes de jeu de caractères possibles figurent <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
     <p><b>Remarque :</b> si la valeur du paramètre <codeph>charSet</codeph> n’est pas reconnue par le système actuel, l’application utilise la page de code par défaut du système comme jeu de caractères. Par exemple, une valeur pour le paramètre <codeph>charSet</codeph>, comme dans <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> qui utilise <codeph>01</codeph> au lieu de <codeph>1</codeph> pourra éventuellement fonctionner sur votre poste de développement, mais pas sur un autre poste. Sur l’autre ordinateur, l’application utilisera la page de code par défaut du système.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lit une chaîne à plusieurs octets de longueur spécifiée à partir du flux d’octets et à l’aide du jeu de caractères désigné.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readObject"><apiName>readObject</apiName><shortdesc>
	 Lit dans le flux d’octets un objet codé au format AMF (Action Message Format) sérialisé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readObject, readObject
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.	 
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet désérialisé.
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Lit dans le flux d’octets un objet codé au format AMF (Action Message Format) sérialisé.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readShort"><apiName>readShort</apiName><shortdesc>
	 Lit un entier de 16 bits signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readShort, readShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier signé de 16 bits compris entre -32768 et 32767.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier de 16 bits signé dans le flux d’octets.
	 
	 <p>La valeur renvoyée est comprise entre -32768 et 32767.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUTF"><apiName>readUTF</apiName><shortdesc>
	 Lit une chaîne UTF-8 dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUTF, readUTF
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne au format UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit une chaîne UTF-8 dans le flux d’octets. La chaîne doit être précédée d’un caractère non signé indiquant la longueur en octets.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataInput/readUTF()"><linktext>flash.utils.IDataInput.readUTF()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	 Lit une séquence d’octets UTF-8 spécifiée par le paramètre length dans le flux d’octets et renvoie une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUTFBytes, readUTFBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne de longueur spécifiée composée d’octets UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier court non signé qui indique la longueur des octets UTF-8.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lit une séquence d’octets UTF-8 spécifiée par le paramètre <codeph>length</codeph> dans le flux d’octets et renvoie une chaîne.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	 Lit un octet non signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedByte, readUnsignedByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier non signé de 32 bits compris entre 0 et 255.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un octet non signé dans le flux d’octets.
	 
	 <p>La valeur renvoyée est comprise entre 0 et 255. </p>	
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	 Lit un entier de 32 bits non signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedInt, readUnsignedInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier non signé de 32 bits compris entre 0 et 4294967295.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier de 32 bits non signé dans le flux d’octets.
	 
	 <p>La valeur renvoyée est comprise entre 0 et 4294967295. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	 Lit un entier de 16 bits non signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedShort, readUnsignedShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Entier non signé de 16 bits compris entre 0 et 65535.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier de 16 bits non signé dans le flux d’octets.
	 
	 <p>La valeur renvoyée est comprise entre 0 et 65535. </p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:toString"><apiName>toString</apiName><shortdesc>
	 Convertit le tableau d’octets en chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Représentation sous forme de chaîne du tableau d’octets.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Convertit le tableau d’octets en chaîne. Si les données du tableau débutent par une marque d’ordre d’octet Unicode, l’application la respecte lors de la conversion en chaîne. Si <codeph>System.useCodePage</codeph> est défini sur <codeph>true</codeph>, l’application traite les données du tableau comme si elles figuraient dans l’actuelle page de codes système lors de la conversion.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:uncompress"><apiName>uncompress</apiName><shortdesc>
	 Décompresse le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.uncompress, uncompress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ces données ne sont pas des données compressés valides, car elles n’ont pas été compressées avec l’algorithme utilisé lors de la compression.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>algorithm</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Algorithme de compression à utiliser lors de la décompression. Il doit s’agir du même algorithme de compression utilisé lors de la compression des données. Les valeurs valides sont définies comme constantes dans la classe CompressionAlgorithm. Par défaut, le format zlib est utilisé. Ce paramètre n’est reconnu que dans le cas de contenu s’exécutant dans Adobe AIR. <ph platform="actionscript">Flash Player ne prend en charge que l’algorithme par défaut, zlib, et renvoie une exception si vous tentez de transmettre une valeur pour ce paramètre.</ph>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Décompresse le tableau d’octets. Dans le cas de contenu s’exécutant dans Adobe AIR, vous pouvez spécifier un algorithme de compression en transmettant une valeur (définie dans la classe CompressionAlgorithm) en tant que paramètre <codeph>algorithm</codeph>. Le tableau d’octets doit avoir été compressé à l’aide du même algorithme. <ph platform="actionscript">Flash Player prend uniquement en charge l’algorithme par défaut, zlib.</ph>
	 
	 <p>Après l’appel, la propriété <codeph>length</codeph> de l’objet ByteArray est définie sur la nouvelle longueur. La propriété <codeph>position</codeph> est définie sur 0.</p>
	 
	 <p>Le format de données compressé zlib est décrit à l’adresse <xref href="http://www.ietf.org/rfc/rfc1950.txt" scope="external">http://www.ietf.org/rfc/rfc1950.txt</xref>.</p>
	 
	 <p>L’algorithme de compression deflate est décrit à l’adresse <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>Pour décoder les données compressées dans un format qui utilise l’algorithme de compression deflate (données au format gzip ou zip, par exemple), l’appel de la méthode <codeph>uncompress(CompressionAlgorithm.DEFLATE)</codeph> pour un objet ByteArray contenant les données de format de compression ne suffit pas. Vous devez tout d’abord séparer les métadonnées faisant partie du format de données compressées des données compressées actuelles. Pour obtenir de plus amples informations, reportez-vous à description de la méthode <codeph>compress()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/compress()"><linktext>compress()</linktext></link><link href="flash.utils.xml#CompressionAlgorithm"><linktext>flash.utils.CompressionAlgorithm</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	 Ecrit une valeur booléenne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeBoolean, writeBoolean
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur booléenne qui détermine l’octet à écrire. Si le paramètre a pour valeur <codeph>true</codeph>, la méthode écrit 1 ; s’il a pour valeur <codeph>false</codeph>, la méthode écrit 0.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une valeur booléenne. Un seul octet est écrit, conformément au paramètre <codeph>value</codeph>, soit 1 si <codeph>true</codeph> ou 0 si <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeByte"><apiName>writeByte</apiName><shortdesc>
	 Ecrit un octet dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeByte, writeByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier de 32 bits. Les 8 bits inférieurs sont écrits dans le flux d’octets.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un octet dans le flux d’octets. 
	 <p>Les 8 bits inférieurs du paramètre sont utilisés. Les 24 bits supérieurs ne sont pas pris en compte. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	 Ecrit une séquence d’octets length extraits du tableau d’octets, des octets, des octets de début du décalage (index à base zéro) spécifié dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeBytes, writeBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet ByteArray.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Index de base zéro indiquant où débuter l’écriture dans le tableau.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier non signé qui indique l’emplacement du début d’écriture dans la mémoire tampon.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une séquence d’octets <codeph>length</codeph> extraits du tableau d’octets <codeph>bytes</codeph>, en démarrant aux octets <codeph>offset</codeph> (index à base zéro) dans le flux d’octets.
	 
	 <p>Si le paramètre <codeph>length</codeph> est omis, la longueur par défaut, 0, est utilisée. La méthode écrit tout le contenu de la mémoire tampon à partir de <codeph>offset</codeph>. Si le paramètre <codeph>offset</codeph> est également omis, toute la mémoire tampon est écrite. </p> <p>Si les paramètres <codeph>offset</codeph> et <codeph>length</codeph> sont hors limites, ils sont réglés sur le début et la fin du tableau (<codeph>bytes</codeph>).</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	 Ecrit un nombre à virgule flottante à deux décimales (64 bits), conforme à IEEE 754, dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeDouble, writeDouble
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à virgule flottante à deux décimales (64 bits).
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un nombre à virgule flottante à deux décimales (64 bits), conforme à IEEE 754, dans le flux d’octets. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	 Ecrit un nombre à virgule flottante à une décimale (32 bits) et conforme à IEEE 754 dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeFloat, writeFloat
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à virgule flottante à une décimale (32 bits).
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un nombre à virgule flottante à une décimale (32 bits) et conforme à IEEE 754 dans le flux d’octets. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeInt"><apiName>writeInt</apiName><shortdesc>
	 Ecrit un entier de 32 bits signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeInt, writeInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier à écrire dans le flux d’octets.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un entier de 32 bits signé dans le flux d’octets.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	 Ecrit une chaîne à plusieurs octets dans le flux d’octets en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeMultiByte, writeMultiByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne indiquant le jeu de caractères à utiliser. Parmi les chaînes de jeu de caractères possibles figurent <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une chaîne à plusieurs octets dans le flux d’octets en utilisant le jeu de caractères spécifié. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeObject"><apiName>writeObject</apiName><shortdesc>
	 Ecrit un objet dans le tableau d’octets au format AMF sérialisé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeObject, writeObject
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Objet à sérialiser.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un objet dans le tableau d’octets au format AMF sérialisé.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:writeShort"><apiName>writeShort</apiName><shortdesc>
	 Ecrit un entier de 16 bits dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeShort, writeShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Entier de 32 bits, dont les 16 bits inférieurs sont écrits dans le flux d’octets.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un entier de 16 bits dans le flux d’octets. Les 16 bits inférieurs du paramètre sont utilisés. Les 16 bits supérieurs ne sont pas pris en compte.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	 Ecrit une chaîne UTF-8 dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUTF, writeUTF
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la longueur est supérieure à 65535.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une chaîne UTF-8 dans le flux d’octets. La longueur de la chaîne UTF-8 exprimée en octets est d’abord écrite sous forme d’entier de 16 bits, suivi des octets représentant les caractères de la chaîne.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	 Ecrit une chaîne UTF-8 dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUTFBytes, writeUTFBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une chaîne UTF-8 dans le flux d’octets. Comme <codeph>writeUTF()</codeph>, mais la méthode <codeph>writeUTFBytes()</codeph> n’insère pas dans la chaîne un préfixe correspondant à un mot de 16 bits.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	 Ecrit un entier de 32 bits non signé dans le flux d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUnsignedInt, writeUnsignedInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Entier non signé à écrire dans le flux d’octets.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un entier de 32 bits non signé dans le flux d’octets.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:ByteArray:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	 Nombre d’octets de données pouvant être lus à partir de la position actuelle dans le tableau d’octets et jusqu’à la fin de ce tableau.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>available, bytes, position 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre d’octets de données pouvant être lus à partir de la position actuelle dans le tableau d’octets et jusqu’à la fin de ce tableau.
	 
	 <p>Utilisez la propriété <codeph>bytesAvailable</codeph> conjointement avec les méthodes de lecture chaque fois que vous accédez à un objet ByteArray pour vous assurer que les données lues sont valides.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:ByteArray:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 Indique l’encodage d’objet par défaut que doit utiliser la classe ByteArray pour une nouvelle occurrence de ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.defaultObjectEncoding, defaultObjectEncoding
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Indique l’encodage d’objet par défaut que doit utiliser la classe ByteArray pour une nouvelle occurrence de ByteArray. Lorsque vous créez une nouvelle occurrence de ByteArray, l’encodage correspondant débute par la valeur de <codeph>defaultObjectEncoding</codeph>. La propriété <codeph>defaultObjectEncoding</codeph> est initialisée à <codeph>ObjectEncoding.AMF3</codeph>.
	 
	 
	 <p>Lorsqu’un objet est écrit ou lu dans des données binaires, la valeur <codeph>objectEncoding</codeph> permet de déterminer le format à utiliser : ActionScript 3.0, ActionScript 2.0 ou ActionScript 1.0. La valeur est une constante extraite de la classe ObjectEncoding.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding class</linktext></link><link href="flash.utils.xml#ByteArray/objectEncoding"><linktext>flash.utils.ByteArray.objectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:endian:get"><apiName>endian</apiName><shortdesc>
	 Modifie ou lit l’ordre des octets des données (Endian.BIG_ENDIAN ou Endian.LITTLE_ENDIAN).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Modifie ou lit l’ordre des octets des données (<codeph>Endian.BIG_ENDIAN</codeph> ou <codeph>Endian.LITTLE_ENDIAN</codeph>).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Classe Endian</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:length:get"><apiName>length</apiName><shortdesc>
	 Longueur de l’objet ByteArray, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Longueur de l’objet ByteArray, en octets.
	 
	 <p>Si la longueur est définie sur une valeur supérieure à la longueur en cours, le côté droit du tableau d’octets est rempli de zéros.</p>
	 
	 <p>Si la longueur est définie sur une valeur inférieure à la longueur en cours, le tableau d’octets est tronqué.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:ByteArray:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 Permet de déterminer le format à utiliser (ActionScript 3.0, ActionScript 2.0 ou ActionScript 1.0) pour l’écriture ou la lecture d’une occurrence de ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.objectEncoding, objectEncoding
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Permet de déterminer le format à utiliser (ActionScript 3.0, ActionScript 2.0 ou ActionScript 1.0) pour l’écriture ou la lecture d’une occurrence de ByteArray. La valeur est une constante extraite de la classe ObjectEncoding.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding class</linktext></link><link href="flash.utils.xml#ByteArray/defaultObjectEncoding"><linktext>flash.utils.ByteArray.defaultObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:position:get"><apiName>position</apiName><shortdesc>
	 Déplace le pointeur de fichier dans l’objet ByteArray ou en renvoie la position actuelle, en octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.getFilePointer, 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Déplace le pointeur de fichier dans l’objet ByteArray ou en renvoie la position actuelle, en octets. Il s’agit de l’endroit où le prochain appel d’une méthode de lecture ou d’écriture démarre l’opération.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IDataOutput"><apiName>IDataOutput</apiName><shortdesc>
L’interface IDataOutput propose plusieurs méthodes d’écriture des données binaires.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
L’interface IDataOutput propose plusieurs méthodes d’écriture des données binaires. Cette interface est l’équivalent E/S de l’interface IDataOutput, qui lit des données binaires. L’interface IDataOutput est implémentée par les classes FileStream, Socket et ByteArray.
<p>Toutes les opérations IDataInput et IDataOutput utilisent l’ordre d’octet « bigEndian » par défaut (où l’octet le plus significatif de la séquence est mémorisé dans l’adresse de stockage de plus bas niveau ou dans la première adresse de stockage) et ne sont pas bloquantes. </p>
<p>L’extension de signe ne joue un rôle que lors de la lecture des données et non lors de leur écriture. Il est donc inutile d’utiliser des méthodes d’écriture distinctes pour faire appel à <codeph>IDataInput.readUnsignedByte()</codeph> et <codeph>IDataInput.readUnsignedShort()</codeph>. En d’autres termes :</p>
<ul>
  <li>Utilisez <codeph>IDataOutput.writeByte()</codeph> avec <codeph>IDataInput.readUnsignedByte()</codeph> et <codeph>IDataInput.readByte()</codeph>.</li>
  <li>Utilisez <codeph>IDataOutput.writeShort()</codeph> avec <codeph>IDataInput.readUnsignedShort()</codeph> et <codeph>IDataInput.readShort()</codeph>.</li>
</ul>

</apiDesc><example conref="examples\DataOutputExample.as"> L’exemple suivant utilise la classe <codeph>DataOutputExample</codeph> pour écrire une valeur booléenne et la représentation à virgule flottante à deux décimales de pi dans un tableau d’octets. Cette opération se déroule selon la procédure suivante :
 <ol>
     <li>Déclarez une nouvelle occurrence de l’objet <codeph>byteArr</codeph>.</li>
     <li>Ecrivez l’équivalant en octets de la valeur booléenne <codeph>false</codeph> et l’équivalent de la valeur mathématique de pi avec deux décimales.</li>
     <li>Relisez la valeur booléenne et le nombre à virgule flottante à deux décimales.</li>
 </ol>
 
 <p>Vous remarquerez qu’un segment de code est ajouté à la fin pour vérifier les erreurs de fin de fichier et s’assurer que la lecture du flux d’octets ne dépasse pas la fin.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class DataOutputExample extends Sprite {        
        public function DataOutputExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            byteArr.writeDouble(Math.PI);
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean()); // false
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
                        
            try {
                trace(byteArr.readDouble());    // 3.141592653589793
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);        // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#IDataInput"><linktext>Interface IDataInput</linktext></link><link href="flash.utils.xml#IDataOutput/endian"><linktext>endian</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>Classe FileStream</linktext></link><link href="flash.net.xml#Socket"><linktext>Classe Socket</linktext></link><link href="flash.net.xml#URLStream"><linktext>Classe URLStream</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>Classe ByteArray</linktext></link></related-links><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	 Ecrit une valeur booléenne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Valeur booléenne qui détermine l’octet à écrire. Si le paramètre a pour valeur <codeph>true</codeph>, 1 est écrit ; s’il a pour valeur <codeph>false</codeph>, 0 est écrit.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une valeur booléenne. Un seul octet est écrit, conformément au paramètre <codeph>value</codeph>, soit 1 si <codeph>true</codeph> ou 0 si <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeByte"><apiName>writeByte</apiName><shortdesc>
	 Ecrit un octet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un octet. Les 8 bits inférieurs du paramètre sont utilisés. Les 24 bits supérieurs ne sont pas pris en compte.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	 Ecrit une séquence d’octets à partir du tableau d’octets ou des octets spécifiés, en partant de l’octet spécifié par l’offset (à l’aide d’un index de base zéro) dont la longueur est indiquée par le paramètre length dans le flux de fichiers ou d’octets, ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Tableau d’octets à écrire.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Index de base zéro qui indique où débuter l’écriture dans le tableau.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Entier non signé qui indique l’emplacement du début d’écriture dans la mémoire tampon.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une séquence d’octets à partir du tableau d’octets ou des <codeph>octets</codeph> spécifiés, en partant de l’octet spécifié par l’<codeph>offset</codeph> (à l’aide d’un index de base zéro) dont la longueur est indiquée par le paramètre <codeph>length</codeph> dans le flux de fichiers ou d’octets, ou le tableau d’octets.
	 
	 <p>Si le paramètre <codeph>length</codeph> est omis, la longueur par défaut est utilisée (à savoir 0) et tout le contenu de la mémoire tampon à partir de <codeph>offset</codeph> est écrit. Si le paramètre <codeph>offset</codeph> est également omis, toute la mémoire tampon est écrite. </p>
	 
	 <p>Si les paramètres <codeph>offset</codeph> ou <codeph>length</codeph> ne sont pas compris dans la plage supportée, ils sont réglés sur le début et la fin du tableau d’octets (<codeph>bytes</codeph>).</p>
 	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	 Ecrit un nombre à virgule flottante à deux décimales (64 bits) et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à virgule flottante à deux décimales (64 bits).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un nombre à virgule flottante à deux décimales (64 bits) et conforme à IEEE 754.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	 Ecrit un nombre à virgule flottante à une décimale (32 bits) et conforme à IEEE 754.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Nombre à virgule flottante à une décimale (32 bits).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un nombre à virgule flottante à une décimale (32 bits) et conforme à IEEE 754.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeInt"><apiName>writeInt</apiName><shortdesc>
	 Ecrit un entier signé de 32 bits.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier signé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un entier signé de 32 bits.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	 Ecrit une chaîne multi-octets dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>IDataOutput, IDataOutput.writeMultiByte, writeMultiByte
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne indiquant le jeu de caractères à utiliser. Parmi les chaînes de jeu de caractères possibles figurent <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une chaîne multi-octets dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeObject"><apiName>writeObject</apiName><shortdesc>
	 Ecrit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Objet à sérialiser.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataOutput/objectEncoding"><linktext>objectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeShort"><apiName>writeShort</apiName><shortdesc>
	 Ecrit un entier de 16 bits.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un entier de 16 bits. Les 16 bits inférieurs du paramètre sont utilisés. Les 16 bits supérieurs ne sont pas pris en compte.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	 Ecrit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Si la longueur est supérieure à 65535.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets. La longueur de la chaîne UTF-8 exprimée en octets est d’abord écrite sous forme d’entier de 16 bits, suivi des octets représentant les caractères de la chaîne.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	 Ecrit une chaîne UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Valeur de la chaîne à écrire.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit une chaîne UTF-8. Comme <codeph>writeUTF()</codeph>, mais n’insère pas dans la chaîne un préfixe correspondant à un mot de 16 bits.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	 Ecrit un entier non signé de 32 bits.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Valeur d’octet exprimée comme un entier non signé.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ecrit un entier non signé de 32 bits.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:IDataOutput:flash.utils:IDataOutput:endian:get"><apiName>endian</apiName><shortdesc>
	 Ordre d’octet des données, à savoir la constante BIG_ENDIAN ou LITTLE_ENDIAN de la classe Endian.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Ordre d’octet des données, à savoir la constante <codeph>BIG_ENDIAN</codeph> ou <codeph>LITTLE_ENDIAN</codeph> de la classe Endian.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Classe Endian</linktext></link></related-links></apiValue><apiValue id="flash.utils:IDataOutput:flash.utils:IDataOutput:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Permet de déterminer si le format AMF3 ou AMF0 est utilisé lors de l’écriture ou la lecture des données binaires à l’aide de la méthode writeObject().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Permet de déterminer si le format AMF3 ou AMF0 est utilisé lors de l’écriture ou la lecture des données binaires à l’aide de la méthode <codeph>writeObject()</codeph>. La valeur est une constante extraite de la classe ObjectEncoding.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#IDataInput/readObject()"><linktext>IDataInput.readObject()</linktext></link><link href="flash.utils.xml#IDataOutput/writeObject()"><linktext>writeObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding class</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.utils:Endian"><apiName>Endian</apiName><shortdesc>
 La classe Endian contient des valeurs qui dénotent l’ordre des octets qui est utilisé pour représenter les nombres à plusieurs octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Endian contient des valeurs qui dénotent l’ordre des octets qui est utilisé pour représenter les nombres à plusieurs octets. L’ordre d’octet correspond soit à bigEndian (octet le plus significatif en première position), soit à littleEndian (octet le moins significatif en première position).
 
 <p>Le contenu <ph platform="actionscript">de Flash Player ou </ph>d’Adobe<sup>®</sup> AIR™ peut interagir avec un serveur en utilisant directement le protocole binaire de ce dernier. Certains serveurs utilisent l’ordre d’octet bigEndian, tandis que d’autres font appel à littleEndian. Sur Internet, la plupart des serveurs utilisent l’ordre d’octet bigEndian, car « ordre d’octet du réseau » correspond à bigEndian. L’ordre d’octet littleEndian est le plus populaire car il est utilisé par l’architecture Intel x86. Utilisez l’ordre d’octet correspondant au protocole du serveur qui envoie ou reçoit les données.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.utils.xml#ByteArray/endian"><linktext>flash.utils.ByteArray.endian</linktext></link><link href="flash.filesystem.xml#FileStream/endian"><linktext>flash.filesystem.FileStream.endian</linktext></link><link href="flash.utils.xml#IDataInput/endian"><linktext>flash.utils.IDataInput.endian</linktext></link><link href="flash.utils.xml#IDataOutput/endian"><linktext>flash.utils.IDataOutput.endian</linktext></link><link href="flash.net.xml#Socket/endian"><linktext>flash.net.Socket.endian</linktext></link><link href="flash.net.xml#URLStream/endian"><linktext>flash.net.URLStream.endian</linktext></link></related-links><apiValue id="flash.utils:Endian:BIG_ENDIAN"><apiName>BIG_ENDIAN</apiName><shortdesc>
	 Indique que l’octet le plus significatif du nombre à plusieurs octets apparaît en première position dans la séquence d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bigEndian</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’octet le plus significatif du nombre à plusieurs octets apparaît en première position dans la séquence d’octets.
	 <p>Le nombre hexadécimal 0x12345678 contient 4 octets (2 chiffres hexadécimaux par octet). L’octet le plus significatif correspond à 0x12. L’octet le moins significatif correspond à 0x78. (Pour le nombre décimal équivalent, 305419896, le chiffre le plus significatif est 3, tandis que le moins significatif est 6).</p>
	 <p>Un flux qui utilise l’ordre bigEndian (octet le plus significatif en première position) écrit :</p>
	 <pre>
	 12 34 56 78
	 </pre>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Endian:LITTLE_ENDIAN"><apiName>LITTLE_ENDIAN</apiName><shortdesc>
	 Indique que l’octet le moins significatif du nombre à plusieurs octets apparaît en première position dans la séquence d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>littleEndian</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Indique que l’octet le moins significatif du nombre à plusieurs octets apparaît en première position dans la séquence d’octets.
	 <p>Le nombre hexadécimal 0x12345678 contient 4 octets (2 chiffres hexadécimaux par octet). L’octet le plus significatif correspond à 0x12. L’octet le moins significatif correspond à 0x78. (Pour le nombre décimal équivalent, 305419896, le chiffre le plus significatif est 3, tandis que le moins significatif est 6).</p>
	 <p>Un flux qui utilise l’ordre littleEndian (octet le moins significatif en première position) écrit :</p>
	 <pre>
	 78 56 34 12
	 </pre>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IExternalizable"><apiName>IExternalizable</apiName><shortdesc>
 L’interface IExternalizable permet de contrôler la sérialisation d’une classe lorsqu’elle est codée dans un flux de données.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
 L’interface IExternalizable permet de contrôler la sérialisation d’une classe lorsqu’elle est codée dans un flux de données. Les méthodes <codeph>writeExternal()</codeph> et <codeph>readExternal()</codeph> de l’interface IExternalizable sont implémentées par une classe pour permettre la personnalisation du contenu et du format du flux de données (mais non le nom de classe ou le type) pour un objet et ses super-types. Chaque classe individuelle doit sérialiser et reconstruire l’état de ses occurrences. Ces méthodes doivent être symétriques au super-type pour enregistrer son état. Elles remplacent le comportement de sérialisation AMF (Action Message Format) natif. 
 <p>Si une classe n’implémente pas l’interface IExternalizable et qu’elle n’hérite pas d’une classe qui implémente elle-même l’interface, une occurrence de la classe est sérialisée par le biais du mécanisme par défaut réservé aux membres publics. De ce fait, les membres privés, internes et protégés d’une classe ne seront pas disponibles.</p>
 <p>Pour sérialiser les membres privés, une classe doit utiliser l’interface IExternalizable. Par exemple, la classe suivante ne sérialisera aucun de ses membres, parce qu’ils sont privés :</p>
 <codeblock>
 class Example {
 
       private var one:int;
       private var two:int;
 }
 </codeblock>
 <p>Cependant, si vous implémentez l’interface IExternalizable, vous pouvez lire et écrire dans le flux de données les membres privés de la classe, comme suit :</p>
 <codeblock>
 class Example implement IExternalizable {
 
       private var one:int;
       private var two:int;
 
       public function writeExternal(output:IDataOutput) {
 
            output.writeInt(one);
            output.writeInt(two);
       }
 
       public function readExternal(input:IDataInput) {
 
            one = input.readInt();
            two = input.readInt();
       }
 }
 </codeblock>
 <p><b>Remarque :</b> si une classe implémente Externalizable, la sérialisation par défaut ne s’applique plus à ses occurrences. Si cette classe hérite des membres publics d’une super-classe, vous devez également les gérer avec soin.</p>
 <p>Lorsqu’une sous-classe de la classe qui implémente IExternalizable possède des membres privés qui lui sont propres, elle doit remplacer les méthodes de IExternalizable, comme suit :</p>
 <codeblock>
 public class Base implements IExternalizable {
  
      private var one:Boolean;
  
      public function writeExternal(output:IDataOutput):void {
  
          output.writeBoolean(one);
      }
  
      public function readExternal(input:IDataInput):void {
  
          one = input.readBoolean();
      }
 }
  
 public class Example extends Base {
  
      private var one:String;
  
  
      public override function writeExternal(output:IDataOutput):void {
  
          super.writeExternal(output);
          output.writeUTF(one);
      }
  
      public override function readExternal(input:IDataInput):void {
      
          super.readExternal(input);
          one = input.readUTF();
      }
 }
 </codeblock>
 <p>L’interface IExternalizable permet également de compresser les données avant de les écrire dans un flux de données. Exemple :</p>
 <codeblock>
 class Example implements IExternalizable {
  
      public var one:Boolean;
      public var two:Boolean;
      public var three:Boolean;
      public var four:Boolean;
      public var five:Boolean;
      public var six:Boolean;
      public var seven:Boolean;
      public var eight:Boolean;
 
      public function writeExternal(output:IDataOutput) {
 
          var flag:int = 0;
 
          if (one) flag |= 1;
          if (two) flag |= 2;
          if (three) flag |= 4;
          if (four) flag |= 8;
          if (five) flag |= 16;
          if (six) flag |= 32;
          if (seven) flag |= 64;
          if (eight) flag |= 128;
 
          output.writeByte(flag);
      }
 
      public function readExternal(input:IDataInput) {
 
          var flag:int = input.readByte();
 
          one = (flag &amp; 1) != 0;
          two = (flag &amp; 2) != 0;
          three = (flag &amp; 4) != 0;
          four = (flag &amp; 8) != 0;
          five = (flag &amp; 16) != 0;
          six = (flag &amp; 32) != 0;
          seven = (flag &amp; 64) != 0;
          eight = (flag &amp; 128) != 0;
      }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links><apiOperation id="flash.utils:IExternalizable:flash.utils:IExternalizable:readExternal"><apiName>readExternal</apiName><shortdesc>
	 Une classe implémente cette méthode pour s’auto-décoder depuis un flux de données en appelant les méthodes de l’interface IDataInput.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>input</apiItemName><apiOperationClassifier>flash.utils:IDataInput</apiOperationClassifier><apiDesc>Nom de la classe qui implémente l’interface IDataInput.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Une classe implémente cette méthode pour s’auto-décoder depuis un flux de données en appelant les méthodes de l’interface IDataInput. Cette méthode doit lire les valeurs dans le même ordre et avec les mêmes types que ceux qui ont servi à l’écriture par la méthode <codeph>writeExternal()</codeph> pour l’écriture.
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IExternalizable:flash.utils:IExternalizable:writeExternal"><apiName>writeExternal</apiName><shortdesc>
	 Une classe implémente cette méthode pour s’auto-coder dans un flux de données en appelant les méthodes de l’interface IDataOutput.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.utils:IDataOutput</apiOperationClassifier><apiDesc>Nom de la classe qui implémente l’interface IDataOutput.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Une classe implémente cette méthode pour s’auto-coder dans un flux de données en appelant les méthodes de l’interface IDataOutput.
     </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiOperation id="globalOperation:flash.utils:describeType"><apiName>describeType</apiName><shortdesc>
	 Produit un objet XML qui décrit l’objet ActionScript identifié en tant que paramètre de la méthode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Objet XML contenant des renseignements sur l’objet transmis sous forme de paramètre, à savoir :
	 
	 <ul>
	  <li>la classe de l’objet ;</li> 
	 	 <li>les attributs de la classe ;</li> 
	 	 <li>l’arborescence de l’héritage transmis par la classe à ses classes de base ;</li> 
	 	 <li>les interfaces implémentées par la classe ;</li> 
	 	 <li>les propriétés d’occurrence déclarées de la classe ;</li> 
	 	 <li>les propriétés statiques déclarées de la classe ;</li> 
	 	 <li>les méthodes d’occurrence de la classe ;</li>
	 	 <li>les méthodes statiques de la classe ; </li>
	 	 <li>pour chaque méthode de la classe, son nom, le nombre de paramètres, le type de renvoi et les types de paramètres. </li>
	 </ul>
     <p><b>Remarque :</b> <codeph>describeType()</codeph> n’indique que les propriétés et les méthodes publiques, et exclut les propriétés et les méthodes privées, internes au package ou figurant dans des espaces de nom personnalisés. </p>
	 
 	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Objet pour lequel une description de type est requise. Toute valeur ActionScript peut être transmise à cette méthode, y compris tous les types, occurrences d’objet, types de primitives (tels que uint) et objets de classe ActionScript disponibles.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Produit un objet XML qui décrit l’objet ActionScript identifié en tant que paramètre de la méthode. Cette méthode implémente le concept de programmation <i>par réflexion</i> pour le langage ActionScript.
	 <p>Si le paramètre <codeph>value</codeph> est l’occurrence d’un type, l’objet XML renvoyé comprend toutes les propriétés d’occurrence de ce type, mais n’inclut aucune propriété statique. Pour vérifier cette condition lors de l’analyse de l’objet XML, examinez la valeur de l’attribut <codeph>isStatic</codeph> de la balise <codeph>&lt;type></codeph>, qui est réglée sur <codeph>false</codeph> lorsque le paramètre <codeph>value</codeph> est l’occurrence d’un type.</p>
	 <p>Pour obtenir les propriétés statiques d’un type, transmettez le type en tant que tel pour le paramètre <codeph>value</codeph>. L’objet XML renvoyé comprend non seulement les propriétés statiques du type, mais aussi toutes les propriétés de son occurrence. Pour les distinguer des propriétés statiques, les propriétés de l’occurrence sont imbriquées dans la balise <codeph>&lt;factory></codeph>. Dans ce cas, l’attribut <codeph>isStatic</codeph> de la balise <codeph>&lt;type></codeph> a la valeur <codeph>true</codeph>.</p>
	 <p><b>Remarque :</b> s’il vous suffit de parcourir la hiérarchie d’héritage d’un objet sans avoir besoin d’accéder aux autres informations fournies par <codeph>describeType()</codeph>, utilisez plutôt les fonctions <codeph>getQualifiedClassName()</codeph> et <codeph>getQualifiedSuperclassName()</codeph>.</p>
	 <p>Le tableau ci-dessous décrit certains attributs et certaines balises de l’objet XML généré par <codeph>describeType()</codeph> (tous les noms de classe et d’interface renvoyés sont au format complet) :</p>
	 <adobetable class="innertable">
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	 <tgroup cols="3"><thead><row><entry>Balise</entry><entry>Attribut</entry><entry>Description</entry></row></thead><tbody><row><entry><codeph>&lt;type></codeph></entry><entry> </entry><entry>Balise racine de l’objet XML.</entry></row><row><entry> </entry><entry>nom</entry><entry>Nom du type de données de l’objet ActionScript.</entry></row><row><entry> </entry><entry>base</entry><entry>Super-classe immédiate de la classe de définition de l’objet ActionScript. Si l’objet ActionScript est un objet de classe, la valeur est <codeph>Class</codeph>.</entry></row><row><entry> </entry><entry>isDynamic</entry><entry><codeph>true</codeph> si la classe de définition de l’objet ActionScript est dynamique ; <codeph>false</codeph> dans le cas contraire. Si l’objet ActionScript est un objet de classe, la valeur est <codeph>true</codeph>, car la classe Class est dynamique.</entry></row><row><entry> </entry><entry>isFinal</entry><entry><codeph>true</codeph> si la classe de définition de l’objet ActionScript est spécifiée en dernière position ; <codeph>false</codeph> dans le cas contraire.</entry></row><row><entry> </entry><entry>isStatic</entry><entry><codeph>true</codeph> si l’objet ActionScript est un objet de classe ou une fonction constructeur ; <codeph>false</codeph> dans le cas contraire. Cet attribut s’appelle <codeph>isStatic</codeph> car, s’il est réglé sur <codeph>true</codeph>, toute balise non imbriquée dans la balise <codeph>factory</codeph> est statique.</entry></row><row><entry><codeph>&lt;extendsClass></codeph></entry><entry> </entry><entry>Balise <codeph>extendsClass</codeph> distincte, associée à chaque super-classe de la classe de définition de l’objet ActionScript.</entry></row><row><entry> </entry><entry>type</entry><entry>Nom d’une super-classe développée par la classe de définition de l’objet ActionScript.</entry></row><row><entry><codeph>&lt;implementsInterface></codeph></entry><entry> </entry><entry>A chaque interface implémentée par la classe de définition ou toute super-classe de l’objet ActionScript correspond une balise <codeph>implementsInterface</codeph> distincte.</entry></row><row><entry> </entry><entry>type</entry><entry>Nom d’une interface implémentée par la classe de définition de l’objet ActionScript.</entry></row><row><entry><codeph>&lt;accessor></codeph></entry><entry> </entry><entry>Un accesseur est une propriété définie par les fonctions getter et setter.</entry></row><row><entry> </entry><entry>nom</entry><entry>Nom de l’accesseur.</entry></row><row><entry> </entry><entry>access</entry><entry>Droits d’accès de la propriété. Parmi les valeurs supportées figurent <codeph>readonly</codeph>, <codeph>writeonly</codeph> et <codeph>readwrite</codeph>.</entry></row><row><entry> </entry><entry>type</entry><entry>Type de données de la propriété.</entry></row><row><entry> </entry><entry>declaredBy</entry><entry>Classe qui contient les fonctions getter ou setter connexes.</entry></row><row><entry><codeph>&lt;constant></codeph></entry><entry> </entry><entry>Une constante est une propriété définie par l’instruction <codeph>const</codeph>.</entry></row><row><entry> </entry><entry>nom</entry><entry>Nom de la constante.</entry></row><row><entry> </entry><entry>type</entry><entry>Type de données de la constante.</entry></row><row><entry><codeph>&lt;méthode></codeph></entry><entry> </entry><entry>Une méthode est une fonction déclarée dans le cadre d’une définition de classe.</entry></row><row><entry> </entry><entry>nom</entry><entry>Nom de la méthode.</entry></row><row><entry> </entry><entry>declaredBy</entry><entry>Classe qui contient la définition de la méthode.</entry></row><row><entry> </entry><entry>returnType</entry><entry>Type de données de la valeur renvoyée par la méthode.</entry></row><row><entry><codeph>&lt;parameter></codeph></entry><entry> </entry><entry>A chaque paramètre défini par une méthode correspond une balise <codeph>parameter</codeph> distincte. Cette balise est systématiquement imbriquée dans une balise <codeph>&lt;method></codeph>.</entry></row><row><entry> </entry><entry>index</entry><entry>Nombre correspondant à l’ordre d’apparition du paramètre dans la liste des paramètres de la méthode. Le premier paramètre a la valeur 1.</entry></row><row><entry> </entry><entry>type</entry><entry>Type de données du paramètre.</entry></row><row><entry> </entry><entry>optional</entry><entry><codeph>true</codeph> si le paramètre est facultatif ; <codeph>false</codeph> dans le cas contraire.</entry></row><row><entry><codeph>&lt;variable></codeph></entry><entry> </entry><entry>Une variable est une propriété définie par l’instruction <codeph>var</codeph>.</entry></row><row><entry> </entry><entry>nom</entry><entry>Nom de la variable.</entry></row><row><entry> </entry><entry>type</entry><entry>Type de données de la variable.</entry></row><row><entry><codeph>&lt;factory></codeph></entry><entry> </entry><entry>Si l’objet ActionScript est un objet de classe ou une fonction constructeur, toutes les propriétés et méthodes de ses occurrences sont imbriquées dans cette balise. Si l’attribut <codeph>isStatic</codeph> de la balise <codeph>&lt;type></codeph> est réglé sur <codeph>true</codeph>, toutes les propriétés et méthodes qui ne sont pas imbriquées dans la balise <codeph>&lt;factory></codeph> sont statiques. Cette balise n’apparaît que si l’objet ActionScript est un objet de classe ou une fonction constructeur.</entry></row></tbody></tgroup></adobetable>
	 
	 
	 </apiDesc><example conref="examples\DescribeTypeExample.as"><codeblock>package {
    import flash.display.Sprite;
    import flash.utils.describeType;
    
    public class DescribeTypeExample extends Sprite {
        public function DescribeTypeExample() {
            var child:Sprite = new Sprite();
            var description:XML = describeType(child);
            trace(description..accessor.@name.toXMLString());
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/getQualifiedClassName()"><linktext>getQualifiedClassName()</linktext></link><link href="flash.utils.xml#/getQualifiedSuperclassName()"><linktext>getQualifiedSuperclassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:escapeMultiByte"><apiName>escapeMultiByte</apiName><shortdesc>
	  Renvoie une copie contenant une séquence d’échappement de la chaîne entrée, codée au format UTF-8 ou page de codes système, selon la valeur de System.useCodePage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Copie contenant une séquence d’échappement de la chaîne entrée. Si System.useCodePage est réglé sur <codeph>true</codeph>, la chaîne contenant une séquence d’échappement est codée au format page de codes système. Si System.useCodePage est réglé sur <codeph>false</codeph>, la chaîne contenant une séquence d’échappement est codée au format UTF-8. Par exemple, la chaîne saisie « CrÃ¼e » est convertie en « Cr%C3%BCe » dans tous les systèmes si System.useCodePage est réglé sur <codeph>false</codeph>. Si system.useCodePage est réglé sur <codeph>true</codeph> et que le système utilise une page de codes latine, la chaîne « CrÃ¼e » sera convertie en « Cr%FCe ». Si le système utilise une page de codes non latine qui ne contient pas la lettre « Ã¼ », le résultat correspondra probablement à « Cr?e ».
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne qui doit subir le processus de conversion escape.
	  
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Renvoie une copie contenant une séquence d’échappement de la chaîne entrée, codée au format UTF-8 ou page de codes système, selon la valeur de System.useCodePage. L’utilisation de System.useCodePage permet à Flash Player d’accéder au contenu hérité codé dans les pages de codes locales, mais uniquement sur les systèmes qui utilisent la page de codes héritée. Par exemple, des données en japonais codées au format <codeph>Shift-JIS</codeph> ne subiront le processus de conversion escape/unescape que dans un système d’exploitation qui utilise une page de codes japonais par défaut.
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:getDefinitionByName"><apiName>getDefinitionByName</apiName><shortdesc>
	 Renvoie une référence à l’objet de la classe spécifiée par le paramètre name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Aucune définition publique n’existe sous le nom spécifié.
	 
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Renvoie une référence à l’objet de la classe spécifiée par le paramètre <codeph>name</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Nom d’une classe.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Renvoie une référence à l’objet de la classe spécifiée par le paramètre <codeph>name</codeph>.
	 </apiDesc><example conref="examples\GetDefinitionByNameExample.as"> L’exemple suivant utilise la classe <codeph>GetDefinitionByNameExample</codeph> pour créer un carré orange sur la scène. Cette opération se déroule selon la procédure suivante :
 <ol>
     <li>Des variables sont déclarées pour une couleur d’arrière-plan orange et une taille de 80 pixels, et seront ensuite utilisées pour tracer le carré.</li>
     <li>A l’intérieur du constructeur, une variable <codeph>ClassReference</codeph> de type Class est affectée au Sprite.</li>
     <li>Une occurrence de ClassReference appelée <codeph>occurrence</codeph> est instanciée.</li>
     <li><codeph>occurrence</codeph> étant, par référence, un objet Sprite, il est possible de dessiner un carré et de l’ajouter à la liste d’affichage à l’aide des méthodes disponibles pour Sprite.</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.utils.getDefinitionByName;

    public class GetDefinitionByNameExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 80;

        public function GetDefinitionByNameExample() {
            var ClassReference:Class = getDefinitionByName("flash.display.Sprite") as Class;
            var instance:Object = new ClassReference();
            instance.graphics.beginFill(bgColor);
            instance.graphics.drawRect(0, 0, size, size);
            instance.graphics.endFill();
            addChild(DisplayObject(instance));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:getQualifiedClassName"><apiName>getQualifiedClassName</apiName><shortdesc>
	  Renvoie le nom de classe complet d’un objet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Chaîne contenant le nom de classe complet.
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Objet pour lequel un nom de classe complet est requis. Toute valeur ActionScript peut être transmise à cette méthode, y compris tous les types, occurrences d’objet, types de primitives (tels que uint) et objets de classe ActionScript disponibles.
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Renvoie le nom de classe complet d’un objet.
	  
	  </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#/describeType()"><linktext>describeType()</linktext></link><link href="flash.utils.xml#/getQualifiedSuperclassName()"><linktext>getQualifiedSuperclassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:getQualifiedSuperclassName"><apiName>getQualifiedSuperclassName</apiName><shortdesc>
	Renvoie le nom complet de la classe de base de l’objet spécifié par le paramètre value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nom complet de classe de base ou <codeph>null</codeph> si aucune classe n’est définie.
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>N’importe quelle valeur.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Renvoie le nom complet de la classe de base de l’objet spécifié par le paramètre <codeph>value</codeph>. Cette fonction permet d’extraire plus rapidement le nom de la classe de base que <codeph>describeType()</codeph>, mais ne fournit pas autant d’informations que <codeph>describeType()</codeph>.
	<p>Après avoir récupéré le nom d’une classe avec cette fonction, vous pouvez le convertir en référence de classe à l’aide de la fonction <codeph>getDefinitionByName()</codeph>.</p>
	<p><b>Remarque :</b> cette fonction se limite elle-même aux hiérarchies d’occurrences, alors que la fonction <codeph>describeType()</codeph> utilise les hiérarchies d’objets de classe si le paramètre <codeph>value</codeph> est un type de données. L’appel de <codeph>describeType()</codeph> sur un type de données renvoie la super-classe basée sur la hiérarchie d’objets de classe, dans laquelle tous les objets de classe héritent de Class. Cependant, la fonction <codeph>getQualifiedSuperclassName()</codeph> ne tient pas compte de la hiérarchie d’objets de classe et renvoie la super-classe en fonction de la hiérarchie d’occurrences, plus familière. Ainsi, un appel de <codeph>getQualifiedSuperclassName(String)</codeph> renvoie <codeph>Object</codeph> bien que, théoriquement, l’objet de classe String hérite de Class. En d’autres termes, les résultats sont identiques, que vous utilisiez l’occurrence d’un type ou le type lui-même.</p>
	</apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#/describeType()"><linktext>describeType()</linktext></link><link href="flash.utils.xml#/getDefinitionByName()"><linktext>getDefinitionByName()</linktext></link><link href="flash.utils.xml#/getQualifiedClassName()"><linktext>getQualifiedClassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:getTimer"><apiName>getTimer</apiName><shortdesc>
	 Permet de calculer le temps relatif.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Nombre de millisecondes écoulées depuis l’initialisation du moteur d’exécution (exécution d’ActionScript 2.0), ou depuis le démarrage de la machine virtuelle (exécution d’ActionScript 3.0). Si le moteur d’exécution commence la lecture d’un fichier SWF et qu’un autre fichier SWF est chargé ultérieurement, la valeur renvoyée désigne le moment du chargement du premier fichier SWF.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Permet de calculer le temps relatif. Pour un moteur d’exécution de Flash qui exécute ActionScript 3.0, cette méthode renvoie le nombre de millisecondes qui se sont écoulées depuis le démarrage de la machine virtuelle du moteur d’exécution de Flash pour ActionScript 3.0. Pour un moteur d’exécution de Flash qui exécute ActionScript 2.0, cette méthode renvoie le nombre de millisecondes qui se sont écoulées depuis le début de l’initialisation du moteur d’exécution de Flash. Le moteur d’exécution de Flash utilise deux machines virtuelles pour exécuter ActionScript. AVM1 désigne la machine virtuelle ActionScript qui exécute ActionScript 1.0 et 2.0. AVM2 désigne la machine virtuelle ActionScript qui exécute ActionScript 3.0. Le comportement de la méthode <codeph>getTimer(),</codeph> pour AVM1 est différent du comportement pour AVM2. 
	 <p>Pour obtenir une date de calendrier (horodatage), voir l’objet Date.</p> 	 
	 
	 </apiDesc><example conref="examples\getTimerExample.as"> L’exemple suivant utilise la classe <codeph>GetTimerExample</codeph> pour récupérer et imprimer le nombre de millisecondes écoulées depuis le début de la lecture de Flash Player.
<codeblock>
package {
    import flash.utils.getTimer;
    import flash.display.Sprite;

    public class GetTimerExample extends Sprite {
        public function GetTimerExample() {
            var duration:uint = getTimer();
            trace("duration: " + duration);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#AVM1Movie"><linktext>flash.display.AVM1Movie</linktext></link><link href="#Date"><linktext>Classe Date</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:unescapeMultiByte"><apiName>unescapeMultiByte</apiName><shortdesc>
	  Renvoie une copie de la chaîne entrée soumise au processus de conversion unescape, décodée du format UTF-8 ou page de codes système, selon la valeur de System.useCodePage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Copie contenant une séquence d’échappement de la chaîne entrée. Si System.useCodePage est réglé sur <codeph>true</codeph>, la chaîne contenant une séquence d’échappement est codée au format page de codes système. Si System.useCodePage est réglé sur <codeph>false</codeph>, la chaîne contenant une séquence d’échappement est codée au format UTF-8. Par exemple, la chaîne saisie « Crüe » est convertie en « Cr%C3%BCe » dans tous les systèmes si System.useCodePage est réglé sur <codeph>false</codeph>.. Si system.useCodePage est réglé sur <codeph>true</codeph> et que le système utilise une page de codes latine, la chaîne « Crüe » sera convertie en « Cr%FCe ». Si le système utilise une page de codes non latine qui ne contient pas la lettre « ü », le résultat correspondra probablement à « Cr?e ». Si la chaîne « Cr%C3%BCe » est soumise au processus de conversion unescape et que System.useCodePage est réglé sur <codeph>true</codeph>, les résultats sont incorrects, mais varient selon les systèmes, par exemple « CrÃ¼e » dans un système latin. De même, si la chaîne « Cr%FCe » est soumise au processus de conversion unescape et que System.useCodePage est réglé sur <codeph>false</codeph>, les résultats pourraient correspondre à « Cre », à « Cr?e » ou autres variantes, selon la page de codes du système.	
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne contenant une séquence d’échappement à convertir.
	  
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Renvoie une copie de la chaîne entrée soumise au processus de conversion unescape, décodée du format UTF-8 ou page de codes système, selon la valeur de System.useCodePage. L’utilisation de System.useCodePage permet à Flash Player d’accéder au contenu hérité codé dans les pages de codes locales, mais uniquement sur les systèmes qui utilisent la page de codes héritée. Par exemple, des données en japonais codées au format <codeph>Shift-JIS</codeph> ne subiront le processus de conversion escape/unescape que dans un système d’exploitation qui utilise une page de codes japonais par défaut.
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:clearInterval"><apiName>clearInterval</apiName><shortdesc>
 Annule un appel setInterval() spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>ID de l’appel de <codeph>setInterval()</codeph>, que vous réglez sur une variable, comme dans l’exemple suivant :
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Annule un appel de <codeph>setInterval()</codeph> spécifié.
 
 </apiDesc><example conref="examples\ClearIntervalExample.as"> L’exemple suivant utilise la méthode <codeph>setInterval()</codeph> pour créer un intervalle de temps, en appelant la méthode <codeph>myRepeatingFunction()</codeph> à intervalle régulier d’une seconde.
 <p>Chaque appel de la méthode <codeph>myRepeatingFunction</codeph> incrémente la propriété <codeph>counter</codeph> et, lorsqu’elle correspond à la propriété <codeph>stopCount</codeph>, la méthode <codeph>clearInterval() </codeph> est appelée avec la propriété <codeph>intervalId</codeph>, identifiant faisant référence à l’intervalle créé précédemment.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class ClearIntervalExample extends Sprite {
        private var intervalDuration:Number = 1000; // duration between intervals, in milliseconds
        private var intervalId:uint;
        private var counter:uint     = 0;
        private var stopCount:uint     = 3;
        
        public function ClearIntervalExample() {
            intervalId = setInterval(myRepeatingFunction, intervalDuration, "Hello", "World");
        }

        public function myRepeatingFunction():void {
            trace(arguments[0] + " " + arguments[1]);

            counter++;
            if(counter == stopCount) {
                trace("Clearing Interval");
                clearInterval(intervalId);    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/setInterval()"><linktext>setInterval()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:clearTimeout"><apiName>clearTimeout</apiName><shortdesc>
 Annule un appel setTimeout() spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>ID de l’appel <codeph>setTimeout()</codeph>, que vous réglez sur une variable, comme dans l’exemple suivant :
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Annule un appel de <codeph>setTimeout()</codeph> spécifié.
 
 </apiDesc><example conref="examples\ClearTimeoutExample.as"> L’exemple suivant utilise la méthode <codeph>setTimeout()</codeph> pour appeler une autre méthode après un délai défini.
 <p>Une boucle est créée pour compter jusqu’à un million. Si l’ordinateur peut traiter cette requête en moins d’une seconde, <codeph>clearTimeout()</codeph> supprime la requête de <codeph>setTimeout()</codeph> et la méthode <codeph>myDelayedFunction()</codeph> n’est pas appelée.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class ClearTimeoutExample extends Sprite {
        private var delay:Number = 1000; // delay before calling myDelayedFunction
        private var intervalId:uint;
        private var count:uint = 1000000;
        
        public function ClearTimeoutExample() {
            intervalId = setTimeout(myDelayedFunction, delay);
            startCounting();
        }

        public function startCounting():void {
            var i:uint = 0;
            do {
                if(i == count-1) {
                    clearTimeout(intervalId);
                    trace("Your computer can count to " + count + " in less than " + delay/1000 + " seconds.");    
                }
                i++;
            } while(i &lt; count)            
        }
        
        public function myDelayedFunction():void {
            trace("Time expired.");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/setTimeout()"><linktext>setTimeout()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:setInterval"><apiName>setInterval</apiName><shortdesc>
 Exécute une fonction à fréquence définie (intervalle exprimé en millisecondes).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Identificateur numérique unique utilisé pour le processus chronométré. Utilisez cet identificateur pour annuler le processus, en appelant la méthode <codeph>clearInterval()</codeph>.
 
 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>closure</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Nom de la fonction à exécuter. N’incluez ni guillemets, ni parenthèses et ne spécifiez pas les paramètres de la fonction à appeler. Par exemple, utilisez <codeph>functionName</codeph>, et non <codeph>functionName()</codeph> ou <codeph>functionName(param)</codeph>.
 
 </apiDesc></apiParam><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Intervalle, exprimé en millisecondes. 
 
 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Liste facultative d’arguments transmis à la fonction de fermeture.
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Exécute une fonction à fréquence définie (intervalle exprimé en millisecondes).
 
 <p>Au lieu d’utiliser la méthode <codeph>setInterval()</codeph>, envisagez de créer un objet Timer associé à l’intervalle spécifié, en utilisant 0 pour le paramètre <codeph>repeatCount</codeph> (qui règle l’horloge sur une répétition perpétuelle).</p>
 
 <p>Si vous souhaitez utiliser la méthode <codeph>clearInterval()</codeph> pour annuler l’appel de <codeph>setInterval()</codeph>, veillez à affecter l’appel de <codeph>setInterval()</codeph> à une variable (à laquelle la méthode <codeph>clearInterval()</codeph> fera ultérieurement référence). Si vous n’appelez pas la fonction <codeph>clearInterval()</codeph> pour annuler l’appel de <codeph>setInterval()</codeph>, l’objet contenant la fonction de fermeture setTimeout spécifiée ne sera pas nettoyé. </p>
 
 </apiDesc><example conref="examples\SetIntervalExample.as"> L’exemple suivant utilise la méthode <codeph>setInterval()</codeph> pour créer un intervalle de temps, en appelant la méthode <codeph>myRepeatingFunction()</codeph> à intervalle régulier d’une seconde.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class SetIntervalExample extends Sprite {
        private var intervalDuration:Number = 1000; // duration between intervals, in milliseconds
        
        public function SetIntervalExample() {
            var intervalId:uint = setInterval(myRepeatingFunction, intervalDuration, "Hello", "World");
        }

        public function myRepeatingFunction():void {
            trace(arguments[0] + " " + arguments[1]);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/clearInterval()"><linktext>clearInterval()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:setTimeout"><apiName>setTimeout</apiName><shortdesc>
 Exécute une fonction spécifiée après un délai défini (exprimé en millisecondes).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Identificateur numérique unique utilisé pour le processus chronométré. Utilisez cet identificateur pour annuler le processus, en appelant la méthode <codeph>clearTimeout()</codeph>.
 
 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>closure</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Nom de la fonction à exécuter. N’incluez ni guillemets, ni parenthèses et ne spécifiez pas les paramètres de la fonction à appeler. Par exemple, utilisez <codeph>functionName</codeph>, et non <codeph>functionName()</codeph> ou <codeph>functionName(param)</codeph>.
 
 </apiDesc></apiParam><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Délai, exprimé en millisecondes, qui précède l’exécution de la fonction. 
 
 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Liste facultative d’arguments transmis à la fonction de fermeture.
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Exécute une fonction spécifiée après un délai défini (exprimé en millisecondes).
 
 <p>Au lieu d’utiliser cette méthode, envisagez de créer un objet Timer associé à l’intervalle spécifié, en utilisant 1 en tant que paramètre <codeph>repeatCount</codeph> (qui règle l’horloge pour qu’elle ne s’exécute qu’une seule fois).</p>
 
 <p>Si vous souhaitez utiliser la méthode <codeph>clearTimeout()</codeph> pour annuler l’appel de <codeph>setTimeout()</codeph>, veillez à affecter l’appel de <codeph>setTimeout()</codeph> à une variable (à laquelle la fonction <codeph>clearTimeout()</codeph> fera ultérieurement référence). Si vous n’appelez pas la fonction <codeph>clearTimeout()</codeph> pour annuler l’appel de <codeph>setTimeout()</codeph>, l’objet contenant la fonction de fermeture setTimeout spécifiée ne sera pas nettoyé. </p>
 
 </apiDesc><example conref="examples\SetTimeoutExample.as"> L’exemple suivant utilise la méthode <codeph>setTimeout()</codeph> pour appeler une autre méthode après un délai défini.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class SetTimeoutExample extends Sprite {
        private var delay:Number = 1000; // delay before calling myDelayedFunction
        
        public function SetTimeoutExample() {
            var intervalId:uint = setTimeout(myDelayedFunction, delay, "Hello", "World");
        }

        public function myDelayedFunction():void {
            trace(arguments[0] + " " + arguments[1]);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/clearTimeout()"><linktext>clearTimeout()</linktext></link></related-links></apiOperation><apiClassifier id="flash.utils:Timer"><apiName>Timer</apiName><shortdesc>
 La classe Timer, qui correspond à l’interface des horloges, vous permet d’exécuter le code sur une chronologie spécifiée.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Timer, qui correspond à l’interface des horloges, vous permet d’exécuter le code sur une chronologie spécifiée. Utilisez la méthode <codeph>start()</codeph> pour démarrer une horloge. Ajoutez un écouteur à l’événement <codeph>timer</codeph> pour définir le code à exécuter à intervalles définis.
 
 <p>Vous pouvez créer des objets Timer pour les exécuter une seule fois ou à intervalles spécifiés, afin d’exécuter du code conformément au planning défini. <ph platform="actionscript">Selon la cadence du fichier SWF ou l’environnement de Flash Player (mémoire disponible et autres facteurs), Flash Player ou Adobe AIR risque de distribuer les événements à intervalles légèrement décalés. Par exemple, si la cadence d’un fichier SWF est de 10 images/seconde (i/s), soit une fréquence de 100 millisecondes, mais que votre horloge est réglée de sorte à déclencher un événement à 80 millisecondes, l’événement sera déclenché à une fréquence proche de 100 millisecondes.</ph> <ph platform="javascript">Selon la cadence interne de l’application, celle-ci risque de distribuer les événements à intervalles légèrement décalés.</ph> Les scripts qui consomment beaucoup de mémoire risquent également de décaler les événements.</p>
 
 </apiDesc><example conref="examples\TimerExample.as"> L’exemple suivant utilise la classe <codeph>TimerExample</codeph> pour montrer comment configurer une méthode d’écouteurs <codeph>timerHandler()</codeph> pour écouter un nouvel événement TimerEvent à diffuser. L’horloge démarre à l’appel de <codeph>start()</codeph> et les événements timer sont distribués à partir de ce moment.  
<codeblock>
package {
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.display.Sprite;

    public class TimerExample extends Sprite {

        public function TimerExample() {
            var myTimer:Timer = new Timer(1000, 2);
            myTimer.addEventListener("timer", timerHandler);
            myTimer.start();
        }

        public function timerHandler(event:TimerEvent):void {
            trace("timerHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.utils:Timer_flash.events.TimerEvent.TIMER_COMPLETE_timerComplete"><apiName>timerComplete</apiName><shortdesc>
 Distribué lorsque le traitement du nombre de requêtes défini par Timer.repeatCount est terminé.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TimerEvent.TIMER_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.TimerEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsque le traitement du nombre de requêtes défini par <codeph>Timer.repeatCount</codeph> est terminé. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.utils:Timer_flash.events.TimerEvent.TIMER_timer"><apiName>timer</apiName><shortdesc>
 Distribué lorsqu’un objet Timer atteint un intervalle spécifié conformément à la propriété Timer.delay.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TimerEvent.TIMER</apiEventType><adobeApiEventClassifier>flash.events.TimerEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Distribué lorsqu’un objet Timer atteint un intervalle spécifié conformément à la propriété <codeph>Timer.delay</codeph>. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.utils:Timer:Timer"><apiName>Timer</apiName><shortdesc>
	 Construit un nouvel objet Timer en tenant compte du délai et du nombre de répétitions spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Si le délai spécifié est négatif ou qu’il ne correspond pas à un nombre fini
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Délai entre les événements Timer, en millisecondes.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeatCount</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Spécifie le nombre de répétitions. S’il correspond à zéro, l’horloge se répète perpétuellement. S’il correspond à une valeur autre que zéro, l’horloge s’exécute le nombre spécifié de fois, puis s’arrête.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Construit un nouvel objet Timer en tenant compte des états <codeph>delay</codeph> et <codeph>repeatCount</codeph> spécifiés.
	 
	 <p>L’horloge ne démarre pas automatiquement. Pour ce faire, vous devez appeler la méthode <codeph>start()</codeph>.</p>
	 
	 </apiDesc><example conref="examples\Timer_constructorExample.as"> Dans l’exemple suivant, l’utilisateur a 90 secondes pour écrire une réponse dans le champ de saisie de texte. En outre, un message d’état indique toutes les trente secondes le nombre de secondes restantes à l’utilisateur.
 
 <p>Un objet Timer est créé, démarre dans 30 secondes (délai défini sur 30000 millisecondes) et se répète trois fois pour un total de 90 secondes (l’objet Timer s’interrompt après la troisième fois).</p>
 
 <p>Deux écouteurs d’événement sont ajoutés au minuteur <codeph>myTimer</codeph>. Le premier est déclenché par l’événement <codeph>TimerEvent.TIMER</codeph>, qui se produit à chaque démarrage du minuteur. La méthode <codeph>timerHandler()</codeph> modifie le texte du champ de texte <codeph>statusTextField</codeph> pour afficher les secondes restantes. </p>
 <p><b>Remarque :</b> la classe Timer garde la trace du nombre de démarrage qu’elle effectue (<codeph>repeats</codeph>) en augmentant le nombre de la propriété <codeph>currentCount</codeph>.</p> 
 
 <p>Après que l’horloge est appelée pour la dernière fois, l’événement <codeph>TimerEvent.TIMER_COMPLETE</codeph> est distribué et la méthode <codeph>completeHandler()</codeph> est appelée. La méthode <codeph>completeHandler()</codeph> modifie le type du champ de texte <codeph>inputTextField</codeph> de <codeph>INPUT</codeph> à <codeph>DYNAMIC</codeph>, ce qui signifie que la saisie et la modification de texte ne sont plus autorisées.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.Event;

    public class Timer_constructorExample extends Sprite {
            private var statusTextField:TextField = new TextField();        
            private var inputTextField:TextField = new TextField();
            private var delay:uint = 30000;
            private var repeat:uint = 3;
            private var myTimer:Timer = new Timer(delay, repeat);
            
        public function Timer_constructorExample() {
            inputTextField.x = 10;
            inputTextField.y = 10;
            inputTextField.border = true;
            inputTextField.background = true;
            inputTextField.height = 200;
            inputTextField.width = 200;
            inputTextField.multiline = true;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            statusTextField.x = 10;
            statusTextField.y = 220;
            statusTextField.background = true;
            statusTextField.autoSize = TextFieldAutoSize.LEFT;   

            myTimer.start(); 
            statusTextField.text = "You have " + ((delay * repeat) / 1000) 
                                 + " seconds to write your response.";

            myTimer.addEventListener(TimerEvent.TIMER, timerHandler);
            myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, completeHandler);

            addChild(inputTextField);
            addChild(statusTextField);
        }

        private function timerHandler(e:TimerEvent):void{
            repeat--;
            statusTextField.text = ((delay * repeat) / 1000) + " seconds left.";
        }

        private function completeHandler(e:TimerEvent):void {
            statusTextField.text = "Times Up.";
            inputTextField.type = TextFieldType.DYNAMIC;    
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.utils:Timer:reset"><apiName>reset</apiName><shortdesc>
   	 Arrête l’horloge, le cas échéant, et redéfinit la propriété currentCount sur 0, tout comme le bouton de remise à zéro d’un chronomètre.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
   	 Arrête l’horloge, le cas échéant, et redéfinit la propriété <codeph>currentCount</codeph> sur 0, tout comme le bouton de remise à zéro d’un chronomètre. Lorsque <codeph>start()</codeph> est appelée, l’occurrence de l’horloge s’exécute le nombre de fois indiqué par la valeur <codeph>repeatCount</codeph>.
   	 
   	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Timer/stop()"><linktext>Timer.stop()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Timer:start"><apiName>start</apiName><shortdesc>
	 Démarre l’horloge, le cas échéant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Démarre l’horloge, le cas échéant.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:Timer:stop"><apiName>stop</apiName><shortdesc>
	 Arrête l’horloge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Arrête l’horloge. Lorsque <codeph>start()</codeph> est appelée après <codeph>stop()</codeph>, l’occurrence de l’horloge s’exécute en fonction du nombre de répétitions (<i>remaining</i>) défini par la propriété <codeph>repeatCount</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Timer/reset()"><linktext>Timer.reset()</linktext></link></related-links></apiOperation><apiValue id="flash.utils:Timer:currentCount:get"><apiName>currentCount</apiName><shortdesc>
	 Nombre total de déclenchements de l’horloge depuis son démarrage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre total de déclenchements de l’horloge depuis son démarrage. Si l’horloge a été réinitialisée, seuls les déclenchements qui suivent la réinitialisation sont comptabilisés.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:delay:get"><apiName>delay</apiName><shortdesc>
	 Délai, en millisecondes, entre les événements d’horloge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Cette opération renvoie une exception si le délai spécifié est négatif ou ne correspond pas à un nombre fini.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Délai, en millisecondes, entre les événements d’horloge. Si vous réglez l’intervalle lorsque l’horloge est en cours d’exécution, celle-ci redémarre à la même itération de <codeph>repeatCount</codeph>.
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:repeatCount:get"><apiName>repeatCount</apiName><shortdesc>
	 Nombre total de répétitions définies de l’horloge.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Nombre total de répétitions définies de l’horloge. Si le nombre de répétitions est réglé sur 0, l’horloge s’exécute indéfiniment ou jusqu’à ce que la méthode <codeph>stop()</codeph> soit appelée ou que le programme s’arrête. Si le nombre de répétitions n’est pas réglé sur zéro, l’horloge s’exécute le nombre de fois spécifié. Si <codeph>repeatCount</codeph> est défini sur un total inférieur ou égal à <codeph>currentCount</codeph>, l’horloge s’arrête et ne se déclenche plus.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:running:get"><apiName>running</apiName><shortdesc>
     Etat actuel de l’horloge : true si l’horloge est en cours d’exécution, false dans le cas contraire.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Etat actuel de l’horloge : <codeph>true</codeph> si l’horloge est en cours d’exécution, <codeph>false</codeph> dans le cas contraire.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:CompressionAlgorithm"><apiName>CompressionAlgorithm</apiName><shortdesc>
 La classe CompressionAlgorithm définit les constantes de type chaîne pour les noms des options de compression et de décompression.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe CompressionAlgorithm définit les constantes de type chaîne pour les noms des options de compression et de décompression. Ces constantes sont utilisées en tant que valeurs du paramètre <codeph>algorithm</codeph> des méthodes <codeph>ByteArray.compress()</codeph> et <codeph>ByteArray.uncompress()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.utils.xml#ByteArray/compress()"><linktext>flash.utils.ByteArray.compress()</linktext></link><link href="flash.utils.xml#ByteArray/uncompress()"><linktext>flash.utils.ByteArray.uncompress()</linktext></link></related-links><apiValue id="flash.utils:CompressionAlgorithm:DEFLATE"><apiName>DEFLATE</apiName><shortdesc>
	 Définit la chaîne à utiliser pour l’algorithme de compression deflate.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deflate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Définit la chaîne à utiliser pour l’algorithme de compression deflate.
	 
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:CompressionAlgorithm:ZLIB"><apiName>ZLIB</apiName><shortdesc>
	Définit la chaîne à utiliser pour l’algorithme de compression zlib.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>zlib</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Définit la chaîne à utiliser pour l’algorithme de compression zlib.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IDataInput"><apiName>IDataInput</apiName><shortdesc>
L’interface IDataInput propose plusieurs méthodes de lecture des données binaires.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
L’interface IDataInput propose plusieurs méthodes de lecture des données binaires. Elle est l’équivalent en E/S de l’interface IDataOutput, qui écrit des données binaires.
<p>Toutes les opérations IDataInput et IDataOutput utilisent l’ordre d’octet « bigEndian » par défaut (où l’octet le plus significatif de la séquence est mémorisé dans l’adresse de stockage de plus bas niveau ou dans la première adresse de stockage) et ne sont pas bloquantes. Si les données disponibles sont insuffisantes, une exception <codeph>EOFError</codeph> est renvoyée. Utilisez la propriété <codeph>IDataInput.bytesAvailable</codeph> pour déterminer le volume de données disponible pour la lecture.</p>

<p>L’extension de signe ne joue un rôle que lors de la lecture des données et non lors de leur écriture. Il est donc inutile d’utiliser des méthodes d’écriture distinctes pour faire appel à <codeph>IDataInput.readUnsignedByte()</codeph> et <codeph>IDataInput.readUnsignedShort()</codeph>. En d’autres termes :</p>
<ul><li>Utilisez <codeph>IDataOutput.writeByte()</codeph> avec <codeph>IDataInput.readUnsignedByte()</codeph> et <codeph>IDataInput.readByte()</codeph>.</li>
<li>Utilisez <codeph>IDataOutput.writeShort()</codeph> avec <codeph>IDataInput.readUnsignedShort()</codeph> et <codeph>IDataInput.readShort()</codeph>.</li></ul>

</apiDesc><example conref="examples\DataInputExample.as"> L’exemple suivant utilise la classe <codeph>DataInputExample</codeph> pour écrire une valeur booléenne et la représentation à virgule flottante à deux décimales de pi dans un tableau d’octets. Cette opération se déroule selon la procédure suivante :
 <ol>
     <li>Déclarez une nouvelle occurrence de l’objet <codeph>byteArr</codeph>.</li>
     <li>Ecrivez l’équivalant en octets de la valeur booléenne <codeph>false</codeph> et l’équivalent de la valeur mathématique de pi avec deux décimales.</li>
     <li>Relisez la valeur booléenne et le nombre à virgule flottante à deux décimales.</li>
 </ol>
 
 <p>Vous remarquerez qu’un segment de code est ajouté à la fin pour vérifier les erreurs de fin de fichier et s’assurer que la lecture du flux d’octets ne dépasse pas la fin.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class DataInputExample extends Sprite {        
        public function DataInputExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            byteArr.writeDouble(Math.PI);
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean()); // false
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());    // 3.141592653589793
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);        // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#IDataOutput"><linktext>Interface IDataOutput</linktext></link><link href="flash.utils.xml#IDataInput/endian"><linktext>endian</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>Classe FileStream</linktext></link><link href="flash.net.xml#Socket"><linktext>Classe Socket</linktext></link><link href="flash.net.xml#URLStream"><linktext>Classe URLStream</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>Classe ByteArray</linktext></link><link href="flash.errors.xml#EOFError"><linktext>Classe EOFError</linktext></link></related-links><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	 Lit une valeur booléenne dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Valeur booléenne, <codeph>true</codeph> si l’octet correspond à une valeur non nulle, <codeph>false</codeph> dans le cas contraire.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit une valeur booléenne dans le flux de fichiers, le flux d’octets ou le tableau d’octets. Un seul octet est lu, et la valeur <codeph>true</codeph> est renvoyée s’il n’est pas nul, <codeph>false</codeph> dans le cas contraire.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readByte"><apiName>readByte</apiName><shortdesc>
	 Lit un octet signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre -128 et 127.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un octet signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readBytes"><apiName>readBytes</apiName><shortdesc>
	 Lit le nombre d’octets de données spécifié par le paramètre length dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Objet <codeph>ByteArray</codeph> contenant les données à lire.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Décalage dans le paramètre <codeph>bytes</codeph> où la lecture des données doit commencer.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Nombre d’octets à lire. La valeur 0 (par défaut) provoque la lecture de toutes les données disponibles.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lit le nombre d’octets de données spécifié par le paramètre <codeph>length</codeph> dans le flux de fichiers, le flux d’octets ou le tableau d’octets. Les octets sont lus dans l’objet ByteArray spécifié par le paramètre <codeph>bytes</codeph>, à partir de la position indiquée par <codeph>offset</codeph>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readDouble"><apiName>readDouble</apiName><shortdesc>
	 Lit un nombre à virgule flottante à deux décimales, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à deux décimales et conforme à IEEE 754.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un nombre à virgule flottante à deux décimales, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readFloat"><apiName>readFloat</apiName><shortdesc>
	 Lit un nombre à virgule flottante à une décimale, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Nombre à virgule flottante à une décimale et conforme à IEEE 754.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un nombre à virgule flottante à une décimale, conforme à IEEE 754, extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readInt"><apiName>readInt</apiName><shortdesc>
	 Lit un entier signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre -2147483648 et 2147483647.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	 Lit une chaîne multi-octets de longueur spécifiée dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>IDataInput, IDataInput.readMultiByte, readMultiByte
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne au format UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire dans le flux d’octets.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Chaîne désignant le le jeu de caractères à utiliser pour interpréter les octets. Parmi les chaînes de jeu de caractères possibles figurent <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph>, etc. Pour obtenir la liste complète, voir la section <xref href="../../charset-codes.html">Jeux de caractères pris en charge</xref>. 
	 
     <p><b>Remarque :</b> si la valeur du paramètre <codeph>charSet</codeph> n’est pas reconnue par le système actuel, <ph platform="actionscript">Adobe<sup>®</sup> Flash<sup>®</sup> Player ou </ph>Adobe<sup>®</sup> AIR<sup>®</sup> utilise la page de code par défaut du système comme jeu de caractères. Par exemple, une valeur pour le paramètre <codeph>charSet</codeph>, comme dans <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> qui utilise <codeph>01</codeph> au lieu de <codeph>1</codeph> pourra éventuellement fonctionner sur votre machine de développement, mais pas sur un autre ordinateur. Sur l’autre ordinateur, <ph platform="actionscript">Flash Player ou </ph>le moteur d’exécution AIR utilise la page de code par défaut du système.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lit une chaîne multi-octets de longueur spécifiée dans le flux de fichiers, le flux d’octets ou le tableau d’octets en utilisant le jeu de caractères spécifié.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readObject"><apiName>readObject</apiName><shortdesc>
	 Lit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Objet déserialisé
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Lit un objet codé au format AMF sérialisé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataInput/objectEncoding"><linktext>objectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readShort"><apiName>readShort</apiName><shortdesc>
	 Lit un entier signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre -32768 et 32767.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUTF"><apiName>readUTF</apiName><shortdesc>
	 Lit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8 générée par la représentation des caractères sous forme d’octets.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit une chaîne UTF-8 dans le flux de fichiers, le flux d’octets ou le tableau d’octets. La chaîne doit être précédée d’un caractère non signé indiquant la longueur en octets.
	 
	 <p>Cette méthode est similaire à la méthode <codeph>readUTF()</codeph> de l’interface IDataInput Java<sup>®</sup>.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	 Lit une séquence d’octets UTF-8 dans le flux ou le tableau d’octets et renvoie une chaîne.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Chaîne UTF-8 de longueur spécifiée, générée par la représentation des caractères sous forme d’octets.	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Nombre d’octets à lire.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Lit une séquence d’octets UTF-8 dans le flux ou le tableau d’octets et renvoie une chaîne.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	 Lit un octet non signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre 0 et 255. 	   
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un octet non signé dans le flux de fichiers, le flux d’octets ou le tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	 Lit un entier non signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre 0 et 4294967295.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier non signé de 32 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	 Lit un entier non signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Les données à lire ne sont pas suffisantes.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>La valeur renvoyée est comprise entre 0 et 65535. 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Lit un entier non signé de 16 bits extrait du flux de fichiers, du flux d’octets ou du tableau d’octets.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	 Renvoie le nombre d’octets de données disponibles pour la lecture dans le tampon de saisie.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Renvoie le nombre d’octets de données disponibles pour la lecture dans le tampon de saisie. Le code utilisateur doit appeler <codeph>bytesAvailable</codeph> pour garantir que les données disponibles sont suffisantes avant leur lecture à l’aide de l’une des méthodes read.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:endian:get"><apiName>endian</apiName><shortdesc>
	 Ordre d’octet des données, à savoir la constante BIG_ENDIAN ou LITTLE_ENDIAN de la classe Endian.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Ordre d’octet des données, à savoir la constante <codeph>BIG_ENDIAN</codeph> ou <codeph>LITTLE_ENDIAN</codeph> de la classe Endian.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Classe Endian</linktext></link></related-links></apiValue><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Permet de déterminer si le format AMF3 ou AMF0 est utilisé lors de l’écriture ou la lecture des données binaires à l’aide de la méthode readObject().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Permet de déterminer si le format AMF3 ou AMF0 est utilisé lors de l’écriture ou la lecture des données binaires à l’aide de la méthode <codeph>readObject()</codeph>. La valeur est une constante extraite de la classe ObjectEncoding.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#IDataInput/readObject()"><linktext>readObject()</linktext></link><link href="flash.utils.xml#IDataOutput/writeObject()"><linktext>IDataOutput.writeObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding class</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.utils:Dictionary"><apiName>Dictionary</apiName><shortdesc>
 La classe Dictionary vous permet de créer un ensemble dynamique de propriétés, qui utilise l’opérateur d’égalité stricte (===) pour comparer les clés.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 La classe Dictionary vous permet de créer un ensemble dynamique de propriétés, qui utilise l’opérateur d’égalité stricte <codeph>===</codeph> pour comparer les clés. Lorsqu’un objet sert de clé, son identité est utilisée pour le rechercher, plutôt que la valeur renvoyée par l’appel de <codeph>toString()</codeph> sur son entrée. Dans une collection Dictionary, les objets primitifs (intégrés), tels que Numbers, se comportent de la même manière que lorsqu’ils sont la propriété d’un objet ordinaire.
 
 <p platform="actionscript">Les instructions suivantes indiquent les relations qui existent entre un objet Dictionary et un objet clé :</p>
 
 <codeblock platform="actionscript">
 var dict:Dictionary = new Dictionary();
 var obj:Object = new Object();
 var key:Object = new Object();
 key.toString = function() { return "key" }
  
 dict[key] = "Letters";
 obj["key"] = "Letters";
  
 dict[key] == "Letters"; // true
 obj["key"] == "Letters"; // true 
 obj[key] == "Letters"; // true because key == "key" is true because key.toString == "key"
 dict["key"] == "Letters"; // false because "key" === key is false
 delete dict[key]; //removes the key
 </codeblock>
 
 <p><b>Important :</b> la classe Dictionary est disponible uniquement pour le code ActionScript 3.0 (s’exécutant dans le contenu SWF). Elle n’est pas disponible pour le code JavaScript (s’exécutant dans Adobe<sup>®</sup> AIR™).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="../../operators.html#strict_equality"><linktext>=== (égalité stricte)</linktext></link></related-links><apiConstructor id="flash.utils:Dictionary:Dictionary"><apiName>Dictionary</apiName><shortdesc>
	 Crée un nouvel objet Dictionary.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>weakKeys</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Demande à l’objet Dictionary d’utiliser des références « faibles » aux clés d’objets. Si la seule référence à un objet réside dans l’objet Dictionary spécifié, la clé peut être nettoyée et est supprimée de la table lors de la collecte de l’objet.
  	 
  	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Crée un nouvel objet Dictionary. Pour supprimer une clé dans un objet Dictionary, utilisez l’opérateur <codeph>delete</codeph>.
  	 
  	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier></apiPackage>