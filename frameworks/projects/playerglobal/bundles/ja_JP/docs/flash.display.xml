<?xml version="1.0"?>
<apiPackage id="flash.display"><apiName>flash.display</apiName><apiDetail/><apiClassifier id="flash.display:FrameLabel"><apiName>FrameLabel</apiName><shortdesc>
	
	FrameLabel オブジェクトには、フレーム番号および対応するラベル名を指定するプロパティがあります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	
	FrameLabel オブジェクトには、フレーム番号および対応するラベル名を指定するプロパティがあります。Scene クラスには、<codeph>labels</codeph> プロパティがあります。これは、シーンの FrameLabel オブジェクトの配列です。 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Scene/labels"><linktext>Scene.labels</linktext></link><link href="flash.display.xml#MovieClip/currentLabel"><linktext>MovieClip.currentLabel</linktext></link><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:FrameLabel:frame:get"><apiName>frame</apiName><shortdesc>
		ラベルを含むフレームの番号。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		ラベルを含むフレームの番号。
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FrameLabel:name:get"><apiName>name</apiName><shortdesc>
		ラベルの名前。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		ラベルの名前。
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
 InteractiveObject クラスは、マウスとキーボードを使用してユーザーが操作できるすべての表示オブジェクトの抽象基本クラスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 InteractiveObject クラスは、マウスとキーボードを使用してユーザーが操作できるすべての表示オブジェクトの抽象基本クラスです。
 
 <p>InteractiveObject クラスを直接インスタンス化することはできません。<codeph>new InteractiveObject()</codeph> コンストラクターを呼び出すと、<codeph>ArgumentError</codeph> 例外がスローされます。</p>
 
 <p>InteractiveObject クラス自体は、コンテンツを画面上に描画する API を含みません。そのため、InteractiveObject クラスのカスタムサブクラスを作成する場合は、Sprite、SimpleButton、TextField、または MovieClip など、画面上にコンテンツを描画する API を持つサブクラスの 1 つを拡張する必要があります。</p>
 
 </apiDesc><example conref="examples\InteractiveObjectExample.as"> 次の例では、<codeph>InteractiveObjectExample</codeph> クラスを使用します。このクラスは、<codeph>ChildSprite</codeph> クラスを使用して矩形を描画し、その矩形を様々なマウスイベントに基づいて操作します。これを行うには、以下の手順を実行します。
 <ol>
    <li><codeph>InteractiveObjectExample</codeph> コンストラクターで、呼び出されたタイプ Sprite の新しい ChildSprite オブジェクト <codeph>child</codeph> が作成されます。これは、ChildSprite コンストラクターメソッドを呼び出してシェイプを描画し、そのシェイプにマウスイベントを追加します（以下の手順で説明）。<codeph>child</codeph> オブジェクトは、座標 <i>x = 0、y = 0</i> の表示リストの最上部に追加されます。  </li>
 
    <li><codeph>ChildSprite</codeph> クラスで、<codeph>size</codeph> プロパティおよび <codeph>overSize</codeph> プロパティを宣言します。これらのプロパティは、後で <codeph>draw()</codeph> メソッドおよび MouseEvent メソッドで使用されます。</li>
 
     <li>背景色をオレンジ色、マウスポインターが上に置かれたときの色を暗い黄色、マウスポインターの下の色を明るい青色に設定するプロパティを宣言します。</li>
 
    <li><codeph>ChildSprite</codeph> コンストラクターで、Graphic クラスのメソッドと <codeph>draw()</codeph> メソッドを使用して、オレンジ色の四角形が描画されます。</li>
 
    <li>コンストラクターは以下に示す 4 つの MouseEvent イベントリスナーメソッドを追加します。
 
     <ul>
        <li><codeph>mouseOverHandler</codeph>：暗い黄色で 60 x 60 ピクセルに大きくした四角形を元の座標に再描画します。</li>
        <li><codeph>mouseOutHandler</codeph>：四角形のサイズとカラーを元に戻します。</li>
        <li><codeph>mouseDownHandler</codeph>：明るい青色で 60 x 60 ピクセルに大きくした四角形を元の座標に再描画します。</li>
        <li><codeph>mouseUpHandler</codeph>：<codeph>mouseOverHandler</codeph> と同様です。</li>
     </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class InteractiveObjectExample extends Sprite {

        public function InteractiveObjectExample() {
            var child:Sprite = new ChildSprite();
            addChild(child);
        }
    }
}

import flash.display.Sprite;
import flash.events.MouseEvent;

class ChildSprite extends Sprite {
    private var size:uint = 50;
    private var overSize:uint = 60;
    private var backgroundColor:uint = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;

    public function ChildSprite() {
        buttonMode = true;
        draw(size, size, backgroundColor);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
        addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
    }

    private function draw(w:uint, h:uint, bgColor:uint):void {
        graphics.clear();
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }

    public function mouseOverHandler(event:MouseEvent):void {
        trace("mouseOverHandler");
        draw(overSize, overSize, overColor);
    }

    public function mouseOutHandler(event:MouseEvent):void {
        trace("mouseOutHandler");
        draw(size, size, backgroundColor);
    }

    public function mouseDownHandler(event:MouseEvent):void {
        trace("mouseDownHandler");
        draw(overSize, overSize, downColor);
    }

    public function mouseUpHandler(event:MouseEvent):void {
        trace("mouseUpHandler");
        draw(overSize, overSize, overColor);
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.display:InteractiveObject_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 テキストの文字を入力すると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 テキストの文字を入力すると送出されます。標準キーボード、IME（入力メソッドエディター）、音声認識システム、書式やスタイルの情報を持たないプレーンテキストのペースト操作など、様々なテキスト入力メソッドによって、このイベントが生成されます。
 </apiDesc><example conref="examples\TextField_textInput.as"/></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CONTEXT_MENU_contextMenu"><apiName>contextMenu</apiName><shortdesc>
 AIR アプリケーションでこのインタラクティブオブジェクトに関連付けられているコンテキストメニューをユーザージェスチャがトリガーすると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CONTEXT_MENU</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 AIR アプリケーションでこのインタラクティブオブジェクトに関連付けられているコンテキストメニューをユーザージェスチャがトリガーすると送出されます。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>contextMenu</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE_nativeDragComplete"><apiName>nativeDragComplete</apiName><shortdesc>
 ユーザーがドラッグジェスチャを止めると、ドラッグイニシエータ InteractiveObject から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがドラッグジェスチャを止めると、ドラッグイニシエータ InteractiveObject から送出されます。
 
 <p>イベントの dropAction プロパティは、ドラッグのターゲットオブジェクトによって設定されたアクションを示します。値 "none"（<codeph>DragActions.NONE</codeph>）は、ドロップ操作がキャンセルされたか、受け入れられなかったことを示します。</p>
 
 <p><codeph>nativeDragComplete</codeph> イベントハンドラーは、開始表示オブジェクトの状態を更新する場合に便利です。例えば、リストからアイテムを削除する場合（move のドラッグアクション）や、ビジュアルプロパティを変更する場合が該当します。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE_nativeDragUpdate"><apiName>nativeDragUpdate</apiName><shortdesc>
 ドラッグ操作が行われている間に、DragManager.doDrag() 呼び出しのドラッグイニシエータとして指定されている InteractiveObject から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ドラッグ操作が行われている間に、DragManager.doDrag() 呼び出しのドラッグイニシエータとして指定されている InteractiveObject から送出されます。
 
 <p>Linux の場合、<codeph>nativeDragUpdate</codeph> イベントは送出されません。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_START_nativeDragStart"><apiName>nativeDragStart</apiName><shortdesc>
 ドラッグ操作の開始時に、DragManager.doDrag() 呼び出しのドラッグイニシエータとして指定されている InteractiveObject から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_START</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ドラッグ操作の開始時に、DragManager.doDrag() 呼び出しのドラッグイニシエータとして指定されている InteractiveObject から送出されます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_EXIT_nativeDragExit"><apiName>nativeDragExit</apiName><shortdesc>
 ドラッグジェスチャが境界を出ると、InteractiveObject から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_EXIT</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ドラッグジェスチャが境界を出ると、InteractiveObject から送出されます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_DROP_nativeDragDrop"><apiName>nativeDragDrop</apiName><shortdesc>
 ドラッグされたオブジェクトがターゲットにドロップされ、そのドロップ操作が DragManager.acceptDragDrop() の呼び出しで受け入れられた場合に、ターゲットの InteractiveObject から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_DROP</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ドラッグされたオブジェクトがターゲットにドロップされ、そのドロップ操作が DragManager.acceptDragDrop() の呼び出しで受け入れられた場合に、ターゲットの InteractiveObject から送出されます。
 
 <p>イベントオブジェクトの <codeph>clipboard</codeph> プロパティを使用して、ドロップされたデータにアクセスします。</p>
 
 <p>このイベントのハンドラーでは、<codeph>DragManager.dropAction</codeph> プロパティを設定し、受け入れられたドラッグアクションについて、イニシエータオブジェクトにフィードバックを提供する必要があります。 値が設定されていない場合、DragManager は、許可されているアクションのリストからデフォルト値を選択します。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_OVER_nativeDragOver"><apiName>nativeDragOver</apiName><shortdesc>
 ドラッグジェスチャが境界の範囲内で行われている間、InteractiveObject から継続的に送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_OVER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ドラッグジェスチャが境界の範囲内で行われている間、InteractiveObject から継続的に送出されます。
 
 <p>マウスが移動するたびに、<codeph>nativeDragOver</codeph> イベントは送出されます。Windows および Mac の場合、マウスが移動していなくても短いタイマー間隔で送出されます。</p>
 
 <p><codeph>nativeDragOver</codeph> イベントまたは <codeph>nativeDragEnter</codeph> イベントのいずれかを処理して、表示オブジェクトがドロップターゲットになれるようにします。</p> 
 
 <p>送出している表示オブジェクトがドロップを受け入れられるかどうか特定するには、イベントオブジェクトの <codeph>clipboard</codeph> プロパティでデータの適合性をチェックし、許容されているドラッグアクションを <codeph>allowedActions</codeph> プロパティでチェックします。</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_ENTER_nativeDragEnter"><apiName>nativeDragEnter</apiName><shortdesc>
 ドラッグジェスチャが境界に入ると、InteractiveObject から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_ENTER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ドラッグジェスチャが境界に入ると、InteractiveObject から送出されます。
 
 <p><codeph>nativeDragEnter</codeph> イベントまたは <codeph>nativeDragOver</codeph> イベントのいずれかを処理して、表示オブジェクトがドロップターゲットになれるようにします。</p>
 
 <p>送出している表示オブジェクトがドロップを受け入れられるかどうか特定するには、イベントオブジェクトの <codeph>clipboard</codeph> プロパティでデータの適合性をチェックし、許容されているドラッグアクションを <codeph>allowedActions</codeph> プロパティでチェックします。</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_INDEX_CHANGE_tabIndexChange"><apiName>tabIndexChange</apiName><shortdesc>
 オブジェクトの tabIndex プロパティの値が変更されたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_INDEX_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 オブジェクトの <codeph>tabIndex</codeph> プロパティの値が変更されたときに送出されます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_ENABLED_CHANGE_tabEnabledChange"><apiName>tabEnabledChange</apiName><shortdesc>
 オブジェクトの tabEnabled フラグが変更されたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_ENABLED_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 オブジェクトの <codeph>tabEnabled</codeph> フラグが変更されたときに送出されます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_CHILDREN_CHANGE_tabChildrenChange"><apiName>tabChildrenChange</apiName><shortdesc>
 オブジェクトの tabChildren フラグの値が変更されたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_CHILDREN_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 オブジェクトの <codeph>tabChildren</codeph> フラグの値が変更されたときに送出されます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_UP_keyUp"><apiName>keyUp</apiName><shortdesc>
 ユーザーがキーを離したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_UP</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがキーを離したときに送出されます。キーと特殊文字の間のマッピングはデバイスやオペレーティングシステムによって異なります。このタイプのイベントは、マッピングが発生してから、IME（入力メソッドエディター）が処理される前に生成されます。IME は、標準的な QWERTY キーボードでは十分に対応できない、中国語の漢字などの文字を入力するために使用されます。このイベントは <codeph>keyDown</codeph> イベントの後に発生し、次のような特性があります。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_DOWN_keyDown"><apiName>keyDown</apiName><shortdesc>
 ユーザーがキーを押したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_DOWN</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがキーを押したときに送出されます。キーと特殊文字の間のマッピングはデバイスやオペレーティングシステムによって異なります。このタイプのイベントは、マッピングが発生してから、IME（入力メソッドエディター）が処理される前に生成されます。IME は、標準的な QWERTY キーボードでは十分に対応できない、中国語の漢字などの文字を入力するために使用されます。このイベントは、<codeph>keyUp</codeph> イベントの前に発生します。
 
 <p>AIR の場合、このイベントをキャンセルすると、テキストフィールドに文字が入力されなくなります。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを離したときに送出されます。 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを離したときに送出されます。  
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを押したときに送出されます。 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを押したときに送出されます。  
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
 ユーザーが同じ InteractiveObject 上でポインティングデバイスの右ボタンを押して離すと送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが同じ InteractiveObject 上でポインティングデバイスの右ボタンを押して離すと送出されます。 <codeph>rightClick</codeph> イベントが発生するためには、<codeph>rightMouseDown</codeph> イベントに続いて <codeph>rightMouseUp</codeph> イベントが発生するという順序でなければなりません。 ターゲットオブジェクトは、これらのイベントの両方について同じでなければなりません。異なる場合、<codeph>rightClick</codeph> イベントは発生しません。 <codeph>rightMouseDown</codeph> イベントまたは <codeph>rightMouseUp</codeph> イベントの間に他の多数のマウスイベントが発生する場合があり、<codeph>rightClick</codeph> イベントは引き続き発生します。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_UP_middleMouseUp"><apiName>middleMouseUp</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを離したときに送出されます。 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを離したときに送出されます。  
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_DOWN_middleMouseDown"><apiName>middleMouseDown</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスの中央ボタンを押したときに送出されます。 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスの中央ボタンを押したときに送出されます。  
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_CLICK_middleClick"><apiName>middleClick</apiName><shortdesc>
 ユーザーが同じ InteractiveObject 上でポインティングデバイスの中央ボタンを押して離すと送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが同じ InteractiveObject 上でポインティングデバイスの中央ボタンを押して離すと送出されます。 <codeph>middleClick</codeph> イベントが発生するためには、<codeph>middleMouseDown</codeph> イベントに続いて <codeph>middleMouseUp</codeph> イベントが発生するという順序でなければなりません。 ターゲットオブジェクトは、これらのイベントの両方について同じでなければなりません。異なる場合、<codeph>middleClick</codeph> イベントは発生しません。 <codeph>middleMouseDown</codeph> イベントまたは <codeph>middleMouseUp</codeph> イベントの間に他の多数のマウスイベントが発生する場合があり、<codeph>middleClick</codeph> イベントは引き続き発生します。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OVER_rollOver"><apiName>rollOver</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンスにポインティングデバイスを合わせたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンスにポインティングデバイスを合わせたときに送出されます。イベントターゲットは、ポインティングデバイスの下に置かれていたオブジェクトか、そのオブジェクトの親です。<codeph>relatedObject</codeph> は、直前にポインティングデバイスの下に置かれていたオブジェクトです。<codeph>rollOver</codeph> イベントは、そのオブジェクトの親チェーンを <codeph>relatedObject</codeph> のルートでも祖先でもない最高位の親から始めて下方向にたどっていき、そのオブジェクトに至るまで連続して送出されます。
 <p><codeph>rollOver</codeph> イベントは、子を持つ表示オブジェクトコンテナのロールアウト動作のコーディングを単純化するためのものです。表示オブジェクトの子ではないオブジェクトから、表示オブジェクトの領域か、その子の領域にマウスが入るとき、表示オブジェクトは <codeph>rollOver</codeph> イベントを送出します。これは <codeph>mouseOver</codeph> イベントとは異なります。mouseOver イベントは、マウスが表示オブジェクトコンテナの子オブジェクトの領域に入る際には、そのマウスが表示オブジェクトコンテナの別の子オブジェクト上に既に置かれていた場合でも、毎回送出されます。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OUT_rollOut"><apiName>rollOut</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンスからポインティングデバイスを離したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンスからポインティングデバイスを離したときに送出されます。イベントターゲットは、直前にポインティングデバイスの下に置かれていたオブジェクトか、そのオブジェクトの親です。<codeph>relatedObject</codeph> はポインティングデバイスの移動先のオブジェクトです。<codeph>rollOut</codeph> イベントは、そのオブジェクトの親チェーンをそのオブジェクトから始めて上方向にたどっていき、<codeph>relatedObject</codeph> のルートでも祖先でもない最高位の親に至るまで連続して送出されます。 
 <p><codeph>rollOut</codeph> イベントは、子を持つ表示オブジェクトコンテナのロールオーバー動作のコーディングを単純化するためのものです。マウスが表示オブジェクトの領域かその子の領域から出て、その子の一部ではないオブジェクトに進む場合、表示オブジェクトは <codeph>rollOut</codeph> イベントを送出します。これは <codeph>mouseOut</codeph> イベントとは異なります。mouseOut イベントは、マウスが表示オブジェクトコンテナの子オブジェクトの領域から出る際には、そのマウスが表示オブジェクトコンテナの別の子オブジェクト上にある場合でも、毎回送出されます。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_WHEEL_mouseWheel"><apiName>mouseWheel</apiName><shortdesc>
 マウスホイールが InteractiveObject インスタンス上を回転するときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_WHEEL</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 マウスホイールが InteractiveObject インスタンス上を回転するときに送出されます。 ターゲットがテキストフィールドである場合、デフォルトの動作ではテキストはスクロールします。Microsoft Windows オペレーティングシステムでのみ使用できます。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを離したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを離したときに送出されます。 ターゲットが SimpleButton インスタンスである場合、オブジェクトは <codeph>upState</codeph> 表示オブジェクトを表示します。ターゲットが選択可能なテキストフィールドである場合、デフォルトの動作ではテキストフィールドの選択が終了します。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OVER_mouseOver"><apiName>mouseOver</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンスにポインティングデバイスを合わせたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンスにポインティングデバイスを合わせたときに送出されます。<codeph>relatedObject</codeph> は、直前にポインティングデバイスの下に置かれていたオブジェクトです。ターゲットが SimpleButton インスタンスである場合、オブジェクトはデフォルトの動作として、マウスボタンが押されているかどうかに応じて、オブジェクトは <codeph>overState</codeph> または <codeph>upState</codeph> 表示オブジェクトを表示します。
 <p><codeph>mouseOver</codeph> イベントは、表示オブジェクトコンテナの別の子オブジェクト上に既にマウスがあった場合でも、表示オブジェクトコンテナの子オブジェクトの領域にマウスが入るたびに送出されます。これは、<codeph>rollOver</codeph> イベントの目的の動作とは異なります。この動作は、子を持つ表示オブジェクトコンテナのロールアウト動作のコーディングを単純化するためのものです。表示オブジェクトの子ではないオブジェクトから、表示オブジェクトの領域か、その子の領域にマウスが入るとき、表示オブジェクトは <codeph>rollOver</codeph> イベントを送出します。<codeph>rollOver</codeph> イベントは、そのオブジェクトの親チェーンを下方向にたどり、連続して送出されます。チェーンの開始は <codeph>relatedObject</codeph> のルートでも祖先でもない最高位の親で、終わりはそのオブジェクトです。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OUT_mouseOut"><apiName>mouseOut</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンスからポインティングデバイスを離したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンスからポインティングデバイスを離したときに送出されます。イベントターゲットは、直前にポインティングデバイスの下に置かれていたオブジェクトです。<codeph>relatedObject</codeph> はポインティングデバイスの移動先のオブジェクトです。ターゲットが SimpleButton インスタンスである場合、デフォルトの動作ではボタンは <codeph>upState</codeph> 表示オブジェクトを表示します。
 <p><codeph>mouseOut</codeph> イベントは、表示オブジェクトコンテナの別の子オブジェクト上にマウスが残る場合でも、表示オブジェクトコンテナの子オブジェクトの領域からマウスが出るたびに送出されます。これは、<codeph>rollOut</codeph> イベントの目的の動作とは異なります。この動作は、子を持つ表示オブジェクトコンテナのロールオーバー動作のコーディングを単純化するためのものです。表示オブジェクトの領域か、その子の領域からマウスが出て、その表示オブジェクトの子ではないオブジェクトに進む場合、表示オブジェクトは <codeph>rollOut</codeph> イベントを送出します。<codeph>rollOut</codeph> イベントは、そのオブジェクトの親チェーンを上方向にたどり、連続して送出されます。チェーンの開始はそのオブジェクトで、終わりは <codeph>relatedObject</codeph> のルートでも祖先でもない最高位の親です。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_MOVE_mouseMove"><apiName>mouseMove</apiName><shortdesc>
 InteractiveObject の上で、ユーザーがポインティングデバイスを移動させたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_MOVE</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 InteractiveObject の上で、ユーザーがポインティングデバイスを移動させたときに送出されます。ターゲットがユーザーの選択するテキストフィールドである場合、選択はデフォルトの動作で更新されます。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを押したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが InteractiveObject インスタンス上でポインティングデバイスのボタンを押したときに送出されます。 ターゲットが SimpleButton インスタンスである場合、デフォルトの動作では SimpleButton インスタンスは <codeph>downState</codeph> 表示オブジェクトを表示します。ターゲットが選択可能なテキストフィールドである場合、デフォルトの動作ではテキストフィールドの選択が開始されます。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.DOUBLE_CLICK_doubleClick"><apiName>doubleClick</apiName><shortdesc>
 オブジェクトの doubleClickEnabled フラグが true に設定されている場合にユーザーが InteractiveObject をポインティングデバイスのメインボタンで 2 回続けてすばやくクリックすると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.DOUBLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 オブジェクトの <codeph>doubleClickEnabled</codeph> フラグが <codeph>true</codeph> に設定されている場合には、ユーザーが同じ InteractiveObject 上でポインティングデバイスのメインボタンを 2 回続けてすばやく押して離すと送出されます。<codeph>doubleClick</codeph> イベントが発生するためには、<codeph>mouseDown</codeph>、<codeph>mouseUp</codeph>、<codeph>click</codeph>、<codeph>mouseDown</codeph>、<codeph>mouseUp</codeph> の一連のイベントの直後でなければなりません。これらのすべてのイベントは、<codeph>doubleClick</codeph> イベントと同じターゲットを共有している必要があります。2 回目の <codeph>mouseDown</codeph> イベントと <codeph>mouseUp</codeph> イベントによって表される 2 回目のクリックは、<codeph>click</codeph> イベント後の特定の期間内に発生する必要があります。この期間の設定可能な長さは、オペレーティングシステムによって異なり、ほとんどの場合ユーザーが設定できます。ターゲットが選択可能なテキストフィールドである場合、デフォルトの動作ではポインターの下の語が選択されます。ターゲットの InteractiveObject の <codeph>doubleClickEnabled</codeph> フラグが <codeph>true</codeph> に設定されていない場合、2 つの <codeph>click</codeph> イベントを受け取ります。  
 
 <p><codeph>doubleClickEnabled</codeph> プロパティのデフォルト値は <codeph>false</codeph> です。  </p>
 
 <p>TextField オブジェクトのダブルクリックによるテキスト選択の動作は、<codeph>doubleClick</codeph> イベントとは無関係です。<codeph>TextField.doubleClickEnabled</codeph> を使用して TextField の選択を制御します。</p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/doubleClickEnabled"><linktext>doubleClickEnabled</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 ユーザーが同じ InteractiveObject 上でポインティングデバイスのメインボタンを押して離すと送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーが同じ InteractiveObject 上でポインティングデバイスのメインボタンを押して離すと送出されます。クリックイベントが発生するためには、mouseDown イベントに続いて mouseUp イベントが発生するという順序でなければなりません。ターゲットオブジェクトは、これらのイベントの両方について同じでなければなりません。異なる場合、<codeph>click</codeph> イベントは発生しません。<codeph>mouseDown</codeph> イベントまたは <codeph>mouseUp</codeph> イベントの間に他の多数のマウスイベントが発生する場合があり、<codeph>click</codeph> イベントは引き続き発生します。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.MOUSE_FOCUS_CHANGE_mouseFocusChange"><apiName>mouseFocusChange</apiName><shortdesc>
 ユーザーがポインティングデバイスでフォーカスを変更しようとすると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.MOUSE_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがポインティングデバイスでフォーカスを変更しようとすると送出されます。このイベントのデフォルトの動作では、フォーカスを変更して、対応する <codeph>focusIn</codeph> イベントと <codeph>focusOut</codeph> イベントを送出します。 
 
 <p>このイベントは、現在フォーカスを持っているオブジェクトに送出されます。このイベントの関連オブジェクトは、デフォルトの動作を変更していない場合は、フォーカスを受け取る InteractiveObject インスタンスです。ターゲットオブジェクトに正しく登録されているイベントリスナーで <codeph>preventDefault()</codeph> を呼び出すことによって、フォーカスを変更できないようにすることができます。<codeph>shiftKey</codeph> プロパティは使用されません。フォーカスが変更され、デフォルトでは <codeph>focusIn</codeph> および <codeph>focusOut</codeph> イベントが送出されます。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.KEY_FOCUS_CHANGE_keyFocusChange"><apiName>keyFocusChange</apiName><shortdesc>
 ユーザーがキーボード操作によってフォーカスを変更しようとすると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.KEY_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがキーボード操作によってフォーカスを変更しようとすると送出されます。このイベントのデフォルトの動作では、フォーカスを変更して、対応する <codeph>focusIn</codeph> イベントと <codeph>focusOut</codeph> イベントを送出します。
 
 <p>このイベントは、現在フォーカスを持っているオブジェクトに送出されます。このイベントの関連オブジェクトは、デフォルトの動作を変更していない場合は、フォーカスを受け取る InteractiveObject インスタンスです。ターゲットオブジェクトに正しく登録されているイベントリスナーで <codeph>preventDefault()</codeph> メソッドを呼び出すことによって、フォーカスを変更不可にできます。フォーカスが変更され、デフォルトでは <codeph>focusIn</codeph> および <codeph>focusOut</codeph> イベントが送出されます。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_OUT_focusOut"><apiName>focusOut</apiName><shortdesc>
 表示オブジェクトがフォーカスを失った後に送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_OUT</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 表示オブジェクトがフォーカスを失った<i>後に</i>送出されます。これは、ポインティングデバイスまたはキーボードによる操作で別のオブジェクトをハイライトするときに生じます。フォーカスを失うオブジェクトはこのイベントのターゲットオブジェクトと呼ばれ、フォーカスを受け取る対応する InteractiveObject インスタンスは関連オブジェクトと呼ばれます。関連オブジェクトへの参照は、ターゲットオブジェクトの <codeph>relatedObject</codeph> プロパティに格納されます。<codeph>shiftKey</codeph> プロパティは使用されません。このイベントは、関連オブジェクトから <codeph>focusIn</codeph> イベントが送出される前に発生します。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_IN_focusIn"><apiName>focusIn</apiName><shortdesc>
 表示オブジェクトがフォーカスを取得した後に送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_IN</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 表示オブジェクトがフォーカスを取得した<i>後に</i>送出されます。この状況は、ポインティングデバイスまたはキーボードによる操作でオブジェクトをハイライトするときに生じます。そのようなフォーカスの受け取り側はこのイベントのターゲットオブジェクトと呼ばれ、この変更によってフォーカスを失う対応する InteractiveObject インスタンスは関連オブジェクトと呼ばれます。関連オブジェクトへの参照は、受信側オブジェクトの <codeph>relatedObject</codeph> プロパティに格納されます。<codeph>shiftKey</codeph> プロパティは使用されません。このイベントは、前のオブジェクトの <codeph>focusOut</codeph> イベントが送出された後に発生します。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.SELECT_ALL_selectAll"><apiName>selectAll</apiName><shortdesc>
 ユーザーがすべて選択操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「すべて選択」を選択した場合に送信されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT_ALL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがすべて選択操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「すべて選択」を選択した場合に送信されます。このイベントは、現在フォーカスを持っているオブジェクトに送出されます。現在フォーカスを持っているオブジェクトが TextField である場合、このイベントのデフォルトの動作では、テキストフィールドのすべてのコンテンツが選択されます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.PASTE_paste"><apiName>paste</apiName><shortdesc>
 ユーザーがペースト操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「ペースト」を選択した場合に送信されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.PASTE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがペースト操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「ペースト」を選択した場合に送信されます。このイベントは、現在フォーカスを持っているオブジェクトに送出されます。現在フォーカスを持っているオブジェクトが TextField である場合、このイベントのデフォルトの動作では、クリップボードのコンテンツが現在の挿入ポイントのテキストフィールドにペーストされ、そのテキストフィールドで現在選択されているテキストが置き換えられます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CUT_cut"><apiName>cut</apiName><shortdesc>
 ユーザーがカット操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「カット」を選択した場合に送信されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CUT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがカット操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「カット」を選択した場合に送信されます。このイベントは、現在フォーカスを持っているオブジェクトに送出されます。現在フォーカスを持っているオブジェクトが TextField である場合、このイベントのデフォルトの動作では、そのテキストフィールド内で現在選択されているテキストがクリップボードにカットされます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.COPY_copy"><apiName>copy</apiName><shortdesc>
 ユーザーがコピー操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「コピー」を選択した場合に送信されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COPY</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがコピー操作のためにプラットフォーム固有のアクセラレーターキーの組み合わせをアクティブ化したとき、またはコンテキストメニューから「コピー」を選択した場合に送信されます。このイベントは、現在フォーカスを持っているオブジェクトに送出されます。現在フォーカスを持っているオブジェクトが TextField である場合、このイベントのデフォルトの動作では、そのテキストフィールド内で現在選択されているテキストがクリップボードにコピーされます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CLEAR_clear"><apiName>clear</apiName><shortdesc>
 ユーザーがコンテキストメニューから「削除」を選択した場合に送信されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLEAR</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ユーザーがコンテキストメニューから「削除」を選択した場合に送信されます。このイベントは、現在フォーカスを持っているオブジェクトに送出されます。現在フォーカスを持っているオブジェクトが TextField である場合、このイベントのデフォルトの動作では、そのテキストフィールド内で現在選択されているテキストが削除されます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:InteractiveObject:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
	新しい InteractiveObject() コンストラクターを呼び出すと、ArgumentError 例外がスローされます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	<codeph>new InteractiveObject()</codeph> コンストラクターを呼び出すと、<codeph>ArgumentError</codeph> 例外がスローされます。しかし、InteractiveObject の以下に示すサブクラスのコンストラクターを呼び出すことができます。
	
	<ul>
	
		<li><codeph>new SimpleButton()</codeph></li>
		<li><codeph>new TextField()</codeph></li>
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:InteractiveObject:contextMenu:get"><apiName>contextMenu</apiName><shortdesc> 
	 このオブジェクトに関連付けられたコンテキストメニューを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier><apiTipTexts><apiTipText>このオブジェクトに関連付けられたコンテキストメニュー
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 このオブジェクトに関連付けられたコンテキストメニューを指定します。
	 
	 <p>Flash Player で実行されているコンテンツでは、このプロパティは ContextMenu オブジェクトです。 AIR ランタイムでは、ContextMenu クラスは NativeMenu クラスを拡張します。ただし、Flash Player では、ContextMenu クラスのみサポートしており、NativeMenu クラスはサポートしていません。
	 </p>
	 
	 <p><b>注意：</b>TextField オブジェクトのコンテキストメニューには、クリップボードメニューが常に含まれます。クリップボードメニューには「カット」、「コピー」、「ペースト」、「クリア」および「すべて選択」コマンドがあります。これらのコマンドを TextField オブジェクトのコンテキストメニューから削除することはできません。TextField オブジェクトでこれらのコマンドを選択（または相当するキーボード操作を実行）する際、<codeph>clear</codeph>、<codeph>copy</codeph>、<codeph>cut</codeph>、<codeph>paste</codeph> および <codeph>selectAll</codeph> 各イベントは生成されません。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:doubleClickEnabled:get"><apiName>doubleClickEnabled</apiName><shortdesc> 
	 オブジェクトが doubleClick イベントを受け取るかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>このオブジェクトがダブルクリックメッセージを受け取るかどうかを指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 オブジェクトが <codeph>doubleClick</codeph> イベントを受け取るかどうかを指定します。デフォルト値は <codeph>false</codeph> です。これは、InteractiveObject インスタンスがデフォルトでは <codeph>doubleClick</codeph> イベントを受け取らないことを意味します。<codeph>doubleClickEnabled</codeph> プロパティが<codeph>true</codeph> に設定される場合、インスタンスはその境界内で <codeph>doubleClick</codeph> イベントを受け取ります。InteractiveObject インスタンスの <codeph>mouseEnabled</codeph> プロパティも<codeph>true</codeph> に設定する必要があります。この設定は、オブジェクトが <codeph>doubleClick</codeph> イベントを受け取るようにするには必須です。
	 
	 <p>このプロパティを設定しても、イベントは送出されません。<codeph>addEventListener()</codeph> メソッドの使用は、<codeph>doubleClick</codeph> イベントのイベントリスナーを追加する場合に必須です。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InteractiveObject/event:doubleClick"><linktext>doubleClick</linktext></link><link href="flash.display.xml#InteractiveObject/mouseEnabled"><linktext>mouseEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:focusRect:get"><apiName>focusRect</apiName><shortdesc> 
	 このオブジェクトがフォーカス矩形を表示するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip._focusRect, Button._focusRect, and 
	 _focusRect (global property) topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc> 
	 このオブジェクトがフォーカス矩形を表示するかどうかを指定します。<codeph>true</codeph>、<codeph>false</codeph> または <codeph>null</codeph> の 3 つの値のいずれかを指定できます。<codeph>true</codeph> および <codeph>false</codeph> の値は、予想されるとおり、フォーカス矩形を表示するかどうかが指定されます。<codeph>null</codeph> 値は、このオブジェクトが Stage の <codeph>stageFocusRect</codeph> プロパティに従うことを示します。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:mouseEnabled:get"><apiName>mouseEnabled</apiName><shortdesc> 
	 このオブジェクトがマウスメッセージを受け取るかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 このオブジェクトがマウスメッセージを受け取るかどうかを指定します。デフォルト値は <codeph>true</codeph> であり、これは表示リスト上の InteractiveObject がデフォルトでマウスイベントを受け取ることを意味します。<codeph>mouseEnabled</codeph> が <codeph>false</codeph> に設定される場合、インスタンスはマウスイベントを受け取らなくなります。表示リスト上のこのインスタンスの子は影響を受けません。表示リスト上のオブジェクトのすべての子に関する <codeph>mouseEnabled</codeph> 動作を変更するには、<codeph>flash.display.DisplayObjectContainer.mouseChildren</codeph> を使用します。
	 <p> このプロパティを設定しても、イベントは送出されません。インタラクティブな機能を作成するには、<codeph>addEventListener()</codeph> メソッドを使用する必要があります。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:tabEnabled:get"><apiName>tabEnabled</apiName><shortdesc> 
	 このオブジェクトがタブ順序に含まれるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip.tabEnabled, Button.tabEnabled, and 
	 TextField.tabEnabled topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>このオブジェクトがタブ順序に含まれるかどうかを指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 このオブジェクトがタブ順序に含まれるかどうかを指定します。このオブジェクトがタブ順序に含まれる場合、値は <codeph>true</codeph> です。含まれない場合、値は <codeph>false</codeph> です。デフォルトでは、次の例外を除き、値は <codeph>false</codeph> です。
     <ul><li>SimpleButton オブジェクトの場合、この値は <codeph>true</codeph> です。</li>
     <li><codeph>type = "input"</codeph> を持つ TextField オブジェクトの場合、値は <codeph>true</codeph> です。</li>
     <li><codeph>buttonMode = true</codeph> を持つ Sprite オブジェクトまたは MovieClip オブジェクトの場合、値は <codeph>true</codeph> です。</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:tabIndex:get"><apiName>tabIndex</apiName><shortdesc> 
   	 SWF ファイル内のオブジェクトのタブ順序を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>このオブジェクトのタブインデックス。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
   	 SWF ファイル内のオブジェクトのタブ順序を指定します。デフォルトでは <codeph>tabIndex</codeph> プロパティは -1 であり、これはそのオブジェクトにタブインデックスが設定されないことを意味します。
	 
   	 <p>SWF ファイルに現在表示されているオブジェクトに <codeph>tabIndex</codeph> プロパティがある場合は、自動タブ順序が無効になり、SWF ファイルのオブジェクトの <codeph>tabIndex</codeph> プロパティからタブ順序が計算されます。カスタムタブ順序には、<codeph>tabIndex</codeph> プロパティを持つオブジェクトのみが含まれます。</p>
	 
   	 <p><codeph>tabIndex</codeph> プロパティは、通常、負以外の整数です。オブジェクトのタブ順序は、その <codeph>tabIndex</codeph> プロパティに従って昇順に決定されます。<codeph>tabIndex</codeph> の値が 1 であるオブジェクトは、<codeph>tabIndex</codeph> の値が 2 であるオブジェクトの前になります。複数のオブジェクトの <codeph>tabIndex</codeph> に同じ値を使用しないでください。</p>
	 
	 <p><codeph>tabIndex</codeph>プロパティで定義されるカスタムタブ順序は <i>flat</i> です。つまり、SWF ファイル内のオブジェクトの階層関係は無視されます。SWF ファイルで <codeph>tabIndex</codeph> プロパティを持つすべてのオブジェクトは、タブ順序に従って配置されます。タブ順序は <codeph>tabIndex</codeph> の値の順番に従います。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
 （u,v）塗り座標または通常の塗りのいずれかを使用してレンダリングが可能な、順序付けられた 1 セットの三角形を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 （u,v）塗り座標または通常の塗りのいずれかを使用してレンダリングが可能な、順序付けられた 1 セットの三角形を定義します。パス内にある各三角形は 3 セットの（x, y）座標で表され、それぞれが三角形の 1 点となります。
 
 <p>
 三角形の頂点には z 座標は含まれず、必ずしも 3D 面を表すとは限りません。しかし、三角形パスを使用して、2D 空間での 3D ジオメトリのレンダリングをサポートすることは可能です。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsTrianglePath:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
     新しい GraphicsTrianglePath オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Number の Vector で、数値の各ペアはポイント（x と y のペア）として扱われます。必須です。
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>整数またはインデックスの Vector です。3 つのインデックスごとに三角形が定義されます。 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>テクスチャマッピングを適用するために使用される正規化座標の Vector です。
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>特定の方向に面する三角形をレンダリングするかどうかを指定します。現在のビューで見えない三角形のレンダリングを避けるのに使用します。TriangleCulling クラスで定義された任意の値に設定できます。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     新しい GraphicsTrianglePath オブジェクトを作成します。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsTrianglePath/culling"><linktext>culling</linktext></link><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsTrianglePath:indices"><apiName>indices</apiName><shortdesc>
     整数またはインデックスの Vector です。3 つのインデックスごとに三角形が定義されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     整数またはインデックスの Vector です。3 つのインデックスごとに三角形が定義されます。indexes パラメーターが null の場合、3 つの頂点（vertices Vector 内の 6 つの x、y ペア）ごとに三角形が定義されます。null でない場合、各インデックスは頂点（vertices Vector 内の数値のペア）を参照します。 例えば、<codeph>indexes[1]</codeph> は（<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>）を参照します。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:uvtData"><apiName>uvtData</apiName><shortdesc>
     テクスチャマッピングを適用するために使用される正規化座標の Vector です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     テクスチャマッピングを適用するために使用される正規化座標の Vector です。各座標は、塗りに使用されるビットマップ上のポイントを参照します。頂点ごとに 1 つの UV 座標または 1 つの UVT 座標が必要です。
     
     <p>
     UV 座標では、（0,0）はビットマップの左上隅で、（1,1）はビットマップの右下隅です。 
     </p>
                    
     <p>
     このベクターの長さが <codeph>vertices</codeph> ベクターの 2 倍である場合、外見上の修正を行うことなく、正規化座標が使用されます。
     </p>
     
     <p>
     このベクターの長さが <codeph>vertices</codeph> ベクターの 3 倍である場合、3 番目の座標は、「t」（視点空間における視点からテクスチャまでの距離）として解釈されます。これにより、3D でテクスチャをマッピングする場合に、レンダリングエンジンが外観を正しく適用できるようになります。
     </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:vertices"><apiName>vertices</apiName><shortdesc>
     Number の Vector で、数値の各ペアはポイント（x と y のペア）として扱われます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Number の Vector で、数値の各ペアはポイント（x と y のペア）として扱われます。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:culling:get"><apiName>culling</apiName><shortdesc>
     特定の方向に面する三角形をレンダリングするかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     特定の方向に面する三角形をレンダリングするかどうかを指定します。現在のビューで見えない三角形のレンダリングを避けるのに使用します。 
     <p>
     TriangleCulling クラスで定義された任意の値に設定できます。
     </p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObject"><apiName>DisplayObject</apiName><shortdesc>
 DisplayObject クラスは、表示リストに含めることのできるすべてのオブジェクトに関する基本クラスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 DisplayObject クラスは、表示リストに含めることのできるすべてのオブジェクトに関する基本クラスです。表示リストは、Flash Player または Adobe AIR に表示されるすべてのオブジェクトを管理します。  DisplayObjectContainer クラスは、表示リスト内で表示オブジェクトを配置するために使用します。DisplayObjectContainer オブジェクトは子表示オブジェクトを持つことができます。これに対して、他の表示オブジェクト（例えば Shape、TextField オブジェクト）は「リーフ」ノードです。つまり、親と兄弟だけを持ち、子はありません。 
 
 <p>DisplayObject クラスは、基本機能（例えばオブジェクトの <i>x</i> 方向および <i>y</i> 方向の位置）に加えて、オブジェクトの拡張プロパティ（例えば変換マトリックス）をサポートします。 
 </p>
 
 <p>DisplayObject は抽象基本クラスであるため、DisplayObject を直接呼び出すことはできません。<codeph>new DisplayObject()</codeph> を呼び出すと <codeph>ArgumentError</codeph> 例外がスローされます。 </p>
 
 <p>すべての表示オブジェクトは DisplayObject クラスから継承します。</p>
 
 <p>DisplayObject クラス自体は、画面上でのコンテンツの描画のための API を含みません。そのため、DisplayObject クラスのカスタムサブクラスを作成する場合は、Shape、Sprite、Bitmap、SimpleButton、TextField または MovieClip など、画面上にコンテンツを描画する API を持つサブクラスの 1 つを拡張する必要があります。</p>
 
 <p>DisplayObject クラスには、複数のブロードキャストイベントが含まれます。通常、個々のイベントのターゲットは、特定の DisplayObject インスタンスです。例えば、<codeph>added</codeph> イベントのターゲットは、表示リストに追加された特定の DisplayObject インスタンスです。単一のターゲットを持つことにより、イベントリスナーの配置が、そのターゲット（および場合によっては表示リスト上のターゲットの祖先）に制限されます。ただし、ブロードキャストイベントの場合は、ターゲットが特定の DisplayObject インスタンスではなく、表示リストに含まれていない DisplayObject インスタンスを含む、すべての DisplayObject インスタンスになります。これは、任意の DisplayObject インスタンスにリスナーを追加して、ブロードキャストイベントを監視できることを意味します。DisplayObject クラスは、DisplayObject クラスの Events テーブルにリストされたブロードキャストイベントだけでなく、EventDispatcher クラスのブロードキャストイベントである <codeph>activate</codeph> と <codeph>deactivate</codeph> も継承します。</p>
 
 <p>ActionScript 1.0 および 2.0 の MovieClip、TextField、および Button クラスで使用されていたいくつかのプロパティ（例えば <codeph>_alpha</codeph>、<codeph>_height</codeph>、<codeph>_name</codeph>、<codeph>_width</codeph>、<codeph>_x</codeph>、<codeph>_y</codeph> など）と同等のプロパティが、ActionScript 3.0 DisplayObject クラスに存在します。これらの名前は変更され、アンダースコア（_）文字では始まりません。</p>
 
 <p>詳しくは、『<i>ActionScript 3.0 のプログラミング</i>』の「表示のプログラミング」の章を参照してください。</p>
 
 </apiDesc><example conref="examples\DisplayObjectExample.as"> <codeph>DisplayObjectExample</codeph> クラスを使用して、オレンジ色の四角形をステージの隅に描画した後、各イベントに関するテキスト情報を表示することによってイベントに応答します。これを行うには、以下の手順を実行します。
 <ol>
    <li>四角形の色とサイズに関するクラスプロパティが宣言されます。</li>
     <li>コンストラクターは <codeph>draw()</codeph> メソッドを呼び出します。このメソッドでは、オレンジ色の四角形が、ステージのデフォルト座標 <i>x = 0, y = 0</i> に描画されます。</li>
    <li>四角形には次のようなイベントリスナーメソッドがあります。
     <ul>
        <li><codeph>addedHandler()</codeph> は、<codeph>added</codeph> イベントをリッスンします。このイベントは四角形が表示リストに追加されたときに送出されます。</li>
        <li><codeph>enterFrameHandler()</codeph> は、<codeph>enterFrame</codeph> イベントをリッスンします。このイベントは、この例では特に意味はありません。</li>
        <li><codeph>removedHandler()</codeph> は、<codeph>removed</codeph> イベントをリッスンします。このイベントは、(四角形がクリックされて) 四角形が表示リストから除去されたときに送出されます。</li>
        <li><codeph>clickHandler()</codeph> は、<codeph>click</codeph> イベントをリッスンします。このイベントはオレンジ色の四角形がクリックされると送出されます。</li>
        <li><codeph>renderHandler()</codeph> は、表示リストの更新後に <codeph>render</codeph> イベントをリッスンします。</li>
  </ul></li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class DisplayObjectExample extends Sprite {
        public function DisplayObjectExample() {
            var child:CustomDisplayObject = new CustomDisplayObject();
            addChild(child);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.*;

class CustomDisplayObject extends Sprite {
    private var bgColor:uint = 0xFFCC00;
    private var size:uint    = 80;

    public function CustomDisplayObject() {
        draw();
        addEventListener(Event.ADDED, addedHandler);
        addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        addEventListener(Event.REMOVED, removedHandler);
        addEventListener(MouseEvent.CLICK, clickHandler);
        addEventListener(Event.RENDER, renderHandler);
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }

    private function clickHandler(event:MouseEvent):void {
        trace("clickHandler: " + event);
        parent.removeChild(this);
    }

    private function addedHandler(event:Event):void {
        trace("addedHandler: " + event);
        stage.scaleMode = StageScaleMode.NO_SCALE;
        stage.align = StageAlign.TOP_LEFT;
        stage.addEventListener("resize", resizeHandler);
    }

    private function enterFrameHandler(event:Event):void {
        trace("enterFrameHandler: " + event);
        removeEventListener("enterFrame", enterFrameHandler);
    }

    private function removedHandler(event:Event):void {
        trace("removedHandler: " + event);
        stage.removeEventListener("resize", resizeHandler);
    }

    private function renderHandler(event:Event):void {
        trace("renderHandler: " + event);
    }

    private function resizeHandler(event:Event):void {
        trace("resizeHandler: " + event);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.RENDER_render"><apiName>render</apiName><shortdesc>
 [ブロードキャストイベント] 表示リストが更新およびレンダリングされようとしているときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RENDER</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [ブロードキャストイベント] 表示リストが更新およびレンダリングされようとしているときに送出されます。このイベントは、表示リストのレンダリング前に、このイベントをリッスンしているオブジェクトが変更を行う最後の機会を提供します。Stage オブジェクトの <codeph>invalidate()</codeph> メソッドは、<codeph>render</codeph> イベントを送出させるたびに呼び出す必要があります。 <codeph>Render</codeph> イベントは、<codeph>Stage.invalidate()</codeph> を呼び出したオブジェクトとの間に相互の信頼関係があるオブジェクトにしか送出されません。このイベントはブロードキャストイベントであるため、このイベントに登録されているリスナーを持つすべての表示イベントによって送出されます。
 
 <p><b>注意：</b>表示がレンダリングされない場合、このイベントは送出されません。 これが該当するのは、コンテンツが最小化または非表示になっている場合です。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_FROM_STAGE_removedFromStage"><apiName>removedFromStage</apiName><shortdesc>
 表示オブジェクトが、直接、または表示オブジェクトを含むサブツリーの削除により、表示リストから削除されようとしているときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED_FROM_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 表示オブジェクトが、直接、または表示オブジェクトを含むサブツリーの削除により、表示リストから削除されようとしているときに送出されます。このイベントを生成する DisplayObjectContainer クラスの 2 つのメソッドは、<codeph>removeChild()</codeph> および <codeph>removeChildAt()</codeph> の 2 つのエディションがあります。 
 
 <p>さらに、新しいオブジェクトの領域を確保するためにオブジェクトを削除する必要がある場合には、DisplayObjectContainer オブジェクトの <codeph>addChild()</codeph>、<codeph>addChildAt()</codeph>、および <codeph>setChildIndex()</codeph> もまたこのイベントを生成します。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_removed"><apiName>removed</apiName><shortdesc>
 表示オブジェクトが表示リストから削除されようとしているときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 表示オブジェクトが表示リストから削除されようとしているときに送出されます。このイベントを生成する DisplayObjectContainer クラスの 2 つのメソッドは、<codeph>removeChild()</codeph> および <codeph>removeChildAt()</codeph> の 2 つのエディションがあります。 
 
 <p>さらに、新しいオブジェクトの領域を確保するためにオブジェクトを削除する必要がある場合には、DisplayObjectContainer オブジェクトの <codeph>addChild()</codeph>、<codeph>addChildAt()</codeph>、および <codeph>setChildIndex()</codeph> もまたこのイベントを生成します。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.EXIT_FRAME_exitFrame"><apiName>exitFrame</apiName><shortdesc>
 [ブロードキャストイベント] 再生ヘッドが現在のフレームを終了するときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXIT_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [ブロードキャストイベント] 再生ヘッドが現在のフレームを終了するときに送出されます。すべてのフレームスクリプトが実行されています。再生ヘッドが移動しない場合、またはフレームが 1 つしか存在しない場合、このイベントはフレームレートに合わせて継続的に送出されます。このイベントはブロードキャストイベントであるため、このイベントに登録されているリスナーを持つすべての表示イベントによって送出されます。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.FRAME_CONSTRUCTED_frameConstructed"><apiName>frameConstructed</apiName><shortdesc>
 [ブロードキャストイベント] フレーム表示オブジェクトのコンストラクターが実行した後で、かつフレームスクリプトが実行される前に送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.FRAME_CONSTRUCTED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [ブロードキャストイベント] フレーム表示オブジェクトのコンストラクターが実行した後で、かつフレームスクリプトが実行される前に送出されます。再生ヘッドが移動しない場合、またはフレームが 1 つしか存在しない場合、このイベントはフレームレートに合わせて継続的に送出されます。 このイベントはブロードキャストイベントであるため、このイベントに登録されているリスナーを持つすべての表示イベントによって送出されます。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ENTER_FRAME_enterFrame"><apiName>enterFrame</apiName><shortdesc>
 [ブロードキャストイベント] 再生ヘッドが新しいフレームに入るときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ENTER_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [ブロードキャストイベント] 再生ヘッドが新しいフレームに入るときに送出されます。再生ヘッドが移動しない場合、またはフレームが 1 つしか存在しない場合、このイベントはフレームレートに合わせて継続的に送出されます。 このイベントはブロードキャストイベントであるため、このイベントに登録されているリスナーを持つすべての表示イベントによって送出されます。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_TO_STAGE_addedToStage"><apiName>addedToStage</apiName><shortdesc>
 表示オブジェクトが、直接、または表示オブジェクトを含むサブツリーの追加により、ステージ上の表示リストに追加されたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED_TO_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 表示オブジェクトが、直接、または表示オブジェクトを含むサブツリーの追加により、ステージ上の表示リストに追加されたときに送出されます。<codeph>DisplayObjectContainer.addChild()</codeph> メソッドおよび <codeph>DisplayObjectContainer.addChildAt()</codeph> メソッドがこのイベントをトリガーします。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_added"><apiName>added</apiName><shortdesc>
 表示オブジェクトが表示リストに追加されたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 表示オブジェクトが表示リストに追加されたときに送出されます。<codeph>DisplayObjectContainer.addChild()</codeph> メソッドおよび <codeph>DisplayObjectContainer.addChildAt()</codeph> メソッドがこのイベントをトリガーします。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:DisplayObject:getBounds"><apiName>getBounds</apiName><shortdesc>
     targetCoordinateSpace オブジェクトの座標系を基準にして、表示オブジェクトの領域を定義する矩形を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>targetCoordinateSpace</codeph> オブジェクトの座標系を基準とする、表示オブジェクトの領域を定義する矩形です。
     
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>使用する座標系を定義する表示オブジェクトです。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     <codeph>targetCoordinateSpace</codeph> オブジェクトの座標系を基準にして、表示オブジェクトの領域を定義する矩形を返します。以下のコードは、どんな <codeph>targetCoordinateSpace</codeph> パラメーターをメソッドに渡すかに応じて、様々な矩形が返されることを示しています。
     
     <codeblock>
     var container:Sprite = new Sprite();
     container.x = 100;
     container.y = 100;
     this.addChild(container);
     var contents:Shape = new Shape();
     contents.graphics.drawCircle(0,0,100);
     container.addChild(contents);
     trace(contents.getBounds(container));
      // (x=-100, y=-100, w=200, h=200)
     trace(contents.getBounds(this));
      // (x=0, y=0, w=200, h=200)
     </codeblock>
     
     
     <p><b>注意：</b>表示オブジェクトのローカル座標を表示座標に、または表示座標をローカル座標に変換するには、それぞれ <codeph>localToGlobal()</codeph> および <codeph>globalToLocal()</codeph> メソッドを使用します。</p>
     
     <p><codeph>getBounds()</codeph> メソッドは <codeph>getRect()</codeph> メソッドに似ていますが、<codeph>getBounds()</codeph> メソッドから返される矩形にはシェイプの線が含まれるのに対し、<codeph>getRect()</codeph> メソッドから返される矩形には含まれません。例については、<codeph>getRect()</codeph> メソッドに関する説明を参照してください。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getRect()"><linktext>getRect()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:getRect"><apiName>getRect</apiName><shortdesc>
    シェイプ上の線を除き、targetCoordinateSpace パラメーターによって定義された座標系に基づいて、表示オブジェクトの境界を定義する矩形を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>targetCoordinateSpace</codeph> オブジェクトの座標系を基準とする、表示オブジェクトの領域を定義する矩形です。
    
    </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>使用する座標系を定義する表示オブジェクトです。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    シェイプ上の線を除き、<codeph>targetCoordinateSpace</codeph> パラメーターによって定義された座標系に基づいて、表示オブジェクトの境界を定義する矩形を返します。<codeph>getRect()</codeph> メソッドから返される値は、<codeph>getBounds()</codeph> メソッドから返される値と同じか、それより小さくなります。
    
    <p><b>注意：</b> 表示オブジェクトのローカル座標をステージ座標に、またはステージ座標をローカル座標に変換するには、それぞれ <codeph>localToGlobal()</codeph> および <codeph>globalToLocal()</codeph> メソッドを使用します。</p>
    
    </apiDesc><example conref="examples\DisplayObject.getRect.1.as"> 次の例では、<codeph>getBounds()</codeph> メソッドが、<codeph>getRect()</codeph> メソッドを使用したときよりも大きい矩形が返される場合があることを示しています。そうなる理由は、追加的な領域が線に必要となるためです。この場合、<codeph>triangle</codeph> スプライトには余分な線が含まれます。これは、<codeph>width</codeph> パラメーターおよび <codeph>jointStyle</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドのパラメーター）があるためです。<codeph>trace()</codeph> の出力（最後の 2 行）は、<codeph>getRect()</codeph> 矩形と <codeph>getBounds()</codeph> 矩形の違いを示しています。
<codeblock>

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.geom.Rectangle;

var triangle:Sprite = new Sprite();
var color:uint = 0xFF0044;
var width:Number = 20;
var alpha:Number = 1.0;
var pixelHinting:Boolean = true;
var scaleMode:String = LineScaleMode.NORMAL;
var caps:String = CapsStyle.SQUARE;
var joints:String = JointStyle.MITER;
triangle.graphics.lineStyle(width, color, alpha, pixelHinting, scaleMode, caps, joints);

var triangleSide:Number = 100;
triangle.graphics.moveTo(0, 0);
triangle.graphics.lineTo(0, triangleSide);
triangle.graphics.lineTo(triangleSide, triangleSide);
triangle.graphics.lineTo(0, 0);

addChild(triangle);

trace(triangle.getBounds(this)); // (x=-10, y=-24.1, w=134.10000000000002, h=134.1)
trace(triangle.getRect(this));     // (x=0, y=0, w=100, h=100)
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getBounds()"><linktext>getBounds()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal"><apiName>globalToLocal</apiName><shortdesc>
     point オブジェクトをステージ（グローバル）座標から表示オブジェクトの（ローカル）座標に変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>表示オブジェクトからの相対座標を持つ Point オブジェクトです。
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point クラスを使って作成されるオブジェクトです。Point オブジェクトは、<i>x</i> および <i>y</i> 座標をプロパティとして指定します。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText><codeph>point</codeph> オブジェクトをステージ（グローバル）座標から表示オブジェクトの（ローカル）座標に変換します。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <codeph>point</codeph> オブジェクトをステージ（グローバル）座標から表示オブジェクトの（ローカル）座標に変換します。
     
     <p>このメソッドを使用するには、まず Point クラスのインスタンスを作成してください。割り当てられる <i>x</i> 値と <i>y</i> 値は、メイン表示領域の起点 (0,0) からの相対値であるため、これらの値はグローバル座標を表します。次に、Point インスタンスを <codeph>globalToLocal()</codeph> メソッドにパラメーターとして渡します。このメソッドは、Stage の起点ではなく、表示オブジェクトの起点からの相対値である <i>x</i> 値と <i>y</i> 値を持つ新しい Point オブジェクトを返します。</p>
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> 次のコードでは、Shape オブジェクトを作成し、パラメーターとして異なるポイントを使用して、<codeph>hitTestPoint()</codeph> メソッドの呼び出し結果を表示します。<codeph>globalToLocal()</codeph> メソッドは、ポイントをステージ座標からシェイプの座標空間に変換します。
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point クラス</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal3D"><apiName>globalToLocal3D</apiName><shortdesc>
     ステージ（グローバル）座標の 2 次元のポイントを 3 次元の表示オブジェクトの（ローカル）座標に変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>3 次元の表示オブジェクトを基準とした座標を持つ Vector3D オブジェクトです。 
     
     </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>グローバル座標の x 座標と y 座標を表す 2 次元の Point オブジェクトです。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     ステージ（グローバル）座標の 2 次元のポイントを 3 次元の表示オブジェクトの（ローカル）座標に変換します。
     
     <p>このメソッドを使用するには、まず Point クラスのインスタンスを作成してください。 Point オブジェクトに割り当てられる x 値と y 値は、メイン表示領域の起点 (0,0) からの相対値であるため、これらの値はグローバル座標を表します。次に、Point オブジェクトを <codeph>globalToLocal3D()</codeph> メソッドの <codeph>point</codeph> パラメーターとして渡します。このメソッドは、3 次元の表示オブジェクトの基点を基準とした <codeph>x</codeph> 値、<codeph>y</codeph> 値、および <codeph>z</codeph> 値を含む Vector3D オブジェクトとして 3 次元座標を返します。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestObject"><apiName>hitTestObject</apiName><shortdesc>
     表示オブジェクトの境界ボックスを評価して、obj 表示オブジェクトの境界ボックスと重複または交差するかどうかを調べます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>表示オブジェクトの境界ボックスが交差する場合は <codeph>true</codeph> を返します。交差しない場合は <codeph>false</codeph> を返します。
     
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>検査の対象となる表示オブジェクトです。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>表示オブジェクトの境界ボックスを評価して、パラメーターとして渡された表示オブジェクトの境界ボックスと重複または交差するかどうかを調べます。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     表示オブジェクトの境界ボックスを評価して、<codeph>obj</codeph> 表示オブジェクトの境界ボックスと重複または交差するかどうかを調べます。
     
     </apiDesc><example conref="examples\DisplayObject.hitTestObject.1.as"> 次のコードでは、3 つの Shape オブジェクトを作成し、<codeph>hitTestObject()</codeph> メソッドの呼び出し結果を示します。circle2 と circle3 は重複しませんが、境界ボックスは重複します。そのため、circle2 と circle3 のヒットテストでは <codeph>true</codeph> が返されます。
<codeblock>

import flash.display.Shape;

var circle1:Shape = new Shape();
circle1.graphics.beginFill(0x0000FF);
circle1.graphics.drawCircle(40, 40, 40);
addChild(circle1);

var circle2:Shape = new Shape();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(40, 40, 40);
circle2.x = 50;
addChild(circle2);

var circle3:Shape = new Shape();
circle3.graphics.beginFill(0xFF0000);
circle3.graphics.drawCircle(40, 40, 40);
circle3.x = 100;
circle3.y = 67;
addChild(circle3);

trace(circle1.hitTestObject(circle2)); // true
trace(circle1.hitTestObject(circle3)); // false
trace(circle2.hitTestObject(circle3)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestPoint"><apiName>hitTestPoint</apiName><shortdesc>
     表示オブジェクトを評価して、x および y パラメーターで指定されたポイントと重複または交差するかどうかを調べます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定されたポイントと表示オブジェクトが重複または交差する場合は <codeph>true</codeph>、そうでなければ <codeph>false</codeph> です。
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>このオブジェクトの検査の基準となる <i>x</i> 座標です。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>このオブジェクトの検査の基準となる <i>y</i> 座標です。
     
     </apiDesc></apiParam><apiParam><apiItemName>shapeFlag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>オブジェクトの実際のピクセルと比較して検査する場合は <codeph>true</codeph>、境界ボックスと比較して検査する場合は <codeph>false</codeph> です。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>表示オブジェクトを評価して、x および y によって指定されるポイントと重複または交差するかどうかを調べます。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     表示オブジェクトを評価して、<codeph>x</codeph> および <codeph>y</codeph> パラメーターで指定されたポイントと重複または交差するかどうかを調べます。<codeph>x</codeph> および <codeph>y</codeph> パラメーターは、表示オブジェクトが含まれる表示オブジェクトコンテナではなく Stage の座標空間内のポイントを指定します（その表示オブジェクトコンテナが Stage の場合を除く）。
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> 次のコードでは、Shape オブジェクトを作成し、パラメーターとして異なるポイントを使用して、<codeph>hitTestPoint()</codeph> メソッドの呼び出し結果を表示します。<codeph>globalToLocal()</codeph> メソッドは、ポイントをステージ座標からシェイプの座標空間に変換します。
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:local3DToGlobal"><apiName>local3DToGlobal</apiName><shortdesc>
     3 次元の表示オブジェクトの（ローカル）座標の 3 次元のポイントをステージ（グローバル）座標の 2 次元のポイントに変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>3 次元のポイントを 2 次元空間で表す 2 次元のポイント。
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point3d</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>3 次元の表示オブジェクトの 3 次元のポイントまたは座標を含む Vector3D オブジェクト。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     3 次元の表示オブジェクトの（ローカル）座標の 3 次元のポイントをステージ（グローバル）座標の 2 次元のポイントに変換します。
     
     <p>例えば、<codeph>display.Graphics</codeph> のメソッドを使用して描画する場合は、2 次元座標（x,y）のみを使用できます。3 次元のオブジェクトを描画するには、表示オブジェクトの 3 次元座標を 2 次元座標にマッピングする必要があります。まず、3 次元の表示オブジェクトの x 座標、y 座標、および z 座標を保持する Vector3D クラスのインスタンスを作成します。次に、Vector3D オブジェクトを <codeph>local3DToGlobal()</codeph> メソッドの <codeph>point3d</codeph> パラメーターとして渡します。このメソッドからは 2 次元の Point オブジェクトが返されます。これを Graphics API で使用すると、3 次元のオブジェクトを描画できます。</p>
     
     
     </apiDesc><example conref="examples\Local3DToGlobalExample.as"> この例では、<codeph>display.Graphics</codeph> のメソッドを使用して、2 次元空間に簡単な 3 次元の立方体を描画します。<codeph>this</codeph> 表示オブジェクトの位置はオフセットされるため、立方体の基準点はその中心になります。Vector3D オブジェクトのベクターには、立方体の 3 次元座標が保持されます。最初に立方体の上部が描画され、次に下部が描画され、最後に上部の四隅と下部の四隅が接続されます。<codeph>local3DToGlobal()</codeph> メソッドを使用するには、立方体を表示オブジェクトのコンテナに追加してから立方体を描画する必要があります。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.geom.*;

    public class Local3DToGlobalExample extends MovieClip {
        private var myCube:Sprite = new Sprite();
        private var v8:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(8);

        public function Local3DToGlobalExample():void {
            this.x = -(this.stage.stageWidth / 2);
            this.y = -(this.stage.stageWidth / 2);

            v8[0] = new Vector3D(-40,-40,-40);
            v8[1] = new Vector3D(40,-40,-40);
            v8[2] = new Vector3D(40,-40,40);
            v8[3] = new Vector3D(-40,-40,40);
            v8[4] = new Vector3D(-40,100,-40);
            v8[5] = new Vector3D(40,100,-40);
            v8[6] = new Vector3D(40,100,40);
            v8[7] = new Vector3D(-40,100,40);

            myCube.x = (this.stage.stageWidth / 2);
            myCube.y = (this.stage.stageWidth / 2);
            myCube.z = 1;
            addChild(myCube);

            Cube();         
        }

        private function Cube():void {
            var ps:Point = new Point(0,0);

            myCube.graphics.lineStyle(2,0xFF0000);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:localToGlobal"><apiName>localToGlobal</apiName><shortdesc>
     point オブジェクトを表示オブジェクトの（ローカル）座標からステージ（グローバル）座標に変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>ステージからの相対座標を持つ Point オブジェクトです。
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Point クラスを使用し、<i>x</i> および <i>y</i> 座標をプロパティとして指定して作成されるポイントの名前または識別子です。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     <codeph>point</codeph> オブジェクトを表示オブジェクトの（ローカル）座標からステージ（グローバル）座標に変換します。
     
     <p>このメソッドを使用すれば、特定の表示オブジェクトの起点 (0,0) との相対値（ローカル座標）からステージの起点との相対値（グローバル座標）に、任意の <i>x</i> および <i>y</i> 座標を変換できます。</p>
     
     <p>このメソッドを使用するには、まず Point クラスのインスタンスを作成してください。割り当てられる <i>x</i> 値と <i>y</i> 値は、表示オブジェクトの起点からの相対値であるため、これらの値はローカル座標を表します。</p>
     
     <p>次に、作成した Point インスタンスを <codeph>localToGlobal()</codeph> メソッドにパラメーターとして渡します。このメソッドは、表示オブジェクトの起点ではなく、Stage の起点からの相対値である <i>x</i> 値と <i>y</i> 値を持つ新しい Point オブジェクトを返します。</p>
     
     </apiDesc><example conref="examples\DisplayObject.localToGlobal.1.as"> 次のコードでは、Sprite オブジェクトを作成します。スプライトの <codeph>mouseX</codeph> プロパティおよび <codeph>mouseY</codeph> プロパティは、表示オブジェクトの座標空間内にあります。このコードは、<codeph>localToGlobal()</codeph> メソッドを使用して、これらのプロパティをグローバル（ステージ）座標に変換します。
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.Point;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
square.x = 100;
square.y = 200;

addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates)

function traceCoordinates(event:MouseEvent):void {
    var clickPoint:Point = new Point(square.mouseX, square.mouseY);
    trace("display object coordinates:", clickPoint);
    trace("stage coordinates:", square.localToGlobal(clickPoint));
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point クラス</linktext></link></related-links></apiOperation><apiValue id="flash.display:DisplayObject:accessibilityProperties:get"><apiName>accessibilityProperties</apiName><shortdesc>
     この表示オブジェクトの現在のアクセシビリティオプションです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.accessibility:AccessibilityProperties</apiValueClassifier></apiValueDef><apiDesc>
     この表示オブジェクトの現在のアクセシビリティオプションです。<codeph>accessibilityProperties</codeph> プロパティ、または <codeph>accessibilityProperties</codeph> 内のいずれかのフィールドを変更した場合、変更内容を有効にするには、<codeph>Accessibility.updateProperties()</codeph> メソッドを呼び出す必要があります。
     
     <p class="flashonly"><b>注意：</b>Flash オーサリング環境で作成されたオブジェクトの場合、そのオブジェクトのアクセシビリティパネルに入力した情報が <codeph>accessibilityProperties</codeph> の値に再設定されます。</p>
     
     </apiDesc><example conref="examples\DisplayObject.accessibilityProperties.1.as"> 次の例では、単純な AccessibilityProperties オブジェクトを TextField インスタンスに割り当てる方法を示します。
<codeblock>

import flash.text.TextField;
import flash.accessibility.AccessibilityProperties;
import flash.accessibility.Accessibility;
import flash.system.Capabilities;

var tf:TextField = new TextField();
tf.text = "hello";

var accessProps:AccessibilityProperties = new AccessibilityProperties();
accessProps.name = "Greeting";

tf.accessibilityProperties = accessProps;

if (Capabilities.hasAccessibility) {
    Accessibility.updateProperties();
}

trace(tf.accessibilityProperties.name); // Greeting
</codeblock></example></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link><link href="flash.accessibility.xml#AccessibilityProperties"><linktext>flash.accessibility.AccessibilityProperties</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:alpha:get"><apiName>alpha</apiName><shortdesc>
     指定されたオブジェクトのアルファ透明度値を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指定されたオブジェクトのアルファ透明度値を示します。有効な値は 0（完全な透明）～ 1（完全な不透明）です。デフォルト値は 1 です。<codeph>alpha</codeph> が 0 に設定されている表示オブジェクト<i>は</i>、表示されない場合でも、アクティブです。
     
     </apiDesc><example conref="examples\DisplayObject.alpha.1.as"> 次のコードでは、スプライト上にマウスが移動したときに、スプライトの <codeph>alpha</codeph> プロパティを 50% に設定します。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.alpha = 0.5;
}

function restoreObject(event:MouseEvent):void {
    event.target.alpha = 1.0;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:blendMode:get"><apiName>blendMode</apiName><shortdesc>
     使用するブレンドモードを指定する BlendMode クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     使用するブレンドモードを指定する BlendMode クラスの値です。内部的には、2 つの方法でビットマップを描画できます。ブレンドモードを有効にした場合、または外部クリッピングマスクを使用する場合には、ビットマップで塗りつぶされた四角形シェイプをベクターレンダーに追加することによってビットマップが描画されます。このプロパティを無効な値に設定しようとすると、Flash Player または Adobe AIR は値を <codeph>BlendMode.NORMAL</codeph> に設定します。
     
     <p><codeph>blendMode</codeph> プロパティは、表示オブジェクトの各ピクセルに影響します。 各ピクセルは、3 つの要素カラー（赤、緑、青）で構成されており、各要素カラーは 0x00 ～ 0xFF の値を持ちます。Flash Player または Adobe AIR は、ムービークリップ内の 1 つのピクセルの各要素カラーを、背景のピクセルの対応するカラーと比較します。 例えば、<codeph>blendMode</codeph> が <codeph>BlendMode.LIGHTEN</codeph> に設定されている場合、Flash Player または Adobe AIR は表示オブジェクトの赤の値と背景の赤の値とを比較して、明るい方の値を表示色の赤の成分として使用します。</p>
     
     <p>次の表では、<codeph>blendMode</codeph> の設定について説明します。BlendMode クラスは、使用可能なストリング値を定義します。表の中の図は、別の表示オブジェクト（1）に重なった円形の表示オブジェクト（2）に適用される <codeph>blendMode</codeph> 値を示しています。</p>
     
     
     <p>
      <adobeimage alt="四角形の数字 1" href="../../images/blendMode-0a.jpg"/> <adobeimage alt="円の数字 2" href="../../images/blendMode-0b.jpg"/>
     
     </p>
     
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="3"><thead><row><entry>BlendMode 定数</entry><entry>図</entry><entry>説明</entry></row></thead><tbody><row valign="top">
     <entry><codeph>BlendMode.NORMAL</codeph></entry>
     <entry><adobeimage alt="ブレンドモード NORMAL" href="../../images/blendMode-1.jpg"/></entry>
     <entry>表示オブジェクトは、背景の前に表示されます。表示オブジェクトのピクセル値は、背景のピクセル値より優先されます。表示オブジェクトが透明な部分では、背景が表示されます。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LAYER</codeph></entry>
     <entry><adobeimage alt="ブレンドモード LAYER" href="../../images/blendMode-2.jpg"/></entry>
     
     <entry>表示オブジェクトに関する透明度グループを強制的に作成します。つまり、表示オブジェクトが処理される前に、一時バッファー内で表示オブジェクトが事前に構成されます。ビットマップキャッシュを使って表示オブジェクトが事前キャッシュされる場合、または表示オブジェクトが、<codeph>blendMode</codeph> が <codeph>BlendMode.NORMAL</codeph> 以外に設定された子オブジェクトを少なくとも 1 つ含む表示オブジェクトコンテナである場合には、これが自動的に実行されます。
     </entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.MULTIPLY</codeph></entry>
     <entry><adobeimage alt="ブレンドモード MULTIPLY" href="../../images/blendMode-3.jpg"/></entry>
     
     <entry>表示オブジェクトの要素カラーの値と背景色の要素カラーの値を乗算した後、0xFF で割って正規化し、色を暗くします。この設定は、シャドウや深度効果によく使用されます。
     
     <p>例えば、表示オブジェクトのピクセルの要素カラー（赤など）と背景のピクセルの対応するカラーの値が共に 0x88 の場合、乗算した結果は 0x4840 です。0xFF で除算すると、その要素カラーの値は 0x48 になります。これは、表示オブジェクトまたは背景の色よりも暗くなります。</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SCREEN</codeph></entry>
     <entry><adobeimage alt="ブレンドモード SCREEN" href="../../images/blendMode-4.jpg"/></entry>
     
     <entry>表示オブジェクトの色の補数（逆）と背景色の補数を乗算して、ブリーチ効果を得ます。この設定は、ハイライトや、表示オブジェクトの黒い領域の削除によく使用されます。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LIGHTEN</codeph></entry>
     <entry><adobeimage alt="ブレンドモード LIGHTEN" href="../../images/blendMode-5.jpg"/></entry>
     
     <entry>表示オブジェクトの要素カラーと背景色のうち明るい方（値が大きい方）の色を選択します。この設定は、重ね合わせタイプによく使用されます。
     
     <p>例えば、表示オブジェクトのピクセルの RGB 値が 0xFFCC33 で、背景のピクセルの RGB 値が 0xDDF800 の場合、0xFF > 0xDD、0xCC &lt; 0xF8、および 0x33 > 0x00 = 33 であるので、表示されるピクセルの RGB 値は 0xFFF833 になります。</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DARKEN</codeph></entry>
     <entry><adobeimage alt="ブレンドモード DARKEN" href="../../images/blendMode-6.jpg"/></entry>
     
     <entry>表示オブジェクトの要素カラーと背景色のうち暗い方（値が小さい方）の色を選択します。この設定は、重ね合わせタイプによく使用されます。
     
     <p>例えば、表示オブジェクトのピクセルの RGB 値が 0xFFCC33, で、背景のピクセルの RGB 値が 0xDDF800 の場合、0xFF > 0xDD、0xCC &lt; 0xF8、0x33 > 0x00 = 33 であるので、表示されるピクセルの RGB 値は 0xDDCC00 になります。</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DIFFERENCE</codeph></entry>
     <entry><adobeimage alt="ブレンドモード DIFFERENCE" href="../../images/blendMode-7.jpg"/></entry>
     
     <entry>表示オブジェクトの要素カラーと背景色を比較し、2 つの要素カラーのうち明るい方の値から暗い方の値を差し引きます。この設定は、明るい色によく使用されます。
     
     <p>例えば、表示オブジェクトの 1 つのピクセルの RGB 値が 0xFFCC33 で、背景のピクセルの RGB 値が 0xDDF800 の場合、0xFF - 0xDD = 0x22、0xF8 - 0xCC = 0x2C、0x33 - 0x00 = 0x33 であるため、表示されるピクセルの RGB 値は 0x222C33 になります。</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ADD</codeph></entry>
     <entry><adobeimage alt="ブレンドモード ADD" href="../../images/blendMode-8.jpg"/></entry>
     
     <entry>表示オブジェクトの要素カラーの値を背景色に加算し、その際に上限 0xFF を適用します。この設定は、2 つのオブジェクト間で色を明るくするディゾルブをアニメーションにするときによく使用されます。
     
     <p>例えば、表示オブジェクトのピクセルの RGB 値が 0xAAA633 で、背景のピクセルの RGB 値が 0xDD2200 の場合、0xAA + 0xDD > 0xFF、0xA6 + 0x22 = 0xC8、および 0x33 + 0x00 = 0x33 であるので、表示されるピクセルの RGB 値は 0xFFC833 になります。</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.SUBTRACT</codeph></entry>
     <entry><adobeimage alt="ブレンドモード SUBTRACT" href="../../images/blendMode-9.jpg"/></entry>
     
     <entry>下限を 0 として、表示オブジェクトの要素カラーの値をその背景色の値から減算します。この設定は、2 つのオブジェクト間で色を暗くするディゾルブをアニメーションにするときによく使用されます。
     
     <p>例えば、表示オブジェクトの 1 つのピクセルの RGB 値が 0xAA2233 で、背景のピクセルの RGB 値が 0xDDA600 の場合、0xDD - 0xAA = 0x33、0xA6 - 0x22 = 0x84、0x00 - 0x33 &lt; 0x00 であるので、表示されるピクセルの RGB 値は 0x338400 になります。</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.INVERT</codeph></entry>
     <entry><adobeimage alt="ブレンドモード INVERT" href="../../images/blendMode-10.jpg"/></entry>
     
     <entry>背景を反転します。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ALPHA</codeph></entry>
     <entry><adobeimage alt="ブレンドモード ALPHA" href="../../images/blendMode-11.jpg"/></entry>
     
     <entry>表示オブジェクトの各ピクセルのアルファ値を背景に適用します。これを行うには、親表示オブジェクトの <codeph>blendMode</codeph> が <codeph>BlendMode.LAYER</codeph> に設定されている必要があります。例えば、図の親表示オブジェクト（白い背景）は、<codeph>blendMode = BlendMode.LAYER</codeph> に設定されています。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ERASE</codeph></entry>
     <entry><adobeimage alt="ブレンドモード ERASE" href="../../images/blendMode-12.jpg"/></entry>
     
     <entry>表示オブジェクトのアルファ値に基づいて背景を消去します。これを行うには、親表示オブジェクトの <codeph>blendMode</codeph> が <codeph>BlendMode.LAYER</codeph> に設定されている必要があります。例えば、図の親表示オブジェクト（白い背景）は、<codeph>blendMode = BlendMode.LAYER</codeph> に設定されています。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.OVERLAY</codeph></entry>
     <entry><adobeimage alt="ブレンドモード OVERLAY" href="../../images/blendMode-13.jpg"/></entry>
     
     <entry>背景の暗さに基づいて、各ピクセルの色を調整します。背景が 50% グレーよりも明るい場合、表示オブジェクトと背景の色が網がけされ、より明るくなります。背景が 50% グレーよりも暗い場合、2 つの色が乗算されて、より暗くなります。この設定は、シャドウ効果によく使用されます。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.HARDLIGHT</codeph></entry>
     <entry><adobeimage alt="ブレンドモード HARDLIGHT" href="../../images/blendMode-14.jpg"/></entry>
     
     <entry>表示オブジェクトの暗さに基づいて、各ピクセルの色を調整します。表示オブジェクトが 50% グレーよりも明るい場合、表示オブジェクトと背景の色が網がけされ、より明るくなります。表示オブジェクトが 50% グレーよりも暗い場合、2 つの色が乗算されて、より暗くなります。この設定は、シャドウ効果によく使用されます。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SHADER</codeph></entry>
     <entry align="center" valign="middle">N/A</entry>
     
     <entry>カスタムシェーダールーチンを使用して、カラーを調整します。使用するシェーダーは、<codeph>blendShader</codeph> プロパティに割り当てられた Shader インスタンスとして指定されます。Shader インスタンスに表示オブジェクトの <codeph>blendShader</codeph> プロパティを設定すると、表示オブジェクトの <codeph>blendMode</codeph> プロパティが <codeph>BlendMode.SHADER</codeph> に自動的に設定されます。<codeph>blendShader</codeph> プロパティを先に設定しないで <codeph>blendMode</codeph> プロパティを <codeph>BlendMode.SHADER</codeph> に設定すると、<codeph>blendMode</codeph> プロパティは <codeph>BlendMode.NORMAL</codeph> に設定されます。</entry>
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\DisplayObject.blendMode.1.as"> 次のコードでは、四角形と円の 2 つのスプライトオブジェクトを作成し、マウスポインターが円の上に移動すると、前景の円のブレンドモードを <codeph>BlendMode.SUBTRACT</codeph> に設定します。
<codeblock>
import flash.display.Sprite;
import flash.display.BlendMode;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF88CC);
square.graphics.drawRect(0, 0, 80, 80);
addChild(square);

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.SUBTRACT;
}

function restoreObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.NORMAL;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>blendShader</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:cacheAsBitmap:get"><apiName>cacheAsBitmap</apiName><shortdesc>
     true に設定されている場合、表示オブジェクトの内部ビットマップ表現が Flash Player または Adobe AIR にキャッシュされます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>この DisplayObject をビットマップとしてキャッシュするかどうかを示します。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     <codeph>true</codeph> に設定されている場合、表示オブジェクトの内部ビットマップ表現が Flash Player または Adobe AIR にキャッシュされます。 このキャッシュ処理により、複雑なベクターコンテンツを含んでいる表示オブジェクトのパフォーマンスを向上できます。
     
     <p>ビットマップがキャッシュされている表示オブジェクトのすべてのベクターデータは、メイン表示ではなくビットマップに描画されます。その後、ビットマップは、最も近いピクセル境界に吸着された非伸縮、非回転のピクセルとして、メイン表示にコピーされます。ピクセルは、親オブジェクトと 1 対 1 でマップされます。ビットマップの境界が変更されると、ビットマップは伸縮されるのではなく、再作成されます。</p>
     
     <p><codeph>cacheAsBitmap</codeph> プロパティが <codeph>true</codeph> に設定されていない限り、内部ビットマップは作成されません。</p>
     
     <p><codeph>cacheAsBitmap</codeph> プロパティを <codeph>true</codeph> に設定した後、レンダリングは変更されませんが、表示オブジェクトはピクセルへの吸着を自動的に実行します。アニメーションの速度は、ベクターコンテンツの複雑さに応じて大幅に速くなる可能性があります。
     </p>
     
     <p>フィルターを表示オブジェクトに適用すると、<codeph>cacheAsBitmap</codeph> プロパティは常に自動的に <codeph>true</codeph> に設定されます（<codeph>filter</codeph> 配列が空でない場合）。また、表示オブジェクトにフィルターが適用される場合、<codeph>cacheAsBitmap</codeph> はその表示オブジェクトの <codeph>true</codeph> と報告されます（たとえプロパティを <codeph>false</codeph> に設定した場合でも）。表示オブジェクトのすべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> は以前の設定に戻ります。</p>
     
     <p>以下のような場合には、<codeph>cacheAsBitmap</codeph> プロパティが <codeph>true</codeph> に設定されていても表示オブジェクトはビットマップを使用せず、代わりにベクターデータから描画します。</p>
     
     <ul>
     
       <li>ビットマップが大きすぎます。AIR 1.5 および Flash Player 10 では、ビットマップイメージの最大サイズは幅または高さが 8,191 ピクセルです。ただし、総ピクセル数が 16,777,215 ピクセルを超えることはできません（したがって、ビットマップイメージの幅が 8,191 ピクセルであった場合、高さは 2,048 ピクセルまでしか指定できません）。Flash Player 9 以前では、制限は高さ 2,880 ピクセル、幅 2,880 ピクセルです。</li>
     
       <li>ビットマップが割り当てに失敗した場合（メモリ不足エラー）。 </li>
     
     </ul>
     
     <p><codeph>cacheAsBitmap</codeph> プロパティは、その内容がほぼ静的で、拡大や縮小、回転が頻繁に行われないムービークリップに最適です。そのようなムービークリップでは、<codeph>cacheAsBitmap</codeph> プロパティによって、ムービークリップの変換時（その <i>x</i> 位置と <i>y</i> 位置の変更時）にパフォーマンスが向上する可能性があります。</p>
     
     </apiDesc><example conref="examples\DisplayObject.cacheAsBitmap.1.as"> 次の例では、Shape インスタンスにドロップシャドウを適用します。その後、<codeph>cacheAsBitmap</codeph> プロパティの値（この値はフィルターの適用時に <codeph>true</codeph> に設定される）をトレースします。
<codeblock>
import flash.display.Sprite;
import flash.filters.DropShadowFilter

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);

addChild(circle);

trace(circle.cacheAsBitmap); // false

var filter:DropShadowFilter = new DropShadowFilter();
circle.filters = [filter];

trace(circle.cacheAsBitmap); // true
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:filters:get"><apiName>filters</apiName><shortdesc>
     表示オブジェクトに現在関連付けられている各フィルターオブジェクトが格納されているインデックス付きの配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc><codeph>filters</codeph> に ShaderFilter が含まれ、シェーダー出力タイプがこの操作に対応しない場合（シェーダーは <codeph>pixel4</codeph> 出力を指定する必要があります）。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>filters</codeph> に ShaderFilter が含まれ、シェーダーがイメージ出力を指定していないか、最初の入力が <codeph>image4</codeph> 入力でない場合。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>filters</codeph> に ShaderFilter が含まれ、シェーダーが指定したイメージ入力が存在しない場合。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>filters</codeph> に ShaderFilter、ByteArray、または Vector が含まれる場合。&lt;Number> インスタンスがシェーダー入力として使用され、ShaderInput オブジェクトの <codeph>width</codeph> および <codeph>height</codeph> プロパティが指定されていない、または指定された値が入力データのデータ量と一致しない場合。詳しくは、<codeph>ShaderInput.input</codeph> プロパティを参照してください。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     表示オブジェクトに現在関連付けられている各フィルターオブジェクトが格納されているインデックス付きの配列です。flash.filters パッケージには、使用可能な特定のフィルターを定義する複数のクラスが含まれています。
     
     <p>ActionScript コードを使用することにより、設計時または実行時に Flash オーサリングツールでフィルターを適用できます。ActionScript を使ってフィルターを適用するには、<codeph>filters</codeph> 配列全体の一時コピーを作成してその一時配列を変更した後、一時配列の値を <codeph>filters</codeph> 配列に割り当てて戻す必要があります。新しいフィルターオブジェクトを <codeph>filters</codeph> 配列に直接追加することはできません。</p>
     
     <p>ActionScript を使ってフィルターを追加するには、次の手順を実行する必要があります（ターゲット表示オブジェクトの名前を <codeph>myDisplayObject</codeph> とします）。</p>
     
     <ol>
     
       <li>適切なフィルタークラスのコンストラクターメソッドを使用して、新しいフィルターオブジェクトを作成します。</li>
     
       <li><codeph>myDisplayObject.filters</codeph> 配列の値を、<codeph>myFilters</codeph> などの名前の一時配列に代入します。</li>
     
       <li>新しいフィルターオブジェクトを一時配列 <codeph>myFilters</codeph> に追加します。</li>
     
       <li>一時配列の値を <codeph>myDisplayObject.filters</codeph> 配列に代入します。</li>
     
     </ol>
     
     <p><codeph>filters</codeph> 配列が未定義の場合、一時配列を使用する必要はありません。その代わりに、作成される 1 つまたは複数のフィルターオブジェクトを格納する配列リテラルを直接割り当てることができます。最初の例では、定義済みおよび未定義の <codeph>filters</codeph> 配列を処理するコードを使用して、ドロップシャドウフィルターを追加します。</p>
     
     <p>既存のフィルターオブジェクトを変更するには、次のように、<codeph>filters</codeph> 配列のコピーを変更する必要があります。</p>
     
     <ol>
     
       <li><codeph>filters</codeph> 配列の値を、<codeph>myFilters</codeph> などの名前の一時配列に代入します。</li>
     
       <li>一時配列 <codeph>myFilters</codeph> を使用してプロパティを変更します。例えば、配列内の最初のフィルターの quality プロパティを設定するには、次のようなコードを使用できます。<codeph>myFilters[0].quality = 1;</codeph></li>
     
       <li>一時配列の値を <codeph>filters</codeph> 配列に代入します。</li>
     
     </ol>
     
     <p>ロード時には、表示オブジェクトにフィルターが関連付けられている場合、透明なビットマップとして表示オブジェクト自身をキャッシュするようにマークされます。これ以降、表示オブジェクトに有効なフィルターリストがある限り、表示オブジェクトはビットマップとしてキャッシュされます。このソースビットマップは、フィルター効果のソースイメージとして使用されます。通常、それぞれの表示オブジェクトには 2 つのビットマップがあります。1 つはフィルター適用前の元の表示オブジェクトのビットマップ、もう 1 つはフィルター適用後の最終イメージのビットマップです。最終イメージはレンダリング時に使用されます。表示オブジェクトが変更されない限り、最終イメージを更新する必要はありません。</p>
     
     <p>flash.filters パッケージにはフィルター用のクラスが含まれます。例えば、DropShadow フィルターを作成するには、次のようにすることができます。</p>
     
     <codeblock>
     import flash.filters.DropShadowFilter
     var myFilter:DropShadowFilter = new DropShadowFilter (distance, angle, color, alpha, blurX, blurY, quality, inner, knockout)
     </codeblock>
     
     <p><codeph>is</codeph> 演算子を使用して、<codeph>filter</codeph> 配列内のそれぞれのインデックス位置に割り当てられるフィルターの種類を判別できます。例えば、次のコードは、DropShadowFilter である <codeph>filters</codeph> 配列内の最初のフィルターの位置を判別する方法を示しています。
     </p>
     
     <codeblock>
     import flash.text.TextField;
     import flash.filters.~~;
     var tf:TextField = new TextField();
     var filter1:DropShadowFilter = new DropShadowFilter();
     var filter2:GradientGlowFilter = new GradientGlowFilter();
     tf.filters = [filter1, filter2];
     
     tf.text = "DropShadow index: " + filterPosition(tf, DropShadowFilter).toString(); // 0
     addChild(tf)
     
     function filterPosition(displayObject:DisplayObject, filterClass:Class):int {
         for (var i:uint = 0; i &lt; displayObject.filters.length; i++) {
             if (displayObject.filters[i] is filterClass) {
                 return i;
             }
         }
         return -1;
     }
     </codeblock>
     <p><b>注意：</b> 新しいフィルターオブジェクトを <codeph>DisplayObject.filters</codeph> 配列に直接追加できないため、次のコードは、<codeph>myDisplayObject</codeph> という名前のターゲット表示オブジェクトに影響を与えません。</p>
     
     <codeblock>
     myDisplayObject.filters.push(myDropShadow);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="../../flash/filters/package-detail.html"><linktext>flash.filters パッケージ</linktext></link><link href="flash.display.xml#ShaderInput/input"><linktext>flash.display.ShaderInput.input</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:height:get"><apiName>height</apiName><shortdesc>
     表示オブジェクトの高さを示します（ピクセル単位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     表示オブジェクトの高さを示します（ピクセル単位）。この高さは、表示オブジェクトのコンテンツの境界に基づいて計算されます。次のコードに示すように、この <codeph>height</codeph> プロパティを設定すると、それに合わせて <codeph>scaleY</codeph> プロパティの値が調整されます。
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>TextField と Video オブジェクトを除いて、<codeph>height</codeph> を別の値に設定しようとしても、コンテンツのない表示オブジェクト（例えば、空のスプラインなど）の高さは 0 になります。</p>
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> 次のコードでは、2 つの TextField オブジェクトを作成し、それぞれの <codeph>height</codeph> プロパティを調整します。このとき、調整はそれぞれの <codeph>textHeight</codeph> プロパティに基づいて行われます。また、その <codeph>y</codeph> プロパティを設定することで、2 番目のテキストフィールドを配置します。
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
     この表示オブジェクトが属するファイルの読み込み情報を含む LoaderInfo オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     この表示オブジェクトが属するファイルの読み込み情報を含む LoaderInfo オブジェクトを返します。<codeph>loaderInfo</codeph> プロパティは、SWF ファイルのルート表示オブジェクト用、または（ActionScript を使用して描画されるビットマップではなく）ロードされるビットマップ用として定義されています。<codeph>loaderInfo</codeph> オブジェクト（<codeph>myDisplayObject</codeph> という名前の表示オブジェクトを含んでいる SWF ファイルに関連）を見つけるには、<codeph>myDisplayObject.root.loaderInfo</codeph> を使用します。
     
     <p><codeph>this.root.loaderInfo.addEventListener(Event.COMPLETE, func)</codeph> を呼び出すことにより、大きな SWF ファイルのダウンロードを監視できます。</p>
     
     </apiDesc><example conref="examples\DisplayObject.loaderInfo.1.as"> 次のコードでは、<codeph>this</codeph> が表示オブジェクトを参照するものと想定しています。このコードでは、表示オブジェクトのルート SWF ファイルの URL を出力します。
<codeblock>
 trace (this.loaderInfo.url);
 
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>LoaderInfo クラス</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:mask:get"><apiName>mask</apiName><shortdesc>
     呼び出し元の表示オブジェクトは、指定された mask オブジェクトによってマスクされます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>表示オブジェクトのマスクを設定します。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     呼び出し元の表示オブジェクトは、指定された <codeph>mask</codeph> オブジェクトによってマスクされます。ステージの拡大および縮小時にマスクが確実に機能するためには、表示リストのアクティブな部分に <codeph>mask</codeph> 表示オブジェクトが含まれている必要があります。<codeph>mask</codeph> オブジェクト自体は描画されません。マスクを除去するには <codeph>mask</codeph> を <codeph>null</codeph> に設定します。
     
     <p>マスクオブジェクトを拡大および縮小するためには、そのオブジェクトが表示リストに含まれている必要があります。（<codeph>startDrag()</codeph> メソッドを呼び出すことにより）マスク Sprite オブジェクトをドラッグするためには、そのオブジェクトが表示リストに含まれなければなりません。マスクスプライトに対して <codeph>startDrag()</codeph> メソッドを呼び出すには（この呼び出しは、スプライトによって送出される <codeph>mouseDown</codeph> イベントに基づきます）、スプライトの <codeph>buttonMode</codeph> プロパティを <codeph>true</codeph> に設定します。</p>
     
     <p><b>注意：</b>1 つの <codeph>mask</codeph> オブジェクトを使用して複数の呼び出し元表示オブジェクトをマスクすることはできません。<codeph>mask</codeph> が 2 番目の表示オブジェクトに割り当てられると、そのオブジェクトは最初の表示オブジェクトのマスクとして削除され、最初の表示オブジェクトの <codeph>mask</codeph> プロパティは <codeph>null</codeph> になります。</p>  
     
     </apiDesc><example conref="examples\DisplayObject.mask.1.as"> 次のコードでは、TextField オブジェクトと Sprite オブジェクトを作成し、Sprite オブジェクトを TextField オブジェクトのマスクとして設定します。ユーザーがテキストフィールドをクリックすると、<codeph>drag()</codeph> イベントリスナー機能が、マスク Sprite オブジェクトの <codeph>startDrag()</codeph> メソッドを呼び出します。
<codeblock>
import flash.text.TextField;
import flash.display.Sprite;
import flash.events.MouseEvent;

var tf:TextField = new TextField();
tf.text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " 
            + "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
tf.selectable = false;
tf.wordWrap = true;
tf.width = 150;
addChild(tf);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 40, 40);
addChild(square);

tf.mask = square;

tf.addEventListener(MouseEvent.MOUSE_DOWN, drag);
tf.addEventListener(MouseEvent.MOUSE_UP, noDrag);

function drag(event:MouseEvent):void {
    square.startDrag();
}
function noDrag(event:MouseEvent):void {
    square.stopDrag();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseX:get"><apiName>mouseX</apiName><shortdesc>
     マウス位置の x 座標を示します（ピクセル単位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     マウス位置の x 座標を示します（ピクセル単位）。
     
     <p><b>メモ</b> : DisplayObject が回転している場合、返される x 座標は回転前のオブジェクトの座標を反映します。</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> 次のコードでは、Sprite オブジェクトを作成し、ユーザーがスプライトをクリックすると、<codeph>mouseX</codeph> および <codeph>mouseY</codeph> の位置がトレースされます。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseY:get"><apiName>mouseY</apiName><shortdesc>
     マウス位置の y 座標を示します（ピクセル単位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     マウス位置の y 座標を示します（ピクセル単位）。
     
     <p><b>メモ</b> : DisplayObject が回転している場合、返される y 座標は回転前のオブジェクトの座標を反映します。</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> 次のコードでは、Sprite オブジェクトを作成し、ユーザーがスプライトをクリックすると、<codeph>mouseX</codeph> および <codeph>mouseY</codeph> の位置がトレースされます。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:name:get"><apiName>name</apiName><shortdesc>
     DisplayObject のインスタンス名を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Flash オーサリングツールで、タイムライン上に配置されたオブジェクトに対して、このプロパティを設定しようとした場合
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>この DisplayObject の名前です。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     DisplayObject のインスタンス名を示します。親表示オブジェクトコンテナの子リスト内でオブジェクトを識別するには、表示オブジェクトコンテナの <codeph>getChildByName()</codeph> メソッドを呼び出します。
     
     </apiDesc><example conref="examples\DisplayObject.name.1.as"> 次のコードでは、2 つの Sprite オブジェクトを作成し、ユーザーがいずれかのオブジェクトをクリックしたときに関連付けられる <codeph>name</codeph> プロパティをトレースします。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.name = "circle1";
addChild(circle1);
circle1.addEventListener(MouseEvent.CLICK, traceName);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x0000FF);
circle2.graphics.drawCircle(140, 40, 40);
circle2.name = "circle2";
addChild(circle2);
circle2.addEventListener(MouseEvent.CLICK, traceName);

function traceName(event:MouseEvent):void {
    trace(event.target.name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:opaqueBackground:get"><apiName>opaqueBackground</apiName><shortdesc>
     表示オブジェクトが特定の背景色で不透明であるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     表示オブジェクトが特定の背景色で不透明であるかどうかを指定します。透明のビットマップにはアルファチャンネルデータが含まれ、透明に描画されます。不透明のビットマップには、アルファチャンネルがありません（したがって透明のビットマップより速くレンダリングされます）。ビットマップが不透明の場合、使用する独自の背景色を指定する必要があります。
     
     <p>数値が設定された場合、これは数値によって指定される RGB 背景色を持つ不透明な（透明でない）サーフェスになります。<codeph>null</codeph>（デフォルト値）に設定された場合、表示オブジェクトの背景は透明になります。</p>
     
     <p><codeph>opaqueBackground</codeph> プロパティの主な用途は、レンダリング最適化のために <codeph>cacheAsBitmap</codeph> プロパティと共に使用することです。<codeph>cacheAsBitmap</codeph> プロパティが true に設定されている表示オブジェクトでは、<codeph>opaqueBackground</codeph> を設定すると、レンダリングのパフォーマンスが向上する可能性があります。</p>
     
     <p>不透明な背景領域は照合され<i>ません</i>（<codeph>hitTestPoint()</codeph> メソッドを、<codeph>shapeFlag</codeph> パラメーターを <codeph>true</codeph> に設定して呼び出す場合）。</p>
     
     <p>不透明な背景領域は、マウスイベントに反応しません。</p>
     
     </apiDesc><example conref="examples\DisplayObject.opaqueBackground.1.as"> 次のコードでは、青色の円の Shape オブジェクトを作成し、その <codeph>opaqueBackground</codeph> プロパティを赤色（0xFF0000）に設定します。
<codeblock>
import flash.display.Shape;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.opaqueBackground = 0xFF0000;
addChild(circle);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/hitTestPoint()"><linktext>hitTestPoint()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:parent:get"><apiName>parent</apiName><shortdesc>
     この表示オブジェクトを含む DisplayObjectContainer オブジェクトを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObjectContainer</apiValueClassifier><apiException><apiDesc>親表示オブジェクトは、アクセス権限が与えられていないセキュリティ Sandbox に属しています。親ムービーで <codeph>Security.allowDomain()</codeph> メソッドを呼び出すことにより、このような状況を避けることができます。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     この表示オブジェクトを含む DisplayObjectContainer オブジェクトを示します。表示リスト階層内の現在の表示オブジェクトの上位にある表示オブジェクトへの相対パスを指定するには、<codeph>parent</codeph> プロパティを使用します。
     
     <p><codeph>parent</codeph> を使用して表示リストの複数のレベルを上に移動するには、次のようにします。</p>
     
     <codeblock>
     this.parent.parent.alpha = 20;
     </codeblock>
     
     </apiDesc><example conref="examples\DisplayObject.parent.1.as"> 次のコードでは、3 つの Sprite オブジェクトを作成し、<codeph>parent</codeph> プロパティに表示リスト階層が反映されるしくみを示します。
<codeblock>

import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite2.parent.name); // sprite1
trace(sprite3.parent.name); // sprite2
trace(sprite3.parent.parent.name); // sprite1
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:root:get"><apiName>root</apiName><shortdesc>
     読み込まれた SWF ファイル内の表示オブジェクトの場合、root プロパティはその SWF ファイルが表す表示リストのツリー構造部分の一番上にある表示オブジェクトとなります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>このオブジェクトのルート表示オブジェクトを返します。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     読み込まれた SWF ファイル内の表示オブジェクトの場合、<codeph>root</codeph> プロパティは、その SWF ファイルが表す表示リストのツリー構造部分の一番上にある表示オブジェクトとなります。読み込まれたイメージファイルを表す Bitmap オブジェクトの場合、<codeph>root</codeph> プロパティは、Bitmap オブジェクトそのものになります。読み込まれた最初の SWF ファイルのメインクラスのインスタンスの場合、<codeph>root</codeph> プロパティは、表示オブジェクトそのものになります。Stage オブジェクトの <codeph>root</codeph> プロパティは、Stage オブジェクトそのものになります。表示リストに追加されていない表示オブジェクトの場合、<codeph>root</codeph> プロパティには、<codeph>null</codeph> が設定されます。ただし、表示リスト外ではあるものの、読み込まれた SWF ファイルの最上位の表示オブジェクトの子である表示オブジェクトコンテナに追加されていている場合は除きます。
     
     <p>例えば、<codeph>Sprite()</codeph> コンストラクターメソッドを呼び出して新しい Sprite オブジェクトを作成した場合、表示リスト（または、表示リストの外にあるが、SWF ファイルの最上位の表示オブジェクトの子である表示オブジェクトコンテナ）に追加されるまで、<codeph>root</codeph> プロパティは <codeph>null</codeph> になります。</p>
     
     <p>読み込まれた SWF ファイルの場合、ファイルの読み込みに使用した Loader オブジェクトが表示リストに存在しない可能性もありますが、SWF ファイルの最上位の表示オブジェクトの <codeph>root</codeph> プロパティには、オブジェクトそのものが設定されます。Loader オブジェクトでは、<codeph>root</codeph> プロパティは設定されません。この状態は、<codeph>root</codeph> プロパティが設定されている表示オブジェクトの子として追加されるまで続きます。</p>
     
     </apiDesc><example conref="examples\DisplayObject.root.1.as"> 次のコードでは、Stage オブジェクト、表示リストに追加される前と後の両方の表示オブジェクト（Loader オブジェクト）、およびロードされたオブジェクト（ロードされた Bitmap オブジェクト）の <codeph>root</codeph> プロパティの違いを表示します。
<codeblock>
import flash.display.Loader;
import flash.net.URLRequest;
import flash.events.Event;

trace(stage.root); // [object Stage]

var ldr:Loader = new Loader();
trace (ldr.root); // null

addChild(ldr); 
trace (ldr.root); // [object ...]

var urlReq:URLRequest = new URLRequest("example.jpg");
ldr.load(urlReq);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void {
    trace(ldr.content.root); // [object Bitmap]
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotation:get"><apiName>rotation</apiName><shortdesc>
     DisplayObject インスタンスの元の位置からの回転角を度単位で示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     DisplayObject インスタンスの元の位置からの回転角を度単位で示します。時計回りに回転させる場合は 0 ～ 180 の値を指定します。反時計回りに回転させる場合は 0 ～ -180 の値を指定します。この範囲を超える値は、360 を加算または減算して、範囲内に収まる値になるように調整されます。例えば、<codeph>my_video.rotation = 450</codeph> というステートメントは <codeph>my_video.rotation = 90</codeph> と同義です。
     
     </apiDesc><example conref="examples\DisplayObject.rotation.1.as"> 次のコードでは、Sprite オブジェクトを作成し、ユーザーがそれをクリックすると、オブジェクトが回転します。
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(-50, -50, 100, 100);
square.x = 150;
square.y = 150;
addChild(square);

square.addEventListener(MouseEvent.CLICK, rotate);

function rotate(event:MouseEvent):void {
        square.rotation += 15;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationX:get"><apiName>rotationX</apiName><shortdesc>
     DisplayObject インスタンスの 3D 親コンテナを基準にした元の位置からの x 軸の回転角を度単位で示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     DisplayObject インスタンスの 3D 親コンテナを基準にした元の位置からの x 軸の回転角を度単位で示します。時計回りに回転させる場合は 0 ～ 180 の値を指定します。反時計回りに回転させる場合は 0 ～ -180 の値を指定します。この範囲を超える値は、360 を加算または減算して、範囲内に収まる値になるように調整されます。
     
     </apiDesc><example conref="examples\RotationExample1.as"> この例では、2 つの楕円の <codeph>rotationX</codeph> プロパティと <codeph>rotationY</codeph> プロパティを使用して、これらの楕円を回転させます。最初の楕円の基準点は、楕円の中心に設定されています。この楕円は、その中心を軸にして回転します。2 つ目の楕円は、外部のポイントを軸にして回転します。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationY:get"><apiName>rotationY</apiName><shortdesc>
     DisplayObject インスタンスの 3D 親コンテナを基準にした元の位置からの y 軸の回転角を度単位で示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     DisplayObject インスタンスの 3D 親コンテナを基準にした元の位置からの y 軸の回転角を度単位で示します。時計回りに回転させる場合は 0 ～ 180 の値を指定します。反時計回りに回転させる場合は 0 ～ -180 の値を指定します。この範囲を超える値は、360 を加算または減算して、範囲内に収まる値になるように調整されます。
     
     
     </apiDesc><example conref="examples\RotationExample1.as"> この例では、2 つの楕円の <codeph>rotationX</codeph> プロパティと <codeph>rotationY</codeph> プロパティを使用して、これらの楕円を回転させます。最初の楕円の基準点は、楕円の中心に設定されています。この楕円は、その中心を軸にして回転します。2 つ目の楕円は、外部のポイントを軸にして回転します。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationZ:get"><apiName>rotationZ</apiName><shortdesc>
     DisplayObject インスタンスの 3D 親コンテナを基準にした元の位置からの z 軸の回転角を度単位で示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     DisplayObject インスタンスの 3D 親コンテナを基準にした元の位置からの z 軸の回転角を度単位で示します。時計回りに回転させる場合は 0 ～ 180 の値を指定します。反時計回りに回転させる場合は 0 ～ -180 の値を指定します。この範囲を超える値は、360 を加算または減算して、範囲内に収まる値になるように調整されます。
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scale9Grid:get"><apiName>scale9Grid</apiName><shortdesc>
     現在有効な拡大 / 縮小グリッドです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following creates a movie clip that contains a 20-pixel line (which forms a border)
     and a gradient fill. The movie clip scales based on the mouse position, and because of the
     <code>scale9Grid</code> set for the movie clip, the thickness of the 20-pixel line does not
     vary when the clip scales (although the gradient in the movie clip <em>does</em> scale):
     
     <listing version="2.0">
     import flash.geom.Rectangle;
     import flash.geom.Matrix;
     
     this.createEmptyMovieClip("my_mc", this.getNextHighestDepth());
     
     var grid:Rectangle = new Rectangle(20, 20, 260, 260);
     my_mc.scale9Grid = grid ;
     
     my_mc._x = 50;
     my_mc._y = 50;
     
     function onMouseMove()
     {
      my_mc._width  = _xmouse;
      my_mc._height = _ymouse;
     }
     
     my_mc.lineStyle(20, 0xff3333, 100);
     var gradient_matrix:Matrix = new Matrix();
     gradient_matrix.createGradientBox(15, 15, Math.PI, 10, 10);
     my_mc.beginGradientFill("radial", [0xffff00, 0x0000ff],
              [100, 100], [0, 0xFF], gradient_matrix,
              "reflect", "RGB", 0.9);
     my_mc.moveTo(0, 0);
     my_mc.lineTo(0, 300);
     my_mc.lineTo(300, 300);
     my_mc.lineTo(300, 0);
     my_mc.lineTo(0, 0);
     my_mc.endFill();
     </listing>
     
     </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>メソッドに無効な引数を渡した場合
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     現在有効な拡大 / 縮小グリッドです。<codeph>null</codeph> に設定されている場合、拡大または縮小変換が適用されると表示オブジェクト全体は通常どおりに拡大または縮小されます。
     
     <p><codeph>scale9Grid</codeph> プロパティを定義すると、グリッドの中央領域を定義する <codeph>scale9Grid</codeph> 矩形に基づいて、9 つの領域からなるグリッドに表示オブジェクトが分割されます。グリッドの他の 8 領域は、次のような領域です。 </p>
     
     <ul>
       <li>矩形の外側の左上端</li>
       <li>矩形の上側の領域 </li>
       <li>矩形の外側の右上端</li>
       <li>矩形の左側の領域</li>
       <li>矩形の右側の領域</li>
       <li>矩形の外側の左下端</li>
       <li>矩形の下側にある領域</li>
       <li>矩形の外側の右下端</li>
     </ul>
     
     <p>矩形で定義される、中心以外の 8 つの領域は、拡大 / 縮小時に特別な規則が適用される額縁のようなものと考えることができます。</p>
     
     <p><codeph>scale9Grid</codeph> プロパティが設定されているときに表示オブジェクトを拡大 / 縮小すると、テキストとグラデーションはすべて通常どおり拡大 / 縮小しますが、それ以外の種類のオブジェクトには次のような規則が適用されます。</p>
     
     <ul>
       <li>中央領域のコンテンツは通常どおり拡大 / 縮小します。 </li>
       <li>左上、右上、左下、右下のコンテンツは拡大 / 縮小しません。 </li>
       <li>上下の領域のコンテンツは水平方向にのみ拡大 / 縮小します。左右の領域のコンテンツは垂直方向にのみ拡大 / 縮小します。</li>
      <li>すべての塗り（ビットマップ、ビデオ、グラデーションを含む）は、形状に収まるように伸縮されます。</li>
     </ul>
     
     <p>表示オブジェクトが回転されると、それ以降の拡大 / 縮小はすべて通常どおりになり、<codeph>scale9Grid</codeph> プロパティは無視されます。</p>
     
     <p>例えば、次のような表示オブジェクトと、その表示オブジェクトの <codeph>scale9Grid</codeph> として適用される矩形があるとします。</p>
     
     <adobetable>
     
       
     
     <tgroup cols="2"><tbody><row>
      <entry align="center"><adobeimage alt="表示オブジェクトのイメージ" href="../../images/scale9Grid-a.jpg"/>
     <p>表示オブジェクトです。</p></entry>
     
      <entry align="center"><adobeimage alt="表示オブジェクトの 9 領域での拡大 / 縮小" href="../../images/scale9Grid-b.jpg"/>
      <p>赤の矩形は <codeph>scale9Grid</codeph> を表します。</p></entry>
       </row></tbody></tgroup></adobetable>
     
     <p>表示オブジェクトを拡大 / 縮小または伸縮すると、矩形内のオブジェクトは通常どおり拡大 / 縮小しますが、矩形外のオブジェクトは <codeph>scale9Grid</codeph> の規則に従って拡大 / 縮小します。</p>
     
     <adobetable>
      
     
      
     
      
     
      
     
     <tgroup cols="2"><tbody><row>
      <entry>75% に縮小：</entry>
      <entry><adobeimage alt="75% の表示オブジェクト" href="../../images/scale9Grid-c.jpg"/></entry>
      </row><row>
      <entry>50% に縮小：</entry>
      <entry><adobeimage alt="50% の表示オブジェクト" href="../../images/scale9Grid-d.jpg"/></entry>
      </row><row>
      <entry>25% に縮小：</entry>
      <entry><adobeimage alt="25% の表示オブジェクト" href="../../images/scale9Grid-e.jpg"/></entry>
      </row><row>
      <entry>水平方向に 150% 伸長： </entry>
      <entry><adobeimage alt="150% に伸長された表示" href="../../images/scale9Grid-f.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     
     <p><codeph>scale9Grid</codeph> 設定の一般的な使用法は、拡大 / 縮小時にエッジ領域が同じ幅に保たれるコンポーネントとして表示オブジェクトをセットアップすることです。</p>
     
     </apiDesc><example conref="examples\DisplayObject.scale9Grid.1.as"> 次のコードでは、Shape オブジェクトを作成し、その <codeph>graphics</codeph> プロパティで矩形を描画します。矩形は、太さ 20 ピクセルの線を境界に使用し、グラデーションで塗りつぶします。タイマーイベントでは <codeph>scale()</codeph> 関数を呼び出し、<codeph>scaleX</codeph> プロパティおよび <codeph>scaleY</codeph> プロパティを調整して、Shape オブジェクトを拡大 / 縮小します。<codeph>scale9Grid</codeph> が Shape オブジェクトに適用されるため、矩形の境界線は拡大 / 縮小されず、グラデーションの塗りのみが拡大 / 縮小されます。
<codeblock>

import flash.display.Shape;
import flash.display.GradientType;
import flash.display.SpreadMethod;
import flash.display.InterpolationMethod;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var square:Shape = new Shape();
square.graphics.lineStyle(20, 0xFFCC00);
var gradientMatrix:Matrix = new Matrix();
gradientMatrix.createGradientBox(15, 15, Math.PI, 10, 10);
square.graphics.beginGradientFill(GradientType.RADIAL, 
            [0xffff00, 0x0000ff], 
            [100, 100], 
            [0, 0xFF], 
            gradientMatrix, 
            SpreadMethod.REFLECT, 
            InterpolationMethod.RGB, 
            0.9);
square.graphics.drawRect(0, 0, 100, 100);

var grid:Rectangle = new Rectangle(20, 20, 60, 60);
square.scale9Grid = grid ;

addChild(square);

var tim:Timer = new Timer(100);
tim.start();
tim.addEventListener(TimerEvent.TIMER, scale);

var scaleFactor:Number = 1.01;

function scale(event:TimerEvent):void {
    square.scaleX *= scaleFactor;
    square.scaleY *= scaleFactor;
    
    if (square.scaleX > 2.0) {
        scaleFactor = 0.99;
    }
    if (square.scaleX &lt; 1.0) {
        scaleFactor = 1.01;
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scaleX:get"><apiName>scaleX</apiName><shortdesc>
     基準点から適用されるオブジェクトの水平スケール（パーセンテージ）を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     基準点から適用されるオブジェクトの水平スケール（パーセンテージ）を示します。 デフォルトの基準点は (0,0) です。1.0 は縮尺 100% と同等です。
     
     <p>ローカル座標系を拡大 / 縮小すると、<codeph>x</codeph> および <codeph>y</codeph> プロパティの値が変化します。この変化は、整数のピクセル数で表されます。 </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> 次のコードでは、Sprite オブジェクトを作成し、その <codeph>graphics</codeph> プロパティで矩形を描画します。ユーザーがスプライトをクリックすると、スプライトは 10% 拡大されます。
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleY:get"><apiName>scaleY</apiName><shortdesc>
     オブジェクトの基準点から適用されるオブジェクトの垂直スケール（パーセンテージ）を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     オブジェクトの基準点から適用されるオブジェクトの垂直スケール（パーセンテージ）を示します。 デフォルトの基準点は (0,0) です。1.0 は縮尺 100% です。
     
     <p>ローカル座標系を拡大 / 縮小すると、<codeph>x</codeph> および <codeph>y</codeph> プロパティの値が変化します。この変化は、整数のピクセル数で表されます。 </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> 次のコードでは、Sprite オブジェクトを作成し、その <codeph>graphics</codeph> プロパティで矩形を描画します。ユーザーがスプライトをクリックすると、スプライトは 10% 拡大されます。
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleZ:get"><apiName>scaleZ</apiName><shortdesc>
     オブジェクトの基準点から適用されるオブジェクトの奥行きスケール（パーセンテージ）を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     オブジェクトの基準点から適用されるオブジェクトの奥行きスケール（パーセンテージ）を示します。デフォルトの基準点は (0,0) です。1.0 は縮尺 100% です。
     
     <p>ローカル座標系を拡大 / 縮小すると、<codeph>x</codeph>、<codeph>y</codeph>、および <codeph>z</codeph> プロパティの値が変化します。これらの値はピクセル単位の整数値で表されます。 </p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/z"><linktext>z</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scrollRect:get"><apiName>scrollRect</apiName><shortdesc>
     表示オブジェクトのスクロール矩形の境界です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     表示オブジェクトのスクロール矩形の境界です。表示オブジェクトは矩形で定義されたサイズにトリミングされ、<codeph>x</codeph> および <codeph>y</codeph> プロパティ（<codeph>scrollRect</codeph> オブジェクトのプロパティ）を変更すると、表示オブジェクトは矩形の内部でスクロールします。
     
     <p><codeph>scrollRect</codeph> 矩形オブジェクトのプロパティは、表示オブジェクトの座標空間を使用し、表示オブジェクト全体と同じように拡大および縮小されます。スクロールしている表示オブジェクト上のトリミングされたウィンドウの隅の境界は、表示オブジェクトの原点 (0,0)、および矩形の幅と高さによって定義されるポイントです。これらは原点を中心に配置されるのではなく、原点を使って領域の左上隅を定義します。スクロールされる表示オブジェクトは、常にピクセル増分全体の中でスクロールします。 </p>
     
     <p><codeph>x</codeph> プロパティ（<codeph>scrollRect</codeph> 矩形オブジェクトのプロパティ）を設定することにより、オブジェクトを左右にスクロールできます。<codeph>y</codeph> プロパティ（<codeph>scrollRect</codeph> 矩形オブジェクトのプロパティ）を設定することにより、オブジェクトを上下にスクロールできます。表示オブジェクトを 90 度回転して左右にスクロールすると、この表示オブジェクトは実際には上下にスクロールします。</p>
     
     </apiDesc><example conref="examples\DisplayObject.scrollRect.1.as"> 次の例では、<codeph>scrollRect</codeph> プロパティが、表示オブジェクトである <codeph>circle</codeph> のスクロール領域を定義する方法を示しています。<codeph>circle</codeph> オブジェクトをクリックすると、<codeph>clicked()</codeph> イベントハンドラーメソッドは、<codeph>y</codeph> プロパティ（<codeph>scrollRect</codeph> プロパティ（<codeph>circle</codeph> オブジェクトのプロパティ）のプロパティ）を調整し、結果としてオブジェクトが下にスクロールします。
<codeblock>

import flash.display.Sprite;
import flash.geom.Rectangle;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(200, 200, 200);
circle.scrollRect = new Rectangle(0, 0, 200, 200);
addChild(circle);

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    var rect:Rectangle = event.target.scrollRect;
    rect.y -= 5;
    event.target.scrollRect = rect;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:stage:get"><apiName>stage</apiName><shortdesc>
     表示オブジェクトのステージです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
     表示オブジェクトのステージです。Flash アプリケーションには Stage オブジェクトが 1 つだけあります。たとえば、複数の表示オブジェクトを作成して表示リストにロードすることができます。その場合、(ロードされた SWF ファイルに表示オブジェクトが属する場合であっても) それぞれの表示オブジェクトの <codeph>stage</codeph> プロパティは、同じ Stage オブジェクトを参照します。
     
     <p>表示オブジェクトが表示リストに追加されていない場合、<codeph>stage</codeph> プロパティは <codeph>null</codeph> に設定されます。</p>
     
     </apiDesc><example conref="examples\DisplayObject.stage.1.as"> 次のコードは、2 つの TextField オブジェクトを作成し、Stage オブジェクトの <codeph>width</codeph> プロパティを使用して、テキストフィールドを配置します。
<codeblock>

import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.x = 10;
addChild(tf1);
tf1.width = tf1.stage.stageWidth / 2 - 10;

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.x = tf1.x + tf1.width + 5;
addChild(tf2);
tf2.width = tf2.stage.stageWidth / 2 - 10;

trace(stage.stageWidth);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:transform:get"><apiName>transform</apiName><shortdesc>
    表示オブジェクトのマトリックス、カラー変換、ピクセル境界に関係するプロパティを持つオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Transform</apiValueClassifier></apiValueDef><apiDesc>
    表示オブジェクトのマトリックス、カラー変換、ピクセル境界に関係するプロパティを持つオブジェクトです。特定のプロパティつまり matrix、colorTransform、および 3 つの読み取り専用プロパティ（<codeph>concatenatedMatrix</codeph>、<codeph>concatenatedColorTransform</codeph>、および <codeph>pixelBounds</codeph>）については、Transform クラスの最初の部分で説明します。
    
    <p>変形オブジェクトの各プロパティは、それ自身がオブジェクトです。この概念は重要です。matrix オブジェクトまたは colorTransform オブジェクトの新しい値を設定する唯一の方法は、新しいオブジェクトを作成し、そのオブジェクトを transform.matrix プロパティまたは transform.colorTransform プロパティにコピーすることです。</p>
    
    <p>例えば、表示オブジェクトのマトリックスの <codeph>tx</codeph> 値を増やすには、次のようにして matrix オブジェクト全体のコピーを作成した後、新しいオブジェクトを変形オブジェクトの matrix プロパティにコピーする必要があります。</p>
    
    <pre><codeph>
    var myMatrix:Matrix = myDisplayObject.transform.matrix;  
    myMatrix.tx += 10; 
    myDisplayObject.transform.matrix = myMatrix;  
    </codeph></pre>
    
    <p><codeph>tx</codeph> プロパティを直接設定することはできません。次のコードは <codeph>myDisplayObject</codeph> に影響を与えません。 </p>
    
    <pre><codeph>
    myDisplayObject.transform.matrix.tx += 10;
    </codeph></pre>
    
    <p>また、変形オブジェクト全体をコピーし、それを別の表示オブジェクトの transform プロパティに割り当てることもできます。例えば、次のコードでは、変形オブジェクト全体を <codeph>myOldDisplayObj</codeph> から <codeph>myNewDisplayObj</codeph> にコピーします。</p>
    <codeph>myNewDisplayObj.transform = myOldDisplayObj.transform;</codeph>
    <p>生成される表示オブジェクト <codeph>myNewDisplayObj</codeph> のマトリックス、カラー変換、ピクセル境界は、古い表示オブジェクト <codeph>myOldDisplayObj</codeph> と同じ値になります。</p>
     
    </apiDesc><example conref="examples\DisplayObject.transform.1.as"> 次のコードでは、Sprite オブジェクト <codeph>square</codeph> を設定します。ユーザーがスプライトをクリックすると、<codeph>transformer()</codeph> メソッドにより、<codeph>colorTransform</codeph> プロパティおよび <codeph>matrix</codeph> プロパティ（スプライトの <codeph>transform</codeph> プロパティのプロパティ）が調整されます。
<codeblock>

import flash.display.Sprite;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Transform;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.lineStyle(20, 0xFF2200);
square.graphics.beginFill(0x0000DD);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

var resultColorTransform:ColorTransform = new ColorTransform();
resultColorTransform.alphaMultiplier = 0.5;
resultColorTransform.redOffset = 155;
resultColorTransform.greenMultiplier = 0.5;

var skewMatrix:Matrix = new Matrix(1, 1, 0, 1);

square.addEventListener(MouseEvent.CLICK, transformer);

function transformer(event:MouseEvent):void {
    var transformation:Transform = square.transform;
    var tempMatrix:Matrix = square.transform.matrix;
    tempMatrix.concat(skewMatrix);
    square.transform.colorTransform = resultColorTransform;
    
    square.transform.matrix = tempMatrix;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Transform"><linktext>Transform クラス</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:visible:get"><apiName>visible</apiName><shortdesc>
     表示オブジェクトが可視かどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     表示オブジェクトが可視かどうかを示します。非可視の表示オブジェクトは無効になります。例えば、ある InteractiveObject インスタンスが <codeph>visible=false</codeph> に設定されている場合、これをクリックすることはできません。
     
     </apiDesc><example conref="examples\DisplayObject.visible.1.as"> 次のコードでは、Timer オブジェクトを使用して、表示オブジェクトの <codeph>visible</codeph> プロパティを定期的に変更する関数を呼び出して、点滅効果を達成します。
<codeblock>

import flash.text.TextField;
import flash.utils.Timer;
import flash.events.TimerEvent;

var tf:TextField = new TextField();
tf.text = "Hello.";
addChild(tf);

var tim:Timer = new Timer(250);
tim.start();
tim.addEventListener(TimerEvent.TIMER, blinker);

function blinker(event:TimerEvent):void {
    tf.visible = !tf.visible;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:width:get"><apiName>width</apiName><shortdesc>
     表示オブジェクトの幅を示します（ピクセル単位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     表示オブジェクトの幅を示します（ピクセル単位）。この幅は、表示オブジェクトのコンテンツの境界に基づいて計算されます。次のコードに示すように、この <codeph>width</codeph> プロパティを設定すると、それに合わせて <codeph>scaleX</codeph> プロパティの値が調整されます。
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>TextField と Video オブジェクトを除いて、<codeph>width</codeph> を別の値に設定しようとしても、コンテンツのない表示オブジェクト（例えば、空のスプラインなど）の幅は 0 になります。</p>
     
     </apiDesc><example conref="examples\DisplayObject.width.1.as"> 次のコードでは、Sprite オブジェクト <codeph>square</codeph> を設定します。ユーザーがスプライトをクリックすると、<codeph>widen()</codeph> メソッドが、スプライトの <codeph>width</codeph> プロパティを増加します。
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, widen);

function widen(event:MouseEvent):void {
    square.width += 10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:x:get"><apiName>x</apiName><shortdesc>
     親 DisplayObjectContainer のローカル座標を基準にした DisplayObject インスタンスの x 座標を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     親 DisplayObjectContainer のローカル座標を基準にした DisplayObject インスタンスの <i>x</i> 座標を示します。変形されている DisplayObjectContainer にオブジェクトが含まれる場合、そのオブジェクトの座標系は、それを囲む DisplayObjectContainer のローカル座標系になります。したがって、反時計回りに 90 度回転した DisplayObjectContainer の場合、その DisplayObjectContainer の子は、反時計回りに 90 度回転した座標系を継承します。オブジェクトの座標は、基準点の位置を参照します。
     
     </apiDesc><example conref="examples\DisplayObject.x.1.as"> 次のコードでは、<codeph>circle</codeph> Sprite オブジェクトを設定します。Timer オブジェクトを使用して、スプライトの <codeph>x</codeph> プロパティを 50 ミリ秒ごとに変更します。
<codeblock>

import flash.display.Sprite;
import flash.utils.Timer;
import flash.events.TimerEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(100, 100, 100);
addChild(circle);

var tim:Timer = new Timer(50);
tim.start();
tim.addEventListener(TimerEvent.TIMER, bounce);

var xInc:Number = 2;

function bounce(event:TimerEvent):void {
    circle.x += xInc;
    if (circle.x > circle.width) {
        xInc = -2;
    }
    if (circle.x &lt; 0) {
        xInc = 2;
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:y:get"><apiName>y</apiName><shortdesc>
     親 DisplayObjectContainer のローカル座標を基準にした DisplayObject インスタンスの y 座標を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     親 DisplayObjectContainer のローカル座標を基準にした DisplayObject インスタンスの <i>y</i> 座標を示します。変形されている DisplayObjectContainer にオブジェクトが含まれる場合、そのオブジェクトの座標系は、それを囲む DisplayObjectContainer のローカル座標系になります。したがって、反時計回りに 90 度回転した DisplayObjectContainer の場合、その DisplayObjectContainer の子は、反時計回りに 90 度回転した座標系を継承します。オブジェクトの座標は、基準点の位置を参照します。
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> 次のコードでは、2 つの TextField オブジェクトを作成し、それぞれの <codeph>height</codeph> プロパティを調整します。このとき、調整はそれぞれの <codeph>textHeight</codeph> プロパティに基づいて行われます。また、その <codeph>y</codeph> プロパティを設定することで、2 番目のテキストフィールドを配置します。
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:z:get"><apiName>z</apiName><shortdesc>
     3D 親コンテナを基準にした、DisplayObject インスタンスの z 軸に沿った z 座標位置を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     3D 親コンテナを基準にした、DisplayObject インスタンスの z 軸に沿った z 座標位置を示します。 z プロパティは、3D 座標で使用されます。画面座標またはピクセル座標用ではありません。 
     <p>表示オブジェクトの <codeph>z</codeph> プロパティをデフォルト値の <codeph>0</codeph> 以外に設定すると、対応する Matrix3D オブジェクトが自動的に作成されます。これにより、3 次元での表示オブジェクトの位置と方向が調整されます。z 軸を使用して作業する場合、x プロパティおよび y プロパティの既存の動作は、画面座標またはピクセル座標から 3D 親コンテナを基準にした位置に変更されます。</p>
     <p>例えば、位置（x = 100, y = 100, z = 200）にある <codeph>_root</codeph> の子は、ピクセル位置（100, 100）に描画されません。この子は、3D 投影計算の結果に応じた位置に描画されます。次の計算が実行されます。</p>
     <p><codeph>（x~~cameraFocalLength/cameraRelativeZPosition, y~~cameraFocalLength/cameraRelativeZPosition）</codeph></p>
     
     
     </apiDesc><example conref="examples\ZAxisExample1.as"> この例では、2 つの楕円を描画し、これらの楕円を消失点に向かって前後に（<codeph>z</codeph> 軸に沿って）移動させます。一方の楕円は、他方の楕円よりも速く移動するよう設定されています。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.geom.*;

    public class ZAxisExample1 extends MovieClip {
        private var ellipse1Back:int = 1;
        private var ellipse2Back:int = 1;
        private var depth:int = 1000;
        
        public function ZAxisExample1():void {
            
            var ellipse1 = drawEllipse((this.stage.stageWidth / 2) - 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 10);
            var ellipse2 = drawEllipse((this.stage.stageWidth / 2) + 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 300);

            this.addChild(ellipse1);
            this.addChild(ellipse2);
            
            ellipse1.addEventListener(Event.ENTER_FRAME, ellipse1FrameHandler);
            ellipse2.addEventListener(Event.ENTER_FRAME, ellipse2FrameHandler);
        }

        private function drawEllipse(x:Number, y:Number, w:Number, h:Number, z:Number):Shape {
            var s:Shape = new Shape();                            
            s.z = z;
            s.graphics.beginFill(0xFF0000);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(x, y, w, h);
            s.graphics.endFill();
            return s;
        }

        private function ellipse1FrameHandler(e:Event):void {
            ellipse1Back = setDepth(e, ellipse1Back);
            e.currentTarget.z += ellipse1Back * 10;
        }

        private function ellipse2FrameHandler(e:Event):void {
            ellipse2Back = setDepth(e, ellipse2Back);
            e.currentTarget.z += ellipse2Back * 20;
        }

        private function setDepth(e:Event, d:int):int {
            if(e.currentTarget.z > depth) {
                e.currentTarget.z = depth; 
                d = -1;
            }else if (e.currentTarget.z &lt;  0) {
                e.currentTarget.z = 0;
                d = 1;
            }
            return d;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>transform</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:blendShader:set"><apiName>blendShader</apiName><shortdesc>
     前景と背景のブレンドに使用するシェーダーを設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.display:Shader</apiValueClassifier><apiException><apiDesc>シェーダー出力タイプがこの操作に対応しない場合（シェーダーは <codeph>pixel4</codeph> 出力を指定する必要があります）。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>シェーダーが指定したイメージ入力が 2 より少ないか、または最初の 2 つの入力が <codeph>image4</codeph> 入力でない場合。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>シェーダーが指定したイメージ入力が存在しない場合。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>ByteArray または Vector の場合。&lt;Number> インスタンスが入力として使用され、ShaderInput の <codeph>width</codeph> および <codeph>height</codeph> プロパティが指定されていない、または指定された値が入力オブジェクトのデータ量と一致しない場合。詳しくは、<codeph>ShaderInput.input</codeph> プロパティを参照してください。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     前景と背景のブレンドに使用するシェーダーを設定します。<codeph>blendMode</codeph> プロパティを <codeph>BlendMode.SHADER</codeph> に設定すると、指定された Shader が表示オブジェクトのブレンドモード出力の作成に使用されます。
     
     <p>Shader インスタンスに表示オブジェクトの <codeph>blendShader</codeph> プロパティを設定すると、表示オブジェクトの <codeph>blendMode</codeph> プロパティが <codeph>BlendMode.SHADER</codeph> に自動的に設定されます。<codeph>blendMode</codeph> プロパティが <codeph>BlendMode.SHADER</codeph> に設定される <codeph>blendShader</codeph> プロパティを設定した後で <codeph>blendMode</codeph> プロパティの値を変更すると、ブレンドモードがリセットされ、<codeph>blendMode</codeph> プロパティを <codeph>BlendMode.SHADER</codeph> に設定するだけでブレンドシェーダーを使用できます。ブレンドモードに使用したシェーダーを変更する場合を除いて、<codeph>blendShader</codeph> プロパティを再度設定する必要はありません。</p>
     
     <p><codeph>blendShader</codeph> プロパティに割り当てた Shader は、少なくとも 2 つ以上の <codeph>image4</codeph> 入力を指定する必要があります。入力は、関連付けられている ShaderInput オブジェクトの <b/><codeph>input</codeph> プロパティを使用してコードで指定する必要はありません。背景表示オブジェクトが、最初の入力として（<codeph>index</codeph> 0 の入力）自動的に使用されます。前景表示オブジェクトは、2 番目の入力として（<codeph>index</codeph> 1 の入力）使用されます。ブレンドシェーダーとして使用するシェーダーは、2 つ以上入力を指定できます。その場合、追加の入力は、ShaderInput インスタンスの <codeph>input</codeph> プロパティを設定することで指定する必要があります。</p>
     
     <p>Shader インスタンスをこのプロパティに割り当てると、シェーダーが内部的にコピーされます。ブレンド操作は、元のシェーダーを参照するのではなく、その内部コピーを使用します。パラメーター値、入力、バイトコードの変更などの変更をシェーダーに加えたとしても、ブレンドモードで使用したコピーシェーダーにはその変更は適用されません。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Loader"><apiName>Loader</apiName><shortdesc>
 Loader クラスは、SWF ファイルまたはイメージ（JPG、PNG、または GIF）ファイルを読み込むために使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Loader クラスは、SWF ファイルまたはイメージ（JPG、PNG、または GIF）ファイルを読み込むために使用します。読み込みを開始するには <codeph>load()</codeph> メソッドを使用します。読み込まれた表示オブジェクトは Loader オブジェクトの子として追加されます。
 
 <p>テキストまたはバイナリデータを読み込むには URLLoader クラスを使用します。</p>
 
 <p>Loader クラスは、継承する次のメソッドをオーバーライドします。これは、Loader オブジェクトが持つことができるのは 1 つの子表示オブジェクト、つまりロードするオブジェクトに限られているためです。次のメソッドを呼び出すと例外がスローされます。メソッドは、<codeph>addChild()</codeph>、<codeph>addChildAt()</codeph>、<codeph>removeChild()</codeph>、<codeph>removeChildAt()</codeph>、および <codeph>setChildIndex()</codeph> です。ロードされた表示オブジェクトを削除するには、親の DisplayObjectContainer 子配列から <i>Loader</i> オブジェクトを削除する必要があります。 </p>
 
 <p><b>注意：</b>ActionScript 2.0 の MovieClipLoader クラスと LoadVars クラスは、ActionScript 3.0 では使用されません。それらは、Loader クラスと URLLoader クラスに置き換えられました。</p>
 
 <p>Loader クラスを使用するときは、Flash Player および Adobe AIR のセキュリティモデルを考慮してください。 </p>
 
 <ul>
  <li>コンテンツは、アクセスできるソースであればどのソースからでもロードできます。 </li>
 
  <li>呼び出し元 SWF ファイルがネットワーク上のサンドボックスにあり、読み込むファイルがローカルにある場合は読み込めません。 </li>
 
  <li>読み込まれたコンテンツが ActionScript 3.0 で作成された SWF ファイルの場合、別のセキュリティ Sandbox にある SWF ファイルでそれをクロススクリプトすることはできません。ただし、読み込まれたコンテンツファイルで、<codeph>System.allowDomain()</codeph> または <codeph>System.allowInsecureDomain()</codeph> メソッドの呼び出しによってクロススクリプトに関する取り決めが承認されていた場合は可能です。</li>
  
  <li>読み込まれたコンテンツが AVM1 SWF ファイル（ActionScript 1.0 または 2.0 で作成されたもの）の場合、AVM2 SWF ファイル（ActionScript 3.0 で作成されたもの）でそれをクロススクリプトすることはできません。ただし、LocalConnection クラスを使用して、2 つの SWF ファイル間で通信を行うことはできます。</li>
  
  <li>ロードされたコンテンツがイメージの場合、セキュリティサンドボックスの外にある SWF ファイルからそのデータにアクセスすることはできません。ただし、その SWF ファイルのドメインがイメージの元のドメインにある URL ポリシーファイルに含まれていた場合は可能です。</li>
 
  <li>ローカルファイルシステムのサンドボックスにあるムービークリップでは、ネットワーク接続したローカルのサンドボックスにあるムービークリップをスクリプト処理できません。その逆も同様です。 </li>
 
  <li>一般的な予約ポートには接続できません。ブロックされているポートの一覧については、<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_jp" scope="external">セキュリティに関する章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_jp" scope="external">セキュリティに関する章</xref></ph>（『ActionScript 3.0 のプログラミング』）の「ネットワーク API の制限」を参照してください。<i/> </li>
 
 
 </ul>
 
 <p>ただし、 AIR では、<codeph>アプリケーション</codeph>セキュリティサンドボックス内のコンテンツ（AIR アプリケーションと共にインストールされたコンテンツ）は、これらのセキュリティ制限による制限を受けません。</p>
 
 <p>詳しくは、次のトピックを参照してください。</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
 
 <li>Flash Player デベロッパーセンタートピック：<xref href="http://www.adobe.com/go/devnet_security_jp" scope="external">セキュリティ</xref></li>
 
 </ul>
 
 <p>信頼されていないソース（Loader オブジェクトのルート SWF ファイルのドメイン以外のドメインなど）から SWF ファイルを読み込む場合は、次のコードに示すように、Loader オブジェクトに対してマスクを定義して、読み込まれたコンテンツ（Loader オブジェクトの子）がそのマスクの外部にあるステージの一部分に描画されないようにすることができます。</p>
 
 <codeblock>import flash.display.~~;
 import flash.net.URLRequest;
 var rect:Shape = new Shape();
 rect.graphics.beginFill(0xFFFFFF);
 rect.graphics.drawRect(0, 0, 100, 100);
 rect.graphics.endFill();
 addChild(rect);
 var ldr:Loader = new Loader();
 ldr.mask = rect;
 var url:String = "http://www.unknown.example.com/content.swf";
 var urlReq:URLRequest = new URLRequest(url);
 ldr.load(urlReq);
 addChild(ldr);
 </codeblock>
 
 </apiDesc><example conref="examples\LoaderExample.as"> 次の例では、LoaderExample クラスを使用して、さまざまなイベントリスナーの使用方法を示します。これを行うには、以下の手順を実行します。
 <ol>
  <li><codeph>url</codeph> プロパティを作成します。これはイメージファイルの場所と名前です。</li>
  <li><codeph>LoaderExample</codeph> コンストラクターでは、<codeph>loader</codeph> という名前の新しい Loader オブジェクトが作成され、手順 3 出説明する <codeph>configureListeners()</codeph> メソッドに渡されます。</li>
  <li>コンストラクターは、<codeph>request</codeph> という URLRequest オブジェクトの新しいインスタンスを作成しますが、その前に、ファイル名と場所が分かるように <codeph>url</codeph> を渡します。</li>
  <li><codeph>request</codeph> オブジェクトが <codeph>loader</codeph> オブジェクトの <codeph>load()</codeph> メソッドに渡されます。これにより、イメージが表示リストにロードされます。</li>
  <li><codeph>clickHandler</codeph> イベントリスナーがローダーの <codeph>click</codeph> イベントに対して登録されます。マウスをクリックすると、ロードされたイメージはアンロードされます。</li>
  <li><codeph>configureListeners()</codeph> メソッドは、次のメソッドを使用して、7 つのイベントリスナーを追加します。
  <ul>
      <li><codeph>completeHandler()</codeph> メソッドは、イメージのロードが完了したときに実行されます。</li>
 
      <li><codeph>httpStatusHandler()</codeph> メソッドは、イメージがローカルにロードされない場合で、ネットワーク要求を行うことができ、Flash Player がそれを検出できる場合にのみ実行されます。</li>
 
      <li><codeph>initHandler()</codeph> メソッドが実行されるのは、<codeph>completeHandler()</codeph> メソッドの前、<codeph>progressHandler()</codeph> メソッドの後です。一般的には、SWF ファイルをロードするとき、<codeph>init</codeph> イベントの方が便利です。</li>
 
      <li><codeph>ioErrorHandler()</codeph> メソッドは、イメージファイルを使用できないか、イメージファイルにアクセスできない場合に実行されます。</li>
 
      <li><codeph>openHandler()</codeph> メソッドは、イメージファイルが最初に開かれたときに実行されます。</li>
 
      <li><codeph>progressHandler()</codeph> メソッドは、イメージファイルのロードが開始したときに実行され、イメージのロードが完了したときに再び実行されます。</li>
 
      <li><codeph>unLoadHandler()</codeph> メソッドは、ユーザーがイメージをクリックしたときに <codeph>unload()</codeph> メソッドを使用してイメージがアンロードされた場合に実行されます。</li>
 
  </ul>
  </li>
 </ol>
 <p> 次の要件に注意してください。</p>
 
 <ul>
  <li>この例では、Image.gif という名前のファイルがコンパイル済み SWF ファイルと同じディレクトリに配置されている必要があります。メイン SWF ファイルのサイズ内に収まる領域を持つイメージを使用します。</li>
 
  <li>この例では、LoaderInfo オブジェクトで使用可能なすべてのイベントを利用しますが、ほとんどの場合、必要になるのは 1 つのサブセットのみです。特に、イメージファイルをロードするだけの場合は、ローカルイメージをロードするときの <codeph>complete</codeph> イベント（および必要に応じて <codeph>ioError</codeph> イベント）で十分です。</li>
 
 </ul>
 
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderExample() {
            var loader:Loader = new Loader();
            configureListeners(loader.contentLoaderInfo);
            loader.addEventListener(MouseEvent.CLICK, clickHandler);

            var request:URLRequest = new URLRequest(url);
            loader.load(request);

            addChild(loader);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(Event.INIT, initHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function initHandler(event:Event):void {
            trace("initHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function unLoadHandler(event:Event):void {
            trace("unLoadHandler: " + event);
        }

        private function clickHandler(event:MouseEvent):void {
            trace("clickHandler: " + event);
            var loader:Loader = Loader(event.target);
            loader.unload();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:Loader:Loader"><apiName>Loader</apiName><shortdesc>
     SWF、JPEG、GIF、または PNG などのファイルの読み込みに使用できる Loader オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need wording on parent/child relationships, root DisplayObjects, and so on.
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     SWF、JPEG、GIF、または PNG などのファイルの読み込みに使用できる Loader オブジェクトを作成します。アセットを Loader インスタンスの子として読み込むには、<codeph>load()</codeph> メソッドを呼び出します。その後、Loader オブジェクトを表示リストに追加できます。例えば、DisplayObjectContainer インスタンスの <codeph>addChild()</codeph> メソッドを使用して追加します。アセットは読み込まれるとステージに表示されます。
     
     <p>Loader インスタンスを "リスト外" で、つまり、表示リスト上の表示オブジェクトコンテナに追加しなくても使用できます。このモードの場合、Loader インスタンスを使用して、アプリケーションの追加モジュールを含む SWF ファイルを読み込むことができます。 </p>
     
     <p>SWF ファイルの読み込みが完了したことを検出するには、Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティに関連付けられた LoaderInfo オブジェクトのイベントを使用できます。その時点で、モジュール SWF ファイル内のコードを実行し、モジュールを初期化して、開始できます。リスト外モードでは、Loader インスタンスを使用して、コンポーネントまたはメディアアセットを含む SWF ファイルをロードすることもできます。この場合も、LoaderInfo オブジェクトのイベント通知を使用して、コンポーネントのロードが完了したことを検出できます。 その時点で、アプリケーションは SWF ファイルのライブラリ内のコンポーネントとメディアアセットの使用を開始できます。これは、それらのコンポーネントとアセットを表す ActionScript 3.0 クラスをインスタンス化することによって行います。</p>
     
     <p>Loader オブジェクトの状態を判別するには、Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティに関連付けられた LoaderInfo オブジェクトの次のイベントを監視します。</p>
     
     <ul>
       
     <li><codeph>open</codeph> イベントは、読み込みが開始したときに送出されます。</li>
       
     <li><codeph>ioError</codeph> または <codeph>securityError</codeph> イベントは、ファイルを読み込めない場合、あるいは読み込み中にエラーが発生した場合に送出されます。 </li>
       
     <li><codeph>progress</codeph> イベントは、ファイルが読み込まれている間、継続的に発生します。</li>
       
     <li><codeph>complete</codeph> イベントは、ファイルのダウンロードが完了したときに送出されます。ただし、この時点では、読み込まれたムービークリップのメソッドとプロパティはまだ使用できません。 </li>
       
     <li><codeph>init</codeph> イベントは、読み込まれた SWF ファイルのプロパティおよびメソッドにアクセスできるようになると、送出されます。そのため、読み込まれた SWF ファイルに対して各種の操作を開始できます。このイベントは、<codeph>complete</codeph> ハンドラーの前に送出されます。ストリーミング SWF ファイルの場合、<codeph>init</codeph> イベントは <codeph>complete</codeph> イベントよりもかなり前に発生することがあります。ほとんどの場合、<codeph>init</codeph> ハンドラーを使用します。</li>
     
     </ul>
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:Loader:close"><apiName>close</apiName><shortdesc>
     Loader インスタンスに対して現在進行中の load() メソッドの処理をキャンセルします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Loader インスタンスに対して現在進行中の <codeph>load()</codeph> メソッドの処理をキャンセルします。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:load"><apiName>load</apiName><shortdesc>
     SWF、JPEG、プログレッシブ JPEG、非アニメーション GIF、または PNG ファイルを、この Loader オブジェクトの子であるオブジェクトにロードします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how to use the <code>MovieClipLoader.loadClip()</code> 
     method by creating a handler for the <code>onLoadInit</code> event and then making the request.
     <p>You should either place the following code directly into a frame action on a Timeline, or 
     paste it into a class that extends MovieClip. This code also expects an image named YourImage.jpg
     to exist in the same directory as the compiled SWF file.</p>
     
     <listing version="2.0">
     var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth());
     var mcLoader:MovieClipLoader = new MovieClipLoader();
     mcLoader.addListener(this);
     mcLoader.loadClip("YourImage.jpg", container);
     
     function onLoadInit(mc:MovieClip) {
         trace("onLoadInit: " + mc);
     }
     </listing>
     
     </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>request</codeph> オブジェクトの <codeph>digest</codeph> プロパティが <codeph>null</codeph> ではありません。RLRequest オブジェクトの <codeph>digest</codeph> プロパティを設定できるのは、<codeph>URLLoader.load()</codeph> メソッドを呼び出して SWZ ファイル（Adobe プラットフォームコンポーネント）を読み込む場合のみです。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>LoaderContext.securityDomain</codeph> の値は、<codeph>null</codeph> または <codeph>SecurityDomain.currentDomain</codeph> のいずれかである必要があります。つまり、ロードされたメディアは、通常のセキュリティサンドボックスまたは独自のサンドボックスのいずれかにしか配置できません。後者の場合は、ポリシーファイルが必要です。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>ローカル SWF ファイルでは、LoaderContext.securityDomain に <codeph>null</codeph> 以外の値を設定できません。また、ローカルでないメディアのローカルサンドボックスへのインポート、およびローカルメディアの通常のサンドボックス以外の場所への配置は許可されません。
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>一般的な予約ポートに接続しようとしている場合。ブロックされているポートの完全な一覧については、『ActionScript 3.0 のプログラミング』のセキュリティに関する章の「ネットワーク API の制限」を参照してください。<i/>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>applicationDomain</codeph> または <codeph>securityDomain</codeph> プロパティ（<codeph>context</codeph> パラメーターのプロパティ）が、許可されていないドメインのものであった場合
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>ローカル SWF ファイルが、<codeph>securityDomain</codeph> プロパティ（<codeph>context</codeph> パラメーターのプロパティ）を使用しようとした場合
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> 読み込む SWF、JPEG、GIF、または PNG ファイルの絶対 URL または相対 URL です。相対パスの場合は、メイン SWF ファイルを基準にする必要があります。絶対 URL の場合は、http:// や file:/// などのプロトコル参照も含める必要があります。ファイル名には、ドライブ指定を含めることはできません。
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>次の定義を行うプロパティのある、LoaderContext オブジェクトです。
     
     <ul>
     
	 <li>オブジェクトのロード時にポリシーファイルの存在を確認するかどうか</li>
     
     <li>ロードされるオブジェクトの ApplicationDomain</li>
     
     <li>読み込まれるオブジェクトの SecurityDomain</li>
     
     </ul>
     <p><codeph>context</codeph> パラメーターが指定されていない場合または null のオブジェクトを参照している場合、読み込まれるコンテンツはそれ自身のセキュリティドメインに置かれたままになります。</p>
     
     <p>完全な詳細については、<xref href="../system/LoaderContext.html">LoaderContext</xref> クラスのプロパティの説明を参照してください。</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>SWF ファイルまたはイメージファイルを、この Loader インスタンスの子である DisplayObject に読み込みます。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     SWF、JPEG、プログレッシブ JPEG、非アニメーション GIF、または PNG ファイルを、この Loader オブジェクトの子であるオブジェクトにロードします。アニメーション GIF ファイルを読み込むと、先頭のフレームのみ表示されます。Loader オブジェクトには子を 1 つだけしか含めることができないため、後続の <codeph>load()</codeph> 要求を発行すると直前の要求（保留中であれば）を終了し、新たに読み込みを開始します。
     
     <p><b>注意</b>：AIR 1.5 および Flash Player 10 では、読み込まれるイメージの最大サイズは幅または高さが 8,191 ピクセルです。ただし、総ピクセル数が 16,777,215 ピクセルを超えることはできません（したがって、読み込まれるイメージの幅が 8,191 ピクセルであった場合、高さは 2,048 ピクセルまでしか指定できません）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。</p>
     
     <p>Loader オブジェクトに読み込んだ SWF ファイルまたはイメージは、その Loader オブジェクトの親の表示オブジェクトの位置、回転、および拡大 / 縮小の各プロパティを継承します。 </p>
     
     <p>このメソッドを使用して読み込まれたムービーまたはイメージを削除したり、進行中の読み込み処理をキャンセルするには、<codeph>unload()</codeph> メソッドを使用します。</p>
     
     <p>SWF ファイルがこのメソッドを使用しないようにするには、SWF コンテンツを含んでいる HTML ページの <codeph>allowNetworking</codeph> パラメーター（<codeph>object</codeph> タグおよび <codeph>embed</codeph> タグ内）を設定します。</p>
     
     <p>このメソッドを使用するときは、Loader クラスの説明にある Flash Player セキュリティモデルを考慮してください。 </p>
     
     <p> Flash Player 10 以降では、"multipart/form-data" などのマルチパート Content-Type にアップロードが含まれていると（アップロードが含まれているかどうかは POST ボディ内の "content-disposition" ヘッダーの "filename" パラメーターで示されます）、そのアップロードに適用されるセキュリティ規則によって POST 処理が拘束されます。</p>
	 <ul>
	 <li>POST 処理は、マウスのクリックやキーの押下などのユーザーが開始したアクションに応答して実行する必要があります。</li>
	 <li>POST 処理がクロスドメインである（POST ターゲットが、POST 要求を送信中の SWF ファイルと同じサーバー上にない）場合は、クロスドメインアクセスを許可する URL ポリシーファイルをターゲットサーバーが提供する必要があります。</li>
	 </ul>
     <p>また、すべてのマルチパート Content-Type では、RFC2046 標準に準拠した有効なシンタックスを使用する必要があります。シンタックスが有効でない場合は、アップロードに適用されるセキュリティ規則によって POST 処理が拘束されます。</p>
     <p>セキュリティ情報について詳しくは、以下を参照してください。</p>
     
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
     
     <li>Flash Player デベロッパーセンタートピック：<xref href="http://www.adobe.com/go/devnet_security_jp" scope="external">セキュリティ</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/contentLoaderInfo"><linktext>contentLoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>flash.display.Loader.unload()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><adobeApiEvent id="flash.display:Loader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>ファイルの読み込みが完了したときに <codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。<codeph>complete</codeph> イベントは、常に、<codeph>init</codeph> イベントの後に送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>ファイルの読み込みが完了したときに、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>ネットワーク要求が HTTP 上で行われ、Flash Player が HTTP ステータスコードを検出できる場合に <codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>ネットワーク要求が HTTP 上で行われ、Flash Player が HTTP ステータスコードを検出できる場合に、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_init"><apiName>init</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>読み込まれた SWF ファイルのプロパティおよびメソッドにアクセスできる場合に、<codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。<codeph>init</codeph> イベントは、常に、<codeph>complete</codeph> イベントの前に送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>読み込まれた SWF ファイルのプロパティおよびメソッドにアクセスできる場合に、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>入出力エラーが発生して読み込み処理が失敗したときに、<codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>入出力エラーが発生して読み込み処理が失敗したときに、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>読み込み処理が開始したときに、<codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>読み込み処理が開始したときに、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>読み込み処理を実行中にデータを受信したときに、<codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>読み込み処理を実行中にデータを受信したときに、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>ローカルファイルシステムのサンドボックス内の SWF ファイルがネットワーク接続したローカルのサンドボックス内のコンテンツを読み込もうとしたか、またはその逆の場合に、<codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>ローカルファイルシステムのサンドボックス内の SWF ファイルがネットワーク接続したローカルのサンドボックス内のコンテンツを読み込もうとしたか、またはその逆の場合に、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_unload"><apiName>unload</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>読み込まれたオブジェクトが削除されるときに、<codeph>contentLoaderInfo</codeph> オブジェクトによって送出されます。
     
     </apiDesc></adobeApiEventDetail><shortdesc>読み込まれたオブジェクトが削除されるときに、contentLoaderInfo オブジェクトによって送出されます。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:Loader:loadBytes"><apiName>loadBytes</apiName><shortdesc>
     ByteArray オブジェクトに保管されているバイナリデータからロードします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>ByteArray オブジェクトの <codeph>length</codeph> プロパティが 0 以下であった場合
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>checkPolicyFile</codeph> または <codeph>securityDomain</codeph> プロパティ（<codeph>context</codeph> パラメーターのプロパティ）が null 以外であった場合
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>applicationDomain</codeph> プロパティ（受け取った <codeph>context</codeph> プロパティのプロパティ）が、許可されていないドメインのものであった場合
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>一般的な予約ポートに接続しようとしている場合。ブロックされているポートの完全な一覧については、『ActionScript 3.0 のプログラミング』のセキュリティに関する章の「ネットワーク API の制限」を参照してください。<i/>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>ByteArray オブジェクトです。ByteArray の内容としては、Loader クラスがサポートする SWF、GIF、JPEG、PNG のうちの任意のファイル形式を使用できます。
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>LoaderContext オブジェクトです。LoaderContext オブジェクトの <codeph>applicationDomain</codeph> プロパティのみが適用され、LoaderContext オブジェクトの <codeph>checkPolicyFile</codeph> および <codeph>securityDomain</codeph> プロパティは適用されません。 
     
     <p><codeph>context</codeph> パラメーターが指定されていない場合または null のオブジェクトを参照している場合、コンテンツは現在のセキュリティドメインにロードされます。Flash Player のセキュリティに関する説明では、このプロセスを「読み込みロード」と呼びます。具体的には、ロードする側の SWF ファイルが、コードにリモート SWF を組み込むことによってリモート SWF を明示的に信頼している場合は、それ自身のセキュリティドメインに直接リモート SWF を読み込むことができます。</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     ByteArray オブジェクトに保管されているバイナリデータからロードします。
     
     <p>このメソッドを使用するときは、Loader クラスの説明にある Flash Player セキュリティモデルを考慮してください。 </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unload"><apiName>unload</apiName><shortdesc>
     load() メソッドを使用して読み込まれた、この Loader オブジェクトの子を削除します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The funky-looking code formatting above is intentional to work around a bug!
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     <codeph>load()</codeph> メソッドを使用してロードされた、この Loader オブジェクトの子を削除します。関連した LoaderInfo オブジェクトの <codeph>property</codeph> は <codeph>null</codeph> にリセットされます。他のオブジェクトが参照している可能性があるので、子は必ずしも破棄されるとは限りません。ただし、Loader オブジェクトの子ではなくなります。
     
     <p>子 SWF ファイルを解放する前に、LocalConnection、NetConnection、NetStream、Sound オブジェクトなど、子 SWF ファイルのオブジェクト内のストリームをすべて明示的に閉じておくことをお勧めします。そうしなかった場合は、子 SWF ファイルが解放された後も、子 SWF ファイルのオーディオの再生が続く場合があります。子 SWF ファイルのストリームを閉じるには、<codeph>unload</codeph> イベントを受け取る子にイベントリスナーを追加します。親が <codeph>Loader.unload()</codeph> を呼び出すと、<codeph>unload</codeph> イベントが子に対して送出されます。次のコードは、このような処理を行う例を示します。</p>
<pre>
function closeAllStreams(evt:Event) { 
    myNetStream.close();
    mySound.close();
    myNetConnection.close();
    myLocalConnection.close();
}

myMovieClip.loaderInfo.addEventListener(Event.UNLOAD, closeAllStreams);</pre>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.media.xml#Sound/close()"><linktext>flash.media.Sound.close()</linktext></link><link href="flash.net.xml#LocalConnection/close()"><linktext>flash.net.LocalConnection.close()</linktext></link><link href="flash.net.xml#NetConnection/close()"><linktext>flash.net.NetConnection.close()</linktext></link><link href="flash.net.xml#NetStream/close()"><linktext>flash.net.NetStream.close()</linktext></link><link href="../../operators.html#delete"><linktext>delete 演算子</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unloadAndStop"><apiName>unloadAndStop</apiName><shortdesc>
     子 SWF ファイルの内容のアンロードを試み、ロードされた SWF ファイルのコマンドの実行を中止します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>gc</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>子 SWF オブジェクトでガベージコレクターが実行されるようにヒントを提供するかどうかを指定します（<codeph>true</codeph> または <codeph>false</codeph>）。多数のオブジェクトを非同期でアンロードする場合は、<codeph>gc</codeph> パラメーターを <codeph>false</codeph> に設定するとアプリケーションのパフォーマンスが向上する可能性があります。ただし、このパラメーターを <codeph>false</codeph> に設定した場合は、<codeph>unloadAndStop()</codeph> コマンドの実行後も子 SWF ファイルのメディアオブジェクトおよび表示オブジェクトがメモリに残ることがあります。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     子 SWF ファイルの内容のアンロードを試み、ロードされた SWF ファイルのコマンドの実行を中止します。このメソッドは、<codeph>Loader.load()</codeph> または <codeph>Loader.loadBytes()</codeph> を使用してロードされた SWF ファイルのアンロードを試みます。このために、子 SWF ファイルの EventDispatcher、NetConnection、Timer、Sound、または Video オブジェクトへの参照を削除します。この結果、子 SWF ファイルおよび子 SWF ファイルの表示リストで以下が行われます。
     <ul><li>サウンドが停止されます。</li>
     <li>Stage イベントリスナーが削除されます。</li>
     <li><codeph>enterFrame</codeph>、<codeph>frameConstructed</codeph>、<codeph>exitFrame</codeph>、<codeph>activate</codeph>、および <codeph>deactivate</codeph> のイベントリスナーが削除されます。</li>
     <li>タイマーが停止されます。</li>
     <li>Camera インスタンスおよび Microphone インスタンスがデタッチされます。</li>
     <li>ムービークリップが停止されます。</li></ul>
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Loader:content:get"><apiName>content</apiName><shortdesc>
     load() または loadBytes() メソッドを使用して読み込まれた SWF ファイルまたはイメージ（JPG、PNG、または GIF）ファイルのルート表示オブジェクトが含まれます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>読み込まれた SWF ファイルまたはイメージファイルは、アクセス権限が与えられていないセキュリティ Sandbox に属しています。読み込まれた SWF ファイルの場合、ファイルで <codeph>Security.allowDomain()</codeph> メソッドを呼び出すことによって、この状況を回避できます。または、<codeph>loaderContext</codeph> パラメーター（<codeph>securityDomain</codeph> プロパティのパラメーター）を <codeph>SecurityDomain.currentDomain</codeph> に設定することによって（ただし、読み込む側のファイルで <codeph>load()</codeph> または <codeph>loadBytes()</codeph> メソッドを呼び出すとき）、この状況を回避できます。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     <codeph>load()</codeph> メソッドまたは <codeph>loadBytes()</codeph> メソッドを使用して読み込まれた SWF ファイルまたはイメージ（JPG、PNG、または GIF）ファイルのルート表示オブジェクトが含まれます。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:Loader:contentLoaderInfo:get"><apiName>contentLoaderInfo</apiName><shortdesc>
     読み込まれているオブジェクトに対応する LoaderInfo オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     読み込まれているオブジェクトに対応する LoaderInfo オブジェクトを返します。LoaderInfo オブジェクトは、Loader オブジェクトと読み込まれたコンテンツオブジェクト間で共有されます。LoaderInfo オブジェクトは、読み込みの進行状況に関する情報と、読み込まれたファイルに関する統計を提供します。 
     
     <p>読み込みに関連するイベントは、Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティで参照される LoaderInfo オブジェクトによって送出されます。<codeph>contentLoaderInfo</codeph> プロパティは、コンテンツの読み込みの前も、有効な valid LoaderInfo オブジェクトに設定されているので、読み込みの前にイベントリスナーをオブジェクトに追加できます。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
     NativeMenuItem クラスは、メニュー中の 1 アイテムを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     NativeMenuItem クラスは、メニュー中の 1 アイテムを表します。
     
     <p>メニューアイテムは、コマンド、サブメニューまたはセパレーター線です。</p> 
     
     <ul>
     <li>コマンドアイテムを作成するには、NativeMenuItem コンストラクターを呼び出します。このとき、ラベルに使用するストリングを渡し、<codeph>false</codeph> を <codeph>isSeparator</codeph> パラメーターに設定します。</li>
     
     <li>サブメニューを作成するには、親メニューとなるコマンドアイテムを作成し、このコマンドアイテムの <codeph>submenu</codeph> プロパティに、作成するサブメニューの NativeMenu オブジェクトを割り当てます。親 NativeMenu オブジェクトの <codeph>addSubmenu()</codeph> メソッドを呼び出してアイテムを作成し、同時に <codeph>submenu</codeph> プロパティを設定できます。</li>
     
     <li>セパレーターを作成するには、NativeMenuItem コンストラクターを呼び出します。このとき、ラベルに使用するストリングとして空のストリングを渡し、<codeph>true</codeph> を <codeph>isSeparator</codeph> パラメーターに設定します。</li>
     </ul>
     
     <p>アイテムまたは親メニューの <codeph>select</codeph> イベントを受け取り、メニューコマンドが選択された時期を検出します。サブメニューとセパレーターは、select イベントを送出しません。<codeph>displaying</codeph> イベントを受け取り、メニューアイテムを表示する時期を決定します。</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     アイテムを含むメニューが表示される直前に、この NativeMenuItem から送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     アイテムを含むメニューが表示される直前に、この NativeMenuItem から送出されます。 
     
	 <p>イベントオブジェクトの <codeph>target</codeph> プロパティは、この NativeMenuItem オブジェクトを含む NativeMenu オブジェクトを参照します。この NativeMenuItem は、<codeph>currentTarget</codeph> プロパティが参照します。</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     ユーザーがメニューアイテムを選択したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     ユーザーがメニューアイテムを選択したときに送出されます。 
     
     <p><codeph>select</codeph> イベントは、このアイテムからアイテムに含まれているメニューまで、親メニューのチェーンをルートメニューオブジェクトに向かって上方にバブルします。<i/>イベントオブジェクトの <codeph>target</codeph> プロパティは、この NativeMenuItem オブジェクトを参照します。<codeph>currentTarget</codeph> プロパティは、送出するオブジェクト（この NativeMenuItem オブジェクトまたはその上位の NativeMenu オブジェクト）を参照します。</p>
	 
	 <p><b>注意：</b>メニューを含むウィンドウがフルスクリーンモードである場合、NativeMenuItem オブジェクトは、ユーザーがメニューアイテムにキーボード相当物を入力しても<i/> <codeph>select</codeph> イベントを送出しません。ただし、<codeph>keyDown</codeph> イベントが送出されるのを監視できます。これを行うには、NativeWindow オブジェクトの <codeph>stage</codeph> プロパティを使用します。</p>
       
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeMenuItem:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
         新しい NativeMenuItem オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>アイテムの表示ラベルまたはセパレーターの空のストリングです。
         </apiDesc></apiParam><apiParam><apiItemName>isSeparator</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>セパレーターを作成する場合は <codeph>true</codeph> に設定し、それ以外の場合は <codeph>false</codeph> に設定します。
         
         </apiDesc></apiParam></apiConstructorDef><apiDesc>
         新しい NativeMenuItem オブジェクトを作成します。
         
         <p>メニューコマンドを作成するには、<codeph>label</codeph> パラメーターを表示ラベルを含むストリングに設定し、<codeph>isSeparator</codeph> を <codeph>false</codeph> に設定します。</p>
	     
	     <p>サブメニューコマンドを作成するには、コマンドアイテムを作成し、サブメニューの NativeMenu オブジェクトをこのアイテムの <codeph>submenu</codeph> プロパティに割り当てます。親メニューにアイテムを追加します。</p>
		  
	     <p>セパレーターを作成するには、<codeph>label</codeph> パラメーターを空のストリングに設定し、<codeph>isSeparator</codeph> を <codeph>true</codeph> に設定します。</p>
         
         <p>NativeMenu の <codeph>addItem()</codeph> メソッドおよび <codeph>removeItem()</codeph> メソッドを使用して、メニューにアイテムを追加したり、メニューからアイテムを削除したりします。</p>
         
         </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeMenuItem:clone"><apiName>clone</apiName><shortdesc>
         NativeMenuItem オブジェクトのコピーを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         NativeMenuItem オブジェクトのコピーを作成します。
         
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenuItem:toString"><apiName>toString</apiName><shortdesc>
         NativeMenuItem オブジェクトのすべてのプロパティを含むストリングを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Event オブジェクトのすべてのプロパティを含むストリングです。
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         NativeMenuItem オブジェクトのすべてのプロパティを含むストリングを返します。
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenuItem:checked:get"><apiName>checked</apiName><shortdesc>
         このメニューにチェックマークを表示するかどうかを制御します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         このメニューにチェックマークを表示するかどうかを制御します。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:data:get"><apiName>data</apiName><shortdesc>
         このメニューアイテムに関連付けられた任意のデータオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
         このメニューアイテムに関連付けられた任意のデータオブジェクトです。
         
         <p>このプロパティには、任意のオブジェクトを割り当てられます。割り当てられたオブジェクトはメニューシステムでは使用されず、（イベントオブジェクトの target プロパティを通じて）イベント処理コードで使用できます。デフォルトでは、このプロパティの値は <codeph>null</codeph> です。</p>
           
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:enabled:get"><apiName>enabled</apiName><shortdesc>
         このメニューを有効にするかどうかを制御します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         このメニューを有効にするかどうかを制御します。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:isSeparator:get"><apiName>isSeparator</apiName><shortdesc>
         このアイテムがメニューセパレーター線かどうかを報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         このアイテムがメニューセパレーター線かどうかを報告します。
         
         <p>NativeMenuItem コンストラクターの <codeph>isSeparator</codeph> パラメーターを <codeph>true</codeph> に設定して、セパレーター線を作成します。</p> 
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalent:get"><apiName>keyEquivalent</apiName><shortdesc>
         このメニューアイテムのキー相当物です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         このメニューアイテムのキー相当物です。
		 
		 <p>小文字を使用して <codeph>keyEquivalent</codeph> を設定し、Shift キーモディファイアを使用しないショートカットを割り当てます。大文字を使用して設定し、Shift キーモディファイアを使用するショートカットを割り当てます。</p>
		 
		 <p>デフォルトでは、キーボードショートカットのモディファイア（Windows または Linux では Ctrl、Mac OS X では Command）がキーボードショートカットの一部に含まれます。キー相当物をモディファイアのないキーにする場合、<codeph>keyEquivalentModifiers</codeph> プロパティを空の配列に設定します。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalentModifiers:get"><apiName>keyEquivalentModifiers</apiName><shortdesc>
         キー相当物のモディファイアに対応するキーコードの配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         キー相当物のモディファイアに対応するキーコードの配列です。
         
         <p>Keyboard クラスで定義されている定数を使用して、モディファイアキーコードを指定します。有効なモディファイアキーは次のとおりです。</p>
         <ul>
         <li><codeph>Keyboard.ALTERNATE</codeph></li>
         <li><codeph>Keyboard.COMMAND</codeph></li>
         <li><codeph>Keyboard.CONTROL</codeph></li>
         </ul>
		 
		 <p>モディファイアを割り当てない場合、Windows または Linux では <codeph>Keyboard.CONTROL</codeph> キー、Mac OS X では <codeph>Keyboard.COMMAND</codeph> キーがデフォルトで割り当てられます。キー相当物にこれらのモディファイアが含まれないようにするには、このプロパティを空の配列に設定します。</p>
		 
		 <p><codeph>keyEquivalent</codeph> プロパティに大文字を割り当てると、Shift キーがモディファイアとして自動的に使用されます。<codeph>keyEquivalentModifier</codeph> を空の配列に設定しても、モディファイアとしての Shift キーは除去されません。</p> 
         
         </apiDesc></apiValueDetail><related-links><link href="flash.ui.xml#Keyboard"><linktext>flash.ui.Keyboard</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeMenuItem:label:get"><apiName>label</apiName><shortdesc>
         このメニューアイテムの表示ストリングです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         このメニューアイテムの表示ストリングです。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:menu:get"><apiName>menu</apiName><shortdesc>
         このアイテムを含むメニューです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         このアイテムを含むメニューです。  
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:mnemonicIndex:get"><apiName>mnemonicIndex</apiName><shortdesc>
         メニューアイテムでのニーモニック文字の位置です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         メニューアイテムでのニーモニック文字の位置です。
         
         <p>指定された位置の文字が、そのメニューアイテムのニーモニック文字です。インデックスは 0 から始まるので、最初の文字は 0 のインデックスを持ちます。</p>
         
         <p>このプロパティは、メニューニーモニックを使用しないオペレーティングシステムでは無視されます。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:name:get"><apiName>name</apiName><shortdesc>
         このメニューアイテムの名前です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         このメニューアイテムの名前です。  
         
         <p>名前の値は表示されず、ロケールに依存しない識別子として使用できます。名前は自動的には割り当てられません。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:submenu:get"><apiName>submenu</apiName><shortdesc>
		 このメニューアイテムに関連付けられたサブメニューです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 このメニューアイテムに関連付けられたサブメニューです。  
		 
		 <p>このプロパティに NativeMenu オブジェクトを割り当てると、メニューアイテムの外観と動作が変化します。サブメニューアイテムにサブメニューアイコンが表示され、select イベントが送出されなくなります。</p>
         
        <p><b>注意：</b>メニューをそのメニューのサブメニューとして追加すると（循環参照）、アプリケーションが異常停止することがあります。</p>
        
         </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenu"><apiName>NativeMenu</apiName><shortdesc>
     NativeMenu クラスには、メニューを定義するメソッドとプロパティが含まれています。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     NativeMenu クラスには、メニューを定義するメソッドとプロパティが含まれています。
     
     <p>AIR では次のタイプのメニューをサポートしています。</p>
     <adobetable class="innertable">
     
     
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>メニュー</entry><entry>インスタンス</entry><entry>機能チェック</entry><entry>サポートしている OS</entry><entry>デフォルトでの提供</entry></row></thead><tbody><row><entry>アプリケーション</entry><entry><codeph>NativeApplication.nativeApplication.menu</codeph></entry><entry><codeph>NativeApplication.supportsMenu</codeph></entry><entry>Mac OS X</entry><entry>あり</entry></row><row><entry>ウィンドウ</entry><entry><codeph>NativeWindow.menu</codeph></entry><entry><codeph>NativeWindow.supportsMenu</codeph></entry><entry>Windows、Linux</entry><entry>なし</entry></row><row><entry>ドックアイコン</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsDockIcon</codeph></entry><entry>Mac OS X</entry><entry>あり</entry></row><row><entry>システムトレイアイコン</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry><entry>Windows、Linux</entry><entry>なし</entry></row><row><entry>コンテキスト</entry><entry><codeph>InteractiveObject.contextMenu</codeph></entry><entry>常にサポートされます</entry><entry>すべて</entry><entry>なし</entry></row><row><entry>ポップアップ</entry><entry>任意の NativeMenu インスタンス</entry><entry>常にサポートされます</entry><entry>すべて</entry><entry>なし</entry></row></tbody></tgroup></adobetable>
     
     <p>メニューには、コマンド、サブメニューおよびセパレーター線に対応するアイテムを含めることができます。 メニューアイテムは、<codeph>addItem()</codeph>、<codeph>addItemAt()</codeph>、<codeph>addSubmenu()</codeph> および <codeph>addSubmenuAt()</codeph> の各メソッドを使用して追加します。メニューでのアイテムの表示順序は、メニューの <codeph>items</codeph> 配列でのアイテムの順序と一致します。</p>
      
     <p>サブメニューは、親メニューの該当するメニューアイテムの <codeph>submenu</codeph> プロパティを使用して、親メニューに追加します。ウィンドウのルートメニューおよびアプリケーションメニューには、サブメニューアイテムのみ含める必要があります。サブメニューのないアイテムは表示できず、このようなタイプのメニューは期待される動作を行いません。</p>
     
     <p>メニューのコマンドアイテム、またはそのサブメニューが選択されると、メニューは <codeph>select</codeph> イベントを送出します（サブメニューアイテムおよびセパレーターアイテムは選択できません）。イベントオブジェクトの <codeph>target</codeph> プロパティは、選択されたアイテムを参照します。</p>
     
     <p>メニューは、メニューが表示される直前に <codeph>displaying</codeph> イベントを送出します。このイベントを使用することで、現在のアプリケーションの状態に基づき、メニューの内容を更新することができます。</p> 
     
     <p platform="actionscript"><b>メモ :</b> NativeMenu オブジェクトまたは ContextMenu オブジェクトのいずれかを使用して、コンテキストメニューを設定します。Flash Player は ContextMenu クラスのみサポートしており、NativeMenu クラスはサポートしていません。
	 </p>
     
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>flash.display.InteractiveObject.contextMenu</linktext></link><link href="flash.display.xml#NativeMenuItem"><linktext>flash.display.NativeMenuItem</linktext></link><link href="flash.display.xml#NativeWindow/menu"><linktext>flash.display.NativeWindow.menu</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/menu"><linktext>flash.desktop.NativeApplication.menu</linktext></link><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     メニューが表示される直前に、この NativeMenu オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     メニューが表示される直前に、この NativeMenu オブジェクトから送出されます。 
     
     <p>このイベントを受け取り、メニューが表示される前に更新します。表示イベントも、メニューのアイテムから送出されます。</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     いずれかのメニューアイテム、またはその子孫のサブメニューのいずれかのアイテムが選択された場合に、この NativeMenu オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     いずれかのメニューアイテム、またはその子孫のサブメニューのいずれかのアイテムが選択された場合に、この NativeMenu オブジェクトから送出されます。 
     
     <p>選択イベントは、メニューアイテムからアイテムに含まれているメニューまで、親メニューのチェーンをルートメニューオブジェクトに向かって上方にバブルします。<i/>イベントオブジェクトの <codeph>target</codeph> プロパティは、選択されている NativeMenuItem オブジェクトを参照します。この NativeMenu オブジェクトは、<codeph>currentTarget</codeph> プロパティが参照します。</p>  
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:NativeMenu:addItem"><apiName>addItem</apiName><shortdesc>
         メニューの下部に、メニューアイテムを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>item</codeph> が <codeph>null</codeph> の場合。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>item</codeph> が別のメニューのメンバーである場合。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>メニューの下部に追加する NativeMenuItem オブジェクトです。
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         メニューの下部に、メニューアイテムを追加します。
         
         <p platform="actionscript">コンテキストメニューを作成する場合は、NativeMenuItem または ContextMenuItem オブジェクトのいずれかを追加できます。ただし、メニュー内のすべてのアイテムが同じプロパティを持つようにするため、コンテキストメニューでは 1 つの型のオブジェクトのみを使用することをお勧めします。</p>
         
         <p><b>注意：</b>アイテムのサブメニューがメニュー自体に設定されている場合、アイテムをメニューに追加すると、アプリケーションが異常停止することがあります（循環参照が発生）。</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addItemAt"><apiName>addItemAt</apiName><shortdesc>
         指定された位置に、メニューアイテムを挿入します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>item</codeph> が <codeph>null</codeph> の場合。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>item</codeph> が別のメニューのメンバーである場合。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>インデックスが、メニューの <codeph>items</codeph> 配列の範囲外の場合。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>挿入する NativeMenuItem オブジェクトです。
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>メニューアイテムを挿入する、0 から始まるメニューの位置です。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定された位置に、メニューアイテムを挿入します。
         
         <p><b>メモ：</b>アイテムのサブメニューがメニュー自体に設定されている場合、アイテムをメニューに追加すると、アプリケーションが異常停止することがあります（循環参照が発生）。</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenu"><apiName>addSubmenu</apiName><shortdesc>
        新しいメニューアイテムを挿入して、メニューにサブメニューを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>サブメニューとして作成された NativeMenuItem オブジェクトです。 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>追加するサブメニューを定義する NativeMenu オブジェクトです。
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>追加するメニューアイテムの表示ラベルです。
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        新しいメニューアイテムを挿入して、メニューにサブメニューを追加します。
        
        <p><codeph>addSubMenu()</codeph> メソッドを呼び出すと、新しいメニューアイテムを作成するのと同様の処理が実行されます。メニューアイテムをメニューに追加し、アイテムの <codeph>submenu</codeph> プロパティに NativeMenu オブジェクトを割り当てます。</p>
        
        <p><b>注意：</b>メニューをそのメニューのサブメニューとして追加すると（循環参照）、アプリケーションが異常停止することがあります。</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenuAt"><apiName>addSubmenuAt</apiName><shortdesc>
        指定された位置に新しいメニューアイテムを挿入して、メニューにサブメニューを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>サブメニューとして作成された NativeMenuItem オブジェクトです。 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>追加するサブメニューを定義する NativeMenu オブジェクトです。
        </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>追加するメニューアイテムを挿入する、このメニューの <codeph>items</codeph> 配列の位置です。
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>追加するメニューアイテムの表示ラベルです。
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        指定された位置に新しいメニューアイテムを挿入して、メニューにサブメニューを追加します。
        
        <p><codeph>addSubMenuAt()</codeph> メソッドを呼び出すと、新しいメニューアイテムを作成するのと同様の処理が実行されます。メニューの指定された位置にメニューアイテムを挿入し、アイテムの <codeph>submenu</codeph> プロパティに NativeMenu オブジェクトを割り当てます。</p>
        
        <p><b>注意：</b>メニューをそのメニューのサブメニューとして追加すると（循環参照）、アプリケーションが異常停止することがあります。</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:clone"><apiName>clone</apiName><shortdesc>
        
        メニューおよびすべてのアイテムのコピーを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
        
        メニューおよびすべてのアイテムのコピーを作成します。
        
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:containsItem"><apiName>containsItem</apiName><shortdesc>
         このメニューが、指定されたメニューアイテムを含むかどうかを報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>（<codeph>item</codeph> がこのメニューに存在する場合）。
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>検索対象の NativeMenuItem オブジェクトです。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         このメニューが、指定されたメニューアイテムを含むかどうかを報告します。
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:display"><apiName>display</apiName><shortdesc>
        このメニューを、指定された位置にポップアップ表示します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stage</apiItemName><apiOperationClassifier>flash.display:Stage</apiOperationClassifier><apiDesc>このメニューが表示される Stage オブジェクトです。
		
        </apiDesc></apiParam><apiParam><apiItemName>stageX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>このメニューを表示するステージの起点を基準とした、水平方向のピクセル数です。
		
        </apiDesc></apiParam><apiParam><apiItemName>stageY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>このメニューが表示されるステージの起点を基準にした垂直方向のピクセル数です。
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
        このメニューを、指定された位置にポップアップ表示します。
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemAt"><apiName>getItemAt</apiName><shortdesc>
         指定されたインデックス位置にあるメニューアイテムを取得します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>index</codeph> が、メニューの <codeph>items</codeph> 配列の範囲外の場合。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>メニューの指定された位置にある NativeMenuItem オブジェクトです。
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>0 から始まる、返すアイテムの位置です。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定されたインデックス位置にあるメニューアイテムを取得します。  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemByName"><apiName>getItemByName</apiName><shortdesc>
         指定された名前を持つメニューアイテムを取得します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定された名前を持つ NativeMenuItem オブジェクト、または <codeph>null</codeph>（メニューにそのようなアイテムがない場合）です。
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>検索対象のストリングです。
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定された名前を持つメニューアイテムを取得します。
         
         <p><b>注意：</b>メニューアイテムの <codeph>name</codeph> プロパティは、デフォルトでは割り当てられていません。</p>
            
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemIndex"><apiName>getItemIndex</apiName><shortdesc>
         指定されたアイテムの位置を取得します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定されたアイテムの 0 から始まるこのメニューでの位置、または <codeph>null</codeph> (アイテムがこのメニューに存在しない場合) です。
         
         </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>検索対象の NativeMenuItem オブジェクトです。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定されたアイテムの位置を取得します。 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeAllItems"><apiName>removeAllItems</apiName><shortdesc>
         メニューからすべてのアイテムを削除します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
         メニューからすべてのアイテムを削除します。  
         
         
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItem"><apiName>removeItem</apiName><shortdesc>
         指定されたメニューアイテムを削除します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>item</codeph> がこのメニューに存在しない場合。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>このメニューから削除する NativeMenuItem オブジェクトです。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定されたメニューアイテムを削除します。 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItemAt"><apiName>removeItemAt</apiName><shortdesc>
         指定されたインデックス位置にあるメニューアイテムを削除して返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>index</codeph> が、このメニューの <codeph>items</codeph> 配列の範囲外の場合。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>削除された NativeMenuItem オブジェクトです。
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>0 から始まる、削除するアイテムの位置です。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定されたインデックス位置にあるメニューアイテムを削除して返します。  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:setItemIndex"><apiName>setItemIndex</apiName><shortdesc>
         指定された位置に、メニューアイテムを移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>index</codeph> が、メニューの <codeph>items</codeph> 配列の範囲外の場合。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>移動する NativeMenuItem オブジェクトです。
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc><codeph>item</codeph> の移動先となる、0 から始まるメニューの位置です。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         指定された位置に、メニューアイテムを移動します。該当するアイテムがまだメニュー内にない場合、このメソッドを呼び出すとメニューにアイテムが追加されます。
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenu:items:get"><apiName>items</apiName><shortdesc>
         このメニューの NativeMenuItem の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         このメニューの NativeMenuItem の配列です。
         
         <p>配列は、表示順にソートされています。</p>
         
         <p><i>注意：</i>このプロパティは、AIR 1.0 では読み取り専用です。AIR 1.1 で、読み取り / 書き込み可能になりました。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:numItems:get"><apiName>numItems</apiName><shortdesc>
         このメニューの NativeMenuItem オブジェクトの数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         このメニューの NativeMenuItem オブジェクトの数です。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:parent:get"><apiName>parent</apiName><shortdesc>
         親メニューです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         親メニューです。  
         
         <p>ルート (最上位) メニューオブジェクトの <codeph>parent</codeph> は、<codeph>null</codeph> になります。</p>
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
DisplayObjectContainer クラスは、表示リストで表示オブジェクトコンテナとして機能するすべてのオブジェクトの基本クラスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>子オブジェクトを持つすべての表示オブジェクトの抽象基本クラスです。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
DisplayObjectContainer クラスは、表示リストで表示オブジェクトコンテナとして機能するすべてのオブジェクトの基本クラスです。表示リストは、Flash Player または Adobe AIR に表示されるすべてのオブジェクトを管理します。  DisplayObjectContainer クラスは、表示リスト内で表示オブジェクトを配置するために使用します。各 DisplayObjectContainer オブジェクトは、オブジェクトの z 順序を編成するために独自の子リストを持っています。z 順序は、どのオブジェクトを前面、背面、その他に描画するかを決定する、前から後ろへの順序です。 
 
 <p>DisplayObject は抽象基本クラスであるため、DisplayObject を直接呼び出すことはできません。<codeph>new DisplayObject()</codeph> を呼び出すと <codeph>ArgumentError</codeph> 例外がスローされます。</p>
 
 DisplayObjectContainer クラスは、子オブジェクトを持つすべてのオブジェクトの抽象基本クラスです。これは直接インスタンス化することはできません。<codeph>new DisplayObjectContainer()</codeph> コンストラクターを呼び出すと、<codeph>ArgumentError</codeph> 例外がスローされます。
 
 <p>詳しくは、『<i>ActionScript 3.0 のプログラミング</i>』の「表示のプログラミング」の章を参照してください。</p>
 
 </apiDesc><example conref="examples\DisplayObjectContainerExample.as"> 次の例では、クラス <codeph>DisplayObjectContainerExample</codeph> を使用して、5 つのオレンジ色の四角形を連続して作成します。これを行うには、以下の手順を実行します。
 
 <ol>
     <li>コンストラクターは <codeph>configureAssets()</codeph> メソッドを呼び出します。</li>
 
  <li><codeph>configureAssets()</codeph> メソッドは、<codeph>child</codeph> および <codeph>lastChild</codeph> Sprite オブジェクトを作成します。</li>
 
    <li><codeph>for</codeph> ループは、オレンジ色の四角形を 5 個作成し、それらを 1 つずつ配置します。</li>
 
     <li>CustomSprite オブジェクトが作成されるたびに、そのコンストラクターは <codeph>draw()</codeph> メソッド（<codeph>CustomSprite</codeph> オブジェクトのメソッド）を呼び出します。これにより、50 x 50 ピクセルの四角形が、Graphics クラスの <codeph>beginFill()</codeph> メソッド、<codeph>drawRect()</codeph> メソッド、および <codeph>endFill()</codeph> メソッドを呼び出すことで作成されます。<codeph>addChild()</codeph> メソッドは、各四角形を表示リストに追加します。</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class DisplayObjectContainerExample extends Sprite {
        private var gutter:uint     = 5;
        private var childCount:uint = 5;

        public function DisplayObjectContainerExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var child:Sprite = new CustomSprite();
            var lastChild:Sprite = child;
            for (var i:uint = 1; i &lt;= childCount; i++) {
                child = new CustomSprite();
                child.x = lastChild.x + lastChild.width + gutter;
                addChild(child);
                lastChild = child;
            }
        }
    }
}

import flash.display.Sprite;

class CustomSprite extends Sprite {
    private var size:uint = 50;
    private var bgColor:uint = 0xFFCC00;

    public function CustomSprite() {
        draw(size, size);
    }

    private function draw(w:uint, h:uint):void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:DisplayObjectContainer:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
	新しい DisplayObjectContainer() コンストラクターを呼び出すと、ArgumentError 例外がスローされます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	<codeph>new DisplayObjectContainer()</codeph> コンストラクターを呼び出すと、<codeph>ArgumentError</codeph> 例外がスローされます。ただし、<i/>次に示す DisplayObjectContainer のサブクラスについてはコンストラクターを呼び出すことができます。
	
	<ul>
	
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
 	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:DisplayObjectContainer:addChild"><apiName>addChild</apiName><shortdesc>
     この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>子が親と同じ場合にスローされます。呼び出し元が、追加されている子の子（または孫など）の場合もスローされます。
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>child</codeph> パラメーターで渡す DisplayObject インスタンスです。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>この DisplayObjectContainer インスタンスの子として追加する DisplayObject インスタンスです。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>この DisplayObjectContainer インスタンスに子オブジェクトを追加します。
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。子インスタンスは、この DisplayObjectContainer インスタンスにある他のすべての子の前（上）に追加されます（特定のインデックス位置に子を追加する場合は、<codeph>addChildAt()</codeph> メソッドを使用します）。
     
	 <p>既に異なる表示オブジェクトコンテナを親に持つ子オブジェクトを追加する場合は、もう一方の表示オブジェクトコンテナの子リストからそのオブジェクトが削除されます。 </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> 次の例では、<codeph>container1</codeph> および <codeph>container2</codeph> という名前の 2 つの Sprite オブジェクトを設定します。Sprite は表示オブジェクトコンテナの 1 つです。例では、<codeph>addChild()</codeph> メソッドを呼び出して、次のような表示階層を設定します。<codeph>container1</codeph> は <codeph>container2</codeph> の子で、他の 2 つの表示オブジェクト <codeph>circle1</codeph> と <codeph>circle2</codeph> は、<codeph>container1</codeph> の子です。<codeph>trace()</codeph> メソッドを呼び出すと、各オブジェクトの子の数が表示されます。<codeph>numChildren</codeph> のカウントには孫は含められません。
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChild_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>表示オブジェクトが表示リストに追加されたときに送出されます。
     </apiDesc></adobeApiEventDetail><shortdesc>表示オブジェクトが表示リストに追加されたときに送出されます。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>インデックス位置が子リストに存在しない場合にスローされます。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>子が親と同じ場合にスローされます。呼び出し元が、追加されている子の子（または孫など）の場合もスローされます。
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>child</codeph> パラメーターで渡す DisplayObject インスタンスです。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>この DisplayObjectContainer インスタンスの子として追加する DisplayObject インスタンスです。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>子を追加するインデックス位置です。既にオブジェクトが置かれているインデックス位置を指定すると、その位置にあるオブジェクトとその上に位置するすべてのオブジェクトが、子リスト内で 1 つ上の位置に移動します。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>この DisplayObjectContainer インスタンスに子オブジェクトを追加します。
     
  	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。子インスタンスは、指定されたインデックス位置に追加されます。インデックス 0 は、この DisplayObjectContainer オブジェクトの表示リストの背景または一番下を表します。
	 
	 <p>例えば、a、b、c というラベルの 3 個の表示オブジェクトをインデックス位置 0、2、1 にそれぞれ配置すると、以下のようになります。</p>
	 
	 <p><adobeimage alt="a の上に c、c の上に b" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>既に異なる表示オブジェクトコンテナを親に持つ子オブジェクトを追加する場合は、もう一方の表示オブジェクトコンテナの子リストからそのオブジェクトが削除されます。 </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.addChildAt.1.as"> 次の例では、<codeph>container</codeph> 表示オブジェクトコンテナを作成し、表示オブジェクト <codeph>circle1</codeph> をその表示リストに追加します。次に <codeph>container.addChildAt(circle2, 0)</codeph> を呼び出します。これは、<codeph>circle2</codeph> オブジェクトをインデックス位置ゼロ（黒）に追加し、<codeph>circle1</codeph> オブジェクトをインデックス位置 1 に移動します。
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
var circle2:Sprite = new Sprite();

container.addChild(circle1);
container.addChildAt(circle2, 0);

trace(container.getChildAt(0) == circle2); // true
trace(container.getChildAt(1) == circle1); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>addChild()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChildAt_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>表示オブジェクトが表示リストに追加されたときに送出されます。
     </apiDesc></adobeApiEventDetail><shortdesc>表示オブジェクトが表示リストに追加されたときに送出されます。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:areInaccessibleObjectsUnderPoint"><apiName>areInaccessibleObjectsUnderPoint</apiName><shortdesc>
	 特定の point ポイントを指定して呼び出した DisplayObjectContainer.getObjectsUnderPoint() メソッドから返されたリストに、セキュリティ上の制約のために省略される表示オブジェクトがあるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> は、そのポイントがセキュリティ上の制限のある子表示オブジェクトを含んでいることを示します。
	 
 	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>注目するポイントです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 特定の <codeph>point</codeph> ポイントを指定して呼び出した <codeph>DisplayObjectContainer.getObjectsUnderPoint()</codeph> メソッドから返されたリストに、セキュリティ上の制約のために省略される表示オブジェクトがあるかどうかを示します。デフォルトでは、<codeph>Security.allowDomain()</codeph> メソッドの呼び出しによって許可されていない限り、あるドメインのコンテンツから別のドメインのオブジェクトにアクセスすることはできません。 
	 
	 <p>詳しくは、次のトピックを参照してください。 </p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
     
     <li>Flash Player デベロッパーセンタートピック：<xref href="http://www.adobe.com/go/devnet_security_jp" scope="external">セキュリティ</xref></li>
     </ul>     
     
	 <p><codeph>point</codeph> パラメーターは、ステージの座標空間内にあり、表示オブジェクトコンテナの座標空間とは異なる場合があります。ただし、表示オブジェクトがステージである場合、座標空間は同じです。<codeph>globalToLocal()</codeph> メソッドおよび <codeph>localToGlobal()</codeph> メソッドを使用すると、これらの座標空間の間でポイントを変換できます。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.areInaccessibleObjectsUnderPoint.as"> 次に示すコードは <codeph>container</codeph> という名前の表示オブジェクトコンテナを作成します。次のコードブロックでは、Loader オブジェクトを使用してリモートファイルサーバーから "test.jpg" という名前の JPEG ファイルをロードします。LoaderContext オブジェクトの <codeph>checkPolicyFile</codeph> プロパティ（<codeph>load()</codeph> メソッドでパラメーターとして使用）が、<codeph>false</codeph> に設定されます。ファイルがロードされると、コードは <codeph>loaded()</codeph> メソッドを呼び出します。このメソッドは、<codeph>container.areInaccessibleObjectsUnderPoint()</codeph> を呼び出しますが、ロードされたコンテンツがアクセスできないドメインからのものであることを前提としているため、<codeph>true</codeph> の値が返されます。
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.system.LoaderContext;
import flash.net.URLRequest;
import flash.events.Event;
import flash.geom.Point;

var container:Sprite = new Sprite();

var urlReq:URLRequest = new URLRequest("http://localhost/RemoteFile.swf");
var ldr:Loader = new Loader();
var context:LoaderContext = new LoaderContext();
context.checkPolicyFile = false;
ldr.load(urlReq, context);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);

function loaded(event:Event):void {
    var pt:Point = new Point(1, 1);
    trace(container.areInaccessibleObjectsUnderPoint(pt)); // true
}

function urlNotFound(event:Event):void {
    trace("The URL was not found."); 
}
</codeblock> この例では、このコードによって生成される SWF ファイルが JPEG ファイルとは異なるドメインからロードされ、ロードされた JPEG ファイルがポイント (1, 1) に置かれることを想定しています。 
</example></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getObjectsUnderPoint()"><linktext>getObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:contains"><apiName>contains</apiName><shortdesc>
	 指定された表示オブジェクトが、DisplayObjectContainer インスタンスの子であるか、インスタンス自体であるかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph> となります（<codeph>child</codeph> オブジェクトが DisplayObjectContainer の子であるか、コンテナ自体である場合）。そうでない場合は、<codeph>false</codeph> となります。
	 
	  
	  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>テストする子オブジェクトです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定された表示オブジェクトが、DisplayObjectContainer インスタンスの子であるか、インスタンス自体であるかを指定します。検索には、この DisplayObjectContainer インスタンスの入った表示リスト全体が含まれます。孫、ひ孫などがそれぞれ <codeph>true</codeph> を返します。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.contains.1.as"> 次の例では、Sprite オブジェクトの数を設定し、いくつかを他の子リストに追加します。Sprite オブジェクトは、表示オブジェクトコンテナの 1 つです。さまざまなオブジェクト間の関係は、<codeph>contains()</codeph> メソッドを呼び出すと表示されます。
<codeblock>
import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();
var sprite4:Sprite = new Sprite();

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite1.contains(sprite1)); // true
trace(sprite1.contains(sprite2)); // true
trace(sprite1.contains(sprite3)); // true
trace(sprite1.contains(sprite4)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildAt"><apiName>getChildAt</apiName><shortdesc>
     指定のインデックス位置にある子表示オブジェクトインスタンスを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>インデックスが子リストに存在しない場合にスローされます。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>この子表示オブジェクトは、アクセス権が与えられていない Sandbox に属しています。子ムービーで <codeph>Security.allowDomain()</codeph> を呼び出すことにより、この状況を回避できます。
     
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定されたインデックス位置にある子表示オブジェクトです。
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>子オブジェクトのインデックス位置です。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     指定のインデックス位置にある子表示オブジェクトインスタンスを返します。
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildAt.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に 3 つの表示オブジェクトを <codeph>container</codeph> オブジェクトの子リストに追加します。<codeph>getChildAt()</codeph> メソッドを呼び出すと、子オブジェクトの位置が表示されます。
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();

container.addChild(sprite1);
container.addChild(sprite2);
container.addChildAt(sprite3, 0);

trace(container.getChildAt(0) == sprite3); // true
trace(container.getChildAt(1) == sprite1); // true
trace(container.getChildAt(2) == sprite2); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildByName()"><linktext>getChildByName()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildByName"><apiName>getChildByName</apiName><shortdesc>
     指定された名前に一致する子表示オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>この子表示オブジェクトは、アクセス権が与えられていない Sandbox に属しています。子ムービーで <codeph>Security.allowDomain()</codeph> メソッドを呼び出すことにより、この状況を回避できます。
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定された名前を持つ子表示オブジェクトです。
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>返される子の名前です。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     指定された名前に一致する子表示オブジェクトを返します。指定された名前を持つ子表示オブジェクトが複数存在する場合、メソッドは子リストの最初のオブジェクトを返します。
     
	 <p><codeph>getChildAt()</codeph> メソッドは、<codeph>getChildByName()</codeph> メソッドよりも処理が高速です。<codeph>getChildAt()</codeph> メソッドはキャッシュ配列の子にアクセスしますが、<codeph>getChildByName()</codeph> メソッドでは子にアクセスするためにリンクされたリストを移動する必要があります。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に 2 つの子表示オブジェクトをコンテナに追加します。次にコードは <codeph>getChildByName()</codeph> メソッドおよび <codeph>getChildIndex()</codeph> メソッドを呼び出し、<codeph>container</codeph> オブジェクトの子のインデックス位置を返します。このオブジェクトは、<codeph>name "sprite1"</codeph> を持ちます。
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildAt()"><linktext>getChildAt()</linktext></link><link href="flash.display.xml#DisplayObject/name"><linktext>flash.display.DisplayObject.name</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildIndex"><apiName>getChildIndex</apiName><shortdesc>
     子 DisplayObject インスタンスのインデックス位置を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>子パラメーターがこのオブジェクトの子でない場合にスローされます。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>特定する子表示オブジェクトのインデックス位置です。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>特定する DisplayObject インスタンスです。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>子 DisplayObject インスタンスのインデックス番号を返します。
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <codeph>child</codeph> DisplayObject インスタンスのインデックス位置を返します。
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に 2 つの子表示オブジェクトをコンテナに追加します。次にコードは <codeph>getChildByName()</codeph> メソッドおよび <codeph>getChildIndex()</codeph> メソッドを呼び出し、<codeph>container</codeph> オブジェクトの子のインデックス位置を返します。このオブジェクトは、<codeph>name "sprite1"</codeph> を持ちます。
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getObjectsUnderPoint"><apiName>getObjectsUnderPoint</apiName><shortdesc>
     指定されたポイントの下にあり、この DisplayObjectContainer インスタンスの子（または孫など）であるオブジェクトの配列を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定されたポイントの下にあり、この DisplayObjectContainer インスタンスの子または孫などであるオブジェクトの配列です。
     
 	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>注目するポイントです。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     指定されたポイントの下にあり、この DisplayObjectContainer インスタンスの子（または孫など）であるオブジェクトの配列を返します。セキュリティ上の理由でアクセスできない子オブジェクトは返される配列から除かれます。このようなセキュリティ上の制限が、返される配列に与えている影響について判別するには、<codeph>areInaccessibleObjectsUnderPoint()</codeph> メソッドを呼び出します。
	 
	 <p><codeph>point</codeph> パラメーターは、ステージの座標空間内にあり、表示オブジェクトコンテナの座標空間とは異なる場合があります。ただし、表示オブジェクトがステージである場合、座標空間は同じです。<codeph>globalToLocal()</codeph> メソッドおよび <codeph>localToGlobal()</codeph> メソッドを使用すると、これらの座標空間の間でポイントを変換できます。</p>
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getObjectsUnderPoint.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に重なり合う 2 つの子表示オブジェクトをコンテナに追加します。さらにコードは <codeph>getObjectsUnderPoint()</codeph> を 2 回（最初は 1 つのオブジェクトのみに接するポイントを使用して、次にオブジェクトが重なり合うポイントを使用して）呼び出し、返された Array の <codeph>length</codeph> で、コンテナの各ポイントにあるオブジェクト数を示します。
<codeblock>
import flash.display.Sprite;
import flash.geom.Point;

var container:Sprite = new Sprite();

var square1:Sprite = new Sprite();
square1.graphics.beginFill(0xFFCC00);
square1.graphics.drawRect(0, 0, 40, 40);

var square2:Sprite = new Sprite();
square2.graphics.beginFill(0x00CCFF);
square2.graphics.drawRect(20, 0, 30, 40);

container.addChild(square1);
container.addChild(square2);

var pt:Point = new Point(10, 20);
var objects:Array = container.getObjectsUnderPoint(pt); 
trace(objects.length); // 1

pt = new Point(35, 20);
objects = container.getObjectsUnderPoint(pt);
trace(objects.length);  // 2
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/areInaccessibleObjectsUnderPoint()"><linktext>areInaccessibleObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChild"><apiName>removeChild</apiName><shortdesc>
	 DisplayObjectContainer インスタンスの子リストから指定の child DisplayObject インスタンスを削除します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>子パラメーターがこのオブジェクトの子でない場合にスローされます。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>child</codeph> パラメーターで渡す DisplayObject インスタンスです。
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>削除する DisplayObject インスタンスです。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>DisplayObjectContainer インスタンスから子表示オブジェクトを削除します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 DisplayObjectContainer インスタンスの子リストから指定の <codeph>child</codeph> DisplayObject インスタンスを削除します。削除された子の <codeph>parent</codeph> プロパティは <codeph>null</codeph> に設定されます。その子に対する参照が存在しない場合、そのオブジェクトはガベージコレクションによって収集されます。DisplayObjectContainer の子より上位にある表示オブジェクトのインデックス位置は 1 つ下がります。
	 
	 <p>ガベージコレクターは、未使用のメモリスペースの再割り当てを行います。 変数またはオブジェクトがアクティブに参照されなくなり、任意の場所に保存されていない場合、ガベージコレクターによってメモリ内が探索され、それらに対する参照が存在しなければメモリスペースを占有している変数またはオブジェクトが一掃されます。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChild.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に 2 つの子表示オブジェクトをコンテナに追加します。イベントリスナーが <codeph>container</codeph> オブジェクトに追加されます。これは、ユーザーがコンテナの子オブジェクトをクリックしたときに、<codeph>removeChild()</codeph> メソッドが、クリックされた子をコンテナの子リストから削除することを目的としています。
<codeblock>
 
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);

container.addChild(circle1);
container.addChild(circle2);

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    container.removeChild(DisplayObject(event.target)); 
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 DisplayObjectContainer の子リストの指定された index 位置から子 DisplayObject を削除します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>この子表示オブジェクトは、呼び出し元オブジェクトにアクセス権が与えられていない Sandbox に属しています。子ムービーで <codeph>Security.allowDomain()</codeph> メソッドを呼び出すことにより、この状況を回避できます。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>インデックスが子リストに存在しない場合にスローされます。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>削除された DisplayObject インスタンスです。
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>削除する DisplayObject の子インデックスです。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>指定された <codeph>index</codeph> 位置にある子表示オブジェクトを、DisplayObjectContainer インスタンスから削除します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 DisplayObjectContainer の子リストの指定された <codeph>index</codeph> 位置から子 DisplayObject を削除します。削除された子の <codeph>parent</codeph> プロパティは <codeph>null</codeph> に設定されます。その子に対する参照が存在しない場合、そのオブジェクトはガベージコレクションによって収集されます。DisplayObjectContainer の子より上位にある表示オブジェクトのインデックス位置は 1 つ下がります。
	 
	 <p>ガベージコレクターは、未使用のメモリスペースの再割り当てを行います。 変数またはオブジェクトがアクティブに参照されなくなり、任意の場所に保存されていない場合、ガベージコレクターによってメモリ内が探索され、それらに対する参照が存在しなければメモリスペースを占有している変数またはオブジェクトが一掃されます。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChildAt.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に 2 つの子表示オブジェクトをコンテナに追加します。<codeph>removeChildAt()</codeph> メソッドを呼び出して、最下位のインデックス位置（0）にある子を削除するときに、リスト内の他の子オブジェクトが 1 つ下がることを、コードは示しています。
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.numChildren) // 2
container.removeChildAt(0); 
trace(container.numChildren) // 1
trace(container.getChildAt(0).name); // sprite2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	表示オブジェクトコンテナの既存の子の位置を変更します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>インデックスが子リストに存在しない場合にスローされます。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>子パラメーターがこのオブジェクトの子でない場合にスローされます。
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>インデックス番号を変更する子 DisplayObject インスタンスです。
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc><codeph>child</codeph> 表示オブジェクトの結果のインデックス番号です。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>既存の子のインデックス番号を変更します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	表示オブジェクトコンテナの既存の子の位置を変更します。これは、子オブジェクトのレイヤーに影響します。例えば、a、b、c というラベルの 3 個の表示オブジェクトをインデックス位置 0、1、2 にそれぞれ配置すると、以下のようになります。
	
	<p><adobeimage alt="a の上に b、b の上に c" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p><codeph>setChildIndex()</codeph> を使用し、既に占有されているインデックス位置を指定した場合、表示オブジェクトの前の位置と新しい位置の間にある位置だけが変化します。その他は変化しません。現在のインデックスよりも小さいインデックスに子を移動すると、その間のすべての子が、それぞれのインデックス参照について 1 増加します。現在のインデックスよりも大きいインデックスに子を移動すると、その間のすべての子が、それぞれのインデックス参照について 1 減少します。例えば、上記の例の表示オブジェクトコンテナの名前が <codeph>container</codeph> である場合、次に示すコードを呼び出すことによって、a および b というラベルが付けられた表示オブジェクトの位置を入れ替えることができます。</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>このコードによって、次に示すようなオブジェクトの配置になります。</p>
	
    <p><adobeimage alt="b の上に a、a の上に c" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc><example conref="examples\DisplayObjectContainer.setChildIndex.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に少しずつ重なり合う 3 つの子表示オブジェクトをコンテナに追加します。ユーザーがこれらのオブジェクトのいずれかをクリックしたとき、<codeph>clicked()</codeph> メソッドは <codeph>setChildIndex()</codeph> メソッドを呼び出し、クリックされたオブジェクトを <codeph>container</codeph> オブジェクトの子リストの最上位置に移動します。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.addEventListener(MouseEvent.CLICK, clicked);
 
var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(100, 40, 40);
circle2.addEventListener(MouseEvent.CLICK, clicked);
 
var circle3:Sprite = new Sprite();
circle3.graphics.beginFill(0x0000FF);
circle3.graphics.drawCircle(70, 80, 40);
circle3.addEventListener(MouseEvent.CLICK, clicked);
 
container.addChild(circle1);
container.addChild(circle2);
container.addChild(circle3);
addChild(container);
 
function clicked(event:MouseEvent):void {
    var circle:Sprite = Sprite(event.target);
    var topPosition:uint = container.numChildren - 1;
    container.setChildIndex(circle, topPosition);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getChildIndex()"><linktext>getChildIndex()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildren"><apiName>swapChildren</apiName><shortdesc>
	 指定された 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>子パラメーターがいずれもこのオブジェクトの子でない場合にスローされます。
	 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>先頭の子オブジェクトです。
	 
     </apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>2 番目の子オブジェクトです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定された 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。表示オブジェクトコンテナの他のすべての子オブジェクトは、同じインデックス位置に残されます。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildren.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に 2 つの子表示オブジェクトをコンテナに追加して、<codeph>swapChildren()</codeph> メソッドの呼び出す場合の影響を示しています。
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2

container.swapChildren(sprite1, sprite2);

trace(container.getChildAt(0).name); // sprite2
trace(container.getChildAt(1).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 子リスト内の指定されたインデックス位置に該当する 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>インデックスが子リストに存在しません。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>最初の子オブジェクトのインデックス位置です。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>2 番目の子オブジェクトのインデックス位置です。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 子リスト内の指定されたインデックス位置に該当する 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。表示オブジェクトコンテナの他のすべての子オブジェクトは、同じインデックス位置に残されます。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildrenAt.1.as"> 次の例では、<codeph>container</codeph> という名前の表示オブジェクトコンテナを作成し、次に子表示オブジェクトをコンテナに追加して、<codeph>swapChildrenAt()</codeph> メソッドの呼び出しにより、表示オブジェクトコンテナの子リストが再配置される方法を示しています。
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

container.addChild(sprite1);
container.addChild(sprite2);
container.addChild(sprite3);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite3

container.swapChildrenAt(0, 2);

trace(container.getChildAt(0).name); // sprite3
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:DisplayObjectContainer:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 オブジェクトの子に対してマウスが有効かどうかを調べます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 オブジェクトの子に対してマウスが有効かどうかを調べます。オブジェクトが使用可能なマウスの場合、マウスを使用して対話できます。デフォルト値は <codeph>true</codeph> です。
	 
	 <p>このプロパティは、SimpleButton クラスではなく、Sprite クラスのインスタンスを使用してボタンを作成するときに役立ちます。Sprite インスタンスを使用してボタンを作成する場合、他の Sprite インスタンスを追加するために <codeph>addChild()</codeph> メソッドを使用してボタンの修飾を選択できます。子として追加する Sprite インスタンスは、親インスタンスをターゲットオブジェクトとすることを想定するときに、マウスイベントのターゲットオブジェクトとなる場合があるため、マウスイベントについて予期しない動作を引き起こす可能性があります。親インスタンスが確実にマウスイベントのターゲットオブジェクトになるようにするには、親インスタンスの <codeph>mouseChildren</codeph> プロパティを <codeph>false</codeph> に設定します。</p>
	 <p> このプロパティを設定しても、イベントは送出されません。インタラクティブな機能を作成するには、<codeph>addEventListener()</codeph> メソッドを使用する必要があります。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.mouseChildren.1.as"> 次の例では、<codeph>container</codeph> という名前の Sprite オブジェクト（一種の表示オブジェクトコンテナ）を設定し、<codeph>mouseChildren</codeph> プロパティを <codeph>false</codeph> に設定するとき、<codeph>mouseClick</codeph> イベントのターゲットは、その子オブジェクトのいずれかではなく、<codeph>container</codeph> オブジェクトになります。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
container.name = "container";
addChild(container);

var circle:Sprite = new Sprite();
circle.name = "circle";
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);

container.addChild(circle);

container.mouseChildren = false;

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace(event.target.name); // container
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>flash.display.Sprite.buttonMode</linktext></link><link href="flash.events.xml#EventDispatcher/addEventListener()"><linktext>flash.events.EventDispatcher.addEventListener()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObjectContainer:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 このオブジェクトの子の数を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 このオブジェクトの子の数を返します。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> 次の例では、<codeph>container1</codeph> および <codeph>container2</codeph> という名前の 2 つの Sprite オブジェクトを設定します。Sprite は表示オブジェクトコンテナの 1 つです。例では、<codeph>addChild()</codeph> メソッドを呼び出して、次のような表示階層を設定します。<codeph>container1</codeph> は <codeph>container2</codeph> の子で、他の 2 つの表示オブジェクト <codeph>circle1</codeph> と <codeph>circle2</codeph> は、<codeph>container1</codeph> の子です。<codeph>trace()</codeph> メソッドを呼び出すと、各オブジェクトの子の数が表示されます。<codeph>numChildren</codeph> のカウントには孫は含められません。
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 オブジェクトの子に対してタブが有効かどうかを調べます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Stage オブジェクトのこのプロパティを呼び出すと、例外がスローされます。Stage オブジェクトはこのプロパティを実装しません。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 オブジェクトの子に対してタブが有効かどうかを調べます。オブジェクトの子に対してタブを有効または無効にします。デフォルト値は <codeph>true</codeph> です。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.tabChildren.1.as"> 次の例では、<codeph>container1</codeph> 表示オブジェクトコンテナを作成し、2 つの表示オブジェクト <codeph>circle1</codeph> と <codeph>circle2</codeph> をその子リストに追加します。例では、tabChildren を子の <codeph>false</codeph> に設定するため、<codeph>tabIndex</codeph> を使用して自身のタブ順を管理できます。
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();
container.tabChildren = false;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.tabIndex = 1;

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);
circle2.tabIndex = 0;

container.addChild(circle1);
container.addChild(circle2);
</codeblock> この例の結果を表示するには、ファイルをコンパイルして実行します。いずれかの円をクリックした後に、Tab キーを押すと、フォーカスがある表示オブジェクトを切り替えることができます。フォーカスを持っている表示オブジェクトは、黄色でハイライト表示された矩形で示されます。
</example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
     この DisplayObjectContainer インスタンスの TextSnapshot オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier></apiValueDef><apiDesc>
     この DisplayObjectContainer インスタンスの TextSnapshot オブジェクトを返します。
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.textSnapshot.1.as"> 次に示す例は、Flash オーサリング環境でのみ機能します。Flex では、静止テキストをファイルに追加する方法はありません。この例のための Flash ファイルを準備するには、ムービーの最初のフレームに静止テキストフィールドを追加します。その後、最初のフレームに次に示すスクリプトを挿入して、ファイルを実行します。出力は、追加した静止テキストとなります。
<codeblock>
trace(this.textSnapshot.getText(0, this.textSnapshot.charCount));
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot"><linktext>flash.text.TextSnapshot</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
 グラデーション塗りを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 グラデーション塗りを定義します。 
 
 <p>
 GraphicsGradientFill オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。GraphicsGradientFill オブジェクトの描画は、<codeph>Graphics.beginGradientFill()</codeph> メソッドの呼び出しに相当します。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsGradientFill:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
     新しい GraphicsGradientFill オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>linear</apiData><apiDesc>使用するグラデーションのタイプを指定する、GradientType クラスで定義された値です。有効な値は、<codeph>GradientType.LINEAR</codeph> または <codeph>GradientType.RADIAL</codeph> です。 
     
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>グラデーションで使用する RGB 16 進カラー値の配列（赤 0xFF0000、青 0x0000FF など）。最大 15 色まで指定できます。 各色について、alphas パラメーターと ratios パラメーターで対応する値を指定してください。
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>colors 配列内の各色に対応するアルファ値の配列。有効な値は 0 ～ 1 です。 値が 0 より小さい場合は、0 が使用されます。値が 1 より大きい場合は、1 が使用されます。
     
     </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>色分布比率の配列です。0 ～ 255 の範囲の値を指定できます。この値は、100％でサンプリングされる色の幅の割合をパーセントで定義します。 値 0 はグラデーションボックスの左の位置を表し、255 はグラデーションボックスの右の位置を表します。 
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスで定義される変換マトリックスです。flash.geom.Matrix クラスには、<codeph>createGradientBox()</codeph> メソッドがあります。このメソッドを使用すると、<codeph>beginGradientFill()</codeph> メソッドで使用できるマトリックスを容易に設定できます。
     
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>pad</apiData><apiDesc>使用する spread メソッドを指定する SpreadMethod クラスの値は、次のいずれかです。<codeph>SpreadMethod.PAD</codeph>、<codeph>SpreadMethod.REFLECT</codeph>、または <codeph>SpreadMethod.REPEAT</codeph>。 
     
     </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiType value=""/><apiData>rgb</apiData><apiDesc>使用する値を指定する InterpolationMethod クラスの値は、<codeph>InterpolationMethod.LINEAR_RGB</codeph> または <codeph>InterpolationMethod.RGB</codeph> です。
     
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiType value=""/><apiData>0.0</apiData><apiDesc>グラデーションの焦点の位置を制御する数値です。値が 0 の場合は、焦点が中央に設定されます。値が 0 の場合は、焦点がグラデーション円の一方の境界に設定されます。値が -1 の場合は、焦点がグラデーション円のもう一方の境界に設定されます。-1 未満または 1 より大きい値は、それぞれ -1 または 1 に丸められます。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     新しい GraphicsGradientFill オブジェクトを作成します。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsGradientFill:alphas"><apiName>alphas</apiName><shortdesc>
     colors 配列内の各色に対応するアルファ値の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     colors 配列内の各色に対応するアルファ値の配列です。有効な値の範囲は 0 ～ 1 です。値が 0 より小さい場合は、0 が使用されます。値が 1 より大きい場合は、1 が使用されます。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:colors"><apiName>colors</apiName><shortdesc>
     グラデーションで使用する RGB 16 進数カラー値の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     グラデーションで使用する RGB 16 進数カラー値の配列です。例えば、赤は 0xFF0000、青は 0x0000FF などです。最大 15 色まで指定できます。 各色について、alphas プロパティと ratios プロパティで対応する値を指定してください。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:focalPointRatio"><apiName>focalPointRatio</apiName><shortdesc>
     グラデーションの焦点の位置を制御する数値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     グラデーションの焦点の位置を制御する数値です。値が 0 の場合は、焦点が中央に設定されます。値 1 は焦点がグラデーション円のいずれかの境界にあることを示します。値が -1 の場合は、焦点がグラデーション円のもう一方の境界に設定されます。-1 未満または 1 より大きい値は、それぞれ -1 または 1 に丸められます。例えば、次の例では <codeph>focalPointRatio</codeph> が 0.75 に設定されています。
     
     <p><adobeimage alt="focalPointRatio が 0.75 に設定された放射状グラデーション" href="../../images/radial_sketch.jpg"/> </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:matrix"><apiName>matrix</apiName><shortdesc>
     Matrix クラスで定義される変換マトリックスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Matrix クラスで定義される変換マトリックスです。flash.geom.Matrix クラスには、<codeph>createGradientBox()</codeph> メソッドがあります。このメソッドを使用すると、<codeph>beginGradientFill()</codeph> メソッドで使用するマトリックスを設定できます。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:ratios"><apiName>ratios</apiName><shortdesc>
     色分布の比率の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     色分布の比率の配列です。 有効な値の範囲は 0 ～ 255 です。この値は、100％でサンプリングされる色の幅の割合をパーセントで定義します。 値 0 はグラデーションボックスの左の位置を表し、値 255 はグラデーションボックスの右の位置を表します。 
     
     <p><b>注意：</b>この値は、グラデーションボックス内の位置を表すもので、最終グラデーションの座標空間を表すものではありません。最終グラデーションは、グラデーションボックスより広くなったり狭くなったりする場合があります。<codeph>colors</codeph> プロパティの値ごとに、対応する値を指定してください。 </p>
     
     <p>例えば、青と緑の 2 色を含む線状グラデーションの場合、次の例は、<codeph>ratios</codeph> 配列の様々な値に基づいて配置される色を示します。</p>
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>グラデーション</entry></row></thead><tbody><row>
     
      <entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 0 と 127）" href="../../images/gradient-ratios-1.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 0 と 255）" href="../../images/gradient-ratios-2.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 127 と 255）" href="../../images/gradient-ratios-3.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     <p>配列内の値は、<codeph>[0, 63, 127, 190, 255]</codeph> のように順に増やしていく必要があります。 </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:interpolationMethod:get"><apiName>interpolationMethod</apiName><shortdesc>
     使用する値を指定する InterpolationMethod クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     使用する値を指定する InterpolationMethod クラスの値です。 有効な値は、<codeph>InterpolationMethod.LINEAR_RGB</codeph> または <codeph>InterpolationMethod.RGB</codeph> です。
     
     <p>例えば、2 色間のシンプルな線状グラデーション（<codeph>spreadMethod</codeph> パラメーターを <codeph>SpreadMethod.REFLECT</codeph> に設定）の例を次に示します。それぞれの補間方法で、外観は次のように変化します。 </p>
     
      <adobetable>
      
      
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="InterpolationMethod.LINEAR_RGB での線状グラデーション" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="InterpolationMethod.RGB での線状グラデーション" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
      </row><row>
      <entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
      <entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
      </row></tbody></tgroup></adobetable>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:spreadMethod:get"><apiName>spreadMethod</apiName><shortdesc>
     使用する spread メソッドを指定する SpreadMethod クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     使用する spread メソッドを指定する SpreadMethod クラスの値です。 値は <codeph>SpreadMethod.PAD</codeph>、<codeph>SpreadMethod.REFLECT</codeph>、または <codeph>SpreadMethod.REPEAT</codeph> です。 
     
     <p>例えば、2 つの色の間のシンプルな線状グラデーションを次の例に示します。</p>
     
     <codeblock>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       
     this.graphics.drawRect(0,0,100,100);
     </codeblock>
     
      <p>この例では spread メソッドに <codeph>SpreadMethod.PAD</codeph> を使用しているため、グラデーションの塗りは次のようになります。</p>
     
      <p><adobeimage alt="SpreadMethod.PAD での線状グラデーション" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
     
      <p>spread メソッドに <codeph>SpreadMethod.REFLECT</codeph> を使用する場合、グラデーションの塗りは次のようになります。</p>
     
      <p><adobeimage alt="SpreadMethod.REFLECT での線状グラデーション" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
     
      <p>spread メソッドに <codeph>SpreadMethod.REPEAT</codeph> を使用する場合、グラデーションの塗りは次のようになります。</p>
     
      <p><adobeimage alt="SpreadMethod.REPEAT での線状グラデーション" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:type:get"><apiName>type</apiName><shortdesc>
     使用するグラデーションのタイプを指定する GradientType クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     使用するグラデーションのタイプを指定する GradientType クラスの値です。値は <codeph>GradientType.LINEAR</codeph> または <codeph>GradientType.RADIAL</codeph> です。 
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Sprite"><apiName>Sprite</apiName><shortdesc>
 Sprite クラスは、表示リストの基本的要素です。つまり、グラフィックを表示でき、子を持つこともできる表示リストノードです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>ActionScript が作成するオブジェクトの基本表示オブジェクトです。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Sprite クラスは、表示リストの基本的要素です。つまり、グラフィックを表示でき、子を持つこともできる表示リストノードです。
 
 <p>Sprite オブジェクトはムービークリップと似ていますが、タイムラインを持ちません。Sprite は、タイムラインを必要としないオブジェクトに適した基本クラスです。例えば、Sprite は、通常はタイムラインを使用しないユーザーインターフェイス（UI）コンポーネントの論理基本クラスになります。</p>
 
 <p>Sprite クラスは、ActionScript 3.0 での新しいクラスです。これは MovieClip クラスの代替機能を提供します。また、以前のリリースの ActionScript のすべての機能を維持しているので後方互換性があります。</p>
 
 </apiDesc><example conref="examples\SpriteExample.as"> 次の例では、SpriteExample クラスを使用して、ステージにオレンジ色の四角形を描画し、ユーザーがその四角形をクリックまたはドラッグするたびにイベントを送出します。これを行うには、以下の手順を実行します。
 <ol>
  <li><codeph>size</codeph> プロパティ（100 x 100 ピクセル）と背景色（オレンジ色）を宣言します。</li>
 
  <li>次にコンストラクターは、新しい <codeph>child</codeph> Sprite オブジェクトを作成して使用し、2 つのイベントリスナーとその関連メソッドを追加します。<codeph>mouseDownHandler()</codeph> および <codeph>mouseUpHandler()</codeph> の 2 つのエディションがあります。</li>
 
  <li><codeph>child</codeph> Sprite オブジェクトが <codeph>draw()</codeph> メソッドに渡され、オレンジ色の四角形が描画されます。</li>
 
  <li>次に、<codeph>addChild()</codeph> メソッドの呼び出しによって、表示リストに子が配置されます。 </li>
 
  <li>イベントリスナーは、以下のように動作します。
 
  <ul>
      <li><codeph>mouseDownHandler()</codeph>：ユーザーが Sprite オブジェクトをクリックすると、このメソッドは mouseMove イベントリスナーである <codeph>mouseMoveHandler()</codeph> メソッドを追加します。これによって、マウスの移動が処理されます。次に <codeph>startDrag()</codeph> メソッドが呼び出されます。これによって Sprite オブジェクトのドラッグが可能になります。</li>
 
      <li><codeph>mouseUpHandler()</codeph>：マウスボタンが離されると、mouseMove イベントリスナーが削除され、<codeph>stopDrag()</codeph> メソッドが呼び出されます。これによって、オレンジ色の四角形の位置が固定されます。</li>
 
      <li><codeph>mouseMoveHandler</codeph>：左マウスボタンが押されている間、このメソッドはプレーヤーに対して引き続きオレンジ色の四角形を再描画するよう指示します。</li>
 
  </ul>
  </li>
 
 </ol>
 
 <p><b>注意：</b>イベントリスナーのメソッドそれぞれが、ローカル変数 <codeph>sprite</codeph> を宣言します。これにより、イベントの <codeph>target</codeph> プロパティが割り当てられます。</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;

    public class SpriteExample extends Sprite {
        private var size:uint    = 100;
        private var bgColor:uint = 0xFFCC00;

        public function SpriteExample() {
            var child:Sprite = new Sprite();
            child.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
            child.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
            draw(child);
            addChild(child);
        }

        private function mouseDownHandler(event:MouseEvent):void {
            trace("mouseDownHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.startDrag();
        }

        private function mouseUpHandler(event:MouseEvent):void {
            trace("mouseUpHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.stopDrag();
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            trace("mouseMoveHandler");
            event.updateAfterEvent();
        }

        private function draw(sprite:Sprite):void {
            sprite.graphics.beginFill(bgColor);
            sprite.graphics.drawRect(0, 0, size, size);
            sprite.graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:Sprite:Sprite"><apiName>Sprite</apiName><shortdesc>
	新しい Sprite インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	新しい Sprite インスタンスを作成します。Sprite インスタンスの作成後、<codeph>DisplayObjectContainer.addChild()</codeph> または <codeph>DisplayObjectContainer.addChildAt()</codeph> メソッドを呼び出して、親 DisplayObjectContainer に Sprite を追加できます。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:Sprite:startDrag"><apiName>startDrag</apiName><shortdesc>
	 指定されたスプライトをユーザーがドラッグできるようにします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.startDrag, startDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lockCenter</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ドラッグ可能なスプライトが、マウス位置の中心にロックされるか (<codeph>true</codeph>)、ユーザーがスプライト上で最初にクリックした点にロックされるか (<codeph>false</codeph>) を指定します。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>bounds</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Sprite の制限矩形を指定する Sprite の親の座標を基準にした相対値です。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定されたスプライトをユーザーがドラッグできるようにします。<codeph>Sprite.stopDrag()</codeph> メソッドを呼び出して明示的に停止するか、他のスプライトをドラッグ可能にするまでの間、スプライトはドラッグ可能なままになります。一度に 1 つのスプライトのみドラッグ可能です。
	 <p>3 次元表示オブジェクトがマウスを追いかけ、<codeph>Sprite.startDrag()</codeph> が、表示オブジェクトによって定義された 3 次元平面の中でオブジェクトを移動します。または、表示オブジェクトが 2 次元オブジェクトであり、3 次元オブジェクトの子である場合は、親である 3 次元オブジェクトによって定義された 3 次元平面の中を 2 次元オブジェクトが移動します。</p>
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> 次の例では、<codeph>circle</codeph> スプライトおよび 2 つの <codeph>target</codeph> スプライトを作成します。ユーザーがスプライト上にカーソルを置き、マウスボタンを押したとき、<codeph>startDrag()</codeph> メソッドが <codeph>circle</codeph> スプライト上に呼び出され、ユーザーがマウスボタンを離したときには、<codeph>stopDrag()</codeph> メソッドが呼び出されます。これによって、ユーザーはスプライトをドラッグできるようになります。マウスボタンが離された時点で、<codeph>mouseRelease()</codeph> メソッドが呼び出されます。このメソッドは、<codeph>name</codeph>（<codeph>dropTarget</codeph> オブジェクトのもの）、つまり、ユーザーが <codeph>circle</codeph> スプライトをドラッグする先をトレースします。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Sprite:stopDrag"><apiName>stopDrag</apiName><shortdesc>
	 startDrag() メソッドを終了します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sprite, movieclip.stopDrag, stopDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 <codeph>startDrag()</codeph> メソッドを終了します。<codeph>startDrag()</codeph> メソッドによってドラッグ可能になったスプライトは、<codeph>stopDrag()</codeph> メソッドを追加するか、他のスプライトがドラッグ可能になるまで、ドラッグ可能のままです。一度に 1 つのスプライトのみドラッグ可能です。
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> 次の例では、<codeph>circle</codeph> スプライトおよび 2 つの <codeph>target</codeph> スプライトを作成します。ユーザーがスプライト上にカーソルを置き、マウスボタンを押したとき、<codeph>startDrag()</codeph> メソッドが <codeph>circle</codeph> スプライト上に呼び出され、ユーザーがマウスボタンを離したときには、<codeph>stopDrag()</codeph> メソッドが呼び出されます。これによって、ユーザーはスプライトをドラッグできるようになります。マウスボタンが離された時点で、<codeph>mouseRelease()</codeph> メソッドが呼び出されます。このメソッドは、<codeph>name</codeph>（<codeph>dropTarget</codeph> オブジェクトのもの）、つまり、ユーザーが <codeph>circle</codeph> スプライトをドラッグする先をトレースします。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Sprite:buttonMode:get"><apiName>buttonMode</apiName><shortdesc>
     このスプライトのボタンモードを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>このスプライトのボタンモードを指定します。
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     このスプライトのボタンモードを指定します。<codeph>true</codeph> の場合、このスプライトはボタンとして動作します。この場合、このスプライトは、マウスがこのスプライト上を通るとハンドカーソルの表示をトリガーし、このスプライトにフォーカスがあるときに Enter キーまたは Space キーが押されると <codeph>click</codeph> イベントを受け取ることができます。<codeph>useHandCursor</codeph> プロパティを <codeph>false</codeph> に設定することにより、ハンドカーソルの表示を抑制することができます。この場合はポインターが表示されます。
     
     <p>SimpleButton クラスを使用してボタンを作成する方が望ましい実装ですが、<codeph>buttonMode</codeph> プロパティを使用することにより、スプライトにボタンに似た機能を持たせることができます。タブ順序にスプライトを組み込むには、<codeph>tabEnabled</codeph> プロパティ (InteractiveObject クラスから継承されデフォルトは <codeph>false</codeph>) を <codeph>true</codeph> に設定します。さらに、スプライトの子をマウス対応にするかどうかも検討してください。イベントフローが混乱するため、ほとんどのボタンではその子オブジェクトに対するマウス操作を有効にしません。すべての子オブジェクトに対するマウス操作を無効にするには、<codeph>mouseChildren</codeph> プロパティ (DisplayObjectContainer クラスから継承) を <codeph>false</codeph> に設定する必要があります。</p>
     
     <p>MovieClip クラス (Sprite クラスのサブクラス) で <codeph>buttonMode</codeph> プロパティを使用すると、ボタンにいくつかの機能を追加できます。_up、_over、および _down のラベルが付いたフレームを組み込むと、自動状態変化になります（以前のバージョンの ActionScript で提供されていた、ボタンとして使用されるムービークリップ用の機能と似た機能）。こうした自動状態変化は、スプライトでは使用できません。スプライトはタイムラインを持たず、そのためラベルを付けるフレームがないためです。 </p>
	 
	 </apiDesc><example conref="examples\Sprite.buttonMode.1.as"> 次の例では、2 つのスプライトを作成し、<codeph>buttonMode</codeph> プロパティを片方は <codeph>true</codeph> に、もう片方は <codeph>false</codeph> に設定します。アプリケーションをコンパイルして実行するとき、両方のスプライトがマウスイベントに応答しますが、<codeph>buttonMode</codeph> が <codeph>true</codeph> に設定されたものはハンドカーソルを使用し、タブ順序に含められます。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton"><linktext>Button</linktext></link><link href="flash.display.xml#Sprite/useHandCursor"><linktext>Sprite.useHandCursor</linktext></link><link href="flash.display.xml#InteractiveObject/tabEnabled"><linktext>InteractiveObject.tabEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:dropTarget:get"><apiName>dropTarget</apiName><shortdesc>
	 スプライトのドラッグ先またはスプライトがドロップされた先の表示オブジェクトを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Sprite, Sprite.dropTarget, dropTarget
	 
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>スプライトのドラッグ先またはスプライトがドロップされた DisplayObject を指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 スプライトのドラッグ先またはスプライトがドロップされた先の表示オブジェクトを指定します。
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> 次の例では、<codeph>circle</codeph> スプライトおよび 2 つの <codeph>target</codeph> スプライトを作成します。ユーザーがスプライト上にカーソルを置き、マウスボタンを押したとき、<codeph>startDrag()</codeph> メソッドが <codeph>circle</codeph> スプライト上に呼び出され、ユーザーがマウスボタンを離したときには、<codeph>stopDrag()</codeph> メソッドが呼び出されます。これによって、ユーザーはスプライトをドラッグできるようになります。マウスボタンが離された時点で、<codeph>mouseRelease()</codeph> メソッドが呼び出されます。このメソッドは、<codeph>name</codeph>（<codeph>dropTarget</codeph> オブジェクトのもの）、つまり、ユーザーが <codeph>circle</codeph> スプライトをドラッグする先をトレースします。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:graphics:get"><apiName>graphics</apiName><shortdesc>
     ベクターの描画コマンドが発生するこのスプライトに属する Graphics オブジェクトを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Graphics オブジェクトを指定します。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     ベクターの描画コマンドが発生するこのスプライトに属する Graphics オブジェクトを指定します。
     
	 </apiDesc><example conref="examples\Sprite.graphics.1.as"> 次の例では、<codeph>circle</codeph> スプライトを作成し、その <codeph>graphics</codeph> プロパティを使用して黄色（0xFFCC00）で塗りつぶした円を描画します。
<codeblock>
import flash.display.Sprite;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:hitArea:get"><apiName>hitArea</apiName><shortdesc>
	 スプライトのヒット領域となる別のスプライトを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Sprite</apiValueClassifier></apiValueDef><apiDesc>
	 スプライトのヒット領域となる別のスプライトを指定します。<codeph>hitArea</codeph> プロパティが存在しないか、このプロパティの値が <codeph>null</codeph> または <codeph>undefined</codeph> の場合は、スプライト自体がヒット領域として使用されます。<codeph>hitArea</codeph> プロパティの値は、Sprite オブジェクトへの参照である場合があります。
	 
	 <p><codeph>hitArea</codeph> プロパティはいつでも変更できます。このプロパティを変更したスプライトには新しいヒット領域の動作が直ちに反映されます。ヒット領域として指定したスプライトは可視状態である必要はありません。不可視状態であっても、そのグラフィカルシェイプをヒット領域として検出できます。</p>
	 
	 <p><b>注意：</b><codeph>false</codeph> に、ヒット領域として指定したスプライトの <codeph>mouseEnabled</codeph> プロパティを設定する必要があります。そうしないと、ヒット領域として指定したスプライトがスプライトボタンではなくマウスイベントを受け取るので、スプライトボタンが機能しない可能性があります。</p>
	 
	 </apiDesc><example conref="examples\Sprite.hitArea.1.as"> 次の例では、<codeph>circle</codeph> スプライトおよび <codeph>square</codeph> スプライトを作成します。<codeph>square</codeph> スプライトは <codeph>hitArea</codeph>（<codeph>circle</codeph> スプライトのもの）です。したがって、ユーザーが <codeph>square</codeph> スプライトをクリックすると、<codeph>circle</codeph> スプライトは <codeph>click</codeph> イベントを送出します。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xCCFF00);
square.graphics.drawRect(200, 0, 100, 100);

circle.hitArea = square;
square.mouseEnabled = false;

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void{
    trace(event.target == circle); // true
    trace(event.target == square); // false
}

addChild(circle);
addChild(square);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 このスプライト内のサウンドを制御します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 このスプライト内のサウンドを制御します。
	 
	 </apiDesc><example conref="examples\Sprite.soundTransform.1.as"> 次の例では、<codeph>container</codeph> という名前のスプライトを作成し、Loader オブジェクトをその子リストに追加します。Loader オブジェクトは SWF ファイルをロードします。ユーザーが <codeph>tf</codeph> テキストフィールド <codeph>true</codeph> にあるリンクをクリックすると、<codeph>mute()</codeph> メソッドは <codeph>volume</codeph> プロパティを設定します。このプロパティは、<codeph>soundTransform</codeph> プロパティ（<codeph>container</codeph> スプライトのプロパティ）のプロパティです。
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.events.IOErrorEvent;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.text.TextField;
import flash.media.SoundTransform;

var container:Sprite = new Sprite();
addChild(container);

var ldr:Loader = new Loader;
var urlReq:URLRequest = new URLRequest("SoundPlayer.swf");
ldr.load(urlReq);

container.addChild(ldr);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);
            
var tf:TextField = new TextField();
tf.htmlText = "&lt;a href = 'event:Mute'>Mute / Unmute&lt;/a>";
addChild(tf);

var mySoundTransform:SoundTransform = new SoundTransform();
mySoundTransform.volume = 1;

tf.addEventListener(MouseEvent.CLICK, mute);

function mute(event:MouseEvent):void {    
    if (mySoundTransform.volume == 0) {
        mySoundTransform.volume = 1;
    } else {
        mySoundTransform.volume = 0;        
    }
    container.soundTransform = mySoundTransform;
}

function urlNotFound(event:IOErrorEvent):void {
    trace("The URL was not found."); 
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
	 buttonMode プロパティが true に設定されたスプライト上にマウスが移動したときに、指差しハンドポインター（ハンドカーソル）を表示するかどうかを示すブール値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>buttonMode プロパティが true に設定されたスプライト上にマウスが移動したときに、指差しハンドポインター（ハンドカーソル）を表示するかどうかを示すブール値です。 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 <codeph>buttonMode</codeph> プロパティが <codeph>true</codeph> に設定されたスプライト上にマウスが移動したときに、指差しハンドポインター（ハンドカーソル）を表示するかどうかを示すブール値です。<codeph>useHandCursor</codeph> プロパティのデフォルト値は <codeph>true</codeph> です。<codeph>useHandCursor</codeph> を <codeph>true</codeph> に設定すると、マウスがボタンスプライト上に移動したときに、指差し状態のハンドカーソルが表示されます。<codeph>useHandCursor</codeph> を <codeph>false</codeph> に設定すると、代わりに矢印のポインターが使用されます。
	 
	 <p><codeph>useHandCursor</codeph> プロパティはいつでも変更できます。このプロパティを変更したスプライトには、新しいカーソル外観が直ちに反映されます。 </p>
     
     <p product="flex"><b>注意：</b>子を持つスプライトの場合は、<codeph>mouseChildren</codeph> プロパティを <codeph>false</codeph> に設定します。 例えば、Flex &lt;mx:Label> コントロール上にハンドカーソルを表示させるには、<codeph>useHandCursor</codeph> および <codeph>buttonMode</codeph> プロパティを <codeph>true</codeph> に設定し、<codeph>mouseChildren</codeph> プロパティを <codeph>false</codeph> に設定します。</p>
	 
	 </apiDesc><example conref="examples\Sprite.useHandCursor.1.as"> 次の例では、2 つのスプライトを作成し、両方とも <codeph>buttonMode</codeph> プロパティは <codeph>true</codeph> に設定します。ただし、片方の <codeph>useHandCursor</codeph> プロパティは <codeph>true</codeph> に、もう片方は <codeph>false</codeph> に設定します。アプリケーションをコンパイルして実行すると、両方のスプライトもボタンとして応答しますが（タブ順序にも組み込まれる）、<codeph>useHandCursor</codeph> が <codeph>true</codeph> に設定されたものだけがハンドカーソルを使用します。
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.useHandCursor = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = true;
circle2.useHandCursor = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>buttonMode</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
 ビットマップ塗りを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 ビットマップ塗りを定義します。ビットマップは、スムージング、繰り返し、またはタイリング表示して領域を塗りつぶしたり、変形マトリックスを使用して操作できます。
 <p>
 GraphicsBitmapFill オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。GraphicsBitmapFill オブジェクトの描画は、<codeph>Graphics.beginBitmapFill()</codeph> メソッドの呼び出しに相当します。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsBitmapFill:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
     新しい GraphicsBitmapFill オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>表示されるビットを含む透明または不透明ビットマップイメージです。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスのマトリックスオブジェクトです。これを使用してビットマップ上に変形を定義します。
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc><codeph>true</codeph> の場合、ビットマップイメージが一定のパターンでタイル状に表示されます。<codeph>false</codeph> の場合、ビットマップイメージは繰り返されません。ビットマップからはみ出す塗り領域にはビットマップのエッジが使用されます。 
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><codeph>false</codeph> の場合、拡大ビットマップイメージは最近傍アルゴリズムを使用してレンダリングされ、ピクセル化されたように見えます。<codeph>true </codeph> の場合、拡大ビットマップイメージは双線形アルゴリズムを使用してレンダリングされます。通常は、最近傍アルゴリズムを使用したレンダリングの方が高速です。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     新しい GraphicsBitmapFill オブジェクトを作成します。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsBitmapFill:bitmapData"><apiName>bitmapData</apiName><shortdesc>
     透明または不透明なビットマップイメージです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
     透明または不透明なビットマップイメージです。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:matrix"><apiName>matrix</apiName><shortdesc>
     ビットマップ上の変形を定義する、（flash.geom.Matrix クラスの）マトリックスオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     ビットマップ上の変形を定義する、（flash.geom.Matrix クラスの）マトリックスオブジェクトです。例えば、次のマトリックスは、ビットマップを 45 度（π/4 ラジアン）回転します。
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:repeat"><apiName>repeat</apiName><shortdesc>
     ビットマップイメージを一定のパターンでタイル状に表示するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     ビットマップイメージを一定のパターンでタイル状に表示するかどうかを指定します。
     
     <p>
     <codeph>true</codeph> の場合、ビットマップイメージが一定のパターンでタイル状に表示されます。<codeph>false</codeph> の場合、ビットマップイメージは繰り返されません。ビットマップ境界からはみ出す塗り領域には、ビットマップのエッジの一番外側のピクセルが使用されます。</p>
     
     <p>例えば、次のビットマップ（20 x 20 ピクセルのチェッカーボードのパターン）を考えます。</p>
     
     <p><adobeimage alt="20 x 20 ピクセルの格子縞模様" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
     
     <p>次の例のように <codeph>repeat</codeph> が <codeph>true</codeph> に設定されている場合、ビットマップの塗りでビットマップが繰り返されます。</p>
     
     <p><adobeimage alt="60 x 60 ピクセルの格子縞模様" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
     
     <p><codeph>repeat</codeph> が <codeph>false</codeph> に設定されている場合、エッジのピクセルがビットマップの外側の塗り領域に使用されます。</p>
     
     <p><adobeimage alt="繰り返しのない 60 x 60 ピクセルイメージ" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsBitmapFill:smooth"><apiName>smooth</apiName><shortdesc>
     ビットマップイメージにスムージングアルゴリズムを適用するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     ビットマップイメージにスムージングアルゴリズムを適用するかどうかを指定します。
     <p>
     <codeph>false</codeph> の場合、拡大ビットマップイメージは最近傍アルゴリズムを使用してレンダリングされ、ピクセル化されたように見えます。<codeph>true</codeph> の場合、拡大ビットマップイメージは双線形アルゴリズムを使用してレンダリングされます。通常は、最近傍アルゴリズムを使用したレンダリングの方が高速です。
     </p>
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 線のスタイルを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsStroke</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 線のスタイルを定義します。 
 
 <p>
 GraphicsStroke オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。GraphicsStroke オブジェクトの描画は、線スタイルを設定する Graphics クラスのメソッドの呼び出しに相当します。例えば、<codeph>Graphics.lineStyle()</codeph> メソッド、<codeph>Graphics.lineBitmapStyle()</codeph> メソッド、<codeph>Graphics.lineGradientStyle()</codeph> メソッドなどがあります。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>flash.display.Graphics.lineBitmapStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsStroke:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 新しい GraphicsStroke オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>線の太さをポイント単位で示す整数。有効な値は 0 ～ 255 です。パラメーターが undefined である場合は、線は描画されません。0 未満の値を指定した場合は、デフォルトで 0 が適用されます。0 は極細線です。最大の太さは 255 です。255 を超える値を指定した場合は、デフォルトで 255 が適用されます。 
 
 </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ピクセル全体に対して線をヒンティングするかどうかを指定するブール値。この値は、曲線のアンカーの位置と線のサイズ自身の両方に影響を与えます。<codeph>pixelHinting</codeph> を <codeph>true</codeph> に設定すると、全ピクセル幅に線幅がヒンティングされます。<codeph>pixelHinting</codeph> を <codeph>false</codeph> に設定すると、曲線と直線で非連続が発生することがあります。例えば、次の図は、<codeph>pixelHinting</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドで使用）の設定が異なるだけで他はまったく同じ 2 つの角丸矩形がどのようにレンダリングされるかを示したものです（違いが分かるようにイメージは 200% に拡大されています）。
 
 <p><adobeimage alt="pixelHinting false および pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 <p>値を指定しない場合、線でピクセルのヒンティングが使用されません。</p>
  
 </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>使用する拡大・縮小モードを指定する LineScaleMode クラスの値です。
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> — オブジェクトが拡大 / 縮小される場合、常に線の太さが拡大 / 縮小されます（デフォルト）。
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> — 線の太さを拡大 / 縮小しません。
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> — オブジェクトを垂直方向に<i>のみ</i>拡大 / 縮小する場合は、線の太さを拡大 / 縮小しません。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.VERTICAL</codeph> に設定されているとします。左側の円は垂直方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
 
 <p><adobeimage alt="1 つの円は垂直方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> — オブジェクトを水平方向に<i>のみ</i>拡大 / 縮小する場合は、線の太さを拡大 / 縮小しません。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.HORIZONTAL</codeph> に設定されているとします。左側の円は水平方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
 
 <p><adobeimage alt="1 つの円は水平方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 
 </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>線の終端のキャップの種類を指定する CapsStyle クラスの値です。有効な値は次のとおりです。<codeph>CapsStyle.NONE</codeph>、<codeph>CapsStyle.ROUND</codeph>、および <codeph>CapsStyle.SQUARE</codeph>。この値を指定しない場合は、丸いキャップが使用されます。 
 <p>例えば、次の図は <codeph>capsStyle</codeph> のさまざまな設定を示します。それぞれの設定で、図の青い線は太さ 30 で、<codeph>capsStyle</codeph> が適用されています。重ね合わせた黒い線は太さ 1 で、<codeph>capsStyle</codeph> は適用されていません。
 </p>
 <p><adobeimage alt="NONE、ROUND、および SQUARE" href="../../images/linecap.jpg"/></p>
 
 </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>round</apiData><apiDesc>角で使用する接合点の外観の種類を指定する JointStyle クラスの値です。有効な値は次のとおりです。<codeph>JointStyle.BEVEL</codeph>、<codeph>JointStyle.MITER</codeph>、および <codeph>JointStyle.ROUND</codeph>。この値を指定しないと、角丸（"round"）の接合点が使用されます。 
 
 <p>例えば、次の図は <codeph>joints</codeph> のさまざまな設定を示します。それぞれの設定で、角のある青い線は太さ 30 で、<codeph>jointStyle</codeph> が適用されています。重ね合わせた黒い線は太さ 1 で、<codeph>jointStyle</codeph> は適用されていません。
 </p>
 
 <p><adobeimage alt="MITER、ROUND、および BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>注意：</b><codeph>joints</codeph> を <codeph>JointStyle.MITER</codeph> に設定すると、<codeph>miterLimit</codeph> パラメーターを使用して、マイターの長さを制限できます。</p>
 
 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3.0</apiData><apiDesc>マイターが切り取られる限度を示す数値です。有効な値の範囲は 1 ～ 255 で、この範囲を超えた値は 1 または 255 に丸められます。この値は、<codeph>jointStyle</codeph> を <codeph>"miter"</codeph> に設定した場合にのみ有効です。<codeph>miterLimit</codeph> の値により、線の接合点を越えてマイターを延長できる長さが決定します。マイターを延長できる長さは、この値と線の <codeph>thickness</codeph> が乗算されたものです。例えば、<codeph>miterLimit</codeph> の値が 2.5 で、<codeph>thickness</codeph> が 10 ピクセルの場合、マイターは 25 ピクセルで切り取られます。 
 
 <p>例として、次のような角のある線を考えます。どの線も <codeph>thickness</codeph> を 20 に設定して描画されていますが、<codeph>miterLimit</codeph> はそれぞれ 1、2、4 に設定されています。重ね合わされた黒の基準線は、接合点を示しています。</p>
 
 <p><adobeimage alt="miterLimit が 1、2、および 4 に設定されている線" href="../../images/miterLimit.jpg"/></p>
 
 <p><codeph>miterLimit</codeph> のそれぞれの値には、マイターが切り取られる独自の最大角度があります。次の表に、いくつかの例を示します。</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> の値：</entry><entry>角度が以下より小さい場合は切り取られる</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 度</entry></row><row><entry>2</entry>      <entry>60 度</entry></row><row><entry>4</entry>      <entry>30 度</entry></row><row><entry>8</entry>      <entry>15 度</entry></row></tbody></tgroup></adobetable>
 </apiDesc></apiParam><apiParam><apiItemName>fill</apiItemName><apiOperationClassifier>flash.display:IGraphicsFill</apiOperationClassifier><apiData>null</apiData><apiDesc>線を塗りつぶすためのデータを格納している IGraphicsFill インスタンス。IGraphicsFill インスタンスは、一連の塗りコマンドを表す場合があります。
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 新しい GraphicsStroke オブジェクトを作成します。
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsStroke:fill"><apiName>fill</apiName><shortdesc>
 線を塗りつぶすためのデータを格納しているインスタンスを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:IGraphicsFill</apiValueClassifier></apiValueDef><apiDesc>
 線を塗りつぶすためのデータを格納しているインスタンスを表します。IGraphicsFill インスタンスは、一連の塗りコマンドを表す場合があります。
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:miterLimit"><apiName>miterLimit</apiName><shortdesc>
 マイターが切り取られる限度を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 マイターが切り取られる限度を示します。有効な値の範囲は 1 ～ 255 で、この範囲を超えた値は 1 または 255 に丸められます。この値は、<codeph>jointStyle</codeph> を <codeph>"miter"</codeph> に設定した場合にのみ有効です。<codeph>miterLimit</codeph> の値により、線の接合点を越えてマイターを延長できる長さが決定します。マイターを延長できる長さは、この値と線の <codeph>thickness</codeph> が乗算されたものです。例えば、<codeph>miterLimit</codeph> の値が 2.5 で、<codeph>thickness</codeph> が 10 ピクセルの場合、マイターは 25 ピクセルで切り取られます。 
 
 <p>例として、次のような角のある線を考えます。どの線も <codeph>thickness</codeph> を 20 に設定して描画されていますが、<codeph>miterLimit</codeph> はそれぞれ 1、2、4 に設定されています。重ね合わされた黒の基準線は、接合点を示しています。</p>
 
 <p><adobeimage alt="miterLimit が 1、2、および 4 に設定されている線" href="../../images/miterLimit.jpg"/></p>
 
 <p><codeph>miterLimit</codeph> のそれぞれの値には、マイターが切り取られる独自の最大角度があります。次の表に、いくつかの例を示します。</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> の値：</entry><entry>角度が以下より小さい場合は切り取られる</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 度</entry></row><row><entry>2</entry>      <entry>60 度</entry></row><row><entry>4</entry>      <entry>30 度</entry></row><row><entry>8</entry>      <entry>15 度</entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:pixelHinting"><apiName>pixelHinting</apiName><shortdesc>
 ピクセル全体に対して線をヒンティングするかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
 ピクセル全体に対して線をヒンティングするかどうかを指定します。この値は、曲線のアンカーの位置と線のサイズ自身の両方に影響を与えます。<codeph>pixelHinting</codeph> を <codeph>true</codeph> に設定すると、全ピクセル幅に線幅がヒンティングされます。<codeph>pixelHinting</codeph> を <codeph>false</codeph> に設定すると、曲線と直線で非連続が発生することがあります。例えば、次の図は、<codeph>pixelHinting</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドで使用）の設定が異なるだけで他はまったく同じ 2 つの角丸矩形がどのようにレンダリングされるかを示したものです（違いが分かるようにイメージは 200% に拡大されています）。
 
 <p><adobeimage alt="pixelHinting false および pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:thickness"><apiName>thickness</apiName><shortdesc>
 線の太さをポイント単位で示します。有効な値は 0 ～ 255 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 線の太さをポイント単位で示します。有効な値は 0 ～ 255 です。パラメーターが undefined である場合は、線は描画されません。0 未満の値を指定した場合は、デフォルトで 0 が適用されます。0 は極細線です。最大の太さは 255 です。255 を超える値を指定した場合は、デフォルトで 255 が適用されます。
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:caps:get"><apiName>caps</apiName><shortdesc>
 線の終端のキャップの種類を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 線の終端のキャップの種類を指定します。有効な値は次のとおりです。<codeph>CapsStyle.NONE</codeph>、<codeph>CapsStyle.ROUND</codeph>、および <codeph>CapsStyle.SQUARE</codeph>。この値を指定しない場合は、丸いキャップが使用されます。 
 <p>例えば、次の図は <codeph>capsStyle</codeph> のさまざまな設定を示します。それぞれの設定で、図の青い線は太さ 30 で、<codeph>capsStyle</codeph> が適用されています。重ね合わせた黒い線は太さ 1 で、<codeph>capsStyle</codeph> は適用されていません。
 </p>
 <p><adobeimage alt="NONE、ROUND、および SQUARE" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:joints:get"><apiName>joints</apiName><shortdesc>
 角で使用する接合点の外観の種類を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 角で使用する接合点の外観の種類を指定します。有効な値は次のとおりです。<codeph>JointStyle.BEVEL</codeph>、<codeph>JointStyle.MITER</codeph>、および <codeph>JointStyle.ROUND</codeph>。この値を指定しないと、角丸（"round"）の接合点が使用されます。 
 
 <p>例えば、次の図は <codeph>joints</codeph> のさまざまな設定を示します。それぞれの設定で、角のある青い線は太さ 30 で、<codeph>jointStyle</codeph> が適用されています。重ね合わせた黒い線は太さ 1 で、<codeph>jointStyle</codeph> は適用されていません。
 </p>
 
 <p><adobeimage alt="MITER、ROUND、および BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>注意：</b><codeph>joints</codeph> を <codeph>JointStyle.MITER</codeph> に設定すると、<codeph>miterLimit</codeph> パラメーターを使用して、マイターの長さを制限できます。</p>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
 線の太さの拡大 / 縮小を表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 線の太さの拡大 / 縮小を表します。有効な値は次のとおりです。
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> — オブジェクトが拡大 / 縮小される場合、常に線の太さが拡大 / 縮小されます（デフォルト）。
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> — 線の太さを拡大 / 縮小しません。
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> — オブジェクトを垂直方向に<i>のみ</i>拡大 / 縮小する場合は、線の太さを拡大 / 縮小しません。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.VERTICAL</codeph> に設定されているとします。左側の円は垂直方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
 
 <p><adobeimage alt="1 つの円は垂直方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> — オブジェクトを水平方向に<i>のみ</i>拡大 / 縮小する場合は、線の太さを拡大 / 縮小しません。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.HORIZONTAL</codeph> に設定されているとします。左側の円は水平方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
 
 <p><adobeimage alt="1 つの円は水平方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 グラフィック塗りの最後を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 グラフィック塗りの最後を示します。GraphicsEndFill オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。
 
 <p>
 GraphicsEndFill オブジェクトの描画は、<codeph>Graphics.endFill()</codeph> メソッドの呼び出しに相当します。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsEndFill:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 塗りを明示的に終了するために、Graphics.drawGraphicsData() メソッドと共に使用するオブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 塗りを明示的に終了するために、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用するオブジェクトを作成します。
 
 
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderPrecision"><apiName>ShaderPrecision</apiName><shortdesc>
	 このクラスによって、Shader クラスの precisionHint プロパティの有効な値を表す定数が定義されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 このクラスによって、Shader クラスの <codeph>precisionHint</codeph> プロパティの有効な値を表す定数が定義されます。定数はそれぞれシェーダー操作を実行する精度モードのいずれかを表します。
	 
	 <p>精度モードの選択は、次のシェーダー操作に影響します。これらの操作は、SSE 命令セットを内蔵する Intel プロセッサーでは高速になります。</p>
	 
	 <ul>
	   <li><codeph>sin(x)</codeph></li>
	   <li><codeph>cos(x)</codeph></li>
	   <li><codeph>tan(x)</codeph></li>
	   <li><codeph>asin(x)</codeph></li>
	   <li><codeph>acos(x)</codeph></li>
	   <li><codeph>atan(x)</codeph></li>
	   <li><codeph>atan(x, y)</codeph></li>
	   <li><codeph>exp(x)</codeph></li>
	   <li><codeph>exp2(x)</codeph></li>
	   <li><codeph>log(x)</codeph></li>
	   <li><codeph>log2(x)</codeph></li>
	   <li><codeph>pow(x, y)</codeph></li>
	   <li><codeph>reciprocal(x)</codeph></li>
	   <li><codeph>sqrt(x)</codeph></li>
	 </ul>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links><apiValue id="flash.display:ShaderPrecision:FAST"><apiName>FAST</apiName><shortdesc>
		 fast 精度モードを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fast</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 fast 精度モードを表します。
		 
		 <p>fast 精度モードは処理速度を最大にするように設計されていますが、異なるプラットフォームや個々の CPU 構成で一貫した結果が得られません。多くの場合、グラフィックエフェクトの作成にはアーティファクトが見えることもなく、この精度レベルで十分です。</p>
		 
		 <p>fast 精度モードの方が、ルックアップテーブルを使用するよりも高速です。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderPrecision:FULL"><apiName>FULL</apiName><shortdesc>
		 full 精度モードを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 full 精度モードを表します。
		 
		 <p>full 精度モードでは、シェーダーはすべての算術演算を完全桁の IEEE 32 ビット浮動少数規格で計算します。このモードでは、すべてのプラットフォームで一貫した動作が得られます。このモードでは、三角関数や指数関数などの一部の算術演算について処理速度が低下することがあります。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:BlendMode"><apiName>BlendMode</apiName><shortdesc>
ブレンドモードの視覚効果のために定数値を提供するクラスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
ブレンドモードの視覚効果のために定数値を提供するクラスです。これらの定数は以下で使用されます。

<ul>

	<li> flash.display.DisplayObject クラスの <codeph>blendMode</codeph> プロパティです。</li>

	<li> <codeph>blendMode</codeph> パラメーター（flash.display.BitmapData クラスの <codeph>draw()</codeph> メソッドのパラメーター）です。</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiValue id="flash.display:BlendMode:ADD"><apiName>ADD</apiName><shortdesc>
表示オブジェクトの要素カラーの値を背景色に加算し、その際に上限 0xFF を適用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>add</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの要素カラーの値を背景色に加算し、その際に上限 0xFF を適用します。この設定は、2 つのオブジェクト間で色を明るくするディゾルブをアニメーションにするときによく使用されます。

<p>例えば、表示オブジェクトのピクセルの RGB 値が 0xAAA633 で、背景のピクセルの RGB 値が 0xDD2200 の場合、0xAA + 0xDD > 0xFF、0xA6 + 0x22 = 0xC8、および 0x33 + 0x00 = 0x33 であるので、表示されるピクセルの RGB 値は 0xFFC833 になります。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ALPHA"><apiName>ALPHA</apiName><shortdesc>
表示オブジェクトの各ピクセルのアルファ値を背景に適用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alpha</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの各ピクセルのアルファ値を背景に適用します。このためには、親表示オブジェクトの <codeph>blendMode</codeph> プロパティを <codeph>flash.display.BlendMode.LAYER</codeph> に設定する必要があります。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DARKEN"><apiName>DARKEN</apiName><shortdesc>
表示オブジェクトの要素カラーと背景色のうち暗い方（値が小さい方）の色を選択します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>darken</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの要素カラーと背景色のうち暗い方（値が小さい方）の色を選択します。この設定は、重ね合わせタイプによく使用されます。 

<p>例えば、表示オブジェクトのピクセルの RGB 値が 0xFFCC33, で、背景のピクセルの RGB 値が 0xDDF800 の場合、0xFF > 0xDD、0xCC &lt; 0xF8、0x33 > 0x00 = 33 であるので、表示されるピクセルの RGB 値は 0xDDCC00 になります。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DIFFERENCE"><apiName>DIFFERENCE</apiName><shortdesc>
表示オブジェクトの要素カラーと背景色を比較し、2 つの要素カラーのうち明るい方の値から暗い方の値を差し引きます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>difference</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの要素カラーと背景色を比較し、2 つの要素カラーのうち明るい方の値から暗い方の値を差し引きます。この設定は、明るい色によく使用されます。 

<p>例えば、表示オブジェクトの 1 つのピクセルの RGB 値が 0xFFCC33 で、背景のピクセルの RGB 値が 0xDDF800 の場合、0xFF - 0xDD = 0x22、0xF8 - 0xCC = 0x2C、0x33 - 0x00 = 0x33 であるため、表示されるピクセルの RGB 値は 0x222C33 になります。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ERASE"><apiName>ERASE</apiName><shortdesc>
表示オブジェクトのアルファ値に基づいて背景を消去します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>erase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトのアルファ値に基づいて背景を消去します。この処理では、親表示オブジェクトの <codeph>blendMode</codeph> プロパティを <codeph>flash.display.BlendMode.LAYER</codeph> に設定する必要があります。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:HARDLIGHT"><apiName>HARDLIGHT</apiName><shortdesc>
表示オブジェクトの暗さに基づいて、各ピクセルの色を調整します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>hardlight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの暗さに基づいて、各ピクセルの色を調整します。表示オブジェクトが 50% グレーよりも明るい場合、表示オブジェクトと背景の色が網がけされ、より明るくなります。表示オブジェクトが 50% グレーよりも暗い場合、2 つの色が乗算されて、より暗くなります。この設定は、シャドウ効果によく使用されます。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:INVERT"><apiName>INVERT</apiName><shortdesc>
背景を反転します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invert</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
背景を反転します。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LAYER"><apiName>LAYER</apiName><shortdesc>
表示オブジェクトに関する透明度グループを強制的に作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>layer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトに関する透明度グループを強制的に作成します。つまり、表示オブジェクトが処理される前に、一時バッファー内で表示オブジェクトが事前に構成されます。ビットマップキャッシュを使って表示オブジェクトが事前キャッシュされる場合、または表示オブジェクトが、<codeph>blendMode</codeph> が <codeph>"normal"</codeph> 以外に設定された子オブジェクトを少なくとも 1 つ含む表示オブジェクトコンテナである場合には、この事前構成の処理が自動的に実行されます。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LIGHTEN"><apiName>LIGHTEN</apiName><shortdesc>
表示オブジェクトの要素カラーと背景色のうち明るい方（値が大きい方）の色を選択します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lighten</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの要素カラーと背景色のうち明るい方（値が大きい方）の色を選択します。この設定は、重ね合わせタイプによく使用されます。 

<p>例えば、表示オブジェクトのピクセルの RGB 値が 0xFFCC33 で、背景のピクセルの RGB 値が 0xDDF800 の場合、0xFF > 0xDD、0xCC &lt; 0xF8、および 0x33 > 0x00 = 33 であるので、表示されるピクセルの RGB 値は 0xFFF833 になります。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:MULTIPLY"><apiName>MULTIPLY</apiName><shortdesc>
表示オブジェクトの要素カラーの値と背景色の要素カラーの値を乗算した後、0xFF で割って正規化し、色を暗くします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>multiply</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの要素カラーの値と背景色の要素カラーの値を乗算した後、0xFF で割って正規化し、色を暗くします。この設定は、シャドウや深度効果によく使用されます。

<p>例えば、表示オブジェクトのピクセルの要素カラー（赤など）と背景のピクセルの対応するカラーの値が共に 0x88 の場合、乗算した結果は 0x4840 です。0xFF で除算すると、その要素カラーの値は 0x48 になります。これは、表示オブジェクトまたは背景の色よりも暗くなります。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
表示オブジェクトは、背景の前に表示されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトは、背景の前に表示されます。表示オブジェクトのピクセル値は、背景のピクセル値より優先されます。表示オブジェクトが透明な部分では、背景が表示されます。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:OVERLAY"><apiName>OVERLAY</apiName><shortdesc>
背景の暗さに基づいて、各ピクセルの色を調整します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>overlay</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
背景の暗さに基づいて、各ピクセルの色を調整します。背景が 50% グレーよりも明るい場合、表示オブジェクトと背景の色が網がけされ、より明るくなります。背景が 50% グレーよりも暗い場合、2 つの色が乗算されて、より暗くなります。この設定は、シャドウ効果によく使用されます。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SCREEN"><apiName>SCREEN</apiName><shortdesc>
表示オブジェクトの色の補数（逆）と背景色の補数を乗算して、ブリーチ効果を得ます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>screen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
表示オブジェクトの色の補数（逆）と背景色の補数を乗算して、ブリーチ効果を得ます。この設定は、ハイライトや、表示オブジェクトの黒い領域の削除によく使用されます。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SHADER"><apiName>SHADER</apiName><shortdesc>
シェーダーを使用して、オブジェクト間のブレンドを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>shader</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
シェーダーを使用して、オブジェクト間のブレンドを定義します。

<p>Shader インスタンスに <codeph>blendShader</codeph> プロパティを設定すると、表示オブジェクトの <codeph>blendMode</codeph> プロパティが <codeph>BlendMode.SHADER</codeph> に自動的に設定されます。<codeph>blendShader</codeph> プロパティを先に設定しないで <codeph>blendMode</codeph> プロパティを <codeph>BlendMode.SHADER</codeph> に設定すると、<codeph>blendMode</codeph> プロパティは <codeph>BlendMode.NORMAL</codeph> に設定されます。<codeph>blendMode</codeph> プロパティが <codeph>BlendMode.SHADER</codeph> に設定される <codeph>blendShader</codeph> プロパティを設定した後で <codeph>blendMode</codeph> プロパティの値を変更すると、ブレンドモードがリセットされ、<codeph>blendMode</codeph> プロパティを <codeph>BlendMode.SHADER</codeph> に設定するだけでブレンドシェーダーを使用できます。ブレンドモードの定義に使用したシェーダーを変更する場合を除いて、<codeph>blendShader</codeph> プロパティを再度設定する必要はありません。</p>

</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue><apiValue id="flash.display:BlendMode:SUBTRACT"><apiName>SUBTRACT</apiName><shortdesc>
結果の下限を 0 として、表示オブジェクトの要素カラーの値をその背景色の値から減算します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subtract</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
下限を 0 として、表示オブジェクトの要素カラーの値をその背景色の値から減算します。この設定は、2 つのオブジェクト間で色を暗くするディゾルブをアニメーションにするときによく使用されます。

<p>例えば、表示オブジェクトの 1 つのピクセルの RGB 値が 0xAA2233 で、背景のピクセルの RGB 値が 0xDDA600 の場合、0xDD - 0xAA = 0x33、0xA6 - 0x22 = 0x84、0x00 - 0x33 &lt; 0x00 であるので、表示されるピクセルの RGB 値は 0x338400 になります。</p>
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Graphics"><apiName>Graphics</apiName><shortdesc>
 Graphics クラスには、ベクターシェイプの作成に使用できる一連のメソッドがあります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Graphics クラスには、ベクターシェイプの作成に使用できる一連のメソッドがあります。描画をサポートする表示オブジェクトには、Sprite および Shape オブジェクトがあります。これらの各クラスには、Graphics オブジェクトである <codeph>graphics</codeph> プロパティがあります。以下は、簡単に使用できるように用意されているヘルパー関数の一例です。<codeph>drawRect()</codeph>、<codeph>drawRoundRect()</codeph>、<codeph>drawCircle()</codeph>、および <codeph>drawEllipse()</codeph>。
 
 <p>ActionScript コードから直接 Graphics オブジェクトを作成することはできません。<codeph>new Graphics()</codeph> を呼び出すと、例外がスローされます。</p>
 
 <p>Graphics クラスは final クラスであるため、サブクラス化することはできません。</p>
 
 
 </apiDesc><example conref="examples\GraphicsExample.as"> 次の例では、GraphicsExample クラスを使用して、円、角丸矩形、および四角形を描画します。これを行うには、以下の手順を実行します。
 <ol>
    <li>後で各シェイプのサイズを決定する際に使用する <codeph>size</codeph> プロパティを宣言します。</li>
     <li>背景色をオレンジ色、境界線色を濃い灰色、境界線のサイズを 0 ピクセル、角丸の半径を 9 ピクセル、ステージの端と他のオブジェクトの間のスペースを 5 ピクセルに、それぞれ設定するプロパティを宣言します。</li>
    <li>上記の手順で宣言したプロパティを Graphics クラスのビルトインメソッドと共に使用して、円、角丸矩形、および四角形を、座標 x = 0、y = 0 に描画します。</li>
    <li>ステージの一番上に配置された各シェイプを、x = 5、y = 5 から、シェイプ間のスペースを 5 ピクセルにして再描画します。</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Graphics:beginBitmapFill"><apiName>beginBitmapFill</apiName><shortdesc>
	 描画領域をビットマップイメージで塗りつぶします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>表示されるビットを含む透明または不透明ビットマップイメージです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスのマトリックスオブジェクトです。これを使用してビットマップ上に変形を定義できます。例えば、次のマトリックスを使用すると、ビットマップを 45 度（π/4 ラジアン）回転できます。
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc><codeph>true</codeph> の場合、ビットマップイメージが一定のパターンでタイル状に表示されます。<codeph>false</codeph> の場合、ビットマップイメージは繰り返されません。ビットマップからはみ出す塗り領域にはビットマップのエッジが使用されます。 
	 
	 <p>例えば、次のビットマップ（20 x 20 ピクセルのチェッカーボードのパターン）を考えます。</p>
	 
     <p><adobeimage alt="20 x 20 ピクセルの格子縞模様" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
	 
	 <p>次の例のように <codeph>repeat</codeph> が <codeph>true</codeph> に設定されている場合、ビットマップの塗りでビットマップが繰り返されます。</p>
	 
     <p><adobeimage alt="60 x 60 ピクセルの格子縞模様" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
	 
	 <p><codeph>repeat</codeph> が <codeph>false</codeph> に設定されている場合、エッジのピクセルがビットマップの外側の塗り領域に使用されます。</p>
	 
     <p><adobeimage alt="繰り返しのない 60 x 60 ピクセルイメージ" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 
   	 
	 </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><codeph>false</codeph> の場合、拡大ビットマップイメージは最近傍アルゴリズムを使用してレンダリングされ、ピクセル化されたように見えます。<codeph>true</codeph> の場合、拡大ビットマップイメージは双線形アルゴリズムを使用してレンダリングされます。最近傍アルゴリズムを使用したレンダリングの方が高速です。
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>ビットマップ塗りのシェイプを開始します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 描画領域をビットマップイメージで塗りつぶします。ビットマップを繰り返すか、タイリング表示して、領域を塗りつぶすことができます。<codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginShaderFill()</codeph> メソッドを呼び出すまで、塗りは有効です。<codeph>clear()</codeph> メソッドを呼び出すと、塗りがクリアされます。
	 
	 <p>アプリケーションでは、3 つ以上の点が描画されたとき、または <codeph>endFill()</codeph> メソッドが呼び出されたときに、塗りをレンダリングします。 </p>
	 
	 </apiDesc><example conref="examples\Graphics_beginBitmapFillExample.as"> 次の例では、イメージ（<codeph>image1.jpg</codeph>）を使用し、回転させながら繰り返して矩形を塗りつぶします。
 
 <ol>
    <li>イメージファイル（<codeph>image1.jpg</codeph>）は、<codeph>Loader</codeph> オブジェクトおよび <codeph>URLRequest</codeph> オブジェクトを使用してロードされます。ここでは、ファイルは SWF ファイルと同じディレクトリにあります。SWF ファイルは、「ローカルでの再生に関するセキュリティ」を「ローカルファイルにのみアクセスする」に設定してコンパイルする必要があります。</li>
     <li>イメージをロード（<codeph>イベント</codeph>が完了）すると、<codeph>drawImage()</codeph> メソッドが呼び出されます。イメージが適切にロードされなかった場合、<codeph>ioErrorHandler()</codeph> メソッドがトレースコメントを書き出します。</li>  
  <li><codeph>drawImage()</codeph> メソッドで、<codeph>BitmapData</codeph> オブジェクトがインスタンス化され、その幅と高さがイメージ（<codeph>image1.jpg</codeph>）に設定されます。その後、ソースイメージが BitmapData オブジェクトに描画されます。次に、矩形が <codeph>mySprite</codeph> Sprite オブジェクトに描画され、BitmapData オブジェクトを使用して塗りつぶされます。<codeph>Matrix</codeph> オブジェクトを使用して、<codeph>beginBitmapFill()</codeph> メソッドがイメージを 45 度回転し、イメージによる矩形の塗りつぶしを開始し、完全に塗りつぶします。</li> 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginFill"><apiName>beginFill</apiName><shortdesc>
 	 描画のときに他の Graphics メソッド（lineTo() や drawCircle() など）に対する今後の呼び出しに使用する単純な一色塗りを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>塗りのカラーです（0xRRGGBB）。
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>塗りのアルファ値です（0.0 ～ 1.0）。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>単色の塗りを指定します。
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 描画のときに他の Graphics メソッド（<codeph>lineTo()</codeph> や <codeph>drawCircle()</codeph> など）に対する今後の呼び出しに使用する単純な一色塗りを指定します。 <codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginShaderFill()</codeph> メソッドを呼び出すまで、塗りは有効です。<codeph>clear()</codeph> メソッドを呼び出すと、塗りがクリアされます。
	 
	 <p>アプリケーションでは、3 つ以上の点が描画されたとき、または <codeph>endFill()</codeph> メソッドが呼び出されたときに、塗りをレンダリングします。</p>
	 
	 </apiDesc><example>このメソッドの使用方法の詳細については、このクラスの末尾の<xref href="Graphics.html#includeExamplesSummary">例</xref>を参照してください。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginGradientFill"><apiName>beginGradientFill</apiName><shortdesc>
	 Graphics の他のメソッド（lineTo()、drawCircle() など）に対する、オブジェクトの後続の呼び出しに使用するグラデーション塗りを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>type</codeph> パラメーターが有効でない場合
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>使用するグラデーションのタイプを指定する GradientType クラスの値は、次のとおりです。<codeph>GradientType.LINEAR</codeph> または <codeph>GradientType.RADIAL</codeph>。 
	 
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>グラデーションで使用する RGB 16 進カラー値の配列（赤 0xFF0000、青 0x0000FF など）。最大 15 色まで指定できます。 各色について、alphas パラメーターと ratios パラメーターで対応する値を指定してください。
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>colors 配列内の各色に対応するアルファ値の配列。有効な値は 0 ～ 1 です。 0 未満の値を指定した場合、デフォルトで 0 が適用されます。1 より大きい値を指定した場合、デフォルトで 1 が適用されます。
     
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>色分布比率の配列です。0 ～ 255 の範囲の値を指定できます。この値は、100％でサンプリングされる色の幅の割合をパーセントで定義します。 値 0 はグラデーションボックスの左の位置を表し、255 はグラデーションボックスの右の位置を表します。 
	 
	 <p><b>注意：</b>この値は、グラデーションボックス内の位置を表すもので、最終グラデーションの座標空間を表すものではありません。最終グラデーションは、グラデーションボックスより広くなったり狭くなったりする場合があります。<codeph>colors</codeph> パラメーターの値ごとに、値を指定してください。 </p>
	 
	 <p>例えば、青と緑の 2 色を含む線状グラデーションの場合、次の例は、<codeph>ratios</codeph> 配列のさまざまな値に基づいて配置される色を示します。</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>グラデーション</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
	 	<entry><adobeimage alt="青から緑への線状グラデーション（比率 0 と 127）" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 0 と 255）" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 127 と 255）" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>配列内の値は、<codeph>[0, 63, 127, 190, 255]</codeph> のように順に増やしていく必要があります。 </p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスで定義される変換マトリックスです。flash.geom.Matrix クラスには、<codeph>createGradientBox()</codeph> メソッドがあります。このメソッドを使用すると、<codeph>beginGradientFill()</codeph> メソッドで使用できるマトリックスを容易に設定できます。
	 
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>使用する spread メソッドを指定する SpreadMethod クラスの値は、次のいずれかです。<codeph>SpreadMethod.PAD</codeph>、<codeph>SpreadMethod.REFLECT</codeph>、または <codeph>SpreadMethod.REPEAT</codeph>。 
	 
	 <p>例えば、2 つの色の間にシンプルな線状グラデーションがあるとします。</p>
	 
	 <codeblock>
	 import flash.geom.*
	 import flash.display.*
	 var fillType:String = GradientType.LINEAR;
	 var colors:Array = [0xFF0000, 0x0000FF];
	 var alphas:Array = [1, 1];
	 var ratios:Array = [0x00, 0xFF];
	 var matr:Matrix = new Matrix();
	 matr.createGradientBox(20, 20, 0, 0, 0);
	 var spreadMethod:String = SpreadMethod.PAD;
	 this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);		
	 this.graphics.drawRect(0,0,100,100);
	 </codeblock>
	 
	 	<p>この例では spread メソッドに <codeph>SpreadMethod.PAD</codeph> を使用しているため、グラデーションの塗りは次のようになります。</p>
	 
      <p><adobeimage alt="SpreadMethod.PAD での線状グラデーション" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
 	 
	 	<p>spread メソッドに <codeph>SpreadMethod.REFLECT</codeph> を使用する場合、グラデーションの塗りは次のようになります。</p>
 	 
      <p><adobeimage alt="SpreadMethod.REFLECT での線状グラデーション" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
 	 
	 	<p>spread メソッドに <codeph>SpreadMethod.REPEAT</codeph> を使用する場合、グラデーションの塗りは次のようになります。</p>
 	 
      <p><adobeimage alt="SpreadMethod.REPEAT での線状グラデーション" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>使用する値を指定する InterpolationMethod クラスの値は、<codeph>InterpolationMethod.LINEAR_RGB</codeph> または <codeph>InterpolationMethod.RGB</codeph> です。
	 
	 <p>例えば、2 つの色の間に、<codeph>spreadMethod</codeph> パラメーターが <codeph>SpreadMethod.REFLECT</codeph> に設定されたシンプルな線状グラデーションがあるとします。それぞれの補間方法で、外観に次のような影響があります。 </p>
	 
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="InterpolationMethod.LINEAR_RGB での線状グラデーション" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="InterpolationMethod.RGB での線状グラデーション" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>グラデーションの焦点の位置を制御する数値です。0 は焦点が中央にあること、1 は焦点がグラデーション円のいずれかの境界にあること、-1 は焦点がグラデーション円のもう一方の境界にあることを示します。-1 未満または 1 より大きい値は、-1 または 1 に丸められます。例えば、次の例では、<codeph>focalPointRatio</codeph> が 0.75 に設定されています。
	 
     <p><adobeimage alt="focalPointRatio が 0.75 に設定された放射状グラデーション" href="../../images/radial_sketch.jpg"/> </p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>グラデーションの塗りを指定します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 そのオブジェクトに対して以後実行する他の Graphics メソッド呼び出し（<codeph>lineTo()</codeph>、<codeph>drawCircle()</codeph> など）で使用するグラデーション塗りを指定します。<codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginShaderFill()</codeph> メソッドを呼び出すまで、塗りは有効です。<codeph>clear()</codeph> メソッドを呼び出すと、塗りがクリアされます。
	 
	 <p>アプリケーションでは、3 つ以上の点が描画されたとき、または <codeph>endFill()</codeph> メソッドが呼び出されたときに、塗りをレンダリングします。 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginShaderFill"><apiName>beginShaderFill</apiName><shortdesc>
 	 Graphics の他のメソッド（lineTo()、drawCircle() など）に対する、オブジェクトの後続の呼び出しに使用するシェーダー塗りを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>シェーダー出力タイプがこの操作に対応しない場合（シェーダーは <codeph>pixel3</codeph> または <codeph>pixel4</codeph> 出力を指定する必要があります）。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>シェーダーが指定したイメージ入力が存在しない場合。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>ByteArray または Vector の場合。&lt;Number> インスタンスが入力として使用され、ShaderInput の <codeph>width</codeph> および <codeph>height</codeph> プロパティが指定されていない、または指定された値が入力オブジェクトのデータ量と一致しない場合。詳しくは、<codeph>ShaderInput.input</codeph> プロパティを参照してください。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>塗りに使用するシェーダーです。この Shader インスタンスはイメージ入力の指定には必要ありません。ただし、シェーダーでイメージ入力が指定されている場合は、手動で入力を指定する必要があります。入力を指定するには、<codeph>Shader.data</codeph> プロパティについて、対応する ShaderInput プロパティの <codeph>input</codeph> プロパティを設定します。
	 
	 <p>Shader インスタンスを引数として渡すと、シェーダーが内部的にコピーされます。描画塗り操作は、元のシェーダーを参照するのではなく、その内部コピーを使用します。パラメーター値、入力、バイトコードの変更などの変更をシェーダーに加えたとしても、塗りつぶしに使用したコピーシェーダーにはその変更は適用されません。</p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスのマトリックスオブジェクトです。これを使用してシェーダー上に変形を定義できます。例えば、次のマトリックスを使用すると、シェーダーを 45 度（π/4 ラジアン）回転できます。
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 <p>シェーダーで受け取る座標は、<codeph>matrix</codeph> パラメーターに対して指定したマトリックスに基づきます。デフォルト（<codeph>null</codeph>）のマトリックスの場合、シェーダーの座標は入力のサンプリングが可能なローカルピクセル座標になります。</p>
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>シェーダー塗りを指定します。
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 そのオブジェクトに対して以後実行する他の Graphics メソッド呼び出し（<codeph>lineTo()</codeph>、<codeph>drawCircle()</codeph> など）で使用するシェーダー塗りを指定します。<codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginShaderFill()</codeph> メソッドを呼び出すまで、塗りは有効です。<codeph>clear()</codeph> メソッドを呼び出すと、塗りがクリアされます。
	 
	 <p>アプリケーションでは、3 つ以上の点が描画されたとき、または <codeph>endFill()</codeph> メソッドが呼び出されたときに、塗りをレンダリングします。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:clear"><apiName>clear</apiName><shortdesc>
     この Graphics オブジェクトに描画されているグラフィックをクリアし、塗りと線のスタイルの設定をリセットします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     この Graphics オブジェクトに描画されているグラフィックをクリアし、塗りと線のスタイルの設定をリセットします。
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:copyFrom"><apiName>copyFrom</apiName><shortdesc>
	 すべての描画コマンドをソース Graphics オブジェクトから、呼び出し Graphics オブジェクトにコピーします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceGraphics</apiItemName><apiOperationClassifier>flash.display:Graphics</apiOperationClassifier><apiDesc>描画コマンドのコピー元の Graphics オブジェクトです。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 すべての描画コマンドをソース Graphics オブジェクトから、呼び出し Graphics オブジェクトにコピーします。
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:curveTo"><apiName>curveTo</apiName><shortdesc>
	 (controlX, controlY) で指定されたコントロールポイントを使用し、現在の描画位置から (anchorX, anchorY) まで、現在の線のスタイルで曲線を描画します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的なコントロールポイントの水平座標を指定する数値。  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的なコントロールポイントの垂直座標を指定する数値。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な次のアンカーポイントの水平座標を指定する数値。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な次のアンカーポイントの垂直座標を指定する数値。  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>(controlX, controlY) で指定されたコントロールポイントを使用し、現在の描画位置から (anchorX, anchorY) まで曲線を描画します。
     
	 
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 (<codeph>controlX</codeph>, <codeph>controlY</codeph>) で指定されたコントロールポイントを使用し、現在の描画位置から (anchorX, anchorY) まで、現在の線のスタイルで曲線を描画します。その後、現在の描画位置は (<codeph>anchorX</codeph>, <codeph>anchorY</codeph>) に設定されます。描画先のムービークリップに Flash の描画ツールで作成したコンテンツが含まれている場合は、<codeph>curveTo()</codeph> メソッドへの呼び出しの結果はこのコンテンツの下に描画されます。<codeph>curveTo()</codeph> メソッドを呼び出してから <codeph>moveTo()</codeph> メソッドを呼び出すと、現在の描画位置はデフォルトで (0,0) になります。いずれかのパラメーターを省略すると、このメソッドは失敗し、現在の描画位置は変更されません。
	 
	 <p>描画される曲線は、二次ベジェ曲線です。二次ベジェ曲線は、2 つのアンカーポイントと 1 つのコントロールポイントで構成されています。曲線は、2 つのアンカーポイントを補間し、コントロールポイントに向かいます。 </p>
	 
	 <p><adobeimage alt="二次ベジェおよび三次ベジェ" href="../../images/quad_bezier.jpg"/></p>
	 
  	 </apiDesc><example conref="examples\Graphics_curveToExample1.as"> 次の例では、幅と高さが 100 ピクセル、Sprite 表示オブジェクトの基準点 (0, 0) から右に 250 ピクセルの緑の丸いオブジェクトを描画します。 
 <p>4 本の曲線を描いて円を作成し、緑で塗りつぶします。</p>
   
 <p>二次ベジェ方程式の性質上、これは完全な円ではありません。円を描画する最善の方法は、Graphics クラスの <codeph>drawCircle()</codeph> メソッドを使用することです。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</codeblock></example><example conref="examples\Graphics_curveToExample2.as"> 次の例では、<codeph>curveTo()</codeph> メソッドを使用して新月を描画します。
 
 <p>1 ピクセルの 2 本の曲線を描画し、その曲線の間のスペースを白で塗りつぶします。<codeph>moveTo()</codeph> メソッドを使用して、現在の描画位置を座標 (100, 100) に配置します。最初の曲線の描画位置がターゲットポイント (100, 200) に移動します。2 番目の曲線の描画位置がターゲットポイントである開始位置 (100, 100) に戻ります。水平方向のコントロールポイントで、異なる曲線サイズが指定されています。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:drawCircle"><apiName>drawCircle</apiName><shortdesc>
	 円を描画します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの円の中心の相対 <i>x</i> 座標（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの円の中心の相対 <i>y</i> 座標（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>radius</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>円の半径（ピクセル単位）。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>円を描画します。
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 円を描画します。<codeph>drawCircle()</codeph> メソッドを呼び出す前に、線のスタイルまたは塗り、あるいはその両方を設定します。そのためには、<codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginBitmapFill()</codeph> メソッドを呼び出します。
	 
	 </apiDesc><example>このメソッドの使用方法の詳細については、このクラスの末尾の<xref href="Graphics.html#includeExamplesSummary">例</xref>を参照してください。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawEllipse()"><linktext>drawEllipse()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawEllipse"><apiName>drawEllipse</apiName><shortdesc>
	 楕円を描画します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの楕円の境界ボックスの左上の相対 <i>x</i> 座標（ピクセル単位）です。
	
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点に対して相対的な、楕円の境界ボックスの左上の <i>y</i> 座標（ピクセル単位）です。
	
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>楕円の幅（ピクセル単位）。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>楕円の高さ（ピクセル単位）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>楕円を描画します。
         
         </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 楕円を描画します。<codeph>drawEllipse()</codeph> メソッドを呼び出す前に、線のスタイルまたは塗り、あるいはその両方を設定します。そのためには、<codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginBitmapFill()</codeph> メソッドを呼び出します。
	 
	 </apiDesc><example conref="examples\Graphics_drawEllipseExample.as"> 次の例では、<codeph>drawEgg()</codeph> 関数を使用し、<codeph>eggSize</codeph> パラメーターに応じて 3 つの異なるサイズの卵（3 種類のサイズの楕円）を描画します。  
 <ol>
 <li>コンストラクターが <codeph>drawEgg()</codeph> 関数を呼び出し、卵を描画する領域に対する水平方向および垂直方向のパラメーターと卵の種類（<codeph>eggSize</codeph>）を渡します。卵（楕円）の高さと幅は、描画する領域を決定するために使用できます。</li> 
 <li><codeph>drawEgg()</codeph> 関数が、それぞれのサイズの楕円を描画し、<codeph>beginFill()</codeph> メソッドを使用して白く塗りつぶします。この関数に対して事前に記述されたエラー処理はありません。</li>
 </ol>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawCircle()"><linktext>drawCircle()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawGraphicsData"><apiName>drawGraphicsData</apiName><shortdesc>
	 描画用の一連の IGraphicsData インスタンスを送信します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>graphicsData</apiItemName><apiType value="Vector$flash.display:IGraphicsData"/><apiDesc>グラフィックオブジェクトを含む Vector です。IGraphicsData インターフェイスを実装します。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 描画用の一連の IGraphicsData インスタンスを送信します。このメソッドでは、IGraphicsData インターフェイスを実装する、パス、塗り、線などのオブジェクトを含む Vector を使用できます。IGraphicsData インスタンスの Vector は、図形の一部を表す場合と、図形全体を描画するための複雑な定義済みデータセットを表す場合があります。
     
     
     <p>
     グラフィックパスには別のグラフィックパスを含めることができます。 この操作では、<codeph>graphicsData</codeph> Vector にパスが含まれる場合、そのパスとサブパスがすべてレンダリングされます。
     </p>
     
     </apiDesc><example conref="examples\Graphics_DrawGraphicsDataExample.as"> 以下の例では、GraphicsGradientFill オブジェクトを作成して、四角形の塗りプロパティを設定します。次に、GraphicsStroke オブジェクト（線の太さ用）クラスと GraphicsSolidFill オブジェクト（線のカラー用）を作成して、四角形の境界線のプロパティを設定します。その後、GraphicsPath オブジェクトを作成して、図形描画用の値を含めます。これらのオブジェクトはすべて 1 つの IGraphicsData オブジェクトに格納され、図形をレンダリングする <codeph>drawGraphicsData</codeph> コマンドに渡されます。
<codeblock>
package{
    import flash.display.*;
    import flash.geom.*;
    
    public class DrawGraphicsDataExample extends Sprite {

    public function DrawGraphicsDataExample(){    

    // establish the fill properties
    var myFill:GraphicsGradientFill = new GraphicsGradientFill();
    myFill.colors = [0xEEFFEE, 0x0000FF];
    myFill.matrix = new Matrix();
    myFill.matrix.createGradientBox(100, 100, 0);
 
    // establish the stroke properties
    var myStroke:GraphicsStroke = new GraphicsStroke(2);
    myStroke.fill = new GraphicsSolidFill(0x000000);
 
    // establish the path properties
    var myPath:GraphicsPath = new GraphicsPath(new Vector.&lt;int>(), new Vector.&lt;Number>());
    myPath.commands.push(1,2,2,2,2);
    myPath.data.push(10,10, 10,100, 100,100, 100,10, 10,10);
 
    // populate the IGraphicsData Vector array
    var myDrawing:Vector.&lt;IGraphicsData> = new Vector.&lt;IGraphicsData>();
    myDrawing.push(myFill, myStroke, myPath);
 
    // render the drawing 
    graphics.drawGraphicsData(myDrawing);
    }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#IGraphicsData"><linktext>flash.display.IGraphicsData</linktext></link><link href="flash.display.xml#GraphicsBitmapFill"><linktext>flash.display.GraphicsBitmapFill</linktext></link><link href="flash.display.xml#GraphicsEndFill"><linktext>flash.display.GraphicsEndFill</linktext></link><link href="flash.display.xml#GraphicsGradientFill"><linktext>flash.display.GraphicsGradientFill</linktext></link><link href="flash.display.xml#GraphicsPath"><linktext>flash.display.GraphicsPath</linktext></link><link href="flash.display.xml#GraphicsShaderFill"><linktext>flash.display.GraphicsShaderFill</linktext></link><link href="flash.display.xml#GraphicsSolidFill"><linktext>flash.display.GraphicsSolidFill</linktext></link><link href="flash.display.xml#GraphicsStroke"><linktext>flash.display.GraphicsStroke</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawPath"><apiName>drawPath</apiName><shortdesc>
	 描画用の一連のコマンドを送信します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiDesc>GraphicsPathCommand クラスで定義されているコマンドを表す整数の Vector です。GraphicsPathCommand クラスは、コマンドをこのベクター配列の数値識別子にマッピングします。
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiDesc>Number の Vector で、数値の各ペアは座標位置（x と y のペア）として扱われます。x 座標と y 座標の値のペアは Point オブジェクトではありません。<codeph>data</codeph> ベクターは一連の数値であり、2 つの数値からなる各グループは 1 つの座標位置を表します。 
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>GraphicsPathWinding クラスで定義されている値を使用して、湾曲規則を指定します。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 描画用の一連のコマンドを送信します。 <codeph>drawPath()</codeph> メソッドでは、ベクター配列を使用して、個別の <codeph>moveTo()</codeph>、<codeph>lineTo()</codeph>、および <codeph>curveTo()</codeph> 描画コマンドを 1 回の呼び出しに統合できます。<codeph>drawPath()</codeph> メソッドのパラメーターは、描画コマンドと、x 座標と y 座標の値のペアおよび描画方向の組み合わせです。描画コマンドは、GraphicsPathCommand クラスの値です。x 座標と y 座標の値のペアは配列の Number であり、各ペアによって座標位置が定義されます。描画方向は、GraphicsPathWinding クラスの値です。
     
	 <p>
	 一般に、描画では、<codeph>drawPath()</codeph> を使用する方が、一連の個別の <codeph>lineTo()</codeph> メソッドと <codeph>curveTo()</codeph> メソッドを使用するよりもレンダリングが高速です。 
	 </p>
     
	 <p>
     <codeph>drawPath()</codeph> メソッドでは、浮動小数点の計算を使用するため、シェイプの回転と拡大 / 縮小がより正確で、よりよい結果が得られます。ただし、<codeph>drawPath()</codeph> メソッドを使用して送信された曲線は、<codeph>lineTo()</codeph> メソッドおよび <codeph>curveTo()</codeph> メソッドと組み合わせて使用された場合、小さなサブピクセルの配置誤差が発生することがあります。
     </p>
     
	 <p>
	 <codeph>drawPath()</codeph> メソッドは、線の塗りおよび描画に少し異なる規則も使用します。異なる規則を以下に示します。
     </p>
     
	 <ul>
     <li>塗りがパスをレンダリングするのに適用される場合：
	  <ul>
          <li>3 ポイント未満のサブパスはレンダリングされません（ただし、線のレンダリングは発生し、線に対する規則は以下と同じになります）。</li>
	      <li>閉じていないサブパス（始まりと終わりの端点が同じでない）は、暗黙的に閉じられます。</li>
	   </ul>
     </li>
     <li>線がパスをレンダリングするのに適用される場合：
       <ul>
	     <li>サブパスは、任意の数のポイントで構成できます。</li>
	     <li>サブパスが暗黙的に閉じられることはありません。</li>
        </ul>
     </li>
     </ul>
     
     </apiDesc><example conref="examples\Graphics_DrawPathExample.as"> 次の例では、2 つの Vector オブジェクトを作成し、これを <codeph>drawPath()</codeph> メソッドに渡して青い星をレンダリングします。1 つ目の Vector である <codeph>star_commands</codeph> には、flash.display.GraphicsPathCommand クラスの描画コマンドを表す一連の整数が格納されています。ここで、値 1 は <codeph>MoveTo()</codeph> コマンドであり、値 2 は <codeph>LineTo()</codeph> コマンドです。2 つ目の Vector である <codeph>star_coord</codeph> には、x 座標と y 座標のペアが 5 組格納されています。<codeph>drawPath()</codeph> メソッドは、これらのコマンドを位置と対応させて、星を描画します。
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {

    public function DrawPathExample(){

    var star_commands:Vector.&lt;int> = new Vector.&lt;int>(5, true);
    
    star_commands[0] = 1;
    star_commands[1] = 2;
    star_commands[2] = 2;
    star_commands[3] = 2;
    star_commands[4] = 2;

    var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>(10, true);
    star_coord[0] = 66; //x
    star_coord[1] = 10; //y 
    star_coord[2] = 23; 
    star_coord[3] = 127; 
    star_coord[4] = 122; 
    star_coord[5] = 50; 
    star_coord[6] = 10; 
    star_coord[7] = 49; 
    star_coord[8] = 109; 
    star_coord[9] = 127;


    graphics.beginFill(0x003366);
    graphics.drawPath(star_commands, star_coord);

    }

    }
}

</codeblock></example><example conref="examples\Graphics_DrawPathExample2.as"> 上記の例では、座標のペアとコマンドをそれぞれ個別に割り当てて配列に位置を表示していますが、単一のステートメントで割り当てることもできます。以下の例では、単一の <codeph>push()</codeph> ステートメント内で各配列に値を割り当てることにより、同じ星を描画しています。
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {
    public function DrawPathExample(){
        var star_commands:Vector.&lt;int> = new Vector.&lt;int>();
        star_commands.push(1, 2, 2, 2, 2);

           var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>();
           star_coord.push(66,10, 23,127, 122,50, 10,49, 109,127);

        graphics.beginFill(0x003366);
        graphics.drawPath(star_commands, star_coord);
    }
    }
}


</codeblock> <b>注意：</b>デフォルトでは、<codeph>drawPath()</codeph> メソッドは奇数 / 偶数の湾曲タイプを使用します。このため、星の中心は塗りつぶされません。次のように、3 つ目のパラメーターにゼロ以外の湾曲タイプを指定すると、星の中心が塗りつぶされます。
 <codeblock>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </codeblock>
 
</example></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRect"><apiName>drawRect</apiName><shortdesc>
	 矩形を描画します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>width</codeph> または <codeph>height</codeph> パラメーターが数値（<codeph>Number.NaN</codeph>）でない場合
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な水平座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な垂直座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>矩形の幅（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>矩形の高さ（ピクセル単位）。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>角丸矩形を描画します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 矩形を描画します。<codeph>drawRect()</codeph> メソッドを呼び出す前に、線のスタイルまたは塗り、あるいはその両方を設定します。そのためには、<codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginBitmapFill()</codeph> メソッドを呼び出します。
	 
	 </apiDesc><example>このメソッドの使用方法の詳細については、このクラスの末尾の<xref href="Graphics.html#includeExamplesSummary">例</xref>を参照してください。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRoundRect()"><linktext>drawRoundRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRoundRect"><apiName>drawRoundRect</apiName><shortdesc>
	 角丸矩形を描画します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>width</codeph>、<codeph>height</codeph>、<codeph>ellipseWidth</codeph>、または <codeph>ellipseHeight</codeph> パラメーターが数値（<codeph>Number.NaN</codeph>）でない場合
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な水平座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な垂直座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>角丸矩形の幅（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>角丸矩形の高さ（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>丸角の描画に使用される楕円の幅（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>丸角の描画に使用される楕円の高さ（ピクセル単位）。（オプション）値を指定しない場合は、<codeph>ellipseWidth</codeph> パラメーターに指定された値がデフォルトで適用されます。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>角丸矩形を描画します。
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 角丸矩形を描画します。<codeph>drawRoundRect()</codeph> メソッドを呼び出す前に、線のスタイルまたは塗り、あるいはその両方を設定します。そのためには、<codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginBitmapFill()</codeph> メソッドを呼び出します。
	 
	 </apiDesc><example>このメソッドの使用方法の詳細については、このクラスの末尾の<xref href="Graphics.html#includeExamplesSummary">例</xref>を参照してください。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRect()"><linktext>drawRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawTriangles"><apiName>drawTriangles</apiName><shortdesc>
	 一連の三角形をレンダリングします。通常は、ビットマップを歪曲させて、3 次元の外観にします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiDesc>Number の Vector で、数値の各ペアは座標位置（x と y のペア）として扱われます。<codeph>vertices</codeph> パラメーターを指定する必要があります。
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>整数またはインデックスの Vector です。3 つのインデックスごとに三角形が定義されます。<codeph>indexes</codeph> パラメーターが null の場合、3 つの頂点（<codeph>vertices</codeph> Vector 内の 6 つの x、y ペア）ごとに三角形が定義されます。null でない場合、各インデックスは頂点（<codeph>vertices</codeph> Vector 内の数値のペア）を参照します。例えば、<codeph>indexes[1]</codeph> は（<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>）を参照します。<codeph>indexes</codeph> パラメーターはオプションですが、インデックスを使用すると、通常、送信されるデータ量と計算されるデータ量が減少します。 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>テクスチャマッピングを適用するために使用される正規化座標の Vector です。各座標は、塗りに使用されるビットマップ上のポイントを参照します。頂点ごとに 1 つの UV 座標または 1 つの UVT 座標が必要です。UV 座標では、（0,0）はビットマップの左上隅で、（1,1）はビットマップの右下隅です。 
     <p>このベクターの長さが <codeph>vertices</codeph> ベクターの 2 倍である場合、外見上の修正を行うことなく、正規化座標が使用されます。 </p>
     <p>このベクターの長さが <codeph>vertices</codeph> ベクターの 3 倍である場合、3 番目の座標は、「t」（視点空間における視点からテクスチャまでの距離）として解釈されます。これにより、3D でテクスチャをマッピングする場合に、レンダリングエンジンが外観を正しく適用できるようになります。</p>
     <p><codeph>uvtData</codeph> パラメーターが null の場合、通常の塗り規則（およびいずれかの塗りタイプ）が適用されます。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>特定の方向に面する三角形をレンダリングするかどうかを指定します。このパラメーターは、現在のビューで見えない三角形のレンダリングを避けるのに使用します。このパラメーターは、TriangleCulling クラスで定義された任意の値に設定できます。 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 一連の三角形をレンダリングします。通常は、ビットマップを歪曲させて、3 次元の外観にします。<codeph>drawTriangles()</codeph> メソッドは、(u,v) 座標を使用して現在の塗りまたはビットマップ塗りを三角形の各面にマッピングします。 
     <p>
     どのタイプの塗りでも使用できます。ただし、その塗りに変換マトリックスがある場合でも、その変換マトリックスは無視されます。
     </p>
     
     <p>
     ビットマップ塗りを使用する場合、<codeph>uvtData</codeph> パラメーターを使用すると、テクスチャマッピングを改善できます。 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:endFill"><apiName>endFill</apiName><shortdesc>
	 beginFill()、beginGradientFill()、または beginBitmapFill() メソッドへの最後の呼び出し以降に追加された線と曲線に塗りを適用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a square with red fill on the Stage:
	 
	 <listing>
	 this.createEmptyMovieClip("square_mc", this.getNextHighestDepth());
	 square_mc.beginFill(0xFF0000);
	 square_mc.moveTo(10, 10);
	 square_mc.lineTo(100, 10);
	 square_mc.lineTo(100, 100);
	 square_mc.lineTo(10, 100);
	 square_mc.lineTo(10, 10);
	 square_mc.endFill();
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>線と曲線に塗りを適用します。
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 <codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginBitmapFill()</codeph> メソッドへの最後の呼び出し以降に追加された線と曲線に塗りを適用します。適用される塗りは、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph>、または <codeph>beginBitmapFill()</codeph> メソッドの前回の呼び出しで指定されたものです。現在の描画位置が <codeph>moveTo()</codeph> メソッドの直前の呼び出しで指定された座標と等しくない場合、塗りが定義されていれば、パスが線で閉じられた後、塗りが適用されます。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineBitmapStyle"><apiName>lineBitmapStyle</apiName><shortdesc>
	 線の描画で、線として使用するビットマップを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>線を描画するときに使用するビットマップです。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスで定義されるオプションの変換マトリックスです。マトリックスを使用して拡大 / 縮小できます。または、線スタイルに適用する前にビットマップを操作します。
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>ビットマップをタイル状に繰り返すかどうか。
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ビットマップにスムージングを適用するかどうか。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 線の描画で、線として使用するビットマップを指定します。 
     
     <p>ビットマップ線スタイルは、<codeph>lineTo()</codeph> メソッドや <codeph>drawCircle()</codeph> メソッドなど、Graphics のメソッドの後続の呼び出しに使用されます。線のスタイルは、<codeph>lineStyle()</codeph> メソッド、<codeph>lineGradientStyle()</codeph> メソッド、または <codeph>lineBitmapStyle()</codeph> メソッドを再度異なるパラメーターで呼び出すまで有効です。 </p>
     
     <p>パスの描画中に <codeph>lineBitmapStyle()</codeph> メソッドを呼び出し、パス内の線のセグメントごとに異なるスタイルを指定できます。 </p>
     
     <p>線を有効にするには、先に <codeph>lineStyle()</codeph> メソッドを呼び出してから <codeph>lineBitmapStyle()</codeph> メソッドを呼び出します。そうでないと、線スタイルの値は <codeph>undefined</codeph> になります。</p>
     
     <p><codeph>clear()</codeph> メソッドを呼び出すと、線スタイルの設定が <codeph>undefined</codeph> に戻ります。
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineGradientStyle"><apiName>lineGradientStyle</apiName><shortdesc>
	 線の描画で使用するグラデーションを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>使用するグラデーションのタイプを指定する GradientType クラスの値は、GradientType.LINEAR または GradientType.RADIAL のいずれかです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>グラデーションで使用する RGB 16 進カラー値の配列（赤 0xFF0000、青 0x0000FF など）。
	 
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>colors 配列内の各色に対応するアルファ値の配列。有効な値は 0 ～ 1 です。0 未満の値の場合は、デフォルトで 0 が適用されます。1 より大きい値の場合は、デフォルトで 1 が適用されます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>色分布比率の配列です。0 ～ 255 の範囲の値を指定できます。この値は、100% でサンプリングされる色の幅の割合をパーセントで定義します。値 0 はグラデーションボックスの左の位置を表し、255 はグラデーションボックスの右の位置を表します。この値は、グラデーションボックス内の位置を表すもので、最終グラデーションの座標空間を表すものではありません。最終グラデーションは、グラデーションボックスより広くなったり狭くなったりする場合があります。<codeph>colors</codeph> パラメーターの値ごとに、値を指定してください。 
	 
	 <p>例えば、青と緑の 2 色を含む線状グラデーションの場合、次の図は、<codeph>ratios</codeph> 配列のさまざまな値に基づいて配置される色を示します。</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>グラデーション</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 0 と 127）" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 0 と 255）" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="青から緑への線状グラデーション（比率 127 と 255）" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>配列内の値は、<codeph>[0, 63, 127, 190, 255]</codeph> のように順に増やしていく必要があります。 </p>
   	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスで定義される変換マトリックスです。flash.geom.Matrix クラスには、<codeph>createGradientBox()</codeph> メソッドがあります。このメソッドを使用すると、<codeph>lineGradientStyle()</codeph> メソッドで使用できるマトリックスを容易に設定できます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>使用する spread メソッドを指定する SpreadMethod クラスの値は、次のとおりです。 
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="3"><tbody><row><entry align="center"><adobeimage alt="SpreadMethod.PAD での線状グラデーション" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>
      <entry align="center"><adobeimage alt="SpreadMethod.REFLECT での線状グラデーション" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>
      <entry align="center"><adobeimage alt="SpreadMethod.REPEAT での線状グラデーション" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>使用する値を指定する InterpolationMethod クラスの値です。例えば、2 つの色の間に、<codeph>spreadMethod</codeph> パラメーターが <codeph>SpreadMethod.REFLECT</codeph> に設定されたシンプルな線状グラデーションがあるとします。それぞれの補間方法で、外観に次のような影響があります。
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="InterpolationMethod.LINEAR_RGB での線状グラデーション" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="InterpolationMethod.RGB での線状グラデーション" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>グラデーションの焦点の位置を制御する数値です。0 は焦点が中央にあること、1 は焦点がグラデーション円のいずれかの境界にあること、-1 は焦点がグラデーション円のもう一方の境界にあることを示します。-1 未満の値は -1 に、1 より大きい値は 1 に丸められます。次のイメージは、<codeph>focalPointRatio</codeph> を -0.75 に設定したグラデーションを示しています。
   	 
     <p><adobeimage alt="focalPointRatio が 0.75 に設定された放射状グラデーション" href="../../images/radial_sketch.jpg"/> </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 線の描画で使用するグラデーションを指定します。
     
     <p><codeph>lineTo()</codeph> メソッドや <codeph>drawCircle()</codeph> メソッドなど、Graphics のメソッドの後続の呼び出しにはグラデーション線スタイルが使用されます。線のスタイルは、<codeph>lineStyle()</codeph> メソッド、<codeph>lineBitmapStyle()</codeph> メソッド、または <codeph>lineGradientStyle()</codeph> メソッドを再度別のパラメーターで呼び出すまで有効のままです。 </p>
     
     <p>パスの描画中に <codeph>lineGradientStyle()</codeph> メソッドを呼び出し、パス内の線のセグメントごとに異なるスタイルを指定できます。 </p>
     
     <p>線を有効にするには、先に <codeph>lineStyle()</codeph> メソッドを呼び出してから <codeph>lineGradientStyle()</codeph> メソッドを呼び出します。そうでないと、線スタイルの値は <codeph>undefined</codeph> になります。</p>
     
     <p><codeph>clear()</codeph> メソッドを呼び出すと、線スタイルの設定が <codeph>undefined</codeph> に戻ります。
     </p>
	 
	 </apiDesc><example conref="examples\Graphics_lineGradientStyleExample.as"> 次の例では、赤から緑、青へのグラデーションの境界線を使用する矩形と円を描画します。
 
 <p><codeph>Matrix</codeph> クラスの <codeph>createGradientBox()</codeph> メソッドを使用して、グラデーションボックスが幅 200、高さ 40 に定義されます。線の太さは 5 ピクセルに設定されます。境界線の太さを、<codeph>lineGradientStyle()</codeph> メソッドに対して定義する必要があります。グラデーションは線状に設定されます。グラデーションの色は赤、緑、および青に設定されます。色の透明度（アルファ値）は 1（不透明）に設定されます。グラデーションの分布は均等です。つまり、値 0（グラデーションボックスの左の位置）、128（ボックスの中央の位置）、255（ボックスの右の位置）の各位置で 100% で色がサンプリングされます。矩形の幅はグラデーションのすべての領域を包含します。一方、円は領域の中央から 50% を包含します。</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineShaderStyle"><apiName>lineShaderStyle</apiName><shortdesc>
	 線の描画で、線として使用するビットマップを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>線を描画するときに使用するビットマップです。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスで定義されるオプションの変換マトリックスです。マトリックスを使用して拡大 / 縮小できます。または、線スタイルに適用する前にビットマップを操作します。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 線の描画で、線として使用するビットマップを指定します。 
     
     <p>ビットマップ線スタイルは、<codeph>lineTo()</codeph> メソッドや <codeph>drawCircle()</codeph> メソッドなど、Graphics のメソッドの後続の呼び出しに使用されます。線のスタイルは、<codeph>lineStyle()</codeph> メソッド、<codeph>lineGradientStyle()</codeph> メソッド、または <codeph>lineBitmapStyle()</codeph> メソッドを再度異なるパラメーターで呼び出すまで有効です。 </p>
     
     <p>パスの描画中に <codeph>lineShaderStyle()</codeph> メソッドを呼び出し、パス内の線のセグメントごとに異なるスタイルを指定できます。 </p>
     
     <p>線を有効にするには、先に <codeph>lineStyle()</codeph> メソッドを呼び出してから <codeph>lineShaderStyle()</codeph> メソッドを呼び出します。そうでないと、線スタイルの値は <codeph>undefined</codeph> になります。</p>
     
     <p><codeph>clear()</codeph> メソッドを呼び出すと、線スタイルの設定が <codeph>undefined</codeph> に戻ります。
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineStyle"><apiName>lineStyle</apiName><shortdesc>
     lineTo() メソッドや drawCircle() メソッドなど、Graphics のメソッドの後続の呼び出しに使用する線スタイルを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following code draws a triangle with a 5-pixel, solid magenta line with 
	 no fill, with pixel hinting, no stroke scaling, no caps, and miter joints with 
	 <code>miterLimit</code> set to 1:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", this.getNextHighestDepth());
	 triangle_mc.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 </listing>
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>線の太さをポイント単位で示す整数。有効な値は 0 ～ 255 です。パラメーターが undefined である場合は、線は描画されません。0 未満の値を指定した場合は、デフォルトで 0 が適用されます。0 は極細線です。最大の太さは 255 です。255 を超える値を指定した場合は、デフォルトで 255 が適用されます。 
     
     </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>線の色を表す 16 進値。例えば、赤は 0xFF0000、青は 0x0000FF で表します。値を指定しない場合は、デフォルトで 0x000000（黒）が適用されます。オプション。
	 
 	 
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>線の色のアルファ値を示す数値。有効な値は 0 ～ 1 です。値を指定しない場合は、デフォルトで 1（ソリッド）が適用されます。0 未満の値を指定した場合、デフォルトで 0 が適用されます。1 より大きい値を指定した場合、デフォルトで 1 が適用されます。 
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ピクセル全体に対して線をヒンティングするかどうかを指定するブール値。この値は、曲線のアンカーの位置と線のサイズ自身の両方に影響を与えます。<codeph>pixelHinting</codeph> を <codeph>true</codeph> に設定すると、線幅が全ピクセル幅に調整されます。 <codeph>pixelHinting</codeph> を <codeph>false</codeph> に設定すると、曲線と直線で非連続が発生することがあります。例えば、次の図は、Flash Player または Adobe AIR で、<codeph>pixelHinting</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドで使用）の設定が異なるだけで他はまったく同じ 2 つの角丸矩形がどのようにレンダリングされるかを示したものです（違いが分かるようにイメージは 200% に拡大されています）。
	 
	 <p><adobeimage alt="pixelHinting false および pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
	 
	 <p>値を指定しない場合、線でピクセルのヒンティングが使用されません。</p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>使用する拡大・縮小モードを指定する LineScaleMode クラスの値です。
	 
	 <ul>
	 
	 <li>
	 <codeph>LineScaleMode.NORMAL</codeph> — オブジェクトが拡大 / 縮小される場合、常に線の太さが拡大 / 縮小されます（デフォルト）。
	 </li>
	 
	 <li>
	 <codeph>LineScaleMode.NONE</codeph> — 線の太さを拡大 / 縮小しません。
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.VERTICAL</codeph> — オブジェクトを垂直方向に<i>のみ</i>拡大 / 縮小する場合は、線の太さを拡大 / 縮小しません。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.VERTICAL</codeph> に設定されているとします。左側の円は垂直方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
	 
     <p><adobeimage alt="1 つの円は垂直方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	 
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.HORIZONTAL</codeph> — オブジェクトを水平方向に<i>のみ</i>拡大 / 縮小する場合は、線の太さを拡大 / 縮小しません。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.HORIZONTAL</codeph> に設定されているとします。左側の円は水平方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
	 
     <p><adobeimage alt="1 つの円は水平方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	 
	 </li>
	 
	 
	 </ul>
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>線の終端のキャップの種類を指定する CapsStyle クラスの値です。有効な値は次のとおりです。<codeph>CapsStyle.NONE</codeph>、<codeph>CapsStyle.ROUND</codeph>、および <codeph>CapsStyle.SQUARE</codeph>。この値を指定しない場合は、丸いキャップが使用されます。 
	 <p>例えば、次の図は <codeph>capsStyle</codeph> のさまざまな設定を示します。それぞれの設定で、図の青い線は太さ 30 で、<codeph>capsStyle</codeph> が適用されています。重ね合わせた黒い線は太さ 1 で、<codeph>capsStyle</codeph> は適用されていません。
	 </p>
	 <p><adobeimage alt="NONE、ROUND、および SQUARE" href="../../images/linecap.jpg"/></p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>角で使用する接合点の外観の種類を指定する JointStyle クラスの値です。有効な値は次のとおりです。<codeph>JointStyle.BEVEL</codeph>、<codeph>JointStyle.MITER</codeph>、および <codeph>JointStyle.ROUND</codeph>。この値を指定しないと、角丸（"round"）の接合点が使用されます。 
	 
	 <p>例えば、次の図は <codeph>joints</codeph> のさまざまな設定を示します。それぞれの設定で、角のある青い線は太さ 30 で、<codeph>jointStyle</codeph> が適用されています。重ね合わせた黒い線は太さ 1 で、<codeph>jointStyle</codeph> は適用されていません。
	 </p>
	 
     <p><adobeimage alt="MITER、ROUND、および BEVEL" href="../../images/linejoin.jpg"/></p>
	 
	 <p><b>注意：</b><codeph>joints</codeph> を <codeph>JointStyle.MITER</codeph> に設定すると、<codeph>miterLimit</codeph> パラメーターを使用して、マイターの長さを制限できます。</p>
 	 
	 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3</apiData><apiDesc>マイターが切り取られる限度を示す数値です。有効な値の範囲は 1 ～ 255 で、この範囲を超えた値は 1 または 255 に丸められます。この値は、<codeph>jointStyle</codeph> を <codeph>"miter"</codeph> に設定した場合にのみ有効です。<codeph>miterLimit</codeph> の値により、線の接合点を越えてマイターを延長できる長さが決定します。マイターを延長できる長さは、この値と線の <codeph>thickness</codeph> が乗算されたものです。例えば、<codeph>miterLimit</codeph> の値が 2.5 で、<codeph>thickness</codeph> が 10 ピクセルの場合、マイターは 25 ピクセルで切り取られます。 
	 
	 <p>例として、次のような角のある線を考えます。どの線も <codeph>thickness</codeph> を 20 に設定して描画されていますが、<codeph>miterLimit</codeph> はそれぞれ 1、2、4 に設定されています。重ね合わされた黒の基準線は、接合点を示しています。</p>
	 
     <p><adobeimage alt="miterLimit が 1、2、および 4 に設定されている線" href="../../images/miterLimit.jpg"/></p>
	 
	 <p><codeph>miterLimit</codeph> のそれぞれの値には、マイターが切り取られる独自の最大角度があります。次の表に、いくつかの例を示します。</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> の値：</entry><entry>角度が以下より小さい場合は切り取られる</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 度</entry></row><row><entry>2</entry>      <entry>60 度</entry></row><row><entry>4</entry>      <entry>30 度</entry></row><row><entry>8</entry>      <entry>15 度</entry></row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>線の描画に使用する線のスタイルを指定します。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <codeph>lineTo()</codeph> メソッドや <codeph>drawCircle()</codeph> メソッドなど、Graphics のメソッドの後続の呼び出しに使用する線スタイルを指定します。線のスタイルは、<codeph>lineGradientStyle()</codeph> メソッド、<codeph>lineBitmapStyle()</codeph> メソッド、または <codeph>lineStyle()</codeph> メソッドを再度別のパラメーターで呼び出すまで有効のままです。 
     
     <p>パスの描画中に <codeph>lineStyle()</codeph> メソッドを呼び出し、パス内の線のセグメントごとに異なるスタイルを指定できます。</p> 
	 
	 <p><b>注意：</b><codeph>clear()</codeph> メソッドを呼び出すと、線のスタイルが <codeph>undefined</codeph> に戻ります。</p>
     
	 </apiDesc><example><xref href="Graphics.html#lineTo()">lineTo()</xref> または <xref href="Graphics.html#moveTo()">moveTo()</xref> メソッドの例を参照して、<codeph>getStyle()</codeph> メソッドの使用方法を確認してください。 
     
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineBitmapStyle"><linktext>lineBitmapStyle</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle"><linktext>lineGradientStyle</linktext></link><link href="flash.display.xml#LineScaleMode"><linktext>LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>JointStyle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineTo"><apiName>lineTo</apiName><shortdesc>
	 現在の描画位置から (x, y) まで、現在の線のスタイルを使用して線を描画します。その後で、現在の描画位置は (x, y) に設定されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill.
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な水平座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な垂直座標を示す数値（ピクセル単位）。
     
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>現在の描画位置から (x, y) 地点まで線を描画します。
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 現在の描画位置から (<codeph>x</codeph>, <codeph>y</codeph>) まで、現在の線のスタイルを使用して線を描画します。その後で、現在の描画位置は (<codeph>x</codeph> , <codeph>y</codeph>) に設定されます。描画先の表示オブジェクトに Flash の描画ツールで作成したコンテンツが含まれている場合、<codeph>lineTo()</codeph> メソッドへの呼び出しの結果はこのコンテンツの下に描画されます。<codeph>lineTo()</codeph> を呼び出してから <codeph>moveTo()</codeph> メソッドを呼び出すと、現在の描画位置はデフォルトで (<i>0,0</i>) になります。いずれかのパラメーターを省略すると、このメソッドは失敗し、現在の描画位置は変更されません。
	 
	 </apiDesc><example conref="examples\Graphics_lineToExample.as"> 次の例では、<codeph>lineTo()</codeph> メソッドを使用して、ピクセル (100, 100) で始まる台形を描画します。 
 <p>線の太さが 10 ピクセル、色が金色で不透明、線の先端のキャップがなし（すべての線が結合されるため）に設定され、線の継ぎ目はマイター限度が 10、尖った鋭角の <codeph>MITER</codeph> に設定されます。</p>     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:moveTo"><apiName>moveTo</apiName><shortdesc>
     現在の描画位置を (x, y) に移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
	 
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な水平座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な垂直座標を示す数値（ピクセル単位）。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>現在の描画位置を (x, y) に移動します。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     現在の描画位置を (<codeph>x</codeph>, <codeph>y</codeph>) に移動します。いずれかのパラメーターを省略すると、このメソッドは失敗し、現在の描画位置は変更されません。
     
	 </apiDesc><example conref="examples\Graphics_moveToExample.as"> 次の例では、<codeph>moveTo()</codeph> メソッドおよび <codeph>lineTo()</codeph> メソッドを使用して、3 ピクセルの太さの破線を描画します。
 
 <p><codeph>lineStyle()</codeph> メソッドを使用して、線の太さが 3 ピクセルに設定されます。また、拡大 / 縮小しないよう設定されます。透明度が 25% の赤に色が設定されます。<codeph>CapsStyle</codeph> プロパティは四角形に設定されます（デフォルトは円形）。</p>
 
 <p><codeph>Graphics_moveToExample</codeph> は <codeph>Sprite</codeph> クラスのインスタンスであるため、すべての Graphics クラスのメソッドへのアクセス権があります。Graphics クラスのメソッドを使用して、<codeph>Graphic_moveToExample</codeph> Sprite オブジェクト上に直接描画できます。ただし、<codeph>Shape</codeph> にベクター描画オブジェクトを配置しないと、管理、移動、または変更できる方法が制限されます。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.display:NativeWindowType"><apiName>NativeWindowType</apiName><shortdesc>
	 NativeWindowType クラスは、ネイティブウィンドウを作成するために使用される NativeWindowInitOptions オブジェクトの type プロパティの定数を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 NativeWindowType クラスは、ネイティブウィンドウを作成するために使用される NativeWindowInitOptions オブジェクトの <codeph>type</codeph> プロパティの定数を定義します。
	 
	 <p><b>注意：</b>type 値は、ウィンドウが作成されて変更できないときに指定されます。</p>
	 	  
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowType:LIGHTWEIGHT"><apiName>LIGHTWEIGHT</apiName><shortdesc>
		 最小ウィンドウです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lightweight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 最小ウィンドウです。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
		 一般的なウィンドウです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 一般的なウィンドウです。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:UTILITY"><apiName>UTILITY</apiName><shortdesc>
		 ユーティリティウィンドウです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>utility</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 ユーティリティウィンドウです。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowDisplayState"><apiName>NativeWindowDisplayState</apiName><shortdesc>
     NativeWindowDisplayState クラスは、ウィンドウ表示状態の名前の定数を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     NativeWindowDisplayState クラスは、ウィンドウ表示状態の名前の定数を定義します。
     
     <p><b>注意：</b> フルスクリーンモードは Stage オブジェクトの <codeph>displayState</codeph> プロパティを使用して設定されます。ウィンドウの <codeph>displaySate</codeph> ではありません。</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link></related-links><apiValue id="flash.display:NativeWindowDisplayState:MAXIMIZED"><apiName>MAXIMIZED</apiName><shortdesc>
         最大化された表示状態です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>maximized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         最大化された表示状態です。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:MINIMIZED"><apiName>MINIMIZED</apiName><shortdesc>
         最小化された表示状態です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>minimized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         最小化された表示状態です。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
         通常の表示状態です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         通常の表示状態です。
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Screen"><apiName>Screen</apiName><shortdesc>
	 Screen クラスは、このアプリケーションで使用可能な表示画面に関する情報を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Screen クラスは、このアプリケーションで使用可能な表示画面に関する情報を提供します。
	 
	 <p>画面は、それよりも大きい可能性のある「仮想デスクトップ」内の独立したデスクトップ領域です。この仮想デスクトップの起点はオペレーティングシステムで設計されたメイン画面の左上隅になります。そのため、各表示画面の境界の座標は、負の値になる場合があります。また、どの表示画面の範囲にも含まれない仮想デスクトップの領域が存在する場合もあります。</p>
	 
	 <p>Screen クラスには、利用可能な画面オブジェクトにアクセスするための静的なクラスメンバーと、個別の画面のプロパティにアクセスするためのインスタンスメンバーが用意されています。画面情報は、ユーザーによって常に変更される可能性があるので、キャッシュされません。</p>
	  
	 <p>画面と、コンピューターに接続されている実際のモニターとの間には 1 対 1 の対応は必要ありません。例えば、2 つのモニターが同一の画面を表示することもあります。</p>
	 
	 <p>Screen クラスを直接インスタンス化することはできません。<codeph>new Screen()</codeph> コンストラクターを呼び出すと、<codeph>ArgumentError</codeph> 例外がスローされます。</p>
	 
	 </apiDesc><example conref="examples\ScreenExample.as"> 次の例では、DockingWindow クラスを使用して、画面の側面にドッキングするウィンドウを定義します。これを行うには、以下の手順を実行します。
 
 <ol>
     <li>キーボードイベントに応答して、ドッキングする画面の側面を決定します。</li>
 
    <li>静的な Screen クラスのメソッド <codeph>getScreensForRectangle()</codeph> にアクセスして、ウィンドウが現在表示されている画面の Screen オブジェクトを取得します。</li>
 
    <li>画面のサイズに基づいて、ウィンドウの境界をリセットします。</li>
 
    <li>新しいウィンドウのサイズに基づいて、ウィンドウのコンテンツを再描画します。</li>
 
 </ol>
 
 <p>このクラスは、<codeph>SystemChrome="none"</codeph> および <codeph>transparent="true"</codeph> の設定を持つ AIR アプリケーションのルートクラスとして使用することを目的としていることに注意してください。 システムクロムを使用するウィンドウでこのクラスを使用するには、ウィンドウの位置とサイズを計算するときに、クロムの幅とウィンドウの最小幅を考慮する必要があります。</p>
<codeblock>

package
{
    import flash.display.Screen;
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.KeyboardEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;

    public class DockingWindow extends Sprite
    {
        private const dockedWidth:uint = 80;
        private const dockedHeight:uint = 80;
        
        public function DockingWindow():void{
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onKey);
            dockLeft();
        }
        
        private function onKey(event:KeyboardEvent):void{
            switch(event.keyCode){
                case Keyboard.LEFT :
                    dockLeft();
                    break;
                case Keyboard.RIGHT :
                    dockRight();
                    break;
                case Keyboard.UP :
                    dockTop();
                    break;
                case Keyboard.DOWN :
                    dockBottom();
                    break;
                case Keyboard.SPACE :
                    stage.nativeWindow.close();
            }    
        }
        
        public function dockLeft():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.height = screen.visibleBounds.height;
            stage.stageWidth = dockedWidth;
            drawContent();
        }
        
        public function dockRight():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.width - dockedWidth;            
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.stageWidth = dockedWidth;
            stage.nativeWindow.height = screen.visibleBounds.height;
            drawContent();
        }
        
        public function dockTop():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;
            drawContent();
        }
        
        public function dockBottom():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.height - dockedHeight;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;    
            drawContent();        
        }
        
        private function getCurrentScreen():Screen{
            return Screen.getScreensForRectangle(stage.nativeWindow.bounds)[0];
        }
        
        private function drawContent():void{
            const size:int = 60;
            const pad:int = 10;
            var numHSquares:int = Math.floor(stage.stageWidth/(size + pad));
            var numVSquares:int = Math.floor(stage.stageHeight/(size + pad));
            with (graphics){
                clear();
                lineStyle(1);
                beginFill(0x3462d5,.7);
                for(var i:int = 0; i &lt; numHSquares; i++){
                    for(var j:int = 0; j &lt; numVSquares; j++){                
                            drawRect((i * (size + pad)) + pad, (j * (size + pad)) + pad, size, size);
                    }
                }
                endFill();
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Screen:getScreensForRectangle"><apiName>getScreensForRectangle</apiName><shortdesc>
		 指定された矩形と交差する画面のセット（空の場合もあります）を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc><codeph>rect</codeph> パラメーターで定義されている領域の一部を含む画面が含まれている Screen オブジェクトの配列です。
		 
		 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>仮想デスクトップの起点（主画面の左上隅）を基準とした座標を持つ矩形です。
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 指定された矩形と交差する画面のセット（空の場合もあります）を返します。
		  
		 </apiDesc><example conref="examples\Screen.getScreensForRectangle.1.as"> 次の例は、少なくとも指定された矩形の一部を含む画面の配列を取得する方法を示したものです。
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var rect:Rectangle = new Rectangle(-200, 100, 1000, 600);
var intersectedScreens:Array = Screen.getScreensForRectangle(rect);
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:Screen:bounds:get"><apiName>bounds</apiName><shortdesc>
		 この画面の境界です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 この画面の境界です。
		 
		 <p>画面の位置は、仮想デスクトップを基準としています。</p>
		 
		 </apiDesc><example conref="examples\Screen.bounds.1.as"> 次の例は、画面の境界 (ここでは主表示画面) を取得する方法を示したものです。
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.bounds;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:colorDepth:get"><apiName>colorDepth</apiName><shortdesc>
		 ビット数で表した、この画面の色深度です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 ビット数で表した、この画面の色深度です。
		 
		 </apiDesc><example conref="examples\Screen.colorDepth.1.as"> 次の例は、画面の色深度（ここでは主表示画面）を取得する方法を示したものです。
<codeblock>

var mainScreen:Screen = Screen.mainScreen;
var colors:uint = mainScreen.colorDepth;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:mainScreen:get"><apiName>mainScreen</apiName><shortdesc>
		 主表示です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Screen</apiValueClassifier></apiValueDef><apiDesc>
		 主表示です。
		 
		 </apiDesc><example conref="examples\Screen.mainScreen.1.as"> 次の例は、このコンピューターの「メイン」画面を表す Screen オブジェクトを取得する方法を示したものです。
<codeblock>

var primaryScreen:Screen = Screen.mainScreen;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:screens:get"><apiName>screens</apiName><shortdesc>
		 現在使用可能な画面の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3."/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 現在使用可能な画面の配列です。 
		 
		 <p>返された配列を変更しても、使用可能な画面には影響しません。</p>
		 
		 </apiDesc><example conref="examples\Screen.screens.1.as"> 次の例は、使用可能な画面を含む配列を取得する方法を示したものです。
<codeblock>

var screenArray:Array = Screen.screens;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:visibleBounds:get"><apiName>visibleBounds</apiName><shortdesc>
		 この画面上にウィンドウを表示できる領域の境界です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 この画面上にウィンドウを表示できる領域の境界です。
		 
		 <p>画面の <codeph>visibleBounds</codeph> は、Windows の場合はタスクバー（およびその他のドッキングデスクバー）を除いた領域、Mac OS X の場合はメニューバーと、システムの設定によってはドックを除いた領域です。Linux の場合、構成によっては表示境界を特定できないことがあります。その場合、<codeph>visibleBounds</codeph> プロパティは <codeph>screenBounds</codeph> プロパティと同じ値を返します。</p>
		 
		 </apiDesc><example conref="examples\Screen.usableBounds.1.as"> 次の例は、使用可能な画面の境界（ここでは主表示画面）を取得する方法を示したものです。
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.visibleBounds;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Bitmap"><apiName>Bitmap</apiName><shortdesc>
 Bitmap クラスはビットマップイメージを表す表示オブジェクトを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>イメージが派生する表示オブジェクトを表します。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Bitmap クラスはビットマップイメージを表す表示オブジェクトを表します。これらは flash.display.Loader クラスによってロードするイメージか、<codeph>Bitmap()</codeph> コンストラクターによって作成するイメージです。 
 
 <p><codeph>Bitmap()</codeph> コンストラクターを使用すると、BitmapData オブジェクトへの参照を含んだビットマップオブジェクトを作成できます。ビットマップオブジェクトの作成後、親 DisplayObjectContainer インスタンスの <codeph>addChild()</codeph> メソッドまたは <codeph>addChildAt()</codeph> メソッドを使用して表示リスト上にビットマップを配置できます。</p>
 
 <p>Bitmap オブジェクトの BitmapData への参照は、translation プロパティまたは rotation プロパティと関係なく、複数の Bitmap オブジェクトで共有できます。作成した複数のビットマップオブジェクトで同じ BitmapData オブジェクトを参照することができるため、各表示オブジェクトインスタンスに関する BitmapData オブジェクトのメモリのオーバーヘッドを避けつつ、複数の表示オブジェクトで同一の複雑な BitmapData オブジェクトを使用することができます。</p>
 
 <p>Bitmap オブジェクトを使用して BitmapData オブジェクトを画面に描画するには、ベクターレンダラーをビットマップ塗りつぶしのシェイプとして使用するか、高速なピクセルコピールーチンを使用します。ピクセルコピールーチンはベクターレンダラーよりも高速ですが、使用する際には、ビットマップオブジェクトに以下の特定の条件が適用されます。</p>
 
 <ul>
 
 <li> ビットマップオブジェクトには、伸縮、回転、傾斜は適用されません。</li>
 <li> ビットマップオブジェクトにはカラー変換は適用されません。 </li>
 <li> ビットマップオブジェクトにはブレンドモードは適用されません。 </li>
 <li> マスクレイヤーまたは <codeph>setMask()</codeph> メソッドでクリッピングは行われません。 </li>
 <li> イメージ自体はマスクできません。 </li>
 <li> 宛先の座標は全体がピクセル境界内になければなりません。 </li>
 
 </ul>
 
 <p>ロードする Bitmap オブジェクトの置かれているドメインが、イメージのロードに使用する Loader オブジェクトのドメインと異なる場合は、Loader オブジェクトのドメインへのアクセスを許可する URL ポリシーファイルが用意されていないと、そのドメイン内のスクリプトは Bitmap オブジェクトやそのプロパティとメソッドにアクセスできません。詳しくは、次のトピックを参照してください。</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_jp" scope="external">セキュリティに関する章</xref>（『ActionScript 3.0 のプログラミング』）と LiveDocs に関する最新のコメント<i/></li>
 
 <li>Flash Player デベロッパーセンタートピック：<xref href="http://www.adobe.com/go/devnet_security_jp" scope="external">セキュリティ</xref></li>
 </ul>
 
 
 <p><b>注意：</b>Bitmap クラスは InteractiveObject クラスのサブクラスではないため、マウスイベントを送出できません。しかし、ビットマップオブジェクトを格納した表示オブジェクトコンテナの <codeph>addEventListener()</codeph> メソッドを使用できます。</p>
 
 </apiDesc><example conref="examples\BitmapExample.as"> 次の例では、BitmapExample クラスを使用して、"Image.gif" イメージをデフォルトの位置（<i>x = 0、y = 0</i>）にある DisplayObject にロードします。"Image.gif" のコピーを下のイメージの右に配置します。このコピーでは、<codeph>threshold()</codeph> メソッドを使用するテストに合格したピクセルに新しい色が適用されています。これを行うには、以下の手順を実行します。
 <ol>
  <li>プロパティ <codeph>url</codeph> を作成します。これはイメージファイルの場所と名前です。</li>
  <li>クラスコンストラクターが <codeph>configureAssets()</codeph> メソッドを呼び出します。続いて、このメソッドでは <codeph>completeHandler()</codeph> メソッドを呼び出します。</li>
  <li><codeph>configureAssets()</codeph> が Loader オブジェクトを作成します。これは、<codeph>completeHandler()</codeph> がイメージ操作を完了したときに送出されるイベントリスナーをインスタンス化します。</li>
  <li>次に、<codeph>buildChild()</codeph> が URLRequest オブジェクト <codeph>request</codeph> の新しいインスタンスを作成しますが、その前に、ファイル名と場所が分かるように <codeph>url</codeph> を渡します。</li>
  <li><codeph>request</codeph> オブジェクトが <codeph>loader.load()</codeph> メソッドに渡されます。このメソッドは、イメージを表示オブジェクト経由でメモリにロードします。</li>
  <li>次にイメージが表示リストに配置され、イメージは直ちに画面の座標 <i>x = 0、y = 0</i> に表示されます。</li>
  <li>続いて、<codeph>completeHandler()</codeph> メソッドで、次の処理が実行されます。
  <ol outputclass="A">
      <li>2 番目の Loader オブジェクトと Bitmap オブジェクトを作成します。Bitmap オブジェクトは、この Loader オブジェクトで </li>
      <li>2 番目の Bitmap オブジェクトである <codeph>duplicate</codeph> を作成します。これは、<codeph>duplicateImage()</codeph> メソッドを呼び出し、元のイメージを複製します。 </li>
      <li>BitmapData オブジェクトを作成します。これは、<codeph>duplicate</codeph> オブジェクトの BitmapData オブジェクトに割り当てられます。</li>
      <li>元のイメージと同じ座標、幅、高さで初期化された新しい Rectangle オブジェクトを作成します。</li>
      <li>新しい Point オブジェクトを作成します。デフォルトでは <i>x = 0、y = 0</i> に作成されます。</li>
      <li>次に示す変数を作成します。
      <ul>
          <li><codeph>operation</codeph>：しきい値が元の値以上である場合に、新しい色を適用します。</li>
          <li><codeph>threshold</codeph>：各ピクセルの比較対象の値です。アルファ 0xCC の明るい灰色に設定されます。 </li>
          <li><codeph>color</codeph>：しきい値のテストに合格したピクセルに設定する色です。この場合は黄色です。</li>
          <li><codeph>mask</codeph>：正反対の色に設定します。この場合は透明色の青色です。</li>
          <li><codeph>copySource</codeph>：false に設定されます。これは、しきい値を満たさなかった場合にピクセル値がコピーされないことを示します。しきい値のテストに合格したピクセルだけが変更されるため、この値に意味はありません。</li>
      </ul></li>
      <li>上記の変数を使用して <codeph>threshold()</codeph> メソッドを呼び出します。結果のしきい値の等式は、<codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph> のようになります。 </li>
  </ol></li>
 </ol>
 <p> <b>注意：</b>
 <ul>
  <li>「ローカルでの再生に関するセキュリティ」を「ローカルファイルにのみアクセスする」に設定して SWF ファイルをコンパイルする必要があります。
 </li>
  <li>この例では、"Image.gif" という名前のファイルが SWF ファイルと同じディレクトリに配置されている必要があります。
 </li>
  <li>イメージは、幅が 80 ピクセル以内のものを使用することをお勧めします。 </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiConstructor id="flash.display:Bitmap:Bitmap"><apiName>Bitmap</apiName><shortdesc>
     指定された BitmapData オブジェクトを参照するようにビットマップオブジェクトを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>BitmapData オブジェクトが参照されます。 
     
     </apiDesc></apiParam><apiParam><apiItemName>pixelSnapping</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>auto</apiData><apiDesc>ビットマップオブジェクトが最も近いピクセルに吸着されるかどうかを示します。
     
     </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ビットマップを拡大 / 縮小するときにスムージングするかどうかを示します。例えば、次の例は同じビットマップを 3 倍に拡大した場合に、<codeph>smoothing</codeph> を <codeph>false</codeph> に設定したもの（左）と <codeph>true</codeph> に設定したもの（右）です。
     
     <p>
      <adobetable>
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="スムージングなしのビットマップ。" href="../../images/bitmap_smoothing_off.jpg"/></entry>
      <entry align="center"><adobeimage alt="スムージングありのビットマップ。" href="../../images/bitmap_smoothing_on.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     </p>
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     指定された BitmapData オブジェクトを参照するようにビットマップオブジェクトを初期化します。
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Bitmap:bitmapData:get"><apiName>bitmapData</apiName><shortdesc>
    BitmapData オブジェクトが参照されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
    BitmapData オブジェクトが参照されます。
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:pixelSnapping:get"><apiName>pixelSnapping</apiName><shortdesc>
    Bitmap オブジェクトが最も近いピクセルに吸着されるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Bitmap オブジェクトが最も近いピクセルに吸着されるかどうかを指定します。PixelSnapping クラスには正の値が入ります。
    
    <ul>
    
      <li><codeph>PixelSnapping.NEVER</codeph> — ピクセルは吸着されません。</li>
    
      <li><codeph>PixelSnapping.ALWAYS</codeph> — イメージは、変換とは関係なく常に最も近いピクセルに吸着されます。</li>
    
      <li><codeph>PixelSnapping.AUTO</codeph> — イメージが回転または傾斜なしで描画され、しかも 99.9% ～ 100.1% の倍率で描画される場合、イメージは最も近いピクセルに吸着されます。これらの条件が満たされる場合、ビットマップイメージは 100% の倍率で描画され、最も近いピクセルに吸着されます。内部的には、この値によって、ベクターレンダラーを使ってイメージが可能な限り高速に描画されます。</li>
    
    </ul>
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:smoothing:get"><apiName>smoothing</apiName><shortdesc>
    ビットマップを拡大 / 縮小するときにスムージングするかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    ビットマップを拡大 / 縮小するときにスムージングするかどうかを指定します。<codeph>true</codeph> である場合、ビットマップは拡大 / 縮小時にスムージングされます。<codeph>false</codeph> である場合、ビットマップは拡大 / 縮小時にスムージングされません。
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Scene"><apiName>Scene</apiName><shortdesc>
	Scene クラスには、シーン内のフレームの名前、ラベル、数を識別できるプロパティがあります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Scene クラスには、シーン内のフレームの名前、ラベル、数を識別できるプロパティがあります。MovieClip クラスの <codeph>currentScene</codeph> プロパティは、MovieClip インスタンスのタイムライン内の再生ヘッドが置かれているシーンを識別する Scene オブジェクトです。MovieClip クラスの <codeph>scenes</codeph> プロパティは、Scene オブジェクトの配列です。また、MovieClip クラスの <codeph>gotoAndPlay()</codeph> および <codeph>gotoAndStop()</codeph> メソッドは、Scene オブジェクトをパラメーターとして使用します。
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:Scene:labels:get"><apiName>labels</apiName><shortdesc>
		シーンの FrameLabel オブジェクトの配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		シーンの FrameLabel オブジェクトの配列です。各 FrameLabel オブジェクトには、ラベルに対応するフレーム数を指定する <codeph>frame</codeph> プロパティ、および <codeph>name</codeph> プロパティがあります。
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:Scene:name:get"><apiName>name</apiName><shortdesc>
		シーン名です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		シーン名です。
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Scene:numFrames:get"><apiName>numFrames</apiName><shortdesc>
		シーン内のフレームの数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		シーン内のフレームの数です。
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageDisplayState"><apiName>StageDisplayState</apiName><shortdesc>
StageDisplayState クラスは、Stage.displayState プロパティの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageDisplayState クラスは、<codeph>Stage.displayState</codeph> プロパティの値を提供します。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link></related-links><apiValue id="flash.display:StageDisplayState:FULL_SCREEN"><apiName>FULL_SCREEN</apiName><shortdesc>
ステージがフルスクリーンモードであることを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージがフルスクリーンモードであることを指定します。このモードでは、キーボード操作は無効になります。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:FULL_SCREEN_INTERACTIVE"><apiName>FULL_SCREEN_INTERACTIVE</apiName><shortdesc>
ステージがフルスクリーンモードで、キーボード操作が有効であることを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreenInteractive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージがフルスクリーンモードで、キーボード操作が有効であることを指定します。<ph platform="actionscript">AIR アプリケーションだけが、この機能をサポートしています。</ph>

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
ステージが標準モードであることを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージが標準モードであることを指定します。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderData"><apiName>ShaderData</apiName><shortdesc>
	 ShaderData オブジェクトには、シェーダーカーネルのパラメーターと入力を表すプロパティ、シェーダーに指定されたメタデータを含むプロパティがあります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderData オブジェクトには、シェーダーカーネルのパラメーターと入力を表すプロパティ、シェーダーに指定されたメタデータを含むプロパティがあります。
	 
	 <p>これらのプロパティは、ShaderData オブジェクトの作成時に追加されます。プロパティ名はシェーダーのソースコードで指定された名前と一致します。各プロパティのデータ型は、そのプロパティがシェーダーの何を表すかによって異なります。それぞれのデータ型に対応して、シェーダーパラメーターを表すプロパティは ShaderParameter インスタンス、入力イメージを表すプロパティは ShaderInput インスタンス、シェーダーメタデータを表すプロパティは ActionScript クラスのインスタンスとなります。例えば、テキストメタデータの場合は String インスタンス、uint メタデータの場合は uint となります。</p>
	 
	 <p>例えば、1 つの入力イメージ（<codeph>src</codeph>）、2 つのパラメーター（<codeph>size</codeph> と <codeph>radius</codeph>）、3 つのメタデータ値（<codeph>nameSpace</codeph>、<codeph>version</codeph>、<codeph>description</codeph>）で定義されるシェーダーがあるとします。</p>
	 
	 <codeblock>
	 &lt;languageVersion : 1.0;>
	 
	 kernel DoNothing
	 &lt;
	     namespace: "Adobe::Example";
	     vendor: "Adobe examples";
	     version: 1;
	     description: "A shader that does nothing, but does it well.";
	 >
	 {
	     input image4 src;
	 
	     output pixel4 dst;
	     
	     parameter float2 size
	     &lt;
	         description: "The size of the image to which the kernel is applied";
	         minValue: float2(0.0, 0.0);
	         maxValue: float2(100.0, 100.0);
	         defaultValue: float2(50.0, 50.0);
	     >;
	     
	     parameter float radius
	     &lt;
	         description: "The radius of the effect";
	         minValue: 0.0;
	         maxValue: 50.0;
	         defaultValue: 25.0;
	     >;
	 
	     void evaluatePixel()
	     {
	         float2 one = (radius / radius) ∗ (size / size);
	         dst = sampleNearest(src, outCoord());
	     }
	 }
	 </codeblock>
	 
	 <p>このシェーダーのバイトコードを読み込んで Shader インスタンスを作成すると、<codeph>data</codeph> プロパティの ShaderData インスタンスには次のプロパティが含まれます。</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>プロパティ</entry><entry>データ型</entry><entry>値</entry></row></thead><tbody><row>
	   <entry>name</entry>
	   <entry>String</entry>
	   <entry>"DoNothing"</entry>
	 </row><row>
	   <entry>nameSpace</entry>
	   <entry>String</entry>
	   <entry>"Adobe::Example"</entry>
	 </row><row>
	   <entry>version</entry>
	   <entry>String</entry>
	   <entry>"1"</entry>
	 </row><row>
	   <entry>description</entry>
	   <entry>String</entry>
	   <entry>"A shader that does nothing, but does it well."</entry>
	 </row><row>
	   <entry>src</entry>
	   <entry>ShaderInput</entry>
	   <entry>[ShaderInput インスタンス]<i/></entry>
	 </row><row>
	   <entry>size</entry>
	   <entry>ShaderParameter</entry>
	   <entry>[ShaderParameter インスタンスとパラメーターメタデータのプロパティ]<i/></entry>
	 </row><row>
	   <entry>radius</entry>
	   <entry>ShaderParameter</entry>
	   <entry>[ShaderParameter インスタンスとパラメーターメタデータのプロパティ]<i/></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>シェーダーソースコードで定義されていても、シェーダーの <codeph>evaluatePixel()</codeph> 関数で使用されなかった入力イメージやパラメーターは、シェーダーがバイトコードにコンパイルされるときに削除されます。その場合、対応する ShaderInput と ShaderParameter インスタンスは ShaderData インスタンスのプロパティとして追加されません。</p> 
	 
	 <p>一般に、開発者コードでは ShaderData インスタンスは作成されません。シェーダーのデータ、パラメーター、および入力を含む ShaderData インスタンスは、Shader インスタンスの <codeph>data</codeph> プロパティとして使用できます。</p>
	 
	 </apiDesc><example conref="examples\ShaderDataExample.1.as"> 次の例では、シェーダーを読み込み、ShaderData インスタンスを <codeph>data</codeph> プロパティで列挙し、シェーダーの入力、パラメーター、メタデータの各プロパティを表示します。
 
 <p>この例では、"donothing.pbj" という名前のシェーダーバイトコードファイルが、アプリケーションの出力先と同じディレクトリにあるものとします。</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel DoNothing
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "A shader that does nothing, but does it well.";
>
{
    input image4 src;
    
    output pixel4 dst;
    
    parameter float2 size
    &lt;
        description: "The size of the image to which the shader is applied";
        minValue: float2(0.0, 0.0);
        maxValue: float2(100.0, 100.0);
        defaultValue: float2(50.0, 50.0);
    >;
    
    parameter float radius
    &lt;
        description: "The radius of the effect";
        minValue: float(0.0);
        maxValue: float(50.0);
        defaultValue: float(25.0);
    >;

    void evaluatePixel()
    {
        float2 one = (radius / radius) * (size / size);
        dst = sampleNearest(src, outCoord());
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderDataExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function ShaderDataExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            for (var p:String in shader.data) {
                trace(p, ":", shader.data[p]);
                for (var d:String in shader.data[p]) {
                    trace("\t", d, ":", shader.data[p][d]);
                }
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links><apiConstructor id="flash.display:ShaderData:ShaderData"><apiName>ShaderData</apiName><shortdesc>
		 ShaderData インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>byteCode</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>シェーダーのバイトコードです。
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 ShaderData インスタンスを作成します。一般に、ShaderData コンストラクターは開発者コードでは直接呼び出されません。Shader インスタンスのデータ、パラメーター、入力を含む ShaderData インスタンスは、<codeph>data</codeph> プロパティを使用してアクセスします。
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
	 スタンドアローンモードでシェーダー操作を実行するには、ShaderJob インスタンスを使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 スタンドアローンモードでシェーダー操作を実行するには、ShaderJob インスタンスを使用します。シェーダー操作が実行されて、その結果のデータが返されます。その結果の使用方法は開発者が決めます。
	 
	 <p>シェーダーをスタンドアローンモードで使用する主な理由が 2 つあります。</p>
	 
	 <ul>
	   <li>イメージ以外のデータの処理：ShaderJob インスタンスを使用して入力値を制御し、シェーダーの結果の使用方法を制御できます。シェーダーは、イメージデータの代わりにバイナリデータまたは数値データとして結果を返すことができます。</li>
	   <li>バックグラウンド処理：一部の複雑なシェーダーは、実行するのに著しく時間がかかります。アプリケーションのメイン実行で複雑なシェーダーを実行すると、ユーザー入力や画面の更新など、アプリケーションの他の部分が減速する場合があります。ShaderJob インスタンスを使用すると、シェーダーをバックグラウンドで実行できます。この方法でシェーダーを実行すると、シェーダー操作はアプリケーションのメイン実行とは別個に実行されます。</li>
	 </ul>
	 
	 <p><codeph>shader</codeph> プロパティ（またはコンストラクターパラメーター）は、操作に使用するシェーダーを表す Shader インスタンスを指定します。シェーダーに必要なパラメーターや入力を指定するには、関連する ShaderParameter や ShaderInput インスタンスを使用します。</p>
	 
	 <p>ShaderJob 操作の実行前に、結果の書き込み先のオブジェクトを <codeph>target</codeph> プロパティの値として設定します。シェーダー操作が終了すると、結果が <codeph>target</codeph> オブジェクトに書き込まれます。</p>
	 
	 <p>バックグラウンドでのシェーダー操作を開始するには、<codeph>start()</codeph> メソッドを呼び出します。操作が終了すると、結果が <codeph>target</codeph> オブジェクトに書き込まれます。その時点で、ShaderJob インスタンスは <codeph>complete</codeph> イベントを送出し、結果が出ていることをリスナーに通知します。</p>
	 
	 <p>シェーダーをバックグラウンドで実行せずに同期的に実行するには、<codeph>start()</codeph> メソッドを呼び出して <codeph>true</codeph> を引数として渡します。シェーダーはメイン実行のスレッドで実行され、この操作が完了するまでコードが一時停止します。終了すると、結果が <codeph>target</codeph> オブジェクトに書き込まれます。その後にアプリケーションの実行が次のコード行から続行されます。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader"><linktext>Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>ShaderParameter</linktext></link><link href="flash.events.xml#ShaderEvent"><linktext>ShaderEvent</linktext></link></related-links><adobeApiEvent id="flash.display:ShaderJob_flash.events.ShaderEvent.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 ShaderJob を非同期的に実行したときに、シェーダーによるデータ処理が終了すると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ShaderEvent.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 ShaderJob を非同期的に実行したときに、シェーダーによるデータ処理が終了すると送出されます。ShaderJob インスタンスを非同期的に実行するには、<codeph>start()</codeph> メソッドを呼び出して <codeph>waitForCompletion</codeph> パラメーターに値として <codeph>false</codeph> を渡します。
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:ShaderJob:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
		 
		 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>操作に使用するシェーダーです。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>シェーダー操作の結果が書き込まれるオブジェクトです。この引数は、BitmapData、ByteArray、または Vector のいずれかでなければなりません。&lt;Number> インスタンスです。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>ByteArray または Vector の場合は、<codeph>target</codeph> の結果データの幅です。&lt;Number> インスタンスです。ByteArray または Vector のサイズです。&lt;Number> インスタンスは必要に応じて拡大され、既存のデータは上書きされます。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>ByteArray または Vector の場合は、<codeph>target</codeph> の結果データの高さです。&lt;Number> インスタンスです。ByteArray または Vector のサイズです。&lt;Number> インスタンスは必要に応じて拡大され、既存のデータは上書きされます。
         
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:ShaderJob:cancel"><apiName>cancel</apiName><shortdesc>
		 現在実行中のシェーダー操作をキャンセルします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 現在実行中のシェーダー操作をキャンセルします。既に計算済みの結果データがある場合、そのデータは破棄されます。<codeph>complete</codeph> イベントは送出されません。
		 
		 <p><codeph>cancel()</codeph> を複数回呼び出しても効果はありません。</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:ShaderJob:start"><apiName>start</apiName><shortdesc>
		 waitForCompletion パラメーターの値に従って、シェーダー操作を同期モードまたは非同期モードで開始します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>target</codeph> プロパティが <codeph>null</codeph> または BitmapData、ByteArray、Vector でない場合。&lt;Number> インスタンスです。
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>シェーダーが指定したイメージ入力が存在しない場合。
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>ByteArray または Vector の場合。&lt;Number> インスタンスが入力として使用され、ShaderInput の <codeph>width</codeph> および <codeph>height</codeph> プロパティが指定されていない、または指定された値が入力オブジェクトのデータ量と一致しない場合。詳しくは、<codeph>ShaderInput.input</codeph> プロパティを参照してください。
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>waitForCompletion</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>シェーダーの実行をバックグラウンド（<codeph>false</codeph>、デフォルト）で行うか、プログラムのメイン実行（<codeph>true</codeph>）で行うかを指定します。
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 <codeph>waitForCompletion</codeph> パラメーターの値に従って、シェーダー操作を同期モードまたは非同期モードで開始します。
		 
		 <p><codeph>waitForCompletion</codeph> が <codeph>false</codeph>（デフォルト）の場合は、非同期モードになり、ShaderJob はバックグラウンドで実行されます。シェーダー操作は、表示の応答性や他の操作には影響しません。非同期モードでは、<codeph>start()</codeph> 呼び出しが即座に戻り、プログラムの実行が次のコード行から続行されます。非同期のシェーダー操作が終了すると、結果が出て <codeph>complete</codeph> イベントが送出されます。</p>
		 
		 <p>バックグラウンドでは一度に 1 つの ShaderJob 操作のみが実行されます。シェーダー操作は実行されるまでキューに入ります。シェーダー操作の実行中に <codeph>start()</codeph> メソッドを呼び出すと、追加の操作がキューの末尾に追加されます。後で順番が来ると、その操作が実行されます。</p>
		 
		 <p>シェーダー操作を同期モードで実行するには、<codeph>start()</codeph> を呼び出して <codeph>waitForCompletion</codeph> パラメーター（唯一のパラメーター）に <codeph>true</codeph> を渡します。シェーダー操作が完了するまでは、コードの実行が <codeph>start()</codeph> を呼び出した箇所で一時停止します。操作が完了すると、結果が出て次のコード行から実行が続行されます。</p>
		 
		 <p><codeph>start()</codeph> メソッドを呼び出すと、<codeph>shader</codeph> プロパティの Shader インスタンスの内部的にコピーされます。シェーダー操作は、元のシェーダーを参照するのではなく、その内部コピーを使用します。パラメーター値、入力、バイトコードの変更などの変更をシェーダーに加えたとしても、シェーダーの処理で使用したコピーシェーダーにはその変更は適用されません。シェーダーの変更をシェーダーの処理に適用するには、（必要に応じて）<codeph>cancel()</codeph> メソッドを呼び出し、もう一度 <codeph>start()</codeph> メソッドを呼び出して、シェーダーの処理を再開します。</p>
		 
		 <p>シェーダー操作の実行中、<codeph>target</codeph> オブジェクトの値は変わりません。操作が終了すると（非同期モードで <codeph>complete</codeph> イベントが送出されると）、結果全体が一度に <codeph>target</codeph> オブジェクトに書き込まれます。<codeph>target</codeph> オブジェクトが BitmapData インスタンスで、操作が終了する前にその <codeph>dispose()</codeph> メソッドが呼び出された場合でも、非同期モードでは <codeph>complete</codeph> イベントが送出されます。ただし、結果データは破棄状態にあるため、BitmapData オブジェクトには書き込まれません。</p>
         
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.display:ShaderJob:start_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><codeph>start()</codeph> メソッドを呼び出して <codeph>waitForCompletion</codeph> 引数に <codeph>true</codeph> を渡した場合は、操作の終了時に送出されます。
		 
		 </apiDesc></adobeApiEventDetail><shortdesc>start() メソッドを呼び出して waitForCompletion 引数に true を渡した場合は、操作の終了時に送出されます。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.display:ShaderJob:height:get"><apiName>height</apiName><shortdesc>
		 ByteArray または Vector の場合は、target の結果データの高さです。&amp;lt;Number&amp;gt; インスタンスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 ByteArray または Vector の場合は、<codeph>target</codeph> の結果データの高さです。&lt;Number> インスタンスです。ByteArray または Vector のサイズです。&lt;Number> インスタンスは必要に応じて拡大され、既存のデータは上書きされます。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:progress:get"><apiName>progress</apiName><shortdesc>
		 実行中のシェーダーの進行状況です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 実行中のシェーダーの進行状況です。このプロパティは 0 から 1 までの値です。初期値は 0 です（0 ％完了）。1 はシェーダー操作が完了したことを示します。
		 
		 <p><codeph>cancel()</codeph> メソッドが呼び出されると、このプロパティは <codeph>undefined</codeph> になります。シェーダー操作が再開されるまで、このプロパティの値を信頼して使用することはできません。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:shader:get"><apiName>shader</apiName><shortdesc>
		 操作に使用したシェーダーです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 操作に使用したシェーダーです。Shader インスタンスの <codeph>data</codeph> プロパティで、ShaderInput または ShaderParameter プロパティを使用して、目的のシェーダーの入力またはパラメーターを指定する必要があります。対応する ShaderInput が <codeph>target</codeph> オブジェクトと同じ場合でも、これを使用して入力を指定する必要があります。
		 
		 <p>線形データ配列（イメージデータではなく）を含む ByteArray を処理するには、ByteArray 内の対応する  ShaderInput インスタンスの <codeph>height</codeph> を 1 に、<codeph>width</codeph> を 32 ビット浮動小数点の値に設定します。その場合、シェーダーの入力は <codeph>image1</codeph> データ型で定義する必要があります。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderJob:target:get"><apiName>target</apiName><shortdesc>
		 シェーダー操作の結果が書き込まれるオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダー操作の結果が書き込まれるオブジェクトです。このオブジェクトは、BitmapData、ByteArray、または Vector のいずれかでなければなりません。&lt;Number> インスタンスです。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:width:get"><apiName>width</apiName><shortdesc>
		 ByteArray または Vector の場合は、target の結果データの幅です。&amp;lt;Number&amp;gt; インスタンスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 ByteArray または Vector の場合は、<codeph>target</codeph> の結果データの幅です。&lt;Number> インスタンスです。ByteArray または Vector のサイズです。&lt;Number> インスタンスは必要に応じて拡大され、既存のデータは上書きされます。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowSystemChrome"><apiName>NativeWindowSystemChrome</apiName><shortdesc>
	 NativeWindowSystemChrome クラスは、ネイティブウィンドウを作成するために使用される NativeWindowInitOptions オブジェクトの systemChrome プロパティの定数を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 NativeWindowSystemChrome クラスは、ネイティブウィンドウを作成するために使用される NativeWindowInitOptions オブジェクトの <codeph>systemChrome</codeph> プロパティの定数を定義します。  
	 
	 <p>システムクロムは、タイトルバー、最小化ボタン、最大化ボタン、閉じるボタンなど、オペレーティングシステムに固有のウィンドウエレメントを参照します。</p>
  	 
	 <p><b>注意：</b>使用されるシステムクロムのタイプは、ウィンドウが作成されて変更できないときに指定されます。</p>
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowSystemChrome:NONE"><apiName>NONE</apiName><shortdesc>
	 システムクロムはありません。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 システムクロムはありません。 
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowSystemChrome:STANDARD"><apiName>STANDARD</apiName><shortdesc>
	 ホストオペレーティングシステムの標準クロムです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 ホストオペレーティングシステムの標準クロムです。
	 
	 <p>この設定を使用して、ネイティブオペレーティングシステムの外観と使用感をエミュレートします。</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsStroke"><apiName>IGraphicsStroke</apiName><shortdesc>
	このインターフェイスは、flash.display.Graphics のメソッドおよび描画クラスの線パラメーターとして使用されるオブジェクトを定義するために使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	このインターフェイスは、flash.display.Graphics のメソッドおよび描画クラスの線パラメーターとして使用されるオブジェクトを定義するために使用します。線プロパティデータの作成と管理、および異なるインスタンスでの同じデータの再利用には、このインターフェイスの実装者クラスを使用します。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
 SimpleButton クラスを使用すると、SWF ファイル内のボタンシンボルのすべてのインスタンスを制御することができます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>SimpleButton クラスを使用すると、SWF ファイル内のボタンシンボルのすべてのインスタンスを制御することができます。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 SimpleButton クラスを使用すると、SWF ファイル内のボタンシンボルのすべてのインスタンスを制御することができます。オーサリングツール内のボタンのインスタンスを作成した後は、SimpleButton クラスのメソッドとプロパティを使用して、ActionScript でボタンを操作できます。
 
 <p product="flash">プロパティインスペクターでもボタンにインスタンス名を付けることができます。SimpleButton インスタンスの名前は、ムービーエクスプローラーに表示されます。また、アクションパネルのターゲットパスの挿入ダイアログボックスにも表示されます。</p>
 
 <p>ActionScript 3.0 では、<codeph>new SimpleButton()</codeph> コンストラクターを使用して SimpleButton インスタンスを作成します。</p>
 
 <p>SimpleButton クラスは、InteractiveObject クラスから継承します。</p>
 
 </apiDesc><example conref="examples\SimpleButtonExample.as"> 次の例では、SimpleButtonExample クラスを使用します。これは、CustomSimpleButton クラスを使用し、次にこのクラスは 4 つの ButtonDisplayState オブジェクトをインスタンス化します。その結果として作成されるボタンは、形状が四角形で、背景色がマウスの状態に応じて変わります。これは、SimpleButton クラスのプロパティをオーバーライドすることによって行われます。ここでは以下の手順を実行します。
 <ol>
  <li><codeph>SimpleButtonExample()</codeph> コンストラクターで、SimpleButton タイプの新しい CustomSimpleButton オブジェクト（<codeph>button</codeph> と呼ばれる）が作成されます。これにより、<codeph>CustomSimpleButton</codeph> コンストラクターメソッドが呼び出されます。<codeph>button</codeph> オブジェクトが表示リストに追加されます。ボタンの色とサイズは、次の手順で決定されます。</li>
 
  <li>CustomSimpleButton クラスで、インスタンスのプロパティが宣言されます。これらは、後に <codeph>button</codeph> のサイズと背景色を制御するために使われます。その制御は、ボタンの状態に基づいて行われ、通常の状態ではオレンジ、マウスポインターが置かれた状態では暗い黄色、マウスボタンが押された状態では明るい青色になります。<codeph>button</codeph> がどの状態にあるときでも、四角形のサイズは、<codeph>size</codeph> プロパティを使用して 80 ピクセルに設定されます。</li>
 
  <li>CustomSimpleButton クラスのコンストラクター関数では、<codeph>downState</codeph>、<codeph>overState</codeph>、<codeph>upState</codeph>、<codeph>hitTestState</codeph>、および <codeph>useHandCursor</codeph> プロパティに ButtonDisplayState クラスの 4 つのインスタンスを設定します。</li>
 
  <li>ButtonDisplayState クラスのコンストラクターでは、四角形のサイズと背景色の値を設定し、<codeph>draw()</codeph> メソッドを呼び出します。</li>
 
  <li><codeph>draw()</codeph> メソッドは、ボタンの状態に基づき、コンストラクターで設定されたサイズと背景色で四角形を再描画します。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class SimpleButtonExample extends Sprite {
        public function SimpleButtonExample() {
            var button:CustomSimpleButton = new CustomSimpleButton();
            addChild(button);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.SimpleButton;

class CustomSimpleButton extends SimpleButton {
    private var upColor:uint   = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;
    private var size:uint      = 80;

    public function CustomSimpleButton() {
        downState      = new ButtonDisplayState(downColor, size);
        overState      = new ButtonDisplayState(overColor, size);
        upState        = new ButtonDisplayState(upColor, size);
        hitTestState   = new ButtonDisplayState(upColor, size * 2);
        hitTestState.x = -(size / 4);
        hitTestState.y = hitTestState.x;
        useHandCursor  = true;
    }
}

class ButtonDisplayState extends Shape {
    private var bgColor:uint;
    private var size:uint;

    public function ButtonDisplayState(bgColor:uint, size:uint) {
        this.bgColor = bgColor;
        this.size    = size;
        draw();
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject"><linktext>InteractiveObject クラス</linktext></link></related-links><apiConstructor id="flash.display:SimpleButton:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
	新しい SimpleButton インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>upState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton のアップ状態用の初期値です。
	</apiDesc></apiParam><apiParam><apiItemName>overState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton のオーバー状態用の初期値です。
	</apiDesc></apiParam><apiParam><apiItemName>downState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton のダウン状態用の初期値です。
	</apiDesc></apiParam><apiParam><apiItemName>hitTestState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton の hitTest 状態用の初期値です。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>新しい SimpleButton インスタンスを作成します。
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	新しい SimpleButton インスタンスを作成します。さまざまなボタンの状態を表す表示オブジェクトのいずれかまたはすべてを、コンストラクター内のパラメーターとして設定することができます。  
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:SimpleButton:downState:get"><apiName>downState</apiName><shortdesc>
	 ボタンの "ダウン" 状態用のビジュアルオブジェクトとして使用される表示オブジェクトを指定します。ダウン状態とは、ユーザーが hitTestState オブジェクトをクリックしたときのボタンの状態です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>ボタンの "ダウン" 状態用に使用する DisplayObject 値を指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 ボタンの "ダウン" 状態用のビジュアルオブジェクトとして使用される表示オブジェクトを指定します。ダウン状態とは、ユーザーが <codeph>hitTestState</codeph> オブジェクトをクリックしたときのボタンの状態です。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:enabled:get"><apiName>enabled</apiName><shortdesc>
	 ボタンが有効であるか無効であるかを指定するブール値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button.enabled, enabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>ボタンが有効（true）か無効（false）かを指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 ボタンが有効であるか無効であるかを指定するブール値です。ボタンが無効になっているとき（enabled プロパティが <codeph>false</codeph> に設定されているとき）、ボタンは表示されますが、クリックできません。デフォルト値は <codeph>true</codeph> です。このプロパティは、ナビゲーションの一部を無効にする場合に便利です。例えば、現在表示されているページのボタンを無効にしてクリックできないようにすることで、ページのリロードを禁止できます。
	 
	 <p><b>注意：</b>ボタンに対して mouseClick が発生しないようにするには、<codeph>enabled</codeph> プロパティと <codeph>mouseEnabled</codeph> プロパティの両方を <codeph>false</codeph> に設定します。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:hitTestState:get"><apiName>hitTestState</apiName><shortdesc>
	 ボタンのヒットテストオブジェクトとして使用する表示オブジェクトを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier></apiValueDef><apiDesc>
	 ボタンのヒットテストオブジェクトとして使用する表示オブジェクトを指定します。基本的なボタンでは、<codeph>hitTestState</codeph> プロパティを <codeph>overState</codeph> プロパティと同じ表示オブジェクトに設定します。<codeph>hitTestState</codeph> プロパティを設定しない場合、SimpleButton は非アクティブになります。つまり、マウスイベントやキーボードイベントに反応しません。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:overState:get"><apiName>overState</apiName><shortdesc>
	 ボタンのオーバー状態用のビジュアルオブジェクトとして使用される表示オブジェクトを指定します。オーバー状態とは、ボタンの上にマウスが置かれている状態のことです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>ボタンの "オーバー" 状態用に使用する DisplayObject 値を指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 ボタンのオーバー状態用のビジュアルオブジェクトとして使用される表示オブジェクトを指定します。オーバー状態とは、ボタンの上にマウスポインターが置かれている状態のことです。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 このボタンに割り当てられた SoundTransform オブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should information from AS2 setTransform be here? e.g. percentage values indicating
	 how much of the left input to play in the left speaker or right speaker; it is generally
	 best to use 22-KHZ 6-bit mono sounds?
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 このボタンに割り当てられた SoundTransform オブジェクトです。SoundTransform オブジェクトには、ボリューム、パン、左スピーカーの割り当て、および右スピーカーの割り当てを設定するプロパティが含まれます。この SoundTransform オブジェクトはボタンのすべての状態に適用されます。この SoundTransform オブジェクトは埋め込みサウンドのみに影響します。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 SimpleButton または MovieClip オブジェクトである他の表示オブジェクトがマウス解放イベントを受け取ることができるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 SimpleButton または MovieClip オブジェクトである他の表示オブジェクトがマウス解放イベントを受け取ることができるかどうかを示します。<codeph>trackAsMenu</codeph> プロパティを使用してメニューを作成できます。<codeph>trackAsMenu</codeph> プロパティは、任意の SimpleButton または MovieClip オブジェクトに対して設定できます。<codeph>trackAsMenu</codeph> プロパティがない場合、デフォルトの動作は <codeph>false</codeph> です。 
	 
	 <p><codeph>trackAsMenu</codeph> プロパティは必要に応じていつでも変更できます。ボタンに対する変更は即座に反映されます。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:upState:get"><apiName>upState</apiName><shortdesc>
	 ボタンのアップ状態用のビジュアルオブジェクトとして使用される表示オブジェクトを指定します。アップ状態とは、ボタンの上にマウスが置かれていない状態のことです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>ボタンの "アップ" 状態用に使用する DisplayObject 値を指定します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 ボタンのアップ状態用のビジュアルオブジェクトとして使用される表示オブジェクトを指定します。アップ状態とは、ボタンの上にマウスポインターが置かれていない状態のことです。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
     マウスがボタン上に移動したときに、ハンドカーソルを表示するかどうかを示すブール値です。true に設定されると、ハンドカーソルを表示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create two buttons on the Stage with the instance names <code>myBtn1_btn</code> and <code>myBtn2_btn</code>. Enter the following ActionScript in Frame 1 of the Timeline:
	 <listing>
	 myBtn1_btn.useHandCursor = false;
	 myBtn1_btn.onRelease = buttonClick;
	 myBtn2_btn.onRelease = buttonClick;
	 function buttonClick() {
	   trace(this._name);
	 }
	 </listing>
	 <p>When the mouse is over and clicks <code>myBtn1_btn</code>, there is no pointing hand. However, you see the pointing hand when the button is over and clicks <code>myBtn2_btn</code>.</p>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>true に設定すると、指差しハンドカーソルを表示します。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     マウスがボタン上に移動したときに、ハンドカーソルを表示するかどうかを示すブール値です。<codeph>true</codeph> に設定されると、ハンドカーソルを表示します。 このプロパティを <codeph>false</codeph> に設定すると、代わりに矢印カーソルが表示されます。デフォルト値は <codeph>true</codeph> です。
	 
	 <p><codeph>useHandCursor</codeph> プロパティは必要に応じていつでも変更できます。変更されたボタンでは新しいカーソルの動作が即座に使用されます。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:TriangleCulling"><apiName>TriangleCulling</apiName><shortdesc>
 三角形のパスを描画するときに、レンダリングしない三角形を決めるカリングアルゴリズムのコードを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 三角形のパスを描画するときに、レンダリングしない三角形を決めるカリングアルゴリズムのコードを定義します。
 
 <p>
 <codeph>POSITIVE</codeph> と <codeph>NEGATIVE</codeph> は、三角形の z 軸法線の符号を示します。法線は、三角形の表面に対して垂直の 3D ベクターです。
 </p>
 
 <p>
 三角形の頂点 0、1、2 が時計回りに並んでいる三角形の法線は、正の値になります。つまり、法線が現在のビューポイントから離れた正の z 軸方向を指します。<codeph>TriangleCulling.POSITIVE</codeph> アルゴリズムを使用すると、正の法線を持つ三角形はレンダリングされません。これをバックフェースカリングと呼ぶこともあります。
 </p>
 
 <p>
 三角形の頂点が反時計回りに並んでいる場合は、法線が負の値になります。つまり、法線が現在のビューポイントに向かう負の z 軸方向を指します。<codeph>TriangleCulling.NEGATIVE</codeph> アルゴリズムを使用すると、負の法線を持つ三角形はレンダリングされません。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTrianglePath()"><linktext>flash.display.Graphics.drawTrianglePath()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="http://www.gamedev.net/reference/articles/article1089.asp"><linktext>3D ベクターの紹介</linktext></link><link href="http://www.gamedev.net/reference/articles/article1088.asp"><linktext>3D バックフェースカリング</linktext></link></related-links><apiValue id="flash.display:TriangleCulling:NEGATIVE"><apiName>NEGATIVE</apiName><shortdesc>
     現在のビューポイント方向の内向きにある三角形すべてのカリングを指定します。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>negative</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     現在のビューポイント方向の内向きにある三角形すべてのカリングを指定します。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:NONE"><apiName>NONE</apiName><shortdesc>
     カリングなしを指定します。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     カリングなしを指定します。パス内の三角形はすべてレンダリングされます。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:POSITIVE"><apiName>POSITIVE</apiName><shortdesc>
     現在のビューポイントから外向きにある三角形すべてのカリングを指定します。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>positive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     現在のビューポイントから外向きにある三角形すべてのカリングを指定します。こちらも、バックフェースカリングと呼ぶことがあります。
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
 NativeWindow クラスは、ネイティブのデスクトップウィンドウを作成および制御するインターフェイスを提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 NativeWindow クラスは、ネイティブのデスクトップウィンドウを作成および制御するインターフェイスを提供します。
  
 <p platform="actionscript">NativeWindow インスタンスへの参照は、ウィンドウコンストラクターから返されます。NativeWindow インスタンスへの参照には、そのウィンドウのステージにある任意の表示オブジェクトの <codeph>stage.nativeWindow</codeph> プロパティを使用してアクセスすることもできます。
 </p>
 
 <pre platform="actionscript">var window:NativeWindow = displayObject.stage.nativeWindow;</pre>
 
 <p platform="javascript">NativeWindow インスタンスへの参照は、ウィンドウコンストラクターから返されます。<codeph>window.nativeWindow</codeph> プロパティを使用することで、HTML ページの JavaScript から NativeWindow インスタンスを参照することができます。
 </p>
 
 <p>NativeWindow インスタンスのプロパティには、アプリケーションコンテンツからのみアクセスできます。アプリケーションコンテンツ以外が NativeWindow オブジェクトにアクセスしようとすると、セキュリティエラーがスローされます。</p>
 
 <p>コンテンツは、Stage オブジェクトの DisplayObjectContainer メソッド（<codeph>addChild()</codeph> など）を使用してウィンドウに追加できます。</p>
 
 <p platform="actionscript">Flex コンポーネントを、NativeWindow インスタンスの表示リストに直接追加することはできません。この場合、Flex mx:WindowedApplication コンポーネントおよび mx:Window コンポーネントを使用してウィンドウを作成し、これらのオブジェクトに他の Flex コンポーネントを子として追加します。Flex ベースの SWF が、その SWF のアプリケーションドメインにロードされていて、アプリケーションコンテンツである場合は、この SWF を NativeWindow ウィンドウに直接追加することができます。
 </p>
 
 <p>HTML コンテンツを表示するルート HTML ウィンドウを作成するには、通常は <codeph>HTMLLoader.createRootWindow()</codeph> を使用したほうが簡単です。この方法で作成されたウィンドウには、HTMLLoader オブジェクトが自動的に追加されます（JavaScript コードでは、JavaScript <codeph>window.open()</codeph> 関数も使用できます。ただし、この方法では、ウィンドウの外観と動作を制御することが難しくなります)。</p>
 
 <p>
 NativeWindow オブジェクトに対する <codeph>close()</codeph>、<codeph>maximize()</codeph>、<codeph>minimize()</codeph>、<codeph>restore()</codeph>、および <codeph>bounds</codeph> の変更などの操作は非同期的です。アプリケーションは、これらの操作が完了すると、該当するイベントを受け取って検出することができます。
 </p>
 
 <p>
 <codeph>NativeApplication.autoExit</codeph> プロパティが <codeph>true</codeph> の場合（デフォルト）、最後のウィンドウが閉じられると（すべての <codeph>close</codeph> イベントハンドラーがイベントを返すと）、そのアプリケーションは終了します。<codeph>autoExit</codeph> が <codeph>false</codeph> の場合は、<codeph>NativeApplication.nativeApplication.exit()</codeph> を呼び出してアプリケーションを終了する必要があります。
 </p>
 <p>
 ウィンドウコンストラクターが呼び出され、まだ <codeph>close()</codeph> が呼び出されていない場合、NativeWindow オブジェクトはガベージコレクションされません。 アプリケーションのウィンドウを閉じるのは、そのアプリケーション自体が受け持つことになります。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/nativeWindow"><linktext>flash.display.Stage.nativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="flash.desktop.xml#NativeApplication"><linktext>flash.desktop.NativeApplication</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
 ウィンドウが非アクティブになると、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウが非アクティブになると、この NativeWindow オブジェクトから送出されます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
 ウィンドウがアクティブになると、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウがアクティブになると、この NativeWindow オブジェクトから送出されます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 ウィンドウが閉じられると、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウが閉じられると、この NativeWindow オブジェクトから送出されます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSING_closing"><apiName>closing</apiName><shortdesc>
 ウィンドウが閉じられる直前に、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウが閉じられる直前に、この NativeWindow オブジェクトから送出されます。このイベントは、ウィンドウが閉じられないようにキャンセルできます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE_displayStateChange"><apiName>displayStateChange</apiName><shortdesc>
 ウィンドウの displayState プロパティが変化すると、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウの <codeph>displayState</codeph> プロパティが変化すると、この NativeWindow オブジェクトから送出されます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING_displayStateChanging"><apiName>displayStateChanging</apiName><shortdesc>
 ウィンドウがその表示状態を変更する直前に、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウがその表示状態を変更する直前に、この NativeWindow オブジェクトから送出されます。このイベントは、変更されないようにキャンセルすることができます。
 
 </apiDesc><example conref="examples\NativeWindow.displayStateChanging.1.as"> 次の例では、<codeph>displayStateChanging</codeph> イベントをキャンセルする方法を示します。
<codeblock>
function displayStateChanging_handler(displayStateEvent:NativeWindowDisplayStateEvent):void
{
  //shouldStopStateChange is an application-defined Boolean indicating 
  //that display state changes should be canceled
  if (displayStateEvent.type == NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING 
                                  &amp;&amp;    shouldStopStateChange)
  {
    displayStateEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 ウィンドウのサイズが変更されると、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ウィンドウのサイズが変更されると、この NativeWindow オブジェクトから送出されます。ウィンドウのサイズが変更されると、常に <codeph>resize</codeph> イベントが送出されます。ウィンドウのサイズ（<codeph>width</codeph> プロパティまたは <codeph>height</codeph> プロパティ）変更は、システムによって制御されたウィンドウサイズの変更の場合、最小化、最大化またはウィンドウのサイズを元に戻した場合、<codeph>width</codeph>、<codeph>height</codeph> または <codeph>bounds</codeph> の各プロパティを設定して変更した場合に行われます。NativeWindow の <codeph>resize</codeph> イベントは、システム制御のサイズ変更ループの場合に送出されます。一方、Stage オブジェクトの <codeph>resize</codeph> イベントは、ステージの描画の準備が整っている場合に送出されます。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Stage/resize"><linktext>flash.display.Stage.resize</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZING_resizing"><apiName>resizing</apiName><shortdesc>
 デスクトップ上でウィンドウのサイズが変更される直前に、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 デスクトップ上でウィンドウのサイズが変更される直前に、この NativeWindow オブジェクトから送出されます。このイベントは、サイズ変更を中止または変更するためにキャンセルすることができます。
 
 </apiDesc><example conref="examples\NativeWindow.resizing.1.as"> 次の例では、<codeph>resizing</codeph> イベントをキャンセルする方法を示します。
<codeblock>
function boundsChanging_handler(boundsEvent:NativeWindowBoundsEvent):void
{
  //shouldStopResize is an application-defined Boolean indicating 
  //that resize operations should be canceled
  if (boundsEvent.type == NativeWindowBoundsEvent.RESIZING &amp;&amp; shouldStopResize)
  {
    boundsEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVE_move"><apiName>move</apiName><shortdesc>
 デスクトップ上でウィンドウが移動されると、この NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 デスクトップ上でウィンドウが移動されると、この NativeWindow オブジェクトから送出されます。
 <p>
 ウィンドウの原点が変更されると、常に <codeph>move</codeph> イベントが送出されます。ウィンドウの原点（<codeph>x</codeph> プロパティまたは <codeph>y</codeph> プロパティ）の移動は、システムによって制御されたウィンドウの移動の場合、最小化、最大化またはウィンドウのサイズを元に戻した場合、または <codeph>x</codeph>、<codeph>y</codeph> または <codeph>bounds</codeph> の各プロパティを設定して移動した場合に行われます。
 </p>
 <p><b>注意：</b> NativeWindow オブジェクトの <codeph>moving</codeph> イベントと <codeph>move</codeph> イベントの両方に対するハンドラー関数でオペレーティングシステムのダイアログボックスを同時に開くようなアクションは避けてください。これは、例えば、両方のハンドラー関数がエラーをスローする場合などに発生します。そのようなアクションが発生した場合、2 番目に開かれるダイアログボックスにはマウスのクリックが登録されないので、キーボードを使って閉じることが必要になります。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVING_moving"><apiName>moving</apiName><shortdesc>
 デスクトップ上でウィンドウが移動される直前に、NativeWindow オブジェクトから送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 デスクトップ上でウィンドウが移動される直前に、NativeWindow オブジェクトから送出されます。このイベントは、移動を中止または変更するためにキャンセルできます。
 
 <p><b>注意：</b> NativeWindow オブジェクトの <codeph>moving</codeph> イベントと <codeph>move</codeph> イベントの両方に対するハンドラー関数でオペレーティングシステムのダイアログボックスを同時に開くようなアクションは避けてください。これは、例えば、両方のハンドラー関数がエラーをスローする場合などに発生します。そのようなアクションが発生した場合、2 番目に開かれるダイアログボックスにはマウスのクリックが登録されないので、キーボードを使って閉じることが必要になります。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeWindow:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
    NativeWindow インスタンスと、対応するオペレーティングシステムウィンドウを新たに作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc><codeph>initOptions</codeph> パラメーターが有効でない場合。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiParam><apiItemName>initOptions</apiItemName><apiOperationClassifier>flash.display:NativeWindowInitOptions</apiOperationClassifier><apiDesc>このウィンドウの初期化プロパティを格納するオブジェクトです。
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    NativeWindow インスタンスと、対応するオペレーティングシステムウィンドウを新たに作成します。
    <p>
    ウィンドウの作成後は、<codeph>initOptions</codeph> パラメーターで定義されている設定を変更することはできません。<codeph>initOptions</codeph> 設定が無効な場合、無効な操作を示すエラーがスローされます。現在のシステムで使用できなくても、設定が有効な場合は、例外はスローされません。現在のオペレーティングシステムに固有の機能は、必要に応じて、静的な NativeWindow メンバー（<codeph>systemMaxSize</codeph> など）を使用することで検出できます。
    </p>
    
    <p>デフォルトのウィンドウサイズはオペレーティングシステムによって決定されますが、ウィンドウの境界を設定することで変更できます。ウィンドウの <codeph>visible</codeph> プロパティが <codeph>false</codeph> の場合、変更を加えても表示されません。</p>
    
    </apiDesc><example conref="examples\NativeWindow.constructor.1.as"> 次の例では、NativeWindow インスタンスを新たに作成し、アクティブ化します。
<codeblock>
import flash.display.NativeWindowInitOptions;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowType;
import flash.display.NativeWindow;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.geom.Rectangle;

var windowOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
windowOptions.systemChrome = NativeWindowSystemChrome.STANDARD;
windowOptions.type = NativeWindowType.NORMAL;

var newWindow:NativeWindow = new NativeWindow(windowOptions);
newWindow.stage.scaleMode = StageScaleMode.NO_SCALE;
newWindow.stage.align = StageAlign.TOP_LEFT;
newWindow.bounds = new Rectangle(100, 100, 800, 800);

newWindow.activate();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeWindow:activate"><apiName>activate</apiName><shortdesc>
	 このウィンドウをアクティブ化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 このウィンドウをアクティブ化します。 
	 
	 <p>ウィンドウをアクティブ化すると、次のようになります。</p>
	 <ul> 
	 <li>ウィンドウが可視になります。</li>
	 <li>ウィンドウが前面に移動します。</li> 
	 <li>キーボードおよびマウスのフォーカスが、そのウィンドウに移動します。</li>
	 </ul>
	 
	 <p>Linux の場合、<codeph>activate()</codeph> は非同期的に実行される操作です。</p>
	 
	 <p>NativeWindow オブジェクトは、どのプラットフォームでも <codeph>activate</codeph> イベントを送出します。</p>
	 
	 </apiDesc><example conref="examples\NativeWindow.activate.1.as"> 次の例は、ウィンドウをアクティブにする方法を示しています。
  
 <p>ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。</p>
<codeblock>
displayObject.stage.nativeWindow.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.2.as"> NativeWindow クラスのインスタンスへの参照を使用する場合は、次のように処理します。
<codeblock>
windowObj.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.3.as"> ウィンドウにレンダリングされている HTML ページの JavaScript からは、次のように処理します（<codeph>window</codeph> は、グローバル JavaScript ウィンドウオブジェクト）。
<codeblock>
window.nativeWindow.activate();
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/visible"><linktext>visible</linktext></link><link href="flash.display.xml#NativeWindow/orderToFront"><linktext>orderToFront</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:close"><apiName>close</apiName><shortdesc>
      このウィンドウを閉じます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      このウィンドウを閉じます。 
      
      <p>閉じる操作が完了すると、<codeph>close</codeph> イベントが直ちに送出されます。<codeph>closing</codeph> イベントは送出されません。閉じる操作のキャンセルを許可する場合は、<codeph>closing</codeph> イベントを送出し、登録されているリスナーがデフォルトの動作をキャンセルするかどうかを、<codeph>close()</codeph> メソッドを呼び出す前にチェックします。
      </p>
      <p>
      現在ウィンドウにある表示オブジェクトのインスタンスが他の場所で参照されていない場合は、AIR によって作成された最初のアプリケーションウィンドウを除き、ガベージコレクションされて破棄されます。最初のウィンドウにある表示オブジェクトがガベージコレクションされるようにするには、ウィンドウステージからそれらを削除します。
      </p>
      <p>
      閉じられた後でも NativeWindow オブジェクトは有効な参照として残りますが、プロパティやメソッドにアクセスすると、多くの場合は無効な操作を示すエラーがスローされます。
      </p>
      <p>
      閉じたウィンドウを再び開くことはできません。ウィンドウが既に閉じられている場合、アクションは実行されず、イベントも送出されません。
      </p>
      
      <p>注意：ウィンドウを閉じずに非表示にするには、ウィンドウの <codeph>visible</codeph> プロパティを <codeph>false</codeph> に設定します。
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.close.1.as"> 次の例は、ウィンドウを閉じる方法を示しています。
  
 <p>NativeWindow インスタンス（<codeph>windowObj</codeph>）への参照を使用した場合は、次のようになります。</p>
<codeblock>
windowObj.close();

</codeblock></example><example conref="examples\NativeWindow.close.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObj.stage.nativeWindow.close();
</codeblock></example><example conref="examples\NativeWindow.close.3.as"> HTMLLoader オブジェクト（または HTML ルートウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.close(); //overriddable in HTMLHost
</codeblock></example><example conref="examples\NativeWindow.close.4.as"> または：
<codeblock>
window.nativeWindow.close(); //not overriddable
</codeblock></example><example conref="examples\NativeWindow.close.5.as">  
 次の例は、閉じる操作のキャンセルを許可する方法を示したものです（<codeph>windowObj</codeph> が、閉じる NativeWindow インスタンスです）。
<codeblock>
public function closeCommand():Boolean{
    var closeEvent:Event = new Event(Event.CLOSING,true,true);
    windowObj.dispatchEvent(closeEvent);
    if(!closeEvent.isDefaultPrevented()){
        windowObj.close();
        return true;
    } else {
      return false;
    }
}
</codeblock></example><example conref="examples\NativeWindow.close.6.as"> 次の例は、操作のキャンセルを許可しながら、HTMLLoader オブジェクト（または HTML ルートウィンドウ）で実行している JavaScript ルーチンからウィンドウを閉じる方法を示したものです。
<codeblock>
&lt;script src="AIRAliases.js" type="text/javascript">&lt;/script>
&lt;script type="text/javascript">
    var dirtyData = false;
    function closeWindow(){
            var closingEvent = new air.Event(air.Event.CLOSING,true,true);
            window.nativeWindow.dispatchEvent(closingEvent);
               if(!closingEvent.isDefaultPrevented()){
                   window.nativeWindow.close();
                //or use: window.close(); 
               return true;
           } else {
               return false;
        }
    }
        
    function onClosing(event){
        if(dirtyData){
            event.preventDefault();
            //Save data...
        }
    }    

    window.nativeWindow.addEventListener(air.Event.CLOSING,onClosing);        
&lt;/script>
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/closed"><linktext>flash.display.NativeWindow.closed</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>flash.html.HTMLLoader</linktext></link><link href="../../flash/html/HTMLHost.html"><linktext>flash.html.HTMLHost</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:globalToScreen"><apiName>globalToScreen</apiName><shortdesc>
      ウィンドウステージの起点を基準としたピクセル単位の座標のポイント（表示リストから見たグローバルポイント）を、仮想デスクトップのポイントに変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>デスクトップを基準とした、指定されたグローバルポイントです。
      
      </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>globalPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>画面上のポイントに変換するステージ上のポイントです。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      ウィンドウステージの起点を基準としたピクセル単位の座標のポイント（表示リストから見たグローバルポイント）を、仮想デスクトップのポイントに変換します。
      
      <p>仮想デスクトップの座標は、主モニターの左上隅を基準としています。</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:maximize"><apiName>maximize</apiName><shortdesc>
      このウィンドウを最大化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>このウィンドウの <codeph>maximizable</codeph> プロパティが <codeph>false</codeph> の場合、またはこのウィンドウを閉じた後にメソッドが呼び出された場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      このウィンドウを最大化します。  
      <p>
      <codeph>maximize()</codeph> を呼び出すと、<codeph>displayStateChange</codeph> イベントが送出されます。また、該当する場合は、<codeph>move</codeph> イベントおよび <codeph>resize</codeph> イベントも送出されます。ユーザーが maximize コマンドを発行すると、システムクロムがキャンセル可能な <codeph>displayStateChanging</codeph> イベントを送出しますが、必要に応じて、この動作を最大化ロジックに実装する必要があります。
      </p>
      <p>
      <codeph>maximize()</codeph> メソッドは非同期に実行されます。状態変更の完了を検出するには、<codeph>displayStateChange</codeph> イベントを受け取ります。
      </p>
      <p>ウィンドウが既に最大化されている場合、アクションは実行されず、イベントも送出されません。</p>
      
      <p><b>注意：</b></p> 
      <ul>
      <li>Mac OS X などのオペレーティングシステムでは、ウィンドウを最大化してもサイズ変更は禁止されません。そのため、<codeph>maximize()</codeph> を呼び出すとウィンドウが画面いっぱいに拡大されますが、その後でウィンドウのサイズを変更することができます。拡大されたウィンドウのサイズを変更すると、表示状態も元に戻ります。</li>
      
      <li>Mac OS X などの一部のオペレーティングシステムおよび Linux の一部のウィンドウマネージャーでは、ウィンドウを最大化しても、<codeph>maxSize</codeph> プロパティで指定されている幅と高さより大きくは拡大しません。それ以外では、画面が <codeph>maxSize</codeph> よりも大きい場合でもウィンドウは画面いっぱいに拡大されます。</li>
      
      <li>Linux の一部のウィンドウマネージャーでは、ユーティリティウィンドウを最大化できません。</li>
      
      </ul>
      
      </apiDesc><example conref="examples\NativeWindow.maximize.1.as">  
 次の例は、最大化操作のキャンセルを許可する方法を示したものです。  
<codeblock>
public function maximizeWindow(nativeWin:NativeWindow):Boolean{
  if(nativeWin.displayState != NativeWindowDisplayState.MAXIMIZED){
    var beforeState:String = nativeWin.displayState;
    var afterState:String = NativeWindowDisplayState.MAXIMIZED;
    var displayStateEvent:NativeWindowDisplayStateEvent = 
        new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
    nativeWin.dispatchEvent(displayStateEvent);
    if(!displayStateEvent.isDefaultPrevented()){
        nativeWin.maximize();
        return true;
    } else {
      return false;
    }
  }
  return false;
}
</codeblock></example><example conref="examples\NativeWindow.maximize.2.as">  
 次の例は、ウィンドウ上の HTMLLoader オブジェクト（または HTML ウィンドウ）で実行される JavaScript ルーチンから最大化操作をキャンセルできるようにする方法を示したものです。  
<codeblock>
function maximizeWindow(nativeWin){
    if(nativeWin.displayState != air.NativeWindowDisplayState.MAXIMIZED){
        var beforeState = nativeWin.displayState;
        var afterState = air.NativeWindowDisplayState.MAXIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.maximize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:minimize"><apiName>minimize</apiName><shortdesc>
      このウィンドウを最小化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>このウィンドウの <codeph>minimizable</codeph> プロパティが <codeph>false</codeph> の場合、またはこのウィンドウを閉じた後にメソッドが呼び出された場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      このウィンドウを最小化します。 
      <p>
      <codeph>minimize()</codeph> を呼び出すと、displayStateChange イベントが送出されます。また、該当する場合は、move イベントおよび resize イベントも送出されます。<codeph/><codeph/><codeph/>ユーザーが minimize コマンドを発行すると、システムクロムがキャンセル可能な <codeph>displayStateChanging</codeph> イベントを送出するのに対し、<codeph>minimize()</codeph> を直接呼び出してもこのイベントは発行されません。必要に応じて、この動作を最小化ロジックに実装できます。
      </p>
      
      <p><codeph>minimize()</codeph> メソッドは非同期に実行されます。状態変更の完了を検出するには、<codeph>displayStateChange</codeph> イベントを監視します。ウィンドウが既に最小化されている場合、アクションは実行されず、イベントも送出されません。</p>
      
      <p>一部の Linux ウィンドウマネージャーでは、ユーティリティウィンドウを最小化できません。</p>
      
	  </apiDesc><example conref="examples\NativeWindow.minimize.1.as"> 次の例は、<codeph>minimize()</codeph> 呼び出しを、<codeph>displayStateChanging</codeph> イベントを送出することによってキャンセルできるようにする方法を示したものです。 
<codeblock>
public function minimizeWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.MINIMIZED){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.minimize.2.as"> 次の例は、<codeph>minimize()</codeph> 呼び出しを、HTMLLoader オブジェクト（または HTML ウィンドウ）で実行される JavaScript でキャンセルできるようにする方法を示したものです。 
<codeblock> 
function minimizeWindow(){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.MINIMIZED){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:notifyUser"><apiName>notifyUser</apiName><shortdesc>
      該当するイベントが発生したオペレーティングシステムを通して、視覚的なキューをトリガーします。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>通知の緊急性を表すストリングです。   
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      該当するイベントが発生したオペレーティングシステムを通して、視覚的なキューをトリガーします。
      
      <p><codeph>NativeWindow.supportsNotification</codeph> が <codeph>true</codeph> の場合、視覚的なキューは、ネイティブシステムのオペレーティングシステムの規則に従います。例えば、Windows では、タスクバーアイコンが点滅します。</p>
      
      <p>キューの強度は、<codeph>type</codeph> パラメーターによって決定されます。有効な値の定数は NotificationType クラスで定義されていて、次のようになる場合があります。</p>
      <ul>
      <li><codeph>NotificationType.INFORMATIONAL</codeph></li>
      <li><codeph>NotificationType.CRITICAL</codeph></li>
      </ul>
      <p>情報の通知を目的としたキューは、継続時間が短く設定されています。重要な通知のキューは、ユーザーがこのウィンドウをアクティブ化するまで継続します。一部の Linux ウィンドウマネージャーは、2 レベルの通知をサポートしていません。このようなウィンドウマネージャーでは、どのオプションを指定しても、<codeph>notifyUser()</codeph> は同じ動作をします。</p>
      
      <p><b>注意：</b><codeph>notifyUser()</codeph> の呼び出しは、<codeph>NativeWindow.supportsNotification</codeph> が <codeph>false</codeph> の場合でも可能です。ただし、何も実行されません。</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInBackOf"><apiName>orderInBackOf</apiName><shortdesc>
      このウィンドウを、指定されたウィンドウの背面に直接移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>このウィンドウが正常に背面に移動された場合は <codeph>true</codeph>、このウィンドウが不可視であるか最小化されている場合は <codeph>false</codeph> になります。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>アプリケーションウィンドウです。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      このウィンドウを、指定されたウィンドウの背面に直接移動します。
      
      <p>ウィンドウまたはアプリケーションをアクティブ化したり、フォーカスを取得したりしません。最小化または非表示（<codeph>visible</codeph> が <codeph>false</codeph>）にされているウィンドウの順序は変更できません。</p>
      
      <p>一部の Linux ウィンドウマネージャーでは、ユーティリティウィンドウを標準ウィンドウよりも後に順序付けすることはできません。</p>
      
      </apiDesc><example conref="NativeWindow.orderInBackOf.1.as"> 次の例は、NativeWindow インスタンスへの参照を使用して、ウィンドウを他のウィンドウの真下に移動する方法を示したものです。
<codeblock>
windowBehind.orderInBackOf(windowFront);
</codeblock></example><example conref="NativeWindow.orderInBackOf.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObjBehind.stage.nativeWindow.orderInBackOf(displayObjectFront.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInBackOf.3.as"> HTMLLoader オブジェクト（または HTML ルートウィンドウ）で実行している JavaScript ルーチンから、2 つの JavaScript ウィンドウオブジェクトへの参照を使用する場合は、次のように処理します。
<codeblock>
jsWindowObjBehind.nativeWindow.orderInBackOf(jsWindowObjFront.nativeWindow);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInFrontOf"><apiName>orderInFrontOf</apiName><shortdesc>
      このウィンドウを、指定されたウィンドウの前面に直接移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>このウィンドウが正常に前面に移動された場合は <codeph>true</codeph>、このウィンドウが不可視であるか最小化されている場合は <codeph>false</codeph> になります。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>アプリケーションウィンドウです。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      このウィンドウを、指定されたウィンドウの前面に直接移動します。
      
      <p>ウィンドウまたはアプリケーションをアクティブ化したり、フォーカスを取得したりしません。最小化または非表示（<codeph>visible</codeph> が <codeph>false</codeph>）にされているウィンドウの順序は変更できません。</p>
      
      <p>一部の Linux ウィンドウマネージャーでは、標準ウィンドウをユーティリティウィンドウよりも前に順序付けすることはできません。</p>
      
      </apiDesc><example conref="NativeWindow.orderInFrontOf.1.as"> 次の例は、NativeWindow インスタンスへの参照を使用して、ウィンドウを他のウィンドウの真上に移動する方法を示したものです。
<codeblock>
windowFront.orderInFrontOf(windowBehind);
</codeblock></example><example conref="NativeWindow.orderInFrontOf.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObjFront.stage.nativeWindow.orderInFrontOf(displayObjectBehind.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInFrontOf.3.as"> HTMLLoader オブジェクト（または HTML ルートウィンドウ）で実行している JavaScript ルーチンから、2 つの JavaScript ウィンドウオブジェクトへの参照を使用する場合は、次のように処理します。
<codeblock>
jsWindowObjFront.nativeWindow.orderInFrontOf(jsWindowObjBehind.nativeWindow);

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToBack"><apiName>orderToBack</apiName><shortdesc>
      このウィンドウを他のすべての可視ウィンドウの背面に移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>このウィンドウが正常に背面に移動された場合は <codeph>true</codeph>、このウィンドウが不可視であるか最小化されている場合は <codeph>false</codeph> になります。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      このウィンドウを他のすべての可視ウィンドウの背面に移動します。
      
      <p>このウィンドウまたはアプリケーションをアクティブ化したり、フォーカスを取得したりしません。最小化または非表示（<codeph>visible</codeph> が <codeph>false</codeph>）にされているウィンドウの順序は変更できません。</p>
      
      <p><codeph>alwaysInFront</codeph> が <codeph>true</codeph> の場合、このメソッドを呼び出しても、<codeph>alwaysInFront</codeph> が <codeph>false</codeph> に設定されているウィンドウの背面には移動しません。</p>
      
      <p>一部の Linux ウィンドウマネージャーでは、ユーティリティウィンドウを標準ウィンドウよりも後に順序付けすることはできません。</p>
      
      </apiDesc><example conref="NativeWindow.orderToBack.1.as"> 次の例は、アプリケーションの他のすべてのウィンドウ（同じ <codeph>alwaysInFront</codeph> 設定を持つもの）の背面にウィンドウを移動する方法を示したものです。
<codeblock>
windowObj.orderToBack();

</codeblock></example><example conref="NativeWindow.orderToBack.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObj.stage.nativeWindow.orderToBack();
</codeblock></example><example conref="NativeWindow.orderToBack.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.orderToBack();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToFront"><apiName>orderToFront</apiName><shortdesc>
      このウィンドウを他の可視ウィンドウの前面に移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>このウィンドウが正常に前面に移動された場合は <codeph>true</codeph>、このウィンドウが不可視であるか最小化されている場合は <codeph>false</codeph> になります。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      このウィンドウを他の可視ウィンドウの前面に移動します。 
      
      <p>このウィンドウまたはアプリケーションをアクティブ化したり、フォーカスを取得したりしません。最小化または非表示（<codeph>visible</codeph> が <codeph>false</codeph>）にされているウィンドウの順序は変更できません。</p>
       
      <p><codeph>alwaysInFront</codeph> が <codeph>false</codeph> の場合、このメソッドを呼び出しても、<codeph>alwaysInFront</codeph> が <codeph>true</codeph> に設定されているウィンドウの前面には移動しません。</p>
      
      <p>一部の Linux ウィンドウマネージャーでは、標準ウィンドウをユーティリティウィンドウよりも前に順序付けすることはできません。</p> 
      
      </apiDesc><example conref="NativeWindow.orderToFront.1.as"> 次の例は、アプリケーションの他のすべてのウィンドウ（同じ <codeph>alwaysInFront</codeph> 設定を持つもの）の前面にウィンドウを移動する方法を示したものです。
<codeblock>
windowObj.orderToFront();

</codeblock></example><example conref="NativeWindow.orderToFront.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObj.stage.nativeWindow.orderToFront();
</codeblock></example><example conref="NativeWindow.orderToFront.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.orderToFront();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:restore"><apiName>restore</apiName><shortdesc>
      最小化または最大化された状態から、このウィンドウを元の状態に戻します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>このウィンドウが閉じられた後に、メソッドが呼び出された場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      最小化または最大化された状態から、このウィンドウを元の状態に戻します。
      
      <p><codeph>restore()</codeph> を呼び出すと、<codeph>displayStateChange</codeph> イベントが送出されます。また、該当する場合は、<codeph>move</codeph> イベントおよび <codeph>resize</codeph> イベントも送出されます。ユーザーが restore コマンドを発行すると、システムクロムがキャンセル可能な <codeph>displayStateChanging</codeph> イベントを送出しますが、必要に応じて、この動作を元に戻すロジックに実装する必要があります。
      </p>
      
      <p>ウィンドウが既に <codeph>NativeWindowDisplayState.NORMAL</codeph> の状態の場合、アクションは実行されず、イベントも送出されません。</p>
      
      <p>
      状態変更の完了を検出するには、<codeph>displayStateChange</codeph> イベントを監視します。これは、どのプラットフォームでも送出されるイベントです。
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.restore.1.as">  
 次の例は、元に戻す操作のキャンセルを許可する方法を示したものです。 
<codeblock>
public function restoreWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.NORMAL){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.NORMAL;
        var displayStateChangingEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateChangingEvent);
        if(!displayStateChangingEvent.isDefaultPrevented()){
            nativeWin.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.restore.2.as"> 次の例は、ウィンドウ上の HTMLLoader オブジェクト（または HTML ウィンドウ）で実行される JavaScript ルーチンから元に戻す操作をキャンセルできるようにする方法を示したものです。 
<codeblock>
function restoreWindow(nativeWin){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.NORMAL){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.NORMAL;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:startMove"><apiName>startMove</apiName><shortdesc>
      このウィンドウのシステム制御による移動を開始します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>このウィンドウが閉じられた後に、メソッドが呼び出された場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>移動が正常に開始された場合は <codeph>true</codeph>、ウィンドウが最大化されている場合は <codeph>false</codeph> になります。
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      このウィンドウのシステム制御による移動を開始します。
      <p>
      <codeph>mouseDown</codeph> イベントから呼び出された場合、このメソッドはマウス操作による移動シーケンスを開始し、<codeph>mouseUp</codeph> イベントが発生するまで続行します。 
      </p>
      <p>
      その他のコードから呼び出された場合、このメソッドは、オペレーティングシステムのデフォルトのシーケンスに従い、キーボードまたはマウス操作による移動シーケンスを開始します。
      </p>
      
      <p>移動シーケンスの間、ウィンドウの起点が移動すると、一連のイベントが送出されます。各増分移動について、最初に <codeph>moving</codeph> イベントが送出され、<codeph>moving</codeph> イベントがキャンセルされなかった場合は、ウィンドウの位置が更新されて <codeph>move</codeph> イベントが送出されます。<codeph>moving</codeph> イベントがキャンセルされた場合、移動シーケンスは直ちに終了します。</p>
      
      </apiDesc><example conref="NativeWindow.startMove.1.as"> 次の例は、<codeph>mouseDown</codeph> イベントに応答してウィンドウを移動する方法を示したものです。
<codeblock>
var initOpts:NativeWindowInitOptions = new NativeWindowInitOptions();
var win:NativeWindow = new NativeWindow(initOpts);
win.activate();
win.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);

function mouseDownHandler(event:MouseEvent):void
{
    win.startMove();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:startResize"><apiName>startResize</apiName><shortdesc>
      このウィンドウのシステム制御によるサイズ変更操作を開始します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>このウィンドウが閉じられた後に、メソッドが呼び出された場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>サイズ変更が正常に開始された場合は <codeph>true</codeph>、ウィンドウが最大化されている場合は <codeph>false</codeph> になります。

      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>edgeOrCorner</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>このウィンドウのサイズ変更する端または隅を指定する、NativeWindowResize クラスの定数です。使用できる値は次のとおりです。
      
      <p>
      <adobetable class="innertable">
          
           
           
           
           
            
            
            
            
            
           
      <tgroup cols="3"><thead><row><entry>値</entry><entry>垂直方向の配置</entry><entry>水平方向の配置</entry></row></thead><tbody><row><entry><codeph>NativeWindowResize.TOP</codeph></entry>
           <entry>上揃え</entry>
           <entry>中央揃え</entry>
           </row><row><entry><codeph>NativeWindowResize.BOTTOM</codeph></entry>
           <entry>下揃え</entry>
           <entry>中央揃え</entry>
           </row><row><entry><codeph>NativeWindowResize.LEFT</codeph></entry>
           <entry>中央揃え</entry>
           <entry>左揃え</entry>
           </row><row><entry><codeph>NativeWindowResize.RIGHT</codeph></entry>
           <entry>中央揃え</entry>
           <entry>右揃え</entry>
           </row><row><entry><codeph>NativeWindowResize.TOP_LEFT</codeph></entry>
            <entry>上揃え</entry>
            <entry>左揃え</entry>
            </row><row><entry><codeph>NativeWindowResize.TOP_RIGHT</codeph></entry>
            <entry>上揃え</entry>
            <entry>右揃え</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_LEFT</codeph></entry>
            <entry>下揃え</entry>
            <entry>左揃え</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_RIGHT</codeph></entry>
            <entry>下揃え</entry>
            <entry>右揃え</entry>
            </row><row><entry><codeph>NativeWindowResize.NONE</codeph></entry>
            <entry>下揃え</entry>
            <entry>右揃え</entry>
            </row></tbody></tgroup></adobetable>
      </p>
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      このウィンドウのシステム制御によるサイズ変更操作を開始します。
      <p>
      <codeph>mouseDown</codeph> イベントハンドラーから呼び出された場合、このメソッドはマウス操作によるサイズ変更シーケンスを開始し、<codeph>mouseUp</codeph> イベントが発生するまで続行します。  
      </p>
      <p>
      その他のコードから呼び出された場合、このメソッドは、オペレーティングシステムのデフォルトのシーケンスに従い、キーボードまたはマウス操作によるサイズ変更シーケンスを開始します。
      </p>
      <p>サイズ変更シーケンスの間、ウィンドウのサイズが変化すると、一連のイベントが送出されます。各増分変化について、最初に <codeph>resizing</codeph> イベントが送出され、<codeph>resizing</codeph> イベントがキャンセルされなかった場合は、ウィンドウのサイズが更新されて <codeph>resize</codeph> イベントが送出されます。<codeph>resizing</codeph> イベントがキャンセルされた場合、サイズ変更シーケンスは直ちに終了します。</p>
      
      </apiDesc><example conref="NativeWindow.startResize.1.as"> 次の例は、<codeph>mouseDown</codeph> イベントに応答してウィンドウを移動する方法を示したものです。
<codeblock>
stage.addEventListener(MouseEvent.MOUSE_DOWN, onResizeCommand);

function onResizeCommand(event:MouseEvent):void
{
    var win:NativeWindow = event.target.nativeWindow;
    var resizeFrom:String = "";
    if (event.stageY &lt; win.height * .33)
    {
        resizeFrom = NativeWindowResize.TOP;
    }
    else if (event.stageY > win.height * .66)
    {
        resizeFrom = NativeWindowResize.BOTTOM;
    }
    if (event.stageX &lt; win.width * .33)
    {
        resizeFrom += NativeWindowResize.LEFT;
    }
    else if (event.stageX > win.width * .66)
    {
        resizeFrom += NativeWindowResize.RIGHT;
    }
    win.startResize(resizeFrom);    
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeWindow:active:get"><apiName>active</apiName><shortdesc>
      このウィンドウが、アクティブなアプリケーションウィンドウかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      このウィンドウが、アクティブなアプリケーションウィンドウかどうかを示します。
      
      <p><codeph>activate()</codeph> メソッドを使ってウィンドウをアクティブにします。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate"><linktext>flash.display.NativeWindow.activate</linktext></link><link href="flash.desktop.xml#NativeApplication/activate"><linktext>flash.desktop.NativeApplication.activate</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:alwaysInFront:get"><apiName>alwaysInFront</apiName><shortdesc>
      このウィンドウを、常に他のウィンドウ（他のアプリケーションのウィンドウも含む）よりも前面に表示するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      このウィンドウを、常に他のウィンドウ（他のアプリケーションのウィンドウも含む）よりも前面に表示するかどうかを指定します。
      
      <p>システムでウィンドウが重なる順序において、各ウィンドウは 2 つのグループに分けられます。<codeph>alwaysInFront</codeph> に設定されているウィンドウのグループは、常に他のウィンドウよりも前面に表示されます。同じグループ内での重なりの順序は、通常の規則に従います。つまり、あるウィンドウをアクティブ化すると、そのウィンドウは同じグループの他のウィンドウよりも前面に表示されます。</p>
      
      <p><codeph>alwaysInFront</codeph> を <codeph>false</codeph> から <codeph>true</codeph> に変更すると、そのウィンドウは最前面に表示されます。このプロパティを <codeph>true</codeph> から <codeph>false</codeph> に変更すると、そのウィンドウは「alwaysInFront」ウィンドウの背面に表示されます。ただし、同じグループの他のウィンドウよりも前面に表示されたままになります。プロパティを現在の値に設定しても、ウィンドウの重なりの順序は変更されません。</p>
      
      <p><codeph>alwaysInFront</codeph> プロパティが <codeph>true</codeph> に設定されているウィンドウは、他のアプリケーションのウィンドウがアクティブの場合でも、そのウィンドウより前面に表示されるので、このプロパティは慎重に設定する必要があります。</p>
      
      <p>Linux の一部のウィンドウマネージャーでは、ユーティリティウィンドウは常に通常ウィンドウの前面に表示されます。</p>
      
      <p><b>注意：</b>Mac<sup>®</sup> OS X では、<codeph>alwaysInFront</codeph> を <codeph>true</codeph> に設定しても、ウィンドウステージの <codeph>displayState</codeph> プロパティが <codeph>fullScreen</codeph> または <codeph>fullScreenInteractive</codeph> に設定されていると、効果がありません。Linux では、<codeph>alwaysInFront</codeph> が <codeph>true</codeph> に設定されたフルスクリーンウィンドウは、<codeph>alwaysInFront</codeph> が <codeph>true</codeph> に設定された他のウィンドウの前面に常に表示されます。</p> 
      
      </apiDesc><example conref="NativeWindow.alwaysInFront.1.as"> 次の例では、ウィンドウを強制的に他のウィンドウ（同様に強制的に前面に表示されていないウィンドウ）の前面に表示します。
<codeblock>
windowObj.alwaysInFront = true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObject.stage.nativeWindow.alwaysInFront=true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.alwaysInFront = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:bounds:set"><apiName>bounds</apiName><shortdesc>
      このウィンドウのサイズと位置です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>rectangle が null または無効な値を含んでいる場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、bounds プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      このウィンドウのサイズと位置です。  
      <p>
      ウィンドウのサイズには、システムクロムが含まれます。ウィンドウのステージのサイズは、ウィンドウのサイズからシステムクロムのサイズを引いたものに等しくなります。ウィンドウの幅と高さを変更すると、ステージの<codeph>stageWidth</codeph> および <codeph>stageHeight</codeph> が変更されます。その逆も同様で、ステージのサイズを変更すると、ウィンドウのサイズが変更されます。
      </p>
      <p>ルート HTML ウィンドウでは、<codeph>outerWidth</codeph> プロパティおよび <codeph>outerHeigth</codeph> プロパティは、ウィンドウの <codeph>height</codeph> プロパティおよび <codeph>width</codeph> プロパティに等しくなります。<codeph>innerWidth</codeph> プロパティおよび <codeph>innerHeight</codeph> プロパティは、<codeph>stage.stageWidth</codeph> プロパティおよび <codeph>stage.stageHeight</codeph> プロパティから、ウィンドウに表示されている自動スクロールバーの幅および高さを引いた値に等しくなります。</p>
      <p>
      <codeph>resize</codeph> イベントは、このウィンドウの幅または高さが変更されると常に送出されます。同様に、このウィンドウの起点（x,y）が変更されると、常に <codeph>move</codeph> イベントが送出されます。Mac OS および Windows では、<codeph>bounds</codeph> プロパティを直接に設定した場合 <codeph>moving</codeph> イベントや <codeph>resizing</codeph> イベントは送出されません。それに対し、Linux では、NativeWindow<i> </i>から <codeph>moving</codeph> イベントや <codeph>resizing</codeph> イベントが、<codeph>bounds</codeph> プロパティを直接に設定した場合でも送出されます。 
      </p>
      <p>
      ウィンドウの <codeph>bounds</codeph> プロパティを設定することは、ウィンドウの <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> および <codeph>height</codeph> プロパティを設定することと同じです。同様に、個々の寸法のいずれかを設定することは、<codeph>bounds</codeph> プロパティを設定することと同じです。<codeph>bounds</codeph> プロパティを使用してすべてのサイズを同時に設定すると、送信されるイベントの数が少なくなります。 
      </p>
      <p>個々のサイズが設定される順序は保証されません。デスクトップ領域より大きくウィンドウを拡大できない Linux ウィンドウマネージャーでは、すべてのプロパティ変更を適用した最終的な結果が正規のウィンドウになる場合であっても、個別のプロパティに対する変更がブロックされる場合があります。</p>
      
      <p>指定された幅または高さが、許容される幅または高さの下限よりも小さい場合や上限よりも大きい場合、許容される最も近い値にウィンドウの幅または高さが設定されます。幅と高さの下限および上限は、次の要因に基づいて決定されます。</p>
      
      <ul>
      
      	<li>NativeWindow オブジェクトの <codeph>minSize</codeph> および <codeph>maxSize</codeph> プロパティ。</li>
      	<li>オペレーティングシステムの制限による上限と下限。これは、<codeph>NativeWindow.systemMinSize</codeph> と <codeph>NativeWindow.systemMaxSize</codeph> の値です。</li>
      	<li>Adobe AIR におけるウィンドウ幅および高さの上限（2880 ピクセル）。</li>
      	<li>表示されているシステムクロムに必要な幅と高さの最小値</li>
      
      </ul>
      
	  </apiDesc><example conref="examples\NativeWindow.bounds.1.as"> 次の例では、NativeWindow オブジェクトへの参照を含むウィンドウの境界を設定します。
<codeblock>
windowObj.bounds = new Rectangle(200, 200, 1000, 800);
</codeblock></example><example conref="examples\NativeWindow.bounds.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObject.stage.nativeWindow.bounds = new Rectangle(20, 20, 800, 600);
</codeblock></example><example conref="examples\NativeWindow.bounds.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.bounds = new air.Rectangle(20, 20, 800, 600);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:closed:get"><apiName>closed</apiName><shortdesc>
      このウィンドウが閉じられたかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      このウィンドウが閉じられたかどうかを示します。  
      
      <p>閉じられたウィンドウで次のプロパティにアクセスすると、無効な操作を示すエラーがスローされます。</p>
      <ul> 
      <li><codeph>title</codeph></li>
      <li><codeph>bounds</codeph></li>
      <li><codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph>、<codeph>height</codeph></li>
      <li><codeph>displayState</codeph></li>
      <li><codeph>visible</codeph></li>
      </ul>
      <p>同様に、閉じられたウィンドウで次のメソッドを呼び出すと、無効な操作を示すエラーがスローされます。</p>
      <ul>
      <li><codeph>minimize()</codeph></li>
      <li><codeph>maximize()</codeph></li>
      <li><codeph>restore()</codeph></li>
      <li><codeph>startResize()</codeph></li>
      <li><codeph>startMove()</codeph></li>
      </ul>
      
      </apiDesc><example conref="NativeWindow.closed.1.as"> 次の例は、ウィンドウの <codeph>closed</codeph> プロパティにアクセスする方法を示したものです。
<codeblock>
var isWindowClosed:Boolean = windowObj.closed;
</codeblock></example><example conref="NativeWindow.closed.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
var isWindowClosed:Boolean = displayObject.stage.nativeWindow.closed;
</codeblock></example><example conref="NativeWindow.closed.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
var isWindowClosed = window.nativeWindow.closed;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:displayState:get"><apiName>displayState</apiName><shortdesc>
     このウィンドウの表示状態です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>このウィンドウが閉じられた後に、<codeph>displayState</codeph> プロパティがアクセスされた場合。
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     このウィンドウの表示状態です。
     <p>
     有効な値の定数は、NativeWindowDisplayState クラスで定義されています。 
     </p>
     <ul>
     <li><codeph>NativeWindowDisplayState.NORMAL</codeph></li>
     <li><codeph>NativeWindowDisplayState.MINIMIZED</codeph></li>
     <li><codeph>NativeWindowDisplayState.MAXIMIZED</codeph></li>
     </ul> 
     
     </apiDesc><example conref="examples\NativeWindow.displayState.1.as"> 次の例は、ウィンドウオブジェクトへの参照を指定して、現在のウィンドウの表示状態を取得する方法を示したものです。
<codeblock>
var state:String = windowObj.displayState;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:height:get"><apiName>height</apiName><shortdesc>
      このウィンドウの高さ（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>値セットが <codeph>null</codeph> または無効な値の場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      このウィンドウの高さ（ピクセル単位）です。
      
      <p>ウィンドウのサイズには、表示されているシステムウィンドウのクロムが含まれます。ウィンドウ内側の使用可能な表示領域の高さは、<codeph>Stage.stageHeight</codeph> プロパティから取得できます。</p>
      
      <p>ウィンドウの <codeph>height</codeph> プロパティを変更すると、<codeph>bounds</codeph> プロパティから高さを変更した場合と同じ動作をします。</p>
      
      <p>指定された高さが、許容される高さの下限よりも小さい場合や上限よりも大きい場合、許容される最も近い値にウィンドウの高さが設定されます。高さの下限および上限は、次の要因に基づいて決定されます。</p>
      
      <ul>
      
      	<li>NativeWindow オブジェクトの <codeph>minSize.x</codeph> および <codeph>maxSize.x</codeph> プロパティ</li>
      	<li>オペレーティングシステムの制限による上限と下限。これは、<codeph>NativeWindow.systemMinSize.x</codeph> と <codeph>NativeWindow.systemMaxSize.x</codeph> の値です。</li>
      	<li>Adobe AIR におけるウィンドウ高さの上限（2880 ピクセル）。</li>
      
      </ul>
      
      <p>Linux の場合、<codeph>height</codeph> プロパティを設定する操作は非同期的に実行されます。</p>
     
      <p>
      高さ変更の完了を検出するには、<codeph>resize</codeph> イベントを監視します。これは、どのプラットフォームでも送出されるイベントです。
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageHeight"><linktext>flash.display.Stage.stageHeight</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maxSize:get"><apiName>maxSize</apiName><shortdesc>
      このウィンドウの最大サイズです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>割り当てられているサイズが、オペレーティングシステムの最小および最大ウィンドウサイズの範囲外の場合。 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>サイズが、そのコンテンツの現在の特権で禁止されている場合。
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>サイズが <codeph>null</codeph> または無効な値を含んでいる場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、<codeph>maxSize</codeph> プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      このウィンドウの最大サイズです。  
      
      <p>サイズ制限は、Point オブジェクトの座標として指定されます。ポイントの <codeph>x</codeph> プロパティはウィンドウの幅に相当し、<codeph>y</codeph> プロパティはウィンドウの高さに相当します。</p>
      
      <p>
      <codeph>maxSize</codeph> の制限は、<ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> コードとオペレーティングシステムの両方で呼び出されるウィンドウサイズの変更操作に対して強制的に設定されます。
      </p>
      <p>
      現在の境界が新しい最大サイズよりも大きい場合、<codeph>maxSize</codeph> を設定すると、ウィンドウの境界が変化します。
      </p>
      
      <p>指定された幅または高さが、許容される幅または高さの上限よりも大きい場合、値は許容される最も近い値に設定されます。幅および高さの上限は、次の要因に基づいて決まります。</p>
      
      <ul>
      
      	<li>オペレーティング システムによる上限。これは、<codeph>NativeWindow.systemMaxSize</codeph> の値です。</li>
      	<li>Adobe AIR におけるウィンドウ幅および高さの上限（各 2880 ピクセル）。</li>
      
      </ul>
      
      <p>
      <b>注意：</b>Mac OS X などの一部のオペレーティングシステムでは、ウィンドウを <codeph>maxSize</codeph> 値まで拡大しても、最大化したウィンドウはオペレーティングシステムの画面より小さくなります。このような場合でも、ウィンドウは最大化された表示状態となります。
      </p>
      
      </apiDesc><example conref="NativeWindow.maxSize.1.as"> 次の例は、ウィンドウの許容最大サイズを設定する方法を示したものです。
<codeblock>
windowObj.maxSize = new Point(1040,920);
</codeblock></example><example conref="NativeWindow.maxSize.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObject.stage.nativeWindow.maxSize = new Point(800,600);
</codeblock></example><example conref="NativeWindow.maxSize.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.maxSize = new air.Point(960,960);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maximizable:get"><apiName>maximizable</apiName><shortdesc>
	 このウィンドウの作成に使用される最大化可能設定を報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 このウィンドウの作成に使用される <codeph>maximizable</codeph> 設定を報告します。
	  
	 <p>ウィンドウが作成された後で、<codeph>maximizable</codeph> 設定を変更することはできません。</p>
	 
	 <p>一部の Linux ウィンドウマネージャーは、<codeph>maximizable</codeph> 設定をサポートしていません。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/maximizable"><linktext>flash.display.NativeWindowInitOptions.maximizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:menu:get"><apiName>menu</apiName><shortdesc>
      このウィンドウのネイティブメニューです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
      このウィンドウのネイティブメニューです。 
      
      <p>NativeMenu オブジェクトがウィンドウの <codeph>menu</codeph> プロパティに割り当てられている場合、<codeph>NativeWindow.supportsMenu</codeph> が <codeph>true</codeph> に設定されていれば、ウィンドウにネイティブメニューが表示されます。ただし、ウィンドウの <codeph>systemChrome</codeph> プロパティが <codeph>NativeWindowSystemChrome.NONE</codeph> の場合は表示されません。</p>
      
      <p><b>注意：</b><codeph>NativeWindow.supportsMenu</codeph> が <codeph>false</codeph> の場合、またはウィンドウの <codeph>systemChrome</codeph> プロパティが <codeph>NativeWindowSystemChrome.NONE</codeph> の場合も、メニューを割り当てることはできますが、効果はありません。使用しているオペレーティングシステムでウィンドウメニューがサポートされているか確認するには、必ず <codeph>NativeWindow.supportsMenu</codeph> プロパティを使用してください。その他の方法（<codeph>Capabilities.os</codeph> など）でサポートの有無を判断すると、プログラミングエラーの原因になる可能性があります（ターゲットとなり得るオペレーティングシステムの種類についての配慮が完全でない場合）。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minSize:get"><apiName>minSize</apiName><shortdesc>
      このウィンドウの最小サイズです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>割り当てられているサイズが、オペレーティングシステムの最小および最大ウィンドウサイズの範囲外の場合。 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>サイズが、そのコンテンツの現在の特権で禁止されている場合。
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>サイズが <codeph>null</codeph> または無効な値を含んでいる場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、<codeph>minSize</codeph> プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      このウィンドウの最小サイズです。 
       
      <p>サイズ制限は、Point オブジェクトの座標として指定されます。ポイントの <codeph>x</codeph> プロパティはウィンドウの幅に相当し、<codeph>y</codeph> プロパティはウィンドウの高さに相当します。</p>
      <p>
      現在の境界が新しい最小サイズよりも小さい場合、<codeph>minSize</codeph> を設定すると、ウィンドウの境界が変化します。
      </p>
      <p>
      <codeph>minSize</codeph> の制限は、<ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> コードとオペレーティングシステムの両方で呼び出されるウィンドウサイズの変更操作に対して強制的に設定されます。
      </p>
      <p>
      <b>注意：</b>表示されているシステムクロムの幅および高さによって、ウィンドウのサイズを指定された最小サイズにできない場合があります。 
      </p>
      
      </apiDesc><example conref="NativeWindow.minSize.1.as"> 次の例は、ウィンドウの許容最小サイズを設定する方法を示したものです。
<codeblock>
windowObj.minSize = new Point(200,80);
</codeblock></example><example conref="NativeWindow.minSize.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObject.stage.nativeWindow.minSize = new Point(120,60);
</codeblock></example><example conref="NativeWindow.minSize.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.minSize = new air.Point(80,60);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minimizable:get"><apiName>minimizable</apiName><shortdesc>
	 このウィンドウの作成に使用される最小化可能設定を報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 このウィンドウの作成に使用される <codeph>minimizable</codeph> 設定を報告します。
	 
	 <p>ウィンドウが作成された後で、<codeph>minimizable</codeph> 設定を変更することはできません。</p>
	 
	 <p>一部の Linux ウィンドウマネージャーは、<codeph>minimizable</codeph> 設定をサポートしていません。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/minimizable"><linktext>flash.display.NativeWindowInitOptions.minimizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:resizable:get"><apiName>resizable</apiName><shortdesc>
	 このウィンドウの作成に使用されるサイズ変更可能設定を報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 このウィンドウの作成に使用される <codeph>resizable</codeph> 設定を報告します。
	 
	 <p>ウィンドウが作成された後で、<codeph>resizable</codeph> 設定を変更することはできません。</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:stage:get"><apiName>stage</apiName><shortdesc>
      このウィンドウの Stage オブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
      このウィンドウの Stage オブジェクトです。<ph platform="actionscript">Stage オブジェクトは、ActionScript 3.0 ベースの SWF コンテンツで使用されている表示リストアーキテクチャのルートオブジェクトです。</ph>
      
      <p>
      ステージは、ウィンドウの表示リストのルートです。ビジュアル表示オブジェクトをウィンドウに追加するには、そのオブジェクトをステージまたは既にこのステージの表示リストに存在する別のオブジェクトに追加します。ステージのサイズは、ウィンドウがシステムクロムを使用する場合のウィンドウクライアント領域のサイズです。システムクロムが使用されていない場合、ステージのサイズはウィンドウのサイズと等しくなります。
      </p>
      
      <p platform="javascript">HTML コンテンツをレンダリングする HTMLLoader は、表示リストツリーの単一のリーフになります。 ActionScript で定義されている表示オブジェクトは、HTMLLoader の上下どちらにでも、描画順序で配置できます。ただし、HTMLLoader によってレンダリングされたビジュアルエレメントの間に配置することはできません。</p>
      
      </apiDesc><example conref="NativeWindow.stage.1.as"> 次の例は、NativeWindow インスタンスの stage プロパティを設定する方法を示したものです。
<codeblock>
import flash.display.StageAlign;

windowObj.stage.align = StageAlign.TOP_LEFT;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage"><linktext>flash.display.Stage</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
      AIR が現在のコンピューターシステムのネイティブのウィンドウメニューをサポートするかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      AIR が現在のコンピューターシステムのネイティブのウィンドウメニューをサポートするかどうかを示します。
      
      <p><codeph>NativeWindow.supportsMenu</codeph> が <codeph>true</codeph> の場合、NativeMenu オブジェクトがウィンドウの <codeph>menu</codeph> プロパティに割り当てられると、そのウィンドウにネイティブメニューが表示されます。ただし、ウィンドウの <codeph>systemChrome</codeph> プロパティが <codeph>NativeWindowSystemChrome.NONE</codeph> の場合は表示されません。使用しているオペレーティングシステムでネイティブウィンドウメニューがサポートされているか確認するには、必ず <codeph>NativeWindow.supportsMenu</codeph> プロパティを使用してください。その他の方法（<codeph>Capabilities.os</codeph> など）でサポートの有無を判断すると、プログラミングエラーの原因になる可能性があります（ターゲットとなり得るオペレーティングシステムの種類についての配慮が完全でない場合）。</p>
      
      <p><b>注意：</b><codeph>NativeWindow.supportsMenu</codeph> が <codeph>false</codeph> の場合、またはウィンドウの <codeph>systemChrome</codeph> プロパティが <codeph>NativeWindowSystemChrome.NONE</codeph> の場合にメニューを割り当てることも可能ですが、何も実行されません。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsMenu"><linktext>flash.desktop.NativeApplication.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsNotification:get"><apiName>supportsNotification</apiName><shortdesc> 
      AIR が現在のコンピューターシステムのウィンドウ通知キュー送信をサポートするかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      AIR が現在のコンピューターシステムのウィンドウ通知キュー送信をサポートするかどうかを示します。
      
      <p><codeph>NativeWindow.supportsNotification</codeph> が <codeph>true</codeph> の場合、ウィンドウの <codeph>notifyUser()</codeph> メソッドを呼び出すと、該当するイベントが発生したユーザーに対して視覚的なキューを表示します。この視覚的なキューは、ネイティブシステムのオペレーティングシステムの規則に従います。例えば、Windows<sup>®</sup> では、タスクバーアイコンが点滅します。</p>
      
      <p><b>注意：</b><codeph>notifyUser()</codeph> の呼び出しは、<codeph>NativeWindow.supportsNotification</codeph> が <codeph>false</codeph> の場合でも可能です。ただし、何も実行されません。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsTransparency:get"><apiName>supportsTransparency</apiName><shortdesc> 
      AIR が透明なピクセルを含むネイティブのウィンドウをサポートするかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      AIR が透明なピクセルを含むネイティブのウィンドウをサポートするかどうかを示します。
      
      <p><codeph>NativeWindow.supportsTransparency</codeph> が <codeph>true</codeph> である場合、ウィンドウの <codeph>transparent</codeph> プロパティが <codeph>true</codeph> に設定されていれば、ネイティブのウィンドウのピクセル透過性が適用されます。ウィンドウの <codeph>transparent</codeph> プロパティの値にかかわらず、<codeph>NativeWindow.supportsTransparency</codeph> が <codeph>false</codeph> であれば、すべてのピクセルの不透明度が 1 に設定されます。<codeph>NativeWindow.supportsTransparency</codeph> が <codeph>false</codeph> の場合、完全に透明なピクセルは黒としてレンダリングされます。使用しているオペレーティングシステムで透明度がサポートされているか確認するには、必ず <codeph>NativeWindow.supportsTransparency</codeph> プロパティを使用してください。その他の方法（<codeph>Capabilities.os</codeph> など）でサポートの有無を判断すると、プログラミングエラーの原因になる可能性があります（ターゲットとなり得るオペレーティングシステムの種類についての配慮が完全でない場合）。</p>
      
      <p><b>注意：</b>このプロパティの値は、オペレーティングシステムで設定されるユーザー環境設定に基づいて、アプリケーションの実行中に変化する可能性があります。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/transparent"><linktext>flash.display.NativeWindow.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
	 このウィンドウの作成に使用されるシステムクロム設定を報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 このウィンドウの作成に使用されるシステムクロム設定を報告します。
	 
	 <p><codeph>NativeWindow.systemChrome</codeph> から返される値は、NativeWindowSystemChrome クラスで定義されている定数のいずれかになります。</p>
	 
	 <p>ウィンドウが作成された後で、システムクロムの設定を変更することはできません。</p>
	 
	 </apiDesc><example conref="NativeWindow.systemChrome.1.as"> 次の例は、ウィンドウのシステムクロムタイプを取得する方法を示したものです。
<codeblock>
var sysChromeType:String = windowObj.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
var sysChromeType:String = displayObject.stage.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
var sysChromeType = window.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.4.as"> 次の例は、新しいウィンドウを作成し、すべての子表示オブジェクトを新しいウィンドウに移動して、外見上のシステムクロムの設定と透明度の設定を変更する方法を示したものです。
<codeblock>
import flash.display.NativeWindow;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowInitOptions;

public function deChromeWindow(oldWindow:NativeWindow):NativeWindow{
    if(oldWindow.systemChrome != NativeWindowSystemChrome.NONE){
        var newOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
        newOptions.systemChrome = NativeWindowSystemChrome.NONE;
        newOptions.transparent = true;
        
        var newWindow:NativeWindow = new NativeWindow(newOptions);
        newWindow.stage.stageWidth = oldWindow.stage.stageWidth;
        newWindow.stage.stageHeight = oldWindow.stage.stageHeight;
        newWindow.stage.align = oldWindow.stage.align;
        newWindow.stage.scaleMode = oldWindow.stage.scaleMode;
        
        for(var i:int = 0; i &lt; oldWindow.stage.numChildren; i++){
            newWindow.stage.addChild(oldWindow.stage.getChildAt(i));
        }
        newWindow.activate();
        oldWindow.close();
        
        return newWindow;
    }
    return oldWindow;
}

</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/systemChrome"><linktext>flash.display.NativeWindowInitOptions.systemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemMaxSize:get"><apiName>systemMaxSize</apiName><shortdesc>
	 オペレーティングシステムで許可されている最大のウィンドウサイズです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 オペレーティングシステムで許可されている最大のウィンドウサイズです。
	 
      <p>サイズ制限は、Point オブジェクトの座標として指定されます。ポイントの <codeph>x</codeph> プロパティはウィンドウの幅に相当し、<codeph>y</codeph> プロパティはウィンドウの高さに相当します。</p>
      
      <p>オペレーティング システムによるサイズ制限に加え、AIR にも、ウィンドウサイズが上限 2880 × 2880 ピクセルまでという制限があります。また、アプリケーションが NativeWindow オブジェクトの <codeph>maxSize</codeph> プロパティを使用して制限を設定することもできます。</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:systemMinSize:get"><apiName>systemMinSize</apiName><shortdesc>
	 オペレーティングシステムで許可されている最小のウィンドウサイズです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 オペレーティングシステムで許可されている最小のウィンドウサイズです。
	 
      <p>サイズ制限は、Point オブジェクトの座標として指定されます。ポイントの <codeph>x</codeph> プロパティはウィンドウの幅に相当し、<codeph>y</codeph> プロパティはウィンドウの高さに相当します。</p>
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:title:set"><apiName>title</apiName><shortdesc>
      ウィンドウのタイトルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Low-privilege apps will probably have a string appended to all of their title strings
      
      </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      ウィンドウのタイトルです。  
      <p>
      タイトルを表示する場合は、ウィンドウのシステムクロムに加え、その他のシステムに依存した場所（タスクバーなど）に表示されます。
      </p>
      
      </apiDesc><example conref="NativeWindow.title.1.as"> 次の例では、ウィンドウオブジェクトのタイトルを設定します。
<codeblock>
windowObj.title = "Window Title";
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:transparent:get"><apiName>transparent</apiName><shortdesc>
	 このウィンドウの作成に使用される透明度設定を報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 このウィンドウの作成に使用される透明度設定を報告します。
	 
     <p>ウィンドウが作成された後で、<codeph>transparent</codeph> プロパティを変更することはできません。透明度は、ウィンドウの視覚的な外観とマウス動作に影響します。Windows および Mac OS X の場合、ピクセルのアルファ値が特定のしきい値を下回っている場合、ウィンドウでマウスイベントはキャプチャされません。この値は、オペレーティングシステムによってはおよそ .06 ～ .01 の間で変わります。Linux の場合、このウィンドウでは完全に透明な領域の上のマウスイベントがキャプチャされます。したがって、ユーザーはデスクトップ上のその他のウィンドウおよびアイテムにアクセスすることができません。</p>
     
     <p><b>注意：</b>ウィンドウの透明度は必ずしもサポートされているとは限りません。ユーザーのオペレーティングシステムの設定で透明度が使用できない場合、ウィンドウは透明度なしで作成されます。透明にしている領域は、黒と合成されます。<codeph>NativeWindow.supportsTransparency</codeph> プロパティを使用して、ウィンドウの透明度をサポートするかどうかを指定します。</p>
	 
	 </apiDesc><example conref="NativeWindow.transparent.1.as"/><example conref="NativeWindow.transparent.2.as"/><example conref="NativeWindow.transparent.3.as"/></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/transparent"><linktext>flash.display.NativeWindowInitOptions.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:type:get"><apiName>type</apiName><shortdesc>
	 このウィンドウの作成に使用されるウィンドウタイプの設定を報告します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 このウィンドウの作成に使用されるウィンドウの <codeph>type</codeph> の設定を報告します。
	 
	 <p><codeph>NativeWindow.type</codeph> から返される値は、NativeWindowType クラスで定義されている定数のいずれかになります。</p>
	 
	 <p>ウィンドウが作成された後で、<codeph>type</codeph> 設定を変更することはできません。</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/type"><linktext>flash.display.NativeWindowInitOptions.type</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:visible:get"><apiName>visible</apiName><shortdesc> 
      このウィンドウが可視かどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>十分な特権がない状態で <codeph>false</codeph> を設定しようとした場合。
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
      このウィンドウが可視かどうかを指定します。  
      
      <p>
      不可視のウィンドウはデスクトップに表示されませんが、ウィンドウのプロパティとメソッドはすべて有効です。
      </p> 
      <p>
      デフォルトでは、<codeph>visible</codeph> は <codeph>false</codeph> に設定されています。ウィンドウを表示するには、<codeph>visible</codeph> を <codeph>true</codeph> に設定するか、<codeph>NativeWindow.activate()</codeph> を呼び出します。
      </p>
      <p>
      <b>注意：</b>Mac OS X では、最小化されたウィンドウで <codeph>visible=false</codeph> に設定しても、ウィンドウアイコンはドックから削除されません。その後、ユーザーがドックアイコンをクリックするとウィンドウは可視状態に戻り、デスクトップに表示されます。
      </p>
      
      </apiDesc><example conref="NativeWindow.visible.1.as"> 次の例は、ウィンドウの <codeph>visible</codeph> プロパティにアクセスする方法を示したものです。
<codeblock>
windowObj.visible = true;
</codeblock></example><example conref="NativeWindow.visible.2.as"> ウィンドウステージの表示オブジェクトへの参照を使用した場合は、次のようになります。
<codeblock>
displayObj.stage.nativeWindow.visible = true;
</codeblock></example><example conref="NativeWindow.visible.3.as"> ウィンドウの HTMLLoader オブジェクト（またはルート HTML ウィンドウ）で実行している JavaScript ルーチンからは、次のように処理します。
<codeblock>
window.nativeWindow.visible = true;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate()"><linktext>activate()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:width:get"><apiName>width</apiName><shortdesc>
      このウィンドウの幅（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>値セットが <codeph>null</codeph> または無効な値の場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      このウィンドウの幅（ピクセル単位）です。
      
      <p>ネイティブウィンドウの通知されるサイズには、表示されているシステムウィンドウのクロムが含まれます。ウィンドウ内側の使用可能な表示領域の幅は、<codeph>Stage.stageWidth</codeph> プロパティから取得できます。</p>
      
      <p>ウィンドウの <codeph>width</codeph> プロパティを変更すると、<codeph>bounds</codeph> プロパティから幅を変更した場合と同じ動作をします。</p>
      
      <p>指定された幅が、許容される幅の下限よりも小さい場合や上限よりも大きい場合、許容される最も近い値にウィンドウの幅が設定されます。幅の下限および上限は、次の要因に基づいて決定されます。</p>
      
      <ul>
      
      	<li>NativeWindow オブジェクトの <codeph>minSize.y</codeph> および <codeph>maxSize.y</codeph> プロパティ</li>
      	<li>オペレーティングシステムの制限による上限と下限。これは、<codeph>NativeWindow.systemMinSize.y</codeph> と <codeph>NativeWindow.systemMaxSize.y</codeph> の値です。</li>
      	<li>Adobe AIR におけるウィンドウ幅の上限（2880 ピクセル）。</li>
      
      </ul>
      
      <p>Linux の場合、<codeph>width</codeph> プロパティを設定する操作は非同期的に実行されます。</p>
      
      <p>
      幅変更の完了を検出するには、<codeph>resize</codeph> イベントを監視します。これは、どのプラットフォームでも送出されるイベントです。
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageWidth"><linktext>flash.display.Stage.stageWidth</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:x:get"><apiName>x</apiName><shortdesc>
      オペレーティングシステムのデスクトップの起点を基準とした、このウィンドウの左上隅の水平軸座標です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>値セットが <codeph>null</codeph> または無効な値の場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      オペレーティングシステムのデスクトップの起点を基準とした、このウィンドウの左上隅の水平軸座標です。
      
      <p>複数のモニターがあるシステムでは、<codeph>x</codeph> が負の値になることがあります。ウィンドウを以前の場所に再位置付けするために値を保存した場合、位置を復元したときにウィンドウが使用可能な場所に配置されていることを常に検証する必要があります。画面の解像度やモニターの配置を変更すると、ウィンドウが画面外に配置されることがあります。Screen クラスを使用して、デスクトップジオメトリに関する情報を取得してください。</p> 
      
      <p>ウィンドウの <codeph>x</codeph> プロパティを変更すると、<codeph>bounds</codeph> プロパティから位置を変更した場合と同じ動作をします。</p>
      
      <p>Linux の場合、<codeph>x</codeph> プロパティを設定する操作は非同期的に実行されます。</p>
      
      <p>
      位置変更の完了を検出するには、<codeph>move</codeph> イベントを監視します。これは、どのプラットフォームでも送出されるイベントです。
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:y:get"><apiName>y</apiName><shortdesc>
      オペレーティングシステムのデスクトップの左上隅を基準とした、このウィンドウの左上隅の垂直軸座標です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>値セットが <codeph>null</codeph> または無効な値の場合。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>このウィンドウが閉じられた後に、プロパティがアクセスされた場合。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      オペレーティングシステムのデスクトップの左上隅を基準とした、このウィンドウの左上隅の垂直軸座標です。
      
      <p>複数のモニターがあるシステムでは、<codeph>y</codeph> が負の値になることがあります。ウィンドウを以前の場所に再位置付けするために値を保存した場合、位置を復元したときにウィンドウが使用可能な場所に配置されていることを常に検証する必要があります。画面の解像度やモニターの配置を変更すると、ウィンドウが画面外に配置されることがあります。Screen クラスを使用して、デスクトップジオメトリに関する情報を取得してください。</p> 
      
      <p>ウィンドウの <codeph>y</codeph> プロパティを変更すると、<codeph>bounds</codeph> プロパティから位置を変更した場合と同じ動作をします。</p>
      
      <p>Linux の場合、<codeph>y</codeph> プロパティを設定する操作は非同期的に実行されます。</p>
       
      <p>
      位置変更の完了を検出するには、<codeph>move</codeph> イベントを監視します。これは、どのプラットフォームでも送出されるイベントです。
      </p>
     
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Stage"><apiName>Stage</apiName><shortdesc>
 Stage クラスはメイン描画領域を表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Stage クラスはメイン描画領域を表します。 
 
 <p platform="actionscript">ブラウザー（Flash<sup>®</sup> Player）で実行されている SWF コンテンツの場合、Stage は Flash コンテンツが表示されている全体の領域を表します。AIR で実行されているコンテンツの場合、各 NativeWindow オブジェクトが、対応する Stage オブジェクトを持ちます。</p>
 
 <p platform="actionscript">Stage オブジェクトはグローバルにアクセスすることはできません。アクセスするには、DisplayObject インスタンスの <codeph>stage</codeph> プロパティを介する必要があります。</p> 
 
 <p platform="actionscript">Stage クラスには、DisplayObjectContainer、InteractiveObject、DisplayObject、EventDispatcher などの祖先クラスがあり、これらからプロパティやメソッドを継承します。これらのプロパティおよびメソッドの多くは、Stage オブジェクトに適用できないか、Stage オブジェクトで呼び出す際にセキュリティチェックを必要とします。セキュリティチェックを必要とするプロパティとメソッドについては、Stage クラスの一部として記述されています。</p>
 
 <p platform="actionscript">加えて、以下に示す継承プロパティは Stage オブジェクトに適用できません。これらを設定しようとすると、IllegalOperationError がスローされます。これらのプロパティは読み取ることはできますが、設定することはできないため、常にデフォルト値となります。</p>
 
 <ul platform="actionscript">
 <li><codeph>accessibilityProperties</codeph></li>
 <li><codeph>alpha</codeph></li>
 <li><codeph>blendMode</codeph></li>
 <li><codeph>cacheAsBitmap</codeph></li>
 <li><codeph>contextMenu</codeph></li>
 <li><codeph>filters</codeph></li>
 <li><codeph>focusRect</codeph></li>
 <li><codeph>loaderInfo</codeph></li>
 <li><codeph>mask</codeph></li>
 <li><codeph>mouseEnabled</codeph></li>
 <li><codeph>name</codeph></li>
 <li><codeph>opaqueBackground</codeph></li>
 <li><codeph>rotation</codeph></li>
 <li><codeph>scale9Grid</codeph></li>
 <li><codeph>scaleX</codeph></li>
 <li><codeph>scaleY</codeph></li>
 <li><codeph>scrollRect</codeph></li>
 <li><codeph>tabEnabled</codeph></li>
 <li><codeph>tabIndex</codeph></li>
 <li><codeph>transform</codeph></li>
 <li><codeph>visible</codeph></li>
 <li><codeph>x</codeph></li>
 <li><codeph>y</codeph></li>
 </ul>
 
 <p><codeph>enterFrame</codeph>、<codeph>exitFrame</codeph>、<codeph>frameConstructed</codeph>、<codeph>render</codeph> など、Stage クラスの一部であると予想される一部のイベントは、これらのイベントが使用されるすべての状況において Stage オブジェクトへの参照が存在するわけではないため、Stage のイベントにすることができません。Stage オブジェクトはこれらのイベントを送出できないため、これらのイベントは、代わりに、各 DisplayObject インスタンスによって送出されます。このため、任意の DisplayObject インスタンスにイベントリスナーを追加して、これらのイベントを監視できます。DisplayObject クラスの一部であるこれらのイベントはブロードキャストイベントと呼ばれ、特定の DisplayObject インスタンスをターゲットとするイベントとは区別されます。これ以外のブロードキャストイベントである <codeph>activate</codeph> と <codeph>deactivate</codeph> の 2 つは、DisplayObject のスーパークラスである EventDispatcher に属します。<codeph>activate</codeph> イベントと <codeph>deactivate</codeph> イベントは DisplayObject のブロードキャストイベントと同じように動作します。ただし、すべての DisplayObject インスタンスだけでなく、すべての EventDispatcher インスタンスおよび EventDispatcher の他のサブクラスのインスタンスによって送出される点が異なります。ブロードキャストイベントの詳細については、DisplayObject クラスに関する説明を参照してください。</p>
 
 </apiDesc><example conref="examples\StageExample.as"> 次の例では、<codeph>StageExample</codeph> クラスを使用して、ステージのアクティブ化またはサイズ変更に伴い、イベントを送出します。ここでは以下の手順を実行します。
 <ol>
  <li>最初にクラスコンストラクターは、Flash Player のウィンドウのサイズに関係なく、<codeph>activateHandler()</codeph> メソッドおよび <codeph>resizeHandler()</codeph> メソッドを使用して、固定する Flash アプリケーションを設定します。</li>
 
  <li>マウスの左ボタンをクリックすると、<codeph>activateHandler()</codeph>メソッドが実行されます。</li>
 
  <li>ステージのサイズを変更すると、<codeph>resizeHandler()</codeph> メソッドが実行されます。</li>
 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.Event;

    public class StageExample extends Sprite {

        public function StageExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.addEventListener(Event.ACTIVATE, activateHandler);
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function activateHandler(event:Event):void {
            trace("activateHandler: " + event);
        }

        private function resizeHandler(event:Event):void {
            trace("resizeHandler: " + event);
            trace("stageWidth: " + stage.stageWidth + " stageHeight: " + stage.stageHeight);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><adobeApiEvent id="flash.display:Stage_flash.events.FullScreenEvent.FULL_SCREEN_fullScreen"><apiName>fullScreen</apiName><shortdesc>
 Stage オブジェクトが、フルスクリーンモードに設定または設定解除されると送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FullScreenEvent.FULL_SCREEN</apiEventType><adobeApiEventClassifier>flash.events.FullScreenEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Stage オブジェクトが、フルスクリーンモードに設定または設定解除されると送出されます。フルスクリーンモードの変更は、ActionScript、ユーザーによるキーボードショートカットの呼び出し、または現在のフォーカスのフルスクリーンウィンドウからの移動によって開始できます。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Stage オブジェクトの scaleMode プロパティが StageScaleMode.NO_SCALE に設定され、SWF ファイルのサイズが変更されたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Stage オブジェクトの <codeph>scaleMode</codeph> プロパティが <codeph>StageScaleMode.NO_SCALE</codeph> に設定され、SWF ファイルのサイズが変更されたときに送出されます。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.MOUSE_LEAVE_mouseLeave"><apiName>mouseLeave</apiName><shortdesc>
 マウスポインターがステージ領域から離れたときに、Stage オブジェクトによって送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.MOUSE_LEAVE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 マウスポインターがステージ領域から離れたときに、Stage オブジェクトによって送出されます。マウスボタンが押された場合、イベントは送出されません。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:Stage:addChild"><apiName>addChild</apiName><shortdesc>
	 
     この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>addChild()</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>child</codeph> パラメーターで渡す DisplayObject インスタンスです。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>この DisplayObjectContainer インスタンスの子として追加する DisplayObject インスタンスです。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
     この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。子インスタンスは、この DisplayObjectContainer インスタンスにある他のすべての子の前（上）に追加されます（特定のインデックス位置に子を追加する場合は、<codeph>addChildAt()</codeph> メソッドを使用します）。
     
	 <p>既に異なる表示オブジェクトコンテナを親に持つ子オブジェクトを追加する場合は、もう一方の表示オブジェクトコンテナの子リストからそのオブジェクトが削除されます。 </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 
	 この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>addChildAt()</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>child</codeph> パラメーターで渡す DisplayObject インスタンスです。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>この DisplayObjectContainer インスタンスの子として追加する DisplayObject インスタンスです。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>子を追加するインデックス位置です。既にオブジェクトが置かれているインデックス位置を指定すると、その位置にあるオブジェクトとその上に位置するすべてのオブジェクトが、子リスト内で 1 つ上の位置に移動します。 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 この DisplayObjectContainer インスタンスに子 DisplayObject インスタンスを追加します。子インスタンスは、指定されたインデックス位置に追加されます。インデックス 0 は、この DisplayObjectContainer オブジェクトの表示リストの背景または一番下を表します。
	 
	 <p>例えば、a、b、c というラベルの 3 個の表示オブジェクトをインデックス位置 0、2、1 にそれぞれ配置すると、以下のようになります。</p>
	 
	 <p><adobeimage alt="a の上に c、c の上に b" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>既に異なる表示オブジェクトコンテナを親に持つ子オブジェクトを追加する場合は、もう一方の表示オブジェクトコンテナの子リストからそのオブジェクトが削除されます。 </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	 
	イベントリスナーオブジェクトを EventDispatcher オブジェクトに登録し、リスナーがイベントの通知を受け取るようにします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>addEventListener</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。この状態を回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>イベントのタイプです。
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>イベントを処理するリスナー関数です。この関数は、次の例のように、Event オブジェクトを唯一のパラメーターとして受け取り、何も返さないもの<ph platform="actionscript">である必要があります。</ph> <ph platform="javascript"/>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>関数の名前は任意に付けられます。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">このパラメーターは、SWF コンテンツで使用される ActionScript 3.0 の表示リストアーキテクチャの表示オブジェクトに適用されます。</ph> <ph platform="actionscript">リスナーが、キャプチャ段階、またはターゲットおよびバブリング段階で動作するかどうかを判断します。 <codeph>useCapture</codeph> を <codeph>true</codeph> に設定すると、リスナーはキャプチャ段階のみでイベントを処理し、ターゲット段階またはバブリング段階では処理しません。<codeph>useCapture</codeph> を <codeph>false</codeph> に設定すると、リスナーはターゲット段階またはバブリング段階のみでイベントを処理します。3 つの段階すべてでイベントを受け取るには、<codeph>addEventListener</codeph> を 2 回呼び出します。<codeph>useCapture</codeph> を <codeph>true</codeph> に設定して呼び出し、<codeph>useCapture</codeph> を <codeph>false</codeph> に設定してもう一度呼び出します。</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>イベントリスナーの優先度レベルです。優先度は、符号付き 32 ビット整数で指定します。数値が大きくなるほど優先度が高くなります。優先度が <i>n</i> のすべてのリスナーは、優先度が <i>n</i>-1 のリスナーよりも前に処理されます。複数のリスナーに対して同じ優先度が設定されている場合、それらは追加された順番に処理されます。デフォルトの優先度は 0 です。
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>リスナーへの参照が強参照と弱参照のいずれであるかを判断します。デフォルトである強参照の場合は、リスナーのガベージコレクションが回避されます。弱参照では回避されません。 <p>クラスレベルメンバー関数はガベージコレクションの対象外であるため、クラスレベルメンバー関数の <codeph>useWeakReference</codeph> は、ガベージコレクションの制限とは無関係に <codeph>true</codeph> に設定できます。ネストされた内部の関数であるリスナーに対して <codeph>useWeakReference</codeph> を <codeph>true</codeph> に設定すると、その関数はガベージコレクションされ、永続的ではなくなります。inner 関数に対する参照を作成（別の変数に保存）した場合、その関数はガベージコレクションされず、永続化された状態のままになります。</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	イベントリスナーオブジェクトを EventDispatcher オブジェクトに登録し、リスナーがイベントの通知を受け取るようにします。<ph platform="actionscript">イベントリスナーは、特定のタイプのイベント、段階、および優先度に関する表示リスト内のすべてのノードに登録できます。</ph>
	
	<p platform="javascript">AIR ランタイムの JavaScript コードは、このメソッドを使用して AIR API によって定義されたイベント用のイベントリスナーを登録します。他の JavaScript イベント、例えば、<codeph>onload</codeph> イベント（DOM <codeph>body</codeph> オブジェクトのイベント）などの場合、ブラウザー内で実行されるコンテンツに対して行うように標準イベント処理テクニックを使用できます。</p>
	
	<p>イベントリスナーが正常に登録された後に、<codeph>addEventListener()</codeph> をさらに呼び出して優先度を変更することはできません。リスナーの優先度を変更するには、最初に <codeph>removeListener()</codeph> を呼び出す必要があります。その後、同じリスナーを新しい優先度レベルで再度登録できます。 </p>
	
	<p>リスナーが登録された後に、<codeph>addEventListener()</codeph>（<codeph>type</codeph> または <codeph>useCapture</codeph> に別の値を設定）を再度呼び出すと、別のリスナー登録が作成されることに注意してください。<ph platform="actionscript">例えば、最初にリスナーを登録するときに <codeph>useCapture</codeph> を <codeph>true</codeph> に設定すると、そのリスナーはキャプチャ段階のみでリスニングします。同じリスナーオブジェクトを使用して再度 <codeph>addEventListener()</codeph> を呼び出すと（このとき、<codeph>useCapture</codeph> に <codeph>false</codeph> を設定）、異なる 2 つのリスナーが登録されます。1 つはキャプチャ段階でリスニングするリスナーで、もう 1 つはターゲット段階とバブリング段階でリスニングするリスナーです。</ph>
	</p>
	
	<p platform="actionscript">ターゲット段階またはバブリング段階のみを対象とするイベントリスナーを登録することはできません。登録時にこれらの段階が組み合わされるのは、バブリングはターゲットノードの祖先にしか適用されないためです。</p>
	
	<p>イベントリスナーが不要になった場合は、<codeph>removeEventListener()</codeph> を呼び出して、イベントリスナーを削除します。削除しない場合、メモリの問題が発生する可能性があります。ガベージコレクターは送出するオブジェクトがないとリスナーを削除しないので、イベントリスナーはメモリから自動的に削除されません（ただし、<codeph>useWeakReference</codeph> パラメーターが <codeph>true</codeph> に設定されている場合を除きます）。</p>
		
	<p>EventDispatcher インスタンスをコピーしても、それに関連付けられているイベントリスナーはコピーされません。新しく作成したノードにイベントリスナーが必要な場合は、ノードを作成した後に、リスナーを関連付ける必要があります。ただし、EventDispatcher インスタンスを移動した場合は、関連付けられているイベントリスナーも一緒に移動されます。</p>
	
	
	<p platform="actionscript">イベントがノードで処理されるときに、イベントリスナーがそのノードに登録中であれば、イベントリスナーは現在の段階ではトリガーされません。ただし、バブリング段階など、イベントフローの後の段階でトリガーすることができます。</p>
	
	<p platform="actionscript">イベントがノードで処理されているときにイベントリスナーがノードから削除された場合でも、イベントは現在のアクションによってトリガーされます。削除された後は、その後の処理で再び登録されない限り、イベントリスナーは二度と呼び出されません。 </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	 objectToFocus によって指定されたインタラクティブオブジェクトに対して、direction パラメーターで指定されたフォーカスの方向でキーボードフォーカスを設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>フォーカスをターゲットに設定できない場合、または方向が有効なタイプではない場合。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>objectToFocus</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>フォーカスを設定するオブジェクト。Stage 上の任意のエレメントからフォーカスをクリアする場合は <codeph>null</codeph> になります。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>direction</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc><codeph>objectToFocus</codeph> がフォーカスを設定される元の方向。有効な値は、FocusDirection クラスに定数で列挙されています。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>キーボードフォーカスをインタラクティブオブジェクトに割り当て、どこから方向フォーカスが来るのかを指定します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 <codeph>objectToFocus</codeph> によって指定されたインタラクティブオブジェクトに対して、<codeph>direction</codeph> パラメーターで指定されたフォーカスの方向でキーボードフォーカスを設定します。 
	 
	 <p>フォーカス方向の概念は、アプリケーション（またはアプリケーションフレームワーク）で定義する必要があります。インタラクティブオブジェクト固有のフォーカス並べ替え設定が存在しません。ただし、並べ替え方針を確立するには、利用可能な他のプロパティを使用することもできます。例えば、インタラクティブオブジェクトを Stage 内のその位置によって、または表示リストで並べ替えることができます。<codeph>assignFocus()</codeph> を呼び出すことは、<codeph>Stage.focus</codeph> プロパティを設定することと同じであり、さらに、フォーカスを設定する元の方向を示すという追加の機能もあります。</p>
	 
	 <p><codeph>objectToFocus</codeph> は、フォーカスを受け取ると <codeph>focusIn</codeph> イベントを送出します。FocusEvent オブジェクトの <codeph>direction</codeph> プロパティは、<codeph>direction</codeph> パラメーターの設定を報告します。</p>
	 
	 <p>HTMLLoader オブジェクトを <codeph>objectToFocus</codeph> パラメーターに割り当てた場合、HTMLLoader オブジェクトは、<codeph>direction</codeph> パラメーター値に基づいて、HTML DOM 内で適切なフォーカス可能なオブジェクトを選択します。値が <codeph>FocusDirection.BOTTOM</codeph> である場合、読み取り順の最後にある HTML DOM 内のフォーカス可能なオブジェクトにフォーカスが設定されます。値が <codeph>FocusDirection.TOP</codeph> である場合、読み取り順の最初にある HTML DOM 内のフォーカス可能なオブジェクトにフォーカスが設定されます。値が <codeph>NONE</codeph> である場合は、現在フォーカスがあるエレメントを変更せずに、HTMLLoader オブジェクトにフォーカスが設定されます。</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link><link href="flash.display.xml#FocusDirection"><linktext>flash.display.FocusDirection</linktext></link><link href="flash.events.xml#FocusEvent"><linktext>flash.events.FocusEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
	 
	イベントをイベントフローに送出します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>dispatchEvent()</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>値が <codeph>true</codeph> の場合、イベントは正常に送出されました。値が <codeph>false</codeph> の場合、イベントの送出に失敗したか、イベントで <codeph>preventDefault()</codeph> が呼び出されたことを示しています。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>イベントフローに送出されるイベントオブジェクトです。イベントが再度送出されると、イベントのクローンが自動的に作成されます。イベントが送出された後にそのイベントの <codeph>target</codeph> プロパティは変更できないため、再送出処理のためにはイベントの新しいコピーを作成する必要があります。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	イベントをイベントフローに送出します。イベントターゲットは EventDispatcher オブジェクトです。これに対して <codeph>dispatchEvent()</codeph> メソッドが呼び出されます。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
	 
	EventDispatcher オブジェクトに、特定のイベントタイプに対して登録されたリスナーがあるかどうかを確認します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>hasEventListener()</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定したタイプのリスナーが登録されている場合は <codeph>true</codeph>、それ以外の場合は <codeph>false</codeph> です。
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>イベントのタイプです。
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	EventDispatcher オブジェクトに、特定のイベントタイプに対して登録されたリスナーがあるかどうかを確認します。これにより、EventDispatcher オブジェクトがイベントタイプの処理をイベントフロー階層のどこで変更したかを判断できます。特定のイベントタイプが実際にイベントリスナーをトリガーするかどうかを判別するには、<codeph>willTrigger()</codeph> を使用します。
	
	<p><codeph>hasEventListener()</codeph> と <codeph>willTrigger()</codeph> の違いは、<codeph>hasEventListener()</codeph> では自身が属するオブジェクトのみが検証され、<codeph>willTrigger()</codeph> では <codeph>type</codeph> パラメーターで指定されたイベントのイベントフロー全体が検証されることです。 <ph platform="javascript">イベントフローは、SWF コンテンツで使用される ActionScript 3.0 表示リストに適用されます。</ph>
	</p>
	
	<p><codeph>hasEventListener()</codeph> が LoaderInfo オブジェクトから呼び出された場合は、呼び出し側がアクセスできるリスナーのみ考慮されます。</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:invalidate"><apiName>invalidate</apiName><shortdesc>
     invalidate() メソッドは、表示リストをレンダリングする必要のある次の機会に、表示オブジェクトに警告するよう Flash Player に通知します。例えば、再生ヘッドを新しいフレームに進める場合などです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>ステージを更新する必要のある次の機会に、表示オブジェクトのプロパティを更新するよう Flash Player に通知します。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <codeph>invalidate()</codeph> メソッドは、表示リストをレンダリングする必要のある次の機会に、表示オブジェクトに警告するよう Flash Player に通知します。例えば、再生ヘッドを新しいフレームに進める場合などです。<codeph>invalidate()</codeph> メソッドを呼び出すと、表示リストが次にレンダリングされるときに、Flash Player から <codeph>render</codeph> イベントが、<codeph>render</codeph> イベントを受け取るように登録されている各表示オブジェクトに対して送出されます。その都度 <codeph>invalidate()</codeph> メソッドを呼び出す必要があります（Flash Player に <codeph>render</codeph> イベントを送出させたい場合）。 
     
     <p><codeph>render</codeph> イベントによって、実際に表示される直前に表示リストに変更を加えることができます。こうすることで、表示リストへの更新を最後まで遅らせることが可能です。この方法では、画面の更新を不必要に行わなくてよいため、パフォーマンスを向上させることができます。</p>
     
     <p><codeph>render</codeph> イベントは、<codeph>stage.invalidate()</codeph> メソッドを呼び出すコードと同じセキュリティドメイン内の表示オブジェクト、または <codeph>Security.allowDomain()</codeph> メソッドで許可が与えられているセキュリティドメインの表示オブジェクトに対してのみ、送出されます。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/RENDER"><linktext>flash.events.Event.RENDER</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:isFocusInaccessible"><apiName>isFocusInaccessible</apiName><shortdesc>
	 Stage.focus プロパティがセキュリティ上の理由で null を返すかどうかを決定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>フォーカスを持つオブジェクトが、SWF ファイルがアクセスできないセキュリティ Sandbox に属している場合、<codeph>true</codeph> を返します。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText><codeph>Stage.focus</codeph> プロパティがセキュリティ上の理由で <codeph>null</codeph> を返すかどうかを決定します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 <codeph>Stage.focus</codeph> プロパティがセキュリティ上の理由で <codeph>null</codeph> を返すかどうかを決定します。つまり、フォーカスを持つオブジェクトが、SWF ファイルがアクセスできないセキュリティ Sandbox に属している場合、<codeph>isFocusInaccessible</codeph> は <codeph>true</codeph> を返します。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 
	 DisplayObjectContainer の子リストの指定された index 位置から子 DisplayObject を削除します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>removeChildAt()</codeph> メソッドを呼び出すと、削除するオブジェクトと同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。これを回避するには、そのオブジェクトの所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>削除された DisplayObject インスタンスです。
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>削除する DisplayObject の子インデックスです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 DisplayObjectContainer の子リストの指定された <codeph>index</codeph> 位置から子 DisplayObject を削除します。削除された子の <codeph>parent</codeph> プロパティは <codeph>null</codeph> に設定されます。その子に対する参照が存在しない場合、そのオブジェクトはガベージコレクションによって収集されます。DisplayObjectContainer の子より上位にある表示オブジェクトのインデックス位置は 1 つ下がります。
	 
	 <p>ガベージコレクターは、未使用のメモリスペースの再割り当てを行います。 変数またはオブジェクトがアクティブに参照されなくなり、任意の場所に保存されていない場合、ガベージコレクターによってメモリ内が探索され、それらに対する参照が存在しなければメモリスペースを占有している変数またはオブジェクトが一掃されます。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	 
	表示オブジェクトコンテナの既存の子の位置を変更します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>setChildIndex()</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>インデックス番号を変更する子 DisplayObject インスタンスです。
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc><codeph>child</codeph> 表示オブジェクトの結果のインデックス番号です。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	表示オブジェクトコンテナの既存の子の位置を変更します。これは、子オブジェクトのレイヤーに影響します。例えば、a、b、c というラベルの 3 個の表示オブジェクトをインデックス位置 0、1、2 にそれぞれ配置すると、以下のようになります。
	
	<p><adobeimage alt="a の上に b、b の上に c" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p><codeph>setChildIndex()</codeph> を使用し、既に占有されているインデックス位置を指定した場合、表示オブジェクトの前の位置と新しい位置の間にある位置だけが変化します。その他は変化しません。現在のインデックスよりも小さいインデックスに子を移動すると、その間のすべての子が、それぞれのインデックス参照について 1 増加します。現在のインデックスよりも大きいインデックスに子を移動すると、その間のすべての子が、それぞれのインデックス参照について 1 減少します。例えば、上記の例の表示オブジェクトコンテナの名前が <codeph>container</codeph> である場合、次に示すコードを呼び出すことによって、a および b というラベルが付けられた表示オブジェクトの位置を入れ替えることができます。</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>このコードによって、次に示すようなオブジェクトの配置になります。</p>
	
    <p><adobeimage alt="b の上に a、a の上に c" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 
	 子リスト内の指定されたインデックス位置に該当する 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>swapChildrenAt()</codeph> メソッドを呼び出すと、入れ替わるどちらかのオブジェクトの所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。これを回避するには、オブジェクト所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>最初の子オブジェクトのインデックス位置です。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>2 番目の子オブジェクトのインデックス位置です。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 子リスト内の指定されたインデックス位置に該当する 2 つの子オブジェクトの z 順序（重ね順）を入れ替えます。表示オブジェクトコンテナの他のすべての子オブジェクトは、同じインデックス位置に残されます。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:willTrigger"><apiName>willTrigger</apiName><shortdesc>
	 
	指定されたイベントタイプについて、この EventDispatcher オブジェクトまたはその祖先にイベントリスナーが登録されているかどうかを確認します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Stage オブジェクトの <codeph>willTrigger()</codeph> メソッドを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定したタイプのリスナーがトリガーされた場合は <codeph>true</codeph>、それ以外の場合は <codeph>false</codeph> です。
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>イベントのタイプです。
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	指定されたイベントタイプについて、この EventDispatcher オブジェクトまたはその祖先にイベントリスナーが登録されているかどうかを確認します。指定されたタイプのイベントがこの EventDispatcher オブジェクトまたはその子孫に送出されたときに、イベントリスナーがイベントフローの任意の段階でトリガーされる場合、このメソッドは <codeph>true</codeph> を返します。
	
	<p><codeph>hasEventListener()</codeph> と <codeph>willTrigger()</codeph> メソッドの違いは、<codeph>hasEventListener()</codeph> では自身が属するオブジェクトのみが検証され、<codeph>willTrigger()</codeph> メソッドでは <codeph>type</codeph> パラメーターで指定されたイベントのイベントフロー全体が検証されることです。 <ph platform="javascript">イベントフローは、SWF コンテンツで使用される ActionScript 3.0 表示リストに適用されます。</ph></p>
	
	<p><codeph>willTrigger()</codeph> が LoaderInfo オブジェクトから呼び出された場合は、呼び出し側がアクセスできるリスナーのみが考慮されます。</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:Stage:align:get"><apiName>align</apiName><shortdesc>
	 Flash Player またはブラウザーでのステージの配置を指定する StageAlign クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Flash Player またはブラウザーでのステージの配置を指定する StageAlign クラスの値です。使用できる値は次のとおりです。
	 
	 <p>
	 <adobetable class="innertable">
	 	
	 	 
	 	 
	 	 
	 	 
	 	  
	 	  
	 	  
	 	  
	 	 
	 <tgroup cols="3"><thead><row><entry>値</entry><entry>垂直方向の配置</entry><entry>水平方向</entry></row></thead><tbody><row><entry><codeph>StageAlign.TOP</codeph></entry>
	 	 <entry>上揃え</entry>
	 	 <entry>中央揃え</entry>
	 	 </row><row><entry><codeph>StageAlign.BOTTOM</codeph></entry>
	 	 <entry>下揃え</entry>
	 	 <entry>中央揃え</entry>
	 	 </row><row><entry><codeph>StageAlign.LEFT</codeph></entry>
	 	 <entry>中央揃え</entry>
	 	 <entry>左揃え</entry>
	 	 </row><row><entry><codeph>StageAlign.RIGHT</codeph></entry>
	 	 <entry>中央揃え</entry>
	 	 <entry>右揃え</entry>
	 	 </row><row><entry><codeph>StageAlign.TOP_LEFT</codeph></entry>
	 	  <entry>上揃え</entry>
	 	  <entry>左揃え</entry>
	 	  </row><row><entry><codeph>StageAlign.TOP_RIGHT</codeph></entry>
	 	  <entry>上揃え</entry>
	 	  <entry>右揃え</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_LEFT</codeph></entry>
	 	  <entry>下揃え</entry>
	 	  <entry>左揃え</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_RIGHT</codeph></entry>
	 	  <entry>下揃え</entry>
	 	  <entry>右揃え</entry>
	 	  </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p><codeph>align</codeph> プロパティは、メイン SWF ファイルであるステージ所有者と同じセキュリティ Sandbox 内にあるオブジェクトでのみ使用できます。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.alowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元オブジェクトのドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageAlign"><linktext>flash.display.StageAlign</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrection:get"><apiName>colorCorrection</apiName><shortdesc>
 	 ディスプレイに対する Flash Player のカラー補正を制御します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>モニターのカラー補正を使用することを試行します。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
 	 ディスプレイに対する Flash Player のカラー補正を制御します。カラー補正は、メインモニターに有効な ICC カラープロファイルが割り当てられている場合にのみ機能します。このカラープロファイルは、デバイスの特別なカラー属性を指定します。デフォルトでは、Flash Player はそのホスト (通常はブラウザー) と同じカラー補正を使用しようとします。
     
     <p>現在のシステムでカラー補正が使用できるかどうかとデフォルトの状態を確認するには、<codeph>Stage.colorCorrectionSupport</codeph> プロパティを使用します。カラー補正を利用できる場合、ステージのすべてのカラーは、最も標準的なカラー空間である RGB カラー空間にあると見なされます。カラー補正中、入力デバイスのソースプロファイルは考慮されません。入力カラー補正は適用されません。ステージ出力のみがメインモニターの ICC カラープロファイルにマップされます。</p>
      
     <p>カラー管理をアクティブにする一般的な利点としては、予測可能な一貫性のあるカラー、変換性能の向上、正確なプルーフィング、より効率的なクロスメディア出力などがあります。ただし、色域がデバイスごとに異なり、元のイメージとも異なるため、カラー管理では完全な変換はできない点にご注意ください。また、カラー管理では、カスタムプロファイルも編集済みプロファイルも必要ありません。カラープロファイルは、ブラウザー、オペレーティングシステム（OS）、OS 拡張、出力デバイス、アプリケーションサポートに依存します。</p>
     
     <p>カラー補正を適用すると、Flash Player のパフォーマンスが低下します。Flash Player のカラー補正は、ドキュメントスタイルのカラー補正です。このため、SWF ムービーはすべて暗黙の sRGB プロファイルを持つドキュメントと見なされます。<codeph>Stage.colorCorrectionSupport</codeph> プロパティを使用して、SWF (ドキュメント) をディスプレイカラースペースに表示するときに、最高レベルでカラー補正を行うことを Flash Player に通知します。Flash Player では、モニター間の補正のみを行い、カメラやスキャナーなどの入力デバイス間の補正は行いません。
     </p>
     
 	 <p>3 つの値として、flash.display.ColorCorrection クラスの対応する定数を持つストリングを使用できます。</p>
 	  <ul><li><codeph>"default"</codeph>：ホストシステムと同じカラー補正を使用します。</li> 
 	 <li><codeph>"on"</codeph>：常にカラー補正を実行します。</li>
 	 <li><codeph>"off"</codeph>：常にカラー補正を実行しません。</li>
 	 </ul>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrection"><linktext>flash.display.ColorCorrection</linktext></link><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>colorCorrectionSupport</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrectionSupport:get"><apiName>colorCorrectionSupport</apiName><shortdesc>
      Flash Player が実行されているオペレーティングシステムがカラー補正をサポートしているかどうか、および Flash Player がメイン (主) モニターのカラープロファイルを解読できるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>ColorCorrection
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
      Flash Player が実行されているオペレーティングシステムがカラー補正をサポートしているかどうか、および Flash Player がメイン (主) モニターのカラープロファイルを解読できるかどうかを示します。また、このプロパティはホストシステム (通常はブラウザー) のカラー補正のデフォルト状態を返します。現在、戻り値は次のとおりです。
 	  <p>3 つの値として、flash.display.ColorCorrectionSupport クラスの対応する定数を持つストリングを使用できます。</p>
 	   <ul><li><codeph>"unsupported"</codeph>：カラー補正を使用できません。</li> 
 	  <li><codeph>"defaultOn"</codeph>：常にカラー補正を実行します。</li>
 	  <li><codeph>"defaultOff"</codeph>：常にカラー補正を実行しません。</li>
 	  </ul>      
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrectionSupport"><linktext>flash.display.ColorCorrectionSupport</linktext></link><link href="flash.display.xml#Stage/colorCorrection"><linktext>colorCorrection</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:displayState:get"><apiName>displayState</apiName><shortdesc>
	 使用する表示状態を指定する StageDisplayState クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>displayState</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。設定ダイアログボックスの表示中にユーザー応答なしで <codeph>displayState</codeph> プロパティを設定しようとした場合や、<codeph>param</codeph> または <codeph>embed</codeph> HTML タグの <codeph>allowFullScreen</codeph> 属性が <codeph>true</codeph> に設定されていない場合は、セキュリティエラーがスローされます。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 使用する表示状態を指定する StageDisplayState クラスの値です。使用できる値は次のとおりです。 
	 
	 <ul>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN</codeph> キーボード入力を無効にして、ユーザーの画面全体にステージを拡張するように AIR アプリケーションまたは Flash Player が設定されます。</li>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> キーボード入力を許可して、ユーザーの画面全体にステージを拡張するように AIR アプリケーションが設定されます <ph platform="actionscript">(Flash Player で実行されるコンテンツについては使用できません)。</ph></li>
	 
     <li><codeph>StageDisplayState.NORMAL</codeph> によって、Flash Player を標準のステージ表示モードに戻します。</li>
	 
	 </ul> 
	 
     <p platform="actionscript">フルスクリーンモードでのムービーの拡大 / 縮小動作は、<codeph>scaleMode</codeph> 設定 (<codeph>Stage.scaleMode</codeph> プロパティまたは HTML ファイル内の SWF ファイルの <codeph>embed</codeph> タグ設定を使用して設定) で決定されます。アプリケーションがフルスクリーンモードに移行する際に、<codeph>scaleMode</codeph> プロパティが <codeph>noScale</codeph> に設定されていると、Stage の <codeph>width</codeph> プロパティと <codeph>height</codeph> プロパティが更新され、Stage の <codeph>resize</codeph> イベントが送出されます。</p>
     
     <p platform="actionscript">次の制限は、HTML ページで実行されている SWF ファイルに適用されます（スタンドアローンの Flash Player を使用する場合、または AIR ランタイムで実行されている場合には適用されません）。</p>
     
     <ul platform="actionscript">
	 
	 <li>フルスクリーンモードを有効にするには、次の例のように <codeph>allowFullScreen</codeph> パラメーターを SWF ファイルを含む HTML ページの <codeph>object</codeph> および <codeph>embed</codeph> タグに追加します。このとき、<codeph>allowFullScreen</codeph> は <codeph>"true"</codeph> に設定します。
	 
	 <codeblock>&lt;param name="allowFullScreen" value="true" />
	        ...
	 &lt;embed src="example.swf" allowFullScreen="true" ... ></codeblock>
	 
	 <p>HTML ページでは、スクリプトを使用して SWF 埋め込みタグを生成することもできます。<codeph>allowFullScreen</codeph> 設定が正しく挿入されるように、スクリプトを変更する必要があります。Flash および Flex Builder で生成された HTML ページでは、<codeph>AC_FL_RunContent()</codeph> 関数を使用して SWF ファイルへの参照を埋め込みます。ユーザーは、次のように <codeph>allowFullScreen</codeph> パラメーターの設定を追加する必要があります。</p>
	 
	 <codeblock>AC_FL_RunContent( ... "allowFullScreen", "true", ... )</codeblock></li>
	 
     <li>フルスクリーンモードは、マウスクリックまたはキー操作に対応して開始されます。ムービーでは、ユーザー入力なしに <codeph>Stage.displayState</codeph> を変更できません。Flash Player では、フルスクリーンモードでのキーボード入力は制限されます。入力可能なキーには、フルスクリーンモードを終了するキーボードショーカットや、矢印キー、スペースキー、Shift キー、Tab キーなどの非出力キーがあります。フルスクリーンモードは、次のキーボードショートカットで終了します。Esc キー（Windows、Linux、および Macintosh）、Ctrl + W （Windows）、Command + W （Macintosh）、および Alt + F4。
     <p>フルスクリーンモードに入ると、ムービーの上に Flash Player ダイアログボックスが表示されます。このダイアログボックスには、現在フルスクリーンモードであり、Esc キーを押すとフルスクリーンモードを終了できるというメッセージが表示されます。</p></li>
     <li>Flash Player 9.0.115.0 以降からは、ウィンドウモードの場合と同じようにウィンドウレスモードでフルスクリーンモードが動作するようになりました。ウィンドウモード（HTML では <codeph>wmode</codeph>）を不透明表示（<codeph>opaque</codeph>）または透明表示（<codeph>transparent</codeph>）に設定すると、フルスクリーンを開始できますが、フルスクリーンウィンドウは常に不透明になります。</li> 
	 
     </ul>
     
 	 <p platform="actionscript">これらの制約は、スタンドアローンの Flash Player または AIR ランタイムで実行されている SWF コンテンツには適用<i>されません</i>。AIR では、キーボード入力を許可するインタラクティブフルスクリーンモードがサポートされています。</p>  
	 
	 <p>フルスクリーンモードで実行される <ph platform="actionscript">AIR</ph> コンテンツの場合、システムのスクリーンセーバーと節電オプションは、ビデオコンテンツが再生中のときとビデオが停止するかフルスクリーンモードが終了するまで無効になっています。</p>
 	 
	 <p>Linux の場合、<codeph>displayState</codeph> を <codeph>StageDisplayState.FULL_SCREEN</codeph> または <codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> に設定する操作は非同期的に実行されます。</p>
    
	 </apiDesc><example conref="examples\StageExample2.as"> 次の例では、<codeph>displayState</codeph> プロパティを変更して、フルスクリーンにする方法のインタラクティブなデモンストレーションを作成しています。 <p><b>注意：</b>フルスクリーンは、ユーザーがキーをクリックまたは押した場合など、特定の状況においてのみ、セキュリティ上の制限のためにトリガーされます。ブラウザーで実行する場合、allowFullScreen プロパティを true に設定する必要があります。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Stage;
    import flash.events.*;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.media.Video;
    
    public class FullScreenExample extends Sprite
    {
        private var videoURL:String = "testVideo.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var video:Video;        
        
        public function FullScreenExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
            
            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK,toggleFullScreen);
        }        
        
        private function toggleFullScreen(event:MouseEvent):void {
            switch(stage.displayState) {
                case "normal":
                    stage.displayState = "fullScreen";    
                    break;
                case "fullScreen":
                default:
                    stage.displayState = "normal";    
                    break;
            }
        }    
        
        // Video related:
        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }
        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);

            video = new Video(stage.stageWidth,stage.stageHeight);
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:focus:get"><apiName>focus</apiName><shortdesc>
	 キーボードフォーカスを持つインタラクティブオブジェクトです。フォーカスが設定されていない場合、またはフォーカスが設定されたオブジェクトが呼び出し元オブジェクトからアクセスできないセキュリティ Sandbox に属している場合は null となります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier><apiException><apiDesc>ターゲットにフォーカスを設定できない場合にエラーがスローされます。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>キーボードフォーカスを持つオブジェクトです。
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 キーボードフォーカスを持つインタラクティブオブジェクトです。フォーカスが設定されていない場合、またはフォーカスが設定されたオブジェクトが呼び出し元オブジェクトからアクセスできないセキュリティ Sandbox に属している場合は <codeph>null</codeph> となります。
	 
	 </apiDesc><example conref="Stage.focus.as"> <codeph/>
<codeblock>
var myTF:TextField = new TextField();
myTF.border =true;
myTF.type = TextFieldType.INPUT;

addChild(myTF);
stage.focus= myTF;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Stage:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 ステージのフレームレートを取得または設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>frameRate</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 ステージのフレームレートを取得または設定します。フレームレートの定義は、1 秒あたりのフレーム数です。デフォルトでは、フレームレートは最初に読み込まれた SWF ファイルのものに設定されます。フレームレートの有効範囲は、1 秒あたり 0.01 から 1000 フレームです。 
	 
	 <p><codeph>注意：</codeph>ターゲットプラットフォームのフレーム設定が対応していないため、または Flash Player が表示デバイスの垂直帰線期間との同期が取れていないため、アプリケーションで高いフレームレートを設定できない場合があります。垂直帰線期間は、LCD デバイスでは通常 60 Hz です。CPU 使用率が高くなることが予想される場合、ターゲットプラットフォームの最大フレームレートを低くすることもできます。</p>
	 
	 <p>Adobe AIR で実行されるコンテンツの場合、Stage オブジェクトの <codeph>frameRate</codeph> プロパティを設定することで、さまざまな NativeWindow オブジェクトによって使用されるすべての Stage オブジェクトのフレームレートが変更されます。
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:fullScreenHeight:get"><apiName>fullScreenHeight</apiName><shortdesc>
  フルスクリーンサイズに移行したときに使用されるモニターの高さを返します（直ちに移行する場合)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  フルスクリーンサイズに移行したときに使用されるモニターの高さを返します（直ちに移行する場合)。ユーザーが複数のモニターを持っている場合、使用されるモニターは、そのときに最も多くのステージが表示されているモニターです。
  
  <p><b>注意：</b>値を取得してから、フルスクリーンサイズに移行するまでの間に、あるモニターから別のモニターにブラウザーを移動する機会がある場合、値が不正になる可能性があります。<codeph>Stage.displayState</codeph> を <codeph>StageDisplayState.FULL_SCREEN</codeph> に設定するイベントハンドラーで値を取得すると、値は正しくなります。</p>
  
  <p>これはモニターのピクセルの高さであり、<codeph>Stage.align</codeph> が <codeph>StageAlign.TOP_LEFT</codeph> に設定され、<codeph>Stage.scaleMode</codeph> が <codeph>StageScaleMode.NO_SCALE</codeph> に設定された場合には、ステージの高さと同じになります。</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> この例では、ステージのサイズの緑の矩形を作成し、その上にボタンとしてアクティブ化する赤い四角形を配置します。赤い四角形をクリックすると、<codeph>enterFullScreen()</codeph> イベントハンドラーがトリガーされます。このイベントハンドラーにより、<codeph>fullScreenSourceRect</codeph> プロパティが設定され、フルスクリーンモードに入ります。<codeph>fullScreenSourceRect</codeph> プロパティを設定するため、イベントハンドラーは赤い四角形の位置とサイズで開始します。次に、赤い四角形の縦横比（幅を高さで割った比率）をフルスクリーンのステージの幅と高さの縦横比と比較し、矩形（<codeph>fullScreenSourceRect</codeph>）を拡大して画面の縦横比に一致するようにします。この結果、赤い四角形がモニターの高さいっぱいに表示され、両側に緑の背景が表示されます。縦横比を一致させなかった場合、緑の背景の代わりにステージの背景色（デフォルトは白）が両側に表示されます。
 
 <p><b>注意：</b>ブラウザーでこの例を試してみてください。Flash のパブリッシュ設定ダイアログボックスの「HTML」タブで、テンプレート「Flash のみ - フルスクリーンサポート」を選択します。Flash Player のバージョン 9.0.115.0 を指定し、「形式」タブで Flash 形式および HTML 形式が選択されていることを確認します。パブリッシュし、生成される HTML ファイルをブラウザーで開きます。</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/fullScreenWidth"><linktext>fullScreenWidth</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenSourceRect:get"><apiName>fullScreenSourceRect</apiName><shortdesc>
  ステージの特定の領域を Flash Player で拡大 / 縮小してフルスクリーンモードにするように設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
  ステージの特定の領域を Flash Player で拡大 / 縮小してフルスクリーンモードにするように設定します。可能な場合、拡大 / 縮小は、ユーザーのコンピューター上でグラフィックカードやビデオカードを使用してハードウェアで行われます。通常、この方が、ソフトウェアで拡大 / 縮小するよりもすばやくコンテンツが表示されます。
  
  <p>このプロパティを有効な矩形に設定し、<codeph>displayState</codeph> プロパティをフルスクリーンモードに設定すると、指定された領域が Flash Player により拡大 / 縮小されます。ActionScript 内の実際のステージサイズ（ピクセル単位）は変更されません。標準の "フルスクリーンモードを終了するには、Esc キーを押します" というメッセージに対応するため、矩形のサイズに最小限度が適用されます。通常、この限度は約 260 × 30 ピクセルですが、プラットフォームおよび Flash Player のバージョンによって異なる場合があります。</p>
  
  <p>このプロパティを設定できるのは、Flash Player がフルスクリーンモードでない場合のみです。このプロパティを正しく使用するには、コード例に示すように、このプロパティを最初に設定し、次に <codeph>displayState</codeph> プロパティをフルスクリーンモードに設定します。</p>
  <p>拡大 / 縮小を有効にするには、次のように <codeph>fullScreenSourceRect</codeph> プロパティを矩形オブジェクトに設定します。</p>
  <codeblock>  
  // valid, will enable hardware scaling
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240); 
  </codeblock>
  
  <p>拡大 / 縮小を無効にするには、ActionScript 3.0 では <codeph>fullScreenSourceRect=null</codeph> に設定し、ActionScript 2.0 では <codeph>undefined</codeph> に設定します。</p>
  <codeblock>
  stage.fullScreenSourceRect = null;
  </codeblock>
  
  <p>エンドユーザーが Flash Player の表示設定を使用して、ハードウェアの拡大 / 縮小をオフにすることもできます。この機能はデフォルトでは有効になっています。詳細については、<xref href="http://www.adobe.com/go/display_settings_jp" scope="external">www.adobe.com/go/display_settings_jp</xref> を参照してください。</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenSourceRect.1.as"> ハードウェアの拡大 / 縮小機能を活用するには、ステージ全体またはステージの一部をフルスクリーンモードに設定します。次の ActionScript 3.0 コードでは、ステージ全体をフルスクリーンモードに設定します。
<codeblock>
 
import flash.geom.*; 
{
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
  stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example><example conref="examples\Stage_fullScreenSourceRectExample2.as"> 次の例では、ユーザーはステージをクリックすることで、ビデオ再生をフルスクリーンと通常のスクリーンで切り替えることができます。この例の SWF を Flash Player 9.0.115.0 以降で実行する場合はハードウェアアクセラレーターが使用され、フルスクリーンでの拡大表示時の性能が向上します。
  
 <p>ハードウェアの拡大 / 縮小機能を利用してフルスクリーンモードを使用する場合は、次の条件を満たしていなければなりません。</p>
 
 <ol>
 <li>Flash Player バージョン 9.0.115.0 以降と、これらをサポートするオーサリングツールが必要です。</li>
 <li>フルスクリーンをサポートするように HTML テンプレートを修正する必要があります。<codeph>allowFullScreen</codeph> 属性を <codeph>true</codeph> に設定する必要があります（<codeph>object</codeph> および <codeph>embed</codeph> タグに対して）（SWF 埋め込みタグを生成するスクリプトも、フルスクリーンを許可している必要があります）。 Flex Builder で使用できるファイルのサンプルについては、記事「<xref href="http://www.adobe.com/jp/devnet/flashplayer/articles/full_screen_mode.html" scope="external">Flash Player 9 のフルスクリーンモードの説明</xref>」を参照してください。</li>
 <li>アプリケーションが、FLV ビデオファイルに対するアクセス権を所有している必要があります。 この例では、Flash Video（FLV）ファイルが SWF ファイルと同じディレクトリにあると想定しています。</li>
 <li>ユーザーが、フルスクリーンへのアクセスを許可する必要があります。</li>
 <li>ハードウェアの拡大 / 縮小機能の詳細については、Flash Player の記事<xref href="http://www.adobe.com/jp/devnet/flashplayer/articles/hd_video_flash_player.html" scope="external">「Flash Player における高解像度 H.264 ビデオおよび AAC オーディオのサポートについての説明</xref>」を参照してください。</li>
 </ol>
 
 <p>FLV ファイルは、NetConnection オブジェクトおよび NetStream オブジェクトを使用してロードします。 FLV ファイルが SWF ファイルと同じディレクトリにあり、HTTP 経由で接続するので、<codeph>NetConnection.connect()</codeph> メソッドのパラメーターは <codeph>null</codeph> に設定されます。 <codeph>connect</codeph> NetConnection オブジェクトは、<codeph>netStatus</codeph> イベント（<codeph>netStatusHandler()</codeph> メソッドを呼び出すイベント）を送出して状態を報告します。 <codeph>netStatusHandler()</codeph> メソッドは、接続が正常に確立しているかどうかチェックして <codeph>connectStream()</codeph> メソッドを呼び出します。このメソッドは、パラメーターとして NetConnection オブジェクトを取る NetStream オブジェクトを作成します。また、ビデオオブジェクトを作成し、このビデオオブジェクトに NetStream オブジェクトを追加します。このビデオオブジェクトは表示リストに追加され、ストリームを再生するように設定されます。FLV ビデオファイルにはメタデータまたはキューポイントの情報が含まれていないので、<codeph>AsyncError</codeph> イベントが送出されます。このイベントを処理するためにリスナーを設定する必要があります。ここではリスナーを設定しますが、このイベントは無視されます。<codeph>netStatus</codeph> イベントを受け取る別のリスナーも、NetStream オブジェクトに対して設定します。ストリームが見つからない場合は、エラーメッセージが表示されます（<codeph>netStatusHandler()</codeph> は、ストリームまたは接続に関する何種類もの状態の報告を処理するために使用される場合があることに注意してください）。</p>
 
 <p>ロードされた SWF ファイルのプロパティおよびメソッドにアクセスできる場合、<codeph>createMouseListener()</codeph> メソッドが呼び出されます。このメソッドは、ステージ上でマウスがクリックされた場合にイベントを受け取るイベントリスナーを設定します。<codeph>toggleFullScreen()</codeph> メソッドは、表示状態がフルスクリーンモードか通常スクリーンモードかをチェックします。通常スクリーンの場合、ビデオオブジェクトのサイズは、ビデオストリームのサイズに設定されます。<codeph>fullScreenSourceRect</codeph> プロパティは、ビデオオブジェクトのサイズに一致する矩形に設定されます。<codeph>Stage.displayMode</codeph> プロパティはフルスクリーンに設定されます。これにより、ソース矩形のビデオが、フルスクリーン領域いっぱいまで拡大されます。システム要件を満たす場合は、マシンのグラフィックハードウェアを使用してフルスクリーンでのビデオのレンダリングのパフォーマンスを向上させます。また、表示状態がフルスクリーンモードに設定されます。フルスクリーンモードへの切り替え時に発生する可能性のあるセキュリティエラーをキャッチするために、<codeph>try...catch</codeph> が使用されます（表示状態は、<codeph>fullScreenSourceRect</codeph> プロパティを設定してからフルスクリーンモードに設定する必要があることに注意してください）。通常スクリーンモードに切り替わる前に、ビデオオブジェクトの幅と高さは、保存されている元のビデオオブジェクトの幅と高さに戻ります。また、フルスクリーンモードでビデオオブジェクトに変更が加えられた場合は、それによって幅と高さが決定されます。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageDisplayState;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.NetStatusEvent;
    import flash.events.AsyncErrorEvent;
    import flash.events.SecurityErrorEvent;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.geom.Rectangle;
    
    public class Stage_fullScreenSourceRectExample2 extends Sprite {
        private var videoURL:String = "testVideo1.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var myVideo:Video;        
        private    var savedWidth:uint;
        private    var savedHeight:uint;
 
        public function Stage_fullScreenSourceRectExample2() {
    
            connection = new NetConnection();
             connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);    
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);

            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK, toggleFullScreen);
        }        

        private function toggleFullScreen(event:MouseEvent):void {

            if(stage.displayState == StageDisplayState.NORMAL) {
                myVideo.width = myVideo.videoWidth;
                  myVideo.height = myVideo.videoHeight;

                try {
                    stage.fullScreenSourceRect = new Rectangle(myVideo.x, myVideo.y, 
                                                           myVideo.width, myVideo.height);
                     stage.displayState = StageDisplayState.FULL_SCREEN;

                 } catch (e:SecurityError) {
                     trace ("A security error occurred while switching to full screen: " + event);
                    myVideo.width = savedWidth;
                    myVideo.height = savedHeight;
                 }

            }else {
                myVideo.width = savedWidth;
                myVideo.height = savedHeight;
                stage.displayState = StageDisplayState.NORMAL;
            }
        }    

       private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace ("Unable to locate video: " + videoURL);
                    break;
            }
        }

       private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);     

             myVideo = new Video();
            myVideo.attachNetStream(stream);
            stream.play(videoURL);

            savedWidth = myVideo.width;
            savedHeight = myVideo.height;

            addChild(myVideo);
        }
       
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);    
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/displayState"><linktext>Stage.displayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenWidth:get"><apiName>fullScreenWidth</apiName><shortdesc>
  フルスクリーンサイズに移行したときに使用されるモニターの幅を返します（直ちに移行する場合）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  フルスクリーンサイズに移行したときに使用されるモニターの幅を返します（直ちに移行する場合）。ユーザーが複数のモニターを持っている場合、使用されるモニターは、そのときに最も多くのステージが表示されているモニターです。 
  
  <p><b>注意：</b>値を取得してから、フルスクリーンサイズに移行するまでの間に、あるモニターから別のモニターにブラウザーを移動する機会がある場合、値が不正になる可能性があります。<codeph>Stage.displayState</codeph> を <codeph>StageDisplayState.FULL_SCREEN</codeph> に設定するイベントハンドラーで値を取得すると、値は正しくなります。</p>
  
  <p>これはモニターのピクセル幅であり、<codeph>Stage.align</codeph> が <codeph>StageAlign.TOP_LEFT</codeph> に設定され、<codeph>Stage.scaleMode</codeph> が <codeph>StageScaleMode.NO_SCALE</codeph> に設定された場合には、ステージ幅と同じになります。</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> この例では、ステージのサイズの緑の矩形を作成し、その上にボタンとしてアクティブ化する赤い四角形を配置します。赤い四角形をクリックすると、<codeph>enterFullScreen()</codeph> イベントハンドラーがトリガーされます。このイベントハンドラーにより、<codeph>fullScreenSourceRect</codeph> プロパティが設定され、フルスクリーンモードに入ります。<codeph>fullScreenSourceRect</codeph> プロパティを設定するため、イベントハンドラーは赤い四角形の位置とサイズで開始します。次に、赤い四角形の縦横比（幅を高さで割った比率）をフルスクリーンのステージの幅と高さの縦横比と比較し、矩形（<codeph>fullScreenSourceRect</codeph>）を拡大して画面の縦横比に一致するようにします。この結果、赤い四角形がモニターの高さいっぱいに表示され、両側に緑の背景が表示されます。縦横比を一致させなかった場合、緑の背景の代わりにステージの背景色（デフォルトは白）が両側に表示されます。
 
 <p><b>注意：</b>ブラウザーでこの例を試してみてください。Flash のパブリッシュ設定ダイアログボックスの「HTML」タブで、テンプレート「Flash のみ - フルスクリーンサポート」を選択します。Flash Player のバージョン 9.0.115.0 を指定し、「形式」タブで Flash 形式および HTML 形式が選択されていることを確認します。パブリッシュし、生成される HTML ファイルをブラウザーで開きます。</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenHeight"><linktext>fullScreenHeight</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:height:get"><apiName>height</apiName><shortdesc>
	 
     表示オブジェクトの高さを示します（ピクセル単位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>height</codeph> プロパティを参照すると、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Stage オブジェクトの <codeph>height</codeph> プロパティの設定は、呼び出し元オブジェクトがステージ所有者のメイン SWF ファイルである場合でも無効です。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     表示オブジェクトの高さを示します（ピクセル単位）。この高さは、表示オブジェクトのコンテンツの境界に基づいて計算されます。次のコードに示すように、この <codeph>height</codeph> プロパティを設定すると、それに合わせて <codeph>scaleY</codeph> プロパティの値が調整されます。
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>TextField と Video オブジェクトを除いて、<codeph>height</codeph> を別の値に設定しようとしても、コンテンツのない表示オブジェクト (たとえば、空のスプラインなど) の高さは 0 になります。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 
	 オブジェクトの子に対してマウスが有効かどうかを調べます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>mouseChildren</codeph> プロパティを参照すると、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 オブジェクトの子に対してマウスが有効かどうかを調べます。オブジェクトが使用可能なマウスの場合、マウスを使用して対話できます。デフォルト値は <codeph>true</codeph> です。
	 
	 <p>このプロパティは、SimpleButton クラスではなく、Sprite クラスのインスタンスを使用してボタンを作成するときに役立ちます。Sprite インスタンスを使用してボタンを作成する場合、他の Sprite インスタンスを追加するために <codeph>addChild()</codeph> メソッドを使用してボタンの修飾を選択できます。子として追加する Sprite インスタンスは、親インスタンスをターゲットオブジェクトとすることを想定するときに、マウスイベントのターゲットオブジェクトとなる場合があるため、マウスイベントについて予期しない動作を引き起こす可能性があります。親インスタンスが確実にマウスイベントのターゲットオブジェクトになるようにするには、親インスタンスの <codeph>mouseChildren</codeph> プロパティを <codeph>false</codeph> に設定します。</p>
	 <p> このプロパティを設定しても、イベントは送出されません。インタラクティブな機能を作成するには、<codeph>addEventListener()</codeph> メソッドを使用する必要があります。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:nativeWindow:get"><apiName>nativeWindow</apiName><shortdesc>
	 このステージを含む NativeWindow オブジェクトへの参照です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
	 このステージを含む NativeWindow オブジェクトへの参照です。 
	 
	 <p>window は、ネイティブのオペレーティングシステムのウィンドウを表します。Stage は、そのウィンドウに含まれるコンテンツを表します。このプロパティは、AIR で実行されているコンテンツでのみ有効です。Flash Player（ブラウザーで実行されているコンテンツ）では、このプロパティは <codeph>null</codeph> になります。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 
	 このオブジェクトの子の数を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>numChildren</codeph> プロパティを参照すると、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 このオブジェクトの子の数を返します。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:quality:get"><apiName>quality</apiName><shortdesc>
	 使用するレンダリング品質を指定する StageQuality クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>quality</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 使用するレンダリング品質を指定する StageQuality クラスの値です。使用できる値は次のとおりです。
	 
	 <ul>
	 
	 <li><codeph>StageQuality.LOW</codeph> — 低いレンダリング品質。グラフィックはアンチエイリアス処理されず、ビットマップはスムージングされませんが、ランタイムでは依然としてミップマッピングが使用されます。この設定は Adobe AIR ではサポートされません。</li>
	 
	 <li><codeph>StageQuality.MEDIUM</codeph> — 普通のレンダリング品質。グラフィックは 2 x 2 ピクセルグリッドを使用してアンチエイリアス処理され、ビットマップのスムージングは <codeph>Bitmap.smoothing</codeph> 設定に応じて処理されます。ランタイムではミップマッピングが使用されます。この設定は、テキストを含まないムービーに適しています。この設定は Adobe AIR ではサポートされません。</li>
	 
	 <li><codeph>StageQuality.HIGH</codeph> — 高いレンダリング品質。グラフィックは 4 x 4 ピクセルグリッドを使用してアンチエイリアス処理され、ビットマップのスムージングは <codeph>Bitmap.smoothing</codeph> 設定に応じて処理されます。ランタイムではミップマッピングが使用されます。これは、Flash Player が使用するデフォルトのレンダリング品質設定です。</li>
	 
	 <li><codeph>StageQuality.BEST</codeph> — 非常に高いレンダリング品質。グラフィックは 4 x 4 ピクセルグリッドを使用してアンチエイリアス処理されます。<codeph>Bitmap.smoothing</codeph> が <codeph>true</codeph> の場合、ランタイムでは、高品質のダウンスケールアルゴリズムが使用され、生成されるアーティファクトの数は減少します（ただし、<codeph>Bitmap.smoothing</codeph> に <codeph>true</codeph> を設定した状態で <codeph>StageQuality.BEST</codeph> を使用すると、パフォーマンスが大幅に低下するので、この組み合わせは使用しないことをお勧めします）。</li>
	 
	 </ul>
	 
	 <p>品質設定が高ければ高いほど、拡大 / 縮小されたビットマップのよりよいレンダリングが生成されます。ただし、品質設定が高くなればなるほど計算上のコストも高くなります。特に、拡大 / 縮小されたビデオをレンダリングするときには、より高い品質の設定を使用するほうがフレームレートを減らすことができます。
	 </p>
	 
	 <p>Adobe AIR で実行されるコンテンツの場合、<codeph>quality</codeph> は <codeph>StageQuality.BEST</codeph> または <codeph>StageQuality.HIGH</codeph> に設定できます（また、デフォルト値は <codeph>StageQuality.HIGH</codeph> になります）。別の値に設定しても無視されます（プロパティは変更されません）。
	 </p>
	 
	 <p>Adobe AIR で実行されるコンテンツの場合、Stage オブジェクトの <codeph>quality</codeph> プロパティを設定することで、さまざまな NativeWindow オブジェクトによって使用されるすべての Stage オブジェクトのレンダリング品質が変更されます。
	 </p>
	 
	 <b> <i>注意：</i></b>オペレーティングシステムはデバイスフォントを描画します。デバイスフォントは <codeph>quality</codeph> プロパティの影響を受けません。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageQuality"><linktext>flash.display.StageQuality</linktext></link><link href="flash.display.xml#Bitmap/smoothing"><linktext>flash.display.Bitmap.smoothing</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
	 使用する拡大 / 縮小モードを指定する StageScaleMode クラスの値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>scaleMode</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>使用する拡大 / 縮小モードを指定する StageScaleMode クラスの値です。
 	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 使用する拡大 / 縮小モードを指定する StageScaleMode クラスの値です。使用できる値は次のとおりです。
	 
     <ul>
     
     <li><codeph>StageScaleMode.EXACT_FIT</codeph> — 指定された領域にちょうど収まるようにアプリケーション全体が表示され、元の縦横比は保たれません。歪みが発生し、アプリケーションが引き伸ばしたり圧縮したりしたように表示されることがあります。
     </li>
     
     <li><codeph>StageScaleMode.SHOW_ALL</codeph> — 指定された領域内にアプリケーション全体が、アプリケーションの元の縦横比を維持したまま歪まずに表示されます。ただし、アプリケーションの両側に境界枠が表示されることがあります。   
     </li>
     
	 <li><codeph>StageScaleMode.NO_BORDER</codeph> — 指定された領域いっぱいにアプリケーション全体が歪まずに表示されます。ただし、アプリケーションの元の縦横比を保つために、ある程度トリミングされることがあります。
	 </li>
	 
	 <li><codeph>StageScaleMode.NO_SCALE</codeph> — アプリケーションの全体のサイズが固定され、プレーヤーウィンドウのサイズが変更された場合でも、サイズが維持されます。Flash Player のウィンドウがコンテンツよりも小さい場合は、トリミングされることがあります。
	 </li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:showDefaultContextMenu:get"><apiName>showDefaultContextMenu</apiName><shortdesc>
     Flash Player のコンテキストメニューにデフォルトの項目を表示するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>showDefaultContextMenu</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Flash Player のコンテキストメニューにデフォルトの項目を表示するかどうかを指定します。
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Flash Player のコンテキストメニューにデフォルトの項目を表示するかどうかを指定します。
     
     <p><codeph>showDefaultContextMenu</codeph> プロパティを <codeph>true</codeph> に設定すると、すべてのコンテキストメニュー項目が表示されます。これがデフォルトです。<codeph>showDefaultContextMenu</codeph> プロパティを <codeph>false</codeph> に設定すると、メニュー項目として [設定] および [Adobe Flash Player について] だけが表示されます。</p>
     
 	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageFocusRect:get"><apiName>stageFocusRect</apiName><shortdesc>
	 オブジェクトがフォーカスを持つ場合に強調表示された境界線を表示するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>stageFocusRect</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>オブジェクトがフォーカスを持つ場合に強調表示された境界線を表示するかどうかを指定します。
	 
 	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 オブジェクトがフォーカスを持つ場合に強調表示された境界線を表示するかどうかを指定します。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageHeight:get"><apiName>stageHeight</apiName><shortdesc>
     現在のステージの高さ（ピクセル数）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>stageHeight</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     現在のステージの高さ（ピクセル数）です。
     
     <p>ユーザーがウィンドウのサイズを変更するときに <codeph>Stage.scaleMode</codeph> プロパティの値が <codeph>StageScaleMode.NO_SCALE</codeph> に設定された場合、<codeph>stageHeight</codeph> プロパティが SWF ファイルで占有された画面領域の新しい高さサイズを反映するように変更されても、Stage コンテンツはそのサイズを維持します(他の伸縮モードでは、<codeph>stageHeight</codeph> プロパティは常に SWF ファイルの元の高さを反映します)。<codeph>resize</codeph> イベントにイベントリスナーを追加してから、Stage クラスの <codeph>stageHeight</codeph> プロパティを使用してサイズが変更された Flash Player ウィンドウの実際のピクセルサイズを決定することができます。イベントリスナーでは、ユーザーがウィンドウのサイズを変更するときに画面コンテンツがどのように調整されるかを制御できます。</p>
	 
	 <p><b>注意：</b> SWF ファイルをホスティングする HTML ページでは、<codeph>object</codeph> タグおよび <codeph>embed</codeph> タグの <codeph>height</codeph> 属性はピクセル単位ではなくパーセンテージ（<codeph>100%</codeph> など）で設定する必要があります。設定が JavaScript コードによって設定される場合、<codeph>height</codeph> パラメーター（<codeph>AC_FL_RunContent()</codeph> メソッドのパラメーター）もパーセンテージで設定する必要があります。このパーセンテージは <codeph>stageHeight</codeph> 値に適用されます。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:stageWidth:get"><apiName>stageWidth</apiName><shortdesc>
     ステージの現在の幅をピクセル単位で指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>stageWidth</codeph> プロパティを呼び出すと、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     ステージの現在の幅をピクセル単位で指定します。
     
     
     <p>ユーザーがウィンドウのサイズを変更するときに <codeph>Stage.scaleMode</codeph> プロパティの値が <codeph>StageScaleMode.NO_SCALE</codeph> に設定された場合、<codeph>stageWidth</codeph> プロパティが SWF ファイルで占有された画面領域の新しい幅サイズを反映するように変更されても、Stage コンテンツは定義済みのサイズを維持します(他の伸縮モードでは、<codeph>stageWidth</codeph> プロパティは常に SWF ファイルの元の幅を反映します)。<codeph>resize</codeph> イベントにイベントリスナーを追加してから、Stage クラスの <codeph>stageWidth</codeph> プロパティを使用してサイズが変更された Flash Player ウィンドウの実際のピクセルサイズを決定することができます。イベントリスナーでは、ユーザーがウィンドウのサイズを変更するときに画面コンテンツがどのように調整されるかを制御できます。</p>
	 
     <p><b>注意：</b> SWF ファイルをホスティングする HTML ページでは、<codeph>object</codeph> タグおよび <codeph>embed</codeph> タグの <codeph>width</codeph> 属性はピクセル単位ではなくパーセンテージ（<codeph>100%</codeph> など）で設定する必要があります。設定が JavaScript コードによって生成される場合、<codeph>width</codeph> パラメーター（<codeph>AC_FL_RunContent()</codeph> メソッドのパラメーター）もパーセンテージで設定する必要があります。このパーセンテージは <codeph>stageWidth</codeph> 値に適用されます。</p>
     
 	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 
	 オブジェクトの子に対してタブが有効かどうかを調べます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>tabChildren</codeph> プロパティを参照すると、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 オブジェクトの子に対してタブが有効かどうかを調べます。オブジェクトの子に対してタブを有効または無効にします。デフォルト値は <codeph>true</codeph> です。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
	 
     この DisplayObjectContainer インスタンスの TextSnapshot オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>textSnapshot</codeph> プロパティを参照すると、Stage クラスがこのプロパティを実装しないため、例外がスローされます。これを回避するには、Stage オブジェクト以外の表示オブジェクトコンテナの <codeph>textSnapshot</codeph> プロパティを呼び出します。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     この DisplayObjectContainer インスタンスの TextSnapshot オブジェクトを返します。
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:width:get"><apiName>width</apiName><shortdesc>
	 
     表示オブジェクトの幅を示します（ピクセル単位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Stage オブジェクトの <codeph>width</codeph> プロパティを参照すると、ステージ所有者と同じセキュリティ Sandbox 内にない呼び出し元について例外がスローされます。この場合のステージ所有者とはメイン SWF ファイルです。これを回避するには、ステージ所有者が <codeph>Security.allowDomain()</codeph> メソッドまたは <codeph>Security.allowInsecureDomain()</codeph> メソッドを呼び出して呼び出し元のドメインに許可を与えるようにします。詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Stage オブジェクトの <codeph>width</codeph> プロパティの設定は、システム管理者の場合でも無効です。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     表示オブジェクトの幅を示します（ピクセル単位）。この幅は、表示オブジェクトのコンテンツの境界に基づいて計算されます。次のコードに示すように、この <codeph>width</codeph> プロパティを設定すると、それに合わせて <codeph>scaleX</codeph> プロパティの値が調整されます。
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>TextField と Video オブジェクトを除いて、<codeph>width</codeph> を別の値に設定しようとしても、コンテンツのない表示オブジェクト（例えば、空のスプラインなど）の幅は 0 になります。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:wmodeGPU:get"><apiName>wmodeGPU</apiName><shortdesc>
	 GPU 合成が使用可能であり使用中かどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 GPU 合成が使用可能であり使用中かどうかを示します。<codeph>wmodeGPU</codeph> の値は、次の 3 つの条件すべてに当てはまる場合に<i>のみ</i>、<codeph>true</codeph> になります。
	 <p><ul><li>GPU 合成が要求されている。</li>
	 <li>GPU 合成が使用可能である。</li>
	 <li>GPU 合成が使用中である。</li></ul></p>
	 <p>具体的には、<codeph>wmodeGPU</codeph> プロパティは次のいずれかを示します。</p>
	 <p><ol><li>GPU 合成が要求されていないか、使用可能ではありません。この場合、<codeph>wmodeGPU</codeph> プロパティの値は <codeph>false</codeph> になります。</li>
	 <li>GPU 合成は要求されましたが（適用可能で使用可能な場合）、コンテンツの制約により、環境は（最善のレンダリングモードではなく）代替モードで動作しています。この場合、<codeph>wmodeGPU</codeph> プロパティの値は <codeph>true</codeph> になります。</li>
	 <li>GPU 合成が要求され（適用可能で使用可能な場合）、環境は最善のモードで動作しています。この場合も、<codeph>wmodeGPU</codeph> プロパティの値は <codeph>true</codeph> になります。</li></ol></p>
	 <p>つまり、<codeph>wmodeGPU</codeph> プロパティは、レンダリング環境の機能と状態を示します。（先に説明したように）値が <codeph>true</codeph> になるのは GPU 合成が要求され、使用可能であり、使用中である場合だけなので、GPU 合成をサポートしないランタイム（AIR 1.5.2 など）の場合、この値は常に <codeph>false</codeph> になります。</p>
	 <p><codeph>wmodeGPU</codeph> プロパティは、GPU 合成が使用中かどうかを実行時に判定するのに便利です。<codeph>wmodeGPU</codeph> の値は、コンテンツの伸縮がハードウェアによって処理されるかどうかを示すので、グラフィックを正しいサイズで表示できます。また、高速でレンダリングを行っているかどうかも判別できるので、それに応じてコンテンツの複雑度を調節できます。</p>
	 <p>ブラウザー内で Flash Player を実行する場合は、SWF ファイルを呼び出すページの <codeph>wmode</codeph> HTML パラメーターを <codeph>gpu</codeph> に設定することで、GPU 合成を要求できます。その他の構成の場合は、SWF ファイルのヘッダーで GPU 合成を要求できます（SWF 作成ツールを使用して設定します）。</p>	 
	 <p>ただし、<codeph>wmodeGPU</codeph> プロパティでは、現在のレンダリングパフォーマンスは判別できません。GPU 合成が使用中であっても、レンダリングプロセスは最善のモードで動作していない可能性があります。最善のレンダリングが行われるようにコンテンツを調節するには、Flash のランタイムデバッガーバージョンを使用し、mm.cfg ファイルで <codeph>DisplayGPUBlendsetting</codeph> を設定します。</p>
	 
	 <p><b>注意：</b> 最初のレンダリングパスが開始される前に実行される ActionScript からこのプロパティを参照すると、この値は常に <codeph>false</codeph> になります。例えば、Adobe Flash Professional のフレーム 1 のスクリプトから <codeph>wmodeGPU</codeph> を調べる場合、その SWF ファイルがランタイムの新しいインスタンスに最初にロードされる SWF ファイルであるときは、<codeph>wmodeGPU</codeph> の値が <codeph>false</codeph> になります。正しい値を取得するには、少なくとも最初のレンダリングパスが発生するまで待つ必要があります。<codeph>DisplayObject</codeph> の <codeph>exitFrame</codeph> イベントに対するイベントリスナーを作成すると、<codeph>wmodeGPU</codeph> の値は正しい値になります。</p>
	 
	 </apiDesc><example conref="examples\Stage.wmodeGPU.as"> 次の例では、表示オブジェクト mySprite がレンダリングされた後に <codeph>wmodeGPU</codeph> プロパティを調べているので、正しい値を取得できます。
<codeblock>
mySprite.addEventListener(EXIT_FRAME, exithandler):

function exithandler(exiteventobject:Event):void {
                trace(stage.wmodeGPU);
}
</codeblock></example></apiValueDetail><related-links><link href="DisplayObject.html#event:exitFrame"><linktext>DisplayObject exitFrame イベント</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	 NativeWindowInitOptions クラスは、新しい NativeWindow インスタンスを作成するのに使用される初期化オプションを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 NativeWindowInitOptions クラスは、新しい NativeWindow インスタンスを作成するのに使用される初期化オプションを定義します。 
	 <p>この初期化オプションで定義されたプロパティは、ウィンドウが作成された後に変更することはできません。</p>
	 
	 <p><b>注意：</b> AIR によって自動的に作成された最初のアプリケーションウィンドウでは、これらのすべてのプロパティ（<codeph>type</codeph> 以外）がアプリケーション記述子に設定されます。最初のウィンドウのタイプは常に normal です。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links><apiConstructor id="flash.display:NativeWindowInitOptions:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	    新しい NativeWindowInitOptions オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	    新しい NativeWindowInitOptions オブジェクトを作成します。
	    
        <p>新しく作成されたオブジェクトのデフォルト値は次のとおりです。</p>
	    <ul>
        <li><codeph>systemChrome = NativeWindowSystemChrome.STANDARD</codeph></li>
        <li><codeph>type = NativeWindowType.NORMAL</codeph></li>
	    <li><codeph>transparent = false</codeph></li>
	    <li><codeph>resizable = true</codeph></li>
	    <li><codeph>maximizable = true</codeph></li>
	    <li><codeph>minimizable = true</codeph></li>
	    </ul>
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:NativeWindowInitOptions:maximizable:get"><apiName>maximizable</apiName><shortdesc>
		 ユーザーがウィンドウを最大化できるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MAXIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ユーザーがウィンドウを最大化できるかどうかを指定します。  
		 
		 <p>
		 システムクロムを使用するウィンドウの場合、この設定はウィンドウの最大化ボタンの外観に影響を与えます。また、Microsoft Windows のウィンドウメニューなど、システムが管理するユーザーインターフェイスのその他の部分にも影響します。
		 </p>
		 
		 <p>
		 <codeph>false</codeph> に設定されている場合、ユーザーはウィンドウを最大化できません。NativeWindow <codeph>maximize()</codeph> メソッドを直接呼び出すと、ウィンドウは最大化されます。
		 </p>
		 
		 <p><b>注意：</b>Mac OS X など、ウィンドウを最大化してもサイズ変更が可能なオペレーティングシステムでは、<codeph>maximizable</codeph> および <codeph>resizable</codeph> を両方とも <codeph>false</codeph> に設定し、ウィンドウを拡大またはサイズ変更できないようにする必要があります。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:minimizable:get"><apiName>minimizable</apiName><shortdesc>
		 ユーザーがウィンドウを最小化できるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MINIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ユーザーがウィンドウを最小化できるかどうかを指定します。
		 
		 <p>
		 システムクロムを使用するウィンドウの場合、この設定はウィンドウの最小化ボタンの外観に影響を与えます。また、Microsoft Windows のウィンドウメニューなど、システムが管理するユーザーインターフェイスのその他の部分にも影響します。
		 </p>
		 
		 <p>
		 <codeph>false</codeph> に設定されている場合、ユーザーはウィンドウを最小化できません。NativeWindow <codeph>minimize()</codeph> メソッドを直接呼び出すと、ウィンドウは最小化されます。
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:resizable:get"><apiName>resizable</apiName><shortdesc>
		 ユーザーがウィンドウのサイズを変更できるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_SIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ユーザーがウィンドウのサイズを変更できるかどうかを指定します。
		 
		 <p>
		 <codeph>false</codeph> に設定されている場合、ユーザーはシステムクロムを使用してウィンドウのサイズを変更できません。NativeWindow <codeph>startResize()</codeph> メソッドをマウスイベントに応答して呼び出すと、ユーザーはウィンドウのサイズを変更できます。ウィンドウの境界を直接設定して、ウィンドウのサイズを変更することもできます。
		 </p>
		 
		 <p><b>注意：</b>Mac OS X など、ウィンドウの最大化がサイズ変更操作として扱われるオペレーティングシステムでは、<codeph>maximizable</codeph> および <codeph>resizable</codeph> を両方とも <codeph>false</codeph> に設定し、ウィンドウを拡大またはサイズ変更できないようにする必要があります。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
		 ウィンドウでシステムクロムを使用するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowSystemChrome.STANDARD
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ウィンドウでシステムクロムを使用するかどうかを指定します。 
		  
		 <p> クロムは、ウィンドウのデスクトッププロパティの制御をユーザーに許可しているウィンドウコントロールを参照します。システムクロムは、AIR アプリケーションが実行されるデスクトップ環境の標準コントロールを使用し、ネイティブオペレーティングシステムの標準的な外観と使用感に従います。</p>
		 <p>
		 フレームワーク（Flex など）から提供されているクロムを使用する場合、または独自のウィンドウクロムを提供する場合は、<codeph>systemChrome</codeph> を <codeph>NativeWindowSystemChrome.NONE</codeph> に設定します。
		 </p>
		 <p>このプロパティの有効な値の定数は、NativeWindowSystemChrome クラスで定義されます。
         </p>
		 <ul>
         <li><codeph>NativeWindowSystemChrome.NONE</codeph></li>
		 <li><codeph>NativeWindowSystemChrome.STANDARD</codeph></li>
		 </ul>
		 
		 <p>指定されていない場合、<codeph>systemChrome</codeph> のデフォルト値は <codeph>NativeWindowSystemChrome.STANDARD</codeph> になります。
		 </p>
		 
		 <p>システムクロムを使用するウィンドウの <codeph>transparent</codeph> プロパティを <codeph>true</codeph> に設定することはサポートされていません。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:transparent:get"><apiName>transparent</apiName><shortdesc>
		 ウィンドウが、デスクトップに対する透明度とアルファの組み合わせをサポートするかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
		 
	     </apiDefaultValue></apiValueDef><apiDesc>
		 ウィンドウが、デスクトップに対する透明度とアルファの組み合わせをサポートするかどうかを指定します。
		 
		 <p>
		 <codeph>true</codeph> の場合、ウィンドウ表示がデスクトップと合成されます。表示オブジェクトの範囲外にあるウィンドウ領域、またはアルファの設定が 0 に近い表示オブジェクトの範囲内のウィンドウ領域は実質的には不可視になり、マウスイベント（ウィンドウの下のデスクトップオブジェクトによって受け取られる）を取得しません。オブジェクトがマウスイベントを取得しなくなるアルファ値は、オペレーティングシステムによってほぼ .06 から .01 までの値のいずれかになります。
		 </p>  
		 
		 <p>システムクロムを使用するウィンドウに対して <codeph>transparent</codeph> プロパティを <codeph>true</codeph> に設定することはサポートされていません。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowInitOptions:type:get"><apiName>type</apiName><shortdesc>
		 作成するウィンドウのタイプを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowType.NORMAL
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 作成するウィンドウのタイプを指定します。  
		 
		 <p>このプロパティの有効な値の定数は、NativeWindowType クラスで定義されます。
         </p>
         
		 <ul>
		 <li><codeph>NativeWindowType.NORMAL</codeph> — 一般的なウィンドウです。NORMAL ウィンドウはフルサイズのクロムを使用し、Windows または Linux のタスクバーおよび Mac OS X のウィンドウメニューに表示されます。</li>
		 
		 <li><codeph>NativeWindowType.UTILITY</codeph> — ツールパレットです。UTILITY ウィンドウはスリムなタイプのシステムクロムを使用し、Windows のタスクバーおよび Mac OS X のウィンドウメニューに表示されません。</li>
		 
		 <li><codeph>NativeWindowType.LIGHTWEIGHT</codeph> - LIGHTWEIGHT ウィンドウにはシステムクロムを表示できません。また、Windows または Linux のタスクバーおよび Mac OS X のウィンドウメニューにも表示されません。また、LIGHTWEIGHT ウィンドウには、Windows のシステムメニュー（Alt+ スペースバー）が表示されません。LIGHTWEIGHT ウィンドウは、通知バブルや短時間表示される表示領域を開くコンボボックスなどのコントロールに適しています。LIGHTWEIGHT タイプを使用する場合は、<codeph>systemChrome</codeph> を <codeph>none</codeph> に設定する必要があります。</li>
		 </ul>
		 
		 <p>
		 指定されていない場合、<codeph>type</codeph> のデフォルト値は <codeph>NativeWindowType.NORMAL</codeph> になります。
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
	 ShaderParameter インスタンスはシェーダーカーネルの 1 つの入力パラメーターを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderParameter インスタンスはシェーダーカーネルの 1 つの入力パラメーターを表します。カーネル実行で使用する 0、1、またはそれ以上のパラメーターを許可するようにカーネルを定義できます。ShaderParameter は、対応するデータ型などのパラメーターに関する情報を提供します。また、シェーダーの実行時に使用するパラメーター値を設定するメカニズムも提供します。シェーダーパラメーターの値を指定するには、値が入った Array を作成し、それを <codeph>value</codeph> プロパティに割り当てます。
	 
	 <p>Shader インスタンスのパラメーターを表す ShaderParameter インスタンスは、Shader インスタンスの <codeph>data</codeph> プロパティのプロパティとしてアクセスします。ShaderParameter プロパティの名前は、シェーダーコードのパラメーター名と同じです。例えば、次に示すように、シェーダーが <codeph>radius</codeph> という名前のパラメーターを定義している場合は、<codeph>radius</codeph> パラメーターを表す ShaderParameter インスタンスに <codeph>radius</codeph> というプロパティでアクセスできます。</p>
	 
	 <codeblock>var radiusParam:ShaderParameter = myShader.data.radius;</codeblock>
	 
	 <p>ShaderParameter クラスの定義されたプロパティに加えて、各 ShaderParameter インスタンスには、そのパラメーターに定義されたメタデータに対応する追加のプロパティがあります。これらのプロパティは、ShaderParameter オブジェクトの作成時に追加されます。プロパティ名はシェーダーのソースコードで指定されたメタデータ名と一致します。各プロパティのデータ型は、対応するメタデータのデータ型によって異なります。"description" などのテキストメタデータ値は、String インスタンスです。ストリング以外の値（<codeph>minValue</codeph>、<codeph>defaultValue</codeph> など）を持つメタデータプロパティは、Array インスタンスとなります。エレメント数とエレメントデータ型はメタデータ値に対応します。</p>
	 
	 <p>例えば、シェーダーに次の 2 つのパラメーター宣言が含まれるとします。</p>
	 
	 <codeblock>
	 parameter float2 size
	 &lt;
	     description: "The size of the image to which the kernel is applied";
	     minValue: float2(0.0, 0.0);
	     maxValue: float2(100.0, 100.0);
	     defaultValue: float2(50.0, 50.0);
	 >;
	 
	 parameter float radius
	 &lt;
	     description: "The radius of the effect";
	     minValue: 0.0;
	     maxValue: 50.0;
	     defaultValue: 25.0;
	 >;
	 </codeblock>
	 
	 <p><codeph>size</codeph> パラメーターに対応する ShaderParameter インスタンスは、ビルトインプロパティのほかに、次のメタデータプロパティを持ちます。</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>プロパティ名</entry><entry>データ型</entry><entry>値</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"サイズ"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"カーネルが適用されるイメージのサイズ"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0, 0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[100, 100]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50, 50]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p><codeph>radius</codeph> パラメーターに対応する ShaderParameter には、次の追加プロパティがあります。</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>プロパティ名</entry><entry>データ型</entry><entry>値</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"半径"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>String</entry>
	   <entry><codeph>"エフェクトの半径"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[25]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>一般に、開発者コードでは直接 ShaderParameter インスタンスは作成されません。ShaderParameter インスタンスは、Shader インスタンスが作成されるときに、シェーダーの各パラメーターに対して作成されます。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links><apiConstructor id="flash.display:ShaderParameter:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
		 ShaderParameter インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 ShaderParameter インスタンスを作成します。ShaderParameter コンストラクターは開発者コードでは直接呼び出されません。ShaderParameter インスタンスは、Shader インスタンスが作成されるときに、シェーダーの各パラメーターに対して作成されます。
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderParameter:index:get"><apiName>index</apiName><shortdesc>
          パラメーターのインデックス。このインデックスは 0 から始まります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
          パラメーターのインデックス。このインデックスは 0 から始まります。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameter:type:get"><apiName>type</apiName><shortdesc>
		シェーダーで定義されているパラメーターのデータ型です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		シェーダーで定義されているパラメーターのデータ型です。<codeph>type</codeph> プロパティで使用可能な値セットは、ShaderParameterType クラスの定数によって定義されます。
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameterType"><linktext>flash.display.ShaderParameterType</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameter:value:get"><apiName>value</apiName><shortdesc>
		パラメーター値としてシェーダーに渡される値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		パラメーター値としてシェーダーに渡される値です。<codeph>value</codeph> プロパティはインデックス付き Array です。Array エレメントの数とタイプはパラメーターのデータ型に対応します。これは、<codeph>type</codeph> プロパティを使用して決定できます。
		
		<p>次の表に、パラメータータイプと対応する <codeph>value</codeph> Array エレメントの数とデータ型を示します。</p>
		
		<adobetable class="innertable">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		<tgroup cols="3"><thead><row><entry>パラメータータイプ</entry><entry>エレメントの数</entry><entry>エレメントのデータ型</entry></row></thead><tbody><row>
		  <entry>float（<codeph>ShaderParameterType.FLOAT</codeph>）</entry>
		  <entry>1</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float2（<codeph>ShaderParameterType.FLOAT2</codeph>）</entry>
		  <entry>2</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3（<codeph>ShaderParameterType.FLOAT3</codeph>）</entry>
		  <entry>3</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4（<codeph>ShaderParameterType.FLOAT4</codeph>）</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>int（<codeph>ShaderParameterType.INT</codeph>）</entry>
		  <entry>1</entry>
		  <entry>int または uint</entry>
		</row><row>
		  <entry>int2（<codeph>ShaderParameterType.INT2</codeph>）</entry>
		  <entry>2</entry>
		  <entry>int または uint</entry>
		</row><row>
		  <entry>int3（<codeph>ShaderParameterType.INT3</codeph>）</entry>
		  <entry>3</entry>
		  <entry>int または uint</entry>
		</row><row>
		  <entry>int4（<codeph>ShaderParameterType.INT4</codeph>）</entry>
		  <entry>4</entry>
		  <entry>int または uint</entry>
		</row><row>
		  <entry>bool（<codeph>ShaderParameterType.BOOL</codeph>）</entry>
		  <entry>1</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool2（<codeph>ShaderParameterType.BOOL2</codeph>）</entry>
		  <entry>2</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool3（<codeph>ShaderParameterType.BOOL3</codeph>）</entry>
		  <entry>3</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool4（<codeph>ShaderParameterType.BOOL4</codeph>）</entry>
		  <entry>4</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>float2x2（<codeph>ShaderParameterType.MATRIX2X2</codeph>）</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3x3（<codeph>ShaderParameterType.MATRIX3X3</codeph>）</entry>
		  <entry>9</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4x4（<codeph>ShaderParameterType.MATRIX4X4</codeph>）</entry>
		  <entry>16</entry>
		  <entry>Number</entry>
		</row></tbody></tgroup></adobetable>
		
		<p>マトリックスパラメータータイプの場合、配列エレメントは最初マトリックス行に入力され、次に列に入力されます。例えば、次の ActionScript 行を使用して、<codeph>float2x2</codeph> パラメーターに<codeph>myMatrix</codeph> という名前をつけて入力するとします。</p>
		
		<codeblock>myShader.data.myMatrix.value = [.1, .2, .3, .4];</codeblock>
		
		<p>シェーダー内で、各マトリックスエレメントは次の値を持ちます。</p>
		
		<ul>
		  <li><codeph>myMatrix[0][0]</codeph>：0.1</li>
		  <li><codeph>myMatrix[0][1]</codeph>：0.2</li>
		  <li><codeph>myMatrix[1][0]</codeph>：0.3</li>
		  <li><codeph>myMatrix[1][1]</codeph>：0.4</li>
		</ul>
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GradientType"><apiName>GradientType</apiName><shortdesc>
GradientType クラスは、flash.display.Graphics クラスの beginGradientFill() メソッドおよび lineGradientStyle() メソッドの type パラメーターに値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
GradientType クラスは、<codeph>type</codeph> パラメーター（flash.display.Graphics クラスの <codeph>beginGradientFill()</codeph> メソッドおよび <codeph>lineGradientStyle()</codeph> メソッド内のパラメーター）に値を提供します。

</apiDesc></apiClassifierDetail><apiValue id="flash.display:GradientType:LINEAR"><apiName>LINEAR</apiName><shortdesc>
	線状グラデーションの塗りを指定する値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linear</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	線状グラデーションの塗りを指定する値です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GradientType:RADIAL"><apiName>RADIAL</apiName><shortdesc>
	放射状グラデーションの塗りを指定する値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>radial</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	放射状グラデーションの塗りを指定する値です。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InterpolationMethod"><apiName>InterpolationMethod</apiName><shortdesc>
InterpolationMethod クラスは、Graphics.beginGradientFill() メソッドおよび Graphics.lineGradientStyle() メソッドの interpolationMethod パラメーターの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
InterpolationMethod クラスは、<codeph>interpolationMethod</codeph> パラメーター（<codeph>Graphics.beginGradientFill()</codeph> および <codeph>Graphics.lineGradientStyle()</codeph> メソッドのパラメーター）の値を提供します。このパラメーターは、グラデーションをレンダリングするときに使用する RGB スペースを決定します。 

 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:InterpolationMethod:LINEAR_RGB"><apiName>LINEAR_RGB</apiName><shortdesc>
	線形 RGB 補間メソッドを使用することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linearRGB</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	線形 RGB 補間メソッドを使用することを指定します。これは、線形 RGB カラーモデルをベースにした RGB カラースペースが使用されることを意味します。
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/RGB"><linktext>RGB</linktext></link></related-links></apiValue><apiValue id="flash.display:InterpolationMethod:RGB"><apiName>RGB</apiName><shortdesc>
	RGB 補間メソッドを使用することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>rgb</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	RGB 補間メソッドを使用することを指定します。これは、グラデーションが指数 sRGB（標準 RGB）スペースでレンダリングされることを意味します。 sRGB スペースは、赤、緑、青の各構成要素値と構成要素可視色の実際輝度の間の非線形変換を定義した W3C 承認の標準です。
	
	<p>例えば、2 つの色の間に、<codeph>spreadMethod</codeph> パラメーターが <codeph>SpreadMethod.REFLECT</codeph> に設定されたシンプルな線状グラデーションがあるとします。それぞれの補間方法で、外観に次のような影響があります。 </p>
	
		<adobetable>
		
      
		
		
		
		<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="InterpolationMethod.LINEAR_RGB での線状グラデーション" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="InterpolationMethod.RGB での線状グラデーション" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
		</row><row>
		<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
		<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
		</row></tbody></tgroup></adobetable>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/LINEAR_RGB"><linktext>LINEAR_RGB</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsPath"><apiName>IGraphicsPath</apiName><shortdesc>
	このインターフェイスは、flash.display.Graphics のメソッドおよび描画クラスのパスパラメーターとして使用されるオブジェクトを定義するために使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	このインターフェイスは、flash.display.Graphics のメソッドおよび描画クラスのパスパラメーターとして使用されるオブジェクトを定義するために使用します。パスプロパティデータの作成と管理、および異なるインスタンスでの同じデータの再利用には、このインターフェイスの実装者クラスを使用します。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:IGraphicsFill"><apiName>IGraphicsFill</apiName><shortdesc>
	このインターフェイスは、flash.display.Graphics のメソッドおよび描画クラスの塗りパラメーターとして使用されるオブジェクトを定義するために使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	このインターフェイスは、flash.display.Graphics のメソッドおよび描画クラスの塗りパラメーターとして使用されるオブジェクトを定義するために使用します。塗りプロパティデータの作成と管理、および異なるインスタンスでの同じデータの再利用には、このインターフェイスの実装者クラスを使用します。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#GraphicsStroke/fill"><linktext>flash.display.GraphicsStroke.fill</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:LoaderInfo"><apiName>LoaderInfo</apiName><shortdesc>
 LoaderInfo クラスは、読み込まれる SWF ファイルやイメージファイル（JPEG、GIF、PNG ファイルなど）に関する情報を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion><Exclude kind="method" name="dispatchEvent"/></asMetadata><asCustoms><internal>Update the places LoaderInfo can be obtained from (playerglobal.as) and double-check loader vs. loadee.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 LoaderInfo クラスは、読み込まれる SWF ファイルやイメージファイル（JPEG、GIF、PNG ファイルなど）に関する情報を提供します。LoaderInfo オブジェクトは、すべての表示オブジェクトで使用できます。提供される情報には、読み込みの進行状況、読み込む側と読み込まれたコンテンツの URL、メディアの総バイト数、メディアの規格高さと幅などが含まれます。
 
 <p>次に示す 2 つの方法で LoaderInfo オブジェクトにアクセスできます。 </p>
 
 <ul>
 
 	<li>flash.display.Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティ — <codeph>contentLoaderInfo</codeph> プロパティは常にすべての Loader オブジェクトに対して使用できます。<codeph>load()</codeph> メソッドまたは <codeph>loadBytes()</codeph> メソッドを呼び出していない Loader オブジェクトや、読み込みが完了していない Loader オブジェクトの場合、<codeph>contentLoaderInfo</codeph> プロパティの各種プロパティにアクセスしようとするとエラーがスローされます。</li>
 
 	<li>表示オブジェクトの <codeph>loaderInfo</codeph> プロパティ。 </li>
 
 </ul>
 
 <p>Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティは、Loader オブジェクトが読み込むコンテンツに関する情報を提供するのに対して、DisplayObject の <codeph>loaderInfo</codeph> プロパティは、その表示オブジェクトのルート SWF ファイルに関する情報を提供します。 </p>
 
 <p>Loader オブジェクトを使用して表示オブジェクト（SWF ファイル、ビットマップなど）をロードした場合、表示オブジェクトの <codeph>loaderInfo</codeph> プロパティは Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティと同じになります（<codeph>DisplayObject.loaderInfo = Loader.contentLoaderInfo</codeph>）。SWF ファイルのメインクラスのインスタンスに Loader オブジェクトは含まれないので、<codeph>loaderInfo</codeph> プロパティは、SWF ファイルのメインクラスのインスタンスの LoaderInfo にアクセスする唯一の方法です。</p>
 
 <p>次の図は、SWF ファイルのメインクラスのインスタンス、Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティ、読み込まれたオブジェクトの <codeph>loaderInfo</codeph> プロパティの場合のそれぞれ異なる LoaderInfo オブジェクトの使用方法を示します。</p>
 
 <p>
 <adobeimage alt="異なる LoaderInfo 状況のイメージ" href="../../images/loaderInfo_object.jpg"/>
 </p>
 
 <p>ロード処理が完了していない場合、Loader オブジェクトの <codeph>contentLoaderInfo</codeph> プロパティのいくつかのプロパティは取得できません。<codeph>bytesLoaded</codeph>、<codeph>bytesTotal</codeph>、<codeph>url</codeph>、<codeph>loaderURL</codeph>、<codeph>applicationDomain</codeph> などのいくつかのプロパティは取得できます。<codeph>loaderInfo</codeph> オブジェクトが <codeph>init</codeph> イベントを送出すると、<codeph>loaderInfo</codeph> オブジェクトとロード済みのイメージまたは SWF ファイルのすべてのプロパティにアクセスできます。</p>
 
 <p><b>注意：</b>LoaderInfo オブジェクトのプロパティはすべて読み取り専用です。</p>
 
 <p><codeph>EventDispatcher.dispatchEvent()</codeph> メソッドは、LoaderInfo オブジェクトに適用できません。LoaderInfo オブジェクトで <codeph>dispatchEvent()</codeph> を呼び出した場合、IllegalOperationError 例外がスローされます。</p>
 
 
 
 </apiDesc><example conref="examples\LoaderInfoExample.as"> 次の例では、LoaderInfoExample クラスを使用して、イメージをステージに表示します。ここでは以下の手順を実行します。
 <ol>
  <li>プロパティ <codeph>url</codeph> を作成します。これはイメージの場所と名前です。</li>
 
  <li>クラスコンストラクターは <codeph>loader</codeph> という名前の Loader オブジェクトを作成します。</li>
 
  <li><codeph>loader</codeph> オブジェクトはイベントリスナーをインスタンス化して、イメージが正しくロードされるようにします。</li>
 
  <li>コンストラクターは、<codeph>request</codeph> という URLRequest オブジェクトの新しいインスタンスを作成しますが、その前に、ファイル名と場所が分かるように <codeph>url</codeph> を渡します。</li>
 
  <li>次に <codeph>request</codeph> オブジェクトが <codeph>load()</codeph> メソッド（<codeph>loader</codeph> オブジェクトのメソッド）に渡されます。このメソッドでは、イメージが表示リストにロードされます。</li>
 
 </ol>
 <p><b>重要：</b>この例では、Image.gif という名前のファイルがコンパイル済み SWF ファイルと同じディレクトリに追加されている必要があります。メイン SWF ファイルのサイズ内に収まる領域を持つイメージを使用します。</p>
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.LoaderInfo;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderInfoExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderInfoExample() {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function initHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);
            trace("initHandler: loaderURL=" + info.loaderURL + " url=" + info.url);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObject/loaderInfo"><linktext>flash.display.DisplayObject.loaderInfo</linktext></link></related-links><adobeApiEvent id="flash.display:LoaderInfo_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 ネットワーク要求が HTTP を介して行われ、HTTP ステータスコードを検出できる場合に送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ネットワーク要求が HTTP を介して行われ、HTTP ステータスコードを検出できる場合に送出されます。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.UNLOAD_unload"><apiName>unload</apiName><shortdesc>
 読み込まれたオブジェクトが Loader オブジェクトの unload() メソッドを使用して削除されるたびに、LoaderInfo オブジェクトによって送出されます。または 2 番目の読み込みが同じ Loader オブジェクトによって実行され、読み込み開始前に元のコンテンツが削除された場合に、LoaderInfo オブジェクトによって送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.UNLOAD</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 読み込まれたオブジェクトが Loader オブジェクトの <codeph>unload()</codeph> メソッドを使用して削除されるたびに、LoaderInfo オブジェクトによって送出されます。または 2 番目の読み込みが同じ Loader オブジェクトによって実行され、読み込み開始前に元のコンテンツが削除された場合に、LoaderInfo オブジェクトによって送出されます。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>Loader.unload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 ダウンロード処理を実行中にデータを受信したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ダウンロード処理を実行中にデータを受信したときに送出されます。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 ロード操作が開始したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ロード操作が開始したときに送出されます。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 入出力エラーが発生して読み込み処理が失敗したときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 入出力エラーが発生して読み込み処理が失敗したときに送出されます。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.INIT_init"><apiName>init</apiName><shortdesc>
 ロードされた SWF ファイルのプロパティおよびメソッドがアクセス可能で使用できる状態の場合に送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.INIT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 ロードされた SWF ファイルのプロパティおよびメソッドがアクセス可能で使用できる状態の場合に送出されます。ただし、コンテンツはダウンロード中の可能性があります。次に示す条件に適合するときに LoaderInfo オブジェクトは <codeph>init</codeph> イベントを送出します。
 <ul>
     <li>読み込まれたオブジェクトに関係したすべてのプロパティとメソッド、および LoaderInfo オブジェクトに関係したすべてのプロパティとメソッドにアクセスできます。</li>
     <li>すべての子オブジェクトのコンストラクターが完了済みです。</li>
     <li>ロードされた SWF のメインタイムラインの最初のフレームに含まれるすべての ActionScript コードが実行済みです。</li>
 </ul>
 
 <p>例えば、ムービーまたはアニメーションの最初のフレームがロードされたとき、<codeph>Event.INIT</codeph> が送出されます。その時点で、ムービーはアクセス可能になり、表示リストに追加できます。ただし、ムービー全体のダウンロードには、さらに時間がかかる可能性があります。<codeph>Event.COMPLETE</codeph> は、ムービー全体がダウンロードされた時点で初めて送出されます。</p>
 
 <p><codeph>init</codeph> イベントは、常に、<codeph>complete</codeph> イベントの前に送出されます。</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 データが正常にロードされたときに送出されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 データが正常にロードされたときに送出されます。つまり、すべてのコンテンツのダウンロードが完了し、ロードが完了したときに送出されます。<codeph>complete</codeph> イベントは、常に、<codeph>init</codeph> イベントの後に送出されます。 <codeph>init</codeph> イベントはオブジェクトにアクセス可能になったときに送出されますが、コンテンツはまだダウンロード中である可能性があります。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:LoaderInfo:getLoaderInfoByDefinition"><apiName>getLoaderInfoByDefinition</apiName><shortdesc>
     オブジェクトとして定義され、SWF ファイルに関連付けられている LoaderInfo オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>呼び出し元は、信頼できるローカルのサンドボックスで実行されていません。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>関連付けられている LoaderInfo オブジェクトです。 <codeph>null</codeph> が、非デバッガービルドで呼び出されたとき（またはデバッグ機能が有効でないとき）、または参照された<codeph>オブジェクト</codeph>に LoaderInfo オブジェクト（AIR ランタイムによって使用されるオブジェクトなど）が関連付けられていないときに返されます。 
	 
	 </apiDesc><apiOperationClassifier>flash.display:LoaderInfo</apiOperationClassifier></apiReturn><apiParam><apiItemName>object</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>関連付けられた LoaderInfo オブジェクトを取得する対象のオブジェクトです。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     オブジェクトとして定義され、SWF ファイルに関連付けられている LoaderInfo オブジェクトを返します。
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:LoaderInfo:actionScriptVersion:get"><apiName>actionScriptVersion</apiName><shortdesc>
	 ロード済みの SWF ファイルの ActionScript バージョンです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>ファイルが SWF ファイルでない場合
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 ロード済みの SWF ファイルの ActionScript バージョンです。言語バージョンは、ActionScriptVersion クラスに列挙されているものを使用して指定されます。例えば、<codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> や <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph> などです。
	 
	 <p><b>注意：</b>このプロパティの値は、必ず、<codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> または <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph> のいずれかになります。ActionScript 1.0 と 2.0 はどちらも <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph>（バージョン 2.0）と見なされます。このプロパティは、ActionScript 1.0/2.0 と ActionScript 3.0 だけを区別します。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ActionScriptVersion"><linktext>flash.display.ActionScriptVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:applicationDomain:get"><apiName>applicationDomain</apiName><shortdesc>
	 外部 SWF ファイルが読み込まれると、読み込まれたクラスに含まれているすべての ActionScript 3.0 定義は applicationDomain プロパティに格納されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need better description and example.  
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier><apiException><apiDesc>この呼び出し元のセキュリティサンドボックスからは、この ApplicationDomain にアクセスできません。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 外部 SWF ファイルが読み込まれると、読み込まれたクラスに含まれているすべての ActionScript 3.0 定義は <codeph>applicationDomain</codeph> プロパティに格納されます。
	 
	 <p>SWF ファイル内のすべてのコードは、アプリケーションドメイン内に存在するように定義されます。現在のアプリケーションドメインは、メインアプリケーションが実行されている場所です。システムドメインには、現在のドメインおよび Flash Player または Adobe AIR によって使用されるすべてのクラスを含む、すべてのアプリケーションドメインが含まれます。</p>
	 
	 <p>システムドメインを除くすべてのアプリケーションドメインには、親ドメインが関連付けられています。メインアプリケーションの <codeph>applicationDomain</codeph> の親ドメインは、システムドメインです。読み込まれるクラスは、その親によってまだ定義されていない場合にのみ定義されます。ロードされるクラスの定義を新しい定義でオーバーライドすることはできません。</p>
	 
	 <p>アプリケーションドメインの使用例については、『<i>ActionScript 3.0 のプログラミング</i>』の「クライアントのシステム環境」の章を参照してください。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:bytes:get"><apiName>bytes</apiName><shortdesc>
	 LoaderInfo オブジェクトに関連付けられているバイト数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>この API にアクセスするオブジェクトが、セキュリティの制限のために読み込まれたオブジェクトにアクセスできません。このような状況は、例えば、Loader オブジェクトが <codeph>contentLoaderInfo.content</codeph> プロパティにアクセスしようとするときに、ロードされたコンテンツにアクセスするセキュリティの許可が与えられていない場合に生じます。
	 
	 <p>詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。</p>
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 LoaderInfo オブジェクトに関連付けられているバイト数です。 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 そのメディアのロード済みのバイト数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 そのメディアのロード済みのバイト数です。この数値が <codeph>bytesTotal</codeph> の値と同じである場合、すべてのバイト数がロードされます。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 メディアファイル全体の圧縮後のバイト数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 メディアファイル全体の圧縮後のバイト数です。
	 
	 <p>最初の <codeph>progress</codeph> イベントが、この LoaderInfo オブジェクトの対応する Loader オブジェクトによって送出される前、<codeph>bytesTotal</codeph> は 0 です。Loader オブジェクトの最初の <codeph>progress</codeph> イベントの後、<codeph>bytesTotal</codeph> は、ダウンロードされる実際のバイト数を反映します。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
	 コンテンツ（子）からロードする側（親）への信頼関係を表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合に、スローされます。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 コンテンツ（子）からロードする側（親）への信頼関係を表します。子が親へのアクセスを許可されている場合は <codeph>true</codeph>、そうでない場合は <codeph>false</codeph> です。このプロパティが <codeph>true</codeph> に設定されるのは、子オブジェクトが <codeph>allowDomain()</codeph> メソッドを呼び出して親ドメインへの許可を受けている場合、または子ドメインに URL ポリシーがロードされていて親ドメインへの許可を受けている場合です。子と親が同じドメインに置かれている場合、このプロパティは <codeph>true</codeph> に設定されます。
	 
	 <p>詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:childSandboxBridge:get"><apiName>childSandboxBridge</apiName><shortdesc>
	 Loader オブジェクトのサンドボックスにあるコードによってアクセスできるプロパティとメソッドを公開するために、ロードされたコンテンツのコードで設定できるオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>このプロパティを設定できるのは、ロードされたコンテンツのサンドボックスにあるコンテンツのみです。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Loader オブジェクトのサンドボックスにあるコードによってアクセスできるプロパティとメソッドを公開するために、ロードされたコンテンツのコードで設定できるオブジェクトです。この<i>サンドボックスブリッジ</i>によって、アプリケーション以外のドメインからのコンテンツが AIR アプリケーションサンドボックスのスクリプトへのアクセスを制御しており、また、その逆も行っています。サンドボックスブリッジは、サンドボックス間のゲートウェイとして機能し、アプリケーションとアプリケーション以外のセキュリティサンドボックスの間での明示的なやり取りを提供します。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/parentSandboxBridge"><linktext>parentSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:content:get"><apiName>content</apiName><shortdesc>
	 この LoaderInfo オブジェクトに関係したロードされたオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>この API にアクセスするオブジェクトが、セキュリティの制限のために読み込まれたオブジェクトにアクセスできません。このような状況は、例えば、Loader オブジェクトが <codeph>contentLoaderInfo.content</codeph> プロパティにアクセスしようとするときに、ロードされたコンテンツにアクセスするセキュリティの許可が与えられていない場合に生じます。
	 
	 <p>詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 この LoaderInfo オブジェクトに関係したロードされたオブジェクトです。 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:contentType:get"><apiName>contentType</apiName><shortdesc>
	 ロードされたファイルの MIME タイプです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 ロードされたファイルの MIME タイプです。ファイルのロードが正しく行われておらず、タイプを判別できない場合、この値は <codeph>null</codeph> です。 次のリストは、想定される値を示しています。
	 
	 <ul>
	 	
	 	<li><codeph>"application/x-shockwave-flash"</codeph></li>
	 
	 	<li><codeph>"image/jpeg"</codeph></li>
	 
	 	<li><codeph>"image/gif"</codeph></li>
	 
	 	<li><codeph>"image/png"</codeph></li>
	 
	 </ul>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 読み込み済みの SWF ファイルに関する 1 秒ごとのフレーム数を表す公称のフレームレートです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>ファイルが SWF ファイルでない場合 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 読み込み済みの SWF ファイルに関する 1 秒ごとのフレーム数を表す公称のフレームレートです。この数値はほとんどの場合整数ですが、整数でなくても構いません。
	 
	 <p>この値は、実際のフレームレートとは異なる場合があります。Flash Player または Adobe AIR は、すべてのロード済み SWF ファイルについて一度に 1 つのフレームレートしか使用せず、このフレームレートはメイン SWF ファイルの公称のフレームレートによって決まります。  また、メインのフレームレートは、ハードウェア、サウンド同期、およびその他の要素によっては達成できない場合があります。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:height:get"><apiName>height</apiName><shortdesc>
	 読み込まれたファイルの規格高さです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 読み込まれたファイルの規格高さです。読み込まれたコンテンツやその親表示オブジェクトは拡大 / 縮小されている場合があるため、この値は表示されているコンテンツの実際の高さとは異なる場合があります。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loader:get"><apiName>loader</apiName><shortdesc>
	 この LoaderInfo オブジェクトに関係した Loader オブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Loader</apiValueClassifier><apiException><apiDesc>この API にアクセスするオブジェクトが、セキュリティの制限のために Loader オブジェクトにアクセスできません。これは、例えば、ロードされた SWF ファイルがその <codeph>loaderInfo.loader</codeph> プロパティにアクセスしようとするときに、ロード元 SWF ファイルにアクセスするセキュリティの許可が与えられていない場合に生じます。
	 
	 <p>詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 この LoaderInfo オブジェクトに関係した Loader オブジェクトです。この LoaderInfo オブジェクトが、SWF ファイルのメインクラスのインスタンスの <codeph>loaderInfo</codeph> プロパティである場合、関係する Loader オブジェクトはありません。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loaderURL:get"><apiName>loaderURL</apiName><shortdesc>
	 この LoaderInfo オブジェクトによって記述されるメディアの読み込みを開始した SWF ファイルの URL です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 この LoaderInfo オブジェクトによって記述されるメディアの読み込みを開始した SWF ファイルの URL です。SWF ファイルのメインクラスのインスタンスの場合、この URL は、SWF ファイル自体の URL と同じものです。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parameters:get"><apiName>parameters</apiName><shortdesc>
	 ロード済みの SWF ファイルに提供されるパラメーターを表す、名前と値の組を含んだオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 ロード済みの SWF ファイルに提供されるパラメーターを表す、名前と値の組を含んだオブジェクトです。
	 
	 <p><codeph>for-in</codeph> ループを使用すると、<codeph>parameters</codeph> オブジェクトからすべての名前と値を抽出できます。</p>
	 
	 <p>パラメーターは、メイン SWF ファイルの URL のクエリ文字列と、<codeph>FlashVars</codeph> HTML パラメーターの値の 2 つから提供されます。この HTML パラメーターはメイン SWF ファイルにのみ影響します。</p>
	 
	 <p><codeph>parameters</codeph> プロパティは、メインタイムラインのプロパティとして SWF ファイルパラメーターを提供する ActionScript 1.0 および 2.0 の方法を置き換えます。</p>
	 
	 <p><codeph>parameters</codeph> プロパティの値は、ActionScript 1.0 または 2.0 を使用する SWF ファイルを含んだ Loader オブジェクトについては null です。ActionScript 3.0 を使用する SWF ファイルを含んだ Loader オブジェクトについてのみ、null 以外の値になります。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc>
	 ロードする側（親）からコンテンツ（子）への信頼関係を表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合に、スローされます。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 ロードする側（親）からコンテンツ（子）への信頼関係を表します。親が子のアクセスを許可している場合は <codeph>true</codeph>、そうでない場合は <codeph>false</codeph> です。このプロパティが <codeph>true</codeph> に設定されるのは、親オブジェクトが <codeph>allowDomain()</codeph> メソッドを呼び出して子ドメインへの許可を受けている場合、または親ドメインに URL ポリシーファイルがロードされていて子ドメインへの許可を受けている場合です。子と親が同じドメインに置かれている場合、このプロパティは <codeph>true</codeph> に設定されます。
	 
	 <p>詳細については、『<i>ActionScript 3.0 のプログラミング</i>』の「Flash Player セキュリティ」の章を参照してください。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentSandboxBridge:get"><apiName>parentSandboxBridge</apiName><shortdesc>
	 ロードされたコンテンツのコードによってアクセスできるプロパティとメソッドを公開するために、Loader オブジェクトのサンドボックス内にあるコードで設定できるオブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>このプロパティを設定できるのは、Loader オブジェクトのサンドボックス内にあるコンテンツのみです。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 ロードされたコンテンツのコードによってアクセスできるプロパティとメソッドを公開するために、Loader オブジェクトのサンドボックス内にあるコードで設定できるオブジェクトです。この<i>サンドボックスブリッジ</i>によって、アプリケーション以外のドメインからのコンテンツが AIR アプリケーションサンドボックス内のスクリプトへのアクセスを制御しており、また、その逆も行っています。サンドボックスブリッジは、サンドボックス間のゲートウェイとして機能し、アプリケーションとアプリケーション以外のセキュリティサンドボックスの間での明示的なやり取りを提供します。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/childSandboxBridge"><linktext>childSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:sameDomain:get"><apiName>sameDomain</apiName><shortdesc>
	 ロードする側とそのコンテンツの間のドメインの関係を次のように表します。ドメインが同じ場合は true、異なる場合は false です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合に、スローされます。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 読み込む側とそのコンテンツの間のドメインの関係を次のように表します。ドメインが同じ場合は <codeph>true</codeph>、異なる場合は <codeph>false</codeph> です。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:sharedEvents:get"><apiName>sharedEvents</apiName><shortdesc>
	 セキュリティ境界を越えてイベントを交換するために使用される EventDispatcher インスタンスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.events:EventDispatcher</apiValueClassifier></apiValueDef><apiDesc>
	 セキュリティ境界を越えてイベントを交換するために使用される EventDispatcher インスタンスです。Loader オブジェクトとロードされたコンテンツが、互いに信頼関係を確立していないセキュリティドメインに置かれている場合でも、どちらも <codeph>sharedEvents</codeph> にアクセスし、このオブジェクトを経由してイベントを送受信することができます。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:swfVersion:get"><apiName>swfVersion</apiName><shortdesc>
	 ロード済みの SWF ファイルのファイル形式のバージョンです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>ファイルが SWF ファイルでない場合
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 ロード済みの SWF ファイルのファイル形式のバージョンです。ファイル形式は、SWFVersion クラスに列挙されているものを使用して指定されます。例えば、<codeph>SWFVersion.FLASH7</codeph> や <codeph>SWFVersion.FLASH9</codeph> などです。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SWFVersion"><linktext>flash.display.SWFVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:url:get"><apiName>url</apiName><shortdesc>
	 読み込まれるメディアの URL です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 読み込まれるメディアの URL です。
	 
	 <p>この LoaderInfo オブジェクトの対応する Loader オブジェクトによって最初の <codeph>progress</codeph> イベントが送出されるまでは、<codeph>url</codeph> プロパティの値に、Loader オブジェクトの <codeph>load()</codeph> メソッドの呼び出しで指定した初期 URL しか反映されていない可能性があります。最初の <codeph>progress</codeph> イベントの後は、<codeph>url</codeph> プロパティはリダイレクトや相対 URL が解決された後のメディアの最終的な URL を反映します。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:width:get"><apiName>width</apiName><shortdesc>
	 読み込まれたコンテンツの規格幅です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>ファイルのダウンロードが完了しておらず、要求した情報を取得していない場合
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 読み込まれたコンテンツの規格幅です。読み込まれたコンテンツやその親表示オブジェクトは拡大 / 縮小されている場合があるため、この値は表示されているコンテンツの実際の幅とは異なる場合があります。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageQuality"><apiName>StageQuality</apiName><shortdesc>
StageQuality クラスは、Stage.quality プロパティの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageQuality クラスは、<codeph>Stage.quality</codeph> プロパティの値を提供します。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/quality"><linktext>flash.display.Stage.quality</linktext></link></related-links><apiValue id="flash.display:StageQuality:BEST"><apiName>BEST</apiName><shortdesc>
非常に高いレンダリング品質を指定します。グラフィックは 4 x 4 ピクセルグリッドを使用してアンチエイリアス処理され、ビットマップは常にスムージングされます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>best</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
非常に高いレンダリング品質を指定します。グラフィックは 4 x 4 ピクセルグリッドを使用してアンチエイリアス処理され、ビットマップは常にスムージングされます。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
高いレンダリング品質を指定します。グラフィックは 4 x 4 ピクセルグリッドを使用してアンチエイリアス処理されます。ビットマップは、ムービーが静的なものである場合は、スムージングされます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>high</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
高いレンダリング品質を指定します。グラフィックは 4 x 4 ピクセルグリッドを使用してアンチエイリアス処理されます。ビットマップは、ムービーが静的なものである場合は、スムージングされます。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:LOW"><apiName>LOW</apiName><shortdesc>
低いレンダリング品質を指定します。グラフィックはアンチエイリアス処理されず、ビットマップはスムージングされません。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>low</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
低いレンダリング品質を指定します。グラフィックはアンチエイリアス処理されず、ビットマップはスムージングされません。この設定は Adobe AIR ではサポートされません。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
普通のレンダリング品質を指定します。グラフィックは 2 x 2 ピクセルグリッドを使用してアンチエイリアス処理されますが、ビットマップはスムージングされません。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>medium</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
普通のレンダリング品質を指定します。グラフィックは 2 x 2 ピクセルグリッドを使用してアンチエイリアス処理されますが、ビットマップはスムージングされません。この設定は、テキストを含まないムービーに適しています。この設定は Adobe AIR ではサポートされません。

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 BitmapData クラスを使用すると、Bitmap オブジェクトのビットマップイメージのデータ（ピクセル）を処理できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>これを使用すると、Bitmap オブジェクトのビットマップデータを処理できます。
 
 </apiTipText></apiTipTexts><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 BitmapData クラスを使用すると、<ph platform="actionscript">Bitmap オブジェクトの</ph><ph platform="javascript">ビットマップイメージ</ph>のデータ（ピクセル）を処理できます。BitmapData クラスのメソッドを使用して、任意のサイズの透明または不透明のビットマップイメージを作成し、実行時にさまざまな方法で操作できます。<ph platform="actionscript">さらに、<codeph>flash.display.Loader</codeph> クラスを使ってロードされるビットマップイメージの BitmapData にアクセスすることもできます。</ph> 
 
 <p platform="actionscript">このクラスを使用すると、ビットマップのレンダリング処理を Flash Player 内部の表示更新ルーチンから分離できます。BitmapData オブジェクトを直接操作することで複雑なイメージを作成できるので、ベクターデータのコンテンツを連続的に再描画するフレーム単位のオーバーヘッドを避けることができます。</p>
 
 <p platform="actionscript">BitmapData クラスのメソッドは、（ビットマップ以外の表示オブジェクトでは使用可能な）フィルターを使って設定できないような効果をサポートします。</p>
 
 <p>BitmapData オブジェクトには、ピクセルデータの配列が含まれています。このデータは、完全に不透明なビットマップ、またはアルファチャンネルデータを含む透明なビットマップを表現できます。いずれの種類の BitmapData オブジェクトも 32 ビット整数のバッファーとして保存されます。各 32 ビット整数は、ビットマップ内の 1 つのピクセルのプロパティを決定します。</p>
 
 <p>各 32 ビット整数は、アルファ透明度とピクセルの赤緑青（ARGB）の値を表す 4 つの 8 ビットチャンネル値（0 ～ 255）の組み合わせです。（ARGB 値では、最上位バイトがアルファチャンネル値を表し、続いて赤、緑、青を表します）。</p>
 
 <p>この 4 つのチャンネル（アルファ、赤、緑、青）は、<codeph>BitmapData.copyChannel()</codeph> メソッド、または <codeph>DisplacementMapFilter.componentX</codeph> および <codeph>DisplacementMapFilter.componentY</codeph> プロパティで使用する場合に数値として表されます。これらの数値は、BitmapDataChannel クラスの次の定数によって表されます。</p>
 
 <ul>
 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
  <li><codeph>BitmapDataChannel.RED</codeph></li>
 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
</ul>
 
 <p platform="actionscript">Bitmap オブジェクトの <codeph>bitmapData</codeph> プロパティを使用すると、BitmapData オブジェクトを Bitmap オブジェクトに関連付けることができます。</p>
 
 <p platform="actionscript"><codeph>Graphics.beginBitmapFill()</codeph> メソッドを使用すると、BitmapData オブジェクトを使って Graphics オブジェクトを塗りつぶすことができます。</p>
 
 <p>AIR ランタイムでは、DockIcon、Icon、InteractiveIcon、SystemTrayIcon の各クラスが、アイコンのビットマップイメージを定義する BitmapData オブジェクトの配列である <codeph>bitmaps</codeph> プロパティを含んでいます。</p>
 
 <p>AIR 1.5 および Flash Player 10 では、BitmapData オブジェクトの最大サイズは幅または高さで 8,191 ピクセルです。総ピクセル数が 16,777,215 ピクセルを超えることはできません。（したがって、BitmapData オブジェクトの幅が 8,191 ピクセルであった場合、高さは 2,048 ピクセルまでしか指定できません）。Flash Player 9 以前および AIR 1.1 以前では、制限は高さ 2,880 ピクセル、幅 2,880 ピクセルです。</p>
 
 <p>BitmapData オブジェクトのいずれかのメソッドやプロパティを呼び出したときに、BitmapData オブジェクトが無効なものであった場合（例えば <codeph>height == 0</codeph> かつ <codeph>width == 0</codeph> の場合）や、dispose() で既に破棄されたものであった場合は、ArgumentError エラーがスローされます。 </p>
 
 </apiDesc><example conref="examples\BitmapDataExample.as"> 次の例では、BitmapDataExample クラスを使用して、"Image.gif" イメージをデフォルトの位置 (0, 0) にある DisplayObject にロードします。"Image.gif" のコピーを下のイメージの右に配置します。このコピーでは、<codeph>threshold()</codeph> メソッドを使用するテストに合格したピクセルに新しい色が適用されています。これを行うには、以下の手順を実行します。
 <ol>
     <li><codeph>url</codeph> プロパティを作成します。これはイメージファイルの場所と名前です。</li>
     <li>クラスコンストラクターが Loader オブジェクトを作成します。これは、<codeph>completeHandler()</codeph> メソッドがイメージ操作を完了したときに送出される、イベントリスナーをインスタンス化します。</li>
        <li>次に、<codeph>request</codeph> URLRequest オブジェクトが、<codeph>loader.load()</codeph> に渡されます。これは、表示オブジェクトを使用してメモリにイメージをロードします。</li>
     <li>次にイメージが表示リストに配置され、イメージは画面の座標 <i>x = 0、y = 0</i> に表示されます。</li>
     <li>続いて、<codeph>completeHandler()</codeph> メソッドで次の処理が実行されます。 
     <ul>
         <li>2 番目の Loader オブジェクトと Bitmap オブジェクトを作成します。Bitmap オブジェクトは、この Loader オブジェクトで初期化されます。</li>
         <li>2 番目の Bitmap オブジェクトである <codeph>duplicate</codeph> を作成します。これは、<codeph>duplicateImage()</codeph> メソッドを呼び出し、元のイメージを複製します。 </li>
         <li>BitmapData オブジェクトを作成すると、これが <codeph>duplicate</codeph> オブジェクトの BitmapData オブジェクトに割り当てられます。</li>
         <li>元のイメージと同じ座標、幅、高さで初期化された新しい Rectangle オブジェクトを作成します。</li>
         <li>新しい Point オブジェクトを作成します。デフォルトでは <i>x = 0、y = 0</i> に作成されます。</li>
         <li>次に示す変数を作成します。
         <ul>
             <li><codeph>operation</codeph> — しきい値が元の値以上である場合に、新しい色を適用します。</li>
             <li><codeph>threshold</codeph> — 各ピクセルの比較対象の値。この例では、アルファ 0xCC の明るい灰色に設定されます。 </li>
             <li><codeph>color</codeph> — しきい値のテストに合格したピクセルに設定する色。この例では黄色です。</li>
             <li><codeph>mask</codeph> — 正反対の色。この例では透明色の青色です。</li>
             <li><codeph>copySource</codeph> — <codeph>false</codeph> に設定します。これは、しきい値を満たさなかった場合には、ピクセル値がコピーされないことを示します。しきい値のテストに合格したピクセルだけが変更されるため、この値に意味はありません。</li>
      </ul></li>
         <li>上記の変数を使用して <codeph>threshold()</codeph> メソッドを呼び出します。結果のしきい値の等式は、<codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph> のようになります。 </li>
  </ul></li>
 </ol>
 <p> <b>注意：</b>
 <ul>
     <li>「ローカルでの再生に関するセキュリティ」を「ローカルファイルにのみアクセスする」に設定して SWF ファイルをコンパイルする必要があります。
 </li>
     <li>この例では、"Image.gif" という名前のファイルが SWF ファイルと同じディレクトリに配置されている必要があります。
 </li>
  <li>イメージは、幅が約 80 ピクセル以内のものを使用することをお勧めします。 </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example><example conref="examples\BitmapDataExample2.as"/></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/bitmapData"><linktext>flash.display.Bitmap.bitmapData</linktext></link><link href="flash.desktop.xml#DockIcon/bitmaps"><linktext>flash.desktop.DockIcon.bitmaps</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.desktop.xml#Icon/bitmaps"><linktext>flash.desktop.Icon.bitmaps</linktext></link><link href="flash.desktop.xml#InteractiveIcon/bitmaps"><linktext>flash.desktop.InteractiveIcon.bitmaps</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.desktop.xml#SystemTrayIcon/bitmaps"><linktext>flash.desktop.SystemTrayIcon.bitmaps</linktext></link></related-links><apiConstructor id="flash.display:BitmapData:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 	 指定された幅と高さで BitmapData オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>幅や高さが最大サイズを超えています。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ビットマップイメージの幅（ピクセル単位）です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ビットマップイメージの高さ（ピクセル単位）です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>transparent</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>ビットマップイメージがピクセル単位の透明度をサポートするかどうかを指定します。デフォルト値は <codeph>true</codeph> です（透明）。完全に透明なビットマップを作成するには、<codeph>transparent</codeph> パラメーターの値を <codeph>true</codeph> に、<codeph>fillColor</codeph> パラメーターの値を 0x00000000（または 0）に設定します。<codeph>transparent</codeph> プロパティを <codeph>false</codeph> に設定すると、レンダリングのパフォーマンスが若干向上することがあります。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>ビットマップイメージ領域を塗りつぶすのに使用する 32 ビット ARGB カラー値です。デフォルト値は 0xFFFFFFFF（白）です。
	 
 	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 指定された幅と高さで BitmapData オブジェクトを作成します。<codeph>fillColor</codeph> パラメーターに値を指定した場合、ビットマップのすべてのピクセルにその色が設定されます。
	 
	 <p><codeph>false</codeph> を <codeph>transparent</codeph> パラメーターに渡さない限り、デフォルトではビットマップが透明として作成されます。不透明のビットマップを作成した後、それを透明のビットマップに変更することはできません。不透明のビットマップに含まれるすべてのピクセルは、24 ビットのカラーチャンネル情報だけを使用します。ビットマップを透明に定義した場合、すべてのピクセルは、アルファ透明チャンネルを含む 32 ビットのカラーチャンネル情報を使用します。</p>
	 
	 <p>AIR 1.5 および Flash Player 10 では、BitmapData オブジェクトの最大サイズは幅または高さで 8,191 ピクセルです。総ピクセル数が 16,777,215 ピクセルを超えることはできません。（したがって、BitmapData オブジェクトの幅が 8,191 ピクセルであった場合、高さは 2,048 ピクセルまでしか指定できません）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。幅または高さに 2880 より大きい値を指定すると、新しいインスタンスは作成されません。</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:BitmapData:applyFilter"><apiName>applyFilter</apiName><shortdesc>
	 ソースイメージとフィルターオブジェクトを受け取り、フィルターを適用して得られるイメージを生成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、destPoint、または filter が null です。
 	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>BitmapData オブジェクトの透明度は、フィルター操作と互換性がありません。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>フィルターが正常に適用されたかどうかを示す数値です。フィルターが正常に適用されると、ゼロが返されます。フィルターの適用中にエラーが発生すると、負の数値が返されます。
	 
	 </apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>使用する入力ビットマップイメージです。ソースイメージは、別の BitmapData オブジェクトにすることも、現在の BitmapData インスタンスを参照することもできます。

	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>ソース矩形の左上隅に対応する、ターゲットイメージ（現在の BitmapData インスタンス）内のポイントです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>フィルター適用処理に使用されるフィルターオブジェクトです。それぞれの種類のフィルターには、次のような要件があります。
	 
	 <ul><li><b>BlurFilter</b> — このフィルターは、透明または不透明なソースイメージとターゲットイメージを使用できます。イメージのフォーマットが一致しない場合、フィルター適用中に作成されるソースイメージのコピーがターゲットイメージのフォーマットに合わせられます。</li>
	 
	 <li><b>BevelFilter、DropShadowFilter、GlowFilter、ChromeFilter</b> — これらのフィルターのターゲットイメージは透明イメージでなければなりません。DropShadowFilter または GlowFilter を呼び出すと、ドロップシャドウまたはグローのアルファチャンネルデータを含むイメージが作成されます。ドロップシャドウはターゲットイメージ上に作成されません。これらのフィルターを不透明なターゲットイメージに対して使用すると、例外がスローされます。</li>
	 
	 <li><b>ConvolutionFilter</b> — このフィルターは、透明または不透明なソースイメージとターゲットイメージを使用できます。</li>
	 
	 <li><b>ColorMatrixFilter</b> — このフィルターは、透明または不透明なソースイメージとターゲットイメージを使用できます。</li>
	 
	 <li><b>DisplacementMapFilter</b> — このフィルターは、透明または不透明なソースイメージとターゲットイメージを使用できますが、イメージの形式はソースとターゲットで同じである必要があります。</li></ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 ソースイメージとフィルターオブジェクトを受け取り、フィルターを適用して得られるイメージを生成します。
	 
	 <p>このメソッドはビルトインフィルターオブジェクトの動作に依存します（このオブジェクトは、入力ソース矩形によって影響を受けるターゲット矩形を決定します）。</p>
	 
	 <p>フィルターを適用した後、結果として得られるイメージが入力イメージよりも大きくなることがあります。例えば、BlurFilter クラスを使用してソース矩形 (50,50,100,100) とターゲットポイント (10,10) をぼかすと、ターゲットイメージで変更される領域は、ぼかしのために、(10,10,60,60) よりも大きくなります。これは、<codeph>applyFilter()</codeph> 呼び出し時に内部で発生します。</p>
	 
	 <p><codeph>sourceRect</codeph> パラメーター（<codeph>sourceBitmapData</codeph> パラメーターのパラメーター）が内側領域（200 x 200 のイメージ内の (50,50,100,100) など）である場合、フィルターは、<codeph>sourceRect</codeph> パラメーターの外側にあるソースピクセルを使用して、ターゲット矩形を生成します。</p>
	 
	 <p><codeph>sourceBitmapData</codeph> パラメーターとして指定されたオブジェクトと BitmapData オブジェクトが同じであれば、アプリケーションはオブジェクトの一時コピーを使ってフィルターを実行します。最適なパフォーマンスを得るには、このような状況を避けてください。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.applyFilter.1.as"> 次の例では、BitmapData インスタンスにぼかしフィルターを適用する方法について説明します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>flash.filters.BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>flash.filters.BlurFilter</linktext></link><link href="flash.filters.xml#ColorMatrixFilter"><linktext>flash.filters.ColorMatrixFilter</linktext></link><link href="flash.filters.xml#ConvolutionFilter"><linktext>flash.filters.ConvolutionFilter</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>flash.filters.DropShadowFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>flash.filters.GlowFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:clone"><apiName>clone</apiName><shortdesc>
	 新しい BitmapData オブジェクトとして、元のインスタンスのクローンを返します。含まれるビットマップはまったく同じコピーになります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>元のオブジェクトと同一の新しい BitmapData オブジェクトです。
	 
	 </apiDesc><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>元のビットマップとまったく同一のコピーを含む新しい BitmapData オブジェクトを返します。

	  

	  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 新しい BitmapData オブジェクトとして、元のインスタンスのクローンを返します。含まれるビットマップはまったく同じコピーになります。
	 
	 </apiDesc><example conref="examples\BitmapData.clone.1.as"> 次の例は、BitmapData インスタンスのクローンを作成する方法を示しています。さらに、クローンされた BitmapData インスタンスを変更しても、元のインスタンスは変更されないことを示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:colorTransform"><apiName>colorTransform</apiName><shortdesc>
	 ColorTransform オブジェクトを使用して、ビットマップイメージの特定領域のカラー値を調整します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>rect または colorTransform が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>ColorTransform オブジェクトが適用されるイメージの領域を定義する Rectangle オブジェクトです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>適用されるカラー変換値を記述する ColorTransform オブジェクトです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 <codeph>ColorTransform</codeph> オブジェクトを使用して、ビットマップイメージの特定領域のカラー値を調整します。矩形がビットマップイメージの境界と一致する場合、このメソッドはイメージ全体のカラー値を変換します。
	 
	 </apiDesc><example conref="examples\BitmapData.colorTransform.1.as"> 次の例は、カラー変換を BitmapData オブジェクトの左半分（矩形）に適用する方法を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:compare"><apiName>compare</apiName><shortdesc>
	 
	 2 つの BitmapData オブジェクトを比較します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>otherBitmapData が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>2 つの BitmapData オブジェクトのサイズ（幅と高さ）が同じであれば、このメソッドは、2 つのオブジェクト間の差分を示す新しい BitmapData オブジェクトを返します（主な説明の項を参照してください）。2 つの BitmapData オブジェクトが等しい場合、このメソッドは数値 0 を返します。BitmapData オブジェクトの幅が等しくない場合、メソッドは数値 -3 を返します。BitmapData オブジェクトの高さが等しくない場合、メソッドは数値 -4 を返します。 
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>otherBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>ソース BitmapData オブジェクトと比較される BitmapData オブジェクトです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 2 つの BitmapData オブジェクトを比較します。2 つの BitmapData オブジェクトのサイズ（幅と高さ）が同じであれば、メソッドは新しい BitmapData オブジェクトを返します。この新しいオブジェクトの各ピクセルは、2 つのソースオブジェクトのピクセル間の「差分」です。
	 
	 <ul>
	 
	 	<li>2 つのピクセルが等しい場合、差分ピクセルは 0x00000000 です。 </li>
	 
	 	<li>2 つのピクセルの RGB 値（アルファ値は無視）が異なる場合、差分ピクセルは 0xRRGGBB です。ここで、RR/GG/BB は赤、緑、および青の各チャンネル間の個別の差分値（ソースオブジェクトのピクセル値から <codeph>otherBitmapData</codeph> オブジェクトのピクセル値を引いた値）を表します。この場合、アルファチャネルの差分は無視されます。 </li> 
	 
	 	<li>アルファチャンネルの値だけが異なる場合、ピクセル値は 0x<i>ZZ</i>FFFFFF です。ここで、<i>ZZ</i> はアルファ値の差分（ソースオブジェクトのアルファ値から <codeph>otherBitmapData</codeph> オブジェクトのアルファ値を引いた値）を表します。</li>
	 
	 </ul>
	 
	 <p>例えば、次のような 2 つの BitmapData オブジェクトがあるとします。</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
     </codeblock>
	 
	 <p><b>注意：</b>2 つの BitmapData オブジェクトを塗りつぶすために使用されるそれぞれの色の RGB 値はわずかに異なります（0xFF0000 と 0xFFAA00）。<codeph>compare()</codeph> メソッドの結果として新しい BitmapData オブジェクトが生成され、その各ピクセルは 2 つのビットマップ間の RGB 値の差分を示します。</p>
	 
	 <p>次のような 2 つの BitmapData オブジェクトがあるとします。両者の RGB カラーは同じですが、アルファ値は異なります。</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
	 </codeblock>
	 
	 <p><codeph>compare()</codeph> メソッドの結果として新しい BitmapData オブジェクトが生成され、その各ピクセルは 2 つのビットマップ間のアルファ値の差分を示します。</p>
	 
	 <p>BitmapData オブジェクトが等しい（幅、高さおよびピクセル値が同じ）場合、このメソッドは数値 0 を返します。</p>
	 
	 <p>BitmapData オブジェクトの幅が等しくない場合、このメソッドは数値 -3 を返します。 </p>
	 
	 <p>BitmapData オブジェクトの高さが等しくない場合、幅が同じであれば、このメソッドは数値 -4 を返します。</p>
	 
	 <p>次の例では、幅の異なる 2 つの Bitmap オブジェクトを比較します（それぞれの幅は 50 と 60）。</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 </apiDesc><example conref="examples\BitmapData.compare.1.as"> 次の例では、同じサイズの 2 つの BitmapData オブジェクトを比較した結果であるピクセル値が BitmapData オブジェクトの中に含まれます。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:copyChannel"><apiName>copyChannel</apiName><shortdesc>
	 別の BitmapData オブジェクトまたは現在の BitmapData オブジェクトの 1 つのチャンネルのデータを、現在の BitmapData オブジェクトのチャンネルに転送します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、または destPoint が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>使用する入力ビットマップイメージです。ソースイメージは、別の BitmapData オブジェクトにすることも、現在の BitmapData オブジェクトを参照することもできます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>ソース側の Rectangle オブジェクトです。ビットマップ内のより小さな領域のチャンネルデータだけをコピーするには、BitmapData オブジェクトのサイズ全体よりも小さいソース矩形を指定します。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>新しいチャンネルデータが配置される矩形領域の左上隅を表すターゲット Point オブジェクトです。ある特定の領域のチャンネルデータだけをターゲットイメージ内の別の領域にコピーするには、(0,0) 以外のポイントを指定します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>ソースチャンネルです。BitmapDataChannel クラスの値（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph>、<codeph>BitmapDataChannel.ALPHA</codeph>）を使用します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>ターゲットチャンネルです。BitmapDataChannel クラスの値（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph>、<codeph>BitmapDataChannel.ALPHA</codeph>）を使用します。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 別の BitmapData オブジェクトまたは現在の BitmapData オブジェクトの 1 つのチャンネルのデータを、現在の BitmapData オブジェクトのチャンネルに転送します。ターゲット BitmapData オブジェクト内のその他のチャンネルのデータはすべて保たれます。
	 
	 <p>ソースチャンネルの値とターゲットチャンネルの値は、次のいずれかになります。 </p>
	 <ul>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 </ul>

	 
	 </apiDesc><example conref="examples\BitmapData.copyChannel.1.as"> 次の例は、BitmapData オブジェクト内の赤チャンネルを、20×20 ピクセル領域にわたってオブジェクト独自の青チャンネルにコピーする方法を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:copyPixels"><apiName>copyPixels</apiName><shortdesc>
	 イメージ間のピクセル操作（伸長、回転、カラー効果なし）を高速に実行するルーチンを提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect または destPoint が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>ピクセルのコピー元となる入力ビットマップイメージです。ソースイメージは、別の BitmapData インスタンスにすることも、現在の BitmapData インスタンスを参照することもできます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>ターゲットポイントです。新しいピクセルが配置される矩形領域の左上隅を表します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>第 2 のアルファ BitmapData オブジェクトソースです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>アルファ BitmapData オブジェクトソース内のポイントです。<codeph>sourceRect</codeph> パラメーターの左上隅に対応します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mergeAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>アルファチャンネルを使用するには、値を <codeph>true</codeph> に設定します。アルファチャンネルを使用せずにピクセルをコピーするには、値を <codeph>false</codeph> に設定します。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 イメージ間のピクセル操作（伸長、回転、カラー効果なし）を高速に実行するルーチンを提供します。このメソッドは、ソースイメージの矩形領域を、ターゲット BitmapData オブジェクトのターゲットポイントにある同じサイズの矩形領域にコピーします。
	 
	 <p><codeph>alphaBitmap</codeph> パラメーターと <codeph>alphaPoint</codeph> パラメーターを含めれば、2 番目のイメージをソースイメージのアルファソースとして使用できます。ソースイメージにアルファデータがある場合、両方のアルファデータセットを使用して、ソースイメージのピクセルがソースイメージ上に合成されます。<codeph>alphaPoint</codeph> パラメーターは、アルファイメージ内のポイントであり、ソース側矩形の左上隅に対応するものです。ソースイメージとアルファイメージが交わらない部分のピクセルは、ターゲットイメージにコピーされません。</p>
	 
	 <p><codeph>mergeAlpha</codeph> プロパティは、透明なイメージを別の透明なイメージにコピーするときにアルファチャンネルを使用するかどうかを制御します。アルファチャンネルを使用してピクセルをコピーするには、<codeph>mergeAlpha</codeph> プロパティを <codeph>true</codeph> に設定します。<codeph>mergeAlpha</codeph> プロパティのデフォルト値は <codeph>false</codeph> です。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.copyPixels.1.as"> 次の例は、1 つの BitmapData オブジェクト内のピクセルを、20×20 ピクセル領域にわたって別の BitmapData オブジェクトにコピーする方法を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:dispose"><apiName>dispose</apiName><shortdesc>
	 BitmapData オブジェクトの格納に使用されるメモリを解放します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 BitmapData オブジェクトの格納に使用されるメモリを解放します。 
	 
	 <p><codeph>dispose()</codeph> メソッドをイメージに対して呼び出すと、イメージの高さと幅が 0 に設定されます。それ以降、この BitmapData インスタンスのメソッドまたはプロパティを呼び出すと失敗し、例外がスローされます。 </p>
	 <p><codeph>BitmapData.dispose()</codeph> は、実際のビットマップデータが占めていたメモリ領域を即時に解放します（ビットマップは最大で 64MB のメモリ領域を使用します）。<codeph>BitmapData.dispose()</codeph> を使用した後は BitmapData オブジェクトを使用できなくなり、BitmapData オブジェクトに対して関数を呼び出すと、Flash ランタイムから例外が返されます。ただし、<codeph>BitmapData.dispose()</codeph> では BitmapData オブジェクト（約 128 バイト）のガベージコレクションは行われません。実際の BitmapData オブジェクトが占めていたメモリ領域は、ガベージコレクターによって BitmapData オブジェクトが回収された時点で解放されます。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.dispose.1.as"> 次の例は、<codeph>dispose()</codeph> メソッドに対する呼び出し（例外がスロー）の後、BitmapData オブジェクトを呼び出したときの効果を示しています。
<codeblock>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.system.xml#System/gc()"><linktext>flash.system.System.gc()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:draw"><apiName>draw</apiName><shortdesc>
	 Flash Player または AIR のベクターレンダラーを使用して、source 表示オブジェクトをビットマップイメージ上に描画します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>source</codeph> パラメーターが、BitmapData または DisplayObject オブジェクトではありません。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>source</codeph> オブジェクト、および（Sprite または MovieClip オブジェクトの）すべての子オブジェクトが呼び出し元と同じドメインに属していないか、<codeph>Security.allowDomain()</codeph> メソッド呼び出し後に呼び出し元からアクセスできるコンテンツに含まれていません。この制限事項はアプリケーションセキュリティサンドボックス内の AIR コンテンツには適用されません。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>source が null であるか、有効な IBitmapDrawable オブジェクトではありません。
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>flash.display:IBitmapDrawable</apiOperationClassifier><apiDesc>BitmapData オブジェクトに描画される表示オブジェクトまたは BitmapData オブジェクトです （DisplayObject および BitmapData クラスは IBitmapDrawable インターフェイスを実装しています）。
	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>ビットマップの座標を拡大 / 縮小、回転、または変換するために使われる Matrix オブジェクトです。マトリックス変換をイメージに適用したくない場合は、（デフォルト <codeph>new Matrix()</codeph> コンストラクターを使って作成される）単位マトリックスにこのパラメーターを設定するか、<codeph>null</codeph> 値を渡してください。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>ビットマップのカラー値を調整するために使用する ColorTransform オブジェクトです。オブジェクトが提供されない場合、ビットマップイメージのカラーは変換されません。このパラメーターを渡す必要があるが、イメージを変換したくない場合、このパラメーターを、デフォルトの <codeph>new ColorTransform()</codeph> コンストラクターを使って作成される ColorTransform オブジェクトに設定します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>blendMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>結果として生成されるビットマップに適用されるブレンドモードを指定する、flash.display.BlendMode クラスのストリング値です。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>描画するソースオブジェクトの領域を定義する矩形オブジェクトです。この値を指定しない場合、クリッピングは発生せず、ソースオブジェクト全体が描画されます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><codeph>matrix</codeph> パラメーターでの拡大 / 縮小または回転により、拡大 / 縮小時または回転時に BitmapData オブジェクトがスムージングされるかどうかを決定するブール値です。<codeph>smoothing</codeph> パラメーターが適用されるのは、<codeph>source</codeph> パラメーターが BitmapData オブジェクトである場合のみです。<codeph>smoothing</codeph> を <codeph>false</codeph> に設定すると、回転または拡大 / 縮小した BitmapData イメージはピクセル化されたように、またはぎざぎざに表示されます。例えば、次の 2 つのイメージは、<codeph>source</codeph> パラメーターの同じ BitmapData オブジェクトを使用していますが、<codeph>smoothing</codeph> パラメーターは左の <codeph>true</codeph> と右の <codeph>false</codeph> に設定されています。
	 
	 <p><adobeimage alt="2 つのイメージの左側はスムージングあり、右側はスムージングなしです。" href="../../images/bitmapData_draw_smoothing.jpg"/></p>
	 
	 <p><codeph>smoothing</codeph>（<codeph>true</codeph> に設定済み）を使用してビットマップを描画すると、<codeph>smoothing</codeph>（<codeph>false</codeph> に設定済み）を使用して描画するより時間がかかります。</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 <codeph>source</codeph> 表示オブジェクトをビットマップイメージ上に描画します。描画には <ph platform="actionscript">Flash Player または</ph> AIR のベクターレンダラーが使用されます。 <codeph>matrix</codeph>、<codeph>colorTransform</codeph>、<codeph>blendMode</codeph>、およびターゲット <codeph>clipRect</codeph> パラメーターを指定することにより、レンダリングの実行方法を制御できます。さらに、必要に応じて、拡大 / 縮小時にビットマップのスムージングを行うかどうかを指定することもできます（これはソースオブジェクトが BitmapData オブジェクトの場合にのみ可能です）。
	  
	 <p>このメソッドは、オーサリングツールインターフェイスにおいてオブジェクトに対して標準ベクターレンダラーを使ってオブジェクトを描画する方法に直接対応します。</p>
	 
	 <p>ソース表示オブジェクトは、この呼び出しで適用される変換を使用しません。ライブラリやファイル内に存在するように処理され、マトリックス変換、カラー変換、ブレンドモードはありません。変換プロパティを使って（ムービークリップなどの）表示オブジェクトを描画するには、<codeph>transform</codeph> プロパティオブジェクトを、BitmapData オブジェクトを使用する Bitmap オブジェクトの <codeph>transform</codeph> プロパティにコピーすることができます。</p>
	 
     <p>このメソッドは、<ph platform="actionscript">Flash Player 9.0.115.0 以降および </ph>Adobe AIR の RTMP でサポートされます。サーバーサイドスクリプトで、Flash Media Server 上のストリームへのアクセスを制御することができます。詳細については、<codeph>Client.audioSampleAccess</codeph> プロパティおよび <codeph>Client.videoSampleAccess</codeph> プロパティのトピック（<xref href="http://www.adobe.com/go/documentation_jp" scope="external">『Server-Side ActionScript Language Reference for Adobe Flash Media Server』<i/></xref>）を参照してください。</p>
	 
	 <p platform="actionscript">ソースオブジェクトと（Sprite または MovieClip オブジェクトの場合）その子オブジェクトすべてが、呼び出し元の同一のドメインから来たのではない場合、または <codeph>Security.allowDomain()</codeph> メソッドを呼び出したことによって呼び出し元にアクセス可能なコンテンツ内に存在しない場合、<codeph>draw()</codeph> への呼び出しは SecurityError 例外をスローします。この制限事項はアプリケーションセキュリティサンドボックス内の AIR コンテンツには適用されません。</p>
	 
	 <p platform="actionscript">ロードされたビットマップイメージの <codeph>source</codeph> としての使用にも制限があります。ロードされたイメージが呼び出し元と同じドメインに存在していた場合、<codeph>draw()</codeph> メソッドの呼び出しは成功します。また、イメージのサーバー上のクロスドメインポリシーファイルで、<codeph>draw()</codeph> メソッドを呼び出す SWF コンテンツのドメインに対して許可を与えることもできます。この場合、LoaderContext オブジェクトの <codeph>checkPolicyFile</codeph> プロパティを設定し、このオブジェクトを <codeph>context</codeph> パラメーターとして、イメージの読み込みに使用する Loader オブジェクトの <codeph>load()</codeph> メソッドを呼び出すときに使用する必要があります。これらの制限は、アプリケーションセキュリティサンドボックス内の AIR コンテンツには適用されません。</p>
	 
	 <p>Windows では、<codeph>draw()</codeph> メソッドは <ph platform="actionscript">Adobe AIR</ph> の HTMLLoader オブジェクトにある HTML ページに組み込まれた SWF コンテンツをキャプチャできません。</p>
	 
	 <p><codeph>draw()</codeph> メソッドは <ph platform="actionscript">Adobe AIR</ph> では PDF コンテンツをキャプチャできません。また、<codeph>wmode</codeph> 属性が <codeph>"window"</codeph> に設定されている HTML に埋め込まれた SWF コンテンツをキャプチャできません<ph platform="actionscript">（Adobe AIR の場合）</ph>。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.draw.1.as"> 次の例は、TextField オブジェクトを BitmapData オブジェクトに描画する方法を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:fillRect"><apiName>fillRect</apiName><shortdesc>
	 指定された ARGB カラーで矩形領域のピクセルを塗りつぶします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>rect が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>塗りつぶす矩形領域です。
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>領域を塗りつぶすため使用される ARGB カラー値です。ARGB カラー値は通常、16 進数形式（例えば、0xFF336699）で指定します。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定された ARGB カラーで矩形領域のピクセルを塗りつぶします。
	 
	 </apiDesc><example conref="examples\BitmapData.fillRect.1.as"> 次の例は BitmapData オブジェクトの矩形領域を青で塗りつぶす方法を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:floodFill"><apiName>floodFill</apiName><shortdesc>
	 (x, y) 座標を始点として所定の色で塗りつぶすことにより、イメージに対する塗りつぶし処理を実行します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>イメージの <i>x</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>イメージの <i>y</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>塗りとして使用する ARGB カラーです。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>(x, y) 座標を始点として、イメージの塗りつぶし処理を実行します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 (<i>x</i> , <i>y</i>) 座標を始点として所定の色で塗りつぶすことにより、イメージに対する塗りつぶし処理を実行します。<codeph>floodFill()</codeph> メソッドは、各種のペイントプログラムのバケツツールのようなものです。color は、アルファ情報とカラー情報を含む ARGB カラーです。
	 
	 </apiDesc><example conref="examples\BitmapData.floodFill.1.as"> 次の例では、BitmapData オブジェクトの領域（つまり、ポイント<codeph>（10, 10）</codeph>で定義されたピクセルを囲んでいる領域で、すべてのカラーがそのポイントと同じ色になっている）を赤で塗りつぶす方法を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:generateFilterRect"><apiName>generateFilterRect</apiName><shortdesc>
	 BitmapData オブジェクト、ソース矩形、フィルターオブジェクトを指定して、applyFilter() メソッド呼び出しによって影響を受けるターゲット矩形を決定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceRect または filter が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>イメージ、<codeph>sourceRect</codeph> パラメーター、およびフィルターを使って算出されるターゲット矩形です。
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>ターゲット矩形を算出するために使用するフィルターオブジェクトです。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>applyFilter() 呼び出しによって影響を受けるターゲット矩形を判別します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 BitmapData オブジェクト、ソース矩形、フィルターオブジェクトを指定して、<codeph>applyFilter()</codeph> メソッド呼び出しによって影響を受けるターゲット矩形を決定します。
	 
	 <p>例えば、ぼかしフィルターは通常、元のイメージのサイズよりも大きい領域に影響します。デフォルトの BlurFilter インスタンスによってフィルターが適用される 100 x 200 ピクセルのイメージでは、<codeph>blurX = blurY = 4</codeph> が <codeph>(-2,-2,104,204)</codeph> というターゲット矩形を生成します。<codeph>generateFilterRect()</codeph> メソッドを使用すると、このターゲット矩形のサイズを前もって知ることができるので、フィルター処理の前にターゲットイメージを適切なサイズにすることができます。</p>
	 
	 <p>一部のフィルターでは、ソースイメージのサイズに基づいてターゲット矩形がクリッピングされる場合があります。例えば、内側の <codeph>DropShadow</codeph> は、ソースイメージよりも大きい結果を生成しません。この API では、ソース <codeph>rect</codeph> パラメーターではなく、BitmapData オブジェクトをソースの境界として使用します。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.generateFilterRect.1.as"> 次の例では、<codeph>generateFilterRect()</codeph> メソッドを使用して、ぼかしフィルターの結果が占める矩形領域を決定する方法を示しています。<codeph>generateFilterRect()</codeph> メソッドの結果は、<codeph>trace()</codeph> 関数により出力されます。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock> <codeph>generateFilterRect()</codeph> メソッドはフィルターを適用しない点に注意してください。<codeph>applyFilter()</codeph> メソッドを呼び出してフィルターを適用します。 
</example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getColorBoundsRect"><apiName>getColorBoundsRect</apiName><shortdesc>
	 （findColor パラメーターが true に設定されている場合）ビットマップイメージ内の指定された色のすべてのピクセルを完全に囲む矩形領域を判別します。または、（findColor パラメーターが false に設定されている場合）指定された色ではないすべてのピクセルを完全に囲む矩形領域を判別します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定された色であるイメージの領域です。 
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>対象となる ARGB カラーのビットを指定する 16 進数値です。カラー値は、<codeph>&amp;</codeph>（ビット単位の論理積（AND））演算子を使用して、この 16 進数値と組み合わせられます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>16 進数値です。（<codeph>findColor</codeph> が <codeph>true</codeph> に設定されている場合は）一致すべき ARGB カラー、一致すべき<i>でない</i> ARGB カラー（<codeph>findColor</codeph> が <codeph>false</codeph> に設定されている場合）をそれぞれ指定します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>findColor</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>値が <codeph>true</codeph> に設定された場合、イメージ内のカラー値の境界を返します。値が <codeph>false</codeph> に設定された場合、イメージ内の指定されたカラーが存在しない領域の境界を返します。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 （<codeph>findColor</codeph> パラメーターが <codeph>true</codeph> に設定されている場合）ビットマップイメージ内の指定された色のすべてのピクセルを完全に囲む矩形領域を判別します。または、（<codeph>findColor</codeph> パラメーターが <codeph>false</codeph> に設定されている場合）指定された色ではないすべてのピクセルを完全に囲む矩形領域を判別します。 
	 
	 <p>例えば、あるソースイメージで、0 以外のアルファチャンネルを含むイメージの矩形を判別するには、パラメーターとして <codeph>{mask: 0xFF000000, color: 0x00000000}</codeph> を渡します。<codeph>findColor</codeph> パラメーターが <codeph>true</codeph> に設定されている場合、<codeph>(value &amp; mask) == color</codeph> であるピクセルの境界を見つけるためにイメージ全体が検索されます（<codeph>value</codeph> はピクセルのカラー値）。<codeph>findColor</codeph> パラメーターが <codeph>false</codeph> に設定されている場合、<codeph>(value &amp; mask) !== color</codeph> であるピクセルの境界を見つけるためにイメージ全体が検索されます（<codeph>value</codeph> はピクセルのカラー値）。 イメージの周囲の空白を判別するには、空白以外のピクセルの境界を見つけるために、<codeph>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</codeph> を渡してください。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getColorBoundsRect.1.as"> 次の例では、上半分のピクセルが赤である BitmapData オブジェクトを作成します。<codeph>getColorBoundsRect()</codeph> メソッドを呼び出して、赤（0xFF0000）のピクセルからなる矩形を判別します。さらに、（<codeph>findColor</codeph> パラメーターを <codeph>false</codeph> に設定して）同じメソッドを呼び出し、中のピクセルが赤でない矩形を判別します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getPixel"><apiName>getPixel</apiName><shortdesc>
	 BitmapData オブジェクトの特定ポイント (x, y) の RGB ピクセル値を表す整数を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>RGB ピクセル値を表す数値。(<i>x</i> , <i>y</i>) 座標がイメージの境界外である場合は、0 を返します。 
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ピクセルの <i>x</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ピクセルの <i>y</i> 座標です。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>BitmapData オブジェクトの特定ポイントの RGB ピクセル値を表す整数を返します。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 BitmapData オブジェクトの特定ポイント (<i>x</i>, <i>y</i>) の RGB ピクセル値を表す整数を返します。<codeph>getPixel()</codeph> メソッドは、乗算されていないピクセル値を返します。アルファ情報は返しません。
	 
	 <p>BitmapData オブジェクト内のピクセルはすべて、乗算済みカラー値として保存されます。乗算済みイメージピクセルは、アルファデータが既に乗算された赤、緑、青の各カラーチャンネル値を保持します。例えば、アルファ値が 0 の場合、乗算されていない値に関わらず、RGB チャンネルの値も 0 になります。このようにデータが失われると、処理の実行時に問題が生じることがあります。BitmapData のすべてのメソッドは、乗算されていない値を受け取ったり返したりします。ピクセルの内部表現は、値として返される前に、乗算済みから非乗算に変換されます。設定処理の際は、ピクセル値が事前に乗算されてから、生のイメージピクセルが設定されます。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel.1.as"> 次の例では、塗りが赤の BitmapData オブジェクトを作成し、次に <codeph>getPixel()</codeph> メソッドを使用して、左上隅のピクセルの色の値を決定しています。
<codeblock>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(1, 1);
trace(pixelValue.toString(16)); // ff0000;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixel32"><apiName>getPixel32</apiName><shortdesc>
	 アルファチャンネルデータと RGB データを含む ARGB カラー値を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>ARGB ピクセル値を表す数値です。(<i>x</i>, <i>y</i>) 座標がイメージの境界外である場合は、0 を返します。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ピクセルの <i>x</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ピクセルの <i>y</i> 座標です。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 アルファチャンネルデータと RGB データを含む ARGB カラー値を返します。このメソッドは <codeph>getPixel()</codeph> メソッドと似ていますが、getPixel() メソッドはアルファチャンネルデータがない RGB カラーを返します。
	 
	 <p>BitmapData オブジェクト内のピクセルはすべて、乗算済みカラー値として保存されます。乗算済みイメージピクセルは、アルファデータが既に乗算された赤、緑、青の各カラーチャンネル値を保持します。例えば、アルファ値が 0 の場合、乗算されていない値に関わらず、RGB チャンネルの値も 0 になります。このようにデータが失われると、処理の実行時に問題が生じることがあります。BitmapData のすべてのメソッドは、乗算されていない値を受け取ったり返したりします。ピクセルの内部表現は、値として返される前に、乗算済みから非乗算に変換されます。設定処理の際は、ピクセル値が事前に乗算されてから、生のイメージピクセルが設定されます。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel32.1.as"> 次の例では、色で塗られた BitmapData オブジェクトを作成し、次に <codeph>getPixel32()</codeph> メソッドを使用して左上隅のピクセルの色の値を決定し、さらに各カラー成分（アルファ、赤、緑、青）の 16 進数値を決定します。
<codeblock>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(1, 1);
var alphaValue:uint = pixelValue >> 24 &amp; 0xFF;
var red:uint = pixelValue >> 16 &amp; 0xFF;
var green:uint = pixelValue >> 8 &amp; 0xFF;
var blue:uint = pixelValue &amp; 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixels"><apiName>getPixels</apiName><shortdesc>
	 ピクセルデータの矩形領域からバイト配列を生成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>rect が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>特定の矩形内のピクセルを表す ByteArray です。
	 
	 </apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>現在の BitmapData オブジェクト内の矩形領域です。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 ピクセルデータの矩形領域からバイト配列を生成します。各ピクセルごとに、符号なし整数（32 ビットの乗算されないピクセル値）をバイト配列に書き込みます。
	 
	 </apiDesc><example conref="examples\BitmapData.getPixels.1.as"> 次の例では、ランダムノイズピクセルで塗りつぶされた BitmapData オブジェクトを作成し、<codeph>getPixels()</codeph> メソッドを使用して、ByteArray オブジェクトを BitmapData オブジェクトのピクセル値で塗りつぶします。
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getVector"><apiName>getVector</apiName><shortdesc>
	 ピクセルデータの矩形領域からベクター配列を生成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>rect が null です。
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定された Rectangle を表す Vector です。
	 </apiDesc><apiType value="Vector$uint"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>現在の BitmapData オブジェクト内の矩形領域です。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 ピクセルデータの矩形領域からベクター配列を生成します。指定された矩形を表す、符号なし整数（32 ビットの乗算されないピクセル値）の Vector オブジェクトを返します。
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:histogram"><apiName>histogram</apiName><shortdesc>
	 BitmapData オブジェクトの 256 値のバイナリ数のヒストグラムを計算します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Vector$Vector$Number"/></apiReturn><apiParam><apiItemName>hRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>BitmapData オブジェクトの使用領域です。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 BitmapData オブジェクトの 256 値のバイナリ数のヒストグラムを計算します。このメソッドは 4 つの Vector を含む Vector オブジェクトを返します。&lt;Number> インスタンス（Number オブジェクトを含む 4 つの Vector オブジェクト）です。4 つの Vector インスタンスは、赤、緑、青およびアルファの順の各コンポーネントを表します。各 Vector インスタンスには、各コンポーネントの値のポピュレーションカウント（0 ～ 255）を表す 256 値が含まれています。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:hitTest"><apiName>hitTest</apiName><shortdesc>
	 1 つのビットマップイメージと、ポイント、矩形、または他のビットマップイメージとの間でピクセルレベルのヒットを検出します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>secondObject</codeph> パラメーターが、Point、Rectangle、Bitmap、または BitmapData オブジェクトではありません。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>firstPoint が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>ヒットが発生する場合は <codeph>true</codeph>、そうでない場合は <codeph>false</codeph> です。
	    
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>firstPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc> 任意の座標空間における BitmapData イメージの左上隅の位置です。同じ座標空間を使って <codeph>secondBitmapPoint</codeph> パラメーターが定義されます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>firstAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>このヒットテストで不透明とみなされるアルファチャンネルの最小値です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Rectangle、Point、Bitmap、または BitmapData オブジェクトです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondBitmapDataPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>2 番目の BitmapData オブジェクト内のピクセル位置を定義するポイントです。このパラメーターは、<codeph>secondObject</codeph> の値が BitmapData オブジェクトである場合にのみ使用します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>1</apiData><apiDesc>2 番目の BitmapData オブジェクト内で不透明であるとみなされるアルファチャンネルの最小値です。このパラメーターは、<codeph>secondObject</codeph> の値が BitmapData オブジェクトで、両方の BitmapData オブジェクトが透明である場合にのみ使用します。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 1 つのビットマップイメージと、ポイント、矩形、または他のビットマップイメージとの間でピクセルレベルのヒットを検出します。ヒットは、1 つの不透明なピクセルまたは 2 つの重なり合う不透明なピクセル上のポイントまたは矩形の重なりです。ヒットテストの際、どちらのオブジェクトの変換（伸縮、回転など）も考慮されません。 
	 
	 <p>イメージが不透明である場合、このメソッドでは完全に不透明な矩形と見なされます。透過性を考慮するピクセルレベルのヒットテストを実施する場合は、両方のイメージとも透明である必要があります。2 つの透明なイメージをテストするとき、アルファしきい値パラメーターは、アルファチャンネル値（0 ～ 255）がいくつであれば不透明とみなすかを制御します。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.hitTest.1.as"> 次の例では、矩形領域 (20, 20, 40, 40) でのみ不透明な BitmapData オブジェクトを作成した後、<codeph>hitTest()</codeph> メソッドを呼び出します（<codeph>secondObject</codeph> として Point オブジェクトを使用）。最初の呼び出しでは、Point オブジェクトが（不透明ではない）BitmapData オブジェクトの左上隅を定義し、2 番目の呼び出しでは、Point オブジェクトが（不透明な）BitmapData オブジェクトの中央を定義します。
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:lock"><apiName>lock</apiName><shortdesc>
	 この BitmapData オブジェクトが変更されたときに、BitmapData オブジェクトを参照するすべてのオブジェクト（例えば Bitmap オブジェクト）が更新されないように、イメージをロックします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 この BitmapData オブジェクトが変更されたときに、BitmapData オブジェクトを参照するすべてのオブジェクト（例えば Bitmap オブジェクト）が更新されないように、イメージをロックします。パフォーマンスを向上させるには、このメソッドを <codeph>unlock()</codeph> メソッドと共に、<codeph>setPixel()</codeph> メソッドまたは <codeph>setPixel32()</codeph> メソッドを何度も呼び出す前後に使用してください。
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> 次の例では、<codeph>bitmapData</codeph> プロパティ（Bitmap オブジェクトである <codeph>picture</codeph> のプロパティ）に基づいて BitmapData オブジェクトを作成します。次に、<codeph>lock()</codeph> メソッドを呼び出してから、BitmapData オブジェクトを変更する複雑なカスタム関数である <codeph>complexTransformation()</codeph> を呼び出します （<codeph>picture</codeph> オブジェクトおよび <codeph>complexTransformation()</codeph> 関数はこの例では定義されません）。<codeph>complexTransformation()</codeph> 関数が <codeph>bitmapData</codeph> プロパティ（<codeph>picture</codeph> オブジェクトのプロパティ）を更新する場合でも、コードが <codeph>unlock()</codeph> メソッドを <codeph>bitmapData</codeph> オブジェクトに対して呼び出すまで、変更は反映されません。
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:merge"><apiName>merge</apiName><shortdesc>
     ソースイメージとターゲットイメージをチャンネルごとにブレンドします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、または destPoint が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>使用する入力ビットマップイメージです。ソースイメージは、別の BitmapData オブジェクトにすることも、現在の BitmapData オブジェクトを参照することもできます。
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>ソース矩形の左上隅に対応する、ターゲットイメージ（現在の BitmapData インスタンス）内のポイントです。
     </apiDesc></apiParam><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>赤チャンネル値に乗算する 16 進数の uint 値です。 
     </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>緑チャンネル値に乗算する 16 進数の uint 値です。 
     </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>青チャンネル値に乗算する 16 進数の uint 値です。
     </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>アルファ透明度の値に乗算する 16 進数の uint 値です。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     ソースイメージとターゲットイメージをチャンネルごとにブレンドします。チャンネルおよびピクセルごとに、ソースピクセルおよびターゲットピクセルのチャンネル値に基づいて新しい値が計算されます。例えば、赤チャンネルでは、新しい値が次のように計算されます（ここで、<codeph>redSrc</codeph> はソースイメージのピクセルでの赤チャンネル値、<codeph>redDest</codeph> はターゲットイメージの対応するピクセルでの赤チャンネル値です）。 
	 <p>
	 <codeph> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </codeph>
	 </p>
	 
	 <p><codeph>redMultiplier</codeph>、<codeph>greenMultiplier</codeph>、<codeph>blueMultiplier</codeph>、および <codeph>alphaMultiplier</codeph> の各値は、それぞれのカラーチャンネルに対して使用する乗数です。<codeph>0</codeph> から <codeph>0x100</codeph>（256）までの 16 進数値を使用します。<codeph>0</codeph> を指定すると、ターゲットの値がそのまま結果で使用され、<codeph>0x100</codeph> を指定すると、ソースの値がそのまま使用されます。その間の数値を指定すると、混ぜ合わされた色が使用されます（50% の場合、<codeph>0x80</codeph> など）。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.merge.1.as"> 次の例では、2 つの BitmapData オブジェクトを作成します。どちらのサイズも 100 x 80 ピクセルです。最初のオブジェクトは緑、2 番目のオブジェクトは赤でそれぞれ塗りつぶされます。コードは <codeph>merge()</codeph> メソッドを呼び出し、2 番目の BitmapData ピクセルを最初の BitmapData オブジェクトの指定された矩形領域にのみ結合します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:noise"><apiName>noise</apiName><shortdesc>
	 ランダムノイズを表すピクセルでイメージを塗りつぶします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ランダムシード（乱数の種）として使用する数値です。他のすべてのパラメーターを同じままにした場合、ランダムシードの値を変更することでさまざまな疑似乱数を生成できます。ノイズ関数はマッピング関数であり、真の乱数生成関数ではありません。このため、同じランダムシードから毎回同じ結果が作成されます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>low</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>チャンネルごとに生成する最小値です（0 ～ 255）。 
	 </apiDesc></apiParam><apiParam><apiItemName>high</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>255</apiData><apiDesc>チャンネルごとに生成する最大値です（0 ～ 255）。 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc>任意の 4 つのカラーチャンネル値（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph>、および <codeph>BitmapDataChannel.ALPHA</codeph>）の組み合わせである数値。OR 論理演算子（<codeph>|</codeph>）を使用して、複数のチャンネル値を組み合わせることができます。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ブール値です。値が <codeph>true</codeph> である場合、すべてのカラーチャンネルに同じ値を設定することでグレースケールのイメージが作成されます。このパラメーターを <codeph>true</codeph> に設定しても、アルファチャンネル選択には影響しません。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 ランダムノイズを表すピクセルでイメージを塗りつぶします。
	 
	 </apiDesc><example conref="examples\BitmapData.noise.1.as"> 次の例では、2 つの BitmapData オブジェクトを作成し、両者に対して <codeph>noise()</codeph> メソッドを呼び出します。ただし、<codeph>grayscale</codeph> パラメーターは <codeph>false</codeph> に設定されるか（1 番目のオブジェクトの <codeph>noise()</codeph> メソッドへの呼び出しの場合）、<codeph>true</codeph> に設定されます（2 番目のオブジェクトの <codeph>noise()</codeph> メソッドへの呼び出しの場合）。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapDataChannel/RED"><linktext>flash.display.BitmapDataChannel.RED</linktext></link><link href="flash.display.xml#BitmapDataChannel/BLUE"><linktext>flash.display.BitmapDataChannel.BLUE</linktext></link><link href="flash.display.xml#BitmapDataChannel/GREEN"><linktext>flash.display.BitmapDataChannel.GREEN</linktext></link><link href="flash.display.xml#BitmapDataChannel/ALPHA"><linktext>flash.display.BitmapDataChannel.ALPHA</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:paletteMap"><apiName>paletteMap</apiName><shortdesc>
	 最大で 4 つのカラーパレットデータ配列（各チャンネルごとに 1 つの配列）を使用して、イメージ内のカラーチャンネル値をマッピングし直します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、または destPoint が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>使用する入力ビットマップイメージです。ソースイメージは、別の BitmapData オブジェクトにすることも、現在の BitmapData インスタンスを参照することもできます。
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>ソース矩形の左上隅に対応する、ターゲットイメージ（現在の BitmapData オブジェクト）内のポイントです。
	 </apiDesc></apiParam><apiParam><apiItemName>redArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>redArray</codeph> が <codeph>null</codeph> でない場合、<codeph>red = redArray[source red value] else red = source rect value</codeph>。
	 </apiDesc></apiParam><apiParam><apiItemName>greenArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>greenArray</codeph> が <codeph>null</codeph> でない場合、<codeph>green = greenArray[source green value] else green = source green value.</codeph>。
	 </apiDesc></apiParam><apiParam><apiItemName>blueArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>blueArray</codeph> が <codeph>null</codeph> でない場合、<codeph>blue = blueArray[source blue value] else blue = source blue value</codeph>。
	 </apiDesc></apiParam><apiParam><apiItemName>alphaArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>alphaArray</codeph> が <codeph>null</codeph> でない場合、<codeph>alpha = alphaArray[source alpha value] else alpha = source alpha value</codeph>。
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 最大で 4 つのカラーパレットデータ配列（各チャンネルごとに 1 つの配列）を使用して、イメージ内のカラーチャンネル値をマッピングし直します。 
	 
	 <p><ph platform="actionscript">Flash Player</ph> または AIR は以下の手順に従って、結果として得られるイメージを生成します。</p>
	 
	 <ol>
	 
	 <li>赤、緑、青、アルファの各値を算出した後、標準の 32 ビット整数算術演算を使ってこれらの値を足し合わせます。 </li>
	 
	 <li>各ピクセルの赤、緑、青、アルファのチャンネル値を抽出して、別個の 0 ～ 255 の値にします。これらの値は、次の該当する配列で新しいカラー値を調べる場合に使用します。<codeph>redArray</codeph>、<codeph>greenArray</codeph>、<codeph>blueArray</codeph>、および <codeph>alphaArray</codeph>。これら 4 つの配列にはそれぞれ 256 個の値が含まれている必要があります。 </li>
	 
	 <li>新しいチャンネル値を 4 つともすべて取得した後、それらの値を組み合わせて、ピクセルに適用される標準の ARGB 値にします。</li>
	 
	 </ol>
	 
	 <p>このメソッドではクロスチャンネル効果をサポートできます。それぞれの入力配列は完全な 32 ビット値を含むことができます。値を足し合わせるときに移動は発生しません。このルーチンは、チャンネル単位のクランピングに対応していません。 </p>
	 
	 <p>チャンネルに対して配列が指定されない場合は、ソースイメージからターゲットイメージにカラーチャンネルがコピーされます。</p>
	 
	 <p>このメソッドは各種効果で使用できます。例えば、通常のパレットマッピング（1 つのチャンネルを選択して疑似色イメージに変換する）などです。さらに、ガンマ、曲線、平準化、量子化といったさまざまなカラー操作アルゴリズムにもこのメソッドを使用できます。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.paletteMap.1.as"> 次の例では、中央に赤い正方形がある緑の BitmapData オブジェクトを作成した後、<codeph>paletteMap()</codeph> メソッドを使用して、BitmapData オブジェクトの下半分の矩形内の赤と緑を入れ替えます。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:perlinNoise"><apiName>perlinNoise</apiName><shortdesc>
	 Perlin ノイズイメージを生成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>baseX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc><i>x</i> 方向で使用する周波数。例えば、64 x 128 のイメージに見合うサイズのノイズを生成するには、<codeph>baseX</codeph> 値として 64 を渡します。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>baseY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc><i>y</i> 方向で使用する周波数。例えば、64 x 128 のイメージに見合うサイズのノイズを生成するには、<codeph>baseY</codeph> 値として 128 を渡します。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numOctaves</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>このノイズを作成するために組み合わせるオクターブ（つまり個々のノイズ関数）の数です。オクターブ数を多くすると、よりきめ細かいイメージを作成できます。オクターブ数を増やすと、処理時間も長くなります。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>ランダムシード（乱数の種）として使用する数値です。他のすべてのパラメーターを同じままにした場合、ランダムシードの値を変更することでさまざまな疑似乱数を生成できます。Perlin ノイズ関数はマッピング関数であり、真の乱数生成関数ではありません。このため、同じランダムシードから毎回同じ結果が作成されます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>stitch</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>ブール値です。値が <codeph>true</codeph> の場合、ビットマップ塗りとしてシームレスなタイリング用テクスチャを作成するために、このメソッドはイメージのトランジションエッジをスムーズにすることを試みます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fractalNoise</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>ブール値です。値が <codeph>true</codeph> の場合、このメソッドはフラクタルノイズを生成します。それ以外の場合は、乱流を生成します。乱流があるイメージにはグラデーションに視覚的な不連続性があるので、炎や海の波のようなシャープな視覚効果に適している場合があります。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc> 任意の 4 つのカラーチャンネル値（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph>、および <codeph>BitmapDataChannel.ALPHA</codeph>）の組み合わせである数値。OR 論理演算子（<codeph>|</codeph>）を使用して、複数のチャンネル値を組み合わせることができます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ブール値です。値が <codeph>true</codeph> の場合、赤、緑、および青の各カラーチャンネルに同じ値を設定して、グレースケールイメージが作成されます。この値が <codeph>true</codeph> に設定されても、アルファチャンネルの値に影響はありません。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>offsets</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>各オクターブの <i>x</i> オフセットと <i>y</i> オフセットに対応するポイントの配列です。オフセット値を操作することで、perlinNoise イメージのレイヤーをスムーズにスクロールできます。オフセット配列内の各ポイントは、特定のオクターブノイズ関数に影響を与えます。
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Perlin ノイズイメージを生成します。
	 
	 <p>Perlin ノイズ生成アルゴリズムでは、個々のランダムノイズ関数（オクターブといいます）を補間および組み合わせることで、より自然に見えるランダムノイズを生成する単一の関数にします。音楽のオクターブと同様、各オクターブ関数の周波数は、その前のオクターブ関数の周波数の 2 倍になります。Perlin ノイズは、複数のノイズデータセットをさまざまな詳細レベルで組み合わせるので、"フラクタルノイズの和" と呼ばれてきました。</p>
	 
	 <p>Perlin ノイズ関数は、木目、雲、山脈など、自然現象や風景をシミュレートする場合に使用できます。ほとんどの場合、Perlin ノイズ関数の出力をそのまま表示するのではなく、他のイメージを強調したり、擬似ランダムバリエーションを与えるために使用します。</p>
	 
	 <p>単純なデジタルランダムノイズ関数は、コントラストのきついポイントが含まれるイメージを生成する場合が多いです。このようにきついコントラストは自然界にはあまりありません。Perlin ノイズアルゴリズムは、さまざまな詳細レベルで実行する複数のノイズ関数を混ぜ合わせます。このアルゴリズムの結果、互いに隣接するピクセル値の差異はより小さくなります。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.perlinNoise.1.as"> 次の例では、<codeph>perlinNoise()</codeph> メソッドを呼び出して赤および青の水彩画効果を生み出す 200 x 200 ピクセルの BitmapData オブジェクトを作成します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:pixelDissolve"><apiName>pixelDissolve</apiName><shortdesc>
	 ソースイメージからターゲットイメージへのピクセルディゾルブ、または同じイメージを使用したピクセルディゾルブを実行します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、または destPoint が null です。
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>numPixels が負の値です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>後続の呼び出しで使用する新しいランダムシード（乱数の種）です。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>使用する入力ビットマップイメージです。ソースイメージは、別の BitmapData オブジェクトにすることも、現在の BitmapData インスタンスを参照することもできます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>ソース矩形の左上隅に対応する、ターゲットイメージ（現在の BitmapData インスタンス）内のポイントです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>ピクセルディゾルブを開始するために使用するランダムシード（乱数の種）です。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numPixels</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>デフォルトは、ソース領域（幅 x 高さ）の 1/30 です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>ソース値とターゲット値が等しいピクセルの塗りつぶしに使用する ARGB カラー値です。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 ソースイメージからターゲットイメージへのピクセルディゾルブ、または同じイメージを使用したピクセルディゾルブを実行します。<ph platform="actionscript">Flash Player</ph> または AIR は <codeph>randomSeed</codeph> 値を使ってランダムなピクセルディゾルブを生成します。完了するまでピクセルディゾルブを続けるには、この関数の戻り値を後続の呼び出しに渡す必要があります。
	 
	 <p>ソースイメージとターゲットイメージが等しくない場合は、すべてのプロパティを使用して、ソースからターゲットにピクセルがコピーされます。この処理により、空白イメージから完全に設定されたイメージへのディゾルブが可能になります。</p>
	 
	 <p>ソースイメージとターゲットイメージが等しい場合は、<codeph>color</codeph> パラメーターを使ってピクセルが塗られます。この処理により、完全に設定されたイメージを消去するようにディゾルブできます。このモードでは、ターゲット <codeph>point</codeph> パラメーターが無視されます。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.pixelDissolve.1.as"> 次の例では、<codeph>pixelDissolve()</codeph> メソッドを使用して、すべてのピクセルのカラーが変更されるまで一度に 40 個のピクセルをディゾルブすることにより、グレーの BitmapData オブジェクトを赤に変換します。
<codeblock>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 &amp;&amp; grayRegion.height == 0 ) {
        tim.stop();
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:scroll"><apiName>scroll</apiName><shortdesc>
	 所定の (x, y) ピクセル量だけイメージをスクロールします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>水平方向のスクロール量です。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>垂直方向のスクロール量です。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 所定の (<i>x</i> , <i>y</i>) ピクセル量だけイメージをスクロールします。スクロール領域外のエッジ領域は変わらずにそのままになります。
	 
	 </apiDesc><example conref="examples\BitmapData.scroll.1.as"> 次の例は、Bitmap データオブジェクトを右に 40 ピクセルだけスクロールした効果を示しています。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:setPixel"><apiName>setPixel</apiName><shortdesc>
	 BitmapData オブジェクトの 1 つのピクセルを設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>値が変更されるピクセルの <i>x</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>値が変更されるピクセルの <i>y</i> 座標です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>結果として生成される、ピクセルの RGB カラーです。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 BitmapData オブジェクトの 1 つのピクセルを設定します。この処理中、イメージピクセルのアルファチャンネルは現在の値が保持されます。RGB カラーパラメーターの値は、乗算されていないカラー値として扱われます。
	 
	 <p><b>注意：</b><codeph>setPixel()</codeph> または <codeph>setPixel32()</codeph> メソッドを繰り返し使用する場合、パフォーマンスを向上させるには、<codeph>lock()</codeph> メソッドを呼び出してから <codeph>setPixel()</codeph> または <codeph>setPixel32()</codeph> メソッドを呼び出します。その後、ピクセル変更がすべて完了したら、<codeph>unlock()</codeph> メソッドを呼び出します。このように処理を行うと、ピクセル変更がすべて完了するまで、この BitmapData インスタンスを参照するオブジェクトは更新されません。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel.1.as"> 次の例では、<codeph>setPixel()</codeph> メソッドを使用して、BitmapData オブジェクト内に赤い線を描画します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixel32"><apiName>setPixel32</apiName><shortdesc>
	 BitmapData オブジェクトの 1 つのピクセルにカラー値とアルファ透明度を設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>値が変更されるピクセルの <i>x</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>値が変更されるピクセルの <i>y</i> 座標です。
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>結果として生成される、ピクセルの ARGB カラーです。ビットマップが不透明な（透明でない）場合には、このカラー値のアルファ透明度部分は無視されます。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 BitmapData オブジェクトの 1 つのピクセルにカラー値とアルファ透明度を設定します。このメソッドは <codeph>setPixel()</codeph> メソッドと似ています。主な違いは、<codeph>setPixel32()</codeph> メソッドではアルファチャンネル情報が含まれる ARGB カラー値を引数として取ることです。
	 
	 <p>BitmapData オブジェクト内のピクセルはすべて、乗算済みカラー値として保存されます。乗算済みイメージピクセルは、アルファデータが既に乗算された赤、緑、青の各カラーチャンネル値を保持します。例えば、アルファ値が 0 の場合、乗算されていない値に関わらず、RGB チャンネルの値も 0 になります。このようにデータが失われると、処理の実行時に問題が生じることがあります。BitmapData のすべてのメソッドは、乗算されていない値を受け取ったり返したりします。ピクセルの内部表現は、値として返される前に、乗算済みから非乗算に変換されます。設定処理の際は、ピクセル値が事前に乗算されてから、生のイメージピクセルが設定されます。</p>
	 
	 <p><b>注意：</b><codeph>setPixel()</codeph> または <codeph>setPixel32()</codeph> メソッドを繰り返し使用する場合、パフォーマンスを向上させるには、<codeph>lock()</codeph> メソッドを呼び出してから <codeph>setPixel()</codeph> または <codeph>setPixel32()</codeph> メソッドを呼び出します。その後、ピクセル変更がすべて完了したら、<codeph>unlock()</codeph> メソッドを呼び出します。このように処理を行うと、ピクセル変更がすべて完了するまで、この BitmapData インスタンスを参照するオブジェクトは更新されません。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel32.1.as"> 次の例では、<codeph>setPixel32()</codeph>メソッドを使用して、透明な（alpha == 0x60）赤い線を BitmapData オブジェクト内に描画します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixels"><apiName>setPixels</apiName><shortdesc>
	 バイト配列をピクセルデータの矩形領域に変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>inputByteArray</codeph> オブジェクトには、<codeph>rect</codeph> 矩形の領域を塗りつぶすための十分なデータが含まれていません。このメソッドは、可能な限り多くのピクセルを塗りつぶした後、例外をスローします。
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>rect または inputByteArray が null です。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>BitmapData オブジェクトの矩形領域を指定します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputByteArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>矩形領域で使用される 32 ビットの乗算されないピクセル値からなる ByteArray オブジェクトです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 バイト配列をピクセルデータの矩形領域に変換します。各ピクセルごとに <codeph>ByteArray.readUnsignedInt()</codeph> メソッドが呼び出され、戻り値がピクセルに書き込まれます。矩形全体が書き込まれる前にバイト配列が終了した場合、関数は終了します。バイト配列内のデータは 32 ビット ARGB ピクセル値と想定されます。ピクセル読み取りの前後に、バイト配列に対するシークは実行されません。  
	 
	 </apiDesc><example conref="examples\BitmapData.setPixels.1.as"> 次の例では、<codeph>getPixels()</codeph> メソッドと <codeph>setPixels()</codeph> メソッドを使用して、ある BitmapData オブジェクトから別の BitmapData オブジェクトにピクセルをコピーします。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/readUnsignedInt()"><linktext>flash.utils.ByteArray.readUnsignedInt()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setVector"><apiName>setVector</apiName><shortdesc>
	 Vector をピクセルデータの矩形領域に変換します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>ベクター配列は、すべてのピクセルデータを読み込めるほど大きくありません。
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>BitmapData オブジェクトの矩形領域を指定します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputVector</apiItemName><apiType value="Vector$uint"/><apiDesc>矩形領域で使用される 32 ビットの乗算されないピクセル値からなる Vector オブジェクトです。  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Vector をピクセルデータの矩形領域に変換します。ピクセルごとに、ベクターエレメントが BitmapData ピクセルに読み込みおよび書き込みされます。Vector のデータは 32 ビット ARGB ピクセル値と推定されます。 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:threshold"><apiName>threshold</apiName><shortdesc>
	 指定されたしきい値と比較してイメージ内のピクセル値をテストし、テストに適合したピクセルに新しいカラー値を設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、destPoint、または operation が null です。
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>operation のストリングが有効な演算ではありません。 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>変更されたピクセルの数です。
 	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>使用する入力ビットマップイメージです。ソースイメージは、別の BitmapData オブジェクトにすることも、現在の BitmapData インスタンスを参照することもできます。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>入力として使用するソースイメージの領域を定義する矩形です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>ソース矩形の左上隅に対応する、ターゲットイメージ（現在の BitmapData インスタンス）内のポイントです。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>比較演算子（"&lt;"、"&lt;="、">"、">="、"=="、"!="）の 1 つ。ストリングとして渡されます。="
	 
	 </apiDesc></apiParam><apiParam><apiItemName>threshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>各ピクセルがしきい値に適合するか、それともしきい値を超えているかをテストするための基準となる値です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>しきい値テストに適合した場合にピクセルに設定されるカラー値です。デフォルト値は 0x00000000 です。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>カラーコンポーネントを分離するために使用するマスクです。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>copySource</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>値が <codeph>true</codeph> の場合、しきい値テストが失敗したときに、ソースイメージのピクセル値がターゲットイメージにコピーされます。値が <codeph>false</codeph> であれば、しきい値テストに適合しない場合にソースイメージはコピーされません。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定されたしきい値と比較してイメージ内のピクセル値をテストし、テストに適合したピクセルに新しいカラー値を設定します。<codeph>threshold()</codeph> メソッドを使用すると、イメージ内のカラー範囲を分離して置換し、イメージピクセルに対しその他の論理演算を実行することができます。 
	 
	 <p><codeph>threshold()</codeph> メソッドのテスト論理は次のとおりです。</p> 
	 
	 <ol> 
	 
	 	<li><codeph>((pixelValue &amp; mask) operation (threshold &amp; mask))</codeph> の場合、ピクセルを <codeph>color</codeph> に設定します。</li>
	 
	 	<li>そうでない場合、<codeph>copySource == true</codeph> であれば、<codeph>sourceBitmap</codeph> の対応するピクセル値にピクセルを設定</li>
	 </ol>
	 
	 <p><codeph>operation</codeph> パラメーターは、しきい値テストで使用する比較演算子を指定します。例えば、<codeph>operation</codeph> パラメーターとして "==" を使用することにより、イメージ内の特定のカラー値を分離できます。または、<codeph>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</codeph> を使用することにより、ソースイメージピクセルのアルファが 0x7F 未満の場合に、すべてのターゲットピクセルが完全に透明になるよう設定できます。アニメーション化されたトランジションやその他の効果に対して、この技法を使用できます。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.threshold.1.as"> 次の例では、<codeph>perlinNoise()</codeph> メソッドを使用して青および赤のパターンを 1 つの BitmapData オブジェクトに追加した後、<codeph>threshold()</codeph> メソッドを使用して、これらのピクセルを最初の BitmapData オブジェクトから 2 番目のオブジェクトにコピーします。その際、赤の値が 0x80（50%）より大きいピクセルを、透明の赤（0x20FF0000）に設定されたピクセルに置換します。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, ">", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:unlock"><apiName>unlock</apiName><shortdesc>
	 この BitmapData オブジェクトが変更されたときに、BitmapData オブジェクトを参照するすべてのオブジェクト（例えば Bitmap オブジェクト）が更新されるように、イメージをロック解除します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>changeRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>変更された BitmapData オブジェクトの領域です。このパラメーターに値を指定しない場合、BitmapData オブジェクトの全領域が変更されたと見なされます。このパラメーターは、Flash Player バージョン 9.0.115.0 以降を必要とします。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 この BitmapData オブジェクトが変更されたときに、BitmapData オブジェクトを参照するすべてのオブジェクト（例えば Bitmap オブジェクト）が更新されるように、イメージをロック解除します。パフォーマンスを向上させるには、このメソッドを <codeph>lock()</codeph> メソッドと共に、<codeph>setPixel()</codeph> メソッドまたは <codeph>setPixel32()</codeph> メソッドを何度も呼び出す前後に使用してください。
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> 次の例では、<codeph>bitmapData</codeph> プロパティ（Bitmap オブジェクトである <codeph>picture</codeph> のプロパティ）に基づいて BitmapData オブジェクトを作成します。次に、<codeph>lock()</codeph> メソッドを呼び出してから、BitmapData オブジェクトを変更する複雑なカスタム関数である <codeph>complexTransformation()</codeph> を呼び出します （<codeph>picture</codeph> オブジェクトおよび <codeph>complexTransformation()</codeph> 関数はこの例では定義されません）。<codeph>complexTransformation()</codeph> 関数が <codeph>bitmapData</codeph> プロパティ（<codeph>picture</codeph> オブジェクトのプロパティ）を更新する場合でも、コードが <codeph>unlock()</codeph> メソッドを <codeph>bitmapData</codeph> オブジェクトに対して呼び出すまで、変更は反映されません。
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiValue id="flash.display:BitmapData:height:get"><apiName>height</apiName><shortdesc>
	 ビットマップイメージの高さ（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 ビットマップイメージの高さ（ピクセル単位）です。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:rect:get"><apiName>rect</apiName><shortdesc>
	 ビットマップイメージのサイズと位置を定義する矩形です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
	 ビットマップイメージのサイズと位置を定義する矩形です。矩形の上端と左端は 0 になります。幅と高さは、BitmapData オブジェクトのピクセルの幅および高さと等しくなります。
   	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:transparent:get"><apiName>transparent</apiName><shortdesc>
	 ビットマップイメージがピクセル単位の透明度をサポートするかどうかを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 ビットマップイメージがピクセル単位の透明度をサポートするかどうかを定義します。この値を設定できるのは、<codeph>true</codeph> を、コンストラクターの <codeph>transparent</codeph> パラメーターに渡すことによって BitmapData オブジェクトを作成する場合だけです。BitmapData オブジェクトを作成した後、<codeph>transparent</codeph> プロパティの値が <codeph>true</codeph> であるかどうかを確認することにより、このオブジェクトがピクセルごとの透明度をサポートするかどうかを検査できます。
   	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:width:get"><apiName>width</apiName><shortdesc>
	 ビットマップイメージの幅（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 ビットマップイメージの幅（ピクセル単位）です。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:JointStyle"><apiName>JointStyle</apiName><shortdesc>
JointStyle クラスは、線の描画で使用される結合スタイルを指定する定数値の列挙です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
JointStyle クラスは、線の描画で使用される結合スタイルを指定する定数値の列挙です。これらの定数は、<codeph>joints</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）の値として使用されます。このメソッドは、マイター、ラウンド、ベベルの 3 種類の結合をサポートします。次に例を示します。 

<p><adobeimage alt="MITER、ROUND、および BEVEL" href="../../images/linejoin.jpg"/></p> 

 
</apiDesc><example conref="examples\JointStyleExample.as"> 次の例では、JointStyleExample クラスを使用して、3 つの異なる結合スタイルを 3 組の結合される線に適用した結果を示します。これを行うには、以下の手順を実行します。
 <ol>
  <li>それぞれの線のプロパティは、次のように設定されます。
  <ul>
      <li>線の長さは 80 ピクセル</li>
      <li>境界線の色はオレンジ色</li>
      <li>境界線のサイズは 30 ピクセル</li>
      <li>ハイライトカラーは灰色</li>
      <li>ハイライトサイズは 0 ピクセル</li>
      <li>アルファは 1（単色になる）</li>
      <li>ピクセルのヒンティングは false に設定（ピクセル全体に対して線がヒンティングされない）</li>
      <li>線の縮小 / 拡大モードは通常（太さを縮小 / 拡大）</li>
      <li>境界線キャップとマイター限度は宣言されているものの、設定されていないため、デフォルト値が使用されます。</li>
  </ul></li>
  <li>クラスコンストラクターは、2 つの連結線セグメントを 3 組作成します。これらのセグメントは、x = 0、y = 0 を起点とします。そのためには、3 つの結合スタイル（マイター、ラウンド、ベベル）を使用して <codeph>doDrawCorner()</codeph> メソッドを 3 度呼び出します。3 度の <codeph>doDrawCorner()</codeph> 呼び出しでは、それぞれ前述の結合スタイルとプロパティを使用して、2 つの連結線セグメント、および関連する線ハイライトを描画します。これには、まず新しい Shape オブジェクト <codeph>child</codeph> を作成し、Graphics クラスのメソッドを使用して、線のスタイルが設定されて線とハイライトを描画します。<codeph>child</codeph> の各インスタンスが表示リストに追加され、ただちにステージに描画されます。</li>
  <li>連結線セグメントは、<codeph>refreshLayout()</codeph> メソッドを使用して再描画されます。再描画される位置は y = 80 ピクセル、起点は x = 80 ピクセル、線のセグメント間の間隔は 25 ピクセルです。</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class JointStyleExample extends Sprite {
        private var size:uint                  = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderCaps:String;
        private var borderMiterLimit:uint;

        public function JointStyleExample() {
            doDrawCorner(JointStyle.MITER);
            doDrawCorner(JointStyle.ROUND);
            doDrawCorner(JointStyle.BEVEL);
            refreshLayout();
        }

        private function doDrawCorner(jointStyle:String):void {
            var halfSize:uint = Math.round(size / 2);
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     borderCaps,
                                     jointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = size;
            lastChild.y = size;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = size;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:JointStyle:BEVEL"><apiName>BEVEL</apiName><shortdesc>
	
	flash.display.Graphics.lineStyle() メソッドの joints パラメーターでベベル結合を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bevel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	<codeph>joints</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）でベベル結合を指定します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:MITER"><apiName>MITER</apiName><shortdesc>
	
	flash.display.Graphics.lineStyle() メソッドの joints パラメーターでマイター結合を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>miter</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	<codeph>joints</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）でマイター結合を指定します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	
	flash.display.Graphics.lineStyle() メソッドの joints パラメーターでラウンド結合を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	<codeph>joints</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）でラウンド結合を指定します。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:AVM1Movie"><apiName>AVM1Movie</apiName><shortdesc>
	AVM1Movie は、ActionScript 1.0 または 2.0 を使用する AVM1 ムービークリップを表す単純なクラスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
	AVM1Movie は、ActionScript 1.0 または 2.0 を使用する AVM1 ムービークリップを表す単純なクラスです。AVM1 は、ActionScript 1.0 および 2.0 を実行するために使用される ActionScript 仮想マシンです。AVM2 は、ActionScript 3.0 を実行するために使用される ActionScript 仮想マシンです。Flash Player 8 以前の SWF ファイルが Loader オブジェクトによってロードされると、AVM1Movie オブジェクトが作成されます。AVM1Movie オブジェクトは、DisplayObject クラスから継承されたメソッドとプロパティ（<codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> など）を使用できます。ただし、AVM1Movie オブジェクトと AVM2 オブジェクトの間で相互に運用することはできません（メソッドの呼び出しやパラメーターの使用など）。
	
	<p>AVM2 SWF ファイルによってロードされた AVM1 SWF ファイルには、次の制約があります。</p>
	
	<ul>
	
	<li>ロードされた AVM1Movie オブジェクトは、AVM1 SWF ファイルと、そのファイルによってロードされたすべての AVM1 SWF ファイルの疑似ルートオブジェクトとして処理されます。つまり、ActionScript 1.0 の <codeph>lockroot</codeph> プロパティが <codeph>true</codeph> に設定されている場合と同様に処理されます。AVM1 ムービーは、すべての子の ActionScript 1.0 または 2.0 のコード実行時に、必ず最初に処理されます。読み込まれた子の <codeph>_root</codeph> プロパティは、読み込まれた AVM1 SWF ファイルの <codeph>lockroot</codeph> プロパティが設定されている場合を除き、常にこの AVM1 SWF ファイルになります。</li>
	
	<li>AVM1 コンテンツで、ファイルをレベルにロードすることはできません。例えば、<codeph>loadMovieNum("url", levelNum)</codeph> を呼び出してファイルをロードすることはできません。</li>
	
	<li>AVM2 SWF ファイルによってロードされた AVM1 SWF ファイルは、他の SWF ファイルを <codeph>this</codeph> にロードできません。つまり、他の SWF ファイルを自身の上にロードすることはできません。ただし、子 Sprite オブジェクト、MovieClip オブジェクト、またはこの SWF ファイルによってロードされた他の AVM1 SWF ファイルを <codeph>this</codeph> にロードすることは可能です。</li>
	
	</ul>
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>DisplayObject</linktext></link><link href="flash.display.xml#Loader"><linktext>Loader</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
	 ShaderInput インスタンスはシェーダーカーネルの 1 つの入力イメージを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderInput インスタンスはシェーダーカーネルの 1 つの入力イメージを表します。カーネル実行で使用する 0、1、またはそれ以上のソースイメージを許可するようにカーネルを定義できます。ShaderInput インスタンスには、シェーダーの実行時に使用する入力イメージを指定するメカニズムがあります。入力値を指定するには、BitmapData、ByteArray、または Vector を指定します。イメージデータを含む &lt;Number> インスタンスで、これを <codeph>input</codeph> プロパティに割り当てます。
	 
	 <p>Shader インスタンスの入力イメージを表す ShaderInput インスタンスが、Shader インスタンスの <codeph>data</codeph> プロパティのプロパティとしてアクセスされます。ShaderInput プロパティの名前は、シェーダーコードの入力名と同じです。例えば、次の例に示すように、シェーダーが <codeph>src</codeph> という名前の入力を定義している場合は、<codeph>src</codeph> 入力を表す ShaderInput インスタンスに <codeph>src</codeph> というプロパティでアクセスできます。</p>
	 
	 <codeblock>myShader.data.src.image = new BitmapData(50, 50, true, 0xFF990000);</codeblock>
	 
	 <p>Shader インスタンスを使用する際に、入力イメージの指定が必要ない場合があります。操作により自動的に指定されるからです。次の目的で Shader を使用する場合にのみ入力を指定します。</p>
	 
	 <ul>
	   <li>シェーダー塗り</li>
	   <li>ShaderFilter、シェーダーで複数の入力を使用するように定義されている場合は、2 番目または追加入力の場合のみ（フィルターの適用先となるオブジェクトが、最初の入力として自動的に使用されます）。</li>
	   <li>シェーダーブレンドモード、シェーダーで 3 つ以上の入力を使用するように定義されている場合は、3 番目または追加入力の場合のみ（ブレンドされるオブジェクトが最初と 2 番目の入力として自動的に使用されます）。</li>
	   <li>ShaderJob バックグラウンド実行</li>
	 </ul>
	 
	 <p>ShaderJob インスタンスを使用してシェーダーを実行し、線形データ配列を含む ByteArray を処理するには、ByteArray 内の ShaderInput インスタンスの <codeph>height</codeph> を 1 に、<codeph>width</codeph> を 32 ビット浮動小数点の値に設定します。その場合、シェーダーの入力は <codeph>image1</codeph> データ型で定義する必要があります。</p>
	 
	 <p>一般に、開発者コードでは直接 ShaderInput インスタンスは作成されません。ShaderInput インスタンスは、Shader インスタンスが作成されるときに、シェーダーの各入力に対して作成されます。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link></related-links><apiConstructor id="flash.display:ShaderInput:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
		 ShaderInput インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 ShaderInput インスタンスを作成します。ShaderInput コンストラクターは開発者コードでは直接呼び出されません。ShaderInput インスタンスは、Shader インスタンスが作成されるときに、シェーダーの各入力に対して作成されます。
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderInput:channels:get"><apiName>channels</apiName><shortdesc>
         シェーダー入力に対応するチャンネル数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         シェーダー入力に対応するチャンネル数です。このプロパティは、入力データが ByteArray または Vector の場合に必ず使用します。&lt;Number> インスタンスです。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:height:get"><apiName>height</apiName><shortdesc>
		 シェーダー入力の高さです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダー入力の高さです。このプロパティは、入力データが ByteArray または Vector の場合にのみ使用します。&lt;Number> インスタンスです。入力が BitmapData インスタンスの場合、高さは自動的に決まります。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:index:get"><apiName>index</apiName><shortdesc>
         シェーダー入力の 0 から始まるインデックスで、シェーダー入力定義の順番を表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         シェーダー入力の 0 から始まるインデックスで、シェーダー入力定義の順番を表します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:input:get"><apiName>input</apiName><shortdesc>
		 
		 シェーダーの実行時に使用する入力データです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 
		 シェーダーの実行時に使用する入力データです。このプロパティには、BitmapData インスタンス、ByteArray インスタンス、または Vector を指定できます。&lt;Number> インスタンスです。
		 
		 <p>ByteArray 値を <codeph>input</codeph> プロパティに割り当てる場合は、次の条件を満たす必要があります。</p>
		 
		 <ul>
		   <li><codeph>height</codeph> と <codeph>width</codeph> のプロパティが設定されていること。</li>
		   <li>バイト配列の内容が、32 ビット浮動小数点値のみで構成されていること。これらの値は、<codeph>ByteArray.writeFloat()</codeph> メソッドを使用して作成できます。</li>
		   <li>total length in bytes of the ByteArray のバイト単位の長さの合計は、<codeph>width</codeph> × <codeph>height</codeph> × <codeph>channels</codeph> × 4 と完全に一致すること。</li>
		   <li>バイト配列の <codeph>endian</codeph> プロパティが <codeph>Endian.LITTLE_ENDIAN</codeph> であること。</li>
		 </ul>
		 
		 <p>Vector の場合：&lt;Number> インスタンスを <codeph>input</codeph> プロパティに割り当てる場合は、Vector の長さが <codeph>width</codeph> × <codeph>height</codeph> × <codeph>channels</codeph> と一致する必要があります。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:width:get"><apiName>width</apiName><shortdesc>
		 シェーダー入力の幅です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダー入力の幅です。このプロパティは、入力データが ByteArray または Vector の場合にのみ使用します。&lt;Number> インスタンスです。入力が BitmapData インスタンスの場合、幅は自動的に決まります。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrection"><apiName>ColorCorrection</apiName><shortdesc>
ColorCorrection クラスは、flash.display.Stage.colorCorrection プロパティの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
ColorCorrection クラスは、<codeph>flash.display.Stage.colorCorrection</codeph> プロパティの値を提供します。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrection"><linktext>flash.display.Stage.colorCorrection</linktext></link></related-links><apiValue id="flash.display:ColorCorrection:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
ホストのデフォルトのカラー補正を使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ホストのデフォルトのカラー補正を使用します。Web プレーヤーの場合、通常、ホストはブラウザーです。Flash Player では、SWF ファイルのホストである Web ページと同じカラー補正を使用しようとします。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:OFF"><apiName>OFF</apiName><shortdesc>
プレーヤーのホスト環境とは関係なしにカラー補正をオフにします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>off</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
プレーヤーのホスト環境とは関係なしにカラー補正をオフにします。この設定により、パフォーマンスが高速化されます。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:ON"><apiName>ON</apiName><shortdesc>
プレーヤーのホスト環境とは関係なしにカラー補正をオンにします。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>on</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
プレーヤーのホスト環境とは関係なしにカラー補正をオンにします。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:LineScaleMode"><apiName>LineScaleMode</apiName><shortdesc>
LineScaleMode クラスは、Graphics.lineStyle() メソッドの scaleMode パラメーターに値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
LineScaleMode クラスは、<codeph>scaleMode</codeph> パラメーター（<codeph>Graphics.lineStyle()</codeph> メソッド内のパラメーター）に値を提供します。


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:LineScaleMode:HORIZONTAL"><apiName>HORIZONTAL</apiName><shortdesc>
	この設定を lineStyle() メソッドの scaleMode パラメーターとして使用すると、線の太さは垂直方向にのみ拡大または縮小されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>horizontal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	この設定を <codeph>scaleMode</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドのパラメーター）として使用すると、線の太さは垂直方向に<i>のみ</i>拡大または縮小されます。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.VERTICAL</codeph> に設定されているとします。左側の円は垂直方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
	
    <p><adobeimage alt="1 つの円は垂直方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NONE"><apiName>NONE</apiName><shortdesc>
	この設定を lineStyle() メソッドの scaleMode パラメーターとして使用すると、線の太さは拡大または縮小されません。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	この設定を <codeph>scaleMode</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドのパラメーター）として使用すると、線の太さは拡大または縮小されません。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	この設定を lineStyle() メソッドの scaleMode パラメーターとして使用すると、オブジェクトが拡大または縮小されるときには線の太さも常に拡大または縮小されます（デフォルト）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	この設定を <codeph>scaleMode</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドのパラメーター）として使用すると、オブジェクトが拡大または縮小されるときには線の太さも常に拡大または縮小されます（デフォルト）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:VERTICAL"><apiName>VERTICAL</apiName><shortdesc>
	この設定を lineStyle() メソッドの scaleMode パラメーターとして使用すると、線の太さは水平方向にのみ拡大または縮小されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>vertical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	この設定を <codeph>scaleMode</codeph> パラメーター（<codeph>lineStyle()</codeph> メソッドのパラメーター）として使用すると、線の太さは水平方向に<i>のみ</i>拡大または縮小されます。例えば、次に示す各円は、1 ピクセルの線で描画され、それぞれ <codeph>scaleMode</codeph> パラメーターが <codeph>LineScaleMode.HORIZONTAL</codeph> に設定されているとします。左側の円は水平方向にのみ拡大または縮小され、右側の円は垂直と水平の両方向に拡大または縮小されたものです。
	
    <p><adobeimage alt="1 つの円は水平方向に拡大または縮小され、もう 1 つの円は垂直と水平の両方向に拡大または縮小されています。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Shader"><apiName>Shader</apiName><shortdesc>
	 Shader インスタンスは ActionScript のシェーダー (Pixel Bender) のカーネルを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Shader インスタンスは ActionScript のシェーダー（Pixel Bender）のカーネルを表します。アプリケーションでシェーダーを使用するには、そのシェーダーの Shader インスタンスを作成します。次に、その Shader インスタンスを目的のエフェクトに合わせて使用します。例えば、シェーダーをフィルターとして使用する場合は、Shader インスタンスを ShaderFilter オブジェクトの <codeph>shader</codeph> プロパティに割り当てます。
	 
	 <p>シェーダーがイメージの全ピクセルに対しピクセル単位で実行する関数を定義します。各関数呼び出し結果が、イメージ内のそのピクセル座標の出力カラーとなります。シェーダーは 1 つ以上の入力イメージを指定できます。このイメージのコンテンツを関数の出力の決定に使用できます。また、シェーダーは 1 つ以上のパラメーターを指定することもできます。これは関数出力の計算に使用可能な入力値となります。1 つのシェーダー実行では、入力値とパラメーター値は定数です。唯一変化するのは、関数の結果がカラーとなるピクセル座標です。複数の出力ピクセル座標のシェーダー関数呼び出しは、シェーダー実行パフォーマンスを高めるために、並行して実行されます。</p>
	 
	 <p>シェーダーバイトコードは、実行時に URLLoader インスタンスを使用してロードできます。次の例は、シェーダーバイトコードファイルを実行時にロードし、それを Shader インスタンスにリンクする方法を示しています。</p>
	 
	 <codeblock>
	 var loader:URLLoader = new URLLoader();
	 loader.dataFormat = URLLoaderDataFormat.BINARY;
	 loader.addEventListener(Event.COMPLETE, onLoadComplete);
	 loader.load(new URLRequest("myShader.pbj"));
	  
	 var shader:Shader;
	  
	 function onLoadComplete(event:Event):void {
	     // Create a new shader and set the loaded data as its bytecode
	     shader = new Shader();
	     shader.byteCode = loader.data;
	     
	     // You can also pass the bytecode to the Shader() constructor like this:
	     // shader = new Shader(loader.data);
	     
	     // do something with the shader
	 }
	 </codeblock>
	 
	 <p><codeph>[Embed]</codeph> メタデータタグを使用して、コンパイル時にシェーダーを SWF に埋め込む方法もあります。<codeph>[Embed]</codeph> メタデータタグは、Flex SDK を使用して SWF をコンパイルした場合にのみ使用できます。この例では、<codeph>[Embed]</codeph> タグの <codeph>source</codeph> パラメーターでシェーダーファイルが指定され、<codeph>mimeType</codeph> パラメーターは <codeph>"application/octet-stream"</codeph> となります。</p>
	 
	 <codeblock>
	 [Embed(source="myShader.pbj", mimeType="application/octet-stream)]
	 var MyShaderClass:Class;
	  
	 // ...
	 
	 // create a new shader and set the embedded shader as its bytecode
	 var shaderShader = new Shader();
	 shader.byteCode = new MyShaderClass();
	  
	 // You can also pass the bytecode to the Shader() constructor like this:
	 // var shader:Shader = new Shader(new MyShaderClass());
	  
	 // do something with the shader
	 </codeblock>
	 
	 <p>どちらの場合も、生のシェーダー（<codeph>URLLoader.data</codeph> プロパティまたは <codeph>[Embed]</codeph> データクラスのインスタンス）を Shader インスタンスにリンクします。前の例で示したとおり、これは 2 つの方法で行うことができます。シェーダーバイトコードを引数として <codeph>Shader()</codeph> コンストラクターに渡します。または、Shader インスタンスの <codeph>byteCode</codeph> プロパティとして設定することもできます。</p>
	 
	 <p>Shader インスタンスが作成されたら、次のいくつかの方法のうちどれでも使用できます。</p>
	 
	 <ul>
	   <li>シェーダー塗り：シェーダーの出力は、描画 API により描画されたコンテンツの塗りとして使用されます。Shader インスタンスを引数として <codeph>Graphics.beginShaderFill()</codeph> メソッドに渡します。</li>
	   <li>シェーダーフィルター：シェーダーの出力は、表示オブジェクトに適用されるグラフィックフィルターとして使用されます。Shader インスタンスを ShaderFilter インスタンスの <codeph>shader</codeph> プロパティに割り当てます。</li>
	   <li>ブレンドモード：シェーダーの出力は、重なり合う 2 つの表示オブジェクト間のブレンドとしてレンダリングされます。Shader インスタンスを、2 つの表示オブジェクトのうち上の <codeph>blendShader</codeph> プロパティに割り当てます。</li>
	   <li>バックグラウンドシェーダー処理：表示のフリーズを避けるため、シェーダーをバックグラウンドで実行し、処理が完了したときにイベントを送出します。Shader インスタンスを ShaderJob インスタンスの <codeph>shader</codeph> プロパティに割り当てます。</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\ShaderExample.1.as"> 次の例は、シェーダーバイトコードファイルを実行時にロードし、それにリンクされた Shader インスタンスを作成する方法を示しています。
 
 <p>この例では、"donothing.pbj" という名前のシェーダーバイトコードファイルが、アプリケーションの出力先と同じディレクトリにあるものとします。DoNothing シェーダーの Pixel Bender ソースコードは、「<xref href="ShaderData.html#includeExamplesSummary">ShaderData クラスの例</xref>」にあります。</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class LoadedShaderExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function LoadedShaderExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example><example conref="examples\ShaderExample.2.as"> 次の例は、シェーダーバイトコードファイルを SWF にコンパイルすることで埋め込み、それにリンクされた Shader インスタンスを作成する方法を示しています。
 
 <p>この例では、"donothing.pbj" という名前のシェーダーバイトコードファイルがアプリケーションのソースコードと同じディレクトリにあり、Flex SDK を使用して SWF をコンパイルしたものとします。DoNothing シェーダーの Pixel Bender ソースコードは、「<xref href="ShaderData.html#includeExamplesSummary">ShaderData クラスの例</xref>」にあります。</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;

    public class EmbeddedShaderExample extends Sprite {
        
        [Embed(source="donothing.pbj", mimeType="application/octet-stream")]
        private static var DoNothingShader:Class;
        
        public function EmbeddedShaderExample() {
            var shader:Shader = new Shader();
            shader.byteCode = new DoNothingShader();
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link><link href="flash.filters.xml#ShaderFilter"><linktext>flash.filters.ShaderFilter</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><apiConstructor id="flash.display:Shader:flash.display:Shader"><apiName>Shader</apiName><shortdesc>
		 新しい Shader インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Shader にリンクする生のシェーダーバイトコードです。
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 新しい Shader インスタンスを作成します。
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shader:data:set"><apiName>data</apiName><shortdesc>
		 Shader インスタンスのパラメーター、入力イメージ、およびメタデータにアクセスできます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:ShaderData</apiValueClassifier></apiValueDef><apiDesc>
		 Shader インスタンスのパラメーター、入力イメージ、およびメタデータにアクセスできます。シェーダーのパラメーターを表す ShaderParameter オブジェクト、シェーダーの入力イメージを表す ShaderInput オブジェクト、シェーダーのメタデータを表すその他の値が、Shader インスタンスの作成時に <codeph>data</codeph> プロパティオブジェクトの各プロパティとして動的に追加されます。これらのプロパティを使用して、シェーダーを検査し、パラメーターと入力値を設定することができます。
		 
		 <p><codeph>data</codeph> オブジェクトの動的プロパティにアクセスし、操作する方法について詳しくは、ShaderData クラスに関する説明を参照してください。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:precisionHint:set"><apiName>precisionHint</apiName><shortdesc>
		 シェーダーが実行する算術演算の精度です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーが実行する算術演算の精度です。
		 
		 <p><codeph>precisionHint</codeph> プロパティで使用可能な値セットは、ShaderPrecision クラスの定数によって定義されます。</p>
		 
		 <p>デフォルト値は <codeph>ShaderPrecision.FULL</codeph> です。精度を <codeph>ShaderPrecision.FAST</codeph> に設定すると、精度が低下しますが算術演算は高速になります。</p>
		 
		 <p>full 精度モード（<codeph>ShaderPrecision.FULL</codeph>）では、すべての算術演算が完全桁の IEEE 32 ビット浮動少数規格で計算され、すべてのプラットフォームで一貫した動作が提供されます。このモードでは、三角関数や指数関数などの一部の算術演算について処理速度が低下することがあります。</p>
		 
		 <p>fast 精度モード（<codeph>ShaderPrecision.FAST</codeph>）は処理速度を優先して設計されていますが、プラットフォームの差異や CPU 構成の内容によって結果が異なることがあります。多くの場合、グラフィックエフェクトの作成にはアーティファクトが見えることもなく、この精度レベルで十分です。</p>
		 
		 <p>精度モードの選択は、次のシェーダー操作に影響します。これらの操作は、SSE 命令セットを内蔵する Intel プロセッサーでは高速になります。</p>
		 
		 <ul>
		   <li><codeph>sin(x)</codeph></li>
		   <li><codeph>cos(x)</codeph></li>
		   <li><codeph>tan(x)</codeph></li>
		   <li><codeph>asin(x)</codeph></li>
		   <li><codeph>acos(x)</codeph></li>
		   <li><codeph>atan(x)</codeph></li>
		   <li><codeph>atan(x, y)</codeph></li>
		   <li><codeph>exp(x)</codeph></li>
		   <li><codeph>exp2(x)</codeph></li>
		   <li><codeph>log(x)</codeph></li>
		   <li><codeph>log2(x)</codeph></li>
		   <li><codeph>pow(x, y)</codeph></li>
		   <li><codeph>reciprocal(x)</codeph></li>
		   <li><codeph>sqrt(x)</codeph></li>
		 </ul>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderPrecision"><linktext>flash.display.ShaderPrecision</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:byteCode:set"><apiName>byteCode</apiName><shortdesc>
		 この Shader インスタンスの生のシェーダーバイトコードです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier></apiValueDef><apiDesc>
		 この Shader インスタンスの生のシェーダーバイトコードです。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsData"><apiName>IGraphicsData</apiName><shortdesc>
	このインターフェイスは、塗り、線、パスなど、flash.display.Graphics のメソッドのパラメーターとして使用されるオブジェクトを定義するために使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	このインターフェイスは、塗り、線、パスなど、flash.display.Graphics のメソッドのパラメーターとして使用されるオブジェクトを定義するために使用します。描画プロパティデータの作成と管理、および異なるインスタンスでの同じデータの再利用には、このインターフェイスの実装者クラスを使用します。その後、Graphics クラスのメソッドを使用して、描画オブジェクトをレンダリングします。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:MovieClip"><apiName>MovieClip</apiName><shortdesc>
 MovieClip クラスは、Sprite、DisplayObjectContainer、InteractiveObject、DisplayObject および EventDispatcher クラスを継承します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>ActionScript が作成するオブジェクトの基本表示オブジェクトです。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:Sprite</apiBaseClassifier></apiClassifierDef><apiDesc>
 MovieClip クラスは、Sprite、DisplayObjectContainer、InteractiveObject、DisplayObject および EventDispatcher クラスを継承します。
 
 <p>MovieClip オブジェクトには、Sprite オブジェクトとは違ってタイムラインがあります。</p>
 
 <p product="flash">MovieClip クラスのメソッドは、ムービークリップをターゲットとするアクションと同じ機能を提供します。Flash オーサリングツールのアクションパネルのアクションツールボックスには同等のアクションがない追加メソッドもあります。 </p>
 
 <p>Flash オーサリングツールのステージに配置された子インスタンスは、親インスタンスのコンストラクター内からコードでアクセスできません。コード実行の該当時点では作成されていないためです。子にアクセスするには、親はコードを使用して子インスタンスを作成するか、子を待機するコールバック関数が <codeph>Event.ADDED_TO_STAGE</codeph> イベントを送出するまでアクセスを遅延させる必要があります。</p>
 
 <p>モーショントゥイーンが含まれている MovieClip オブジェクトの次のいずれかのプロパティを変更した場合、MovieClip オブジェクト、<codeph>alpha</codeph>、<codeph>blendMode</codeph>、<codeph>filters</codeph>、<codeph>height</codeph>、<codeph>opaqueBackground</codeph>、<codeph>rotation</codeph>、<codeph>scaleX</codeph>、<codeph>scaleY</codeph>、<codeph>scale9Grid</codeph>、<codeph>scrollRect</codeph>、<codeph>transform</codeph>、<codeph>visible</codeph>、<codeph>width</codeph>、<codeph>x</codeph>、または <codeph>y</codeph> の再生ヘッドが停止されます。 ただし、その MovieClip オブジェクトの子 MovieClip オブジェクトの再生ヘッドは停止しません。</p>
 
 </apiDesc><example conref="examples\MovieClipExample.as"> 次の例では、MovieClipExample クラスを使用して、MovieClip のさまざまなプロパティを監視する方法を示します。これを行うには、以下の手順を実行します。
 
 <ol>
 
  <li>コンストラクター関数で、MovieClipExample オブジェクト（MovieClip を拡張する）のプロパティの値を表示するのに使用するテキストフィールドを定義します。</li>
 
  <li><codeph>getPropertiesString()</codeph> メソッドの戻り値が、<codeph>outputText</codeph> テキストフィールドのテキストとして使用されます。<codeph>getPropertiesString()</codeph> メソッドは、ムービークリップの以下のプロパティの値が取り込まれたストリングを返します。<codeph>currentFrame</codeph>、<codeph>currentLabel</codeph>、<codeph>currentScene</codeph>、<codeph>framesLoaded</codeph>、<codeph>totalFrames</codeph>、および<codeph>trackAsMenu</codeph> があります。</li>
 
  <li>コンストラクター関数内の 2 行のコードは、<codeph>width</codeph> プロパティおよび <codeph>height</codeph> プロパティ（<codeph>outputText</codeph> テキストフィールドのプロパティ）を調整します。</li>
 
  <li>コンストラクター関数の最後の行は、<codeph>outputText</codeph> テキストフィールドを表示リストに追加します。</li>
 
 </ol>
<codeblock>

package {
    import flash.display.MovieClip;
    import flash.text.TextField;

    public class MovieClipExample extends MovieClip {

        public function MovieClipExample() {
            var outputText:TextField = new TextField();
            outputText.text = getPropertiesString();
            outputText.width = stage.stageWidth;
            outputText.height = outputText.textHeight;
            addChild(outputText);
        }

        private function getPropertiesString():String {
            var str:String = ""
                + "currentFrame: " + currentFrame + "\n"
                + "currentLabel: " + currentLabel + "\n"
                + "currentScene: " + currentScene + "\n"
                + "framesLoaded: " + framesLoaded + "\n"
                + "totalFrames: " + totalFrames + "\n"
                + "trackAsMenu: " + trackAsMenu + "\n";
            return str;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:MovieClip:MovieClip"><apiName>MovieClip</apiName><shortdesc>
	新しい MovieClip インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	新しい MovieClip インスタンスを作成します。MovieClip の作成後、ステージ上の表示オブジェクトコンテナの <codeph>addChild()</codeph> メソッドまたは <codeph>addChildAt()</codeph> メソッドを呼び出せます。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:MovieClip:gotoAndPlay"><apiName>gotoAndPlay</apiName><shortdesc>
	 指定されたフレームで SWF ファイルの再生を開始します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandplay, gotoandplay
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>再生ヘッドの送り先となるフレーム番号を表す数値、または再生ヘッドの送り先となるフレームのラベルを表すストリングです。数値を指定する場合は、指定するシーンに対する相対数で指定します。シーンを指定しない場合は、再生するグローバルフレーム番号が現在のシーンによって決定されます。 シーンを指定した場合、再生ヘッドは指定されたシーン内のフレーム番号にジャンプします。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>再生するシーンの名前です。このパラメーターはオプションです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定されたフレームで SWF ファイルの再生を開始します。この処理は、フレーム内のすべての残存アクションが実行を完了した後に行われます。フレームだけでなくシーンも指定する場合は、<codeph>scene</codeph> パラメーターの値も指定してください。
	 
	 </apiDesc><example conref="examples\MovieClip.gotoAndPlay.1.as"> 次のコードは、<codeph>gotoAndPlay()</codeph> メソッドを使用して、<codeph>mc1</codeph> ムービークリップの再生ヘッドを現在の位置から 5 つ先のフレームに進めます。
<codeblock>
mc1.gotoAndPlay(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndPlay.2.as"> 次のコードは、<codeph>gotoAndPlay()</codeph> メソッドを使用して、<codeph>mc1</codeph> ムービークリップの再生ヘッドを、<codeph>"intro"</codeph> というラベルのフレーム（<codeph>"Scene 12"</codeph> という名前のシーン内）に進めます。
<codeblock>
mc1.gotoAndPlay("intro", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:gotoAndStop"><apiName>gotoAndStop</apiName><shortdesc>
	  このムービークリップの指定されたフレームに再生ヘッドを送り、そこで停止させます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandstop, gotoandstop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>指定された <codeph>scene</codeph> または <codeph>frame</codeph> が、このムービークリップで見つからなかった場合。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>再生ヘッドの送り先となるフレーム番号を表す数値、または再生ヘッドの送り先となるフレームのラベルを表すストリングです。数値を指定する場合は、指定するシーンに対する相対数で指定します。シーンを指定しない場合は、送り先のグローバルフレーム番号が現在のシーンによって決定されます。 シーンを指定した場合、再生ヘッドは指定されたシーン内のフレーム番号に送られて停止します。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>シーン名です。このパラメーターはオプションです。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	  このムービークリップの指定されたフレームに再生ヘッドを送り、そこで停止させます。この処理は、フレーム内のすべての残存アクションが実行を完了した後に行われます。フレームに加えてシーンを指定する場合は、<codeph>scene</codeph> パラメーターを指定してください。
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> 次のコードは、<codeph>gotoAndStop()</codeph> メソッドおよび  <codeph>currentFrame</codeph> プロパティを使用して、<codeph>mc1</codeph> ムービークリップの再生ヘッドを現在の位置から 5 つ先のフレームに進めます。
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndStop.1.as"> 次のコードは、<codeph>gotoAndStop()</codeph> を使用して、<codeph>mc1</codeph> ムービークリップの再生ヘッドを、<codeph>"finale"</codeph> というラベルのフレーム（<codeph>"Scene 12"</codeph> という名前のシーン内）に進め、再生ヘッドを停止します。
<codeblock>
mc1.gotoAndStop("finale", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:nextFrame"><apiName>nextFrame</apiName><shortdesc>
	 次のフレームに再生ヘッドを送り、停止します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.nextframe, nextframe
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 次のフレームに再生ヘッドを送り、停止します。この処理は、フレーム内のすべての残存アクションが実行を完了した後に行われます。
	 
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> 次の例では、2 つの SimpleButton オブジェクトがタイムラインを制御します。<codeph>prev</codeph> ボタンは再生ヘッドを前のフレームに移動し、<codeph>nextBtn</codeph> ボタンは再生ヘッドを次のフレームに移動します。
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/prevFrame()"><linktext>prevFrame()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:nextScene"><apiName>nextScene</apiName><shortdesc>
	 MovieClip インスタンスの次のシーンに再生ヘッドを移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 MovieClip インスタンスの次のシーンに再生ヘッドを移動します。この処理は、フレーム内のすべての残存アクションが実行を完了した後に行われます。
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> 次の例では、2 つの SimpleButton オブジェクトがタイムラインを制御します。<codeph>prevBtn</codeph> ボタンは再生ヘッドを前のシーンに移動し、<codeph>nextBtn</codeph> ボタンは再生ヘッドを次のシーンに移動します。
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:play"><apiName>play</apiName><shortdesc>
	 ムービークリップのタイムライン内で再生ヘッドを移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.play, play
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 ムービークリップのタイムライン内で再生ヘッドを移動します。
	 
	 </apiDesc><example conref="examples\MovieClip.play.1.as"> 次のコードでは <codeph>stop()</codeph> メソッドを使用して、<codeph>mc1</codeph> という名前のムービークリップを停止し、ユーザーが <codeph>continueText</codeph> という名前のテキストフィールドをクリックしたときに再生を再開します。
<codeblock>

import flash.text.TextField;
import flash.events.MouseEvent;

var continueText:TextField = new TextField();
continueText.text = "Play movie...";
addChild(continueText);

mc1.stop();
continueText.addEventListener(MouseEvent.CLICK, resumeMovie);

function resumeMovie(event:MouseEvent):void {
    mc1.play();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>gotoAndPlay()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:prevFrame"><apiName>prevFrame</apiName><shortdesc>
	 直前のフレームに再生ヘッドを戻し、停止します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.prevframe, prevframe, previous frame
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 直前のフレームに再生ヘッドを戻し、停止します。この処理は、フレーム内のすべての残存アクションが実行を完了した後に行われます。
	  
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> 次の例では、2 つの SimpleButton オブジェクトがタイムラインを制御します。<codeph>prev</codeph> ボタンは再生ヘッドを前のフレームに移動し、<codeph>nextBtn</codeph> ボタンは再生ヘッドを次のフレームに移動します。
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:prevScene"><apiName>prevScene</apiName><shortdesc>
	 MovieClip インスタンスの直前のシーンに再生ヘッドを移動します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 MovieClip インスタンスの直前のシーンに再生ヘッドを移動します。この処理は、フレーム内のすべての残存アクションが実行を完了した後に行われます。
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> 次の例では、2 つの SimpleButton オブジェクトがタイムラインを制御します。<codeph>prevBtn</codeph> ボタンは再生ヘッドを前のシーンに移動し、<codeph>nextBtn</codeph> ボタンは再生ヘッドを次のシーンに移動します。
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:stop"><apiName>stop</apiName><shortdesc>
	 ムービークリップ内の再生ヘッドを停止します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.stop, stop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 ムービークリップ内の再生ヘッドを停止します。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:MovieClip:currentFrame:get"><apiName>currentFrame</apiName><shortdesc>
	 MovieClip インスタンスのタイムライン内の再生ヘッドが置かれているフレームの番号を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.currentFrame, currentFrame, currentFrame
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip インスタンスのタイムライン内の再生ヘッドが置かれているフレームの番号を示します。ムービークリップに複数のシーンがある場合、この値は現在のシーンのフレーム番号です。
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> 次のコードは、<codeph>gotoAndStop()</codeph> メソッドおよび  <codeph>currentFrame</codeph> プロパティを使用して、<codeph>mc1</codeph> ムービークリップの再生ヘッドを現在の位置から 5 つ先のフレームに進めます。
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentFrameLabel:get"><apiName>currentFrameLabel</apiName><shortdesc>
	 MovieClip インスタンスのタイムライン内の現在のフレームにあるラベルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip インスタンスのタイムライン内の現在のフレームにあるラベルです。現在のフレームにラベルがない場合、<codeph>currentLabel</codeph> は <codeph>null</codeph> です。
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrameLabel.1.as"/></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabel:get"><apiName>currentLabel</apiName><shortdesc>
	 MovieClip インスタンスのタイムライン内の再生ヘッドが置かれている現在のラベルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip インスタンスのタイムライン内の再生ヘッドが置かれている現在のラベルです。現在のフレームにラベルがない場合、ラベルを含んだ前のフレームの名前に <codeph>currentLabel</codeph> が設定されます。現在のフレームと前のフレームにラベルが含まれない場合、<codeph>currentLabel</codeph> は <codeph>null</codeph> を返します。
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabel.1.as"> 次のコードは、MovieClip オブジェクトの <codeph>currentLabel</codeph> プロパティにアクセスする方法を示しています。MovieClip オブジェクトの名前は <codeph>mc1</codeph> です。
<codeblock>
trace(mc1.currentLabel);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabels:get"><apiName>currentLabels</apiName><shortdesc>
	 現在のシーンの FrameLabel オブジェクトの配列を返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 現在のシーンの FrameLabel オブジェクトの配列を返します。MovieClip インスタンスがシーンを使用していない場合、配列には MovieClip インスタンス全体のすべてのフレームラベルが含まれます。
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabels.1.as"> 次のコードは、MovieClip オブジェクトの <codeph>currentLabels</codeph> プロパティを使用する方法を示しています。MovieClip オブジェクトの名前は <codeph>mc1</codeph> です。
<codeblock>
import flash.display.FrameLabel;
 
var labels:Array = mc1.currentLabels;

for (var i:uint = 0; i &lt; labels.length; i++) {
    var label:FrameLabel = labels[i];
    trace("frame " + label.frame + ": " + label.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>flash.display.FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:currentScene:get"><apiName>currentScene</apiName><shortdesc>
	 MovieClip インスタンスのタイムライン内の再生ヘッドが置かれている現在のシーンです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Scene</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip インスタンスのタイムライン内の再生ヘッドが置かれている現在のシーンです。
	 
	 </apiDesc><example conref="examples\MovieClip.currentScene.1.as"> 次のコードは、MovieClip オブジェクトの <codeph>currentScene</codeph> プロパティを使用する方法を示しています。MovieClip オブジェクトの名前は <codeph>mc1</codeph> です。
<codeblock>
import flash.display.Scene;
 
var scene:Scene = mc1.currentScene;
trace(scene.name + ": " + scene.numFrames + " frames");
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:enabled:get"><apiName>enabled</apiName><shortdesc>
	 ムービークリップの有効 / 無効を示すブール値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 ムービークリップの有効 / 無効を示すブール値です。<codeph>enabled</codeph> のデフォルト値は <codeph>true</codeph> です。<codeph>enabled</codeph> が <codeph>false</codeph> に設定されると、ムービークリップの「オーバー」、「ダウン」、「アップ」の各フレームは無効になります。ムービークリップは、イベント（<codeph>mouseDown</codeph>、<codeph>mouseUp</codeph>、<codeph>keyDown</codeph>、<codeph>keyUp</codeph> など）を引き続き受け取ります。
	 
	 <p><codeph>enabled</codeph> プロパティは、ムービークリップのボタンに似たプロパティのみを制御します。<codeph>enabled</codeph> プロパティはいつでも変更できます。このプロパティの変更後、ムービークリップはすぐに有効 / 無効になります。<codeph>enabled</codeph> プロパティが <codeph>false</codeph> に設定されている場合、オブジェクトは自動タブ順序に含まれません。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.enabled.1.as"> 次のコードは、<codeph>enabled</codeph> プロパティを使用して、MovieClip オブジェクトのボタンに似てプロパティを無効化する方法を示します。MovieClip オブジェクトの名前は <codeph>mc1</codeph> です。
<codeblock>
mc1.enabled = false;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:framesLoaded:get"><apiName>framesLoaded</apiName><shortdesc>
	 ストリーミング SWF ファイルからロードされたフレーム数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.framesLoaded, framesLoaded, framesloaded
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 ストリーミング SWF ファイルからロードされたフレーム数です。<codeph>framesLoaded</codeph> プロパティを使用して、特定のフレームおよびその前のすべてのフレームの内容がロードされていてブラウザーでローカルに使用できるかどうかを判別できます。 これを使用して、大きい SWF ファイルのダウンロードを監視することもできます。例えば、SWF ファイルの指定されたフレームがロードを完了するまで、その SWF ファイルがロード中であることを示すメッセージをユーザーに表示する場合に使用できます。
	 
	 <p>ムービークリップに複数のシーンがある場合は、<codeph>framesLoaded</codeph> プロパティは、ムービークリップ内の<i>すべての</i>シーンのロード済みフレームの数を返します。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.framesLoaded.1.as"> 次のコードは、<codeph>framesLoaded</codeph> プロパティおよび <codeph>totalFrames</codeph> プロパティを使用して、<codeph>mc1</codeph> という名前のストリーミング MovieClip オブジェクトが完全にロードされているかどうかを判別する方法を示します。
<codeblock>
if (mc1.framesLoaded == mc1.totalFrames) {
    trace("OK.");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>Loader クラス</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:scenes:get"><apiName>scenes</apiName><shortdesc>
	 MovieClip インスタンス内のシーンの名前、フレーム数、フレームラベルがリストされた Scene オブジェクトの配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip インスタンス内のシーンの名前、フレーム数、フレームラベルがリストされた Scene オブジェクトの配列です。
	 
	 </apiDesc><example conref="examples\MovieClip.scenes.1.as"> 次のコードは、MovieClip オブジェクトの <codeph>scenes</codeph> プロパティを使用する方法を示しています。MovieClip オブジェクトの名前は <codeph>mc1</codeph> です。
<codeblock>
import flash.display.Scene;
 
for (var i:uint = 0; i &lt; mc1.scenes.length; i++) {
    var scene:Scene = mc1.scenes[i];
    trace("scene " + scene.name + ": " + scene.numFrames + " frames");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:totalFrames:get"><apiName>totalFrames</apiName><shortdesc>
	 MovieClip インスタンス内のフレーム総数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.totalFrames, totalFrames, totalFrames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip インスタンス内のフレーム総数です。
	 
	 <p>ムービークリップに複数のフレームがある場合は、<codeph>totalFrames</codeph> プロパティは、ムービークリップ内の<i>すべての</i>シーンのフレーム総数を返します。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.totalFrames.1.as"> 次のコードは、<codeph>totalFrames</codeph> プロパティ（<codeph>mc1</codeph> という名前の MovieClip オブジェクトのプロパティ）の使用を示します。
<codeblock>
 trace(mc1.totalFrames);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 SimpleButton または MovieClip オブジェクトである他の表示オブジェクトがマウス解放イベントを受け取ることができるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 SimpleButton または MovieClip オブジェクトである他の表示オブジェクトがマウス解放イベントを受け取ることができるかどうかを示します。<codeph>trackAsMenu</codeph> プロパティを使用してメニューを作成できます。<codeph>trackAsMenu</codeph> プロパティは、任意の SimpleButton または MovieClip オブジェクトに対して設定できます。<codeph>trackAsMenu</codeph> プロパティのデフォルト値は <codeph>false</codeph> です。 
	 
	 <p><codeph>trackAsMenu</codeph> プロパティはいつでも変更できます。このプロパティを変更したムービークリップには、新しい動作が直ちに反映されます。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.trackAsMenu.1.as"> 次のコードは、<codeph>trackAsMenu</codeph> プロパティを使用して、<codeph>mc1</codeph> という名前の MovieClip オブジェクトのマウス解放イベントを有効化する方法を示します。
<codeblock>
 mc1.trackAsMenu = true;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SWFVersion"><apiName>SWFVersion</apiName><shortdesc>
	SWFVersion クラスは、読み込まれる SWF ファイルのファイル形式のバージョンを示す定数値の列挙です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	SWFVersion クラスは、読み込まれる SWF ファイルのファイル形式のバージョンを示す定数値の列挙です。SWFVersion 定数は flash.display.LoaderInfo オブジェクトの <codeph>swfVersion</codeph> プロパティの検査に使用されます。
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/swfVersion"><linktext>flash.display.LoaderInfo.swfVersion</linktext></link></related-links><apiValue id="flash.display:SWFVersion:FLASH1"><apiName>FLASH1</apiName><shortdesc>
		SWF ファイル形式のバージョン 1.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 1.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH10"><apiName>FLASH10</apiName><shortdesc>
		SWF ファイル形式のバージョン 10.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>10</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 10.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH2"><apiName>FLASH2</apiName><shortdesc>
		SWF ファイル形式のバージョン 2.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 2.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH3"><apiName>FLASH3</apiName><shortdesc>
		SWF ファイル形式のバージョン 3.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 3.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH4"><apiName>FLASH4</apiName><shortdesc>
		SWF ファイル形式のバージョン 4.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 4.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH5"><apiName>FLASH5</apiName><shortdesc>
		SWF ファイル形式のバージョン 5.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 5.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH6"><apiName>FLASH6</apiName><shortdesc>
		SWF ファイル形式のバージョン 6.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>6</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 6.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH7"><apiName>FLASH7</apiName><shortdesc>
		SWF ファイル形式のバージョン 7.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>7</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 7.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH8"><apiName>FLASH8</apiName><shortdesc>
		SWF ファイル形式のバージョン 8.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 8.0 です。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH9"><apiName>FLASH9</apiName><shortdesc>
		SWF ファイル形式のバージョン 9.0 です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>9</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF ファイル形式のバージョン 9.0 です。 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowResize"><apiName>NativeWindowResize</apiName><shortdesc>
NativeWindowResize クラスは、edgeOrCorner パラメーター (NativeWindow の startResize() メソッドのパラメーター) の有効な値を表す定数を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
NativeWindowResize クラスは、<codeph>edgeOrCorner</codeph> パラメーター（NativeWindow の <codeph>startResize()</codeph> メソッドのパラメーター）の有効な値を表す定数を定義します。 
<p>定数は、ウィンドウのそれぞれの端と隅に名前を付けるために定義されます。</p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow/startResize()"><linktext>flash.display.NativeWindow.startResize()</linktext></link></related-links><apiValue id="flash.display:NativeWindowResize:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
ウィンドウの下端です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの下端です。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
ウィンドウの左下隅です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの左下隅です。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
ウィンドウの右下隅です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの右下隅です。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:LEFT"><apiName>LEFT</apiName><shortdesc>
ウィンドウの左端です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの左端です。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:NONE"><apiName>NONE</apiName><shortdesc>
どの端や隅を基準にしてフォームをサイズ変更するか指定しません。デフォルトの動作が実行されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
どの端や隅を基準にしてフォームをサイズ変更するか指定しません。デフォルトの動作が実行されます。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:RIGHT"><apiName>RIGHT</apiName><shortdesc>
ウィンドウの右端です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの右端です。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP"><apiName>TOP</apiName><shortdesc>
ウィンドウの上端です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの上端です。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
ウィンドウの左上隅です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの左上隅です。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
ウィンドウの右上隅です。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ウィンドウの右上隅です。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapDataChannel"><apiName>BitmapDataChannel</apiName><shortdesc>
BitmapDataChannel クラスは、赤、青、緑、またはアルファ透明度のいずれのチャンネルを使用するかを示す定数値の列挙です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
BitmapDataChannel クラスは、赤、青、緑、またはアルファ透明度のいずれのチャンネルを使用するかを示す定数値の列挙です。 

<p>メソッドを呼び出すとき、ビット単位の OR 演算子（<codeph>|</codeph>）を使って BitmapDataChannel 定数を結合すれば、複数のカラーチャンネルを指定することができます。</p>

<p>BitmapDataChannel 定数は、次のような値として使用されます。</p>

<ul>

	<li><codeph>sourceChannel</codeph> パラメーターおよび <codeph>destChannel</codeph> パラメーター（<codeph>flash.display.BitmapData.copyChannel()</codeph> メソッドのパラメーター）</li>

	<li><codeph>channelOptions</codeph> パラメーター（<codeph>flash.display.BitmapData.noise()</codeph> メソッドのパラメーター）</li>

	<li><codeph>flash.filters.DisplacementMapFilter.componentX</codeph> プロパティおよび <codeph>flash.filters.DisplacementMapFilter.componentY</codeph> プロパティ</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/copyChannel()"><linktext>flash.display.BitmapData.copyChannel()</linktext></link><link href="flash.display.xml#BitmapData/noise()"><linktext>flash.display.BitmapData.noise()</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentX"><linktext>flash.filters.DisplacementMapFilter.componentX</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentY"><linktext>flash.filters.DisplacementMapFilter.componentY</linktext></link></related-links><apiValue id="flash.display:BitmapDataChannel:ALPHA"><apiName>ALPHA</apiName><shortdesc>
		アルファチャンネルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		アルファチャンネルです。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:BLUE"><apiName>BLUE</apiName><shortdesc> 
		青チャンネルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		青チャンネルです。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:GREEN"><apiName>GREEN</apiName><shortdesc>
		緑チャンネルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		緑チャンネルです。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:RED"><apiName>RED</apiName><shortdesc>
		赤チャンネルです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		赤チャンネルです。 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 単色の塗りを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 単色の塗りを定義します。 
 
 <p>
 GraphicsSolidFill オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。GraphicsSolidFill オブジェクトの描画は、<codeph>Graphics.beginFill()</codeph> メソッドの呼び出しに相当します。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>flash.display.Graphics.beginFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsSolidFill:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 新しい GraphicsSolidFill オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>カラー値です。有効な値は、16 進数形式（0xRRGGBB）です。  
 </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>アルファ透明度値です。有効な値は 0（完全な透明）～ 1（完全な不透明）です。
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 新しい GraphicsSolidFill オブジェクトを作成します。 
 
 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:GraphicsSolidFill:alpha"><apiName>alpha</apiName><shortdesc>
 塗りのアルファ透明度値を示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 塗りのアルファ透明度値を示します。有効な値は 0（完全な透明）～ 1（完全な不透明）です。デフォルト値は 1 です。alpha が 0 に設定されている表示オブジェクトは、表示されない場合でも、アクティブです。 
 
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsSolidFill:color"><apiName>color</apiName><shortdesc>
 塗りのカラーです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
 塗りのカラーです。 有効な値は、16 進数形式（0xRRGGBB）です。デフォルト値は 0xFF0000（または uint 0）です。 
 
 
 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IBitmapDrawable"><apiName>IBitmapDrawable</apiName><shortdesc>
	IBitmapDrawable インターフェイスは、BitmapData クラスの draw() メソッドの source パラメーターとして渡すことができるオブジェクトによって実装されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	IBitmapDrawable インターフェイスは、<codeph>source</codeph> パラメーター（BitmapData クラスの <codeph>draw()</codeph> メソッドのパラメーター）として渡すことができるオブジェクトによって実装されます。これらのオブジェクトは、BitmapData または DisplayObject タイプのものです。 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:CapsStyle"><apiName>CapsStyle</apiName><shortdesc>
 CapsStyle クラスは、線の描画で使用されるキャップのスタイルを指定する定数値の列挙です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 CapsStyle クラスは、線の描画で使用されるキャップのスタイルを指定する定数値の列挙です。この定数は、<codeph>caps</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）の値として使用されます。キャップの種類として、次の 3 つを指定できます。
 
 <p><adobeimage alt="キャップには、NONE、ROUND、および SQUARE の 3 種類があります。" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc><example conref="examples\CapsStyleExample.as"> 次の例では、<codeph>CapsStyleExample</codeph> クラスを使用して、線のキャップスタイルがそれぞれ異なる 3 本の平行線を描画します。
 <ol>
     <li>それぞれの線のプロパティは、次のように設定されます。
     <ul>
         <li>線の長さは 80 ピクセル</li>
         <li>境界線の色はオレンジ色</li>
         <li>境界線のサイズは 30 ピクセル </li>
         <li>ハイライトカラーは灰色 </li>
         <li>ハイライトサイズは 0 ピクセル</li>
         <li>アルファは 1（単色になる）</li>
         <li>ピクセルのヒンティングは false に設定（ピクセル全体に対して線がヒンティングされない）</li>
         <li>線の縮小 / 拡大モードは通常（太さを縮小 / 拡大） </li>
         <li>境界線キャップの結合スタイルは <codeph>MITER</codeph> に設定されます。</li>
         <li>マイター限度は 1（線に近いマイターが切り取られる）</li>
     </ul></li>
    <li>クラスコンストラクターは、<i>x = 0、y = 0</i> から始まる 3 本の垂直線を、それぞれ異なる線のキャップのスタイル（なし、丸、角）を使用して <codeph>drawLine()</codeph> メソッドを 3 回呼び出して作成します。<codeph>drawLine()</codeph> メソッドの 3 回の呼び出しごとに、キャップスタイルと上記のプロパティを使用して垂直線および関連する線ハイライトが描画されます。まず新しい Shape オブジェクト <codeph>child</codeph> が作成され、次に Graphics クラスのメソッドを使用して線のスタイルが設定されて線とハイライトが描画されます。各 <codeph>child</codeph> インスタンスが表示リストに追加され、ステージに描画されます。</li>
     <li>連結線セグメントは、<codeph>refreshLayout()</codeph> メソッドを使用して再描画されます。再描画される位置は <i>y = 80</i> ピクセル、起点は <i>x = 80</i> ピクセル、線のセグメント間の間隔は 25 ピクセルです。</li>
 </ol>
<codeblock>
package {
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class CapsStyleExample extends Sprite {
        private var lineLength:uint            = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderJointStyle:String    = JointStyle.MITER;
        private var borderMiterLimit:uint      = 1;

        public function CapsStyleExample() {
            drawLine(CapsStyle.NONE);
            drawLine(CapsStyle.ROUND);
            drawLine(CapsStyle.SQUARE);
            refreshLayout();
        }

        private function drawLine(capsStyle:String):void {
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     capsStyle,
                                     borderJointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = lineLength;
            lastChild.y = lineLength;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = lineLength;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:CapsStyle:NONE"><apiName>NONE</apiName><shortdesc>
	 
	 flash.display.Graphics.lineStyle() メソッドの caps パラメーターでキャップなしを指定するのに使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 <codeph>caps</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）でキャップなしを指定するのに使用します。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	 
	 flash.display.Graphics.lineStyle() メソッドの caps パラメーターで丸いキャップを指定するのに使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 <codeph>caps</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）で丸いキャップを指定するのに使用します。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:SQUARE"><apiName>SQUARE</apiName><shortdesc>
	 
	 flash.display.Graphics.lineStyle() メソッドの caps パラメーターで四角形のキャップを指定するのに使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>square</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 <codeph>caps</codeph> パラメーター（<codeph>flash.display.Graphics.lineStyle()</codeph> メソッドのパラメーター）で四角形のキャップを指定するのに使用します。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageScaleMode"><apiName>StageScaleMode</apiName><shortdesc>
StageScaleMode クラスは、Stage.scaleMode プロパティの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageScaleMode クラスは、<codeph>Stage.scaleMode</codeph> プロパティの値を提供します。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/scaleMode"><linktext>flash.display.Stage.scaleMode</linktext></link></related-links><apiValue id="flash.display:StageScaleMode:EXACT_FIT"><apiName>EXACT_FIT</apiName><shortdesc>
指定された領域内にアプリケーション全体が、元の縦横比を維持しないで表示されるよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exactFit</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定された領域内にアプリケーション全体が、元の縦横比を維持しないで表示されるよう指定します。歪みが発生する場合もあります。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_BORDER"><apiName>NO_BORDER</apiName><shortdesc>
指定された領域いっぱいにアプリケーション全体が歪まずに表示されるように指定します。ただし、アプリケーションの元の縦横比を保つために、ある程度トリミングされることがあります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noBorder</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定された領域いっぱいにアプリケーション全体が歪まずに表示されるように指定します。ただし、アプリケーションの元の縦横比を保つために、ある程度トリミングされることがあります。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_SCALE"><apiName>NO_SCALE</apiName><shortdesc>
 アプリケーションのサイズが固定され、Flash Player のウィンドウのサイズが変更された場合でも、サイズが維持されるように指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noScale</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 アプリケーションのサイズが固定され、Flash Player のウィンドウのサイズが変更された場合でも、サイズが維持されるように指定します。 Flash Player のウィンドウがコンテンツよりも小さい場合は、トリミングされることがあります。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:SHOW_ALL"><apiName>SHOW_ALL</apiName><shortdesc>
指定された領域内にアプリケーション全体が、アプリケーションの元の縦横比を維持したまま、歪まずに表示されるよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>showAll</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定された領域内にアプリケーション全体が、アプリケーションの元の縦横比を維持したまま、歪まずに表示されるよう指定します。 ただし、アプリケーションの両側に境界枠が表示されることがあります。

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SpreadMethod"><apiName>SpreadMethod</apiName><shortdesc>
SpreadMethod クラスは、Graphics クラスの beginGradientFill() メソッドおよび lineGradientStyle() メソッドの spreadMethod パラメーターの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
SpreadMethod クラスは、<codeph>spreadMethod</codeph> パラメーター（Graphics クラスの <codeph>beginGradientFill()</codeph> メソッドおよび <codeph>lineGradientStyle()</codeph> メソッドのパラメーター）の値を提供します。

<p>以下は、さまざまな spread メソッドを使用して同じグラデーションの塗りを行う例です。</p>

<adobetable>





<tgroup cols="3"><tbody><row>

	<entry align="center"><adobeimage alt="SpreadMethod.PAD での線状グラデーション" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>

  <entry align="center"><adobeimage alt="SpreadMethod.REFLECT での線状グラデーション" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>

  <entry align="center"><adobeimage alt="SpreadMethod.REPEAT での線状グラデーション" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>

</row><row>

	 <entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>


</row></tbody></tgroup></adobetable>


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:SpreadMethod:PAD"><apiName>PAD</apiName><shortdesc>
グラデーションで spread メソッド pad を使用することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pad</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
グラデーションで spread メソッド <i>pad</i> を使用することを指定します。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REFLECT"><apiName>REFLECT</apiName><shortdesc>
グラデーションで spread メソッド reflect を使用することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reflect</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
グラデーションで spread メソッド <i>reflect</i> を使用することを指定します。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REPEAT"><apiName>REPEAT</apiName><shortdesc>
グラデーションで spread メソッド repeat を使用することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>repeat</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
グラデーションで spread メソッド <i>repeat</i> を使用することを指定します。
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:FocusDirection"><apiName>FocusDirection</apiName><shortdesc>
 FocusDirection クラスでは、direction パラメーター（Stage オブジェクトの assignFocus() メソッドのパラメーター）および direction プロパティ（FocusEvent オブジェクトのプロパティ）に使用する値が列挙されます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 FocusDirection クラスでは、<codeph>direction</codeph> パラメーター（Stage オブジェクトの <codeph>assignFocus()</codeph> メソッドのパラメーター）および <codeph>direction</codeph> プロパティ（FocusEvent オブジェクトのプロパティ）に使用する値が列挙されます。
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#FocusEvent/direction"><linktext>flash.events.FocusEvent.direction</linktext></link><link href="flash.display.xml#Stage/assignFocus()"><linktext>flash.display.Stage.assignFocus()</linktext></link></related-links><apiValue id="flash.display:FocusDirection:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
		読み込み順の最後のオブジェクトにフォーカスを与えることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bottom</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		読み込み順の最後のオブジェクトにフォーカスを与えることを示します。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:NONE"><apiName>NONE</apiName><shortdesc>
		インタラクティブオブジェクト内のフォーカスオブジェクトを変更しないことを示します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		インタラクティブオブジェクト内のフォーカスオブジェクトを変更しないことを示します。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:TOP"><apiName>TOP</apiName><shortdesc>
		読み込み順の最初のオブジェクトにフォーカスを与えることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>top</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		読み込み順の最初のオブジェクトにフォーカスを与えることを示します。
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageAlign"><apiName>StageAlign</apiName><shortdesc>
StageAlign クラスは、Stage.align プロパティに使用する定数値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageAlign クラスは、<codeph>Stage.align</codeph> プロパティに使用する定数値を提供します。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/align"><linktext>flash.display.Stage.align</linktext></link></related-links><apiValue id="flash.display:StageAlign:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
ステージを下揃えにするよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを下揃えにするよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
ステージを左下の隅に揃えるよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを左下の隅に揃えるよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
ステージを右下の隅に揃えるよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを右下の隅に揃えるよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
ステージを左揃えにするよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを左揃えにするよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
ステージを右揃えにするよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを右揃えにするよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP"><apiName>TOP</apiName><shortdesc>
ステージを上揃えにするよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを上揃えにするよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
ステージを左上の隅に揃えるよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを左上の隅に揃えるよう指定します。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
ステージを右上の隅に揃えるよう指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ステージを右上の隅に揃えるよう指定します。 
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrectionSupport"><apiName>ColorCorrectionSupport</apiName><shortdesc>
ColorCorrectionSupport クラスは、flash.display.Stage.colorCorrectionSupport プロパティの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
ColorCorrectionSupport クラスは、<codeph>flash.display.Stage.colorCorrectionSupport</codeph> プロパティの値を提供します。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>flash.display.Stage.colorCorrectionSupport</linktext></link></related-links><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_OFF"><apiName>DEFAULT_OFF</apiName><shortdesc>
カラー補正はサポートされていますが、デフォルトでオフになっています。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOff</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
カラー補正はサポートされていますが、デフォルトでオフになっています。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_ON"><apiName>DEFAULT_ON</apiName><shortdesc>
カラー補正はデフォルトでサポートされています。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOn</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
カラー補正はデフォルトでサポートされています。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:UNSUPPORTED"><apiName>UNSUPPORTED</apiName><shortdesc>
カラー補正はホスト環境でサポートされていません。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unsupported</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
カラー補正はホスト環境でサポートされていません。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
 シェーダー塗りを定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 シェーダー塗りを定義します。 
 
 <p>
 GraphicsShaderFill オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。GraphicsShaderFill オブジェクトの描画は、<codeph>Graphics.beginShaderFill()</codeph> メソッドの呼び出しに相当します。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsShaderFill:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
     新しい GraphicsShaderFill オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>塗りに使用するシェーダーです。この Shader インスタンスはイメージ入力の指定には必要ありません。ただし、シェーダーでイメージ入力が指定されている場合は、対応する <codeph>Shader.data</codeph> プロパティの ShaderInput プロパティに <codeph>input</codeph> プロパティを設定して、手動で入力する必要があります。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>flash.geom.Matrix クラスのマトリックスオブジェクトです。これを使用してシェーダー上に変形を定義できます。 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     新しい GraphicsShaderFill オブジェクトを作成します。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsShaderFill:matrix"><apiName>matrix</apiName><shortdesc>
     flash.geom.Matrix クラスのマトリックスオブジェクトです。これを使用してシェーダー上に変形を定義できます。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     flash.geom.Matrix クラスのマトリックスオブジェクトです。これを使用してシェーダー上に変形を定義できます。例えば、次のマトリックスを使用すると、シェーダーを 45 度（π/4 ラジアン）回転できます。
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     <p>シェーダーで受け取る座標は、<codeph>matrix</codeph> パラメーターに対して指定したマトリックスに基づきます。デフォルトの（<codeph>null</codeph>）のマトリックスの場合、シェーダーの座標は入力のサンプリングが可能なローカルピクセル座標になります。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsShaderFill:shader"><apiName>shader</apiName><shortdesc>
     塗りに使用するシェーダーです。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
     塗りに使用するシェーダーです。この Shader インスタンスはイメージ入力の指定には必要ありません。ただし、シェーダーでイメージ入力が指定されている場合は、対応する <codeph>Shader.data</codeph> プロパティの ShaderInput プロパティに <codeph>input</codeph> プロパティを設定して、手動で入力する必要があります。
     
     <p>Shader インスタンスを引数として渡すと、シェーダーが内部的にコピーされ、描画塗り操作は元のシェーダーを参照するのではなく、その内部コピーを使用します。パラメーター値、入力、バイトコードの変更などの変更をシェーダーに加えたとしても、塗りつぶしに使用したコピーシェーダーにはその変更は適用されません。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Shape"><apiName>Shape</apiName><shortdesc>
 このクラスは、ActionScript 描画アプリケーションプログラムインターフェイス（API）を使用して単純なシェイプを作成するときに使用されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>シェイプに使用される表示オブジェクトです。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 このクラスは、ActionScript 描画アプリケーションプログラムインターフェイス（API）を使用して単純なシェイプを作成するときに使用されます。 Shape クラスには、Graphics クラスからメソッドにアクセスできる <codeph>graphics</codeph> プロパティがあります。
 
 <p>Sprite クラスにも <codeph>graphics</codeph> プロパティがあり、これには Shape クラスでは使用できない他の機能があります。例えば、Sprite オブジェクトは表示オブジェクトコンテナであるのに対し、Shape オブジェクトはそうではありません（子表示オブジェクトも持てません）。したがって、表示するグラフィックスが同じであっても、Sprite オブジェクトは、Shape オブジェクトよりも多くのメモリを消費します。ただし、Sprite オブジェクトではマウスクリックイベントがサポートされますが、Shape オブジェクトではサポートされません。</p>
 
 </apiDesc><example conref="examples\ShapeExample.as"> 次の例では、<codeph>ShapeExample</codeph> クラスを使用して、円、角丸矩形、および四角形を描画します。これを行うには、以下の手順を実行します。
 
 <ol>
    <li>後で各シェイプのサイズを決定する際に使用する <codeph>size</codeph> プロパティを宣言します。</li>
 
     <li>背景色をオレンジ色、境界線色を濃い灰色、境界線のサイズを 0 ピクセル、角丸の半径を 9 ピクセル、ステージの端と他のオブジェクトの間のスペースを 5 ピクセルに、それぞれ設定するプロパティを宣言します。</li>
 
    <li>上記の手順で宣言したプロパティを Graphics クラスのビルトインメソッドと共に使用して、円、角丸矩形、および四角形を、座標 x = 0、y = 0 に描画します。</li>
 
    <li><codeph>refreshLayout()</codeph> メソッドを使用し、ステージの一番上に配置された各シェイプを、x = 5、y = 5 から、シェイプ間のスペースを 5 ピクセルにして再描画します。</li>
 
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class ShapeExample extends Sprite {
        private var size:uint           = 80;
        private var bgColor:uint       = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function ShapeExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size/2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#Sprite"><linktext>flash.display.Sprite</linktext></link></related-links><apiConstructor id="flash.display:Shape:Shape"><apiName>Shape</apiName><shortdesc>
     新しい Shape オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     新しい Shape オブジェクトを作成します。
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shape:graphics:get"><apiName>graphics</apiName><shortdesc>
     ベクターの描画コマンドが発生する、この Shape オブジェクトに属する Graphics オブジェクトを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Shape オブジェクトの Graphics オブジェクトを指定します。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     ベクターの描画コマンドが発生する、この Shape オブジェクトに属する Graphics オブジェクトを指定します。
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameterType"><apiName>ShaderParameterType</apiName><shortdesc>
	 このクラスによって、ShaderParameter クラスの type プロパティの有効な値を表す定数が定義されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 このクラスによって、ShaderParameter クラスの <codeph>type</codeph> プロパティの有効な値を表す定数が定義されます。各定数は、Flash Player で使用可能な Pixel Bender シェーダー言語のパラメーターに対するデータ型のいずれかを表します。
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links><apiValue id="flash.display:ShaderParameterType:BOOL"><apiName>BOOL</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 1 つの Boolean インスタンスに相当する bool 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 1 つの Boolean インスタンスに相当する <codeph>bool</codeph> 値に定義されていることを示します。
		 
		 <p>このパラメーターは 1 つの値しか取ることができませんが、<codeph>ShaderParameter.value</codeph> プロパティは Array なので、1 つの値が <codeph>value</codeph> プロパティに割り当てられた Array の唯一のエレメントでなければなりません。次のようになります。</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is bool
		 myShader.data.param.value = [true];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL2"><apiName>BOOL2</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 2 つの Boolean インスタンスの Array に相当する bool2 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 2 つの Boolean インスタンスの Array に相当する <codeph>bool2</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL3"><apiName>BOOL3</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 3 つの Boolean インスタンスの Array に相当する bool3 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 3 つの Boolean インスタンスの Array に相当する <codeph>bool3</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL4"><apiName>BOOL4</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 4 つの Boolean インスタンスの Array に相当する bool4 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 4 つの Boolean インスタンスの Array に相当する <codeph>bool4</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT"><apiName>FLOAT</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 1 つの Number インスタンスに相当する float 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 1 つの Number インスタンスに相当する <codeph>float</codeph> 値に定義されていることを示します。
		 
		 <p>このパラメーターは 1 つの値しか取ることができませんが、<codeph>ShaderParameter.value</codeph> プロパティは Array なので、1 つの値が <codeph>value</codeph> プロパティに割り当てられた Array の唯一のエレメントでなければなりません。次のようになります。</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is float
		 myShader.data.param.value = [22.5];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT2"><apiName>FLOAT2</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 2 つの Number インスタンスの Array に相当する float2 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 2 つの Number インスタンスの Array に相当する <codeph>float2</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT3"><apiName>FLOAT3</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 3 つの Number インスタンスの Array に相当する float3 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 3 つの Number インスタンスの Array に相当する <codeph>float3</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT4"><apiName>FLOAT4</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 4 つの Number インスタンスの Array に相当する float4 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 4 つの Number インスタンスの Array に相当する <codeph>float4</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT"><apiName>INT</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 1 つの int または uint インスタンスに相当する int 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 1 つの int または uint インスタンスに相当する <codeph>int</codeph> 値に定義されていることを示します。
		 
		 <p>このパラメーターは 1 つの値しか取ることができませんが、<codeph>ShaderParameter.value</codeph> プロパティは Array なので、1 つの値が <codeph>value</codeph> プロパティに割り当てられた Array の唯一のエレメントでなければなりません。次のようになります。</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is int
		 myShader.data.param.value = [275];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT2"><apiName>INT2</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 2 つの int または uint インスタンスの Array に相当する int2 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 2 つの int または uint インスタンスの Array に相当する <codeph>int2</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT3"><apiName>INT3</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 3 つの int または uint インスタンスの Array に相当する int3 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 3 つの int または uint インスタンスの Array に相当する <codeph>int3</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT4"><apiName>INT4</apiName><shortdesc>
		 シェーダーパラメーターが、ActionScript の 4 つの int または uint インスタンスの Array に相当する int4 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、ActionScript の 4 つの int または uint インスタンスの Array に相当する <codeph>int4</codeph> 値に定義されていることを示します。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX2X2"><apiName>MATRIX2X2</apiName><shortdesc>
		 シェーダーパラメーターが、2 x 2 マトリックスに相当する float2x2 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix2x2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、2 x 2 マトリックスに相当する <codeph>float2x2</codeph> 値に定義されていることを示します。このマトリックスは、ActionScript では 4 つの Number インスタンスの Array で表されます。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX3X3"><apiName>MATRIX3X3</apiName><shortdesc>
		 シェーダーパラメーターが、3 x 3 マトリックスに相当する float3x3 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix3x3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、3 x 3 マトリックスに相当する <codeph>float3x3</codeph> 値に定義されていることを示します。このマトリックスは、ActionScript では 9 つの Number インスタンスの Array で表されます。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX4X4"><apiName>MATRIX4X4</apiName><shortdesc>
		 シェーダーパラメーターが、4 x 4 マトリックスに相当する float4x4 値に定義されていることを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix4x4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 シェーダーパラメーターが、4 x 4 マトリックスに相当する <codeph>float4x4</codeph> 値に定義されていることを示します。このマトリックスは、ActionScript では 16 の Number インスタンスの Array で表されます。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathWinding"><apiName>GraphicsPathWinding</apiName><shortdesc>
GraphicsPathWinding クラスは、flash.display.GraphicsPath.winding プロパティおよび flash.display.Graphics.drawPath() メソッドの値を提供します。これらの値により、パスの描画方向が決まります。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
GraphicsPathWinding クラスは、<codeph>flash.display.GraphicsPath.winding</codeph> プロパティおよび <codeph>flash.display.Graphics.drawPath()</codeph> メソッドの値を提供します。これらの値により、パスの描画方向が決まります。時計回りのパスは正の湾曲方向であり、反時計回りのパスは負の湾曲方向です。
<p><adobeimage alt="正の湾曲方向と負の湾曲方向" href="../../images/winding_positive_negative.gif"/></p>
<p> パスが交差または重なり合う場合、湾曲の方向によって、交差または重なりで作成された領域の塗りの規則が決まります。</p>
<p><adobeimage alt="奇数 / 偶数およびゼロ以外の湾曲規則の比較" href="../../images/winding_rules_evenodd_nonzero.gif"/></p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#GraphicsPath/winding"><linktext>flash.display.GraphicsPath.winding</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiValue id="flash.display:GraphicsPathWinding:EVEN_ODD"><apiName>EVEN_ODD</apiName><shortdesc>
奇数 / 偶数の湾曲タイプを設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>evenOdd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
奇数 / 偶数の湾曲タイプを設定します。奇数 / 偶数の湾曲タイプは、元のすべての描画 API で使用される規則であり、<codeph>flash.display.Graphics.drawPath()</codeph> メソッドのデフォルトのタイプです。重なり合うパスでは、開いた塗りと閉じた塗りが交互に発生します。同じ塗りの交差を使用して 2 つの四角形を描画した場合、交差領域は塗りつぶされません。隣接する領域は同じではありません（両方が塗りつぶされることも、両方が塗りつぶされないこともありません）。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathWinding:NON_ZERO"><apiName>NON_ZERO</apiName><shortdesc>
ゼロ以外の湾曲タイプを設定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>nonZero</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
ゼロ以外の湾曲タイプを設定します。ゼロ以外の湾曲タイプは、反対方向の湾曲のパスが交差するとき、交差領域が塗りつぶされないことを指定します（奇数 / 偶数の湾曲タイプの場合と同じ）。同じ方向の湾曲のパスの場合は、交差領域が塗りつぶされます。

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ActionScriptVersion"><apiName>ActionScriptVersion</apiName><shortdesc>
	ActionScriptVersion クラスは、読み込まれる SWF ファイルの言語バージョンを示す定数値の列挙です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	ActionScriptVersion クラスは、読み込まれる SWF ファイルの言語バージョンを示す定数値の列挙です。言語バージョン定数は flash.display.LoaderInfo オブジェクトの <codeph>actionScriptVersion</codeph> プロパティの検査に使用されます。
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/actionScriptVersion"><linktext>flash.display.LoaderInfo.actionScriptVersion</linktext></link></related-links><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT2"><apiName>ACTIONSCRIPT2</apiName><shortdesc>
		ActionScript 言語バージョン 2.0 以前。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript 言語バージョン 2.0 以前。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT3"><apiName>ACTIONSCRIPT3</apiName><shortdesc>
		ActionScript 言語バージョン 3.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript 言語バージョン 3.0。 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
 描画コマンドおよびそれらのコマンドの座標パラメーターのコレクションです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 描画コマンドおよびそれらのコマンドの座標パラメーターのコレクションです。
 <p>
 GraphicsPath オブジェクトは、<codeph>Graphics.drawGraphicsData()</codeph> メソッドと共に使用します。GraphicsPath オブジェクトの描画は、<codeph>Graphics.drawPath()</codeph> メソッドの呼び出しに相当します。
 </p>
 <p>GraphicsPath クラスには独自のメソッドのセット（<codeph>curveTo()</codeph>、<codeph>lineTo()</codeph>、<codeph>moveTo()</codeph>、<codeph>wideLineTo()</codeph> および <codeph>wideMoveTo()</codeph>）も含まれています。これらのメソッドは、Graphics クラスで <codeph>GraphicsPath.commands</codeph> および <codeph>GraphicsPath.data</codeph> ベクター配列を調整するためのメソッドに似ています。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsPath:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
     新しい GraphicsPath オブジェクトを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>GraphicsPathCommand クラスで定義されているコマンドを表す整数の Vector です。
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Number の Vector で、数値の各ペアはポイント（x と y のペア）として扱われます。
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>GraphicsPathWinding クラスで定義されている値を使用して、湾曲規則を指定します。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     新しい GraphicsPath オブジェクトを作成します。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:GraphicsPath:curveTo"><apiName>curveTo</apiName><shortdesc>
     新しい「curveTo」コマンドを commands ベクターに、新しい座標を data ベクターに追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的なコントロールポイントの水平座標を指定する数値。  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的なコントロールポイントの垂直座標を指定する数値。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な次のアンカーポイントの水平座標を指定する数値。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>親表示オブジェクトの基準点からの相対的な次のアンカーポイントの垂直座標を指定する数値。
     
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     新しい「curveTo」コマンドを <codeph>commands</codeph> ベクターに、新しい座標を <codeph>data</codeph> ベクターに追加します。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/CURVE_TO"><linktext>flash.display.GraphicsPathCommand.CURVE_TO</linktext></link><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:lineTo"><apiName>lineTo</apiName><shortdesc>
     新しい「lineTo」コマンドを commands ベクターに、新しい座標を data ベクターに追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>線のターゲットポイントの x 座標。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>線のターゲットポイントの y 座標。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     新しい「lineTo」コマンドを <codeph>commands</codeph> ベクターに、新しい座標を <codeph>data</codeph> ベクターに追加します。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>flash.display.GraphicsPathCommand.LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:moveTo"><apiName>moveTo</apiName><shortdesc>
     新しい「moveTo」コマンドを commands ベクターに、新しい座標を data ベクターに追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>ターゲットポイントの x 座標。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>ターゲットポイントの y 座標。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     新しい「moveTo」コマンドを <codeph>commands</codeph> ベクターに、新しい座標を <codeph>data</codeph> ベクターに追加します。
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>flash.display.GraphicsPathCommand.MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideLineTo"><apiName>wideLineTo</apiName><shortdesc>
     新しい「wideLineTo」コマンドを commands ベクターに、新しい座標を data ベクターに追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>線のターゲットポイントの x 座標。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>線のターゲットポイントの y 座標。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     新しい「wideLineTo」コマンドを <codeph>commands</codeph> ベクターに、新しい座標を <codeph>data</codeph> ベクターに追加します。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_LINE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_LINE_TO</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideMoveTo"><apiName>wideMoveTo</apiName><shortdesc>
     新しい「wideMoveTo」コマンドを commands ベクターに、新しい座標を data ベクターに追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>ターゲットポイントの x 座標。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>ターゲットポイントの y 座標。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     新しい「wideMoveTo」コマンドを <codeph>commands</codeph> ベクターに、新しい座標を <codeph>data</codeph> ベクターに追加します。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_MOVE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_MOVE_TO</linktext></link></related-links></apiOperation><apiValue id="flash.display:GraphicsPath:commands"><apiName>commands</apiName><shortdesc>
     パスを表す整数としての描画コマンドの Vector です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     パスを表す整数としての描画コマンドの Vector です。コマンドはそれぞれ GraphicsPathCommand クラスで定義されたいずれかの値となります。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPath:data"><apiName>data</apiName><shortdesc>
     描画コマンドと共に使用するパラメーターを含む Number の Vector です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     描画コマンドと共に使用するパラメーターを含む Number の Vector です。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPath:winding:get"><apiName>winding</apiName><shortdesc>
     GraphicsPathWinding クラスで定義されている値を使用して、湾曲規則を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     GraphicsPathWinding クラスで定義されている値を使用して、湾曲規則を指定します。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:MorphShape"><apiName>MorphShape</apiName><shortdesc>
 MorphShape クラスは、表示リスト上の MorphShape オブジェクトを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 MorphShape クラスは、表示リスト上の MorphShape オブジェクトを表します。ActionScript で直接 MorphShape オブジェクトを作成することはできません。このオブジェクトは、Flash オーサリングツールでシェイプトゥイーンを作成したときに作成されます。
 
 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="flash.display:PixelSnapping"><apiName>PixelSnapping</apiName><shortdesc>

PixelSnapping クラスは、Bitmap オブジェクトの pixelSnapping プロパティを使用して、ピクセル吸着オプションを設定するための定数値の列挙です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

PixelSnapping クラスは、Bitmap オブジェクトの <codeph>pixelSnapping</codeph> プロパティを使用して、ピクセル吸着オプションを設定するための定数値の列挙です。


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/pixelSnapping"><linktext>flash.display.Bitmap.pixelSnapping</linktext></link></related-links><apiValue id="flash.display:PixelSnapping:ALWAYS"><apiName>ALWAYS</apiName><shortdesc>
	Bitmap オブジェクトの pixelSnapping プロパティで使用される定数値。変形とは無関係に、ビットマップイメージが常に最も近いピクセルに吸着することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>always</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Bitmap オブジェクトの <codeph>pixelSnapping</codeph> プロパティで使用される定数値。変形とは無関係に、ビットマップイメージが常に最も近いピクセルに吸着することを指定します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:AUTO"><apiName>AUTO</apiName><shortdesc>
	Bitmap オブジェクトの pixelSnapping プロパティで使用される定数値。ビットマップイメージが回転または傾斜なしで、99.9% から 100.1% の縮尺率で描画される場合に、ビットマップイメージが最も近いピクセルに吸着することを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>auto</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Bitmap オブジェクトの <codeph>pixelSnapping</codeph> プロパティで使用される定数値です。ビットマップイメージが回転または傾斜なしで、99.9% ～ 100.1% の縮尺率で描画される場合に、ビットマップイメージが最も近いピクセルに吸着することを指定します。これらの条件が満たされると、イメージは、最も近いピクセルに吸着して縮尺 100% で描画されます。この設定によって、内部的に、ベクターレンダラーを使ってイメージが可能な限り高速に描画されます。
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:NEVER"><apiName>NEVER</apiName><shortdesc>
	Bitmap オブジェクトの pixelSnapping プロパティで使用され、ピクセルへの吸着が発生しないことを指定する定数値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Bitmap オブジェクトの <codeph>pixelSnapping</codeph> プロパティで使用され、ピクセルへの吸着が発生しないことを指定する定数値です。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathCommand"><apiName>GraphicsPathCommand</apiName><shortdesc>
 パス描画コマンドの指定に使用する値を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 パス描画コマンドの指定に使用する値を定義します。 
 
 <p>このクラスの値は、<codeph>Graphics.drawPath()</codeph> メソッドで使用されるか、または GraphicsPath オブジェクトの <codeph>commands</codeph> ベクターに格納されます。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link><link href="flash.display.xml#GraphicsPath/commands"><linktext>flash.display.GraphicsPath.commands</linktext></link></related-links><apiValue id="flash.display:GraphicsPathCommand:CURVE_TO"><apiName>CURVE_TO</apiName><shortdesc>
     現在の描画位置からデータベクターで指定されている（x,y）座標まで、コントロールポイントを使用して、曲線を描画する描画コマンドを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     現在の描画位置からデータベクターで指定されている（x,y）座標まで、コントロールポイントを使用して、曲線を描画する描画コマンドを指定します。このコマンドは、<codeph>Graphics.lineTo()</codeph> メソッドと同じ効果をもたらし、データベクターコントロールおよびアンカー内の 2 つのポイント（cx, cy, ax, ay）を使用します。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:LINE_TO"><apiName>LINE_TO</apiName><shortdesc>
     現在の描画位置からデータベクターで指定されている（x,y）座標までの線を描画する描画コマンドを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     現在の描画位置からデータベクターで指定されている（x,y）座標までの線を描画する描画コマンドを指定します。このコマンドは、<codeph>Graphics.lineTo()</codeph> メソッドと同じ効果をもたらし、データベクター内の 1 つのポイント（x,y）を使用します。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:MOVE_TO"><apiName>MOVE_TO</apiName><shortdesc>
     現在の描画位置を、データベクターで指定されている（x,y）座標に移動する描画コマンドを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     現在の描画位置を、データベクターで指定されている（x,y）座標に移動する描画コマンドを指定します。このコマンドは、<codeph>Graphics.moveTo()</codeph> メソッドと同じ効果をもたらし、データベクター内の 1 つのポイント（x,y）を使用します。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:NO_OP"><apiName>NO_OP</apiName><shortdesc>
     デフォルトの「do nothing」コマンドを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     デフォルトの「do nothing」コマンドを表します。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_LINE_TO"><apiName>WIDE_LINE_TO</apiName><shortdesc>
     「line to」描画コマンドを指定しますが、1 つではなく 2 つの座標セット（4 つの値）を使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     「line to」描画コマンドを指定しますが、1 つではなく 2 つの座標セット（4 つの値）を使用します。このコマンドを使用すると、各コマンドで使用されるデータ値の数を変更することなく、「line to」コマンドと「curve to」コマンドを切り替えられるようになります。このコマンドは、データベクター内の 2 つのセット、つまり、1 つのダミー位置と 1 つの（x,y）位置を使用します。
     
     <p><codeph>WIDE_LINE_TO</codeph> コマンドおよび <codeph>WIDE_MOVE_TO</codeph> コマンドの各バリアントは、<codeph>CURVE_TO</codeph> コマンドと同じ数のパラメーター使用します。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_MOVE_TO"><apiName>WIDE_MOVE_TO</apiName><shortdesc>
     「move to」描画コマンドを指定しますが、1 つではなく 2 つの座標セット（4 つの値）を使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     「move to」描画コマンドを指定しますが、1 つではなく 2 つの座標セット（4 つの値）を使用します。このコマンドを使用すると、各コマンドで使用されるデータ値の数を変更することなく、「move to」コマンドと「curve to」コマンドを切り替えられるようになります。このコマンドは、データベクター内の 2 つのセット、つまり、1 つのダミー位置と 1 つの（x,y）位置を使用します。
     
     <p><codeph>WIDE_LINE_TO</codeph> コマンドおよび <codeph>WIDE_MOVE_TO</codeph> コマンドの各バリアントは、<codeph>CURVE_TO</codeph> コマンドと同じ数のパラメーター使用します。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>