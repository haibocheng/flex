<?xml version="1.0"?>
<apiPackage id="flash.filters"><apiName>flash.filters</apiName><apiDetail/><apiClassifier id="flash.filters:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
ColorMatrixFilter クラスを使用すると、入力イメージの各ピクセルの RGBA カラー値とアルファ値に 4 × 5 マトリックス変換を適用することで、新しい RGBA カラー値とアルファ値から成る結果を作成できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>各ピクセルのカラー値とアルファ透明度値にカラーマトリックス変換を適用します。
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
ColorMatrixFilter クラスを使用すると、入力イメージの各ピクセルの RGBA カラー値とアルファ値に 4 × 5 マトリックス変換を適用することで、新しい RGBA カラー値とアルファ値から成る結果を作成できます。これにより、彩度変更、色相回転、輝度アルファ変換など、さまざまな効果を利用できます。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。

<p><b>注意：</b>RGBA 値の最上位バイトは赤チャネルの値を表し、後続のバイトはそれぞれ緑、青、アルファの値を表します。</p>

<p>新しいカラーマトリックスフィルターを作成するには、シンタックス <codeph>new ColorMatrixFilter()</codeph> を使用します。フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
<ul><li>ムービークリップ、テキストフィールド、ボタン、およびビデオにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>

<li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
</ul>

<p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティは <codeph>true</codeph> に設定されます。すべてのフィルターを削除すると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>

<p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズに達すると、フィルターがオフになります。</p>

</apiDesc><example conref="examples\ColorMatrixFilterExample.as"> 次の例は、さまざまなカラーマトリックスフィルターをイメージファイルに適用します。フィルターコンストラクターでは、<codeph>buildChild()</codeph> を 4 回呼び出して、イメージの 4 つのインスタンスを読み込んで表示します。<codeph>buildChild()</codeph> の最初の呼び出しでは、引数として <codeph>null</codeph> を取り、最初のインスタンスにフィルターを適用しません。その後 <codeph>buildChild()</codeph> を呼び出すたびに、異なるカラーマトリックスフィルターをその後のイメージインスタンスに適用する関数を、引数として取ります。
 <p><codeph>buildChild()</codeph> 関数は <codeph>loader</codeph>という名前の新しい Loader オブジェクトを作成します。<codeph>buildChild()</codeph> を呼び出すたびに、<codeph>complete</codeph> イベントを受け取るイベントリスナーを Loader オブジェクトにアタッチします。これらのイベントは <codeph>buildChild()</codeph> に渡される関数によって処理されます。</p>
 
 <p><codeph>applyRed()</codeph>、<codeph>applyGreen()</codeph>、および <codeph>applyBlue()</codeph> 関数は <codeph>matrix</codeph> 配列に対して異なる値を使用して、さまざまな効果を作り出します。</p>
 <p><b>注意：</b>幅が約 80 ピクセル以内のイメージを使用すると、最良の結果が得られます。イメージファイルの名前と場所は <codeph>url</codeph> プロパティに渡す値に一致する必要があります。例えば、この例の <codeph>url</codeph> に渡す値は、SWF ファイルと同じディレクトリ内にある "Image.jpg" という名前のイメージファイルを指します。
 </p>
 <codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.filters.ColorMatrixFilter;
    import flash.net.URLRequest;

    public class ColorMatrixFilterExample extends Sprite {
        private var size:uint  = 140;
        private var url:String = "Image.jpg";

        public function ColorMatrixFilterExample() {
            buildChild(null);
            buildChild(applyRed);
            buildChild(applyGreen);
            buildChild(applyBlue);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if (loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyRed(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([1, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyGreen(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 1, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyBlue(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>flash.display.BitmapData.getPixel()</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:ColorMatrixFilter:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
	指定されたパラメーターで新しい ColorMatrixFilter インスタンスを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>4 × 5 のマトリックス構成を持つ 20 個のアイテムの配列です。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>新しい ColorMatrixFilter インスタンスを初期化します。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	指定されたパラメーターで新しい ColorMatrixFilter インスタンスを初期化します。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ColorMatrixFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
 	clones it using the <code>clone</code> method. The <code>matrix</code> property cannot be changed directly (for example,
	<code>clonedFilter.matrix[2] = 1;</code>). Instead, you must get a reference
	to the array, make the change, and reset the value using
	<code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter:       " + filter.matrix);
	
	var clonedFilter:ColorMatrixFilter = filter.clone();
	matrix = clonedFilter.matrix;
	matrix[2] = 1;
	clonedFilter.matrix = matrix;
	trace("clonedFilter: " + clonedFilter.matrix);
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元のインスタンスと同じプロパティをすべて備えた新しい ColorMatrixFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ColorMatrixFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	4 × 5 カラー変換用の 20 個のアイテムの配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
  	changes its <code>matrix</code> property. The <code>matrix</code> property cannot be changed by directly modifying
  	its value (for example, <code>clonedFilter.matrix[2] = 1;</code>). Instead, you must
  	get a reference to the array, make the change to the reference, and reset the
	value using <code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter: " + filter.matrix);
	var changedMatrix:Array = filter.matrix;
	changedMatrix[2] = 1;
	filter.matrix = changedMatrix;
	trace("filter: " + filter.matrix);
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	4 × 5 カラー変換用の 20 個のアイテムの配列です。<codeph>matrix</codeph> プロパティは、例えば <codeph>myFilter.matrix[2] = 1;</codeph> のようにしてその値を直接変更することはできません。このプロパティを変更するには、配列への参照を取得し、その参照を変更し、値をリセットする必要があります。
	
	<p>カラーマトリックスフィルターにより、元の各ピクセルが赤、緑、青、アルファの各成分（srcR、srcG、srcB、srcA）に分解されます。4 つのチャンネルそれぞれの結果を計算するために、イメージの各ピクセルの値に変換マトリックスの値が乗算されます。それぞれの結果（マトリックスの各行で 5 番目のアイテム）には -255 ～ 255 の範囲でオフセットを追加できます。カラー成分が 1 つのピクセルに再び結合され、結果が出力されます。次の式において、a[0] ～ a[19] は 20 個の要素を持つ配列のエントリ 0 ～ 19 に対応します。この配列は <codeph>matrix</codeph> プロパティに渡されます。</p>
	<pre>
	redResult   = (a[0]  ~~ srcR) + (a[1]  ~~ srcG) + (a[2]  ~~ srcB) + (a[3]  ~~ srcA) + a[4]
	greenResult = (a[5]  ~~ srcR) + (a[6]  ~~ srcG) + (a[7]  ~~ srcB) + (a[8]  ~~ srcA) + a[9]
	blueResult  = (a[10] ~~ srcR) + (a[11] ~~ srcG) + (a[12] ~~ srcB) + (a[13] ~~ srcA) + a[14]
	alphaResult = (a[15] ~~ srcR) + (a[16] ~~ srcG) + (a[17] ~~ srcB) + (a[18] ~~ srcA) + a[19]
	</pre>
	
	<p>配列の各カラー値が 1 の場合は、出力に送信されるチャンネルが 100% であることに相当し、カラーチャンネルの値が保持されます。</p>
	
	<p>この計算は、乗算されていないカラー値に対して実行します。入力グラフィックが乗算済みカラー値で構成される場合は、この処理のために、乗算済みのカラー値が乗算されていないカラー値に自動的に変換されます。</p>
	
	<p>次の 2 つの最適化モードを使用できます。</p>
	
	<p><b>アルファのみ。</b>ここに示すようにアルファ成分のみを調整するマトリックスをフィルターに渡すと、フィルターのパフォーマンスが最適化されます。</p>
	<pre>
	    1 0 0 0 0
	    0 1 0 0 0
	    0 0 1 0 0
	    0 0 0 N 0  (where N is between 0.0 and 1.0)
	</pre>
	
	<p><b>高速バージョン</b>。Intel<sup>®</sup> Pentium<sup>®</sup> 3 以降、Apple<sup>®</sup> G4 以降など、SSE/AltiVec アクセラレーター対応のプロセッサーでのみ使用できます。アクセラレーターは、乗数項の範囲が -15.99 ～ 15.99 で、加算項 [4]、a[9]、a[14]、および a[19] の範囲が -8000 ～ 8000 の場合に使用されます。</p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
 GradientGlowFilter クラスを使用すると、表示オブジェクトにグラデーショングロー効果を適用できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>グラデーショングロー効果を作成できます。
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 GradientGlowFilter クラスを使用すると、表示オブジェクトにグラデーショングロー効果を適用できます。グラデーショングローとは、制御可能なカラーグラデーションによるリアルな輝きです。グラデーショングローは、オブジェクトの内側エッジや外側エッジの周囲、またはオブジェクトの上に適用できます。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。
 
 <p>フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
 <ul><li>表示オブジェクトにフィルターを適用する場合は、<codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>
 
 <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
 </ul>
 
 <p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティは <codeph>true</codeph> に設定されます。すべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p> 
 
 <p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体を拡大 / 縮小する場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> の値が 1.0 以外に設定されている場合）、フィルター効果は拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>
 
 <p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>
 
 </apiDesc><example conref="examples\GradientGlowFilterExample.as"> 次の例では、四角形を描画してグラデーショングローフィルターを適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>必要なクラスを読み込みます。</li>
  <li>正方形とフィルターの定義に使用するグローバル変数を宣言します。</li>
  <li>コンストラクター関数を作成します。この関数は、次の処理を行います。
      <ul>
          <li><codeph>draw()</codeph> メソッドを呼び出し、Sprite の <codeph>graphics</codeph> プロパティを介してアクセスする Graphics クラスのメソッドを使用して四角形を描画します。</li>
          <li><codeph>filter</codeph> という名前の BitmapFilter オブジェクトを作成し、このオブジェクトに <codeph>getBitmapFilter()</codeph> の呼び出しによる戻り値を割り当てます。これでフィルターが作成されます。</li>
          <li><codeph>myFilters</codeph> という名前の新しい配列を作成し、それに <codeph>filter</codeph> を追加します。</li>
          <li><codeph>myFilters</codeph> を GradientGlowFilterExample オブジェクトの <codeph>filters</codeph> プロパティに割り当てます。これにより、<codeph>myFilters</codeph> で見つかったすべてのフィルターが適用されます。この場合は、<codeph>filter</codeph> だけです。</li>
      </ul>
  </li>
 </ol>
<codeblock>
package {
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientGlowFilter;
    import flash.display.Sprite;

    public class GradientGlowFilterExample extends Sprite {
        private var bgColor:uint = 0xCCCCCC;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        private var distance:Number  = 0;
        private var angleInDegrees:Number = 45;
        private var colors:Array     = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
        private var alphas:Array     = [0, 1, 1, 1];
        private var ratios:Array     = [0, 63, 126, 255];
        private var blurX:Number     = 50;
        private var blurY:Number     = 50;
        private var strength:Number  = 2.5;
        private var quality:Number   = BitmapFilterQuality.HIGH;
        private var type:String      = BitmapFilterType.OUTER;
        private var knockout:Boolean = false;

        public function GradientGlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientGlowFilter(distance,
                                          angleInDegrees,
                                          colors,
                                          alphas,
                                          ratios,
                                          blurX,
                                          blurY,
                                          strength,
                                          quality,
                                          type,
                                          knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter class</linktext></link></related-links><apiConstructor id="flash.filters:GradientGlowFilter:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
	指定されたパラメーターでフィルターを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a gradient glow filter, assigns 
	its values, and applies it to a flat rectangle image.
	
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var art:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	var distance:Number = 0;
	var angleInDegrees:Number = 45;
 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
 	var alphas:Array = [0, 1, 1, 1];
 	var ratios:Array = [0, 63, 126, 255];
	var blurX:Number = 50;
	var blurY:Number = 50;
	var strength:Number = 2.5;
	var quality:Number = 3;
	var type:String = "outer";
	var knockout:Boolean = false;
	
	var filter:GradientGlowFilter = new GradientGlowFilter(distance, 
														 angleInDegrees, 
														 colors, 
														 alphas, 
														 ratios, 
														 blurX, 
														 blurY, 
														 strength, 
														 quality, 
														 type, 
														 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	art.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
	mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>グローのオフセット距離です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>角度（度数）です。指定できる値は 0 ～ 360 です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>グラデーションを定義する色の配列です。例えば、赤は 0xFF0000、青は 0x0000FF などです。
	
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>colors</codeph> 配列内の各色に対応するアルファ透明度の値の配列です。配列の各エレメントに指定できる値は、0 ～ 1 です。例えば、.25 と指定すると、アルファ透明度は 25% になります。
	
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>色分布比率の配列です。指定できる値は 0 ～ 255 です。各値は、100% でサンプリングされる色の幅の割合をパーセントで定義します。
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、グローと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255 です。値が大きいほど、インプリントが濃くなります。値を 0 にすると、フィルターが適用されなくなります。
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>フィルターを適用する回数。BitmapFilterQuality 定数を使用します。
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>詳細については、<codeph>quality</codeph> プロパティの説明を参照してください。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>フィルター効果の配置です。指定できる値は、flash.filters.BitmapFilterType 定数です。
	<ul>
	<li><codeph>BitmapFilterType.OUTER</codeph> - グローがオブジェクトの外側エッジに配置されます。</li>
	<li><codeph>BitmapFilterType.INNER</codeph> - グローがオブジェクトの内側エッジに配置されます。これはデフォルトです。</li>
	<li><codeph>BitmapFilterType.FULL</codeph> - グローがオブジェクトの上に配置されます。</li>
	</ul>
	
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>オブジェクトにノックアウト効果を適用するかどうかを指定します。ノックアウト効果を適用すると、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。<codeph>true</codeph> を指定すると、ノックアウト効果が適用されます。デフォルトは <codeph>false</codeph> で、ノックアウト効果は適用されません。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	指定されたパラメーターでフィルターを初期化します。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:GradientGlowFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GradientGlowFilter objects and compares them; <code>filter_1</code>
	is created by using the GradientGlowFilter construtor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example below modifies the <code>knockout</code> property of <code>filter_1</code>. Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の GradientGlowFilter インスタンスとプロパティがすべて同じである新しい GradientGlowFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientGlowFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	カラー配列内の各色に対応するアルファ透明度の値の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alphas</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAlphas");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var alphas:Array = filter.alphas;
		alphas.pop();
		alphas.pop();
		alphas.push(.3);
		alphas.push(1);
		filter.alphas = alphas;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>アルファ透明度値の配列です。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<codeph>colors</codeph> 配列内の各色に対応するアルファ透明度の値の配列です。配列の各エレメントに指定できる値は、0 ～ 1 です。例えば、.25 を指定すると、アルファ透明度の値として 25% が設定されます。
	
	<p><codeph>alphas</codeph> プロパティの値を直接変更することはできません。このプロパティを変更するには、<codeph>alphas</codeph> への参照を取得し、その参照を変更した後、<codeph>alphas</codeph> をその参照に設定する必要があります。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph>、および <codeph>ratios</codeph> の 3 つのプロパティは関連しています。<codeph>colors</codeph> 配列の先頭のエレメントが <codeph>alphas</codeph> 配列と <codeph>ratios</codeph> 配列の先頭のエレメントに対応するなど、3 つの配列の同じインデックスのエレメントが互いに対応しています。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	角度（度数）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAngle");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 50;
		filter.angle = 90;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	角度（度数）です。指定できる値は 0 ～ 360 です。デフォルト値は 45 です。 
	
	<p>角度の値は、オブジェクトに対する架空の光源の角度を表し、オブジェクトに対する効果の相対位置を決定します。<codeph>distance</codeph> が 0 に設定されている場合、効果がオブジェクトからオフセットされないので、<codeph>angle</codeph> プロパティはオブジェクトに影響しません。</p>
        
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	 水平方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 水平方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	 垂直方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 垂直方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:colors:get"><apiName>colors</apiName><shortdesc>
	 グラデーションを定義する色の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>colors</code> property on an existing movie clip 
	 when a user clicks it.
	 <listing version="2.0">
	 import flash.filters.GradientGlowFilter;
	 var mc:MovieClip = createGradientGlowRectangle("GlowColors");
	 mc.onRelease = function() {
	 	var filter:GradientGlowFilter = this.filters[0];
	 	var colors:Array = filter.colors;
	 	colors.pop();
	 	colors.push(0xFF00FF);
	 	filter.colors = colors;
	 	this.filters = new Array(filter);
	 }
	 
	 function createGradientGlowRectangle(name:String):MovieClip {
	 	var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
	 	var w:Number = 100;
	 	var h:Number = 100;
	 	art.beginFill(0x003366);
	 	art.lineTo(w, 0);
	 	art.lineTo(w, h);
	 	art.lineTo(0, h);
	 	art.lineTo(0, 0);
	 	art._x = 20;
	 	art._y = 20;
	 
	 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	 	var alphas:Array = [0, 1, 1, 1];
	 	var ratios:Array = [0, 63, 126, 255];
	 	var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	 	var filterArray:Array = new Array();
	 	filterArray.push(filter);
	 	art.filters = filterArray;
	 	return art;
	 }
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 グラデーションを定義する色の配列です。例えば、赤は 0xFF0000、青は 0x0000FF などです。
	 
	 <p><codeph>colors</codeph> プロパティの値を直接変更することはできません。このプロパティを変更するには、<codeph>colors</codeph> への参照を取得し、その参照を変更した後、<codeph>colors</codeph> をその参照に設定する必要があります。</p>
	 
	 <p><codeph>colors</codeph>、<codeph>alphas</codeph>、および <codeph>ratios</codeph> の 3 つのプロパティは関連しています。<codeph>colors</codeph> 配列の先頭のエレメントが <codeph>alphas</codeph> 配列と <codeph>ratios</codeph> 配列の先頭のエレメントに対応するなど、3 つの配列の同じインデックスのエレメントが互いに対応しています。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	グローのオフセット距離です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowDistance");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 20;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	グローのオフセット距離です。デフォルト値は 4 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	オブジェクトにノックアウト効果を適用するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowKnockout");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}

	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトにノックアウト効果を適用するかどうかを指定します。ノックアウト効果を適用すると、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。<codeph>true</codeph> を指定すると、ノックアウト効果が適用されます。デフォルト値は <codeph>false</codeph> で、ノックアウト効果は適用されません。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	フィルターを適用する回数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowQuality");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.quality = 3;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	フィルターを適用する回数。デフォルト値は、フィルターを 1 回適用することに相当する <codeph>BitmapFilterQuality.LOW</codeph> です。値 <codeph>BitmapFilterQuality.MEDIUM</codeph> はフィルターを 2 回適用します。値 <codeph>BitmapFilterQuality.HIGH</codeph> はフィルターを 3 回適用します。フィルターに設定された値が小さいほど、速くレンダリングできます。
	
	<p>多くのアプリケーションでは、<codeph>quality</codeph> の値は低、中、または高で十分です。最大 15 までの値を使用してさまざまな効果を出すことができますが、値が大きくなるほどレンダリング速度が低下します。<codeph>quality</codeph> の値を増やす代わりに、<codeph>blurX</codeph> と <codeph>blurY</codeph> の値を増やすだけで、同様の効果が得られます。この方法を実行すると、より高速にレンダリングされます。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	カラー配列内の対応するカラーの色分布比率の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>ratios</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowRatios");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var ratios:Array = filter.ratios;
		ratios.shift();
		ratios.unshift(40);
		filter.ratios = ratios;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	<codeph>colors</codeph> 配列内の対応する色の色分布比率の配列です。指定できる値は 0 ～ 255 です。 
	
	<p><codeph>ratios</codeph> プロパティの値を直接変更することはできません。このプロパティを変更するには、<codeph>ratios</codeph> への参照を取得し、その参照を変更した後、<codeph>ratios</codeph> をその参照に設定する必要があります。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph>、および <codeph>ratios</codeph> の 3 つのプロパティは関連しています。<codeph>colors</codeph> 配列の先頭のエレメントが <codeph>alphas</codeph> 配列と <codeph>ratios</codeph> 配列の先頭のエレメントに対応するなど、3 つの配列の同じインデックスのエレメントが互いに対応しています。</p>
	
	<p>グラデーショングローフィルターは、オブジェクトの中心（<codeph>distance</codeph> が 0 に設定されている場合）から発せられる輝きであり、互いに混ざり合った色のストライプで構成されるグラデーションになります。<codeph>colors</codeph> 配列の先頭の色がグローの最も外側の色です。最後の色がグローの最も内側の色です。</p> 
	
	<p><codeph>ratios</codeph> 配列の各値は、その色のグラデーションの範囲における位置を表します。0 はグラデーションの最も外側の点を表し、255 はグラデーションの最も内側の点を表します。色分布比率の値は、0 ～ 255 ピクセルの範囲で指定できます。例えば、[0, 64, 128, 200, 255] のように値を増やしていきます。0 ～ 128 の値は、グローの外側のエッジに表示されます。129 ～ 255 の値は、グローの内側の領域に表示されます。色の分布比率の値とフィルターの <codeph>type</codeph> の値によっては、フィルターの適用先のオブジェクトによってフィルターの色が見えなくなることがあります。</p>
	
	<p>次のコードとイメージでは、フィルターを黒い円のムービークリップに適用し、そのタイプを <codeph>"full"</codeph> に設定しています。説明のため、<codeph>colors</codeph> 配列の先頭の色であるピンクの <codeph>alpha</codeph> 値を 1 にして、ドキュメントの白い背景の中で目立つようにしていますが、実際に先頭の色をこのように表示することはおそらくありません。配列の最後の色である黄色により、フィルターの適用先の黒い円が見えなくなっています。</p>
	
	<p><pre>
	var colors:Array = [0xFFCCFF, 0x0000FF, 0x9900FF, 0xFF0000, 0xFFFF00];
	var alphas:Array = [1, 1, 1, 1, 1];
	var ratios:Array = [0, 32, 64, 128, 225];
	var myGGF:GradientGlowFilter = new GradientGlowFilter(0, 0, colors, alphas, ratios, 50, 50, 1, 2, "full", false);
	</pre></p>
    <p><adobeimage alt="配列 0、32、64、128、225 のグラーデーショングローフィルター。" href="../../images/gradientGlowDiagram.jpg"/></p>
	
	<p><codeph>type</codeph> を <codeph>"outer"</codeph> または <codeph>"full"</codeph> に設定したときに、ドキュメントの背景と一体になった効果を得るには、配列の先頭の色をドキュメントの背景と同じに色に設定するか、先頭の色のアルファ値を 0 に設定します。どちらの方法を使用しても、フィルターが背景に溶け込みます。</p>
	
	<p>コードに小さな変更を 2 つ加えると、同じ <codeph>ratios</codeph> 配列と <codeph>colors</codeph> 配列でもグローの効果が大きく異なります。配列の先頭の色のアルファ値を 0 に設定してフィルターがドキュメントの白い背景に溶け込むようにし、<codeph>type</codeph> プロパティを <codeph>"outer"</codeph> または <codeph>"inner"</codeph> に設定します。次のイメージで結果を比較してください。</p>
        <p><adobeimage alt="外側のグロー" href="../../images/gradientGlowOuter.jpg"/> <adobeimage alt="内側のグロー" href="../../images/gradientGlowInner.jpg"/></p>
	<p>グラデーションの色の広がりは、<codeph>blurX</codeph>、<codeph>blurY</codeph>、<codeph>strength</codeph>、<codeph>quality</codeph> プロパティの値、および <codeph>ratios</codeph> 値に基づいて変化します。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	インプリントの強さまたは広がりです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowStrength");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、グローと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255 です。値を 0 にすると、フィルターが適用されなくなります。デフォルト値は 1 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:type:get"><apiName>type</apiName><shortdesc>
	フィルター効果の配置です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowType");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.type = "inner";
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>文字列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	フィルター効果の配置です。指定できる値は、flash.filters.BitmapFilterType 定数です。
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> - グローがオブジェクトの外側エッジに配置されます。</li>
	<li><codeph>BitmapFilterType.INNER</codeph> - グローがオブジェクトの内側エッジに配置されます。これはデフォルトです。</li>
	<li><codeph>BitmapFilterType.FULL</codeph> - グローがオブジェクトの上に配置されます。</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
DisplacementMapFilter クラスは、指定された BitmapData オブジェクト（置き換えマップイメージと言います）のピクセル値を使用して、オブジェクトの置き換え（変位）を実行します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>フィルターを適用する元のオブジェクトを変位させます。
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
DisplacementMapFilter クラスは、指定された BitmapData オブジェクト（<i>置き換えマップイメージ</i>と言います）のピクセル値を使用して、オブジェクトの置き換え（変位）を実行します。このフィルターを使用して、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承したオブジェクト、および BitmapData オブジェクトにワープ効果や斑点効果を適用できます。

<p>フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
<ul><li>表示オブジェクトにフィルターを適用する場合は、表示オブジェクトの <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>

<li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
</ul>

<p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティの値が <codeph>true</codeph> に設定されます。すべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>

<p>このフィルターでは次の式を使用します。</p>

<codeblock>
dstPixel[x, y] = srcPixel[x + ((componentX(x, y) - 128) ~~ scaleX) / 256, y + ((componentY(x, y) - 128) ~~scaleY) / 256)
</codeblock>

<p><codeph>componentX(x, y)</codeph> は、<codeph>componentX</codeph> プロパティのカラー値を <codeph>mapBitmap</codeph> プロパティ（<codeph>(x - mapPoint.x ,y - mapPoint.y)</codeph>）から取得します。</p>

<p>フィルターで使用するマップイメージは、ステージの拡大 / 縮小率に一致するように拡大 / 縮小されます。オブジェクト自体を拡大 / 縮小する場合には拡大 / 縮小されません。</p>

<p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体を拡大 / 縮小する場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> プロパティが 1.0 以外に設定されている場合）、フィルター効果は拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>

 </apiDesc><example conref="examples\DisplacementMapFilterExample.as"> 次の例では、放射状グラデーションの塗りの四角形の描画、テキストフィールドの作成、BitmapData オブジェクトの作成を行い、また置き換えマップフィルターを DisplacementMapFilterExample オブジェクトに適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>このクラスは背景色、テキストフィールドラベル、およびさまざまな関数で使用するサイズおよびオフセットの変数を定義します。</li>
  <li>コンストラクター関数は <codeph>draw()</codeph> メソッドを呼び出します。このメソッドは、Graphics クラスのメソッドを使用して放射状グラデーション塗りの四角形を描画します。<codeph>graphics</codeph> は、Sprite を拡張する DisplacementMapFilterExample オブジェクトのプロパティです。</li>
  <li>このコンストラクター関数は <codeph>createLabel()</codeph> メソッドを呼び出します。このメソッドは <codeph>labelText</codeph> の値を表示するテキストフィールドを作成して、表示リストに追加します。</li>
  <li>このコンストラクター関数は、<codeph>createFilter()</codeph> メソッドを呼び出します。このメソッドは以下の処理を行います。
      <ul>
          <li>フィルターオブジェクトの <codeph>filter</codeph> という名前の変数を作成します。</li>
          <li><codeph>getDisplacementMapFilter()</codeph> メソッドを呼び出し、その戻り値を <codeph>filter</codeph> 変数に割り当てます。</li>
          <li><codeph>filter</codeph> を DisplacementFilterExample（メインクラス）の <codeph>filters</codeph> プロパティに渡します。</li>
      </ul>
   </li> 
  <li><codeph>getBitmapFilter()</codeph> メソッドは <codeph>mapBitmap</codeph> という名前の BitmapData オブジェクトを作成し、このオブジェクトに <codeph>createBitmapData()</codeph> メソッドの結果を割り当てます。<codeph>mapBitmap</codeph> オブジェクトは、他の変数と共に、新しい置き換えマップフィルターを定義します。</li>
  <li><codeph>createBitmapData()</codeph> メソッドは、DisplacementMapFilterExample オブジェクトの現在の内容に基づいた新しい BitmapData オブジェクトを作成します。<codeph>bitmapData</codeph> に基づいた新しいビットマップを作成し、ステージに追加します。</li>
 </ol>
<codeblock>
package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.BitmapDataChannel;
    import flash.display.GradientType;
    import flash.display.SpreadMethod;
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.DisplacementMapFilter;
    import flash.filters.DisplacementMapFilterMode;
    import flash.geom.Matrix;
    import flash.geom.Point;
    import flash.text.TextField;
    
    public class DisplacementMapFilterExample extends Sprite {
        private var bgColor:uint     = 0xFFCC00;
        private var size:uint        = 200;
        private var offset:uint      = 90;
        private var labelText:String = "Watch the text bend with the displacement map";

        public function DisplacementMapFilterExample() {
            draw();
            createLabel();
            createFilter();
        }

        private function createFilter():void {
            var filter:BitmapFilter = getBitmapFilter();
            filters = new Array(filter);
        }

        private function getBitmapFilter():BitmapFilter {
            var mapBitmap:BitmapData = createBitmapData();
            var mapPoint:Point       = new Point(0, 0);
            var channels:uint        = BitmapDataChannel.RED;
            var componentX:uint      = channels;
            var componentY:uint      = channels;
            var scaleX:Number        = 0.5;
            var scaleY:Number        = -30;
            var mode:String          = DisplacementMapFilterMode.CLAMP;
            var color:uint           = 0;
            var alpha:Number         = 0;
            return new DisplacementMapFilter(mapBitmap,
                                             mapPoint,
                                             componentX,
                                             componentY,
                                             scaleX,
                                             scaleY,
                                             mode,
                                             color,
                                             alpha);
        }

        private function draw():void {
            var matrix:Matrix = new Matrix();
            matrix.createGradientBox(size, size);
            graphics.beginGradientFill(GradientType.RADIAL,
                                       [0xFF0000, 0x0000FF],
                                       [100, 100],
                                       [55, 200],
                                       matrix,
                                       SpreadMethod.PAD);
            graphics.drawRect(0, 0, size, size);
        }

        private function createBitmapData():BitmapData {
            var bitmapData:BitmapData = new BitmapData(size, size, true, bgColor);
            bitmapData.draw(this, new Matrix());
            var bitmap:Bitmap = new Bitmap(bitmapData);
            bitmap.x = size;
            addChild(bitmap);
            return bitmapData;
        }

        private function createLabel():void {
            var tf:TextField = new TextField();
            tf.text = labelText;
            tf.y = offset;
            tf.width = size;
            addChild(tf);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DisplacementMapFilter:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
	指定されたパラメーターで DisplacementMapFilter インスタンスを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Constructor
	 
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>mapBitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>置き換えマップデータが含まれる BitmapData オブジェクトです。
	</apiDesc></apiParam><apiParam><apiItemName>mapPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>マップイメージの左上隅を基準としたターゲット表示オブジェクトの左上隅のオフセットが含まれる値です。
	</apiDesc></apiParam><apiParam><apiItemName>componentX</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc><i>x</i> の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。指定できる値は、BitmapDataChannel 定数です。 
	</apiDesc></apiParam><apiParam><apiItemName>componentY</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc><i>y</i> の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。指定できる値は、BitmapDataChannel 定数です。 
	</apiDesc></apiParam><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>マップ計算の <i>x</i> 置き換え結果を拡大 / 縮小する場合に使用する乗数です。
	</apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>マップ計算の <i>y</i> 置き換え結果を拡大 / 縮小する場合に使用する乗数です。
	</apiDesc></apiParam><apiParam><apiItemName>mode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>wrap</apiData><apiDesc>フィルターのモードです。指定できる値は、DisplacementMapFilterMode 定数です。
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>範囲外置き換えの場合に使用する色を指定します。置き換えの有効範囲は 0.0 ～ 1.0 です。このパラメーターは、<codeph>mode</codeph> を <codeph>DisplacementMapFilterMode.COLOR</codeph> に設定する場合に使用します。
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>範囲外置き換えの場合に使用するアルファ値を指定します。0.0 ～ 1.0 に正規化した値を指定します。例えば、.25 を指定すると、透明度の値として 25% が設定されます。このパラメーターは、<codeph>mode</codeph> を <codeph>DisplacementMapFilterMode.COLOR</codeph> に設定する場合に使用します。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>DisplacementMapFilter インスタンスを初期化します。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	指定されたパラメーターで DisplacementMapFilter インスタンスを初期化します。
	
   	</apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DisplacementMapFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>DisplacementMapFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>DisplacementMapFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}		
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>mode</code> property of <code>filter_1</code>.  Modifying <code>mode</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1.mode);			// wrap
	trace(filter_2.mode);			// wrap
	trace(clonedFilter.mode);		// wrap
		
	filter_1.mode = "ignore";
	
	trace(filter_1.mode);			// ignore
	trace(filter_2.mode);			// ignore
	trace(clonedFilter.mode);		// wrap
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元のインスタンスと同じプロパティをすべて備えた新しい DisplacementMapFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DisplacementMapFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	範囲外置き換えの場合に使用するアルファ透明度値を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>alpha</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	範囲外置き換えの場合に使用するアルファ透明度値を指定します。0.0 ～ 1.0 に正規化した値を指定します。例えば、.25 を指定すると、透明度の値として 25% が設定されます。デフォルト値は 0 です。<codeph>mode</codeph> プロパティが <codeph>DisplacementMapFilterMode.COLOR</codeph> に設定されている場合は、このプロパティを使用します。  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:color:get"><apiName>color</apiName><shortdesc>
	範囲外置き換えの場合に使用する色を指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>color</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		filter.color = 0x00FF00;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	範囲外置き換えの場合に使用する色を指定します。置き換えの有効範囲は 0.0 ～ 1.0 です。この値は、16 進数形式です。<codeph>color</codeph> のデフォルト値は 0 です。<codeph>mode</codeph> プロパティが <codeph>DisplacementMapFilterMode.COLOR</codeph> に設定されている場合は、このプロパティを使用します。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentX:get"><apiName>componentX</apiName><shortdesc>
	x の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.  It changes the value from 1 to 4 which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentX = 4;
		this.filters = new Array(filter);
	}
	
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>x の結果を変位させる場合に使用するカラーチャンネルです。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<i>x</i> の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。指定できる値は、BitmapDataChannel 定数です。
	<ul>
		<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	<li><codeph>BitmapDataChannel.BLUE</codeph></li>
	<li><codeph>BitmapDataChannel.GREEN</codeph></li>
	<li><codeph>BitmapDataChannel.RED</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentY:get"><apiName>componentY</apiName><shortdesc>
	 y の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks it.  The value changes from 1 to 4, which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentY = 4;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 <i>y</i> の結果を変位させる場合にどのカラーチャンネルをマップイメージで使用するかを指定します。指定できる値は、BitmapDataChannel 定数です。
	 <ul>
	 	<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
         </ul>
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapBitmap:get"><apiName>mapBitmap</apiName><shortdesc>
	置き換えマップデータが含まれる BitmapData オブジェクトです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapBitmap</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	var scope:Object = this;
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapBitmap = scope.createGradientBitmap(300, 80, 0xFF000000, "linear");
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	
	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier><apiException><apiDesc>BitmapData は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	置き換えマップデータが含まれる BitmapData オブジェクトです。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapPoint:get"><apiName>mapPoint</apiName><shortdesc>
	マップイメージの左上隅を基準としたターゲット表示オブジェクトの左上隅のオフセットが含まれる値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapPoint</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapPoint = new Point(-30, -40);
		this.filters = new Array(filter);
		this._x = 30;
		this._y = 40;
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Point は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	マップイメージの左上隅を基準としたターゲット表示オブジェクトの左上隅のオフセットが含まれる値です。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mode:get"><apiName>mode</apiName><shortdesc>
	フィルターのモードです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example modifies <code>scaleY</code> inorder to create a displacement
	value that is out of range and then changes the <code>mode</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>ignore</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "ignore";
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	</oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>文字列は、設定時に null に設定されます。
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>モードストリングは有効ではありません。
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	フィルターのモードです。指定できる値は、DisplacementMapFilterMode 定数です。
	<ul>
	<li><codeph>DisplacementMapFilterMode.WRAP</codeph> - 置き換え値をソースイメージの反対側で折り返します。</li>
	<li><codeph>DisplacementMapFilterMode.CLAMP</codeph> - 置き換え値をソースイメージのエッジに固定します。</li>
	<li><codeph>DisplacementMapFilterMode.IGNORE</codeph> - 置き換え値が範囲外である場合、その置き換えを無視して、ソースピクセルを使用します。</li>
	<li><codeph>DisplacementMapFilterMode.COLOR</codeph> - 置き換え値がイメージの外にある場合、<codeph>color</codeph> プロパティと <codeph>alpha</codeph> プロパティの値を置き換えます。</li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleX:get"><apiName>scaleX</apiName><shortdesc>
	マップ計算の x 置き換え結果を拡大 / 縮小する場合に使用する乗数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleX = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	マップ計算の <i>x</i> 置き換え結果を拡大 / 縮小する場合に使用する乗数です。
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleY:get"><apiName>scaleY</apiName><shortdesc>
	マップ計算の y 置き換え結果を拡大 / 縮小する場合に使用する乗数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	マップ計算の <i>y</i> 置き換え結果を拡大 / 縮小する場合に使用する乗数です。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterType"><apiName>BitmapFilterType</apiName><shortdesc>
BitmapFilterType クラスには、BitmapFilter の型を設定する値が含まれます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
BitmapFilterType クラスには、BitmapFilter の型を設定する値が含まれます。

</apiDesc><example conref="examples\BitmapFilterTypeExample.as"> 次の例では、灰色の四角形を描画し、これに BevelFilter オブジェクトを適用します。この例では、<codeph>type</codeph> プロパティが定数 <codeph>BitmapFilterType.HIGH</codeph> を使用して設定されます。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterTypeExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterTypeExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterType:FULL"><apiName>FULL</apiName><shortdesc>
	オブジェクトの領域全体にフィルターを適用する設定を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトの領域全体にフィルターを適用する設定を定義します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:INNER"><apiName>INNER</apiName><shortdesc>
	オブジェクトの内側の領域にフィルターを適用する設定を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>inner</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトの内側の領域にフィルターを適用する設定を定義します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:OUTER"><apiName>OUTER</apiName><shortdesc>
	オブジェクトの外側の領域にフィルターを適用する設定を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>outer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトの外側の領域にフィルターを適用する設定を定義します。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
DropShadowFilter クラスは、ドロップシャドウを表示オブジェクトに追加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
DropShadowFilter クラスは、ドロップシャドウを表示オブジェクトに追加します。シャドウアルゴリズムは、ぼかしフィルターで使用するのと同じボックスフィルターに基づいています。ドロップシャドウのスタイルには複数のオプションがあり、内側シャドウ、外側シャドウ、ノックアウトモードなどがあります。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。

<p>フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
 <ul><li>表示オブジェクトにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>
 
 <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
 </ul>

<p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティの値が <codeph>true</codeph> に設定されます。すべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>
 <p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体が拡大 / 縮小される場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> プロパティの値が 1.0 以外に設定されている場合）、フィルターは拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>
 
 <p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>

</apiDesc><example conref="examples\DropShadowFilterExample.as"> 次の例では、黄色の四角形を作成してドロップシャドウを適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>フィルターを適用する四角形の描画に使用する 3 つのプロパティを宣言します。</li>
  <li>コンストラクター関数を作成します。コンストラクターは <codeph>draw()</codeph> メソッドを呼び出します。このメソッドでは、Sprite の <codeph>graphics</codeph> プロパティを介してアクセスする Graphics クラスのメソッドを使用して、オレンジ色の四角形を描画します。</li>
  <li>このコンストラクターでは、変数 <codeph>filter</codeph> を BitmapFilter オブジェクトとして宣言し、これを <codeph>getBitmapFilter()</codeph> を呼び出した戻り値に割り当てます。<codeph>getBitmapFilter()</codeph> メソッドでは、使用するドロップシャドウフィルターを定義します。</li>
  <li>新しい配列オブジェクト <codeph>myFilters</codeph> を作成し、<codeph>filter</codeph> を配列に追加します。<codeph>myFilters</codeph> 配列を DropShadowFilterExample オブジェクトの <codeph>filters</codeph> プロパティに割り当てます。これにより、<codeph>myFilters</codeph> で見つかったすべてのフィルターが適用されます。この場合は、<codeph>filter</codeph> だけです。</li>
  </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.DropShadowFilter;

    public class DropShadowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function DropShadowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x000000;
            var angle:Number = 45;
            var alpha:Number = 0.8;
            var blurX:Number = 8;
            var blurY:Number = 8;
            var distance:Number = 15;
            var strength:Number = 0.65;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;
            return new DropShadowFilter(distance,
                                        angle,
                                        color,
                                        alpha,
                                        blurX,
                                        blurY,
                                        strength,
                                        quality,
                                        inner,
                                        knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DropShadowFilter:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
	指定されたパラメーターで新しい DropShadowFilter インスタンスを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new DropShadowFilter object
	with the default values:
	<pre>
	myFilter = new flash.filters.DropShadowFilter()
	</pre>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>シャドウのオフセット距離（ピクセル単位）です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>0 ～ 360 度で表されるシャドウの角度（浮動小数）です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>シャドウのカラーです。16 進数形式（<i>0xRRGGBB</i>）で指定します。デフォルト値は 0x000000 です。
	
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>シャドウカラーのアルファ透明度値です。0.0 ～ 1.0 の値を指定できます。例えば .25 と指定すると、透明度は 25% になります。 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平方向のぼかし量。指定できる値は 0 ～ 255.0（浮動小数）です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直方向のぼかし量。指定できる値は 0 ～ 255.0（浮動小数）です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、シャドウと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255.0 です。 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>フィルターを適用する回数。BitmapFilterQuality 定数を使用します。
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>これらの値については、<codeph>quality</codeph> プロパティの説明を参照してください。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>シャドウが内側のシャドウであるかどうかを指定します。<codeph>true</codeph> の場合は、内側シャドウを示します。値 <codeph>false</codeph> は外側シャドウ（オブジェクトの外側のエッジにあるシャドウ）を示します。
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><codeph>true</codeph> の場合は、ノックアウト効果を適用します。その結果、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。 
	
	</apiDesc></apiParam><apiParam><apiItemName>hideObject</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>オブジェクトが非表示であるかどうかを示します。<codeph>true</codeph> を指定すると、オブジェクト自体は描画されず、シャドウだけが表示されます。 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	指定されたパラメーターで新しい DropShadowFilter インスタンスを作成します。
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DropShadowFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three DropShadowFilter objects and compares them.  <code>filter_1</code>
	is created using the DropShadowFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の DropShadowFilter インスタンスのプロパティをすべて備えた新しい DropShadowFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DropShadowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	シャドウカラーのアルファ透明度の値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAlpha");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	シャドウカラーのアルファ透明度の値です。0.0 ～ 1.0 の値を指定できます。例えば .25 と指定すると、透明度は 25% になります。デフォルト値は 1.0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	シャドウの角度です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAngle");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.angle = 135;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	シャドウの角度です。指定できる値は 0 ～ 360 度（浮動小数）です。デフォルト値は 45 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurX");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurX = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平方向のぼかし量。指定できる値は 0 ～ 255.0（浮動小数）です。デフォルト値は 4.0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurY");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurY = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直方向のぼかし量。指定できる値は 0 ～ 255.0（浮動小数）です。デフォルト値は 4.0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:color:get"><apiName>color</apiName><shortdesc>
	シャドウのカラーです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowColor");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.color = 0xFF0000;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	シャドウのカラーです。指定できる値は、16 進数形式（<i>0xRRGGBB</i>）です。デフォルト値は 0x000000 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	シャドウのオフセット距離（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowDistance");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.distance = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	シャドウのオフセット距離（ピクセル単位）です。デフォルト値は 4.0（浮動小数）です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:hideObject:get"><apiName>hideObject</apiName><shortdesc>
	オブジェクトが非表示であるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>hideObject</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowHideObject");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.hideObject = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトが非表示であるかどうかを示します。<codeph>true</codeph> を指定すると、オブジェクト自体は描画されず、シャドウだけが表示されます。デフォルトは <codeph>false</codeph> で、オブジェクトが表示されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	シャドウが内側のシャドウであるかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowInner");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	シャドウが内側のシャドウであるかどうかを指定します。<codeph>true</codeph> の場合は、内側シャドウであることを示します。デフォルトは <codeph>false</codeph>（外側シャドウ）で、オブジェクトの外周にあるシャドウを示します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	true の場合は、ノックアウト効果を適用します。その結果、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowKnockout");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	<codeph>true</codeph> の場合は、ノックアウト効果を適用します。その結果、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。デフォルトは <codeph>false</codeph>（ノックアウトなし）です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	 フィルターを適用する回数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowQuality");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.quality = 0;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 フィルターを適用する回数。デフォルト値は、フィルターを 1 回適用することに相当する <codeph>BitmapFilterQuality.LOW</codeph> です。値 <codeph>BitmapFilterQuality.MEDIUM</codeph> はフィルターを 2 回適用します。値 <codeph>BitmapFilterQuality.HIGH</codeph> はフィルターを 3 回適用します。フィルターに設定された値が小さいほど、速くレンダリングできます。
	 
	 <p>多くのアプリケーションでは、quality の値は低、中、または高で十分です。最大 15 までの値を使用してさまざまな効果を出すことができますが、値が大きくなるほどレンダリング速度が低下します。<codeph>quality</codeph> の値を増やす代わりに、<codeph>blurX</codeph> と <codeph>blurY</codeph> の値を増やすだけで、同様の効果が得られます。この方法を実行すると、より高速にレンダリングされます。</p>
         </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:DropShadowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	インプリントの強さまたは広がりです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowStrength");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.strength = .6;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、シャドウと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255.0 で、デフォルトは 1.0 です。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterQuality"><apiName>BitmapFilterQuality</apiName><shortdesc>
BitmapFilterQuality クラスには、BitmapFilter オブジェクトのレンダリング品質を設定する値が含まれます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
BitmapFilterQuality クラスには、BitmapFilter オブジェクトのレンダリング品質を設定する値が含まれます。

</apiDesc><example conref="examples\BitmapFilterQualityExample.as"> 次の例では、灰色の四角形を描画し、これに BevelFilter オブジェクトを適用します。この例では、<codeph>quality</codeph> プロパティが定数 <codeph>BitmapFilterQuality.HIGH</codeph> を使用して設定されます。
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterQualityExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterQualityExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>BlurFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>DropShadowFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
	高品質のフィルター設定を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	高品質のフィルター設定を定義します。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:LOW"><apiName>LOW</apiName><shortdesc>
	低品質のフィルター設定を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	低品質のフィルター設定を定義します。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
	標準品質のフィルター設定を定義します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	標準品質のフィルター設定を定義します。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilterMode"><apiName>DisplacementMapFilterMode</apiName><shortdesc>
DisplacementMapFilterMode クラスは DisplacementMapFilter クラスの mode プロパティの値を提供します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
DisplacementMapFilterMode クラスは DisplacementMapFilter クラスの <codeph>mode</codeph> プロパティの値を提供します。

</apiDesc></apiClassifierDetail><apiValue id="flash.filters:DisplacementMapFilterMode:CLAMP"><apiName>CLAMP</apiName><shortdesc>
	置き換え値をソースイメージのエッジに固定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clamp</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	置き換え値をソースイメージのエッジに固定します。<codeph>DisplacementMapFilter.mode</codeph> プロパティと一緒に使用します。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:COLOR"><apiName>COLOR</apiName><shortdesc>
	置き換え値がイメージの外にある場合、color プロパティと alpha プロパティの値を置き換えます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>color</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	置き換え値がイメージの外にある場合、<codeph>color</codeph> プロパティと <codeph>alpha</codeph> プロパティの値を置き換えます。<codeph>DisplacementMapFilter.mode</codeph> プロパティと一緒に使用します。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:IGNORE"><apiName>IGNORE</apiName><shortdesc>
	置き換え値が範囲外である場合、その置き換えを無視して、ソースピクセルを使用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ignore</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	置き換え値が範囲外である場合、その置き換えを無視して、ソースピクセルを使用します。<codeph>DisplacementMapFilter.mode</codeph> プロパティと一緒に使用します。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:WRAP"><apiName>WRAP</apiName><shortdesc>
	置き換え値をソースイメージの反対側で折り返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>wrap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	置き換え値をソースイメージの反対側で折り返します。<codeph>DisplacementMapFilter.mode</codeph> プロパティと一緒に使用します。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.filters:BevelFilter"><apiName>BevelFilter</apiName><shortdesc> 
 BevelFilter クラスを使用すると、表示オブジェクトにベベル効果を追加できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>ベベル効果を追加します。 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc> 
 BevelFilter クラスを使用すると、表示オブジェクトにベベル効果を追加できます。ボタンなどのオブジェクトにベベル効果を適用すると 3 次元的に表現されます。異なるハイライトカラー、シャドウカラー、ベベルのぼかし量、ベベルの角度、ベベルの配置、ノックアウト効果を使用して、ベベルの外観をカスタマイズできます。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。
 
 <p>新しいフィルターを作成するには、コンストラクター <codeph>new BevelFilter()</codeph> を使用します。フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
 <ul><li>ムービークリップ、テキストフィールド、ボタン、およびビデオにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>
 
 <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
 </ul>
 
 <p>表示オブジェクトにフィルターを適用すると、オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティの値が <codeph>true</codeph> に設定されます。すべてのフィルターを削除すると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>
 
 <p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体が拡大 / 縮小される場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> プロパティが 100% に設定されていない場合）、フィルターは拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>
 
 <p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>
 
 </apiDesc><example conref="examples\BevelFilterExample.as"> 次の例では、暗い黄色の四角形を作成し、明るい黄色（0xFFFF00）のハイライトと青（0x0000FF）のシャドウでベベルを適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>必要なクラスを読み込みます。</li>   
  <li><codeph>draw()</codeph> 関数で使用する 3 つのプロパティを宣言します。この関数は、ベベルフィルターを適用するオブジェクトを描画します。</li>
  <li><codeph>BevelFilterExample()</codeph> コンストラクター関数を作成します。この関数は、次の処理を行います。
      <ul>
          <li><codeph>draw()</codeph> 関数を呼び出します。この関数は後で宣言されます。</li>
          <li><codeph>filter</codeph> 変数を BitmapFilter オブジェクトとして宣言し、これを <codeph>getBitmapFilter()</codeph> を呼び出した戻り値に割り当てます。</li>
          <li>新しい配列オブジェクト <codeph>myFilters</codeph> を作成し、その配列に <codeph>filter</codeph> を追加します。さらに <codeph>myFilters</codeph> を BevelFilterExample オブジェクトの <codeph>filters</codeph> プロパティに割り当てます。これにより、<codeph>myFilters</codeph> で見つかったすべてのフィルターが適用されます。この場合は、<codeph>filter</codeph> だけです。</li>      
      </ul>
 </li>
  <li><codeph>getBitmapFilter</codeph> 関数を作成して、フィルターのプロパティを作成して設定します。</li>
  <li><codeph>draw()</codeph> 関数を作成します。この関数は、Sprite クラスの <codeph>graphics</codeph> プロパティを介してアクセスする Graphics クラスのメソッドを使用して、四角形を描画します。</li>
  
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BevelFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xFFFF00;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x0000FF;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BevelFilter:BevelFilter"><apiName>BevelFilter</apiName><shortdesc>
	指定されたパラメーターで新しい BevelFilter インスタンスを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following code creates a new BevelFilter instance. The values given 
	are the default values; you could call the constructor without any values and get the same result.
	<listing> filter = new flash.filters.BevelFilter (4, 45, 0xFFFFFF, 1, 0x000000, 1, 4, 4, 1, 
	1, "inner", false) 
	</listing>
	The next example instantiates a new BevelFilter and applies it to the MovieClip <code>rect</code>.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var distance:Number = 5;
	var angleInDegrees:Number = 45;
	var highlightColor:uint = 0xFFFF00;
	var highlightAlpha:Number = .8;
	var shadowColor:uint = 0x0000FF;
	var shadowAlpha:Number = .8;
	var blurX:Number = 20;
	var blurY:Number = 20;
	var strength:Number = 1;
	var quality:int = 3;
	var type:String = "inner";
	var knockout:Boolean = false;
	
	var filter:BevelFilter = new BevelFilter(distance, angleInDegrees, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout);
	
	var rect:MovieClip = createRectangle(100, 100, 0x00CC00, "bevelFilterExample");
	rect.filters = new Array(filter);
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>ベベルのオフセット距離（ピクセル単位）です（浮動小数）。 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>ベベルの角度（0 ～ 360 度）です。 
	</apiDesc></apiParam><apiParam><apiItemName>highlightColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFF</apiData><apiDesc>ベベルのハイライトカラー <i>0xRRGGBB</i> です。 
	</apiDesc></apiParam><apiParam><apiItemName>highlightAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>ハイライトカラーのアルファ透明度の値です。0.0 ～ 1.0 の値を指定できます。例えば .25 と指定すると、透明度は 25% になります。 
	</apiDesc></apiParam><apiParam><apiItemName>shadowColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0x000000</apiData><apiDesc>ベベルのシャドウカラー <i>0xRRGGBB</i> です。 
	</apiDesc></apiParam><apiParam><apiItemName>shadowAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>シャドウカラーのアルファ透明度の値です。0.0 ～ 1.0 の値を指定できます。例えば .25 と指定すると、透明度は 25% になります。 
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平方向のぼかし量（ピクセル単位）です。指定できる値は 0 ～ 255.0（浮動小数）です。 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直方向のぼかし量（ピクセル単位）です。指定できる値は 0 ～ 255.0（浮動小数）です。
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、ベベルと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255.0 です。 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>ベベルの品質です。指定できる値は 0 ～ 15 ですが、多くのアプリケーションでは <codeph>BitmapFilterQuality</codeph> 定数を使用できます。
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>フィルターに設定された値が小さいほど、速くレンダリングできます。指定できる他の数値を使用すると、異なる効果を作り出すことができます。</p>

	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>ベベルの種類です。指定できる値は、次の <codeph>BitmapFilterType</codeph> 定数です。<codeph>BitmapFilterType.INNER</codeph>、<codeph>BitmapFilterType.OUTER</codeph>、または <codeph>BitmapFilterType.FULL</codeph>。 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><codeph>true</codeph> の場合は、ノックアウト効果を適用します。その結果、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	指定されたパラメーターで新しい BevelFilter インスタンスを初期化します。
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#BitmapFilterType"><linktext>BitmapFilterType</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:BevelFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BevelFilter objects and compares them.  <code>filter_1</code>
	is created using the BevelFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
	 	// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
		// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の BevelFilter インスタンスとプロパティがすべて同じである新しい BevelFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	ベベルの角度です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.angle = 225;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	ベベルの角度です。有効な値の範囲は 0 ～ 360°です。デフォルト値は 45° です。
	
	<p>角度の値は、オブジェクトに対する架空の光源の角度を表し、オブジェクトに対する効果の相対位置を決定します。<codeph>distance</codeph> プロパティが 0 に設定された場合、効果がオブジェクトからオフセットされないため、<codeph>angle</codeph> プロパティは適用されません。</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平方向のぼかし量（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurX");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurX = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平方向のぼかし量（ピクセル単位）です。指定できる値は 0 ～ 255（浮動小数）です。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直方向のぼかし量（ピクセル単位）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurY");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurY = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直方向のぼかし量（ピクセル単位）です。指定できる値は 0 ～ 255（浮動小数）です。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	ベベルのオフセット距離です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.distance = 3;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	ベベルのオフセット距離です。この値はピクセル単位で指定します（浮動小数値）。デフォルト値は 4 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightAlpha:get"><apiName>highlightAlpha</apiName><shortdesc>
	ハイライトカラーのアルファ透明度の値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	ハイライトカラーのアルファ透明度の値です。値には、0 ～ 1 の正規化した値を指定します。例えば、.25 を指定すると、透明度の値として 25% が設定されます。デフォルト値は 1 です。
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightColor:get"><apiName>highlightColor</apiName><shortdesc>
	ベベルのハイライトカラーです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightColor = 0x0000FF;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	ベベルのハイライトカラーです。指定できる値は、16 進数形式（<i>0xRRGGBB</i>）です。デフォルト値は 0xFFFFFF です。
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
    true の場合は、ノックアウト効果を適用します。その結果、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelKnockout");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    <codeph>true</codeph> の場合は、ノックアウト効果を適用します。その結果、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。デフォルト値は <codeph>false</codeph>（ノックアウトなし）です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	フィルターを適用する回数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelQuality");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	フィルターを適用する回数。デフォルト値は、フィルターを 1 回適用することに相当する <codeph>BitmapFilterQuality.LOW</codeph> です。値 <codeph>BitmapFilterQuality.MEDIUM</codeph> はフィルターを 2 回適用します。値 <codeph>BitmapFilterQuality.HIGH</codeph> はフィルターを 3 回適用します。フィルターに設定された値が小さいほど、速くレンダリングできます。
	
	<p>多くのアプリケーションでは、<codeph>quality</codeph> の値は低、中、または高で十分です。最大 15 までの値を使用してさまざまな効果を出すことができますが、値が大きくなるほどレンダリング速度が低下します。<codeph>quality</codeph> の値を増やす代わりに、<codeph>blurX</codeph> と <codeph>blurY</codeph> の値を増やすだけで、同様の効果が得られます。この方法を実行すると、より高速にレンダリングされます。</p>
	
	<p>次の <codeph>BitmapFilterQuality</codeph> 定数を使用して、<codeph>quality</codeph> プロパティの値を指定できます。
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowAlpha:get"><apiName>shadowAlpha</apiName><shortdesc>
	シャドウカラーのアルファ透明度の値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	シャドウカラーのアルファ透明度の値です。値には、0 ～ 1 の正規化した値を指定します。例えば、.25 を指定すると、透明度の値として 25% が設定されます。デフォルト値は 1 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowColor:get"><apiName>shadowColor</apiName><shortdesc>
	ベベルのシャドウカラーです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowColor = 0xFFFF00;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	ベベルのシャドウカラーです。指定できる値は、16 進数形式（<i>0xRRGGBB</i>）です。デフォルト値は 0x000000 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	インプリントの強さまたは広がりです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelStrength");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.strength = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	インプリントの強さまたは広がりです。有効な値の範囲は 0 ～ 255 です。値が大きいほど、濃い色がインプリントされるので、ベベルと背景との間のコントラストが強くなります。デフォルト値は 1 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:type:get"><apiName>type</apiName><shortdesc>
	オブジェクトでのベベルの配置です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelType");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.type = "outer";
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>文字列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	オブジェクトでのベベルの配置です。内側および外側のベベルは、内側または外側のエッジに配置され、フルベベルはオブジェクト全体に配置されます。指定できる値は、次の <codeph>BitmapFilterType</codeph> 定数です。
	
	<ul>
	<li><codeph>BitmapFilterType.INNER</codeph></li>
	<li><codeph>BitmapFilterType.OUTER</codeph></li>
	<li><codeph>BitmapFilterType.FULL</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilter"><apiName>BitmapFilter</apiName><shortdesc>
 BitmapFilter クラスは、すべてのイメージフィルター効果の基本クラスです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>すべてのイメージフィルター効果用の基本クラスです。
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 BitmapFilter クラスは、すべてのイメージフィルター効果の基本クラスです。 
 
 <p>BevelFilter、BlurFilter、ColorMatrixFilter、ConvolutionFilter、DisplacementMapFilter、DropShadowFilter、GlowFilter、GradientBevelFilter、および GradientGlowFilter クラスはすべて、BitmapFilter クラスを継承します。このフィルター効果は、あらゆる表示オブジェクトに適用できます。</p>
 
 <p>BitmapFilter を直接インスタンス化または拡張することはできません。</p>
 
 </apiDesc><example conref="examples\BitmapFilterExample.as"> 次の例では、<codeph>filters</codeph> プロパティを使用して、指定した DisplayObject オブジェクトに複数のフィルターを適用して追跡する方法を示します。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.*;

    public class BitmapFilterExample extends Sprite {
        public function BitmapFilterExample() {
            trace(this.filters.length);             // 0

            var tmpFilters:Array = this.filters;
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.BEVEL_FILTER));
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.GLOW_FILTER));
            this.filters = tmpFilters;

            trace(this.filters.length);             // 2
            trace(this.filters[0] is BitmapFilter); // true
            trace(this.filters[0] is BevelFilter);  // true
            trace(this.filters[1] is BitmapFilter); // true
            trace(this.filters[1] is GlowFilter);   // true
        }
    }
}

import flash.filters.*;
class FilterFactory {
    public static var BEVEL_FILTER:String = "BevelFilter";
    public static var BevelFilterConstructor:Class = BevelFilter;

    public static var BLUR_FILTER:String = "BlurFilter";
    public static var BlurFilterConstructor:Class = BlurFilter;

    public static var COLOR_MATRIX_FILTER:String = "ColorMatrixFilter";
    public static var ColorMatrixFilterConstructor:Class = ColorMatrixFilter;

    public static var CONVOLUTION_FILTER:String = "ConvolutionFilter";
    public static var ConvolutionFilterConstructor:Class = ConvolutionFilter;

    public static var DISPLACEMENT_MAP_FILTER:String = "DisplacementMapFilter";
    public static var DisplacementMapFilterConstructor:Class = DisplacementMapFilter;

    public static var DROP_SHADOW_FILTER:String = "DropShadowFilter";
    public static var DropShadowFilterConstructor:Class = DropShadowFilter;

    public static var GLOW_FILTER:String = "GlowFilter";
    public static var GlowFilterConstructor:Class = GlowFilter;

    public static var GRADIENT_BEVEL_FILTER:String = "GradientBevelFilter";
    public static var GradientBevelFilterConstructor:Class = GradientBevelFilter;

    public static var GRADIENT_GLOW_FILTER:String = "GradientGlowFilter";
    public static var GradientGlowFilterConstructor:Class = GradientGlowFilter;

    public static function createFilter(type:String):BitmapFilter {
        return new FilterFactory[type + "Constructor"]();   
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.filters:BitmapFilter:clone"><apiName>clone</apiName><shortdesc>
	 元の BitmapFilter オブジェクトとまったく同じコピーである BitmapFilter オブジェクトを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>BitmapFilter オブジェクトです。
	 
	 </apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>BitmapFilter オブジェクトのコピーです。
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 元の BitmapFilter オブジェクトとまったく同じコピーである BitmapFilter オブジェクトを返します。
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.filters:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
 BlurFilter クラスを使用すると、表示オブジェクトにぼかし効果を適用できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>ぼかし効果です。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 BlurFilter クラスを使用すると、表示オブジェクトにぼかし効果を適用できます。ぼかし効果は、イメージの細部をぼかします。ソフトフォーカスがかかっているように見えるぼかしから、半透明ガラスを通してイメージを見るようにかすんで見えるガウスぼかしまで作成できます。このフィルターの <codeph>quality</codeph> プロパティを低く設定すると、ソフトフォーカスがかかっているように見えるぼかしになります。<codeph>quality</codeph> プロパティを高く設定すると、ガウスぼかしフィルターに似たものになります。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。
 
 <p>新しいフィルターを作成するには、コンストラクター <codeph>new BlurFilter()</codeph> を使用します。フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
 <ul><li>ムービークリップ、テキストフィールド、ボタン、およびビデオにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>
 
 <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
 </ul>
 
 <p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティは <codeph>true</codeph> に設定されます。すべてのフィルターを削除すると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>
 
 <p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体が拡大 / 縮小される場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> が 100% に設定されていない場合）、フィルター効果は拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>
 
 <p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>
 
 </apiDesc><example conref="examples\BlurFilterExample.as"> 次の例では、暗い黄色の四角形を作成し、ガウスぼかしフィルターをその四角形に適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>必要なクラスを読み込みます。</li>   
  <li><codeph>draw()</codeph> 関数で使用する 3 つのプロパティを宣言します。この関数は、ぼかしフィルターを適用するオブジェクトを描画します。 </li>
  <li><codeph>BlurFilterExample()</codeph> コンストラクター関数を作成します。この関数は、次の処理を行います。
      <ul>
          <li><codeph>draw()</codeph> 関数を呼び出します。この関数は後で宣言されます。</li>
          <li><codeph>filter</codeph> 変数を BitmapFilter オブジェクトとして宣言し、これを <codeph>getBitmapFilter()</codeph> を呼び出した戻り値に割り当てます。</li>
          <li>新しい配列オブジェクト <codeph>myFilters</codeph> を作成し、配列に <codeph>filter</codeph> を追加します。さらに <codeph>myFilters</codeph> を BlurFilterExample オブジェクトの <codeph>filters</codeph> プロパティに割り当てます。これにより、<codeph>myFilters</codeph> で見つかったすべてのフィルターが適用されます。この場合は、<codeph>filter</codeph> だけです。</li>
      </ul>
  </li>
  <li><codeph>getBitmapFilter()</codeph> 関数を作成し、フィルターのプロパティを作成して設定します。</li>
  <li><codeph>draw()</codeph> 関数を作成します。この関数は、Sprite クラスの <codeph>graphics</codeph> プロパティを介してアクセスする Graphics クラスのメソッドを使用して、四角形を描画します。</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BlurFilter;

    public class BlurFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BlurFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var blurX:Number = 30;
            var blurY:Number = 30;
            return new BlurFilter(blurX, blurY, BitmapFilterQuality.HIGH);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BlurFilter:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
	指定されたパラメーターでフィルターを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Instantiate a new <code>BlurFilter</code> and apply it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "BlurFilterExample");
	
	var blurX:Number = 30;
	var blurY:Number = 30;
	var quality:Number = 3;
	
	var filter:BlurFilter = new BlurFilter(blurX, blurY, quality);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平方向のぼかし量。指定できる値は 0 ～ 255.0（浮動小数値）です。 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直方向のぼかし量。指定できる値は 0 ～ 255.0（浮動小数値）です。 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>フィルターを適用する回数。品質は BitmapFilterQuality 定数を使用して指定できます。
	<ul>
	<li><codeph>flash.filters.BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>高品質にすると、ガウスぼかしに似たものになります。多くのアプリケーションでは、これら 3 つの値で十分です。最大 15 までの値を使用して様々な効果を出すことができますが、値が大きくなるほどレンダリング速度が低下することに注意してください。</p>
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>フィルターを初期化します。
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	指定されたパラメーターでフィルターを初期化します。デフォルト値では、ソフトフォーカスのかかったイメージが作成されます。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:BlurFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BlurFilter objects and compares them.  <code>filter_1</code>
	is created using the BlurFilter constructor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>quality</code> property of <code>filter_1</code>.  Modifying <code>quality</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1.quality);			// 2
	trace(filter_2.quality);			// 2
	trace(clonedFilter.quality);		// 2
	
	filter_1.quality = 1;
	
	trace(filter_1.quality);			// 1
	trace(filter_2.quality);			// 1
	trace(clonedFilter.quality);		// 2
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の BlurFilter インスタンスとプロパティがすべて同じである新しい BlurFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BlurFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurX");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurX = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平方向のぼかし量。指定できる値は 0 ～ 255（浮動小数）です。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurY");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurY = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直方向のぼかし量。指定できる値は 0 ～ 255（浮動小数）です。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:quality:get"><apiName>quality</apiName><shortdesc>
	ぼかしの実行回数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterQuality");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	ぼかしの実行回数です。デフォルト値は、フィルターを 1 回適用することに相当する <codeph>BitmapFilterQuality.LOW</codeph> です。値 <codeph>BitmapFilterQuality.MEDIUM</codeph> はフィルターを 2 回適用します。値 <codeph>BitmapFilterQuality.HIGH</codeph> はフィルターを 3 回適用し、ガウスぼかしに近似したものになります。フィルターに設定された値が小さいほど、速くレンダリングできます。
	
	<p>多くのアプリケーションでは、<codeph>quality</codeph> の値は低、中、または高で十分です。最大 15 までの値を使用してぼかしを適用する回数を増やすことができますが、値が大きくなるほどレンダリング速度が低下することに注意してください。<codeph>quality</codeph> の値を増やす代わりに、<codeph>blurX</codeph> と <codeph>blurY</codeph> の値を増やすだけで、同様の効果が得られます。この方法を実行すると、より高速にレンダリングされます。</p>
	
	<p>次の BitmapFilterQuality 定数を使用して、<codeph>quality</codeph> プロパティの値を指定できます。</p>
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
ConvolutionFilter クラスを使用すると、マトリックス畳み込みフィルター効果を適用できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Do we allow anything other than 3x3 matrix convolution? Are default x y values correct?

</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>マトリックス畳み込みフィルターを適用します。

</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
ConvolutionFilter クラスを使用すると、マトリックス畳み込みフィルター効果を適用できます。畳み込みでは、入力イメージ内のピクセルを、隣接するピクセルと組み合わせて、イメージを作成します。畳み込みを使用すると、ぼかし、エッジ検出、シャープ、エンボス、ベベルなど、幅広いイメージ効果を実現できます。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。

<p>畳み込みフィルターを作成するには、シンタックス <codeph>new ConvolutionFilter()</codeph> を使用します。フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
<ul><li>ムービークリップ、テキストフィールド、ボタン、およびビデオにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>

<li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
</ul>

<p>表示オブジェクトにフィルターを適用すると、オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティの値が <codeph>true</codeph> に設定されます。すべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>

<p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>

</apiDesc><example conref="examples\ConvolutionFilterExample.as"> 次の例では、さまざまな畳み込みフィルターをイメージファイルに適用します。フィルターコンストラクターでは、<codeph>buildChild()</codeph> を 4 回呼び出して、イメージの 4 つのインスタンスを読み込んで表示します。<codeph>buildChild()</codeph> を呼び出すたびに、最初のインスタンスにはフィルターを適用せず、異なる畳み込みフィルターをそれ以降のインスタンスに適用する関数を引数として取ります。
 <p><codeph>buildChild()</codeph> 関数は <codeph>loader</codeph>という名前の新しい Loader オブジェクトを作成します。<codeph>buildChild()</codeph> を呼び出すたびに、<codeph>complete</codeph> イベントを受け取るイベントリスナーを Loader オブジェクトにアタッチします。これらのイベントは <codeph>buildChild()</codeph> に渡される関数によって処理されます。</p>
 
 <p><codeph>applyBrightness()</codeph>、<codeph>applySharpness()</codeph>、および <codeph>applyOutline()</codeph> 関数は <codeph>matrix</codeph> 配列に対して異なる値を使用して、さまざまな ConvolutionFilter 効果を作り出します。</p>
 <p><b>注意：</b>幅が約 80 ピクセル以内のイメージを使用すると、最良の結果が得られます。イメージファイルの名前と場所は <codeph>url</codeph> プロパティに渡す値に一致する必要があります。例えば、この例の <codeph>url</codeph> に渡す値は、SWF ファイルと同じディレクトリ内にある "Image.jpg" という名前のイメージファイルを指します。
 </p>
 
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.filters.BitmapFilter;
    import flash.filters.ConvolutionFilter;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ConvolutionFilterExample extends Sprite {
        private var size:uint = 140;
        private var url:String = "Image.jpg";

        public function ConvolutionFilterExample() {
            buildChild(applyNothing);
            buildChild(applyBrightness);
            buildChild(applySharpness);
            buildChild(applyOutline);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if(loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyNothing(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            applyLabel(child, "no filter");
        }

        private function applyBrightness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [5, 5, 5,
                                5, 0, 5,
                                5, 5, 5];
            applyFilter(child, matrix);
            applyLabel(child, "brightness");
        }

        private function applySharpness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [0, -1, 0,
                               -1, 20, -1,
                                0, -1, 0];
            applyFilter(child, matrix);
            applyLabel(child, "sharpness");
        }

        private function applyOutline(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [-30, 30, 0,
                                -30, 30, 0,
                                -30, 30, 0];
            applyFilter(child, matrix);
            applyLabel(child, "outline");
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var matrixX:Number = 3;
            var matrixY:Number = 3;
            var divisor:Number = 9;
            var filter:BitmapFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }

        private function applyLabel(child:DisplayObject, label:String):void {
            var tf:TextField = new TextField();
            tf.x = child.x;
            tf.y = child.height;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.text = label;
            addChild(tf);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.filters.xml#ConvolutionFilter/matrix"><linktext>matrix</linktext></link></related-links><apiConstructor id="flash.filters:ConvolutionFilter:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
	指定されたパラメーターで ConvolutionFilter インスタンスを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a ConvolutionFilter
	object with the four required parameters <code>matrixX</code>, <code>matrixY</code>, 
	<code>matrix</code>, and <code>divisor</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var matrixX:Number = 3;
	var matrixY:Number = 3;
	var matrix:Array = [1, 1, 1, 1, 1, 1, 1, 1, 1];
	var divisor:Number = 9;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
	
   	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
   	
  	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
  	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
   	myBitmapData.noise(128);
   		
   	mc.onPress = function() {
   		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
   	}
	</listing>
	
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrixX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>マトリックスの <i>x</i> 次元（マトリックスの列数）です。デフォルト値は 0 です。
	</apiDesc></apiParam><apiParam><apiItemName>matrixY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>マトリックスの <i>y</i> 次元（マトリックスの行数）です。デフォルト値は 0 です。
	</apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>マトリックス変換に使用する値の配列です。この配列に含まれる項目数は必ず <codeph>matrixX ~~ matrixY</codeph> に等しくなります。
	</apiDesc></apiParam><apiParam><apiItemName>divisor</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>マトリックス変換中に使用する除数です。デフォルト値は 1 です。除数がすべてのマトリックス値の合計と等しい場合は、結果全体のカラー強度が均等化されます。値 0 は無視され、代わりにデフォルト値が使用されます。 
	</apiDesc></apiParam><apiParam><apiItemName>bias</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>マトリックス変換の結果に加算するバイアスです。デフォルト値は 0 です。
	</apiDesc></apiParam><apiParam><apiItemName>preserveAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc><codeph>false</codeph> である場合は、アルファ値が保持されず、アルファチャンネルを含め、すべてのチャンネルに畳み込みを適用します。<codeph>true</codeph> である場合は、畳み込みをカラーチャンネルだけに適用します。デフォルト値は <codeph>true</codeph> です。
	</apiDesc></apiParam><apiParam><apiItemName>clamp</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc><codeph>true</codeph> の場合、ソースイメージの外にあるピクセルに対して、入力イメージの所定のエッジのカラー値を複製するという方法で、必要に応じて境界に沿って入力イメージを拡張します。<codeph>false</codeph> の場合は、別の色を使用します。その色は <codeph>color</codeph> プロパティと <codeph>alpha</codeph> プロパティで指定します。デフォルト値は <codeph>true</codeph> です。 
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>ソースイメージの外にあるピクセルを置換する 16 進数のカラー値です。
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>代替カラーのアルファです。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	指定されたパラメーターで ConvolutionFilter インスタンスを初期化します。
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ConvolutionFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>ConvolutionFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>ConvolutionFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}		
	</listing>
	
	<p>To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>bias</code> property of <code>filter_1</code>.  Modifying <code>bias</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.</p>
	
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	trace(filter_1.bias);			// 0
	trace(filter_2.bias);			// 0
	trace(clonedFilter.bias);		// 0
	
	filter_1.bias = 20;
	
	trace(filter_1.bias);			// 20
	trace(filter_2.bias);			// 20
	trace(clonedFilter.bias);		// 0
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の ConvolutionMatrixFilter インスタンスとプロパティがすべて同じである新しい ConvolutionFilter インスタンスです。
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ConvolutionFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	代替カラーのアルファ透明度の値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property of <code>filter</code>
	from its default value of <code>1</code> to <code>.35</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var alpha:Number = .35;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, 0x0000FF, alpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	 
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, 98, 78), new Point(2, 2), filter);
  	}
	</listing>	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	代替カラーのアルファ透明度の値です。指定できる値は 0 ～ 1.0 です。デフォルトは 0 です。例えば、.25 を指定すると、透明度の値として 25% が設定されます。	  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:bias:get"><apiName>bias</apiName><shortdesc>
	マトリックス変換の結果に加算するバイアス量です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>bias</code> property of <code>filter</code>
	from its default value of 0 to 50.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var bias:Number = 50;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, bias);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
 	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	マトリックス変換の結果に加算するバイアス量です。バイアスにより各チャンネルのカラー値が増えるため、暗い色は明るくなります。デフォルト値は 0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:clamp:get"><apiName>clamp</apiName><shortdesc>
	イメージをクランプする必要があるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	イメージをクランプする必要があるかどうかを示します。<codeph>true</codeph> の場合、ソースイメージの外にあるピクセルに対して、入力イメージの各エッジのカラー値を複製するという方法で、必要に応じて境界に沿って入力イメージを拡張します。<codeph>false</codeph> の場合は、別の色を使用します。その色は <codeph>color</codeph> プロパティと <codeph>alpha</codeph> プロパティで指定します。デフォルト値は <codeph>true</codeph> です。
	
	</apiDesc><example conref="ConvolutionClampExample.as"> 次の例では、<codeph>BitmapData</codeph> クラスを使用してボックスを 1 つと、これよりも半分のサイズのボックスを 1 つ、合計 2 つのボックスを作成します。 サンプルが最初に読み込まれると、大きいほうのボックスが、<codeph>mc</codeph> の内部に <codeph>attachBitmap()</codeph> を使用して描画されます。<codeph>mc</codeph> をクリックして、<codeph>applyFilter()</codeph> メソッドが呼び出されると、<codeph>largeBox</codeph> インスタンス（<codeph>BitmapData</codeph>）が <codeph>smallBox</codeph> をソースビットマップとして再描画されます。 <codeph>applyFilter()</codeph> では、<codeph>smallBox</codeph> を <codeph>Rectangle</codeph> 上に描画します。その幅と高さは <codeph>largeBox</codeph> の幅と高さに指定されているため、ソースビットマップは描画領域より小さくなります。この場合、<codeph>clamp</codeph> プロパティ（<codeph>ConvolutionFilter</codeph>）は <codeph>false</codeph> に設定されます。ソースビットマップの範囲内にない領域 <codeph>smallBox</codeph> は、<codeph>clampColor</codeph> 変数および <codeph>clampAlpha</codeph> 変数で決まる不透明の赤色です。
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.filters.ConvolutionFilter;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.geom.Point;

    public class ConvolutionClampExample extends Sprite {
        // Variables that affect clamping:
        var clamp:Boolean = false;
        var clampColor:Number = 0xFF0000;
        var clampAlpha:Number = 1;
        
        // For illustration, keep other ConvolutionFilter variables neutral:
        var bias:Number = 0;
        var preserveAlpha:Boolean = false;
        // Also, construct a neutral matrix
        var matrixCols:Number = 3;
        var matrixRows:Number = 3;
        var matrix:Array = [ 1,1,1,
                             1,1,1,
                             1,1,1 ];
        
        var filter:ConvolutionFilter = new ConvolutionFilter(matrixCols, matrixRows, matrix, matrix.length, bias, preserveAlpha, clamp, clampColor, clampAlpha);
        
        var largeBoxWidth:Number = 100;
        var largeBoxHeight:Number = 100;
        var largeBox:BitmapData = new BitmapData(largeBoxWidth, largeBoxWidth, true, 0xCC00FF00);
        var smallBoxWidth:Number = largeBoxWidth / 2;
        var smallBoxHeight:Number = largeBoxHeight / 2;
        var smallBox:BitmapData = new BitmapData(smallBoxWidth, smallBoxWidth, true, 0xCC0000FF);
            
        var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
        mc.attachBitmap(largeBox, this.getNextHighestDepth());
        
        mc.onPress = function() {
            largeBox.applyFilter(smallBox,
                                 new Rectangle(0,0, largeBoxWidth, largeBoxHeight),
                                 new Point(0,0),
                                 filter);
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:color:get"><apiName>color</apiName><shortdesc>
	ソースイメージの外にあるピクセルを置換する 16 進数のカラー値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property of <code>filter</code>
	from its default value of <code>0</code> to <code>0xFF0000</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var color:Number = 0x0000FF;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, color, 1);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	  	
  	var height:Number = 100;
  	var width:Number = 80;
  	mc.onPress = function() {
  		height -= 2;
  		width -= 2;
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, height, width), new Point(2, 2), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	ソースイメージの外にあるピクセルを置換する 16 進数のカラー値です。これはアルファ成分なしの RGB 値です。デフォルト値は 0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:divisor:get"><apiName>divisor</apiName><shortdesc>
	マトリックス変換中に使用する除数です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>divisor</code> property of <code>filter</code>
	to 6.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  	
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	 	
  	mc.onPress = function() {
  		var newDivisor:Number = 6;
  		filter.divisor = newDivisor;
  	 	myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	マトリックス変換中に使用する除数です。デフォルト値は 1 です。序数がすべてのマトリックス値の合計と等しい場合は、結果全体のカラー強度が均等化されます。値 0 は無視され、代わりにデフォルト値が使用されます。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	マトリックス変換に使用する値の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>matrix</code> property of <code>filter</code>
	from one that blurs a bitmap to one that sharpens it.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  		
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	  	
  	mc.onPress = function() {
  		var newMatrix:Array = [0, -1, 0, -1, 8, -1, 0, -1, 0];
  		filter.matrix = newMatrix;
  		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	マトリックス変換に使用する値の配列です。この配列に含まれる項目数は必ず <codeph>matrixX ~~ matrixY</codeph> に等しくなります。
	<p> マトリックスの畳み込みは、<i>n</i> x <i>m</i> マトリックスに基づいています。入力イメージ内の特定のピクセルを隣接するピクセルと組み合わせるという方法で、新しいピクセル値を生成します。結果として得られるピクセルは、対応するソースピクセルおよび連接するピクセルにマトリックスを適用することで算出されます。</p>
	
	<p> 3 × 3 のマトリックス畳み込みの場合、独立するカラーチャンネルごとに次の式を使用します。
	<pre><codeph>
	dst (x, y) = ((src (x-1, y-1) ~~ a0 + src(x, y-1) ~~ a1....
	                  src(x, y+1) ~~ a7 + src (x+1,y+1) ~~ a8) / divisor) + bias
	</codeph></pre>
	</p>
	
	<p>SSE（Streaming SIMD Extensions：ストリーミング SIMD 拡張）を提供するプロセッサーで実行するときに処理が高速化されるフィルター仕様もあります。高速な畳み込み操作が可能となる基準は次のとおりです。</p>
	<ul>
	<li>3 × 3 フィルターである。</li>
	<li>フィルター項はすべて -127 ～ +127 の整数である。</li>
	<li>すべてのフィルター項の合計の絶対値が 127 を超えていない。</li> 
	<li>いずれかのフィルター項が負である場合、除数は 2.00001 ～ 256 である。</li>
	<li>フィルター項がすべて正である場合、除数は 1.1 ～ 256 である。</li>
	<li>バイアスは整数である。</li>
	</ul>
    <p><b>注意：</b>パラメーターなしのコンストラクターを使用して ConvolutionFilter インスタンスを作成する場合は、値をマトリックスプロパティに割り当てる順序がフィルターの動作に影響します。次の例では、マトリックス配列に割り当てを行い、<codeph>matrixX</codeph> および <codeph>matrixY</codeph> プロパティは <codeph>0</codeph>（デフォルト値）に設定したままです。</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    </codeblock>
    <p>次の例では、マトリックス配列に割り当てを行い、<codeph>matrixX</codeph> および <codeph>matrixY</codeph> プロパティを <codeph>3</codeph> に設定します。</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    </codeblock>
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixX:get"><apiName>matrixX</apiName><shortdesc>
	マトリックスの x 次元（マトリックスの列数）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixX</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
 	
 	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixX);	// 2
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	マトリックスの <i>x</i> 次元（マトリックスの列数）です。デフォルト値は 0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixY:get"><apiName>matrixY</apiName><shortdesc>
	マトリックスの y 次元（マトリックスの行数）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixY</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixY);	// 3
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	マトリックスの <i>y</i> 次元（マトリックスの行数）です。デフォルト値は 0 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:preserveAlpha:get"><apiName>preserveAlpha</apiName><shortdesc>
	アルファチャンネルがフィルター効果なしで維持されるかどうか、またはカラーチャンネルだけではなくアルファチャンネルにも畳み込みフィルターが適用されるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>preserveAlpha</code> property of <code>filter</code>
	from its default value of <code>true</code> to <code>false</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var preserveAlpha:Boolean = false;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, preserveAlpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
	
	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	アルファチャンネルがフィルター効果なしで維持されるかどうか、またはカラーチャンネルだけではなくアルファチャンネルにも畳み込みフィルターが適用されるかどうかを示します。<codeph>false</codeph> である場合は、アルファチャンネルを含め、すべてのチャンネルに畳み込みを適用します。<codeph>true</codeph> である場合は、畳み込みをカラーチャンネルだけに適用します。デフォルト値は <codeph>true</codeph> です。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
GradientBevelFilter クラスを使用すると、オブジェクトにグラデーションベベル効果を適用し、表示できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>グラデーションベベル効果を適用できます。
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
GradientBevelFilter クラスを使用すると、オブジェクトにグラデーションベベル効果を適用し、表示できます。グラデーションベベルは、オブジェクトの外側、内側、または上側が斜めになったエッジであり、グラデーションカラーで強調されます。斜めのエッジによってオブジェクトが 3 次元に見えます。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。

 <p>フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
 <ul><li>表示オブジェクトにフィルターを適用する場合は、<codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>
 
 <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
 </ul>

<p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティは <codeph>true</codeph> に設定されます。すべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p> 

<p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体を拡大 / 縮小する場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> の値が 1.0 以外に設定されている場合）、フィルター効果は拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>

<p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>

 </apiDesc><example conref="examples\GradientBevelFilterExample.as"> 次の例では、四角形を描画してグラデーションベベルフィルターを適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>必要なクラスを読み込みます。</li>
  <li>正方形とフィルターを定義するグローバル変数を宣言します。</li>
  <li>コンストラクター関数を作成します。この関数は、次の処理を行います。
      <ul>
          <li><codeph>draw()</codeph> メソッドを呼び出し、Sprite の <codeph>graphics</codeph> プロパティを介してアクセスする Graphics クラスのメソッドを使用して灰色の四角形を描画します。</li>
          <li><codeph>filter</codeph> という名前の BitmapFilter オブジェクトを作成し、このオブジェクトに <codeph>getBitmapFilter()</codeph> の呼び出しによる戻り値を割り当てます。これでフィルターが作成されます。</li>
          <li><codeph>myFilters</codeph> という名前の新しい配列を作成し、それに <codeph>filter</codeph> を追加します。</li>
          <li><codeph>myFilters</codeph> を GradientBevelFilterExample オブジェクトの <codeph>filters</codeph> プロパティに割り当てます。これにより、<codeph>myFilters</codeph> で見つかったすべてのフィルターが適用されます。この場合は、<codeph>filter</codeph> だけです。</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientBevelFilter;

    public class GradientBevelFilterExample extends Sprite {
        private var bgColor:uint     = 0xCCCCCC;
        private var size:uint        = 80;
        private var offset:uint      = 50;
        private var distance:Number  = 5;
        private var angleInDegrees:Number = 225; // opposite 45 degrees
        private var colors:Array     = [0xFFFFFF, 0xCCCCCC, 0x000000];
        private var alphas:Array     = [1, 0, 1];
        private var ratios:Array     = [0, 128, 255];
        private var blurX:Number     = 8;
        private var blurY:Number     = 8;
        private var strength:Number  = 2;
        private var quality:Number   = BitmapFilterQuality.HIGH
        private var type:String      = BitmapFilterType.INNER;
        private var knockout:Boolean = true;

        public function GradientBevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientBevelFilter(distance,
                                           angleInDegrees,
                                           colors,
                                           alphas,
                                           ratios,
                                           blurX,
                                           blurY,
                                           strength,
                                           quality,
                                           type,
                                           knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:GradientBevelFilter:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
	指定されたパラメーターでフィルターを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Constructor
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>オフセット距離です。指定できる値は 0 ～ 8 です。 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>角度（度数）です。指定できる値は 0 ～ 360 です。 
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>グラデーションで使用する RGB 16 進数カラー値の配列です。例えば、赤は 0xFF0000、青は 0x0000FF などです。
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc><codeph>colors</codeph> 配列内の各色に対応するアルファ透明度の値の配列です。配列の各エレメントに指定できる値は、0 ～ 1 です。例えば、.25 を指定すると、透明度の値として 25% が設定されます。
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>色分布比率の配列です。0 ～ 255 の範囲の値を指定できます。
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>水平方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>垂直方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、ベベルと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255 です。値を 0 にすると、フィルターが適用されなくなります。 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>フィルターの品質です。次の BitmapFilterQuality 定数を使用します。
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>詳細については、<codeph>quality</codeph> プロパティの説明を参照してください。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>ベベル効果の配置です。指定できる値は、BitmapFilterType 定数です。
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> - ベベルがオブジェクトの外側エッジに配置されます。</li>
	<li><codeph>BitmapFilterType.INNER</codeph> - ベベルがオブジェクトの内側エッジに配置されます。</li>
	<li><codeph>BitmapFilterType.FULL</codeph> - ベベルがオブジェクトの上に配置されます。</li>
	</ul>
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>ノックアウト効果を適用するかどうかを指定します。<codeph>true</codeph> を指定すると、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	指定されたパラメーターでフィルターを初期化します。
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/quality"><linktext>GradientBevelFilter.quality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GradientBevelFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two rectangle shapes. The first, 
	<code>sourceClip</code> has a bevel effect. The second, 
	<code>resultClip</code> has no effect until it is clicked.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var sourceClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneSourceClip");
	var resultClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneResultClip");
	
	resultClip.source = sourceClip;
	
	var sourceFilter:GradientBevelFilter = getNewFilter();
	sourceClip.filters = new Array(sourceFilter);
	
	resultClip._x = 180;
	resultClip.onRelease = function() {
		this.filters = new Array(this.source.filters[0].clone());
	}
	
	function setUpFlatRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		return mc;
	}
	
	function getNewFilter():GradientBevelFilter {
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		return new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	}
	
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の GradientBevelFilter インスタンスとプロパティがすべて同じである新しい GradientBevelFilter インスタンスです。
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientBevelFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	カラー配列内の各色に対応するアルファ透明度の値の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>alphas</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("alphasExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [.2, 0, .2];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [1, 0, 1];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>アルファ値の配列です。
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	<codeph>colors</codeph> 配列内の各色に対応するアルファ透明度の値の配列です。配列の各エレメントに指定できる値は、0 ～ 1 です。例えば、.25 を指定すると、透明度の値として 25% が設定されます。
	
	<p><codeph>alphas</codeph> プロパティの値を直接変更することはできません。このプロパティを変更するには、<codeph>alphas</codeph> への参照を取得し、その参照を変更した後、<codeph>alphas</codeph> をその参照に設定する必要があります。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph>、および <codeph>ratios</codeph> の 3 つのプロパティは関連しています。<codeph>colors</codeph> 配列の先頭のエレメントが <codeph>alphas</codeph> 配列と <codeph>ratios</codeph> 配列の先頭のエレメントに対応するなど、3 つの配列の同じインデックスのエレメントが互いに対応しています。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	角度（度数）です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>angle</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("angleExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].angle = 45;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	角度（度数）です。指定できる値は 0 ～ 360 です。デフォルト値は 45 です。
	
	<p>角度の値は、オブジェクトに向けられる架空の光源の角度を表します。この値によって、グラデーションカラーがオブジェクトに適用されるときの角度を設定します。これによりハイライトとシャドウの現れる場所や、配列の先頭の色が現れる場所が決まります。先頭の色を適用する場所が決まると、他の色が配列内に格納されている順に適用されます。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurX</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurXExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurX = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurY</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurYExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurY = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直方向のぼかし量。指定できる値は 0 ～ 255 です。1 以下の値を指定すると、元のイメージがそのままコピーされます。デフォルト値は 4 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:colors:get"><apiName>colors</apiName><shortdesc>
	グラデーションで使用する RGB 16 進数カラー値の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>colors</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("colorsExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0x000000, 0xCCCCCC, 0xFFFFFF];
		arr[0].colors = colors;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		arr[0].colors = colors;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>RGB 16 進数のカラー値の配列です。
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	グラデーションで使用する RGB 16 進数カラー値の配列です。例えば、赤は 0xFF0000、青は 0x0000FF などです。
	
	<p><codeph>colors</codeph> プロパティの値を直接変更することはできません。このプロパティを変更するには、<codeph>colors</codeph> への参照を取得し、その参照を変更した後、<codeph>colors</codeph> をその参照に設定する必要があります。</p>
	
	<p><codeph>colors</codeph>、<codeph>alphas</codeph>、および <codeph>ratios</codeph> の 3 つのプロパティは関連しています。<codeph>colors</codeph> 配列の先頭のエレメントが <codeph>alphas</codeph> 配列と <codeph>ratios</codeph> 配列の先頭のエレメントに対応するなど、3 つの配列の同じインデックスのエレメントが互いに対応しています。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	オフセット距離です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>distance</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("distanceExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].distance = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	オフセット距離です。指定できる値は 0 ～ 8 です。デフォルト値は 4.0 です。
	
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	オブジェクトにノックアウト効果を適用するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>knockout</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("knockoutExample");
	mc.onRelease = function() {
	var arr:Array = this.filters;
		arr[0].knockout = true;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトにノックアウト効果を適用するかどうかを指定します。ノックアウト効果を適用すると、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。<codeph>true</codeph> を指定すると、ノックアウト効果が適用されます。デフォルトは <codeph>false</codeph> で、ノックアウト効果は適用されません。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	フィルターを適用する回数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>quality</code> property on an existing
	object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("qualityExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].quality = 1; // low quality
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	フィルターを適用する回数。デフォルト値は、フィルターを 1 回適用することに相当する <codeph>BitmapFilterQuality.LOW</codeph> です。値 <codeph>BitmapFilterQuality.MEDIUM</codeph> はフィルターを 2 回適用します。値 <codeph>BitmapFilterQuality.HIGH</codeph> はフィルターを 3 回適用します。フィルターに設定された値が小さいほど、速くレンダリングできます。
	
	<p>多くのアプリケーションでは、<codeph>quality</codeph> の値は低、中、または高で十分です。最大 15 までの値を使用してさまざまな効果を出すことができますが、値が大きくなるほどレンダリング速度が低下します。<codeph>quality</codeph> の値を増やす代わりに、<codeph>blurX</codeph> と <codeph>blurY</codeph> の値を増やすだけで、同様の効果が得られます。この方法を実行すると、より高速にレンダリングされます。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	カラー配列内の対応するカラーの色分布比率の配列です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>ratios</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("ratiosExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [127, 128, 129];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [0, 128, 255];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>配列は、設定時に null に設定されます。
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	<codeph>colors</codeph> 配列内の対応する色の色分布比率の配列です。配列のエレメントに指定できる値は、0 ～ 255 です。
	
	<p><codeph>ratios</codeph> プロパティの値を直接変更することはできません。このプロパティを変更するには、<codeph>ratios</codeph> への参照を取得し、その参照を変更した後、<codeph>ratios</codeph> をその参照に設定する必要があります。</p>
	
	<p> <codeph>colors</codeph>、<codeph>alphas</codeph>、および <codeph>ratios</codeph> の 3 つのプロパティは関連しています。<codeph>colors</codeph> 配列の先頭のエレメントが <codeph>alphas</codeph> 配列と <codeph>ratios</codeph> 配列の先頭のエレメントに対応するなど、3 つの配列の同じインデックスのエレメントが互いに対応しています。</p>
	
	<p> グラデーションベベルで色の分布がどのようになるかを理解するために、まず、グラデーションベベルで使用する色を考えます。ベベルを単純化すると、ハイライト 1 色とシャドウ 1 色で構成されています。グラデーションベベルには 1 つのハイライトグラデーションと 1 つのシャドウグラデーションがあります。ハイライトを左上隅に表示し、シャドウを右下隅に表示するとします。ここでは、一例として、ハイライトに 4 色、シャドウに 4 色を使用します。ハイライトとシャドウに加え、ハイライトとシャドウのエッジが交差する部分にベース塗りの色を使用します。この場合、合計 9 色を使用するので、色分布比率の配列のエレメント数は 9 です。</p>
	
	<p> グラデーションを互いに混ざり合ったさまざまな色のストライプで構成されているものと考えた場合、色分布比率の値は、その色のグラデーションの範囲内における位置を表します。この位置は、0 がグラデーションの最も外側の点を表し、255 がグラデーションの最も内側の点を表します。通常、中間値は 128 で、これがベース塗りの値になります。下のイメージのベベル効果を得るには、9 色の例を使用して色分布比率の値を次のように設定します。</p>
	
	<ul> 
	<li> 最初の 4 色は 0 ～ 127 の範囲で、それぞれの値が前の値と等しいか、それより大きくなるように設定します。これがハイライトのベベルエッジです。</li>
	<li> 5 番目の色（中間色）はベース塗りで、128 に設定します。ピクセル値の 128 によりベース塗りが設定されます。このベース塗りは、type が outer に設定されている場合はシェイプの外側（およびベベルエッジの周囲）に現れ、type が inner に設定されている場合はシェイプの内側に現れてオブジェクト自体の塗りを効果的に隠します。</li>
	<li> 最後の 4 色は 129 ～ 255 の範囲で、それぞれの値が前の値と等しいか、それより大きくなるように設定します。これがシャドウのベベルエッジです。</li>
	</ul>
	
	<p> 各エッジの色分布を同じにする場合は、中間色がベース塗りになるように、使用する色数を奇数にします。0 ～ 127 と 129 ～ 255 の範囲で色を均等に分布した後、値を調整してグラデーションの各色のストライプの幅を変更します。9 色のグラデーションベベルの場合、[16, 32, 64, 96, 128, 160, 192, 224, 235] のような配列が考えられます。次の図は、ここまで説明したグラデーションベベルを表しています。</p>
	
	<p><adobeimage alt="9 色のグラデーションベベル。" href="../../images/gradientBevelRainbow.jpg"/></p>
	
	<p>グラデーションの色の広がりは、<codeph>blurX</codeph>、<codeph>blurY</codeph>、<codeph>strength</codeph>、<codeph>quality</codeph> プロパティの値、および <codeph>ratios</codeph> 値に基づいて変化します。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	インプリントの強さまたは広がりです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>strength</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("strengthExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].strength = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、ベベルと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255 です。値を 0 にすると、フィルターが適用されなくなります。デフォルト値は 1 です。
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:type:get"><apiName>type</apiName><shortdesc>
	ベベル効果の配置です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>type</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("typeExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].type = "outer";
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	ベベル効果の配置です。指定できる値は、BitmapFilterType 定数です。
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> - ベベルがオブジェクトの外側エッジに配置されます。</li>
	<li><codeph>BitmapFilterType.INNER</codeph> - ベベルがオブジェクトの内側エッジに配置されます。</li>
	<li><codeph>BitmapFilterType.FULL</codeph> - ベベルがオブジェクトの上に配置されます。</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
 GlowFilter クラスを使用すると、表示オブジェクトにグロー効果を適用できます。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>グロー効果を追加できます。
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 GlowFilter クラスを使用すると、表示オブジェクトにグロー効果を適用できます。グローのスタイルには複数のオプションがあり、内側グロー、外側グロー、ノックアウトモードなどがあります。グローフィルターは、<codeph>distance</codeph> プロパティと <codeph>angle</codeph> プロパティを 0 に設定したドロップシャドウフィルターによく似ています。このフィルターは、MovieClip、SimpleButton、TextField、Video オブジェクトなどの DisplayObject クラスから継承した表示オブジェクト、および BitmapData オブジェクトに適用できます。
 
 <p>フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
 <ul><li>表示オブジェクトにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。 </li>
 
 <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
 </ul>
 
 
 <p>表示オブジェクトにフィルターを適用すると、表示オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティは <codeph>true</codeph> に設定されます。すべてのフィルターをクリアすると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>

 <p>このフィルターはステージの拡大 / 縮小に対応していますが、通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体が拡大 / 縮小される場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> プロパティの値が 1.0 以外に設定されている場合）、フィルターは拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>
 
 <p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>
 
 </apiDesc><example conref="examples\GlowFilterExample.as"> 次の例では、四角形を描画してぼかしフィルターを適用します。この例に対する一般的なワークフローは、次のようになります。
 <ol>
  <li>必要なクラスを読み込みます。</li>
  <li><codeph>draw</codeph> メソッドで使用する 3 つのプロパティを宣言し、Sprite の <codeph>graphics</codeph> プロパティを介してアクセスする Graphics クラスのメソッドを使用して、オレンジ色の四角形を描画します。</li>
  <li>コンストラクター関数を作成します。この関数は、次の処理を行います。
      <ul>
          <li><codeph>draw</codeph> メソッドを呼び出します。</li> 
          <li><codeph>filter</codeph> という名前の新しい BitmapFilter オブジェクトを作成し、このオブジェクトに <codeph>getBitmapFilter()</codeph> の呼び出しによる戻り値を割り当てます。これでフィルターが定義されます。</li>
          <li><codeph>myFilters</codeph> という名前の新しい配列を作成し、それに <codeph>filter</codeph> を追加します。 </li>
          <li><codeph>myFilters</codeph> を BevelFilterExample オブジェクトの <codeph>filters</codeph> プロパティに割り当てます。これにより、<codeph>myFilters</codeph> で見つかったすべてのフィルターが適用されます。この場合は、<codeph>filter</codeph> だけです。</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.GlowFilter;

    public class GlowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function GlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x33CCFF;
            var alpha:Number = 0.8;
            var blurX:Number = 35;
            var blurY:Number = 35;
            var strength:Number = 2;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;

            return new GlowFilter(color,
                                  alpha,
                                  blurX,
                                  blurY,
                                  strength,
                                  quality,
                                  inner,
                                  knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/scaleX"><linktext>flash.display.DisplayObject.scaleX</linktext></link><link href="flash.display.xml#DisplayObject/scaleY"><linktext>flash.display.DisplayObject.scaleY</linktext></link><link href="flash.filters.xml#DropShadowFilter/distance"><linktext>flash.filters.DropShadowFilter.distance</linktext></link><link href="flash.filters.xml#DropShadowFilter/angle"><linktext>flash.filters.DropShadowFilter.angle</linktext></link></related-links><apiConstructor id="flash.filters:GlowFilter:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
	指定されたパラメーターで新しい GlowFilter インスタンスを初期化します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example instantiates a new GlowFilter instance and applies
	it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	
	var color:Number = 0x33CCFF;
	var alpha:Number = .8;
	var blurX:Number = 35;
	var blurY:Number = 35;
	var strength:Number = 2;
	var quality:Number = 3;
	var inner:Boolean = false;
	var knockout:Boolean = false;
	
	var filter:GlowFilter = new GlowFilter(color, 
										 alpha, 
										 blurX, 
										 blurY, 
										 strength, 
										 quality, 
										 inner, 
										 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFF0000</apiData><apiDesc>グローのカラーです。16 進数形式（0x<i>RRGGBB</i>）で指定します。デフォルト値は 0xFF0000 です。
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>カラーのアルファ透明度の値です。指定できる値は 0 ～ 1 です。例えば、.25 を指定すると、透明度の値として 25% が設定されます。
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>水平方向のぼかし量。指定できる値は 0 ～ 255（浮動小数）です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>垂直方向のぼかし量。指定できる値は 0 ～ 255（浮動小数）です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>2</apiData><apiDesc>インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、グローと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255 です。 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>フィルターを適用する回数。BitmapFilterQuality 定数を使用します。
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>詳細については、<codeph>quality</codeph> プロパティの説明を参照してください。</p>
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>グローが内側グローであるかどうかを示します。<codeph>true</codeph> の場合は、内側グローであることを示します。値 <codeph>false</codeph> は外側グロー（オブジェクトの外周にあるグロー）を示します。 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>オブジェクトにノックアウト効果を適用するかどうかを指定します。<codeph>true</codeph> を指定すると、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。 
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	指定されたパラメーターで新しい GlowFilter インスタンスを初期化します。
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GlowFilter/quality"><linktext>GlowFilter.quality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GlowFilter:clone"><apiName>clone</apiName><shortdesc>
	このフィルターオブジェクトのコピーを返します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GlowFilter objects and compares them: <code>filter_1</code>
	is created by using the GlowFilter constructor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> strength: 2
		// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> strength: 2
	// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>元の GlowFilter インスタンスのプロパティをすべて備えた新しい GlowFilter インスタンスです。
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	このフィルターオブジェクトのコピーを返します。
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GlowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	カラーのアルファ透明度の値です。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterAlpha");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	カラーのアルファ透明度の値です。指定できる値は 0 ～ 1 です。例えば、.25 を指定すると、透明度の値として 25% が設定されます。デフォルト値は 1 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	水平方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurX");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurX = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	水平方向のぼかし量。指定できる値は 0 ～ 255（浮動小数）です。デフォルト値は 6 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	垂直方向のぼかし量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurY");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurY = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	垂直方向のぼかし量。指定できる値は 0 ～ 255（浮動小数）です。デフォルト値は 6 です。2 のべき乗（2、4、8、16、32 など）は、他の値と比べて速くレンダリングできるよう最適化されます。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:color:get"><apiName>color</apiName><shortdesc>
	グローのカラーを表します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterColor");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.color = 0x00FF33;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	グローのカラーを表します。指定できる値は、16 進数形式（0x<i>RRGGBB</i>）です。デフォルト値は 0xFF0000 です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	グローが内側グローであるかどうかを示します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterInner");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	グローが内側グローであるかどうかを示します。<codeph>true</codeph> の場合は、内側グローであることを示します。デフォルトは <codeph>false</codeph>（外側グロー）で、オブジェクトの外側のエッジにあるグローを示します。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	オブジェクトにノックアウト効果を適用するかどうかを指定します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterKnockout");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	オブジェクトにノックアウト効果を適用するかどうかを指定します。<codeph>true</codeph> を指定すると、オブジェクトの塗りが透明になり、ドキュメントの背景色が表示されます。デフォルト値は <codeph>false</codeph>（ノックアウト効果なし）です。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	フィルターを適用する回数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterQuality");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	フィルターを適用する回数。デフォルト値は、フィルターを 1 回適用することに相当する <codeph>BitmapFilterQuality.LOW</codeph> です。値 <codeph>BitmapFilterQuality.MEDIUM</codeph> はフィルターを 2 回適用します。値 <codeph>BitmapFilterQuality.HIGH</codeph> はフィルターを 3 回適用します。フィルターに設定された値が小さいほど、速くレンダリングできます。
	
	<p>多くのアプリケーションでは、<codeph>quality</codeph> の値は低、中、または高で十分です。最大 15 までの値を使用してさまざまな効果を出すことができますが、値が大きくなるほどレンダリング速度が低下します。<codeph>quality</codeph> の値を増やす代わりに、<codeph>blurX</codeph> と <codeph>blurY</codeph> の値を増やすだけで、同様の効果が得られます。この方法を実行すると、より高速にレンダリングされます。</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	インプリントの強さまたは広がりです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterStrength");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.strength = .8;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	インプリントの強さまたは広がりです。値が大きいほど、濃い色がインプリントされるので、グローと背景との間のコントラストが強くなります。指定できる値は 0 ～ 255 です。デフォルト値は 2 です。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
	 ShaderFilter クラスは、フィルター処理されるオブジェクトにシェーダーを実行することによってフィルターを適用します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderFilter クラスは、フィルター処理されるオブジェクトにシェーダーを実行することによってフィルターを適用します。フィルター処理されたオブジェクトは、シェーダーへの入力として使用され、シェーダー出力がフィルター結果になります。
	 
	 <p>新しいフィルターを作成するには、コンストラクター <codeph>new ShaderFilter()</codeph> を使用します。フィルターの使用方法は、フィルターの適用先オブジェクトによって異なります。</p>
	 
	 <ul>
	   <li>ムービークリップ、テキストフィールド、ボタン、およびビデオにフィルターを適用する場合は、DisplayObject から継承した <codeph>filters</codeph> プロパティを使用します。オブジェクトの <codeph>filters</codeph> プロパティを設定しても、オブジェクトは変更されません。<codeph>filters</codeph> プロパティをクリアすることにより、フィルターを取り消すことができます。</li>
	   <li>BitmapData オブジェクトにフィルターを適用するには、<codeph>BitmapData.applyFilter()</codeph> メソッドを使用します。BitmapData オブジェクトで <codeph>applyFilter()</codeph> を呼び出すことによって、ソース BitmapData オブジェクトとフィルターオブジェクトが取得され、フィルターを適用したイメージが生成されます。</li>
	 </ul>
	 
	 <p>表示オブジェクトにフィルターを適用すると、オブジェクトの <codeph>cacheAsBitmap</codeph> プロパティの値が true に設定されます。すべてのフィルターを削除すると、<codeph>cacheAsBitmap</codeph> の元の値が復元されます。</p>
	 
	 <p>このフィルターはステージの拡大 / 縮小に対応していますが、 通常の拡大 / 縮小、回転、傾斜には対応していません。オブジェクト自体が拡大 / 縮小される場合（<codeph>scaleX</codeph> と <codeph>scaleY</codeph> プロパティが 100% に設定されていない場合）、フィルターは拡大 / 縮小されません。フィルターが拡大 / 縮小されるのは、ユーザーがステージをズームインする場合のみです。</p>
	 
	 <p>結果として得られるイメージが最大サイズを超えると、フィルターは適用されません。 AIR 1.5 および Flash Player 10 における最大サイズは、幅または高さが 8,191 ピクセルで、合計のピクセル数は 16,777,215 ピクセルを超えないようにしてください（つまり、幅が 8,191 ピクセルのイメージでは、高さが 2,048 ピクセルになります）。Flash Player 9 以前および AIR 1.1 以前では、高さの限界は 2,880 ピクセルで幅の限界は 2,880 ピクセルです。 例えば、フィルターが適用されたサイズの大きいムービークリップをズームインするとき、結果として得られるイメージが最大サイズを超える場合は、フィルターがオフになります。</p>
	 
	 <p>フィルターで使用する Shader インスタンスを指定するには、Shader インスタンスを <codeph>ShaderFilter()</codeph> コンストラクターに対する引数として渡すか、<codeph>shader</codeph> プロパティの値として設定します。</p>
	 
	 <p>シェーダー出力にフィルターが適用されたオブジェクトの境界を超える拡張を許可するには、<codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph> および <codeph>bottomExtension</codeph> プロパティを使用します。</p>
	 
	 </apiDesc><example conref="examples\ShaderFilterExample.1.as"> 次の例では、シェーダーを読み込み、ShaderFilter の <codeph>shader</codeph> プロパティとして使用します。このコードは、Sprite インスタンスに円を描画してステージに追加します。シェーダーを読み込むと、その Sprite にシェーダーフィルターが適用されます。
 
 <p>この例では、アプリケーションに対する出力ディレクトリとして、同じディレクトリに「gradient.pbj」という名前のシェーダーバイトコードファイルがあると想定しています。</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel RedGradientFilter
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "Applies a gradient across the red channel of the input image.";
>
{
    input image4 src;
    output pixel4 dst;
    
    parameter float width
    &lt;
        description: "The width of the image to which the shader is applied.";
        minValue: 0.0;
    >;

    void evaluatePixel()
    {
        pixel4 temp = sampleNearest(src, outCoord());
        temp.r = 1.0 - (outCoord().x * (1.0 / width));
        dst = temp;
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.filters.ShaderFilter;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderFilterExample extends Sprite {
        
        private var loader:URLLoader;
        private var s:Sprite;
        
        public function ShaderFilterExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("gradient.pbj"));
            
            s = new Sprite();
            s.graphics.beginFill(0x009900);
            s.graphics.drawCircle(100, 100, 100);
            addChild(s);
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader(loader.data);
            shader.data.width.value = [s.width];
            
            var gradientFilter:ShaderFilter = new ShaderFilter(shader);
            s.filters = [gradientFilter];
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links><apiConstructor id="flash.filters:ShaderFilter:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
		 新しいシェーダーフィルターを作成します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>このフィルターに使用するシェーダーです。シェーダーが従う必要のある詳細と制限については、<codeph>shader</codeph> プロパティの説明を参照してください。
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 新しいシェーダーフィルターを作成します。
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#ShaderFilter/shader"><linktext>shader</linktext></link></related-links></apiConstructor><apiValue id="flash.filters:ShaderFilter:bottomExtension:get"><apiName>bottomExtension</apiName><shortdesc>
		 ターゲットオブジェクトの下部でピクセルを増加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ターゲットオブジェクトの下部でピクセルを増加します。
		 
		 <p>実行中にシェーダーに渡されるターゲットオブジェクトの境界を超えた領域に増加します。実行時に、Flash Player または AIR は、ムービークリップの通常の境界を計算し、<codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph>、および <codeph>bottomExtension</codeph> の値に基づいて境界を拡張します。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:leftExtension:get"><apiName>leftExtension</apiName><shortdesc>
		 ターゲットオブジェクトの左側でピクセルを増加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ターゲットオブジェクトの左側でピクセルを増加します。
		 
		 <p>実行中にシェーダーに渡されるターゲットオブジェクトの境界を超えた領域に増加します。実行時に、Flash Player または AIR は、ムービークリップの通常の境界を計算し、<codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph>、および <codeph>bottomExtension</codeph> の値に基づいて境界を拡張します。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:rightExtension:get"><apiName>rightExtension</apiName><shortdesc>
		 ターゲットオブジェクトの右側でピクセルを増加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ターゲットオブジェクトの右側でピクセルを増加します。
		 
		 <p>実行中にシェーダーに渡されるターゲットオブジェクトの境界を超えた領域に増加します。実行時に、Flash Player または AIR は、ムービークリップの通常の境界を計算し、<codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph>、および <codeph>bottomExtension</codeph> の値に基づいて境界を拡張します。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:shader:get"><apiName>shader</apiName><shortdesc>
		 このフィルターに使用するシェーダーです。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 このフィルターに使用するシェーダーです。
		 
		 <p><codeph>shader</codeph> プロパティに割り当てられたシェーダーでは、少なくとも 1 つの <codeph>image4</codeph> 入力を指定する必要があります。入力は、<b/>関連付けられた ShaderInput オブジェクトの <codeph>input</codeph> プロパティを使用してコードで指定される必要はありません。代わりに、フィルターが適用されるオブジェクトが、最初の入力として自動的に使用されます（<codeph>index</codeph> 0 で入力）。フィルターとして使用されるシェーダーは、複数の入力を指定できます。この場合、追加の入力は、ShaderInput インスタンスの <codeph>input</codeph> プロパティを設定して指定される必要があります。</p>
		 
		 <p>Shader インスタンスをこのプロパティに割り当てる場合、シェーダーは内部的にコピーされ、フィルター処理には元のシェーダーへの参照ではなく、この内部コピーが使用されます。パラメーター値、入力またはバイトコードの変更などシェーダーに加えられた変更は、フィルターに使用されるシェーダーのコピーには適用されません。シェーダーの変更がフィルター出力で考慮されるようにするには、Shader インスタンスを <codeph>shader</codeph> プロパティに割り当て直す必要があります。 また、すべてのフィルターと同様、フィルターの変更を適用するには、表示オブジェクトの <codeph>filters</codeph> プロパティに ShaderFilter インスタンスを割り当て直す必要があります。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:topExtension:get"><apiName>topExtension</apiName><shortdesc>
		 ターゲットオブジェクトの上部でピクセルを増加します。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 ターゲットオブジェクトの上部でピクセルを増加します。
		 
		 <p>実行中にシェーダーに渡されるターゲットオブジェクトの境界を超えた領域に増加します。実行時に、Flash Player または AIR は、ムービークリップの通常の境界を計算し、<codeph>leftExtension</codeph>、<codeph>rightExtension</codeph>、<codeph>topExtension</codeph>、および <codeph>bottomExtension</codeph> の値に基づいて境界を拡張します。</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>