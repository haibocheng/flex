<?xml version="1.0"?>
<apiPackage id="__Global__"><apiName>__Global__</apiName><apiDetail/><apiClassifier id="globalClassifier:VerifyError"><apiName>VerifyError</apiName><shortdesc>
 Класс VerifyError представляет ошибку, которая возникает при обнаружении неправильного или поврежденного SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Исключение VerifyError создается, если обнаружен некорректный или поврежденный SWF-файл.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс VerifyError представляет ошибку, которая возникает при обнаружении неправильного или поврежденного SWF-файла. 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>Класс Loader</linktext></link></related-links><apiConstructor id="VerifyError:VerifyError"><apiName>VerifyError</apiName><shortdesc>
	 Создает новый объект VerifyError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Содержит сообщение, связанное с объектом VerifyError.      
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект VerifyError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
 Класс ArgumentError представляет ошибку, которая возникает, если аргументы, переданные функции, не совпадают с аргументами, определенными для этой функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Исключение ArgumentError создается, когда значения параметров, указанные во время вызова функции, не соответствуют параметрам, определенным для этой функции.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс ArgumentError представляет ошибку, которая возникает, если аргументы, переданные функции, не совпадают с аргументами, определенными для этой функции. Эта ошибка появляется, например, тогда, когда функция вызывается с неправильным количеством аргументов, аргументом неверного типа или недействительным аргументом.
 
 </apiDesc><example conref="examples\ArgumentErrorExample.as"> В следующем примере демонстрируется, как генерируется ошибка <codeph>ArgumentError</codeph>, обрабатываемая в операторе <codeph>try.. catch</codeph>. Функция <codeph>println()</codeph> принимает один аргумент (единичную строку), но поскольку указано две строки, появляется ошибка. Как правило, компилятор может перехватить подобную ошибку, но синтаксис <codeph>this[]</codeph> в инструкции <codeph>try</codeph> обходит синтаксис компилятора, проверяющего функцию.
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentErrorExample extends Sprite {
        public function ArgumentErrorExample() {
                println("Hello World");
                
                try {
                    this["println"]("Hello", "World");
                }
                catch(e:ArgumentError) {
                    trace(e);
                }
        }
        
        public function println(str:String):void {
            trace(str);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="ArgumentError:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
	 Создает объект ArgumentError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Строка, связанная с ошибкой.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает объект ArgumentError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:QName"><apiName>QName</apiName><shortdesc>

Объекты QName представляют полные имена элементов и атрибутов XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>QName
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Объекты QName представляют полные имена элементов и атрибутов XML. У каждого объекта QName существует локальное имя и унифицированный идентификатор ресурса пространства имен (URI). Если в качестве значения пространства имен выбрано <codeph>null</codeph>, объект QName совпадает с любым пространством имен. Создайте с помощью конструктора QName новый объект QName, который либо является копией другого объекта QName либо представляет собой новый объект QName, для которого параметр <codeph>uri</codeph> берется из объекта Namespace, а параметр <codeph>localName</codeph> - из объекта QName. 
 

<p>Применяя методы, относящиеся к E4X, можно использовать поочередно строки и объекты QName. Методы E4X представлены в классах QName, Namespace, XML и XMLList. Эти методы принимают как строки, так и объекты QName. Эта взаимозаменяемость проявляется, например, в том, как поддержка пространства имен обрабатывает метод <codeph>XML.child()</codeph>. </p>

<p>В классе QName (а также в классах XML, XMLList и Namespace) реализованы мощные стандарты обработки XML, определенные в языке ECMAScript для спецификации XML E4X (ECMA-357, второе издание).</p>

<p>Результаты оценки с помощью классифицированного идентификатора записываются в объект QName. Если объект QName элемента XML задается без указания пространства имен, свойству <codeph>uri</codeph> связанного объекта QName присваивается значение глобального пространства имен по умолчанию. Если объект QName атрибута XML задается без указания пространства имен, свойству <codeph>uri</codeph> присваивается пустая строка.</p>

</apiDesc><example conref="examples\QNameExample.as"> В следующем примере показан способ создания экземпляра QName и его применения для выбора элементов XML. Демонстрируются два метода использования QName:
 <ol>
    <li>Создание экземпляра пространства имен и последующее использование его в качестве входных данных для конструктора QName. Этот подход является наилучшим, если необходимо позднее воспользоваться свойством <codeph>Namespace.prefix</codeph> в других целях.</li>
  <li>Создание экземпляра QName с помощью простого строчного значения параметра <codeph>uri</codeph> в конструкторе QName.</li>
 </ol>
 <p>
 Этот код выполняет следующие функции:
 </p>
 <ol>
  <li>Определяет переменную XML с именем <codeph>rssXML</codeph>.</li>
    <li>Создает новый объект Namespace с префиксом <codeph>dc</codeph>.</li>
  <li>Создает новый объект QName с помощью объекта Namespace, которому присваивается локальное имя <codeph>creator</codeph>.</li>
  <li>Вызывает метод <codeph>showDescendants()</codeph>, использующий метод <codeph>XML.descendants()</codeph> для получения экземпляра XMLList, в котором содержатся все элементы-потомки, классифицированное имя которых соответствует данному экземпляру QName.</li>
    <li>Показывает классифицированное имя и текстовое значение каждого элемента в списке с помощью цикла <codeph>for each</codeph>.</li>
  <li>Создает еще один объект QName, применяя строковое значение параметра <codeph>uri</codeph> и локальное имя <codeph>date</codeph>.</li>
  <li>Снова вызывает метод <codeph>showDescendants()</codeph> для показа имени и текстового значения элементов-потомков.</li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    
    public class QNameExample extends Sprite
    {
        public function QNameExample()
        {
            var rssXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/">
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            var dcNamespace:Namespace = new Namespace("dc", "http://purl.org/dc/elements/1.1/");
            var creatorQName:QName = new QName(dcNamespace, "creator");
            trace(creatorQName.uri); // http://purl.org/dc/elements/1.1/
            trace(creatorQName.localName); // creator
            
            showDescendants(rssXML, creatorQName);
            
            var dateQName:QName = new QName("http://purl.org/dc/elements/1.1/", "date");
            trace(dateQName.uri); // http://purl.org/dc/elements/1.1/
            trace(dateQName.localName); // date
            
            showDescendants(rssXML, dateQName);
        }
        
        public function showDescendants(xmlData:XML, qualifiedName:QName):void
        {
            var decendantList:XMLList = xmlData.descendants(qualifiedName);
            
            for each (var element:XML in decendantList)
            {
                trace(element.name()); // the fully qualified name, 
                                       // like "http://purl.org/dc/elements/1.1/::creator"
                trace(element); // the simple text value of each element, like "Adobe"
            }                
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Спецификация языка ECMAScript для XML E4X (ECMA-357, второе издание)</linktext></link></related-links><apiConstructor id="QName:QName_0"><apiName>QName</apiName><shortdesc> 
    Создает объект QName с объектом URI из объекта Namespace и свойством localName из объекта QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName
    </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Объект Namespace, из которого копируется значение <codeph>uri</codeph>. Параметр любого другого типа преобразуется в строку.
    </apiDesc></apiParam><apiParam><apiItemName>localName</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>Объект QName, из которого копируется значение <codeph>localName</codeph>. Параметр любого другого типа преобразуется в строку.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    Создает объект QName с объектом URI из объекта Namespace и свойством <codeph>localName</codeph> из объекта QName. Если любой из параметров не относится к ожидаемому типу данных, то он преобразуется в строку и присваивается соответствующему свойству нового объекта QName. Например, если оба параметра представляют собой строки, возвращается новый объект QName. При этом свойство <codeph>uri</codeph> устанавливается для первого параметра, а свойство <codeph>localName</codeph> — для второго параметра. Иными словами, следующие перестановки наряду со многими другими являются действительными формами конструктора:
<pre>
QName (uri:Namespace, localName:String);
QName (uri:String, localName: QName);
QName (uri:String, localName: String);
</pre>
    <p>Если значение <codeph>null</codeph> передается для параметра <codeph>uri</codeph>, свойство <codeph>uri</codeph> нового объекта QName получает значение <codeph>null</codeph>.
    </p>
    <p><b>Примечание.</b> В этом классе показаны две записи конструктора, поскольку каждая из них поддерживает разные параметры. Режим работы конструктора меняется в зависимости от типа и количества переданных параметров (см. описание в записях). ActionScript 3.0 не поддерживает переопределение метода или конструктора.</p>
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="QName:QName_1"><apiName>QName</apiName><shortdesc> 
    Создает объект QName, который является копией другого объекта QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>(pdehaan) i changed first param from "name" to "uri" as the previous naming was very confusing
    </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>qname</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>Копируемый объект QName. Объекты других типов преобразуются в строки, которые присваиваются свойству <codeph>localName</codeph> нового объекта QName.
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    Создает объект QName, который является копией другого объекта QName. Если переданный конструктору параметр является объектом QName, создается копия объекта QName. Если параметр не является объектом QName, то он преобразуется в строку и присваивается свойству <codeph>localName</codeph> нового экземпляра QName. Если параметр <codeph>undefined</codeph> (не определен) или не указан, создается новый объект QName, где для свойства <codeph>localName</codeph> выбрана пустая строка.
    <p><b>Примечание.</b> В этом классе показаны две записи конструктора, поскольку каждая из них поддерживает разные параметры. Режим работы конструктора меняется в зависимости от типа и количества переданных параметров (см. описание в записях). ActionScript 3.0 не поддерживает переопределение метода или конструктора.</p>
    
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="QName:AS3:toString"><apiName>toString</apiName><shortdesc>
	Возвращает строку, составленную из URI и локального имени для объекта QName, разделенных символами «::».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Полное имя в виде строки.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает строку, составленную из URI и локального имени для объекта QName, разделенных символами «::».
	
	<p>Формат зависит от свойства <codeph>uri</codeph> объекта QName:</p>
	<pre>If <codeph>uri</codeph> == "" 
		<codeph>toString</codeph> returns <codeph>localName</codeph>
	else if <codeph>uri</codeph> == null
		<codeph>toString</codeph> returns ~~::<codeph>localName</codeph> 
	else
		<codeph>toString</codeph> returns <codeph>uri</codeph>::<codeph>localName</codeph></pre>
	
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="QName:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    Возвращает объект QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Элементарное значение экземпляра QName.
    
    </apiDesc><apiOperationClassifier>QName</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    Возвращает объект QName.
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="QName:localName:get"><apiName>localName</apiName><shortdesc>
	Локальное имя объекта QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.localName, localName
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Локальное имя объекта QName.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="QName:uri:get"><apiName>uri</apiName><shortdesc>
	Унифицированный идентификатор ресурса (URI-адрес) объекта QName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Унифицированный идентификатор ресурса (URI-адрес) объекта QName.
 	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:EvalError"><apiName>EvalError</apiName><shortdesc>
 Класс EvalError представляет ошибку, возникающую при вызове пользовательским кодом функции eval(), либо если пользовательский код пытается использовать оператор new с объектом Function.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Исключение EvalError создается, когда в коде проводится попытка вызова функции eval() или использования операции new с объектом Function.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс EvalError представляет ошибку, возникающую при вызове пользовательским кодом функции <codeph>eval()</codeph>, либо если пользовательский код пытается использовать оператор <codeph>new</codeph> с объектом Function. Вызов <codeph>eval()</codeph> и <codeph>new</codeph> по отношению к объекту Function не поддерживается.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="EvalError:EvalError"><apiName>EvalError</apiName><shortdesc>
	 Создает новый объект EvalError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Строка, связанная с ошибкой.     
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект EvalError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Math"><apiName>Math</apiName><shortdesc>
 Класс Math содержит методы и константы, представляющие общие математические функции и значения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math, math object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Класс Math располагается на верхнем уровне и состоит из статических свойств и методов, определяющих стандартные математические константы и функции.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Math содержит методы и константы, представляющие общие математические функции и значения. 
 <p>Эти методы и свойства используются для вызова и обработки математических констант и функций. Все свойства и методы класса Math являются статическими и должны вызываться с помощью синтаксиса <codeph>Math.method(</codeph><codeph><i>параметр</i></codeph><codeph>)</codeph> или <codeph>Math.constant</codeph>. В ActionScript константы определяются с максимальной точностью (двойная точность чисел с плавающей запятой IEEE-754).</p>
 <p>В нескольких методах класса Math в качестве параметра используется величина угла в радианах. Рассчитывать значения в радианах перед вызовом метода и вводить их в качестве параметра можно с помощью указанного ниже уравнения. Также допускается ввод всей правой части уравнения (с величиной угла в градусах вместо <codeph>градусов</codeph>) в качестве параметра радиан.</p>
 <p>Для вычисления значения в радианах используйте следующую формулу:</p>
 <pre>
 radians = degrees ~~ Math.PI/180
 </pre>
 <p>Эта формула позволяет перевести градусы в радианы:</p>
 <pre>
 degrees = radians ~~ 180/Math.PI
 </pre>
 <p>В данном примере уравнение применяется как параметр для расчета синуса угла в 45°:</p>
 <p><codeph>Math.sin(45 ~~ Math.PI/180)</codeph> эквивалентно <codeph>Math.sin(.7854)</codeph></p>
 <p><b>Примечание.</b> Результаты применения функций класса Math (acos, asin, atan, atan2, cos, exp, log, pow, sin и sqrt) могут немного различаться в зависимости от алгоритмов, используемых ЦП или операционной системой. Flash Player направляет вызов ЦП (или операционной системе, если ЦП не поддерживает вычисления с плавающей запятой) при выполнении расчетов по функциям, входящим в список. Наблюдается незначительный разброс результатов, который зависит от используемого ЦП или операционной системы.
 </p>
 
 
 </apiDesc></apiClassifierDetail><apiOperation id="Math:abs"><apiName>abs</apiName><shortdesc>
  Вычисляет и возвращает абсолютное значение числа, заданное параметром val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.abs, abs, absolute
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Абсолютное значение заданного параметра.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, абсолютное значение которого возвращается.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает абсолютное значение указанного объекта Number.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает абсолютное значение числа, заданное параметром <codeph>val</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:acos"><apiName>acos</apiName><shortdesc>
  Вычисляет и возвращает арккосинус числа, заданного параметром val в радианах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.acos, acos, arc cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Арккосинус параметра <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число от -1.0 до 1.0.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает арккосинус заданного объекта Number в радианах. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает арккосинус числа, заданного параметром <codeph>val</codeph> в радианах.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:asin"><apiName>asin</apiName><shortdesc>
  Вычисляет и возвращает в радианах арксинус числа, заданного параметром val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.asin, asin, arc sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Число (от отрицательного числа «пи», разделенного на 2 до положительного числа «пи», разделенного на 2).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число от -1.0 до 1.0.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает в радианах значение арксинуса заданного параметра объекта Number.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает в радианах арксинус числа, заданного параметром <codeph>val</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan"><apiName>atan</apiName><shortdesc>
  Вычисляет и возвращает в радианах величину угла, тангенс которого указан в параметре val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan, atan, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Число (от отрицательного числа «пи», разделенного на 2 до положительного числа «пи», разделенного на 2).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, соответствующее тангенсу угла.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает в радианах угол, тангенс которого задан параметром val.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает в радианах величину угла, тангенс которого указан в параметре <codeph>val</codeph>. Возвращаемое значение лежит в диапазоне от отрицательного числа «пи», разделенного на 2 до положительного числа «пи», разделенного на 2.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan2"><apiName>atan2</apiName><shortdesc>
  Вычисляет и возвращает в радианах угол точки y/x, измеренный против часовой стрелки от оси x окружности (где 0,0 соответствует центру круга).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan2, atan2, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Число.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>y</i> точки.
  </apiDesc></apiParam><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>x</i> точки.  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает в радианах угол точки «y/x», измеренный против часовой стрелки от оси «x» окружности.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает в радианах угол точки <codeph>y</codeph>/<codeph>x</codeph>, измеренный против часовой стрелки от оси <i>x</i> окружности (где 0,0 соответствует центру круга). Возвращаемое значение лежит в диапазоне от числа «пи» до отрицательного числа «пи». Учтите, что первый параметр atan2 всегда является координатой <i>y</i>.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:ceil"><apiName>ceil</apiName><shortdesc>
  Возвращает максимальное значение заданного числа или выражения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ceil, ceil, ceiling
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Целое число, которое является ближайшим и одновременно больше или равно значению параметра <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает максимальное значение заданного числа или выражения.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Возвращает максимальное значение заданного числа или выражения. Максимальное значение числа – это ближайшее целое число, которое превышает это число или равно ему.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/floor()"><linktext>Math.floor()</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="Math:cos"><apiName>cos</apiName><shortdesc>
  Вычисляет и возвращает косинус указанного угла в радианах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.cos, cos, cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Число от -1.0 до 1.0.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, представляющее угол, измеренный в радианах. 
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает косинус заданного угла.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает косинус указанного угла в радианах. Чтобы вычислить значение в радианах, см. обзор класса Math.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:exp"><apiName>exp</apiName><shortdesc>
  Возвращает основание натурального логарифма (e), возведенное в степень, показатель которой задан параметром x.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.exp, exp, exponent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc><i>e</i> в степени, определенной параметром <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Показатель; число или выражение.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает основание натурального логарифма (e), возведенное в степень, показатель которой задан параметром val.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Возвращает основание натурального логарифма (<i>e </i>), возведенное в степень, показатель которой задан параметром <codeph>x</codeph>. Константа <codeph>Math.E</codeph> может использоваться для подстановки значения <i>e</i>.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/E"><linktext>Math.E</linktext></link></related-links></apiOperation><apiOperation id="Math:floor"><apiName>floor</apiName><shortdesc>
  Возвращает наименьшее значение числа или выражения, заданного параметром val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.floor, floor
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Целое число, которое является ближайшим и одновременно меньше или равно значению параметра <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает наименьшее значение числа или выражения, заданного параметром val.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Возвращает наименьшее значение числа или выражения, заданного параметром <codeph>val</codeph>. Наименьшее значение – это ближайшее целое число, которое не превышает или равняется заданному числу или выражению.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:log"><apiName>log</apiName><shortdesc>
  Возвращает натуральный логарифм параметра val.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log, log, logarithm
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Возвращает натуральный логарифм параметра <codeph>val</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение, значение которого больше 0.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает натуральный логарифм параметра val. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Возвращает натуральный логарифм параметра <codeph>val</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:max"><apiName>max</apiName><shortdesc>
  Оценивает val1 и val2 (или дополнительные значения) и возвращает самое большое значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.max, max, maximum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Самое большое из значений параметров <codeph>val1</codeph> и <codeph>val2</codeph> (или дополнительные значения).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение.
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение.
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Число или выражение. <codeph>Math.max()</codeph> поддерживает несколько аргументов.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Оценивает параметры val1 и val2 и возвращает большее из двух значений.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Оценивает <codeph>val1</codeph> и <codeph>val2</codeph> (или дополнительные значения) и возвращает самое большое значение.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/min()"><linktext>Math.min()</linktext></link></related-links></apiOperation><apiOperation id="Math:min"><apiName>min</apiName><shortdesc>
  Оценивает val1 и val2 (или дополнительные значения) и возвращает наименьшее значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.min, min, minimum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Наименьшее значение параметров <codeph>val1</codeph> и <codeph>val2</codeph> (или дополнительные значения).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение.
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение.
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Число или выражение. <codeph>Math.min()</codeph> поддерживает несколько аргументов.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Оценивает параметры val1 и val2 и возвращает меньшее из двух значений.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Оценивает <codeph>val1</codeph> и <codeph>val2</codeph> (или дополнительные значения) и возвращает наименьшее значение.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/max()"><linktext>Math.max()</linktext></link></related-links></apiOperation><apiOperation id="Math:pow"><apiName>pow</apiName><shortdesc>
  Вычисляет и возвращает base, возведенное в степень pow.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pow, pow, power
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Значение <codeph>base</codeph>, возведенное в степень <codeph>pow</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>base</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, которое требуется возвести в степень, определяемую параметром <codeph>pow</codeph>.
  </apiDesc></apiParam><apiParam><apiItemName>pow</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее степень, в которую возводится параметр <codeph>base</codeph>.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает параметр val1 в степени параметра val2.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает <codeph>base</codeph>, возведенное в степень <codeph>pow</codeph>.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:random"><apiName>random</apiName><shortdesc>
  Возвращает псевдослучайное число n, где 0 &amp;lt;= n &amp;lt; 1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.random, random
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Псевдослучайное число.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Возвращает псевдослучайное число n, где 0 &lt;= n &lt; 1.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Возвращает псевдослучайное число n, где 0 &lt;= n &lt; 1. Возвращаемое число вычисляется скрытым образом и является псевдослучайным, поскольку расчет неизбежно несет в себе определенный элемент псевдослучайности.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:round"><apiName>round</apiName><shortdesc>
  Округляет значение параметра val в большую или меньшую сторону до ближайшего целого числа и возвращает это значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.round, round
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Параметр <codeph>val</codeph>, округленный до ближайшего целого числа.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Округляемое число.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает значение параметра val, округленное в большую или меньшую сторону до ближайшего целого числа.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Округляет значение параметра <codeph>val</codeph> в большую или меньшую сторону до ближайшего целого числа и возвращает это значение. Если значение <codeph>val</codeph> равноудалено от двух ближайших целых чисел (когда в конце числа стоит «,5»), оно округляется в большую сторону до ближайшего целого числа.
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/ceil()"><linktext>Math.ceil()</linktext></link><link href="#Math/floor()"><linktext>Math.floor()</linktext></link></related-links></apiOperation><apiOperation id="Math:sin"><apiName>sin</apiName><shortdesc>
  Вычисляет и возвращает синус указанного угла в радианах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sin, sin, sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Число; синус указанного угла (от -1,0 до 1,0).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, представляющее угол, измеренный в радианах.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает синус заданного угла.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает синус указанного угла в радианах. Чтобы вычислить значение в радианах, см. обзор класса Math.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:sqrt"><apiName>sqrt</apiName><shortdesc>
  Вычисляет и возвращает квадратный корень заданного числа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt, sqrt, square root 
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Если параметр <codeph>val</codeph>больше или равен нулю, выдается значение; в противном случае выдается <codeph>NaN</codeph> (не число).
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число или выражение, которое больше или равно 0. 
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает квадратный корень заданного числа.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает квадратный корень заданного числа.
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:tan"><apiName>tan</apiName><shortdesc>
  Вычисляет и возвращает тангенс заданного угла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.tan, tan, tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Тангенс параметра <codeph>angleRadians</codeph>.
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, представляющее угол, измеренный в радианах.
  </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает тангенс заданного угла.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вычисляет и возвращает тангенс заданного угла. Чтобы вычислить значение в радианах, см. обзор класса Math.
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link></related-links></apiOperation><apiValue id="Math:E"><apiName>E</apiName><shortdesc>
  Математическая константа, которая используется в качестве основания для натуральных логарифмов. Обозначается буквой e.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.e, e
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.71828182845905</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа, которая используется в качестве основания для натуральных логарифмов. Обозначается буквой e.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа, которая используется в качестве основания для натуральных логарифмов. Обозначается буквой <i>e</i>. Приблизительное значение <i>e</i><codeph> </codeph> составляет 2,71828182845905.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN10"><apiName>LN10</apiName><shortdesc>
  Математическая константа – натуральный логарифм числа 10. Обозначается как loge10, приблизительное значение равно 2,302585092994046.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln10, ln10, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.302585092994046</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа – натуральный логарифм числа 10. Обозначается как loge10, приблизительное значение равно 2,302585092994046.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа – натуральный логарифм числа 10. Обозначается как log<sub>e</sub>10, приблизительное значение равно 2,302585092994046.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN2"><apiName>LN2</apiName><shortdesc>
  Математическая константа – натуральный логарифм числа 2. Обозначается как loge2, приблизительное значение равно 0,6931471805599453.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln2, ln2, natural logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.6931471805599453</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа – натуральный логарифм числа 2. Обозначается как loge2, приблизительное значение равно 0,6931471805599453.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа – натуральный логарифм числа 2. Обозначается как log<sub>e</sub>2, приблизительное значение равно 0,6931471805599453.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG10E"><apiName>LOG10E</apiName><shortdesc>
  Математическая константа – десятичный логарифм числа e (Math.E). Обозначается как log10e, приблизительное значение равно 0,4342944819032518.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log10e, log10e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.4342944819032518</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа, равная логарифму числа «e» по основанию 10. Обозначается как log10e, приблизительное значение равно 0,4342944819032518.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа – десятичный логарифм числа <i>e</i> (<codeph>Math.E</codeph>). Обозначается как log<sub>10</sub>e, приблизительное значение равно 0,4342944819032518. 
  <p>Метод <codeph>Math.log()</codeph> используется для вычисления натурального логарифма числа. Умножьте результат выполнения метода <codeph>Math.log()</codeph> на <codeph>Math.LOG10E</codeph> для получения десятичного логарифма.</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG2E"><apiName>LOG2E</apiName><shortdesc>
  Математическая константа – логарифм числа e по основанию 2. Обозначается как log2e, приблизительное значение равно 1,442695040888963387.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log2e, log2e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.442695040888963387</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа – логарифм числа e по основанию 2. Обозначается как log2e, приблизительное значение равно 1,442695040888963387.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа – логарифм числа <i>e</i> по основанию 2. Обозначается как log2e, приблизительное значение равно 1,442695040888963387.
  
  <p>Метод <codeph>Math.log</codeph> используется для вычисления натурального логарифма числа. Умножьте результат выполнения метода <codeph>Math.log()</codeph> на <codeph>Math.LOG2E</codeph> для получения логарифма по основанию 2.</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:PI"><apiName>PI</apiName><shortdesc>
  Математическая константа – отношение длины окружности к диаметру. Обозначается как «pi», приблизительное значение равно 3,141592653589793.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pi, pi
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3.141592653589793</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа – отношение длины окружности к диаметру. Обозначается как «pi», приблизительное значение равно 3,141592653589793.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа – отношение длины окружности к диаметру. Обозначается как «pi», приблизительное значение равно 3,141592653589793.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT1_2"><apiName>SQRT1_2</apiName><shortdesc> 
  Математическая константа – квадратный корень из одной второй, приблизительное значение равно 0,7071067811865476.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt1_2, sqrt1_2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.7071067811865476</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа – квадратный корень из одной второй, приблизительное значение равно 0,7071067811865476.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
  Математическая константа – квадратный корень из одной второй, приблизительное значение равно 0,7071067811865476.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT2"><apiName>SQRT2</apiName><shortdesc>
  Математическая константа – квадратный корень из 2, приблизительное значение равно 1,4142135623730951.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt2, sqrt2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.4142135623730951</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Математическая константа – квадратный корень из 2, приблизительное значение равно 1,4142135623730951.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Математическая константа – квадратный корень из 2, приблизительное значение равно 1,4142135623730951.
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Array"><apiName>Array</apiName><shortdesc>
 Класс Array обеспечивает доступ к массивам и их обработку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Array, Array object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Позволяет получать доступ к индексированным массивам для выполнения различных операций.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Array обеспечивает доступ к массивам и их обработку. Индексы массива начинаются с нуля. Это значит, что первый элемент массива имеет индекс <codeph>[0]</codeph>, второй элемент — индекс <codeph>[1]</codeph> и т. д. Чтобы создать объект Array, можно воспользоваться конструктором <codeph>new Array()</codeph>. Объект <codeph>Array()</codeph> можно также вызвать в виде функции. Кроме того, можно воспользоваться оператором доступа к массиву (<codeph>[]</codeph>), чтобы инициализировать массив или выполнить доступ к его элементам. 
 <p>В элементе массива можно сохранять широкий спектр типов данных, включая числа, строки, объекты и даже другие массивы. Можно создать <i>многомерный массив</i>. Для этого нужно создать индексированный массив и присвоить каждому из его элементов другой индексированный массив. Такой массив считается многомерным, поскольку его можно использовать для представления данных в виде таблицы.</p>
 <p> Массивы являются <i>разреженными</i>. Это значит, что один элемент может иметь индекс 0, а другой — индекс 5, но позиции индекса между двумя этими элементами будут пустыми. В подобном случае элементы на позициях с 1 по 4 не определены, что указывает на отсутствие элемента, а не обязательно на присутствие элемента со значением <codeph>undefined</codeph>.</p>
 
 <p>Присваивание массива выполняется по ссылке, а не по значению. Когда одна переменная массива присваивается другой переменной массива, они обе относятся к одному и тому же массиву:</p>
 <codeblock>
 var oneArray:Array = new Array("a", "b", "c");
 var twoArray:Array = oneArray; // Both array variables refer to the same array.
 twoArray[0] = "z";             
 trace(oneArray);               // Output: z,b,c.
 </codeblock>
 <p>Не применяйте класс Array для создания <i>массивов ассоциативных элементов</i> (называемых также <i>хэшами</i>), которые представляют собой структуры данных, элементам которых присваиваются имена, а не числа. Чтобы создать массивы ассоциативных элементов, воспользуйтесь классом Object. Хотя ActionScript позволяет создавать массивы ассоциативных элементов с помощью класса Array, ни один из методов и свойств класса Array нельзя использовать с этими массивами. </p>
 <p>Класс Array можно расширить, переопределив или добавив методы. Однако этот подкласс необходимо сделать <codeph>dynamic</codeph>, чтобы не утратить возможность сохранения данных в массиве.</p>
 
 </apiDesc><example conref="examples\ArrayExample.as"> В следующем примере создается новый объект Array <codeph>myArr</codeph> без аргументов и с первоначальной длиной равной 0:
<codeblock>
package {
    import flash.display.Sprite;

    public class ArrayExample extends Sprite {
        public function ArrayExample() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] (array access)</linktext></link><link href="#Object"><linktext>класс Object</linktext></link></related-links><apiConstructor id="Array:Array_0"><apiName>Array</apiName><shortdesc>
	 Позволяет создавать массивы с заданным числом элементов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Аргумент — это число, которое не является целым числом большим или равным 0.	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>numElements</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число, указывающее количество элементов в массиве.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Позволяет создавать массивы с заданным числом элементов. Если не указать никаких параметров, создается массив с нулевым количеством элементов. Если указан ряд элементов, создается массив с количеством элементов <codeph>numElements</codeph>. 
     <p><b>Примечание.</b> В этом классе показаны две записи метода конструктора, поскольку конструктор поддерживает разные типы аргументов. Режим работы конструктора меняется в зависимости от типа и количества переданных аргументов (см. описание в записях). ActionScript 3.0 не поддерживает переопределение метода или конструктора.</p>
     
	 
	 </apiDesc><example conref="examples\Array_Array.as"> В следующем примере создается новый объект Array <codeph>myArr</codeph> без аргументов и с первоначальной длиной 0:
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array extends Sprite {

        public function Array_Array() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example><example conref="examples\Array_Array_2.as"> В следующем примере создается объект Array с 5 начальными элементами и длиной 5. Первый элемент заполняется строкой <codeph>one</codeph>, а в конец массива добавляется строковый элемент <codeph>six</codeph> с помощью метода <codeph>push()</codeph>:
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_2 extends Sprite {

        public function Array_Array_2() {
            var myArr:Array = new Array(5);
            trace(myArr.length); // 5
            myArr[0] = "one";
            myArr.push("six");
            trace(myArr);         // one,,,,,six
            trace(myArr.length); // 6
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[] array access</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiConstructor id="Array:Array_1"><apiName>Array</apiName><shortdesc>
	 Позволяет создавать массив, содержащий заданные элементы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Аргумент — это число, которое не является целым числом большим или равным 0.	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Список из одного или нескольких произвольных значений, разделенных запятыми. 
	 <p><b>Примечание.</b> Если в конструктор Array передается единичный числовой параметр, предполагается, что указано свойство массива <codeph>length</codeph>.</p>
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Позволяет создавать массив, содержащий заданные элементы. Можно указывать значения любого типа. Первый элемент в массиве всегда имеет индекс (или позицию) 0.
     <p><b>Примечание.</b> В этом классе показаны две записи конструктора, поскольку конструктор поддерживает разные типы аргументов. Режим работы конструктора меняется в зависимости от типа и количества переданных аргументов (см. описание в записях). ActionScript 3.0 не поддерживает переопределение метода или конструктора.</p>
	 </apiDesc><example conref="examples\Array_Array_3.as"> В следующем примере создается новый объект Array с первоначальной длиной 3, массив заполняется строковыми элементами <codeph>one</codeph>, <codeph>two</codeph> и <codeph>three</codeph>, а затем элементы преобразуются в строку.
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_3 extends Sprite {

        public function Array_Array_3() {
            var myArr:Array = new Array("one", "two", "three");
            trace(myArr.length); // 3
            trace(myArr);          // one,two,three
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[] array access</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiOperation id="Array:AS3:concat"><apiName>concat</apiName><shortdesc>
	 Указанные в параметрах элементы сцепляются с элементами в массиве, и создается новый массив.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив, содержащий элементы из этого массива, за которыми указаны элементы из параметров.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Значение любого типа данных (например, числа, элементы или строки), которые необходимо сцепить в новом массиве. Если значения не передаются, новый массив дублирует исходный массив.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Сцепляет элементы, заданные в параметрах.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Указанные в параметрах элементы сцепляются с элементами в массиве, и создается новый массив. Если параметры задают массив, элементы этого массива сцепляются. 
 	 
 	 </apiDesc><example conref="examples\Array.concat.1.as"> Следующий код создает четыре объекта Array:
 <ul>
   <li>Массив <codeph>numbers</codeph>, содержащий цифры <codeph>1</codeph>, <codeph>2</codeph> и <codeph>3</codeph>. </li>
   <li>Массив <codeph>letters</codeph>, содержащий буквы <codeph>a</codeph>, <codeph>b</codeph> и <codeph>c</codeph>. </li>
   <li>Массив <codeph>numbersAndLetters</codeph>, вызывающий метод <codeph>concat()</codeph> для создания массива <codeph>[1,2,3,a,b,c]</codeph>. </li>
   <li>Массив <codeph>lettersAndNumbers</codeph>, вызывающий метод <codeph>concat()</codeph> для создания массива <codeph>[a,b,c,1,2,3]</codeph>. </li>
 </ul>
<codeblock>

var numbers:Array = new Array(1, 2, 3);
var letters:Array = new Array("a", "b", "c");
var numbersAndLetters:Array = numbers.concat(letters);
var lettersAndNumbers:Array = letters.concat(numbers);

trace(numbers);       // 1,2,3
trace(letters);       // a,b,c
trace(numbersAndLetters); // 1,2,3,a,b,c
trace(lettersAndNumbers); // a,b,c,1,2,3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:every"><apiName>every</apiName><shortdesc>
	 Выполняет тестовую функцию для каждого элемента массива, пока не будет достигнут элемент, возвращающий значение false для заданной функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Логическое значение <codeph>true</codeph>, если все элементы в массиве возвращают значение <codeph>true</codeph> для указанной функции; в противном случае присваивается значение <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом массива. Эта функция может содержать простое сравнение (например, <codeph>item &lt; 20</codeph>) или более сложную операцию. Она вызывается по трем аргументам: значению элемента, индексу элемента и объекту Array:
     <pre>function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Объект, используемый для этой функции в качестве <codeph>this</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет тестовую функцию для каждого элемента массива, пока не будет достигнут элемент, возвращающий значение <codeph>false</codeph> для заданной функции. Этот метод используется для того, чтобы определить, все ли элементы массива соответствуют критерию (например, их значения должны быть меньше определенного числа).
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Предположим, что функция создается во фрагменте ролика с названием <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Допустим, что используется метод <codeph>every()</codeph> по отношению к массиву <codeph>myArray</codeph>:</p>
     <pre product="flash">
     myArray.every(myFunction, me);
     </pre>
     <p product="flash">Поскольку <codeph>myFunction</codeph> принадлежит классу Timeline, который не может быть переопределен фрагментом ролика <codeph>me</codeph>, Flash Player создает исключение. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
     };
     myArray.every(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array_every.as"> В следующем примере тестируются два массива, чтобы определить, является ли каждый элемент того или иного массива числом. Указываются также результаты теста: параметр <codeph>isNumeric</codeph> имеет значение <codeph>true</codeph> для первого массива и <codeph>false</codeph> для второго:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_every extends Sprite {
        public function Array_every() {
            var arr1:Array = new Array(1, 2, 4);
            var res1:Boolean = arr1.every(isNumeric);
            trace("isNumeric:", res1); // true
 
            var arr2:Array = new Array(1, 2, "ham");
            var res2:Boolean = arr2.every(isNumeric);
            trace("isNumeric:", res2); // false
        }
        private function isNumeric(element:*, index:int, arr:Array):Boolean {
            return (element is Number);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/some()"><linktext>Array.some()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:filter"><apiName>filter</apiName><shortdesc>
	 Выполняет тестовую функцию для каждого элемента массива и формирует новый массив из всех элементов, возвращающих значение true для заданной функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новый массив, содержащий все элементы исходного массива, вернувшие значение <codeph>true</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом массива. Эта функция может содержать простое сравнение (например, <codeph>item &lt; 20</codeph>) или более сложную операцию. Она вызывается по трем аргументам: значению элемента, индексу элемента и объекту Array:
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Объект, используемый для этой функции в качестве <codeph>this</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет тестовую функцию для каждого элемента массива и формирует новый массив из всех элементов, возвращающих значение <codeph>true</codeph> для заданной функции. Если элемент возвращает значение <codeph>false</codeph>, он не включается в новый массив.
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Предположим, что функция создается во фрагменте ролика с названием <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Допустим, что используется метод <codeph>filter()</codeph> по отношению к массиву с именем <codeph>myArray</codeph>:</p>
     <pre product="flash"> 
     myArray.filter(myFunction, me);
     </pre>
     <p product="flash">Поскольку <codeph>myFunction</codeph> принадлежит классу Timeline, который не может быть переопределен фрагментом ролика <codeph>me</codeph>, Flash Player создает исключение. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.filter(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array.filter.as"> В следующем примере создается массив из всех сотрудников-менеджеров:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_filter extends Sprite {
        public function Array_filter() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace("Employees:");
            employees.forEach(traceEmployee);
            
            var managers:Array = employees.filter(isManager);
            trace("Managers:");
            managers.forEach(traceEmployee);
        }
        private function isManager(element:*, index:int, arr:Array):Boolean {
            return (element.manager == true);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace("\t" + element.name + ((element.manager) ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/map()"><linktext>Array.map()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:forEach"><apiName>forEach</apiName><shortdesc>
	 Выполняет функцию для каждого элемента массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом массива. Эта функция может содержать простую команду (например, инструкция <codeph>trace()</codeph>) или более сложную операцию. Она вызывается по трем аргументам: значению элемента, индексу элемента и объекту Array:
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Объект, используемый для этой функции в качестве <codeph>this</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет функцию для каждого элемента массива.
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Предположим, что функция создается во фрагменте ролика с названием <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Допустим, что используется метод <codeph>forEach()</codeph> по отношению к массиву с именем <codeph>myArray</codeph>:</p>
     <pre product="flash">
     myArray.forEach(myFunction, me);
     </pre>
     <p product="flash">Поскольку <codeph>myFunction</codeph> принадлежит классу Timeline, который не может быть переопределен фрагментом ролика <codeph>me</codeph>, Flash Player создает исключение. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.forEach(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_forEach.as"> В следующем примере инструкция <codeph>trace()</codeph> выполняется в функции <codeph>traceEmployee()</codeph> по отношению к каждому элементу массива:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach extends Sprite {
        public function Array_forEach() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace(employees);
            employees.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace(element.name + " (" + element.manager + ")");
        }
    }
}
</codeblock></example><example conref="examples\Array_forEach_2.as"> В следующем примере инструкция <codeph>trace()</codeph> также выполняется в немного измененной функции <codeph>traceEmployee()</codeph> по отношению к каждому элементу массива:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach_2 extends Sprite {
        public function Array_forEach_2() {
            var employeeXML:XML = &lt;employees>
                    &lt;employee name="Steven" manager="false" />
                    &lt;employee name="Bruce" manager="true" />
                    &lt;employee name="Rob" manager="false" />
                &lt;/employees>;
            var employeesList:XMLList = employeeXML.employee;
            var employeesArray:Array = new Array();
            for each (var tempXML:XML in employeesList) {
                employeesArray.push(tempXML);
            }
            employeesArray.sortOn("@name");
            employeesArray.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:Number, arr:Array):void {
            trace(element.@name + ((element.@manager == "true") ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 Ищет элемент в массиве с использованием строгого равенства (===) и возвращает позицию элемента в индексе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Позиция индекса, начинающегося с нуля, для элемента массива. Если аргумент <codeph>searchElement</codeph> не найден, возвращается значение «-1».
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>Элемент, который нужно найти в массиве.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Место в массиве, в которого начинается поиск элемента.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ищет элемент в массиве с использованием строгого равенства <codeph>(===)</codeph> и возвращает позицию элемента в индексе.
	 </apiDesc><example conref="examples\Array_indexOf.as"> В следующем примере показана позиция указанного массива:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_indexOf extends Sprite {
        public function Array_indexOf() {
            var arr:Array = new Array(123,45,6789);
            arr.push("123-45-6789");
            arr.push("987-65-4321");
            
            var index:int = arr.indexOf("123");
            trace(index); // -1
            
            var index2:int = arr.indexOf(123);
            trace(index2); // 0
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/lastIndexOf()"><linktext>Array.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:join"><apiName>join</apiName><shortdesc>
	 Преобразует элементы массива в строки, вставляет указанный разделитель между элементами, сцепляет их и возвращает получившуюся строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.join, join
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строка, состоящая из элементов массива, преобразованных в строки и разделенных указанным параметром.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Символ или строка, которые разделяют элементы массива в возвращенной строке. Если этот параметр пропустить, в качестве разделителя по умолчанию используется запятая. 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Преобразует элементы массива в строки.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Преобразует элементы массива в строки, вставляет указанный разделитель между элементами, сцепляет их и возвращает получившуюся строку. Вложенный массив всегда разделяется запятой (,), а не разделителем, переданным методу <codeph>join()</codeph>.
	 
	 </apiDesc><example conref="examples\Array.join.1.as"> Следующий код создает объект Array <codeph>myArr</codeph> с элементами <codeph>один</codeph>, <codeph>два</codeph>, <codeph>три</codeph> и затем строку, содержащую <codeph>один, два и три</codeph>, с помощью метода <codeph>join()</codeph>.
<codeblock>

var myArr:Array = new Array("one", "two", "three");
var myStr:String = myArr.join(" and ");
trace(myArr); // one,two,three
trace(myStr); // one and two and three
</codeblock></example><example conref="examples\Array.join.2.as"> Следующий код создает объект Array <codeph>specialChars</codeph> с элементами <codeph>(</codeph>, <codeph>)</codeph>, <codeph>-</codeph> и пробелом, а затем создает строку с номером <codeph>(888) 867-5309</codeph>. После этого с помощью цикла <codeph>for</codeph> он удаляет все типы специальных символов, перечисленные в <codeph>specialChars</codeph>, чтобы создать строку (<codeph>myStr</codeph>), которая содержит только цифры телефонного номера: <codeph>888675309</codeph>. Учтите, что другие символы (например, <codeph>+</codeph>) могли быть включены в список <codeph>specialChars</codeph>. При этом данная процедура начинает поддерживать форматы международных телефонных номеров.
<codeblock>

var phoneString:String = "(888) 867-5309";

var specialChars:Array = new Array("(", ")", "-", " ");
var myStr:String = phoneString;

var ln:uint = specialChars.length;
for(var i:uint; i &lt; ln; i++) {
    myStr = myStr.split(specialChars[i]).join("");
}

var phoneNumber:Number = new Number(myStr);

trace(phoneString); // (888) 867-5309
trace(phoneNumber); // 8888675309
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 Ищет элемент в массиве в обратном порядке начиная с последнего элемента с использованием строгого равенства (===), затем возвращает позицию в индексе для подходящего элемента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Позиция индекса, начинающегося с нуля, для элемента массива. Если аргумент <codeph>searchElement</codeph> не найден, возвращается значение «-1».
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>Элемент, который требуется найти в массиве.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Место в массиве, в которого начинается поиск элемента. Значение по умолчанию — максимально допустимое значение индекса. Если параметр <codeph>fromIndex</codeph> не указан, поиск начинается с последнего элемента массива.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Ищет элемент в массиве в обратном порядке начиная с последнего элемента с использованием строгого равенства (<codeph>===</codeph>) , затем возвращает позицию в индексе для подходящего элемента.
	 </apiDesc><example conref="examples\Array_lastIndexOf.as"> В следующем примере показана позиция указанного массива:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_lastIndexOf extends Sprite {
        public function Array_lastIndexOf() {
            var arr:Array = new Array(123,45,6789,123,984,323,123,32);
            
            var index:int = arr.indexOf(123);
            trace(index); // 0
            
            var index2:int = arr.lastIndexOf(123);
            trace(index2); // 6
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/indexOf()"><linktext>Array.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:map"><apiName>map</apiName><shortdesc>
     Выполняет функцию для каждого элемента массива и формирует новый массив из элементов, соответствующих результатам функции для каждого элемента исходного массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новый массив, который содержит результаты функции, выполняемой по отношению к каждому элементу исходного массива.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом массива. Эта функция может содержать простую команду (например, изменение регистра строкового массива) или более сложную операцию. Она вызывается по трем аргументам: значению элемента, индексу элемента и объекту Array:
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Объект, используемый для этой функции в качестве <codeph>this</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет функцию для каждого элемента массива и формирует новый массив из элементов, соответствующих результатам функции для каждого элемента исходного массива.
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Предположим, что функция создается во фрагменте ролика с названием <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Допустим, что используется метод <codeph>map()</codeph> по отношению к массиву с именем <codeph>myArray</codeph>:</p>
     <pre product="flash">
     myArray.map(myFunction, me);
     </pre>
     <p product="flash">Поскольку <codeph>myFunction</codeph> принадлежит классу Timeline, который не может быть переопределен фрагментом ролика <codeph>me</codeph>, Flash Player создает исключение. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.map(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_map.as"> В следующем примере все строчные буквы в элементах массива заменяются прописными:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_map extends Sprite {
        public function Array_map() {
            var arr:Array = new Array("one", "two", "Three");
            trace(arr); // one,two,Three

            var upperArr:Array = arr.map(toUpper);
            trace(upperArr); // ONE,TWO,THREE
        }
        private function toUpper(element:*, index:int, arr:Array):String {
            return String(element).toUpperCase();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/filter()"><linktext>Array.filter()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:pop"><apiName>pop</apiName><shortdesc>
	  Удаляет последний элемент из массива и возвращает значение этого элемента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.pop, pop
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Значение последнего элемента (любого типа данных) в указанном массиве.
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	  Удаляет последний элемент из массива и возвращает значение этого элемента.
	 
	 </apiDesc><example conref="examples\Array.pop.1.as"> Следующий код создает объект Array <codeph>letters</codeph> с элементами <codeph>a</codeph>, <codeph>b</codeph> и <codeph>c</codeph>. Последний элемент (<codeph>c</codeph>) удаляется впоследствии из массива с помощью метода <codeph>pop()</codeph> и присваивается объекту String <codeph>letter</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
var letter:String = letters.pop();
trace(letters); // a,b
trace(letter);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:push"><apiName>push</apiName><shortdesc>
	 Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.push, push
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Целое число, выражающее длину нового массива.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Одно или несколько значений, добавляемых в массив.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.
	 
	 </apiDesc><example conref="examples\Array.push.1.as"> Следующий код создает пустой объект Array <codeph>letters</codeph>, а затем заполняет массив элементами <codeph>a</codeph>, <codeph>b</codeph> и <codeph>c</codeph> с помощью метода <codeph>push()</codeph>.
<codeblock>

var letters:Array = new Array();

letters.push("a");
letters.push("b");
letters.push("c");

trace(letters.toString()); // a,b,c
</codeblock></example><example conref="examples\Array.push.2.as"> Следующий код создает объект Array <codeph>letters</codeph>, который сначала заполняется элементом <codeph>a</codeph>. После этого однократно используется метод <codeph>push()</codeph> для добавления элементов <codeph>b</codeph> и <codeph>c</codeph> в конец массива, который находится на расстоянии трех элементов от элемента, созданного методом push.
<codeblock>

var letters:Array = new Array("a");
var count:uint = letters.push("b", "c");

trace(letters); // a,b,c
trace(count);   // 3
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:reverse"><apiName>reverse</apiName><shortdesc>
	  Преобразует массив в обратный массив.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.reverse, reverse
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новый массив.
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Преобразует массив в обратный массив.
	 
	 </apiDesc><example conref="examples\Array.reverse.1.as"> Следующий код создает объект Array <codeph>letters</codeph> с элементами <codeph>a</codeph>, <codeph>b</codeph> и <codeph>c</codeph>. Порядок элементов массива заменяется затем на противоположный методом <codeph>reverse()</codeph>, чтобы создать массив <codeph>[c,b,a]</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
letters.reverse();
trace(letters); // c,b,a
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:shift"><apiName>shift</apiName><shortdesc>
	 Удаляет первый элемент из массива и возвращает этот элемент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.shift, shift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Первый элемент (любого типа данных) в массиве.
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Удаляет первый элемент из массива и возвращает этот элемент. Оставшиеся элементы массива перемещаются с исходной позицию "i" на позицию "i-1".
	 
	 </apiDesc><example conref="examples\Array.shift.1.as"> Следующий код создает объект Array <codeph>letters</codeph> с элементами <codeph>a</codeph>, <codeph>b</codeph> и <codeph>c</codeph>. Затем применяется метод <codeph>shift()</codeph> для удаления первого элемента (<codeph>a</codeph>) из объекта <codeph>letters</codeph> и присвоения его строке <codeph>firstLetter</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c");
var firstLetter:String = letters.shift();
trace(letters);     // b,c
trace(firstLetter); // a
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:slice"><apiName>slice</apiName><shortdesc>
	 Возвращает новый массив, состоящий из диапазона элементов исходного массива, не модифицируя исходный массив.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив, состоящий из диапазона элементов исходного массива.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Число, указывающее на индекс начальной позиции среза. Если <codeph>startIndex</codeph> — отрицательное число, начальной позицией становится конец массива, последнему элементу которого присваивается позиция «-1».	
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>Число, указывающее на индекс конечной позиции среза. Если этот параметр пропустить, срез включает все элементы от начальной позиции до конца массива. Если <codeph>endIndex</codeph> — отрицательное число, конечная позиция указывается с конца массива, последнему элементу которого присваивается позиция «-1».
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает новый массив, состоящий из диапазона элементов исходного массива.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает новый массив, состоящий из диапазона элементов исходного массива, не модифицируя исходный массив. Возвращенный массив включает элемент <codeph>startIndex</codeph> и все элементы вплоть до него, исключая элемент <codeph>endIndex</codeph>. 
	 <p>Если параметры не переданы, создается дубликат исходного массива.</p>
	 
	 </apiDesc><example conref="examples\Array.slice.1.as"> Следующий код создает объект Array <codeph>letters</codeph> с элементами <codeph>[a,b,c,d,e,f]</codeph>. После этого создается массив <codeph>someLetters</codeph> путем вызова метода <codeph>slice()</codeph>, который применяется к элементам с первого (<codeph>b</codeph>) по третий (<codeph>d</codeph>). В результате получается массив с элементами <codeph>b</codeph> и <codeph>c</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(1,3);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // b,c
</codeblock></example><example conref="examples\Array.slice.2.as"> Следующий код создает объект Array <codeph>letters</codeph> с элементами <codeph>[a,b,c,d,e,f]</codeph>. Затем создается массив <codeph>someLetters</codeph> путем вызова метода <codeph>slice()</codeph> по отношению ко второму элементу (<codeph>c</codeph>). В результате получается массив с элементами <codeph>[c,d,e,f]</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // c,d,e,f
</codeblock></example><example conref="examples\Array.slice.3.as"> Следующий код создает объект Array <codeph>letters</codeph> с элементами <codeph>[a,b,c,d,e,f]</codeph>. После этого создается массив <codeph>someLetters</codeph> путем вызова метода <codeph>slice()</codeph> по отношению ко второму элементу с конца (<codeph>e</codeph>). Это приводит к появлению массива с элементами <codeph>e</codeph> и <codeph>f</codeph>.
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(-2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // e,f
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:some"><apiName>some</apiName><shortdesc>
     Выполняет тестовую функцию для каждого элемента массива, пока не будет достигнут элемент, возвращающий значение true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Логическое значение <codeph>true</codeph>, если какие-либо элементы в массиве возвращают значение <codeph>true</codeph> для указанной функции; в противном случае присваивается значение <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом массива. Эта функция может содержать простое сравнение (например, <codeph>item &lt; 20</codeph>) или более сложную операцию. Она вызывается по трем аргументам: значению элемента, индексу элемента и объекту Array:
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>Объект, используемый для этой функции в качестве <codeph>this</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет тестовую функцию для каждого элемента массива, пока не будет достигнут элемент, возвращающий значение <codeph>true</codeph>. Этот метод используется для того, чтобы определить, все ли элементы массива соответствуют критерию (например, их значения должны быть меньше определенного числа).
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Предположим, что функция создается во фрагменте ролика с названием <codeph>me</codeph>:</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">Допустим, что используется метод <codeph>some()</codeph> по отношению к массиву с именем <codeph>myArray</codeph>:</p>
     <pre product="flash">
     myArray.some(myFunction, me);
     </pre>
     <p product="flash">Поскольку <codeph>myFunction</codeph> принадлежит классу Timeline, который не может быть переопределен фрагментом ролика <codeph>me</codeph>, Flash Player создает исключение. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.some(myFunction, me);
     </pre>   
	 </apiDesc><example conref="examples\Array_some.as"> В следующем примере показано, какие значения не определены:
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_some extends Sprite {
        public function Array_some() {
            var arr:Array = new Array();
            arr[0] = "one";
            arr[1] = "two";
            arr[3] = "four";
            var isUndef:Boolean = arr.some(isUndefined);
            if (isUndef) {
                trace("array contains undefined values: " + arr);
            } else {
                trace("array contains no undefined values.");
            }
        }
        private function isUndefined(element:*, index:int, arr:Array):Boolean {
            return (element == undefined);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sort"><apiName>sort</apiName><shortdesc>
	 Сортирует элементы в массиве.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sort, sort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Возвращаемое значение зависит от того, передаются ли аргументы (см. список):
	 <ul>
	   <li>Если указывается значение 4 или <codeph>Array.UNIQUESORT</codeph> для аргумента <codeph>sortOptions</codeph> параметра <codeph>...args</codeph> и два или более сортируемых элемента имеют идентичные поля сортировки, Flash возвращает значение 0 и не модифицирует массив. </li>
  	   <li>Если указывается значение 8 или <codeph>Array.RETURNINDEXEDARRAY</codeph> для аргумента <codeph>sortOptions</codeph> параметра <codeph>...args</codeph>, Flash возвращает отсортированный числовой массив индексов, отражающий результаты сортировки, и не модифицирует массив. </li>
	   <li>В противном случае Flash ничего не возвращает и изменяет массив, чтобы отразить порядок сортировки.</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Аргументы, указывающие на функцию сравнения и одно или несколько значений, определяющих режим сортировки.
	 <p>В этом методе используется синтаксис и порядок аргументов <codeph>Array.sort(compareFunction, sortOptions)</codeph>, где аргументы определяются следующим образом:</p>
     <ul><li><codeph>compareFunction</codeph> — функция сравнения, используемая для определения порядка сортировки элементов в массиве. Этот аргумент является необязательным. Функция сравнения требует наличия двух сравниваемых аргументов. При наличии элементов A и B функция <codeph>compareFunction</codeph> может возвращать отрицательное, нулевое или положительное значение:
	 <ul>
	   <li>Отрицательное возвращаемое значение обозначает, что A стоит перед B в отсортированной последовательности.</li>
	   <li>Нулевое возвращаемое значение обозначает, что элементы A и B имеют одинаковый порядок сортировки.</li>
	   <li>Положительное возвращаемое значение обозначает, что элемент A стоит после элемента B в отсортированной последовательности.</li>
	 </ul>
	 </li>
	 <li><codeph>sortOptions</codeph> — одно или несколько чисел или определенных констант, разделенных оператором <codeph>|</codeph> (побитовое ИЛИ), которые меняют режим сортировки по умолчанию. Этот аргумент является необязательным. Параметр <codeph>sortOptions</codeph> может принимать следующие значения: 
	  <ul>
	   <li>1 или <codeph>Array.CASEINSENSITIVE</codeph></li>
	   <li>2 или <codeph>Array.DESCENDING</codeph></li>
	   <li>4 или <codeph>Array.UNIQUESORT</codeph></li>
	   <li>8 или <codeph>Array.RETURNINDEXEDARRAY</codeph> </li>
	   <li>16 или <codeph>Array.NUMERIC</codeph></li>
	 </ul>
	 Дополнительную информацию см. в описании метода <codeph>Array.sortOn()</codeph>.</li>
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Сортирует элементы в массиве. Этот метод применяется для сортировки по значениям Юникода. (ASCII — это подмножество Юникода.)
	 <p>По умолчанию <codeph>Array</codeph>. <codeph>sort()</codeph> действует следующим образом:</p>
	 <ul>
	   <li>Сортировка зависит от регистра (<i>Z</i> предшествует <i>a</i>).</li>
	   <li>Сортировка выполняется в восходящем порядке (<i>a</i> предшествует <i>b</i>). </li>
	   <li>Массив изменяется, отражая порядок сортировки; несколько элементов, имеющих идентичные поля сортировки последовательно размещаются в отсортированном массиве без определенного порядка.</li>
	   <li>Все элементы независимо от типа данных сортируются так, как если бы это были строки. Число 100 предшествует числу 99, поскольку «1» — это строковое значение, которое меньше «9».</li>
	 </ul>
	 <p>
	 Чтобы выполнить сортировку массива, используя настройки, которые отличаются от настроек по умолчанию, можно либо воспользоваться одной из возможностей сортировки, описанной в разделе <codeph>sortOptions</codeph> описания параметра <codeph>...args</codeph>, либо создать собственную пользовательскую функцию сортировки. При создании пользовательской функции вызывается метод <codeph>sort()</codeph>, а имя пользовательской функции используется в качестве первого аргумента (<codeph>compareFunction</codeph>) 
	 </p>
	 
	 </apiDesc><example conref="examples\Array.sort.1.as"> Следующий код создает объект Array <codeph>vegetables</codeph> с элементами <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph>. После этого массив сортируется с помощью метода <codeph>sort()</codeph>, который вызывается без параметров. В результате объект <codeph>vegetables</codeph> сортируется в алфавитном порядке (<codeph>[avocado, cilantro, green pepper, onion, spinach]</codeph>).
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

trace(vegetables); // spinach,green pepper,cilantro,onion,avocado
vegetables.sort();
trace(vegetables); // avocado,cilantro,green pepper,onion,spinach
</codeblock></example><example conref="examples\Array.sort.2.as"> Следующий код создает объект Array <codeph>vegetables</codeph> с элементами <codeph>[spinach, green pepper, Cilantro, Onion, Avocado]</codeph>. Сортировка этого массива выполняется методом <codeph>sort()</codeph>, который в первый раз вызывается без параметров. Результат выглядит следующим образом: <codeph>[Avocado,Cilantro,Onion,green pepper,spinach]</codeph>. Затем снова вызывается метод <codeph>sort()</codeph>, применяемый к объекту <codeph>vegetables</codeph>, в котором в качестве параметра выбрана константа <codeph>CASEINSENSITIVE</codeph>. В результате объект <codeph>vegetables</codeph> сортируется в алфавитном порядке (<codeph>[Avocado, Cilantro, green pepper, Onion, spinach]</codeph>).
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "Cilantro",
                 "Onion",
                 "Avocado");

vegetables.sort();
trace(vegetables); // Avocado,Cilantro,Onion,green pepper,spinach
vegetables.sort(Array.CASEINSENSITIVE);
trace(vegetables); // Avocado,Cilantro,green pepper,Onion,spinach
</codeblock></example><example conref="examples\Array.sort.3.as"> Следующий код создает пустой объект Array <codeph>vegetables</codeph>, который затем заполняется путем пяти вызовов метода <codeph>push()</codeph>. Каждый раз при вызове метода <codeph>push()</codeph> создается новый объект <codeph>Vegetable</codeph>. Для этого вызывается конструктор <codeph>Vegetable()</codeph>, который принимает объекты String (<codeph>name</codeph>) и Number (<codeph>price</codeph>). Пятикратный вызов метода <codeph>push()</codeph> с указанными значениями приводит к формированию следующего массива: <codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>. Затем для сортировки массива используется метод <codeph>sort()</codeph>. В результате появляется массив <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>.
<codeblock>
var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort();

trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

//The following code defines the Vegetable class
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.4.as"> Следующий пример в точности напоминает предыдущий, за исключением того, что метод <codeph>sort()</codeph> используется вместе с пользовательской функцией сортировки (<codeph>sortOnPrice</codeph>), выполняющей сортировку по цене, а не в алфавитном порядке. Учтите, что цена извлекается с помощью новой функции <codeph>getPrice()</codeph>.
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort(sortOnPrice);

trace(vegetables);
// celery:1.29, squash:1.44, lettuce:1.49, spinach:1.89, asparagus:3.99

function sortOnPrice(a:Vegetable, b:Vegetable):Number {
    var aPrice:Number = a.getPrice();
    var bPrice:Number = b.getPrice();

    if(aPrice > bPrice) {
        return 1;
    } else if(aPrice &lt; bPrice) {
        return -1;
    } else  {
        //aPrice == bPrice
        return 0;
    }
}

// The following code defines the Vegetable class and should be in a separate package.
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function getPrice():Number {
        return price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.5.as"> Следующий код создает объект Array <codeph>numbers</codeph> с элементами <codeph>[3,5,100,34,10]</codeph>. Вызов метода <codeph>sort()</codeph> без параметров приводит к сортировке в алфавитном порядке. При этом появляется нежелательный результат: <codeph>[10,100,3,34,5]</codeph>. Чтобы правильно отсортировать числовые значения, необходимо передать константу <codeph>NUMERIC</codeph> методу <codeph>sort()</codeph>, который сортирует <codeph>числа</codeph> следующим образом: <codeph>[3,5,10,34,100]</codeph>.
 <p><b>Примечание.</b> Режим функции <codeph>sort()</codeph> по умолчанию состоит в том, чтобы обрабатывать каждую сущность как строку. Аргумент <codeph>Array.NUMERIC</codeph> в действительности не преобразует другие типы данных в тип данных Number; он просто позволяет алгоритму сортировки распознавать числа.</p>
<codeblock>

var numbers:Array = new Array(3,5,100,34,10);

trace(numbers); // 3,5,100,34,10
numbers.sort();
trace(numbers); // 10,100,3,34,5
numbers.sort(Array.NUMERIC);
trace(numbers); // 3,5,10,34,100
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (bitwise OR)</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sortOn"><apiName>sortOn</apiName><shortdesc>
	 Сортирует элементы в массиве по одному или нескольким полям массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sortOn, sortOn
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Возвращаемое значение зависит от наличия переданных параметров:
	 <ul>
	   <li>Если выбрано значение 4 или <codeph>Array.UNIQUESORT</codeph> для параметра <codeph>options</codeph> и два и более сортируемых элементов имеют одинаковые поля сортировки, возвращается значение 0, а сам массив остается неизменным. </li>
  	   <li>Если присвоить значение 8 или <codeph>Array.RETURNINDEXEDARRAY</codeph> параметру <codeph>options</codeph>, возвращается массив, отражающий результаты сортировки, а сам массив остается неизменным.</li>
  	   <li>В противном случае не возвращается ничего, а массив изменяется, отражая порядок сортировки.</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>fieldName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Строка, указывающая на поле, которое должно использоваться в качестве значения сортировки, или на массив, первый элемент которого представляет собой первичное поле сортировки, второй – вторичное поле сортировки и т.д.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>options</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Одно или несколько чисел или имен определенных констант, разделенные <codeph>bitwise OR (|)</codeph> и управляющие режимом сортировки. Параметр <codeph>options</codeph> может принимать следующие значения:
	 <ul>
	   <li><codeph>Array.CASEINSENSITIVE</codeph> или 1</li>
	   <li><codeph>Array.DESCENDING</codeph> или 2</li>
	   <li><codeph>Array.UNIQUESORT</codeph> или 4</li>
	   <li><codeph>Array.RETURNINDEXEDARRAY</codeph> или 8</li>
	   <li><codeph>Array.NUMERIC</codeph> или 16</li>
	 </ul>
     <p product="flash">Подсказки для кодов включаются, если используется строковый формат флага (например, <codeph>DESCENDING</codeph>) вместо числового (2).</p>
   	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Сортирует элементы в массиве по одному или нескольким полям массива. Массив должен обладать следующими характеристиками:
	 <ul>
	   <li>Массив является индексированным, а не массивом ассоциативных элементов.</li>
 	   <li>Каждый элемент массива содержит объект с одним или несколькими свойствами.</li>
	   <li>Все объекты имеют не менее одного общего свойства, значения которого можно применять для сортировки массива. Такое свойство называется <i>полем</i>.</li>
	 </ul>
	 <p>При указании нескольких параметров <codeph>fieldName</codeph> первое поле относится к первичному полю сортировки, второе – к вторичному полю сортировки и т.д. Сортировка в Flash выполняется по значениям Юникода. (ASCII – это подмножество Юникода.) Если любой из сравниваемых элементов не содержит поле, указанное в параметре <codeph>fieldName</codeph>, предполагается, что ему присвоено значение <codeph>undefined</codeph>, а элементы последовательно расположены в отсортированном массиве без определенного порядка.</p>
 	 <p>По умолчанию <codeph>Array</codeph>. <codeph>sortOn()</codeph> действует следующим образом:</p>
	 <ul>
	   <li>Сортировка зависит от регистра (<i>Z</i> предшествует <i>a</i>).</li>
	   <li>Сортировка выполняется в восходящем порядке (<i>a</i> предшествует <i>b</i>). </li>
	   <li>Массив изменяется, отражая порядок сортировки; несколько элементов, имеющих идентичные поля сортировки последовательно размещаются в отсортированном массиве без определенного порядка.</li>
	   <li>Числовые поля сортируются так, как если бы они были строками. Число 100 предшествует числу 99, поскольку 1 – это строковое значение, которое меньше 9.</li>
	 </ul>
	 <p>В Flash Player 7 добавлен параметр <codeph>options</codeph>, который можно применять для переопределения режима сортировки по умолчанию. Чтобы отсортировать простой массив (например, массив, у которого только одно поле) или указать порядок сортировки, который не поддерживается параметром <codeph>options</codeph>, выберите <codeph>Array.sort()</codeph>.</p>
 	 <p>Чтобы установить несколько флагов, разделите их побитовыми операторами ИЛИ (<codeph>|</codeph>):</p>
	 <codeblock>
	 my_array.sortOn(someFieldName, Array.DESCENDING | Array.NUMERIC);
	 </codeblock>
	 <p>В Flash Player 8 добавлена возможность выбора разных вариантов сортировки для каждого поля, когда сортировка выполняется более чем по одному полю. В Flash Player, начиная с версии 8, параметр <codeph>options</codeph> поддерживает массив вариантов сортировки. При этом каждый вариант сортировки соответствует полю сортировки в параметре <codeph>fieldName</codeph>. В следующем примере первичное поле сортировки (<codeph>a</codeph>) сортируется в нисходящем порядке, вторичное поле сортировки (<codeph>b</codeph>) – с помощью численной сортировки, а третичное поле (<codeph>c</codeph>) – с помощью сортировки, не зависящей от регистра:</p>
	 <codeblock>
	 Array.sortOn (["a", "b", "c"], [Array.DESCENDING, Array.NUMERIC, Array.CASEINSENSITIVE]);
	 </codeblock>
	 <p><b>Примечание. </b>Массивы <codeph>fieldName</codeph> и <codeph>options</codeph> должны иметь одно и то же количество элементов; в противном случае массив <codeph>options</codeph> игнорируется. Кроме того, варианты <codeph>Array.UNIQUESORT</codeph> и <codeph>Array.RETURNINDEXEDARRAY</codeph> могут выступать только в роли первого элемента массива. В противном случае они игнорируются.</p>
	 
	 </apiDesc><example conref="examples\Array.sortOn.1.as"> Следующий код создает пустой объект Array <codeph>vegetables</codeph>, который затем заполняется путем пяти вызовов метода <codeph>push()</codeph>. Каждый раз при вызове метода <codeph>push()</codeph> создается новый объект <codeph>Vegetable</codeph>. Для этого вызывается конструктор <codeph>Vegetable()</codeph>, который принимает объекты String (<codeph>name</codeph>) и Number (<codeph>price</codeph>). Пятикратный вызов метода <codeph>push()</codeph> с указанными значениями приводит к формированию следующего массива: <codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>. После этого используется метод <codeph>sortOn()</codeph> с параметром <codeph>name</codeph>, создающий следующий массив: <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>. После этого снова вызывается метод <codeph>sortOn()</codeph> с параметром price, а также константами NUMERIC и DESCENDING. Он создает массив, отсортированный по числам в нисходящем порядке: <codeph>[asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29]</codeph>.
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sortOn("name");
trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

vegetables.sortOn("price", Array.NUMERIC | Array.DESCENDING);
trace(vegetables);
// asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29

class Vegetable {
    public var name:String;
    public var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sortOn.2.as"> Следующий код создает пустой объект Array <codeph>records</codeph>, который затем заполняется путем трех вызовов метода <codeph>push()</codeph>. При каждом вызове метода <codeph>push()</codeph> строки <codeph>имя</codeph>, <codeph>город</codeph> и <codeph>почтовый индекс</codeph> добавляются в объект <codeph>records</codeph>. Печать элементов массива производится с помощью циклов <codeph>for</codeph>. Первый цикл <codeph>for</codeph> выводит элементы на печать в том порядке, в каком они были добавлены. Второй цикл <codeph>for</codeph> выполняется после того, как объект <codeph>records</codeph> был отсортирован по имени и затем по городу с помощью метода <codeph>sortOn()</codeph>. Третий цикл <codeph>for</codeph> приводит к иным результатам, поскольку объект <codeph>records</codeph> сортируется еще раз сначала по городу, а затем по имени.
<codeblock>


var records:Array = new Array();
records.push({name:"john", city:"omaha", zip:68144});
records.push({name:"john", city:"kansas city", zip:72345});
records.push({name:"bob", city:"omaha", zip:94010});

for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, omaha
// john, kansas city
// bob, omaha

trace("records.sortOn('name', 'city');");
records.sortOn(["name", "city"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// bob, omaha
// john, kansas city
// john, omaha

trace("records.sortOn('city', 'name');");
records.sortOn(["city", "name"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, kansas city
// bob, omaha
// john, omaha
</codeblock></example><example conref="examples\Array.sortOn.3.as"> Следующий код создает пустой объект Array <codeph>users</codeph>, который затем заполняется путем четырех вызовов метода <codeph>push()</codeph>. Каждый раз при вызове метода <codeph>push()</codeph> создается объект User с помощью конструктора <codeph>User()</codeph>. В число пользователей добавляются строка <codeph>name</codeph> и uint <codeph>age</codeph>. В результате получается набор массивов <codeph>[Bob:3,barb:35,abcd:3,catchy:4]</codeph>.
 <p>Затем массив сортируется следующими способами:
 <ol>
   <li>Только по имени, создавая массив <codeph>[Bob:3,abcd:3,barb:35,catchy:4]</codeph></li>
   <li>По имени и с константой <codeph>CASEINSENSITIVE</codeph>, создавая массив <codeph>[abcd:3,barb:35,Bob:3,catchy:4]</codeph></li>
   <li>По имени и с константами <codeph>CASEINSENSITIVE</codeph> и <codeph>DESCENDING</codeph>, создавая массив <codeph>[catchy:4,Bob:3,barb:35,abcd:3]</codeph></li>
   <li>Только по возрасту, создавая массив <codeph>[abcd:3,Bob:3,barb:35,catchy:4]</codeph></li>
   <li>По возрасту и с константой <codeph>NUMERIC</codeph>, создавая массив <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph></li>
   <li>По возрасту и с константами <codeph>DESCENDING</codeph> и <codeph>NUMERIC</codeph>, создавая массив <codeph>[barb:35,catchy:4,Bob:3,abcd:3]</codeph></li>
 </ol>
 </p>
 <p>Затем создается массив <codeph>indices</codeph>, которому присваиваются результаты сортировки по возрасту с использованием констант <codeph>NUMERIC</codeph> и <codeph>RETURNINDEXEDARRAY</codeph>. В результате появляется массив <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph>, который впоследствии выводится на печать с помощью цикла <codeph>for</codeph>.</p>
<codeblock>

class User {
    public var name:String;
    public var age:Number;
    public function User(name:String, age:uint) {
        this.name = name;
        this.age = age;
    }

    public function toString():String {
        return this.name + ":" + this.age;
    }
}

var users:Array = new Array();
users.push(new User("Bob", 3));
users.push(new User("barb", 35));
users.push(new User("abcd", 3));
users.push(new User("catchy", 4));

trace(users); // Bob:3,barb:35,abcd:3,catchy:4

users.sortOn("name");
trace(users); // Bob:3,abcd:3,barb:35,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE);
trace(users); // abcd:3,barb:35,Bob:3,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE | Array.DESCENDING);
trace(users); // catchy:4,Bob:3,barb:35,abcd:3

users.sortOn("age");
trace(users); // abcd:3,Bob:3,barb:35,catchy:4

users.sortOn("age", Array.NUMERIC);
trace(users); // Bob:3,abcd:3,catchy:4,barb:35

users.sortOn("age", Array.DESCENDING | Array.NUMERIC);
trace(users); // barb:35,catchy:4,Bob:3,abcd:3

var indices:Array = users.sortOn("age", Array.NUMERIC | Array.RETURNINDEXEDARRAY);
var index:uint;
for(var i:uint = 0; i &lt; indices.length; i++) {
    index = indices[i];
    trace(users[index].name, ": " + users[index].age);
}

// Results:
// Bob : 3
// abcd : 3
// catchy : 4
// barb : 35
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (побитовое ИЛИ)</linktext></link><link href="#Array/sort()"><linktext>Array.sort()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:splice"><apiName>splice</apiName><shortdesc>
	 Добавляет элементы в массив и удаляет элементы из массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.splice, splice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив, содержащий элементы, удаленные из исходного массива.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Целое число, указывающее индекс элемента в массиве, откуда начинается вставка или удаление. Для указания позиции относительно конца массива можно использовать отрицательное число (например, -1 – это последний элемент массива).
	 </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число, указывающее количество удаляемых элементов. Это число включает элемент, указанный в параметре <codeph>startIndex</codeph>. Если значение параметра <codeph>deleteCount</codeph> не указано, метод удаляет все значения, начиная с элемента <codeph>startIndex</codeph> до последнего элемента в массиве. Если значение равно 0, элементы не удаляются. 	 
	 </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Необязательный список, состоящий из одного или нескольких значений, разделенных запятыми, которые вставляется в массив на позиции, указанной параметром <codeph>startIndex</codeph>. Если тип вставленного значения — Array, массив остается без изменений и вставляется как один элемент. Например, если соединить существующий массив из трех элементов с другим массивом из трех элементов, то в результирующем массиве будет только четыре элемента. Однако одним из элементов будет массив из трех элементов.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Добавляет элементы в массив и удаляет элементы из массива. Этот метод изменяет массив, не создавая копии.
	 <p><b>Примечание.</b> Для переопределения этого метода в подклассе Array укажите для параметров значение <codeph>...args</codeph>, как показано в примере:</p>
	 <pre>
	 public override function splice(...args) {
	   // your statements here
	 }
	 </pre>
	 </apiDesc><example conref="examples\Array.splice.1.as"> Следующий код создает объект Array <codeph>vegetables</codeph> с элементами <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph>. Затем вызывается метод <codeph>splice()</codeph> с параметрами 2 и 2, присваивающий <codeph>cilantro</codeph> и <codeph>onion</codeph> массиву со <codeph>срезом</codeph>. Массив <codeph>vegetables</codeph> содержит при этом элементы <codeph>[spinach,green pepper,avocado]</codeph>. Вторично вызывается метод <codeph>splice()</codeph> с параметрами 1, 0, и массив со <codeph>срезом</codeph> присваивает <codeph>[cilantro,onion]</codeph> в качестве второго элемента <codeph>vegetables</codeph>.
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

var spliced:Array = vegetables.splice(2, 2);
trace(vegetables); // spinach,green pepper,avocado
trace(spliced);    // cilantro,onion

vegetables.splice(1, 0, spliced);
trace(vegetables); // spinach,cilantro,onion,green pepper,avocado

</codeblock></example><example conref="examples\Array.splice.2.as"> Учтите, что отслеживание <codeph>cilantro</codeph> и <codeph>onion</codeph> выполняется так, как если бы в <codeph>vegetables</codeph> было 5 элементов, хотя фактически в нем 4 элемента (а второй из них является другим массивом, содержащим два элемента). Чтобы добавить <codeph>cilantro</codeph> и <codeph>onion</codeph> по отдельности, необходимо использовать следующее:
<codeblock>
 
var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");
 
 var spliced:Array = vegetables.splice(2, 2);
 trace(vegetables); // spinach,green pepper,avocado
 trace(spliced);    // cilantro,onion
 
 vegetables.splice(1, 0, "cilantro", "onion");
 trace(vegetables); // spinach,cilantro,onion,green pepper,avocado
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     Возвращает строку, представляющую элементы в заданном массиве.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка с элементами массива.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Возвращает строку, представляющую элементы в заданном массиве. Каждый элемент в массиве, начиная с индекса 0 и заканчивая наибольшим индексом, преобразуется в сцепленную строку, разделенную запятыми. В рамках ActionScript 3.0 этот метод возвращает то же значение, что и метод <codeph>Array.toString()</codeph>.
   	 
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/toString()"><linktext>Array.toString()</linktext></link></related-links></apiOperation><apiOperation id="Array:toString"><apiName>toString</apiName><shortdesc>
	 Возвращает строку, представляющую элементы в заданном массиве.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка с элементами массива.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строку, представляющую элементы в заданном массиве. Каждый элемент в массиве, начиная с индекса 0 и заканчивая наибольшим индексом, преобразуется в сцепленную строку, разделенную запятыми. Для указания пользовательского разделителя примените метод <codeph>Array.join()</codeph>.
   	 
	 
	 </apiDesc><example conref="examples\Array.toString.1.as"> Следующий код создает объект Array, преобразует значения в строки и сохраняет их в переменной <codeph>vegnums</codeph> с типом данных String.

<codeblock>

var vegetables:Array = new Array();
vegetables.push(1);
vegetables.push(2);
vegetables.push(3);
vegetables.push(4);
vegetables.push(5);
var vegnums:String = vegetables.toString();
trace(vegnums+",6");
// 1,2,3,4,5,6
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Array/join()"><linktext>Array.join()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     Добавляет один или несколько элементов в начало массива и возвращает новую длину массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.unshift, unshift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Целое число, выражающее новую длину массива.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Одно или несколько чисел, элементов или переменных, вставляемых в начало массива.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет один или несколько элементов в начало массива и возвращает новую длину массива. Другие элементы массива смещаются с исходных позиций (с i на i+1).
	 
	 </apiDesc><example conref="examples\Array.unshift.1.as"> Следующий код создает пустой объект Array <codeph>names</codeph>. Строки <codeph>Bill</codeph> и <codeph>Jeff</codeph> добавлены с помощью метода <codeph>push()</codeph>, а строки <codeph>Alfred</codeph> и <codeph>Kyle</codeph> добавлены в начало <codeph>names</codeph> путем двух вызовов метода <codeph>unshift()</codeph>.
<codeblock>

var names:Array = new Array();
names.push("Bill");
names.push("Jeff");

trace(names); // Bill,Jeff

names.unshift("Alfred");
names.unshift("Kyle");

trace(names); // Kyle,Alfred,Bill,Jeff
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link></related-links></apiOperation><apiValue id="Array:CASEINSENSITIVE"><apiName>CASEINSENSITIVE</apiName><shortdesc>
     Задает сортировку без учета регистра для методов сортировки класса Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F6
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Задает сортировку без учета регистра для методов сортировки класса Array. Эту константу можно использовать для параметра <codeph>options</codeph> в методе <codeph>sort()</codeph> или <codeph>sortOn()</codeph>. 
	 <p>Значение этой константы равно 1.</p>
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:DESCENDING"><apiName>DESCENDING</apiName><shortdesc>
     Задает сортировку по убыванию для методов сортировки класса Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F7
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Задает сортировку по убыванию для методов сортировки класса Array. Эту константу можно использовать для параметра <codeph>options</codeph> в методе <codeph>sort()</codeph> или <codeph>sortOn()</codeph>. 
 	 <p>Значение этой константы равно 2.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:NUMERIC"><apiName>NUMERIC</apiName><shortdesc>
     Задает числовую сортировку (вместо сортировки по символьной строке) для методов сортировки класса Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F8
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>16</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Задает числовую сортировку (вместо сортировки по символьной строке) для методов сортировки класса Array. Включение этой константы в параметр <codeph>options</codeph> приводит к тому, что методы <codeph>sort()</codeph> и <codeph>sortOn()</codeph> сортируют числа как числовые значения, а не как строки с числовыми значениями. Без константы <codeph>NUMERIC</codeph> сортировка обрабатывает каждый элемент массива как символьную строку и выдает результаты согласно порядку Юникода. 
 	 
     <p>Например, если имеется массив значений <codeph>[2005, 7, 35]</codeph>, а константа <codeph>NUMERIC</codeph> <b>не</b> включена в параметр <codeph>options</codeph>, отсортированный массив выглядит как <codeph>[2005, 35, 7]</codeph>, но если константа <codeph>NUMERIC</codeph> <b>включена</b>, он выглядит следующим образом: <codeph>[7, 35, 2005]</codeph>. </p>
 	 
 	 <p>Эта константа применяется только к числам в массиве; она не применяется к строкам, которые содержат числовые данные (например, <codeph>["23", "5"]</codeph>).</p>
 	 
 	 <p>Значение этой константы равно 16.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:RETURNINDEXEDARRAY"><apiName>RETURNINDEXEDARRAY</apiName><shortdesc>
	 Задает сортировку, которая возвращает массив, состоящий из индексов массивов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F9
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Задает сортировку, которая возвращает массив, состоящий из индексов массивов. Эту константу можно использовать для параметра <codeph>options</codeph> в методе <codeph>sort()</codeph> или <codeph>sortOn()</codeph>. Таким образом, у вас есть доступ к нескольким представлениям элементов массива в то время, как исходный массив остается неизменным. 
 	 <p>Значение этой константы равно 8.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:UNIQUESORT"><apiName>UNIQUESORT</apiName><shortdesc>
     Задает уникальное требование сортировки для методов сортировки класса Array.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217FA
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Задает уникальное требование сортировки для методов сортировки класса Array. Эту константу можно использовать для параметра <codeph>options</codeph> в методе <codeph>sort()</codeph> или <codeph>sortOn()</codeph>. Эта уникальная возможность прекращает сортировку, если любые два сортируемых элемента имеют одинаковые значения. 
	 <p>Значение этой константы равно 4.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:length:get"><apiName>length</apiName><shortdesc>
	 Неотрицательное целое число, которым задается количество элементов в массиве.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Неотрицательное целое число, которым задается количество элементов в массиве. Это свойство автоматически обновляется, когда в массив добавляются новые элементы. Когда элементу массива присваивается свойство (например, <codeph>my_array[index] = value</codeph>), если <codeph>index</codeph> является числом, а <codeph>index+1</codeph> превышает значение свойства <codeph>length</codeph>, свойство <codeph>length</codeph> обновляется, принимая значение <codeph>index+1</codeph>.
   	 <p><b>Примечание. </b>Если свойству <codeph>length</codeph> присваивается значение, которое меньше существующей длины, массив усекается.</p>
   	 
	 </apiDesc><example conref="examples\Array.length.1.as"> Следующий код создает объект Array <codeph>names</codeph> со строковым элементом <codeph>Bill</codeph>. После этого используется метод <codeph>push()</codeph> для добавления еще одного строкового элемента <codeph>Kyle</codeph>. Длина массива, определяемая свойством <codeph>length</codeph>, составляла один элемент перед применением метода <codeph>push()</codeph>. После вызова <codeph>push()</codeph> она составляет два элемента. Добавляется еще одна строка (<codeph>Jeff</codeph>), которая увеличивает длину объекта <codeph>names</codeph> до трех элементов. Затем дважды вызывается метод <codeph>shift()</codeph> для удаления элементов <codeph>Bill</codeph> и <codeph>Kyle</codeph>, после чего параметру <codeph>length</codeph> массива присваивается значение 1.
<codeblock>

var names:Array = new Array("Bill");
names.push("Kyle");
trace(names.length); // 2

names.push("Jeff");
trace(names.length); // 3

names.shift();
names.shift();
trace(names.length); // 1
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:RegExp"><apiName>RegExp</apiName><shortdesc>
     
     Класс RegExp позволяет работать с регулярными выражениями, которые используются в качестве шаблонов для поиска в строках, а также для замены текста в строках.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp
     </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     
     Класс RegExp позволяет работать с регулярными выражениями, которые используются в качестве шаблонов для поиска в строках, а также для замены текста в строках.
     
     <p>Новый объект RegExp можно создать с помощью конструктора <codeph>new RegExp()</codeph> или путем присвоения литерала RegExp переменной:</p>
     
     <codeblock> var pattern1:RegExp = new RegExp("test-\\d", "i");
     var pattern2:RegExp = /test-\d/i;
     </codeblock>
     
     <p>Дополнительную информацию см. в главе «Использование регулярных выражений» документа <i>Программирование на ActionScript 3.0</i>.</p>
     
     </apiDesc><example conref="examples\RegExpExample.as"> В следующем примере показано, как с помощью регулярных выражений можно выполнить синтаксический разбор строк и вернуть новую строку или логическое значение на основе переданной строки. Метод <codeph>informalizeGreeting()</codeph> просто заменяет слово <codeph>Hello</codeph> выражением <codeph>Hi</codeph> независимо от регистра. Кроме того, он удаляет фамилию имени в строке (предполагается, что она соответствует определенному шаблону). В методах <codeph>validateEmail()</codeph> и <codeph>validatePhoneNumber()</codeph> переданная строка проверяется на предмет соответствия шаблона действительному шаблону адреса электронной почты или конкретного телефонного номера. В зависимости от результатов методы возвращают логические значения. 
<codeblock>
package {
    import flash.display.Sprite;

    public class RegExpExample extends Sprite {        
        public function RegExpExample() {            
            var formalGreeting:String = "Hello, John Smith.";
            trace(informalizeGreeting(formalGreeting));    // Hi, John.

            var validEmail:String = "name@domain.com";
            trace(validateEmail(validEmail));        // true
            
            var invalidEmail:String = "foo";
            trace(validateEmail(invalidEmail));  // false
            
            var validPhoneNumber:String = "415-555-1212";
            trace(validatePhoneNumber(validPhoneNumber));    // true
            
            var invalidPhoneNumber:String = "312-867-530999";
            trace(validatePhoneNumber(invalidPhoneNumber));  // false
        }
        private function informalizeGreeting(str:String):String {
            var pattern:RegExp = new RegExp("hello, (\\w+) \\w+", "i");
            return str.replace(pattern, "Hi, $1");
        }
        private function validateEmail(str:String):Boolean {
            var pattern:RegExp = /(\w|[_.\-])+@((\w|-)+\.)+\w{2,4}+/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
        private function validatePhoneNumber(str:String):Boolean {
            var pattern:RegExp = /^\d{3}-\d{3}-\d{4}$/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/replace()"><linktext>String.replace()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links><apiConstructor id="RegExp:RegExp"><apiName>RegExp</apiName><shortdesc>
        Позволяет создавать регулярное выражение из двух строк.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.attribute, attribute
        </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>re</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Шаблон регулярного выражения (также называется <i>строкой конструктора</i>). Это основная часть регулярного выражения (ограниченная символами «/»). 
        
        <p><b>Примечания.</b> </p>
        
        <ul>
        
        <li>Не включайте в начале и в конце символы «/»; применяйте их только для того, чтобы определить литерал регулярного выражения, не используя конструктор. Например, эквивалентными являются следующие два регулярных выражения:
        
        <codeblock> var re1:RegExp = new RegExp("bob", "i"); 
        var re2:RegExp = /bob/i;</codeblock>
        
        </li>
        
        <li>В регулярном выражении, которое определяется методом конструктора <codeph>RegExp()</codeph>, чтобы воспользоваться метапоследовательностью, которая начинается с символа обратной косой черты (\) (например, <codeph>\d</codeph>, что соответствует любой цифре), дважды введите символ обратной косой черты. Например, эквивалентными являются следующие два регулярных выражения:
        
        <codeblock> var re1:RegExp = new RegExp("\\d+", ""); 
        var re2:RegExp = /\d/;</codeblock>
        
        <p>В первом выражении необходимо в данном случае ввести символ обратной косой черты дважды, поскольку первый параметр метода конструктора <codeph>RegExp() </codeph> является строкой. В строковом литерале строки также необходимо дважды ввести символ обратной косой черты, чтобы он распознавался как единичный символ.</p>
        
        </li>
        
        </ul>
        
        </apiDesc></apiParam><apiParam><apiItemName>flags</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Модификаторы регулярного выражения. В их число входят следующие:
        
        <ul>
        
           <li> <codeph>g</codeph> ? При использовании метода <codeph>replace()</codeph> класса String укажите модификатор для замены всех совпадений, а не только для первого из них. Этот модификатор соответствует свойству <codeph>global</codeph> экземпляра RegExp.</li>
           <li> <codeph>i</codeph> ? Анализ регулярного выражения выполнен <i>без учета</i> регистра. Этот модификатор соответствует свойству <codeph>ignoreCase</codeph> экземпляра RegExp.</li>
           <li> <codeph>s</codeph> ? Точка (<codeph>. </codeph>) соответствует символам новой строки. Примечание. Этот модификатор соответствует свойству <codeph>dotall</codeph> экземпляра RegExp.</li>
           <li> <codeph>m</codeph> ? Символ вставки (<codeph>^</codeph>) и символ доллара (<codeph>$</codeph>) совпадают до <i>и</i> после символов новой строки. Этот модификатор соответствует свойству <codeph>multiline</codeph> экземпляра RegExp.</li>
           <li> <codeph>x</codeph> ? Символы пробела в строке <codeph>re</codeph> игнорируются, что позволяет записывать удобочитаемые конструкторы. Этот модификатор соответствует свойству <codeph>extended</codeph> экземпляра RegExp.</li>
        
        </ul>
        
        <p>Все остальные символы в строке <codeph>flags</codeph> игнорируются. </p>
        
        </apiDesc></apiParam></apiConstructorDef><apiDesc>
        Позволяет создавать регулярное выражение из двух строк. Одна строка определяет шаблон регулярного выражения, а другая – флаги, которые в нем используются. 
        
        </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="RegExp:AS3:exec"><apiName>exec</apiName><shortdesc>
         Выполняет поиск регулярного выражения в заданной строке str.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.exec, exec
         </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если совпадения не найдено, появляется значение <codeph>null</codeph>; в противном случае появляется объект, имеющий следующие свойства: 
         
         <ul>
         
          <li>Массив, в котором элемент 0 содержит полную совпадающую подстроку, а остальные элементы массива (от 1 до <i>n</i>) содержат подстроки, которые соответствуют группам, заключенным в регулярном выражении в скобки. </li>
         
          <li><codeph>index</codeph> ? Позиция символа совпадающей подстроки в строке</li>
         
          <li><codeph>input</codeph> ? Строка (<codeph>str</codeph>)</li>
         
         </ul>
         
         
         </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Искомая строка.  
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Выполняет поиск регулярного выражения в заданной строке <codeph>str</codeph>. 
         
         <p>Если флаг <codeph>g</codeph> (<codeph>global</codeph>) <i>не</i> установлен для этого регулярного выражения, то поиск начинается с начала строки (с позиции индекса 0); при поиске игнорируется свойство <codeph>lastIndex</codeph> регулярного выражения.</p>
         
         <p>Если флаг <codeph>g</codeph> (<codeph>global</codeph>) <i>установлен</i> для регулярного выражения, то поиск начинается с позиции индекса, указанной в свойстве <codeph>lastIndex</codeph> регулярного выражения. Если в результате поиска найдено совпадение подстроки, значение свойства <codeph>lastIndex</codeph> становится равным позиции конца совпадающей подстроки. </p>
         
         </apiDesc><example>Когда флаг <codeph>g</codeph> (<codeph>global</codeph>) <i>не</i> установлен в регулярном выражении, то можно воспользоваться <codeph>exec()</codeph>, чтобы найти первое совпадение в строке: 
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;   
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         trace(result);
         </codeblock>
         
         <p> Объекту <codeph>result</codeph> присваивается следующее значение:</p>
         
         <ul>
         
          <li> <codeph>result[0]</codeph> присваивается значение<codeph>She</codeph> (полное совпадение). </li>
         
          <li> <codeph>result[1]</codeph> присваивается значение пустой строки (первая совпадающая группа в скобках). </li>
         
          <li> <codeph>result[2]</codeph> присваивается значение <codeph>«e»</codeph> (вторая совпадающая группа в скобках). </li>
         
          <li> <codeph>result.index</codeph> присваивается значение 0.</li>
         
          <li> <codeph>result.input</codeph> присваивается значение строки ввода: <codeph>She sells seashells by the seashore</codeph>.</li>
         
         </ul> 
         
         
         
         <p> В следующем примере флаг <codeph>g</codeph> (<codeph>global</codeph>) <i>устанавливается</i> в регулярном выражении, чтобы <codeph>exec()</codeph> можно было повторно использовать для поиска нескольких совпадений:</p>
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;  
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         
         while (result != null) {
             trace ( result.index, "\t", result);
             result = myPattern.exec(str);
         }
         </codeblock>
         
         <p> Результатом выполнения этого кода становится следующие выходные данные:</p>
         
         <pre><codeph>
            0      She,,e
            10     seashells,sea,ells
            27     seashore,sea,ore
         </codeph></pre>
         
         </example></apiOperationDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links></apiOperation><apiOperation id="RegExp:AS3:test"><apiName>test</apiName><shortdesc>
         Проверяет совпадение регулярного выражения в данной строке str.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.test, test
          
          </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>В случае совпадения выбирается значение <codeph>true</codeph>; в противном случае – <codeph>false</codeph>.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тестируемая строка.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Проверяет совпадение регулярного выражения в данной строке <codeph>str</codeph>. 
         
         <p>Если флаг <codeph>g</codeph> (<codeph>global</codeph>) <i>не</i> установлен для этого регулярного выражения, то поиск начинается с начала строки (с позиции индекса 0); при поиске игнорируется свойство <codeph>lastIndex</codeph> регулярного выражения.</p>
         
         <p>Если флаг <codeph>g</codeph> (<codeph>global</codeph>) <i>установлен</i> для регулярного выражения, то поиск начинается с позиции индекса, указанной в свойстве <codeph>lastIndex</codeph> регулярного выражения. Если в результате поиска найдено совпадение подстроки, значение свойства <codeph>lastIndex</codeph> становится равным позиции конца совпадающей подстроки. </p>
         
         </apiDesc><example conref="examples\RegExp.test.1.as"> В следующем примере показано применение метода <codeph>test()</codeph> по отношению к регулярному выражению, в котором установлен флаг <codeph>g</codeph> (<codeph>global</codeph>): 
<codeblock>
var re1:RegExp = /\w/g;
var str:String = "a b c";
trace (re1.lastIndex); // 0
trace (re1.test(str)); // true
trace (re1.lastIndex); // 1
trace (re1.test(str)); // true
trace (re1.lastIndex); // 3
trace (re1.test(str)); // true
trace (re1.lastIndex); // 5
trace (re1.test(str)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="RegExp:dotall:get"><apiName>dotall</apiName><shortdesc>
         Указывает, совпадает ли символ точки (.) в шаблоне регулярного выражения с символами новой строки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.dotall, dotall
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Указывает, совпадает ли символ точки (.) в шаблоне регулярного выражения с символами новой строки. Воспользуйтесь флагом <codeph>s</codeph> при создании регулярного выражения для выбора <codeph>dotall = true</codeph>.
         
         </apiDesc><example conref="examples\RegExp.dotall.1.as"> В следующем примере показано воздействие флага <codeph>s</codeph> (<codeph>dotall</codeph>) на регулярное выражение: 
<codeblock>
var str:String = "&lt;p>Hello\n"
        + "again&lt;/p>"
        + "&lt;p>Hello&lt;/p>";

var pattern:RegExp = /&lt;p>.*?&lt;\/p>/;
trace(pattern.dotall) // false
trace(pattern.exec(str)); // &lt;p>Hello&lt;/p>

pattern = /&lt;p>.*?&lt;\/p>/s;
trace(pattern.dotall) // true
trace(pattern.exec(str)); 
   </codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:extended:get"><apiName>extended</apiName><shortdesc>
         Определяет, должен ли использоваться расширенный режим для регулярного выражения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.extended, extended
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Определяет, должен ли использоваться расширенный режим для регулярного выражения. Когда объект RegExp находится в расширенном режиме, символы пробелов в строке конструктора игнорируются. Это позволяет создавать более читабельные конструкторы.
         
         <p>Воспользуйтесь флагом <codeph>x</codeph> при создании регулярного выражения, чтобы установить <codeph>extended = true</codeph>. </p>
         
         </apiDesc><example conref="examples\RegExp.extended.1.as"> В следующем примере показаны различные способы создания одного и того же регулярного выражения. В каждом случае регулярное выражение должно соответствовать определенному шаблону телефонного номера (xxx-xxx-xxxx, (xxx) xxx-xxxx или (xxx)xxx-xxxx). Во втором выражении используется флаг <codeph>x</codeph>, приводящий к тому, что пробелы в строке игнорируются. 
<codeblock>
var rePhonePattern1:RegExp = /\d{3}-\d{3}-\d{4}|\(\d{3}\)\s?\d{3}-\d{4}/; 
var str:String = "The phone number is (415)555-1212.";

trace(rePhonePattern1.extended) // false
trace(rePhonePattern1.exec(str)); // (415)555-1212

var rePhonePattern2:RegExp = / \d{3}-\d{3}-\d{4}  |   \( \d{3} \) \ ? \d{3}-\d{4}  /x; 
trace(rePhonePattern2.extended) // true
trace(rePhonePattern2.exec(str)); // (415)555-1212
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:global:get"><apiName>global</apiName><shortdesc>
         Определяет, должен ли использоваться глобальный поиск совпадений для регулярного выражения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.global, global
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Определяет, должен ли использоваться глобальный поиск совпадений для регулярного выражения. Когда <codeph>global == true</codeph>, свойство <codeph>lastIndex</codeph> устанавливается после нахождения совпадения. При следующем запросе совпадения механизм регулярных выражений начинает работать с позиции в строке, указанной в свойстве <codeph>lastIndex</codeph>. Воспользуйтесь флагом <codeph>g</codeph> при создании регулярного выражения, чтобы выбрать для свойства <codeph>global</codeph> значение <codeph>true</codeph>. 
         
         </apiDesc><example conref="examples\RegExp.global.1.as"> В следующем примере показано влияние установки флага <codeph>g</codeph> (<codeph>global</codeph>) в методе <codeph>exec()</codeph>:
<codeblock>
var pattern:RegExp = /foo\d/; 
var str:String = "foo1 foo2";
trace(pattern.global); // false
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 0
trace(pattern.exec(str)); // foo1

pattern = /foo\d/g;
trace(pattern.global); // true
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 4
trace(pattern.exec(str)); // foo2
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:ignoreCase:get"><apiName>ignoreCase</apiName><shortdesc>
         Определяет, игнорируется ли регистр регулярного выражения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.ignoreCase, ignoreCase
         </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Определяет, игнорируется ли регистр регулярного выражения. Воспользуйтесь флагом <codeph>i</codeph> при создании регулярного выражения, чтобы установить <codeph>ignoreCase = true</codeph>. 
         
         </apiDesc><example conref="examples\RegExp.ignoreCase.1.as"> В следующем примере показано влияние установки флага <codeph>i</codeph> (<codeph>ignoreCase</codeph>):
<codeblock>
var pattern:RegExp = /bob/; 
var str:String = "Bob bob";
trace(pattern.ignoreCase); // false
trace(pattern.exec(str)); // bob

pattern = /bob/i;
trace(pattern.ignoreCase); // true
trace(pattern.exec(str)); // Bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:lastIndex:get"><apiName>lastIndex</apiName><shortdesc>
         Определяет позицию в индексе для строки, с которой должен начинаться следующий поиск.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.lastIndex, lastIndex
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
         Определяет позицию в индексе для строки, с которой должен начинаться следующий поиск. Это свойство влияет на методы <codeph>exec()</codeph> и <codeph>test()</codeph> класса RegExp. Однако методы <codeph>match()</codeph>, <codeph>replace()</codeph> и <codeph>search()</codeph> класса String игнорируют свойство <codeph>lastIndex</codeph> и всегда начинают поиск с начала строки.
         
         <p>Когда метод <codeph>exec()</codeph> или <codeph>test()</codeph> находит совпадение, флаг <codeph>g</codeph> (<codeph>global</codeph>) устанавливается со значением <codeph>true</codeph> для регулярного выражения. С помощью этого метода свойство <codeph>lastIndex</codeph> автоматически устанавливается в соответствии с позицией в индексе символа, который следует <i>за</i> последним символом в совпадающей подстроке последнего совпадения. Если флаг <codeph>g</codeph> (<codeph>global</codeph>) принимает значение <codeph>false</codeph>, метод не устанавливает свойство <codeph>lastIndex</codeph>.</p>
         
         <p>Свойство <codeph>lastIndex</codeph> можно установить так, чтобы скорректировать начальную позицию в строке для поиска регулярных выражений. </p>
         
         </apiDesc><example conref="examples\RegExp.lastIndex.1.as"> В следующем примере показано воздействие установки свойства <codeph>lastIndex</codeph> и то, как оно обновляется после вызова метода <codeph>exec()</codeph> для регулярного выражения, в котором установлен флаг <codeph>g</codeph> (<codeph>global</codeph>):
<codeblock>
var pattern:RegExp = /\w\d/g; 
var str:String = "a1 b2 c3 d4";
pattern.lastIndex = 2; 
trace(pattern.exec(str)); // b2
trace(pattern.lastIndex); // 5
trace(pattern.exec(str)); // c3
trace(pattern.lastIndex); // 8
trace(pattern.exec(str)); // d4
trace(pattern.lastIndex); // 11
trace(pattern.exec(str)); // null
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:multiline:get"><apiName>multiline</apiName><shortdesc>
         Определяет, установлен ли флаг m (multiline).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.multiline, multiline
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Определяет, установлен ли флаг <codeph>m</codeph> (<codeph>multiline</codeph>). Если он установлен, совпадает знак вставки (<codeph>^</codeph>) и знак доллара (<codeph>$</codeph>), расположенные в регулярном выражении до и после новой строки. Воспользуйтесь флагом <codeph>m</codeph> при создании регулярного выражения, чтобы установить <codeph>multiline = true</codeph>.
         
         </apiDesc><example conref="examples\RegExp.multiline.1.as"> В следующем примере показано влияние установки флага <codeph>m</codeph> (<codeph>multiline</codeph>):
<codeblock>
var pattern:RegExp = /^bob/; 
var str:String = "foo\n"
                + "bob";
trace(pattern.multiline); // false
trace(pattern.exec(str)); // null

pattern = /^bob/m;
trace(pattern.multiline); // true
trace(pattern.exec(str)); // bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:source:get"><apiName>source</apiName><shortdesc>
         Определяет шаблонную часть регулярного выражения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.source, source
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Определяет шаблонную часть регулярного выражения.
         
         </apiDesc><example conref="examples\RegExp.source.1.as"> Следующий код выдает параметр <codeph>source</codeph> для двух регулярных выражений:
<codeblock>
var re1:RegExp = /aabb/gi;
trace (re1.source); // aabb

var re2:RegExp = new RegExp("x+y*", "i");
trace(re2.source); // x+y*
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Date"><apiName>Date</apiName><shortdesc>
 Класс Date представляет сведения о дате и времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Date object, built-in class, date 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Date представляет сведения о дате и времени. Экземпляр класса Date представляет определенный момент времени, для которого можно запросить или изменить такие свойства как месяц, день, часы и секунды. Класс Date позволяет извлекать значения даты и времени относительно всемирного времени (среднее время по Гринвичу, которое теперь называется всемирным скоординированным временем или UTC) или местного времени, которое определяется по настройке местного часового пояса в той операционной системе, где запущен Flash Player. Методы класса Date не являются статическими, но применяются только к отдельным объектам Date, указанным при вызове метода. Методы <codeph>Date.UTC()</codeph> и <codeph>Date.parse()</codeph> представляют собой исключение, являясь статическими.
 <p product="flash">Класс Date по-разному обрабатывает переход на летнее время в зависимости от операционной системы и версии Flash Player. Flash Player версии 6 и выше учитывает переход на летнее время в следующих операционных системах.</p>
 <ul product="flash">
 <li>Windows – объект Date автоматически корректирует выводимые данные с учетом перехода на летнее время. Объект Date распознает ситуации, когда переход на летнее время включен в текущем регионе. При этом регистрируется стандартная дата и время данного перехода. Однако даты переходов, выбранные в данный момент, применяются к датам в прошлом и будущем, поэтому расчет временного сдвига может выполняться с ошибкой для прошедших дат, приходящихся на период действия других дат перехода для этого региона.</li>
 <li>Mac OS X – объект Date автоматически корректирует выводимые данные с учетом перехода на летнее время. Информационная база данных о часовых поясах используется в Mac OS X, чтобы определять, необходимо ли применять сдвиг по времени к любым текущим или прошедшим дате и времени.</li>
 <li>Mac OS 9 – в этой операционной системе приводятся сведения, которых достаточно только для определения того, необходимо ли применять временной сдвиг к текущим дате и времени. Исходя из этого, объект Date допускает, что текущий временной сдвиг применяется ко всем прошедшим или еще не наступившим датам.</li>
 </ul>
 <p product="flash">Переход на летнее время обрабатывается Flash Player 5 в следующих операционных системах.</p>
 <ul product="flash">
 <li>В Windows всегда применяются правила перехода на летнее время для США. Это приводит к ошибкам в Европе и других странах, где переход на летнее время принят, но происходит в другой день, нежели в США. Flash правильно определяет, принят ли переход на летнее время в том или ином регионе.</li>
 </ul>
 <p>Чтобы воспользоваться классом Date, создайте экземпляр Date с помощью оператора <codeph>new</codeph>.</p>
 <p>В ActionScript 3.0 добавлено несколько новых свойств средств доступа, которыми можно пользоваться вместо многих методов класса Date, которые выполняют доступ к экземплярам Date или модифицируют их. Также ActionScript 3.0 содержит ряд новых вариантов метода <codeph>toString()</codeph>, добавленных в целях соответствия третьему изданию ECMA-262, включая: <codeph>Date.toLocaleString()</codeph>, <codeph>Date.toTimeString()</codeph>, <codeph>Date.toLocaleTimeString()</codeph>, <codeph>Date.toDateString()</codeph> и <codeph>Date.toLocaleDateString()</codeph>.</p>
 <p>Чтобы вычислить относительное или прошедшее время, воспользуйтесь методом <codeph>getTimer()</codeph> из пакета flash.utils.</p>
 
 </apiDesc><example conref="examples\DateExample.as"> В следующем примере показаны различные применения конструктора <codeph>Date()</codeph>, присваивающего следующие переменные:
 <ul>
   <li><codeph>myDate1</codeph> вызывает конструктор <codeph>Date()</codeph> без параметров. При этом для <codeph>myDate1</codeph> выбираются текущие дата и время (исходя из текущих системных даты и времени). </li>
   <li><codeph>myDate2</codeph> вызывает конструктор <codeph>Date()</codeph>, для которого выбраны параметры <codeph>year</codeph> (<codeph>2000</codeph>), month (<codeph>0</codeph> = январь) и <codeph>day</codeph> (<codeph>1</codeph>).</li>
   <li><codeph>myDate3</codeph> вызывает конструктор <codeph>Date()</codeph>, для которого выбраны параметры <codeph>year</codeph> (<codeph>65</codeph> = 1965), <codeph>month</codeph> (<codeph>2</codeph> = март), <codeph>day</codeph> (<codeph>6</codeph>), <codeph>hour</codeph> (<codeph>9</codeph>), <codeph>minute</codeph> (<codeph>30</codeph>), <codeph>second</codeph> (<codeph>15</codeph>) и <codeph>millisecond</codeph>-+ (<codeph>0</codeph>).</li>
   <li><codeph>myDate4</codeph> вызывает конструктор <codeph>Date()</codeph>, временное значение которого отражает количество миллисекунд <b>до</b> 0:00:00 1 января 1970 г. (среднее время по Гринвичу), поскольку это отрицательное значение.</li>
 </ul>
<codeblock>

package {
    import flash.display.Sprite;
    
    public class DateExample extends Sprite{
        public function DateExample() {
            var myDate1:Date = new Date();
            trace(myDate1); // [NOW]

            var myDate2:Date = new Date(2000, 0, 1);
            trace(myDate2); // Sat Jan 1 00:00:00 GMT-0800 2000

            var myDate3:Date = new Date(65, 2, 6, 9, 30, 15, 0);
            trace(myDate3); // Sat Mar 6 09:30:15 GMT-0800 1965

            var myDate4:Date = new Date(-14159025000);
            trace(myDate4); // Sun Jul 20 19:56:15 GMT-0700 1969
        }        
    }    
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#/getTimer()"><linktext>flash.utils.getTimer()</linktext></link></related-links><apiConstructor id="Date:Date"><apiName>Date</apiName><shortdesc>
	 Создает новый объект Date, который содержит заданную дату и время.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new Date, constructor, date
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>yearOrTimevalue</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Если указаны другие параметры, это число выражает год (например, 1965); в противном случае оно представляет собой временное значение. Если данное число относится к году, значения с 0 до 99 указывают на 1900-1999 гг.; в противном случае необходимо указывать все четыре цифры года. Если число представляет собой временное значение (без дополнительно указанных параметров), оно отражает количество миллисекунд до или после 0:00:00 1 января 1970 г. (среднее время по Гринвичу); отрицательные значения отражают время <i>до</i> 0:00:00 1 января 1970 г. (среднее время по Гринвичу), а положительное значение указывает на время после этой даты.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (январь) до 11 (декабрь).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Целое число от 1 до 31. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 (полночь) до 23 (11 часов вечера).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 до 999 миллисекунд. 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект Date, который содержит заданную дату и время.  
	 
	 <p>Конструктор <codeph>Date()</codeph> может иметь до 7 параметров (year, month, ..., millisecond), позволяющих указывать дату и время с точностью до миллисекунды. Дата, которую содержит только что созданный объект Date зависит от количества и типа данных переданных аргументов. </p>
	 <ul>
	   <li>Если аргументы не указываются, объекту Date присваивается текущие дата и время.</li>
	   <li>Если передается один аргумент с типом данных Number, объекту Date присваивается временное значение, исходя из количества миллисекунд, прошедших с 0:00:000 1 января 1970 года (среднее время по Гринвичу) и указанных в этом единственном аргументе.</li>
	   <li>Если передается один аргумент с типом данных String, и в этой строке есть действительная дата, объект Date содержит временное значение, основанное на этой дате.</li>
	   <li>При передаче двух и большего числа аргументов объекту Date присваивается временное значение на основе переданных значений аргумента, которые относятся к году, месяцу, дате, часу, минуте, секунде и миллисекундам.</li>
	 </ul>
	 <p>Если конструктору класса Date передается строка, дата может быть представлена в разных форматах, но должна включать, по крайней мере, месяц, дату и год. Например, <codeph>Feb 1 2005</codeph> (1 февраля 2005 г.) – это действительное значение в отличие от <codeph>Feb 2005</codeph> (февраль 2005 г.). В списке ниже приведены некоторые действительные форматы:</p>
	 <ul>
	   <li>«День Месяц Дата Часы:Минуты:Секунды GMT Год» (например, значение «Tue Feb 1 00:00:00 GMT-0800 2005», совпадающее со значением <codeph>toString()</codeph>)</li>
	   <li>«День Месяц Дата Год Часы:Минуты:Секунды AM/PM» (например, значение «Tue Feb 1 2005 12:00:00 AM», совпадающее со значением <codeph>toLocaleString()</codeph>)</li>
	   <li>«День Месяц Дата Год» (например, значение «Tue Feb 1 2005», совпадающее со значением <codeph>toDateString()</codeph>)</li>
	   <li>Месяц/День/Год (например, «02/01/2005»)</li>
	   <li>Месяц/Год (например, «02/2005»)</li>
	 </ul>
	 </apiDesc></apiConstructorDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiConstructor><apiOperation id="Date:UTC"><apiName>UTC</apiName><shortdesc>
	 Возвращает число миллисекунд от полуночи 1 января 1970 года по Гринвичу до момента, заданного параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.utc, utc, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Количество миллисекунд, прошедших с 1 января 1970 г. до указанных даты и времени.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое четырехзначное число, указывающее на год (например, 2000).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (январь) до 11 (декабрь).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Целое число от 1 до 31. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 (полночь) до 23 (11 часов вечера).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число от 0 до 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает число миллисекунд от полуночи 1 января 1970 года по Гринвичу до момента, заданного параметрами. В этом методе используется всемирное скоординированное время, а в конструкторе <codeph>Date</codeph> – местное время.
	 <p>Этот метод полезен, если требуется передать дату в формате всемирного скоординированного времени (UTC) конструктору класса Date. Поскольку конструктор класса данных Date поддерживает в качестве аргумента смещение в миллисекундах, можно воспользоваться методом Date.UTC(), чтобы преобразовать дату в формате UTC в соответствующее смещение, выраженное в миллисекундах, а затем отправить это смещение в качестве аргумента конструктору класса Date:</p>
	 
	 </apiDesc><example conref="examples\Date.UTC.1.as"> В следующем примере создается объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>) по местному времени. Затем выполняется вызов <codeph>UTC()</codeph> в методе <codeph>setTime()</codeph>, который приводит к сбросу значений этих параметров и установке всемирного времени.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);
trace(someBirthday.toString());

someBirthday.setTime(Date.UTC(1974, 10, 30, 15, 20));
trace(someBirthday.toString());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getDate"><apiName>getDate</apiName><shortdesc>
	 Возвращает день месяца по местному времени (целое число от 1 до 31), заданный объектом Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getdate, getdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>День месяца (1 – 31), который представляет объект <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает день месяца по местному времени (целое число от 1 до 31), заданный объектом <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
 	 </apiDesc><example conref="examples\Date.getDate.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызывается метод <codeph>getDate()</codeph>, определяющий день месяца.
<codeblock>
package {
    import flash.display.Sprite;

    public class DateExample extends Sprite {

        public function DateExample() {
            var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
            trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
            trace(someBirthday.getDate()); // 30
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getDay"><apiName>getDay</apiName><shortdesc>
	 Возвращает день недели по местному времени (0 – воскресенье, 1 – понедельник, и т.д.), заданный объектом Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getday, getday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Числовая версия дня недели (0 – 6), который представляет объект <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает день недели по местному времени (0 – воскресенье, 1 – понедельник и т.д.), заданный объектом <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
 	 </apiDesc><example conref="examples\Date.getDay.1.as"> В следующем примере создается новый объект Array <codeph>weekDayLabels</codeph> с элементами <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph> и новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). После этого дважды вызывается метод <codeph>getDay()</codeph>, который сначала показывает число месяца в виде цифры 6, а затем показывает день недели с помощью <codeph>weekDayLabels</codeph>.
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                       // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDay());            // 6
trace(weekDayLabels[someBirthday.getDay()]); // Saturday
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getFullYear"><apiName>getFullYear</apiName><shortdesc>
	 Возвращает из объекта Date полный год по местному времени (четырехзначное число, например 2000).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getfullyear, getfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Полный год, который представляет объект <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> полный год по местному времени (четырехзначное число, например 2000). Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.getFullYear.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). После этого вызывается метод <codeph>getFullYear()</codeph>, который извлекает четырехзначное обозначение года.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getHours"><apiName>getHours</apiName><shortdesc>
	 Возвращает час (целое число от 0 до 23) дня, относящегося к объекту Date, по местному времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gethours, gethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Час (0 – 23) дня, представленного объектом <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает час (целое число от 0 до 23) дня, относящегося к объекту <codeph>Date</codeph>, по местному времени. Местное время определяется операционной системой, в которой запущен Flash Player. 
	 
	 </apiDesc><example conref="examples\Date.getHours.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызываются методы <codeph>getHours()</codeph> и <codeph>getMinutes()</codeph>, которые извлекают часы и минуты в 24-часовом формате. В итоге создается строка <codeph>localTime</codeph>, которая присваивается результату вызова функции <codeph>getUSClockTime()</codeph>, которая, в свою очередь, снова вызывает методы <codeph>getHours()</codeph> и <codeph>getMinutes()</codeph>, указывающее время <codeph>03:05 PM</codeph>.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMilliseconds"><apiName>getMilliseconds</apiName><shortdesc>
	 Возвращает из объекта Date число миллисекунд по местному времени (целое число от 0 до 999).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmilliseconds, getmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с миллисекундами.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> число миллисекунд по местному времени (целое число от 0 до 999). Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.getMilliseconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getMilliseconds()</codeph>, который извлекает из объекта Date <codeph>now</codeph> число миллисекунд на момент создания
<codeblock>

var now:Date = new Date();
trace(now.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMinutes"><apiName>getMinutes</apiName><shortdesc>
	 Возвращает из объекта Date число минут по местному времени (целое число от 0 до 59).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getminutes, getminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с минутами.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> число минут по местному времени (целое число от 0 до 59). Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.getMinutes.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getMinutes()</codeph>, который извлекает из объекта Date <codeph>now</codeph> число миллисекунд на момент создания
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMonth"><apiName>getMonth</apiName><shortdesc>
	 Возвращает из объекта Date месяц по местному времени (0 – январь, 1 – февраль и т.д.).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmonth, getmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с месяцем (0 - 11).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> месяц по местному времени (0 – январь, 1 – февраль и т.д.). Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.getMonth.1.as"> В следующем примере создается новый объект Array <codeph>monthLabels</codeph> с элементами от <codeph>January</codeph> до <codeph>December</codeph> и новый объект Date <codeph>now</codeph> без параметров. Затем дважды вызывается метод <codeph>getMonth()</codeph>, который сначала возвращает номер месяца, а затем указывает месяц создания объекта Date <codeph>now</codeph>.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getSeconds"><apiName>getSeconds</apiName><shortdesc>
	 Возвращает из объекта Date число секунд по местному времени (целое число от 0 до 59).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getseconds, getseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с секундами (от 0 до 59).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> число секунд по местному времени (целое число от 0 до 59). Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.getSeconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getSeconds()</codeph>, который извлекает из объекта Date <codeph>now</codeph> число миллисекунд на момент создания.
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTime"><apiName>getTime</apiName><shortdesc>
	 Возвращает для объекта Date число миллисекунд с полуночи 1 января 1970 года по всемирному скоординированному времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettime, gettime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Количество миллисекунд с 1 января 1970 г., выражаемых объектом <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает для объекта <codeph>Date</codeph> число миллисекунд с полуночи 1 января 1970 года по всемирному скоординированному времени. Воспользуйтесь этим методом, чтобы представить определенный момент во времени при сравнении двух и более объектов <codeph>Date</codeph>.
	 
	 </apiDesc><example conref="examples\Date.getTime.1.as"> В следующем примере создается новый объект Date <codeph>mlk</codeph> с параметрами <codeph>year</codeph> (<codeph>1929</codeph>), <codeph>month</codeph> (<codeph>0</codeph> = январь) и <codeph>day</codeph> (<codeph>15</codeph>). Затем вызывается метод <codeph>getTime()</codeph>, который извлекает количество миллисекунд, прошедших с 1 января 1970 г. Это отрицательное число, поскольку выбран 1929 г.
<codeblock>

var mlk:Date = new Date(1929, 0, 15);
trace(mlk);           // Tue Jan 15 00:00:00 GMT-0800 1929
trace(mlk.getTime()); // -1292601600000
</codeblock></example><example conref="examples\Date.getTime.2.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров, а затем используются следующие методы класса DateMath (созданные ниже), добавляющие время в исходный объект Date <codeph>now</codeph>, прошедшее с момента его создания:
 <ul>
   <li><codeph>addSeconds()</codeph>: добавляет 30 секунд к объекту <codeph>now</codeph>.</li>
   <li><codeph>addMinutes()</codeph>: добавляет 30 минут к объекту <codeph>now</codeph>.</li>
   <li><codeph>addHours()</codeph>: добавляет 6 часов к объекту Date <codeph>now</codeph>.</li>
   <li><codeph>addHours()</codeph>: добавляет 30 дней к объекту Date <codeph>now</codeph>.</li>
   <li><codeph>addWeeks()</codeph>: добавляет 4 недели к объекту <codeph>now</codeph>.</li>
 </ul>

<codeblock>

var now:Date = new Date();
trace(now);
trace(DateMath.addSeconds(now, 30));
trace(DateMath.addMinutes(now, 30));
trace(DateMath.addHours(now, 6));
trace(DateMath.addDays(now, 30));
trace(DateMath.addWeeks(now, 4));

class DateMath {
    public static function addWeeks(date:Date, weeks:Number):Date {
        return addDays(date, weeks*7);
    }

    public static function addDays(date:Date, days:Number):Date {
        return addHours(date, days*24);
    }

    public static function addHours(date:Date, hrs:Number):Date {
        return addMinutes(date, hrs*60);
    }

    public static function addMinutes(date:Date, mins:Number):Date {
        return addSeconds(date, mins*60);
    }

    public static function addSeconds(date:Date, secs:Number):Date {
        var mSecs:Number = secs * 1000;
        var sum:Number = mSecs + date.getTime();
        return new Date(sum);
    }
}
</codeblock> <b>Примечание</b>. Не забывайте применять метод getTime при выполнении арифметических расчетов с объектом Date, поскольку он продолжает выполняться в високосные годы и не требует наличия набора логических операций с условием «если, то», как в следующем псевдокоде:
 <pre>
 function addMonths(num:Number):void {
     currentMonth = currentMonth + num;
     if(currentMonth > 12) {
         currentYear++;
         currentMonth = currentMonth - 12;
     }
 }
 </pre>
</example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTimezoneOffset"><apiName>getTimezoneOffset</apiName><shortdesc>
     Возвращает разницу в минутах между местным временем компьютера и всемирным скоординированным временем (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettimezoneoffset, gettimezoneoffset, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Число минут, которые необходимо добавить к значению местного времени компьютера, чтобы оно равнялось UTC. Если время компьютера опережает UTC, возвращается отрицательное значение.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Возвращает разницу в минутах между местным временем компьютера и всемирным скоординированным временем (UTC). 
	 
	 </apiDesc><example conref="examples\Date.getTimezoneOffset.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getTimezoneOffset()</codeph>, который извлекает разницу (в минутах) между моментом создания объекта <codeph>now</codeph> и всемирным временем. Затем смещение временного пояса преобразуется в часы путем деления результата на 60.
<codeblock>

var date:Date = new Date();
trace(date.getTimezoneOffset() / 60);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCDate"><apiName>getUTCDate</apiName><shortdesc>
	 Возвращает из объекта Date день месяца (целое число от 1 до 31) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcdate, getutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>День месяца в формате UTC (1 – 31), который представляет объект <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> день месяца (целое число от 1 до 31) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCDate.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызывается метод <codeph>getUTCDate()</codeph>, который извлекает число месяца в формате UTC.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);             // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCDay"><apiName>getUTCDay</apiName><shortdesc>
	 Возвращает из объекта Date день недели (0 – воскресенье, 1 – понедельник и т. д.) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcday, getutcday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>День недели в формате UTC (0 – 6), который представляет объект <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> день недели (0 – воскресенье, 1 – понедельник и т. д.) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCDay.1.as"> В следующем примере создается новый объект Array <codeph>weekDayLabels</codeph> с элементами <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph> и новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). После этого дважды вызывается метод <codeph>getUTCDay()</codeph>, который сначала показывает число месяца в виде цифры 6, а затем показывает день недели с помощью <codeph>weekDayLabels</codeph> в формате UTC.
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDay()); // 6
trace(weekDayLabels[someBirthday.getUTCDay()]); // Saturday
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCFullYear"><apiName>getUTCFullYear</apiName><shortdesc>
	 Возвращает из объекта Date четырехзначный год по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcfullyear, getutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Четырехзначный год по всемирному скоординированному времени, который представляется объектом <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> четырехзначный год по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCFullYear.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызывается метод <codeph>getUTCFullYear()</codeph>, который извлекает четырехзначный год в формате UTC.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                 // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCHours"><apiName>getUTCHours</apiName><shortdesc>
	 Возвращает из объекта Date час дня (целое число от 0 до 23) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutchours, getutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>День недели в формате UTC (от 0 до 23), который представляет объект <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> час дня (целое число от 0 до 23) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCHours.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызываются методы <codeph>getHours()</codeph> и <codeph>getMinutes()</codeph>, которые извлекают часы и минуты в 24-часовом формате. В итоге создается строка <codeph>localTime</codeph>, которая присваивается результату вызова функции <codeph>getUSClockTime()</codeph>, которая, в свою очередь, снова вызывает методы <codeph>getHours()</codeph> и <codeph>getMinutes()</codeph>, указывающее время <codeph>03:05 PM</codeph>. Последней создается переменная String <codeph>utcTime</codeph>. Метод создания аналогичен методу создания <codeph>localTime</codeph>, и в данном случае получается одинаковый результат.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

var utcTime:String = getUSClockTime(someBirthday.getUTCHours(), someBirthday.getUTCMinutes());
trace(utcTime);      // 11:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCMilliseconds"><apiName>getUTCMilliseconds</apiName><shortdesc>
	  Возвращает из объекта Date число миллисекунд (целое число от 0 до 999) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmilliseconds, getutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с миллисекундами (UTC).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Возвращает из объекта <codeph>Date</codeph> число миллисекунд (целое число от 0 до 999) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCMilliseconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCMilliseconds()</codeph>, который извлекает из объекта Date <codeph>now</codeph> число миллисекунд на момент создания
<codeblock>

var now:Date = new Date();
trace(now.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMinutes"><apiName>getUTCMinutes</apiName><shortdesc>
	 Возвращает из объекта Date число минут (целое число от 0 до 59) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcminutes, getutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с минутами (UTC).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> число минут (целое число от 0 до 59) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCMinutes.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCMinutes()</codeph>, который извлекает из объекта Date <codeph>now</codeph> число минут на момент создания
<codeblock>

var now:Date = new Date();
trace(now.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMonth"><apiName>getUTCMonth</apiName><shortdesc>
	 Возвращает из объекта Date месяц (от 0 [январь] до 11 [декабрь]) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmonth, getutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с месяцем (UTC).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> месяц (от 0 [январь] до 11 [декабрь]) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCMonth.1.as"> В следующем примере создается новый объект Array <codeph>monthLabels</codeph> с элементами от <codeph>January</codeph> до <codeph>December</codeph> и новый объект Date <codeph>now</codeph> без параметров. Затем дважды вызывается метод <codeph>getUTCMonth()</codeph>, который сначала возвращает номер месяца, а затем указывает месяц создания объекта Date <codeph>now</codeph>.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(now.getUTCMonth());
trace(monthLabels[now.getUTCMonth()]);
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCSeconds"><apiName>getUTCSeconds</apiName><shortdesc>
	 Возвращает из объекта Date число секунд (целое число от 0 до 59) по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcseconds, getutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Фрагмент объекта <codeph>Date</codeph> с секундами (UTC).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает из объекта <codeph>Date</codeph> число секунд (целое число от 0 до 59) по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><example conref="examples\Date.getUTCSeconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCSeconds()</codeph>, который извлекает из объекта Date <codeph>now</codeph> число минут на момент создания
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:parse"><apiName>parse</apiName><shortdesc>
	 Преобразует строку, представляющую дату, в число, равное количеству миллисекунд с полуночи 1 января 1970 года по Гринвичу (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Число, выражающее количество миллисекунд, прошедшее с 1 января 1970 года по всемирному скоординированному времени (UTC).
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, представляющая дату, соответствующую выходному формату <codeph>Date.toString()</codeph>. Формат выводимой даты <codeph>Date.toString()</codeph> выглядит следующим образом: 
     <pre>
     Day Mon DD HH:MM:SS TZD YYYY
     </pre>
     <p>Например: </p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
     <p>Идентификатор временного пояса (TZD) всегда представлен в формате <codeph>GMT-ЧЧMM</codeph> или <codeph>UTC-ЧЧMM</codeph>, указывающем на сдвиг часов и минут, относящийся к среднему времени по Гринвичу (GMT), которое сейчас называют также всемирным скоординированным временем (UTC). Месяц и день разделяются в году косой чертой (<codeph>/</codeph>) или пробелом, но никогда дефисом (<codeph>-</codeph>). В число других поддерживаемых форматов входят следующие (можно включить частичные представления этих форматов, то есть месяц, день и год).</p>
     <pre>
     MM/DD/YYYY HH:MM:SS TZD
     HH:MM:SS TZD Day Mon/DD/YYYY 
     Mon DD YYYY HH:MM:SS TZD
     Day Mon DD HH:MM:SS TZD YYYY
     Day DD Mon HH:MM:SS TZD YYYY
     Mon/DD/YYYY HH:MM:SS TZD
     YYYY/MM/DD HH:MM:SS TZD
     </pre>
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует строку, представляющую дату, в число, равное количеству миллисекунд с полуночи 1 января 1970 года по Гринвичу (UTC).
	 
     </apiDesc><example conref="examples\Date.parse.1.as"> В следующем примере строка с данными присваивается параметру <codeph>dateParsed</codeph>, который соответствует 30 ноября 1974 г. Затем вызывается метод <codeph>Date.parse()</codeph>, преобразующий эту дату в число миллисекунд, прошедших с 1 января 1970 г.
<codeblock>
var dateParsed:String = "Sat Nov 30 1974";

var milliseconds:Number = Date.parse(dateParsed);
trace(milliseconds); // 155030400000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>Date.toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setDate"><apiName>setDate</apiName><shortdesc>
	 Задает день месяца по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setdate, setdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 1 до 31.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает день месяца по местному времени и возвращает новое время в миллисекундах. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.setDate.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызывается метод <codeph>getDate()</codeph>, определяющий день месяца. Вызывается метод <codeph>setDate()</codeph> с параметром <codeph>day</codeph>, которому присваивается значение <codeph>20</codeph>, а затем снова выполняется вызов метода <codeph>getDate()</codeph>, определяющего недавно выбранное число месяца.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDate()); // 30

someBirthday.setDate(20);
trace(someBirthday.getDate()); // 20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setFullYear"><apiName>setFullYear</apiName><shortdesc>
	 Задает год по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setfullyear, setfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Четырехзначное число, определяющее год. Двухзначные числа не представляют четырехзначные; например, 99 соответствует не 1999, а 99 году.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (январь) до 11 (декабрь). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число от 1 до 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает год по местному времени и возвращает новое время в миллисекундах. Если указаны параметры <codeph>month</codeph> и <codeph>day</codeph>, им присваивается местное время. Местное время определяется операционной системой, в которой запущен Flash Player.
	 <p>
	 Вызов этого метода не приводит к изменению других полей объекта <codeph>Date</codeph>, но методы <codeph>Date.getUTCDay()</codeph> и <codeph>Date.getDay()</codeph> могут указывать новое значение, если день недели изменяется в результате вызова этого метода.
	 </p>
	 
	 </apiDesc><example conref="examples\Date.setFullYear.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). После этого вызывается метод <codeph>getFullYear()</codeph>, который извлекает четырехзначное обозначение года. Затем вызывается метод <codeph>setFullYear()</codeph> с параметром <codeph>year</codeph>, которому присваивается значение <codeph>2000</codeph>, а затем снова выполняется вызов метода <codeph>getFullYear()</codeph>, определяющего недавно выбранный год.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974

someBirthday.setFullYear(2000);
trace(someBirthday.getFullYear()); // 2000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setHours"><apiName>setHours</apiName><shortdesc>
	 Задает час по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.sethours, sethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (полночь) до 23 (11 часов вечера).
     </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59. 
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59. 
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает час по местному времени и возвращает новое время в миллисекундах. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.setHours.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызываются методы <codeph>getHours()</codeph> и <codeph>getMinutes()</codeph>, определяющие часы и минуты. После этого выполняется вызов метода <codeph>setHours()</codeph> с параметром <codeph>hour</codeph>, которому присваивается значение <codeph>12</codeph>, а затем методы <codeph>getHours()</codeph> и <codeph>getMinutes()</codeph> вызываются снова, определяя только что установленное время в часах и минутах.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:20

someBirthday.setHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMilliseconds"><apiName>setMilliseconds</apiName><shortdesc>
	 Задает количество миллисекунд по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmilliseconds, setmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество миллисекунд по местному времени и возвращает новое время в миллисекундах. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.setMilliseconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getMilliseconds()</codeph>, который извлекает значение миллисекунд на момент создания объекта <codeph>now</codeph>. Затем снова вызывается новый объект Date <codeph>before</codeph>. При этом выполняется дополнительный вызов метода <codeph>setMilliseconds()</codeph>, где параметру <codeph>millisecond</codeph> присвоено значение <codeph>4</codeph> и метода <codeph>getMilliseconds()</codeph>, извлекающего недавно установленное значение в миллисекундах.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMilliseconds());

var before:Date = new Date(now.setMilliseconds(4));
trace(before);
trace(before.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMinutes"><apiName>setMinutes</apiName><shortdesc>
	 Задает количество минут по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setminutes, setminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59.
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59.
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество минут по местному времени и возвращает новое время в миллисекундах. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.setMinutes.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getMinutes()</codeph>, который извлекает значение миллисекунд на момент создания объекта <codeph>now</codeph>. Затем снова вызывается новый объект Date <codeph>before</codeph>. При этом выполняется дополнительный вызов метода <codeph>setMinutes()</codeph>, где параметру <codeph>minute</codeph> присвоено значение <codeph>0</codeph> и метода <codeph>getMinutes()</codeph>, извлекающего недавно установленное значение в минутах.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());

var before:Date = new Date(now.setMinutes(0));
trace(before);
trace(before.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMonth"><apiName>setMonth</apiName><shortdesc>
	 Задает месяц и (при необходимости) день месяца по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmonth, setmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (январь) до 11 (декабрь).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 1 до 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает месяц и (при необходимости) день месяца по местному времени и возвращает новое время в миллисекундах. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.setMonth.1.as"> В следующем примере создается новый объект Array <codeph>monthLabels</codeph> с элементами от <codeph>January</codeph> до <codeph>December</codeph> и новый объект месяца <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getMonth()</codeph>, который извлекает значение месяца на момент создания объекта <codeph>now</codeph>. Затем вызывается метод <codeph>setMonth()</codeph> с параметром <codeph>month</codeph>, которому присваивается значение <codeph>0</codeph>, а затем снова выполняется вызов метода <codeph>getMonth()</codeph>, определяющего недавно выбранный месяц.
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);

now.setMonth(0);
trace(now.getMonth());             // 0
trace(monthLabels[now.getMonth()]); // January
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setSeconds"><apiName>setSeconds</apiName><shortdesc>
	 Задает количество секунд по местному времени и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setseconds, setseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59.
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество секунд по местному времени и возвращает новое время в миллисекундах. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc><example conref="examples\Date.setSeconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getseconds()</codeph>, который извлекает значение секунд на момент создания объекта <codeph>now</codeph>. Затем вызывается метод <codeph>setSeconds()</codeph>, где параметр <codeph>second</codeph> принимает значения <codeph>0</codeph>, а после этого снова вызывается метод <codeph>getSeconds()</codeph>, определяющий недавно установленное время в секундах.
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());

now.setSeconds(0);
trace(now.getSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setTime"><apiName>setTime</apiName><shortdesc>
	 Задает дату в миллисекундах с полуночи 1 января 1970 года и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.settime, settime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число, для которого 0 означает полночь 1 января по универсальному времени (UTC).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает дату в миллисекундах с полуночи 1 января 1970 года и возвращает новое время в миллисекундах. 
	 
	 </apiDesc><example conref="examples\Date.setTime.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>setTime()</codeph>, где параметру <codeph>millisecond</codeph> присвоено значение <codeph>-1292601600000</codeph>, который устанавливает время <codeph>Tue Jan 15 00:00:00 GMT-0800 1929</codeph>.
<codeblock>

var now:Date = new Date();
trace(now);

now.setTime(-1292601600000);
trace(now); // Tue Jan 15 00:00:00 GMT-0800 1929
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCDate"><apiName>setUTCDate</apiName><shortdesc>
	 Задает день месяца по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcdate, setutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 1 до 31.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает день месяца по Гринвичу (UTC) и возвращает новое время в миллисекундах. Вызов этого метода не приводит к изменению других полей объекта <codeph>Date</codeph>, но методы <codeph>Date.getUTCDay()</codeph> и <codeph>Date.getDay()</codeph> могут указывать новое значение, если день недели изменяется в результате вызова этого метода.
	 
	 </apiDesc><example conref="examples\Date.setUTCDate.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Вызывается метод <codeph>getUTCDate()</codeph>, правильно возвращающий день месяца. Затем вызывается метод <codeph>setUTCDate()</codeph>, где параметру <codeph>day</codeph> присвоено значение <codeph>1</codeph>, а инструкция <codeph>trace()</codeph> подтверждает правильность установки даты.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30

someBirthday.setUTCDate(1);
trace(someBirthday); // Fri Nov 1 01:20:00 GMT-0800 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCFullYear"><apiName>setUTCFullYear</apiName><shortdesc>
	 Задает год по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcfullyear, setutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Целое число.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число, которое представляет собой год в полном четырехзначном формате (например, 2000).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (январь) до 11 (декабрь). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 1 до 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает год по Гринвичу (UTC) и возвращает новое время в миллисекундах. 
	 <p>
	 При желании этот метод может установить также месяц и день месяца. Вызов этого метода не приводит к изменению других полей, но методы <codeph>Date.getUTCDay()</codeph> и <codeph>Date.getDay()</codeph> могут указывать новое значение, если день недели изменяется в результате вызова этого метода. 
	 </p>
	 
 	 </apiDesc><example conref="examples\Date.setUTCFullYear.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Вызывается метод <codeph>getUTCFullYear()</codeph>, который правильно возвращает четырехзначный год. Затем вызывается метод <codeph>setUTCFullYear()</codeph>, где параметру <codeph>year</codeph> присвоено значение <codeph>1975</codeph>, а инструкция <codeph>trace()</codeph> подтверждает правильность установки года.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974

someBirthday.setUTCFullYear(1975);
trace(someBirthday); // Thu Nov 30 01:20:00 GMT-0800 1975
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCHours"><apiName>setUTCHours</apiName><shortdesc>
	 Задает час по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutchours, setutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (полночь) до 23 (11 часов вечера).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает час по Гринвичу (UTC) и возвращает новое время в миллисекундах. При желании можно также указать минуты, секунды и миллисекунды.
	 
	 </apiDesc><example conref="examples\Date.setUTCHours.1.as"> В следующем примере создается новый объект Date <codeph>someBirthday</codeph> с параметрами <codeph>year</codeph> (<codeph>1974</codeph>), <codeph>month</codeph> (<codeph>10</codeph> = ноябрь), <codeph>day</codeph> (<codeph>30</codeph>), <codeph>hour</codeph> (<codeph>1</codeph>) и <codeph>minute</codeph> (<codeph>20</codeph>). Затем вызываются методы <codeph>getHours()</codeph>, <codeph>getMinutes()</codeph>, <codeph>getUTCHours</codeph> и <codeph>getUTCMinutes</codeph>, определяющие часы и минуты. После этого вызывается метод <codeph>setUTCHours()</codeph> с параметром <codeph>hour</codeph>, для которого выбрано значение <codeph>12</codeph>. И, наконец, повторно вызываются методы <codeph>getHours()</codeph>, <codeph>getMinutes()</codeph>, <codeph>getUTCHours()</codeph> и <codeph>getUTCMinutes()</codeph> и правильно показывается обновленное время в часах.
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 15:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 23:20

someBirthday.setUTCHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 4:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMilliseconds"><apiName>setUTCMilliseconds</apiName><shortdesc>
	 Задает количество миллисекунд по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmilliseconds, setutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество миллисекунд по Гринвичу (UTC) и возвращает новое время в миллисекундах.
	 
	 </apiDesc><example conref="examples\Date.setUTCMilliseconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCMilliseconds()</codeph>, который извлекает значение миллисекунд (UTC) на момент создания объекта <codeph>now</codeph>. Затем снова вызывается новый объект Date <codeph>before</codeph>. При этом выполняется дополнительный вызов метода <codeph>setUTCMilliseconds()</codeph>, где параметру <codeph>millisecond</codeph> присвоено значение <codeph>4</codeph> и метода <codeph>getUTCMilliseconds()</codeph>, извлекающего недавно установленное значение в миллисекундах.
<codeblock>


var now:Date = new Date();
trace(now);
trace(now.getUTCMilliseconds());

var before:Date = new Date(now.setUTCMilliseconds(4));
trace(before);
trace(before.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMinutes"><apiName>setUTCMinutes</apiName><shortdesc>
	 Задает количество минут по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcminutes, setutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество минут по Гринвичу (UTC) и возвращает новое время в миллисекундах. При желании можно указать секунды и миллисекунды.
	 
	 </apiDesc><example conref="examples\Date.setUTCMinutes.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCMinutes()</codeph>, который извлекает значение минут (UTC) на момент создания объекта <codeph>now</codeph>. Затем снова вызывается новый объект Date <codeph>before</codeph>. При этом выполняется дополнительный вызов метода <codeph>setUTCMinutes()</codeph>, где параметру <codeph>minute</codeph> присвоено значение <codeph>0</codeph> и метода <codeph>getUTCMinutes()</codeph>, извлекающего недавно установленное значение в минутах.
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getUTCMinutes());

var before:Date = new Date(now.setUTCMinutes(0));
trace(before);
trace(before.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMonth"><apiName>setUTCMonth</apiName><shortdesc>
	 Задает месяц и (при необходимости) день месяца по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmonth, setutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 (январь) до 11 (декабрь).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 1 до 31. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает месяц и (при необходимости) день месяца по Гринвичу (UTC) и возвращает новое время в миллисекундах. Вызов этого метода не приводит к изменению других полей, но методы <codeph>Date.getUTCDay()</codeph> и <codeph>Date.getDay()</codeph> могут указывать новое значение, если день недели изменяется в результате вызова этого метода.
	 
	 </apiDesc><example conref="examples\Date.setUTCMonth.1.as"> В следующем примере создается новый объект Array <codeph>UTCMonthLabels</codeph> с элементами от <codeph>January</codeph> до <codeph>December</codeph> и новый объект UTCMonth <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCMonth()</codeph>, который извлекает значение месяца (UTC) на момент создания объекта <codeph>now</codeph>. После этого вызывается метод <codeph>setUTCMonth()</codeph> с параметром <codeph>month</codeph>, которому присваивается значение <codeph>0</codeph>, а затем снова выполняется вызов метода <codeph>getUTCMonth()</codeph>, определяющего недавно выбранный месяц.
<codeblock>

var UTCMonthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getUTCMonth());
trace(UTCMonthLabels[now.getUTCMonth()]);

now.setUTCUTCMonth(0);
trace(now.getUTCMonth());              // 0
trace(UTCMonthLabels[now.getUTCMonth()]); // January
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCSeconds"><apiName>setUTCSeconds</apiName><shortdesc>
	 Задает количество секунд и (при необходимости) миллисекунд по Гринвичу (UTC) и возвращает новое время в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcseconds, setutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новое время в миллисекундах.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 59.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Целое число от 0 до 999. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество секунд и (при необходимости) миллисекунд по Гринвичу (UTC) и возвращает новое время в миллисекундах.
	 
	 </apiDesc><example conref="examples\Date.setUTCSeconds.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getUTCSeconds()</codeph>, который извлекает значение секунд на момент создания объекта <codeph>now</codeph>. После этого вызывается метод <codeph>setUTCSeconds()</codeph>, где параметр <codeph>second</codeph> принимает значение <codeph>0</codeph>, а потом снова вызывается метод <codeph>getUTCSeconds()</codeph>, определяющий недавно установленное время в секундах.
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());

now.setUTCSeconds(0);
trace(now.getUTCSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toDateString"><apiName>toDateString</apiName><shortdesc>
	 Возвращает строковое представление дня и даты без времени или часового пояса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление дня и даты.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление дня и даты без времени или часового пояса. Сравните это с указанными ниже методами.
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph>, который возвращает только время и часовой пояс.</li>
	   <li><codeph>Date.toString()</codeph>, который возвращает не только день и дату, но также время и часовой пояс.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\Date.toDateString.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров, а затем вызываются следующие методы в операторе <codeph>trace()</codeph>.
 <ul>
   <li><codeph>toString</codeph>: показывает все параметры <codeph>now</codeph> на момент создания объекта <codeph>now</codeph>.</li>
   <li><codeph>toDateString()</codeph>: показывает значения параметров <codeph>day</codeph>, <codeph>month</codeph> и <codeph>year</codeph> на момент создания объекта <codeph>now</codeph>.</li>
 </ul>
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.toDateString());
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleDateString"><apiName>toLocaleDateString</apiName><shortdesc>
	 Возвращает строковое представление дня и даты без времени или часового пояса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Представление дня и даты типа <codeph>String</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление дня и даты без времени или часового пояса. Этот метод возвращает то же значение, что и <codeph>Date.toDateString</codeph>. Сравните это с указанными ниже методами.
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph>, который возвращает только время и часовой пояс.</li>
	   <li><codeph>Date.toString()</codeph>, который возвращает не только день и дату, но также время и часовой пояс.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 Возвращает строковое представление дня, даты и времени по местному времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта <codeph>Date</codeph> в местном часовом поясе.
	 
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление дня, даты и времени по местному времени. Сравните это с методом <codeph>Date.toString()</codeph>, возвращающим ту же информацию (а также часовой пояс), относящуюся к году, указанному в конце строки.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toLocaleTimeString"><apiName>toLocaleTimeString</apiName><shortdesc>
	 Возвращает строковое представление времени без дня, даты, года или часового пояса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление времени и часового пояса.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление времени без дня, даты, года или часового пояса. Сравните это с методом <codeph>Date.toTimeString()</codeph>, который возвращает время и часовой пояс.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Возвращает строковое представление дня, даты, времени и часового пояса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.tostring, tostring, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление дня, даты, времени и часового пояса. Формат выводимой даты: 
     <pre>
     Day Mon Date HH:MM:SS TZD YYYY
     </pre>
     <p>Например:</p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
	 
	 </apiDesc><example conref="examples\Date.toString.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров, а затем вызывается метод <codeph>toString</codeph> в инструкции <codeph>trace()</codeph>, который показывает параметры объекта <codeph>now</codeph> на момент создания <codeph>now</codeph>.
<codeblock>


var now:Date = new Date();
trace(now);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toTimeString"><apiName>toTimeString</apiName><shortdesc>
	 Возвращает строковое представление времени и часового пояса без дня и даты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление времени и часового пояса.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление времени и часового пояса без дня и даты. Сравните это с методом <codeph>Date.toDateString()</codeph>, который возвращает только день и дату.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toUTCString"><apiName>toUTCString</apiName><shortdesc>
	 Возвращает строковое представление дня, даты и времени по Гринвичу (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта <codeph>Date</codeph> по всемирному скоординированному времени.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление дня, даты и времени по Гринвичу (UTC). Например, дата 1 февраля 2005 г. выглядит как <codeph>Tue Feb 1 00:00:00 2005 UTC</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Возвращает для объекта Date число миллисекунд с полуночи 1 января 1970 года по всемирному скоординированному времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.valueof, valueof, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Количество миллисекунд с 1 января 1970 г., выражаемое объектом <codeph>Date</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает для объекта <codeph>Date</codeph> число миллисекунд с полуночи 1 января 1970 года по всемирному скоординированному времени.
	 
	 </apiDesc><example conref="examples\Date.valueOf.1.as"> В следующем примере создается новый объект Date <codeph>now</codeph> без параметров. Затем вызывается метод <codeph>getTime()</codeph>, который определяет количество миллисекунд между временем создания <codeph>now</codeph> и полуночью 1 января 1970 г. После этого вызывается метод <codeph>valueOf()</codeph>, определяющий то же самое.
<codeblock>


var now:Date = new Date();
trace(now.getTime());
trace(now.valueOf());
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="Date:AS3:date:get"><apiName>date</apiName><shortdesc>
	 День месяца по местному времени (целое число от 1 до 31), заданный объектом Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 День месяца по местному времени (целое число от 1 до 31), заданный объектом <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/setDate()"><linktext>setDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dateUTC:get"><apiName>dateUTC</apiName><shortdesc>
	 День месяца (целое число от 1 до 31) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 День месяца (целое число от 1 до 31) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDate()"><linktext>getUTCDate()</linktext></link><link href="#Date/setUTCDate()"><linktext>setUTCDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:day:get"><apiName>day</apiName><shortdesc>
	 День недели по местному времени (0 – воскресенье, 1 – понедельник и т. д.), заданный объектом Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 День недели по местному времени (0 – воскресенье, 1 – понедельник и т. д.), заданный объектом <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dayUTC:get"><apiName>dayUTC</apiName><shortdesc>
	 День недели (0 – воскресенье, 1 – понедельник и т. д.) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 День недели (0 – воскресенье, 1 – понедельник и т. д.) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYear:get"><apiName>fullYear</apiName><shortdesc>
	 Полный год (четырехзначное число, например 2000) объекта Date по местному времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Полный год (четырехзначное число, например 2000) объекта <codeph>Date</codeph> по местному времени. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link><link href="#Date/setFullYear()"><linktext>setFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYearUTC:get"><apiName>fullYearUTC</apiName><shortdesc>
	 Четырехзначный год по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Четырехзначный год по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCFullYear()"><linktext>getUTCFullYear()</linktext></link><link href="#Date/setUTCFullYear()"><linktext>setUTCFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hours:get"><apiName>hours</apiName><shortdesc>
	 Час дня по местному времени (целое число от 0 до 23) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Час дня по местному времени (целое число от 0 до 23) из объекта <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link><link href="#Date/setHours()"><linktext>setHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hoursUTC:get"><apiName>hoursUTC</apiName><shortdesc>
	 Час дня (целое число от 0 до 23) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Час дня (целое число от 0 до 23) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCHours()"><linktext>getUTCHours()</linktext></link><link href="#Date/setUTCHours()"><linktext>setUTCHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:milliseconds:get"><apiName>milliseconds</apiName><shortdesc>
	 Число миллисекунд по местному времени (целое число от 0 до 999) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число миллисекунд по местному времени (целое число от 0 до 999) из объекта <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMilliseconds()"><linktext>getMilliseconds()</linktext></link><link href="#Date/setMilliseconds()"><linktext>setMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:millisecondsUTC:get"><apiName>millisecondsUTC</apiName><shortdesc>
	 Число миллисекунд (целое число от 0 до 999) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число миллисекунд (целое число от 0 до 999) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMilliseconds()"><linktext>getUTCMilliseconds()</linktext></link><link href="#Date/setUTCMilliseconds()"><linktext>setUTCMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutes:get"><apiName>minutes</apiName><shortdesc>
	 Число минут по местному времени (целое число от 0 до 59) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число минут по местному времени (целое число от 0 до 59) из объекта <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMinutes()"><linktext>getMinutes()</linktext></link><link href="#Date/setMinutes()"><linktext>setMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutesUTC:get"><apiName>minutesUTC</apiName><shortdesc>
	 Число минут (целое число от 0 до 59) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число минут (целое число от 0 до 59) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMinutes()"><linktext>getUTCMinutes()</linktext></link><link href="#Date/setUTCMinutes()"><linktext>setUTCMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:month:get"><apiName>month</apiName><shortdesc>
	 Месяц (0 – январь, 1 – февраль и т. д.) объекта Date по местному времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Месяц (0 – январь, 1 – февраль и т. д.) объекта <codeph>Date</codeph> по местному времени. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/setMonth()"><linktext>setMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:monthUTC:get"><apiName>monthUTC</apiName><shortdesc>
	 Месяц (от 0 [январь] до 11 [декабрь]) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Месяц (от 0 [январь] до 11 [декабрь]) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMonth()"><linktext>getUTCMonth()</linktext></link><link href="#Date/setUTCMonth()"><linktext>setUTCMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:seconds:get"><apiName>seconds</apiName><shortdesc>
	 Число секунд по местному времени (целое число от 0 до 59) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число секунд по местному времени (целое число от 0 до 59) из объекта <codeph>Date</codeph>. Местное время определяется операционной системой, в которой запущен Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getSeconds()"><linktext>getSeconds()</linktext></link><link href="#Date/setSeconds()"><linktext>setSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:secondsUTC:get"><apiName>secondsUTC</apiName><shortdesc>
	 Число секунд (целое число от 0 до 59) по всемирному скоординированному времени (UTC) из объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число секунд (целое число от 0 до 59) по всемирному скоординированному времени (UTC) из объекта <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCSeconds()"><linktext>getUTCSeconds()</linktext></link><link href="#Date/setUTCSeconds()"><linktext>setUTCSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:time:get"><apiName>time</apiName><shortdesc>
	 Число миллисекунд с полуночи 1 января 1970 года по всемирному скоординированному времени для объекта Date.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число миллисекунд с полуночи 1 января 1970 года по всемирному скоординированному времени для объекта <codeph>Date</codeph>. Воспользуйтесь этим методом, чтобы представить определенный момент во времени при сравнении двух и более объектов <codeph>Date</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getTime()"><linktext>getTime()</linktext></link><link href="#Date/setTime()"><linktext>setTime()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:timezoneOffset:get"><apiName>timezoneOffset</apiName><shortdesc>
     Разница в минутах между местным временем компьютера и временем по всемирному скоординированному времени (UTC).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Разница в минутах между местным временем компьютера и временем по всемирному скоординированному времени (UTC). В частности, это значение представляет собой количество минут, которое необходимо добавить к местному времени компьютера, чтобы оно стало равно всемирному. Если время компьютера опережает UTC, значение будет отрицательным.
     </apiDesc></apiValueDetail><related-links><link href="#Date/getTimezoneOffset()"><linktext>getTimezoneOffset()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="globalClassifier:URIError"><apiName>URIError</apiName><shortdesc>
 Исключение URIError выбрасывается, если способ использования одной из глобальных функций обработки URI несовместим с ее определением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, URIError
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Исключение URIError выбрасывается, если способ использования одной из глобальных функций обработки URI несовместим с ее определением. Это исключение создается, когда указан недействительный URI-адрес для функции, ожидающей действительного URI (например, метод <codeph>Socket.connect()</codeph>).
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>flash.net.Socket.connect()</linktext></link></related-links><apiConstructor id="URIError:URIError"><apiName>URIError</apiName><shortdesc>
	 Создает новый объект URIError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Содержит сообщение, связанное с объектом URIError.  
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект URIError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Object"><apiName>Object</apiName><shortdesc>
 Класс Object находится в корне иерархии класса среды выполнения ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/></apiClassifierDef><apiDesc>
 Класс Object находится в корне иерархии классов <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">runtime</ph>. Объекты создаются конструкторами с помощью синтаксиса оператора <codeph>new</codeph>, и им можно динамически присвоить свойства. <ph platform="actionscript">Объекты могут также создаваться путем присвоения литерала объекта (см. ниже):</ph>
 
 <codeblock platform="actionscript">var obj:Object = {a:"foo", b:"bar"}</codeblock>
 
 <p platform="actionscript">Все классы, которые не объявляют базовый класс явным образом, расширяют встроенный класс Object.</p>
 
 <p platform="javascript">Все классы среды выполнения в Adobe Integrated Runtime расширяют класс runtime.Object.</p>
 
 <p platform="actionscript">Класс Object можно использовать для создания <i>массивов ассоциативных элементов</i>. В сущности, массив ассоциативных элементов является экземпляром класса Object, и каждая пара «ключ-значение» представлена свойством и его значением. Еще одна причина объявить массив ассоциативных элементов с помощью типа данных Object состоит в том, что после этого можно использовать литерал объекта, чтобы заполнить массив ассоциативных элементов (но только в тот раз, когда он объявлен). В следующем примере массив ассоциативных элементов создается с помощью литерала объекта, доступ к элементам выполняется как с помощью оператора-точки, так и посредством оператора доступа к массиву, а затем путем создания нового свойства создается новая пара ключ-значение:</p>
 
 <codeblock platform="actionscript">
 var myAssocArray:Object = {fname:"John", lname:"Public"};
 trace(myAssocArray.fname);     // John
 trace(myAssocArray["lname"]);  // Public
 myAssocArray.initial = "Q";
 trace(myAssocArray.initial);   // Q</codeblock> 
 
 <p platform="actionscript">ActionScript 3.0 имеет два типа наследования: наследование классов и наследование прототипов:</p>
 <ul platform="actionscript">
 <li>Наследование классов – это первичный механизм наследования, поддерживающий наследование фиксированных свойств. Фиксированное свойство – это переменная, константа или метод, объявленные как часть определения класса. Каждое определение класса представлено сейчас особым объектом класса, в котором хранится информация о классе. </li>
 <li>Наследование прототипов является единственным механизмом наследования в предшествующих версиях ActionScript и альтернативной формой наследования в ActionScript 3.0. Каждый класс имеет связанный объект прототипа, и свойствами объекта прототипа обладают все экземпляры класса. При создании экземпляра класса он имеет ссылку на объект прототипа для этого класса, который служит связующим звеном между экземпляром и связанным объектом прототипа класса. Если во время выполнения в экземпляре класса не найдено свойство, наличие свойства проверяется у делегата, в роли которого выступает объект прототипа класса. Если объект прототипа не содержит свойства, этот процесс выполняется по отношению к делегату объекта прототипа. При этом проверка производится последовательно на все более и более высоких уровнях иерархии до тех пор, пока Flash Player не найдет свойство. </li>
 </ul>
 
 <p platform="actionscript">Наследование классов и наследование прототипов может выполняться одновременно, как показано в следующем примере.</p>
 
 <codeblock platform="actionscript">
 class A {
     var x = 1
     prototype.px = 2
 }
 dynamic class B extends A {
     var y = 3
     prototype.py = 4
 }
  
 var b = new B()
 b.x // 1 via class inheritance
 b.px // 2 via prototype inheritance from A.prototype
 b.y // 3
 b.py // 4 via prototype inheritance from B.prototype
  
 B.prototype.px = 5
 b.px // now 5 because B.prototype hides A.prototype
  
 b.px = 6
 b.px // now 6 because b hides B.prototype</codeblock>
 
 <p platform="actionscript">Заменив класс функциями, можно создавать пользовательские деревья наследования прототипов. В случае классов дерево наследования прототипов аналогично дереву наследования классов. Однако, поскольку объекты прототипов являются динамическими, можно добавить или удалить свойства, основанные на прототипах во время выполнения.</p>
 
 </apiDesc><example conref="examples\ObjectExample.as"> В следующем примере классы <codeph>ObjectExample</codeph> и <codeph>Circle</codeph> используются, чтобы продемонстрировать динамический характер класса Object. Кроме того, показывается, как объекты значений могут быть преобразованы в объекты Shape, а затем добавлены в рабочую область с указанными координатами x и y.
 
 <p>В примере создаются объекты значений <codeph>firstInitObj</codeph> и <codeph>secondInitObj</codeph>. Пользовательский класс <codeph>Circle</codeph> принимает объект значения и циклически обрабатывает его, подставляя совпадающие внутренние свойства вместо свойств, определенных в объекте значения.</p>
<codeblock>
package {
    import flash.display.Sprite;

    public class ObjectExample extends Sprite {
        public function ObjectExample() {
            var firstInitObj:Object = new Object();
            firstInitObj.bgColor = 0xFF0000;
            firstInitObj.radius = 25;
            firstInitObj.xCenter = 25;
            firstInitObj.yCenter = 25;
                        
            var firstCircle:Circle = new Circle(firstInitObj);
            addChild(firstCircle);
            firstCircle.x = 50;
            firstCircle.y = 50;

            var secondInitObj:Object = {bgColor:0xCCCCCC, radius:50, xCenter:50, yCenter:50};

            var secondCircle:Circle = new Circle(secondInitObj);            
            addChild(secondCircle);
            secondCircle.x = 100;
            secondCircle.y = 100;
        }
        
    }
}

import flash.display.Shape;
    
class Circle extends Shape {
    public var bgColor:Number = 0xFFFFFF;
    public var radius:Number = 0;
    public var xCenter:Number = 0;
    public var yCenter:Number = 0;
        
    public function Circle(initObj:Object) {
        for(var i:String in initObj) {
            this[i] = initObj[i];
        }
        draw();
    }
        
    public function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawCircle(xCenter, yCenter, radius);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links><apiConstructor id="Object:Object"><apiName>Object</apiName><shortdesc>
	 Создает объект Object и сохраняет ссылку на метод конструктора объекта в свойстве constructor объекта.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Создает объект Object и сохраняет ссылку на метод конструктора объекта в свойстве <codeph>constructor</codeph> объекта.
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Object:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	 Показывает, определено ли заданное свойство для объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Method
	 </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если у целевого объекта есть свойство, указанное параметром <codeph>name</codeph>, выбирается значение <codeph>true</codeph>. В противном случае выбирается <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Свойство объекта.	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Показывает, определено ли заданное свойство для объекта. Этот метод возвращает значение <codeph>true</codeph>, если у целевого объекта есть свойство, совпадающее со строкой, указанной параметром <codeph>name</codeph>. В противном случае указывается значение <codeph>false</codeph>. Следующие типы свойств заставляют метод возвращать значение <codeph>true</codeph> для объектов, которые являются экземплярами классов (в отличие от объектов класса):
	 <ul>
	   <li>фиксированные свойства экземпляра – переменные, константы или методы, определенные классом объекта и не являющиеся статическими;</li>
	   <li>унаследованные фиксированные свойства экземпляра – переменные, константы или методы, унаследованные классом объекта;</li>
	   <li>динамические свойства – свойства, добавленные в объект после того, как были созданы его экземпляры (за рамками определения класса). Чтобы добавить динамические свойства, определяющий класс объекта должен объявляться с ключевым словом <codeph>dynamic</codeph>.</li>
	 </ul>
	 <p>Следующие типы свойств заставляют метод возвращать значение <codeph>false</codeph> для объектов, которые являются экземплярами класса:</p>
	 <ul>
	   <li>статические свойства – переменные, константы или методы, определенные с помощью статического ключевого слова в определяющем классе объекта или любом из его суперклассов;</li>
	   <li>свойства прототипа – свойства, определенные в отношении объекта прототипа, который принадлежит цепи прототипов объекта. В ActionScript 3.0 цепочка прототипов не используется для наследования классов. Тем не менее, она существует и используется в качестве альтернативного механизма наследования. Например, экземпляр класса Array может вызывать метод <codeph>valueOf()</codeph>, поскольку он существует в прототипе <codeph>Object.prototype</codeph>, входящем в цепь для класса Array. Хотя метод <codeph>valueOf()</codeph> можно использовать по отношению к экземпляру Array, параметр <codeph>hasOwnProperty("valueOf")</codeph> принимает для этого экземпляра значение <codeph>false</codeph>.</li>
	 </ul>
	 
	 <p platform="actionscript">В ActionScript 3.0 тоже есть объекты классов, которые прямо представляют определения классов. Когда метод <codeph>hasOwnProperty()</codeph> вызывается по отношению к объектам класса, то значение <codeph>true</codeph> присваивается только в том случае, если свойство является статическим и определено в данном объекте класса. Например, если создается подкласс Array под названием CustomArray и в CustomArray определяется статическое свойство с именем <codeph>foo</codeph>, вызов <codeph>CustomArray.hasOwnProperty("foo")</codeph> возвращает значение <codeph>true</codeph>. Однако для статического свойства <codeph>DESCENDING</codeph>, определенного в классе Array, вызов <codeph>CustomArray.hasOwnProperty("DESCENDING")</codeph> возвращает значение <codeph>false</codeph>.</p>
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function hasOwnProperty():Boolean</codeph>.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:isPrototypeOf"><apiName>isPrototypeOf</apiName><shortdesc>
	 Показывает, есть ли экземпляр класса Object в цепи прототипов объекта, заданного в качестве параметра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если объект находится в цепи прототипов объекта, указанного параметром <codeph>theClass</codeph>, выбирается значение <codeph>true</codeph>. В противном случае устанавливается значение <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>theClass</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Класс, на который может ссылаться указанный объект.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Показывает, есть ли экземпляр класса Object в цепи прототипов объекта, заданного в качестве параметра. Этот метод возвращает значение <codeph>true</codeph>, если объект находится в цепи прототипов объекта, указанного параметром <codeph>theClass</codeph>. Метод возвращает значение <codeph>false</codeph>, если целевой объект отсутствует в цепи прототипов объекта <codeph>theClass</codeph>, а параметр <codeph>theClass</codeph> не является объектом.
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function isPrototypeOf():Boolean</codeph>.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	 Показывает наличие заданного свойства и его перечисляемость.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a generic object, adds a property to the object, then checks whether the object is enumerable. By way of contrast, the example also shows that a built-in property, the <code>Array.length</code> property, is not enumerable.
	 <listing>
	 var myObj:Object = new Object();
	 myObj.prop1 = "hello";
	 trace(myObj.propertyIsEnumerable("prop1")); // true
	 
	 var myArray = new Array();
	 trace(myArray.propertyIsEnumerable("length")); // false
	 </listing> 
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если свойство, указанное параметром <codeph>name</codeph>, перечисляемо, появляется значение <codeph>true</codeph>. В противном случае присваивается значение <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Свойство объекта.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Показывает наличие заданного свойства и его перечисляемость. Значение <codeph>true</codeph> указывает на то, что свойство существует и может быть перечислено в цикле <codeph>for.. in</codeph>. Это свойство должно существовать в целевом объекте, поскольку этот метод не проверяет цепи прототипов целевого объекта.
	 
	 <p>Созданные пользователем свойства перечисляемы, а встроенные свойства, как правило, нет.</p>
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function propertyIsEnumerable():Boolean</codeph>.</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:setPropertyIsEnumerable"><apiName>setPropertyIsEnumerable</apiName><shortdesc>
     Задает доступность динамического свойства для операций цикла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Свойство объекта.
     </apiDesc></apiParam><apiParam><apiItemName>isEnum</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc> Если выбрано значение <codeph>false</codeph>, динамическое свойство не появляется в циклах <codeph>for.. in</codeph>, а метод <codeph>propertyIsEnumerable()</codeph> возвращает значение <codeph>false</codeph>. 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Задает доступность динамического свойства для операций цикла. Это свойство должно существовать в целевом объекте, поскольку этот метод не проверяет цепи прототипов целевого объекта.
     </apiDesc></apiOperationDetail><related-links><link href="#Object/propertyIsEnumerable()"><linktext>propertyIsEnumerable()</linktext></link></related-links></apiOperation><apiOperation id="Object:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 Возвращает строковое представление этого объекта, отформатированного в соответствии со стандартами, принятыми для данного языка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tolocalestring, tolocalestring
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строковое представление этого объекта, отформатированного в соответствии со стандартами, принятыми для данного языка.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление этого объекта, отформатированного в соответствии со стандартами, принятыми для данного языка.
	 
	 <p>Внедрение по умолчанию для этого метода не выполняет специфичное для региона форматирование и возвращает ту же самую строку как <codeph>toString()</codeph>. Для подклассов должно предоставляться их собственное внедрение с учетом местных соглашений, когда это применимо.</p>
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function toLocaleString():String</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiOperation id="Object:toString"><apiName>toString</apiName><shortdesc>
	 Возвращает строковое представление заданного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строковое представление объекта.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строковое представление заданного объекта.
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function toString():String</codeph>.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Возвращает элементарное значение заданного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.valueof, valueof
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Элементарное значение данного объекта или самого объекта.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает элементарное значение заданного объекта. Если у объекта нет элементарного значения, возвращается объект как таковой.
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function valueOf():Object</codeph>.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiValue id="Object:constructor"><apiName>constructor</apiName><shortdesc>
	 Ссылка на объект класса или функцию конструктора для данного экземпляра объекта.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Object, Object.constructor, constructor
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Ссылка на объект класса или функцию конструктора для данного экземпляра объекта. Если объект представляет собой экземпляр класса, в свойстве <codeph>constructor</codeph> содержится ссылка на объект класса. Если объект создается с помощью функции конструктора, свойство <codeph>constructor</codeph> содержит ссылку на эту функцию конструктора. Функцию конструктора не следует путать с методом конструктора для класса. Функция конструктора – это объект Function, используемый для создания объектов и применяемый при определении классов наряду с ключевым словом <codeph>class</codeph>.
	 
	 <p platform="actionscript">Если ключевое слово <codeph>class</codeph> используется для определения класса, объекту прототипа класса присваивается свойство <codeph>constructor</codeph>, в котором содержится ссылка на объект класса. Экземпляр класса наследует это свойство из объекта прототипа. Например, следующий код создает новый класс <codeph>A</codeph> и экземпляр класса <codeph>myA</codeph>:</p>
	 <codeblock platform="actionscript" rev="3.0">
	 dynamic class A {}
	 trace(A.prototype.constructor);      // [class A]
	 trace(A.prototype.constructor == A); // true
	 var myA:A = new A();
	 trace(myA.constructor == A);         // true</codeblock>
	 
	 <p platform="actionscript">Опытные пользователи могут выбрать ключевое слово <codeph>function</codeph> вместо слова <codeph>class</codeph>, чтобы определить объект Function, который можно использовать в качестве шаблона при создании объектов. Такая функция называется функцией конструктора, поскольку ее можно применять в сочетании с оператором <codeph>new</codeph> для создания объектов. Если ключевое слово <codeph>function</codeph> используется для создания функции конструктора, объекту прототипа класса присваивается свойство <codeph>constructor</codeph>, в котором содержится ссылка на функцию конструктора. Если затем функция конструктора используется для создания объекта, объект наследует свойство <codeph>constructor</codeph> из объекта прототипа функции конструктора. Например, следующий код создает новую функцию конструктора <codeph>f</codeph> и объект с именем <codeph>myF</codeph>:</p>
	 <codeblock platform="actionscript" rev="3.0">
	 function f() {}
	 trace(f.prototype.constructor);      // function Function() {}
	 trace(f.prototype.constructor == f); // true
	 var myF = new f();
	 trace(myF.constructor == f);         // true</codeblock>
	 
	 <p><b>Примечание.</b> Свойство <codeph>constructor</codeph> является записываемым. Это означает, что код пользователя может изменить его значение с помощью инструкции присваивания. Не рекомендуется изменять значение свойства <codeph>constructor</codeph>, но если создается код, зависящий от значения свойства <codeph>constructor</codeph>, необходимо убедиться, что это значение не сброшено. Значение может изменяться только тогда, когда доступ к данному свойству выполняется с помощью объекта прототипа (например, <codeph>className.prototype.constructor</codeph>).</p>
     <p>При выполнении доступа к свойству <codeph>constructor</codeph> и компиляции в строгом режиме во время компиляции выводится ошибка, так как свойство конструктора зависит от объекта прототипа, который является сущностью среды выполнения. Если используется стандартный режим или если описание класса – «динамический», код выполняется без ошибок.</p>     
	 </apiDesc></apiValueDetail><related-links><link href="#Class"><linktext>Класс</linktext></link><link href="#Function"><linktext>Функция</linktext></link><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links></apiValue><apiValue id="Object:prototype"><apiName>prototype</apiName><shortdesc>
	 Ссылка на модель объекта класса или функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a class named Shape and a subclass of Shape named Circle.
	 <listing version="2.0">
	 // Shape class defined in external file named Shape.as
	 class Shape {
	 	function Shape() {}
	 }
	 
	 // Circle class defined in external file named Circle.as
	 class Circle extends Shape{
	 	function Circle() {}
	 }
	 </listing>
	 The Circle class can be used to create two instances of Circle:
	 <listing version="2.0">
	 var oneCircle:Circle = new Circle();
	 var twoCircle:Circle = new Circle();
	 </listing>
	 The following trace statement shows that the <code>prototype</code> property of the Circle class points to its superclass Shape. The identifier <code>Shape</code> refers to the constructor function of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.constructor == Shape); // true
	 </listing>
	 The following trace statement shows how you can use the <code>prototype</code> property and the <code>__proto__</code> property together to move two levels up the inheritance hierarchy (or prototype chain). The <code>Circle.prototype.__proto__</code> property contains a reference to the superclass of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.__proto__ == Shape.prototype); // true
	 </listing>
	 
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Ссылка на модель объекта класса или функции. Автоматически создается свойство <codeph>prototype</codeph>, которое присваивается любому созданному классу или объекту функции. Это свойство является статическим, так как относится только к созданному классу или функции. Например, если создается класс, значение свойства <codeph>prototype</codeph> используется всеми экземплярами класса и доступно только как свойство класса. Экземпляры класса не могут напрямую обращаться к свойству <codeph>prototype</codeph>. 
	 
     <p>Объект прототипа класса – это особый экземпляр данного класса, обеспечивающий механизм распространения состояния на все экземпляры класса. Если во время выполнения в экземпляре класса не найдено свойство, наличие свойства проверяется у делегата, в роли которого выступает объект прототипа класса. Если объект прототипа не содержит это свойство, процесс выполняется по отношению к делегату объекта прототипа. При этом проверка производится последовательно на все более и более высоких уровнях иерархии до тех пор, пока <ph platform="actionscript">Flash Player или</ph> Adobe Integrated Runtime не найдет это свойство. </p>
	 
     <p platform="actionscript"><i>Примечание.</i> В ActionScript 3.0 наследование прототипов не является основным механизмом наследования. Главный механизм наследования в ActionScript 3.0 – это наследование классов, обеспечивающее наследование фиксированных свойств в определениях классов.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:SecurityError"><apiName>SecurityError</apiName><shortdesc>
 Исключение SecurityError создается при каком-либо нарушении защиты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SecurityError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Исключение <codeph>SecurityError</codeph> создается при каком-либо нарушении защиты.
 <p>
 Примеры ошибок защиты.</p>
 <ul>
   <li>Несанкционированный доступ к свойству или вызов метода, выполненные из-за границы изолированной программной среды безопасности.</li>
   <li>Предпринята попытка доступа к URL-адресу, не разрешенному изолированной программной средой безопасности.</li>
   <li>Предпринята попытка подключения через сокет к порту с несанкционированным номером, например, к порту с номером больше 65535.</li>
   <li>Предпринята попытка доступа к видеокамере или микрофону пользователя. Пользователь отклонил запрос на доступ к устройству.</li>
 </ul>
 
 </apiDesc><example conref="examples\SecurityErrorExample.as"> В следующем примере показано, как можно вызвать ошибку <codeph>SecurityError</codeph> и обработать ее в инструкции <codeph>try...catch</codeph>, попытавшись подключиться к порту, номер которого превышает допустимый максимум.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.Socket;

    public class SecurityErrorExample extends Sprite {

        public function SecurityErrorExample() {
            try {
                var host:String = "www.[yourDomain].com";
                var socket:Socket = new Socket();
                socket.connect(host, 65536);
            }
            catch(e:SecurityError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="SecurityError:SecurityError"><apiName>SecurityError</apiName><shortdesc>
	 Создает новый объект SecurityError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект SecurityError.
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
 Исключение ReferenceError появляется при попытке выполнить ссылку на неопределенное свойство для защищенного (нединамического) объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, ReferenceError
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Исключение ReferenceError появляется при попытке выполнить ссылку на неопределенное свойство для защищенного (нединамического) объекта. Ссылки на неопределенные переменные приведут к появлению исключений ReferenceError, сообщающих о потенциальных ошибках и помогают исправить код приложения.
 <p>Однако можно ссылаться на неопределенные свойства динамического класса, не вызывая появление исключения ReferenceError. Дополнительную информацию можно получить, указав ключевое слово <codeph>dynamic</codeph>.</p>
 
 </apiDesc><example conref="examples\ReferenceErrorExample.as"> В следующем примере показано, как генерируется и обрабатывается исключение <codeph>ReferenceError</codeph> в операторе <codeph>try.. catch</codeph>. 
<codeblock>
package {
    import flash.display.Sprite;

    public class ReferenceErrorExample extends Sprite {

        public function ReferenceErrorExample() {
            try {
                this["someMember"] = true;
            }
            catch(e:ReferenceError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#dynamic"><linktext>ключевое слово dynamic</linktext></link></related-links><apiConstructor id="ReferenceError:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
	 Создает новый объект ReferenceError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Содержит сообщение, связанное с объектом ReferenceError.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект ReferenceError.
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:RangeError"><apiName>RangeError</apiName><shortdesc>
 Исключение RangeError появляется, если числовое значение находится вне допустимого диапазона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, RangeError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Исключение RangeError появляется, если числовое значение находится вне допустимого диапазона. При работе с массивами ссылка на позицию в индексе несуществующего элемента массива приводит к возникновению исключения RangeError. Использование методов <codeph>Number.toExponential()</codeph>, <codeph>Number.toPrecision()</codeph> и <codeph>Number.toFixed()</codeph> приводит к появлению исключения RangeError в тех случаях, когда аргументы выходят за пределы допустимого числового диапазона. Во избежание этого исключения можно расширить методы <codeph>Number.toExponential()</codeph>, <codeph>Number.toPrecision()</codeph> и <codeph>Number.toFixed()</codeph>.
 <p product="flash">Среди других ситуаций, вызывающих появление этого исключения, можно назвать следующие:
 <ul>
   <li>Любой API программы Flash Player, ожидающий ввода показателя глубины, вызывается с указанием недействительного числа глубины.</li>
   <li>Любой API программы Flash Player, ожидающий ввода номера кадра, вызывается с указанием недействительного номера кадра.</li>
   <li>Любой API программы Flash Player, ожидающий ввода номера слоя, вызывается с указанием недействительного номера слоя.</li>
 </ul>
 </p>
 </apiDesc><example conref="examples\RangeErrorExample.as"> В следующем примере показано, как генерируется и обрабатывается исключение <codeph>RangeError</codeph> в операторе <codeph>try.. catch</codeph>. 
<codeblock>
package {
    import flash.display.Sprite;

    public class RangeErrorExample extends Sprite {

        public function RangeErrorExample() {
            var child:Sprite = new Sprite();
            try {
                addChildAt(child, 1);
            }
            catch(e:RangeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Number/toExponential()"><linktext>Number.toExponential()</linktext></link><link href="#Number/toPrecision()"><linktext>Number.toPrecision()</linktext></link><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links><apiConstructor id="RangeError:RangeError"><apiName>RangeError</apiName><shortdesc>
	 Создает новый объект RangeError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Содержит сообщение, связанное с объектом RangeError.
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект RangeError.
	 </apiDesc></apiConstructorDetail><related-links><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:int"><apiName>int</apiName><shortdesc>
 Класс int позволяет работать с типом данных, представляющим 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int object, int, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс int позволяет работать с типом данных, представляющим 32-разрядное целое число со знаком. Диапазон значений, представленных классом int, составляет от -2147483648 (-2 в степени 31) до 2147483647 (2 в степени 31 -1).
 <p>Постоянные свойства класса int <codeph>MAX_VALUE</codeph> и <codeph>MIN_VALUE</codeph> являются статическими. Это означает, что для их использования не требуется объект, поэтому конструктор применять не требуется. Однако сами методы не являются статическими. Следовательно, их использование требует наличия объекта. Объект int можно создать с помощью конструктора класса int или путем объявления переменной типа int и присвоения ей значения литерала.</p>
 <p>Тип данных int полезен для счетчиков циклов и других ситуаций, когда не требуется число с плавающей запятой. Он аналогичен типу данных int в языках Java и C++. Значение по умолчанию для переменной, введенной как int, составляет <codeph>0</codeph></p>
 <p>При работе с числами, превышающими <codeph>int.MAX_VALUE</codeph>, попробуйте воспользоваться объектом Number.  </p>
 <p>В следующем примере вызывается метод <codeph>toString()</codeph> класса int, который возвращает строку <codeph>1234</codeph>: </p>
 <codeblock rev="3.0">
 var myint:int = 1234;
 myint.toString();
 </codeblock>
 <p>В следующем примере значение свойства <codeph>MIN_VALUE</codeph> присваивается переменной, объявленной без использования конструктора:</p>
 <pre>
 var smallest:int = int.MIN_VALUE;
 </pre> 
 
 </apiDesc><example conref="examples\IntExample.as"> В следующем примере класс <codeph>IntExample</codeph> применяется для того, чтобы показать, как работать с типами данных и проверять типы данных int:
 <ol>
     <li>В конструкторе объявлены две переменные int (<codeph>a</codeph> и <codeph>b</codeph>).</li>
     <li>Две переменные int добавляются с помощью метода <codeph>addIntegers()</codeph>.</li>
     <li>Третьей переменной int (<codeph>c</codeph>) присваивается значение, выводимое методом <codeph>parseInteger()</codeph>, который проверяет достоверность переданной ему строки, чтобы убедиться, что это целое значение в приемлемом диапазоне типов данных int и возвращает значение int, которое в случае достоверности строки является целочисленным значением строки.</li>
     <li>Переменные int <codeph>a</codeph> и <codeph>c</codeph> добавляются вместе с помощью <codeph>addIntegers()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class IntExample extends Sprite {    
        public function IntExample() {
            var a:int = 512;
            var b:int = -128;
            
            trace(addIntegers(a, b)); // 384

            var c:int = parseInteger("32");
            
            trace(addIntegers(a, c)); // 544
        }
            
        public function addIntegers(a:int, b:int):int {
            return a + b;
        }
        
        public function parseInteger(str:String):int {
            var num:Number = parseInt(str);
            if(!isNaN(num) &amp;&amp; num &lt;= int.MAX_VALUE &amp;&amp; num >= int.MIN_VALUE) {
                return int(num);
            }
            
            return 0;
        }
        
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="uint.html"><linktext>uint</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="int:int"><apiName>int</apiName><shortdesc>
	 Конструктор. Создает новый объект int.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Числовое значение создаваемого объекта int или значение, которое должно быть преобразовано в число. Если не указан параметр <codeph>value</codeph>, значение по умолчанию – 0.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Конструктор. Создает новый объект int. При использовании <codeph>int.toString()</codeph> и <codeph>int.valueOf()</codeph> необходимо применять конструктор int. При использовании свойств объекта int конструктор применять не требуется. Конструктор <codeph>new int</codeph> используется в основном в качестве заполнителя. Объект int не аналогичен функции <codeph>int()</codeph>, которая преобразует параметр в элементарное значение.
	 
 	 </apiDesc><example>Следующий код создает новые объекты int:
	 <pre>
	 var n1:int = new int(3.4);
	 var n2:int = new int(-10);
	 </pre>
	 
	 
	 </example></apiConstructorDetail><related-links><link href="#int/toString()"><linktext>int.toString()</linktext></link><link href="#int/valueOf()"><linktext>int.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="int:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      Возвращает экспоненциальное строковое представление числа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>fractionDigits</codeph> выходит за пределы диапазона от 0 до 20.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 0 до 20 включительно, которое соответствует необходимому количеству регистров после запятой.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Возвращает экспоненциальное строковое представление числа. Строка содержит одну цифру перед запятой и до 20 цифр после запятой, как указано в параметре <codeph>fractionDigits</codeph>.
      </apiDesc><example conref="examples\Number.toExponential.1.as"> В следующем примере показано, как <codeph>toExponential(2)</codeph> возвращает строку в экспоненциальном представлении.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     Возвращает строковое представление числа в нотации с фиксированной запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>fractionDigits</codeph> выходит за пределы диапазона от 0 до 20.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 0 до 20 включительно, которое соответствует необходимому количеству регистров после запятой.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает строковое представление числа в нотации с фиксированной запятой. Представление с фиксированной запятой означает, что строка будет содержать определенное количество цифр после запятой, исходя из значения параметра <codeph>fractionDigits</codeph>. Действительный диапазон параметра <codeph>fractionDigits</codeph>составляет от 0 до 20. Выбор значения за пределами этого диапазона приводит к созданию исключения.
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> В следующем примере показано, как <codeph>toFixed(3)</codeph> возвращает строку, которая округляется до трех цифр после запятой.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> В следующем примере показано, как <codeph>toFixed(2)</codeph> возвращает строку, добавляющую в конце нули.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      Возвращает строковое представление числа в нотации с фиксированной запятой либо в экспоненциальной нотации.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>precision</codeph> выходит за пределы диапазона от 1 до 21.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 1 до 21 включительно, которое представляет необходимое количество цифр в строке результатов.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Возвращает строковое представление числа в нотации с фиксированной запятой либо в экспоненциальной нотации. Строка будет содержать количество цифр, указанное в параметре <codeph>precision</codeph>.
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> В следующем примере показано, как <codeph>toPrecision(3)</codeph> возвращает строку только с тремя цифрами. Эта строка представлена в нотации с фиксированной запятой, поскольку экспоненциальная нотация не требуется.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> В следующем примере показано, как <codeph>toPrecision(3)</codeph> возвращает строку только с тремя цифрами. Строка представлена в экспоненциальной нотации, поскольку итоговое число не содержит достаточно цифр для нотации с фиксированной запятой.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Возвращает строковое представление объекта int.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строка.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Указывает числовую основу (от 2 до 36), используемую при преобразовании чисел в строку. Если параметр <codeph>radix</codeph> не указан, значение по умолчанию равно 10.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строковое представление объекта <codeph>int</codeph>.
	 
	 </apiDesc><example>В следующем примере для параметров <codeph>radix</codeph> выбраны значения 2 и 8. При этом возвращается строка с соответствующим представлением числа 9:
	 <pre>
	 var myint:int = new int(9);
	 trace(myint.toString(2)); // 1001
	 trace(myint.toString(8)); // 11
	 </pre>
	 <p>Результатом выполнения следующего примера является шестнадцатеричное значение.</p>
	 <pre>
	 var r:int = new int(250);
	 var g:int = new int(128);
	 var b:int = new int(114);
	 var rgb:String = "0x"+ r.toString(16)+g.toString(16)+b.toString(16);
	 trace(rgb); // 0xfa8072
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Возвращает элементарное значение заданного объекта int.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Значение int.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает элементарное значение заданного объекта int.
	 
 	 </apiDesc><example>В следующем примере результат – элементарное значение объекта <codeph>numSocks</codeph>.
	 <pre>
	 var numSocks:int = new int(2);
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="int:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	Наибольшее представимое 32-разрядное целое число со знаком, а именно 2 147 483 647.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2147483647</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
	Наибольшее представимое 32-разрядное целое число со знаком, а именно 2 147 483 647.
	
    </apiDesc><example>Следующий код ActionScript <ph outputclass="flashonly">показывает</ph> и <ph outputclass="flexonly">записывает</ph> наибольший и наименьший представимые объекты int <ph outputclass="flashonly">на панели «Вывод»</ph> и <ph outputclass="flexonly">в файле журнала</ph>:
	<pre>
	trace("int.MIN_VALUE = "+int.MIN_VALUE);
	trace("int.MAX_VALUE = "+int.MAX_VALUE);
	</pre>
	<p>Этот код <ph outputclass="flexonly">регистрирует</ph> и <ph outputclass="flashonly">показывает</ph> следующие значения:</p>
	<pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
	</pre>
	
	
	</example></apiValueDetail></apiValue><apiValue id="int:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 Наименьшее представляемое 32-разрядное целое число со знаком, а именно -2 147 483 648.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>-2147483648</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Наименьшее представляемое 32-разрядное целое число со знаком, а именно -2 147 483 648.
	 
 	 </apiDesc><example>Следующий код ActionScript <ph outputclass="flashonly">показывает</ph><ph outputclass="flexonly">и записывает</ph> наибольший и наименьший представимые объекты int<ph outputclass="flashonly"> на панели «Вывод»</ph><ph outputclass="flexonly"> в файле журнала</ph>:
     <pre>
     trace("int.MIN_VALUE = "+int.MIN_VALUE);
     trace("int.MAX_VALUE = "+int.MAX_VALUE);
     </pre>
     <p>Этот код <ph outputclass="flexonly">регистрирует</ph> и <ph outputclass="flashonly">показывает</ph> следующие значения:</p>
     <pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
     </pre>
     
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Number"><apiName>Number</apiName><shortdesc>
 Тип данных, представляющий число IEEE-754 с удвоенной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number object, number, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Класс Number представляет собой простую оболочку для типа данных <codeph>Number</codeph>.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Тип данных, представляющий число IEEE-754 с удвоенной точностью и плавающей запятой. Элементарными числовыми значениями можно управлять с помощью методов и свойств, связанных с классом Number. Этот класс идентичен классу JavaScript Number.
 <p>Свойства класса Number статичны. При этом для того, чтобы пользоваться ими, не нужен объект, а значит не требуется использовать конструктор.</p>
 <p>Тип данных Number относится к стандарту двойной точности IEEE-754. </p>
 <p>Тип данных Number полезен, если необходимо использовать значения с плавающей запятой. Flash Player обрабатывает типы данных int и uint эффективней, чем Number. Но последний полезен в ситуациях, когда диапазон требуемых значений выходит за пределы действительного диапазона типов данных int и uint. Класс Number можно использовать для представления целых значений, которые находятся далеко за пределами действительного диапазона типов данных int и uint. В типе данных Number для представления целых значений может отводиться до 53 бит в отличие от типов данных int и uint, для которых отводится 32 бита. Значение по умолчанию для переменной, введенной как Number, – <codeph>NaN</codeph> (нечисловое).</p>
 
 </apiDesc><example conref="examples\NumberExample.as"> В следующем примере показано, как число с шестью цифрами после запятой усекается (с округлением) до числа с двумя цифрами после запятой.
<codeblock>

package {
    import flash.display.Sprite;

    public class NumberExample extends Sprite {
        public function NumberExample() {
            var num:Number = new Number(10.456345);
            var str:String = num.toFixed(2);
            trace(num); // 10.456345
            trace(str); // 10.46
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="uint.html"><linktext>uint</linktext></link></related-links><apiConstructor id="Number:Number"><apiName>Number</apiName><shortdesc>
  Создает объект Number с заданным значением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Числовое значение создаваемого объекта Number или значение, которое должно быть преобразовано в объект Number. Если не указан параметр <codeph>num</codeph>, значение по умолчанию – 0. Использование конструктора без указания параметра <codeph>num</codeph> отличается от объявления переменной типа Number без присвоенного значения (например, <codeph>var myNumber:Number</codeph>), при котором установлено значение по умолчанию <codeph>NaN</codeph>. Число без присвоенного значения не определено и является эквивалентом <codeph>нового объекта Number (неопределенный)</codeph>.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Создает объект Number с заданным значением.
  
  </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
  Создает объект Number с заданным значением. Этот конструктор предназначен для того же, для чего и публичная собственная функция <codeph>Number()</codeph>, которая преобразует объект другого типа в элементарное числовое значение.
  
  </apiDesc></apiConstructorDetail><related-links><link href="#Number/toString()"><linktext>Number.toString()</linktext></link><link href="#Number/valueOf()"><linktext>Number.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="Number:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
	  Возвращает экспоненциальное строковое представление числа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>fractionDigits</codeph> выходит за пределы диапазона от 0 до 20.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 0 до 20 включительно, которое соответствует необходимому количеству регистров после запятой.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Возвращает экспоненциальное строковое представление числа. Строка содержит одну цифру перед запятой и до 20 цифр после запятой, как указано в параметре <codeph>fractionDigits</codeph>.
	  </apiDesc><example conref="examples\Number.toExponential.1.as"> В следующем примере показано, как <codeph>toExponential(2)</codeph> возвращает строку в экспоненциальном представлении.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
	 Возвращает строковое представление числа в нотации с фиксированной запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>fractionDigits</codeph> выходит за пределы диапазона от 0 до 20.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 0 до 20 включительно, которое соответствует необходимому количеству регистров после запятой.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строковое представление числа в нотации с фиксированной запятой. Представление с фиксированной запятой означает, что строка будет содержать определенное количество цифр после запятой, исходя из значения параметра <codeph>fractionDigits</codeph>. Действительный диапазон параметра <codeph>fractionDigits</codeph>составляет от 0 до 20. Выбор значения за пределами этого диапазона приводит к созданию исключения.
	 
	 </apiDesc><example conref="examples\Number.toFixed.1.as"> В следующем примере показано, как <codeph>toFixed(3)</codeph> возвращает строку, которая округляется до трех цифр после запятой.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> В следующем примере показано, как <codeph>toFixed(2)</codeph> возвращает строку, добавляющую в конце нули.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
	  Возвращает строковое представление числа в нотации с фиксированной запятой либо в экспоненциальной нотации.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>precision</codeph> выходит за пределы диапазона от 1 до 21.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 1 до 21 включительно, которое представляет необходимое количество цифр в строке результатов.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Возвращает строковое представление числа в нотации с фиксированной запятой либо в экспоненциальной нотации. Строка будет содержать количество цифр, указанное в параметре <codeph>precision</codeph>.
	  </apiDesc><example conref="examples\Number.toPrecision.1.as"> В следующем примере показано, как <codeph>toPrecision(3)</codeph> возвращает строку только с тремя цифрами. Эта строка представлена в нотации с фиксированной запятой, поскольку экспоненциальная нотация не требуется.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> В следующем примере показано, как <codeph>toPrecision(3)</codeph> возвращает строку только с тремя цифрами. Строка представлена в экспоненциальной нотации, поскольку итоговое число не содержит достаточно цифр для нотации с фиксированной запятой.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toString"><apiName>toString</apiName><shortdesc>
 Возвращает строковое представление заданного объекта Number (myNumber).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Числовое представление объекта Number в виде строки.
 
 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>10</apiData><apiDesc>Указывает числовую основу (от 2 до 36), используемую при преобразовании чисел в строку. Если параметр <codeph>radix</codeph> не указан, значение по умолчанию равно 10.
 
 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает строковое представление данного объекта Number заданным параметром основания в качестве числовой базы.
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 Возвращает строковое представление заданного объекта Number (<codeph><i>myNumber</i></codeph>). Если значением объекта Number является десятичное число без ноля в начале (например, <codeph>,4</codeph>), то <codeph>Number.toString()</codeph> добавляет 0 (<codeph>0,4</codeph>).
 
 
 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
 Возвращает тип элементарного значения для заданного объекта Number.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Элементарный тип значения объекта Number.
 
 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Возвращает тип элементарного значения для заданного объекта Number.
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 Возвращает тип элементарного значения для заданного объекта Number.
 
 </apiDesc></apiOperationDetail></apiOperation><apiValue id="Number:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc>
  Наибольшее представимое число (число IEEE-754 с удвоенной точностью).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.max_value, max_value, max value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Наибольшее представимое число (число IEEE-754 с удвоенной точностью).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Наибольшее представимое число (число IEEE-754 с удвоенной точностью). Это число равно примерно 1,79e+308.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
  Наименьшее представимое неотрицательное отличное от нуля число (IEEE-754 двойной точности).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.min_value, min_value, min value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Наименьшее представимое число (IEEE-754 двойной точности).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Наименьшее представимое неотрицательное отличное от нуля число (IEEE-754 двойной точности). Это число равно примерно 5e-324. В действительности, наименьшим представимым числом является значение параметра <codeph>-Number.MAX_VALUE</codeph>.
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NEGATIVE_INFINITY"><apiName>NEGATIVE_INFINITY</apiName><shortdesc>
  Задает значение IEEE-754, представляющее минус бесконечность.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.negative_infinity, negative_infinity, negative infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Задает значение IEEE-754, представляющее минус бесконечность.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Задает значение IEEE-754, представляющее минус бесконечность. Значение этого свойства аналогично значению константы <codeph>-Infinity</codeph>.
  <p>
  Минус бесконечность – это особое числовое значение, возвращаемое в том случае, когда математическая операция или функция возвращают отрицательное значение, которое не может быть представлено из-за слишком большой длины.
  </p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NaN"><apiName>NaN</apiName><shortdesc>
  Нечисловое значение IEEE-754 (NaN).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.nan, nan, not a number
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Нечисловое значение IEEE-754 (NaN).
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Нечисловое значение IEEE-754 (<codeph>NaN</codeph>).
  
  </apiDesc></apiValueDetail><related-links><link href="package.html#isNaN()"><linktext>isNaN()</linktext></link></related-links></apiValue><apiValue id="Number:POSITIVE_INFINITY"><apiName>POSITIVE_INFINITY</apiName><shortdesc>
  Задает значение IEEE-754, представляющее плюс бесконечность.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.positive_infinity, positive_infinity, positive infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Задает значение IEEE-754, представляющее плюс бесконечность.
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Задает значение IEEE-754, представляющее плюс бесконечность. Значение этого свойства аналогично значению константы <codeph>Infinity</codeph>.
  <p>
  Плюс бесконечность – это особое числовое значение, возвращаемое в том случае, когда математическая операция или функция возвращают значение, которое не может быть представлено из-за слишком большой длины.
  </p>
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
 Класс DefinitionError представляет ошибку, которая возникает при попытке задать пользовательским кодом уже заданный идентификатор.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Исключение DefinitionError создается, когда в коде проводится попытка переопределить класс, интерфейс или функцию.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс DefinitionError представляет ошибку, которая возникает при попытке задать пользовательским кодом уже заданный идентификатор. Эта ошибка обычно происходит при переопределении классов, интерфейсов и функций.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="DefinitionError:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
	 Создает новый объект DefinitionError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект DefinitionError.
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Function"><apiName>Function</apiName><shortdesc>
 Функция – это основная единица кода, которую можно вызвать в ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Класс Function используется для представления встроенных или определяемых пользователем функций.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Функция – это основная единица кода, которую можно вызвать в ActionScript. Объекты Function, которые являются экземплярами класса Function, представляют в ActionScript как встроенные, так и определяемые пользователем функции.
 <p>Методы класса немного отличаются от объектов Function. В отличие от обычного объекта функции метод тесно связан со связанным объектом класса. Поэтому метод или свойство имеют определение, используемое всеми экземплярами одного и того же класса. Из экземпляра можно извлечь методы, обрабатываемые как «связанные» методы (сохраняющие ссылку на исходный экземпляр). В рамках связанного метода ключевое слово <codeph>this</codeph> указывает на исходный объект, реализовавший этот метод. В случае функции <codeph>this</codeph> указывает на связанный объект на момент вызова функции.</p>
 
 
 </apiDesc><example conref="examples\FunctionExample.as"> В следующем примере классы <codeph>FunctionExample</codeph>, <codeph>SimpleCollection</codeph>, <codeph>EventBroadcaster</codeph> и <codeph>EventListener</codeph> используются для показа различных применений функций в ActionScript. Это можно сделать, выполнив следующие действия:
 <ol>
    <li>Конструктор <codeph>FunctionExample</codeph> создает локальную переменную <codeph>simpleColl</codeph>, которая заполняется массивом целых чисел в диапазоне от <codeph>1</codeph> до <codeph>8</codeph>. </li>
    <li>Объект <codeph>simpleColl</codeph> выводится на печать методом <codeph>trace()</codeph>.</li>
  <li>Объект EventListener (<codeph>listener</codeph>) добавляется в <codeph>simpleColl</codeph>.</li>
  <li>При вызове функций <codeph>insert()</codeph> и <codeph>remove()</codeph> этот прослушиватель отвечает на их события.</li>
    <li>Создается второй объект SimpleCollection с именем <codeph>greaterThanFourColl</codeph>.</li>
    <li>Объекту <codeph>greaterThanFourColl</codeph> присваивается результат <codeph>simpleColl.select()</codeph> с аргументом <codeph>4</codeph> и анонимной функцией. Метод выбора объекта SimpleCollection – внутренний итератор, использующий в качестве блока анонимный параметр функции.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class FunctionExample extends Sprite {
        public function FunctionExample() {
            var simpleColl:SimpleCollection;
            simpleColl = new SimpleCollection(0, 1, 2, 3, 4, 5, 6, 7, 8);
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 8

            var listener:EventListener = new EventListener();
            simpleColl.addListener(listener);
            simpleColl.insert(9);        // itemInsertedHandler: 9
            simpleColl.remove(8);        // itemRemovedHandler: 8
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 9

            var greaterThanFourColl:SimpleCollection;
            greaterThanFourColl = simpleColl.select(4, function(item:int, value:int){ return item > value });
            trace(greaterThanFourColl);    // 5, 6, 7, 9
        }
    }
}
    
import flash.display.Sprite;
    
class EventBroadcaster {
    private var listeners:Array;

    public function EventBroadcaster() {
        listeners = new Array();
    }
        
    public function addListener(obj:Object):void {
        removeListener(obj);
        listeners.push(obj);
    }
        
    public function removeListener(obj:Object):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            if(listeners[i] == obj) {
                listeners.splice(i, 1);
            }
        }
    }
    
    public function broadcastEvent(evnt:String, ...args):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            listeners[i][evnt].apply(listeners[i], args);
        }
    }    
}
    
class SimpleCollection extends EventBroadcaster {
    private var arr:Array;
        public function SimpleCollection(... args) {
        arr = (args.length == 1 &amp;&amp; !isNaN(args[0])) ? new Array(args[0]) : args;
    }
        
    public function insert(obj:Object):void {
        remove(obj);
        arr.push(obj);
        broadcastEvent("itemInsertedHandler", obj);
    }
        
    public function remove(obj:Object):void {
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(arr[i] == obj) {
                var obj:Object = arr.splice(i, 1)[0];
                broadcastEvent("itemRemovedHandler", obj);
            }
        }
    }

    public function select(val:int, fn:Function):SimpleCollection {
        var col:SimpleCollection = new SimpleCollection();
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(fn.call(this, arr[i], val)) {
                col.insert(arr[i]);
            }
        }
        return col;
    }
        
    public function toString():String {
        var str:String = new String();
        for(var i:uint = 0; i &lt; arr.length - 1; i++) {
            str += arr[i] + ", ";
        }
        str += arr[arr.length - 1];
        return str;
    }
}

class EventListener {
    public function EventListener() {
    }
    
    public function itemInsertedHandler(obj:Object):void {
        trace("itemInsertedHandler: " + obj);
    }
    
    public function itemRemovedHandler(obj:Object):void {
        trace("itemRemovedHandler: " + obj);        
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="Function:AS3:apply"><apiName>apply</apiName><shortdesc>
  Указывает значение thisObject, используемого в любой функции, вызываемой ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.apply, apply
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Любое значение, указанное вызванной функцией.
  
  
  </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Объект, к которому применяется функция.
  
  </apiDesc></apiParam><apiParam><apiItemName>argArray</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Массив, элементы которого передаются функции в качестве параметров.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Задает экземпляр объекта, для которого вызывается функция.
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Указывает значение <codeph>thisObject</codeph>, используемого в любой функции, вызываемой ActionScript. Этот метод также указывает параметры, передаваемые любой вызванной функции. Поскольку <codeph>apply()</codeph> – это метод класса Function, он также является методом любого объекта Function в ActionScript. 
  <p>Параметры указываются как объект Array в отличие от метода <codeph>Function.call()</codeph>, в котором параметры представлены в виде списка, разделенного запятыми. Часто бывает полезно, когда ряд передаваемых параметров неизвестен вплоть до фактического выполнения сценария.</p>
  <p>Возвращает значение, которое вызванная функция указывает в качестве возвращаемого значения.</p>

  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link></related-links></apiOperation><apiOperation id="Function:AS3:call"><apiName>call</apiName><shortdesc>
  Вызывает функцию, представленную объектом Function.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.call, call
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>Объект, указывающий значение <codeph>thisObject</codeph> в теле функции.
  
  </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Один или несколько параметров, передаваемых функции. Можно указать 0 или несколько параметров.
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>Вызывает эту функцию. 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Вызывает функцию, представленную объектом Function. Каждая функция в ActionScript представлена объектом Function, и все функции поддерживают этот метод. 
  <p>Почти всегда вместо этого метода можно прибегнуть к оператору вызова функции (<codeph>()</codeph>). Оператор вызова функции создает краткий и легко читаемый код. Этот метод полезен, в основном, тогда, когда параметр <codeph>thisObject</codeph> вызова функции необходимо контролировать явным образом. Обычно если функция вызывается как метод объекта, находящегося в теле функции, параметру <codeph>thisObject</codeph> присваивается значение <codeph>myObject</codeph>, как показано в следующем примере:</p>
  <codeblock>
  myObject.myMethod(1, 2, 3);
  </codeblock>
  <p>В некоторых ситуациях может потребоваться, чтобы <codeph>thisObject</codeph> указывал на другой объект (например, если функцию необходимо вызвать как метод объекта, но на самом деле она не сохраняется как метод этого объекта):</p>
  <codeblock>
  myObject.myMethod.call(myOtherObject, 1, 2, 3); 
  </codeblock>
  <p>Чтобы вызвать функцию в качестве регулярной функции, а не метода объекта, можно присвоить значение <codeph>null</codeph> параметру <codeph>thisObject</codeph>. Например, эквивалентны следующие вызовы функции:</p>
  <codeblock>
  Math.sin(Math.PI / 4)
  Math.sin.call(null, Math.PI / 4)
  </codeblock>
  
  <p>Возвращает значение, которое вызванная функция указывает в качестве возвращаемого значения.</p>
  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/apply()"><linktext>Function.apply()</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="globalClassifier:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
 Исключение SyntaxError создается при ошибке разбора по одной из следующих причин:</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SyntaxError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Исключение SyntaxError создается при ошибке разбора по одной из следующих причин: 
 <ul>
   <li>Класс RegExp выполнил разбор недействительного регулярного выражения.</li>
   <li>Недействительное содержимое XML разбирается классом XML.</li>
 </ul>
 
 </apiDesc></apiClassifierDetail><related-links><link href="#RegExp"><linktext>Класс RegExp</linktext></link><link href="#XML"><linktext>Класс XML</linktext></link></related-links><apiConstructor id="SyntaxError:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
	 Создает новый объект SyntaxError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Содержит сообщение, связанное с объектом SyntaxError. 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект SyntaxError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Boolean"><apiName>Boolean</apiName><shortdesc>
Объект Boolean – это тип данных, который используется для логических операций и может иметь одно из двух значений (true или false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>Objects/Core/Boolean/
 
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Объект Boolean – это тип данных, который используется для логических операций и может иметь одно из двух значений (<codeph>true</codeph> или <codeph>false</codeph>). Используйте класс Boolean, чтобы извлечь элементарный тип данных или строковое представление объекта Boolean. 

<p>Чтобы создать объект Boolean, можно воспользоваться конструктором или глобальной функцией либо присвоить значение литерала. Не имеет значения, какой метод использовать; в ActionScript 3.0 все три метода эквивалентны. (Это отличает его от языка JavaScript, где объект Boolean отличается от элементарного типа Boolean.)</p>

  <p>Следующие строки кода эквивалентны:</p>
<codeblock rev="3.0">
var flag:Boolean = true;
var flag:Boolean = new Boolean(true);
var flag:Boolean = Boolean(true);
</codeblock>

 </apiDesc><example conref="examples\BooleanExample.as"> В следующем примере выполняются переключение и показ всех соответствующих значений объекта Boolean.
<codeblock>
 package {
    import flash.display.Sprite;

    public class BooleanExample extends Sprite {
        private var flag:Boolean;

        public function BooleanExample() {
            trace(flag);    // false
            toggle();
            trace(flag);    // true
            toggle();
            trace(flag);    // false
        }
        
        private function toggle():void{
            flag = !flag;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Boolean:Boolean"><apiName>Boolean</apiName><shortdesc>
 Создает объект Boolean с заданным значением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new boolean, constructor
  
  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>Любое выражение. 
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Создает объект Boolean с заданным значением. Если параметр <codeph>expression</codeph> пропущен, объект Boolean инициализируется со значением <codeph>false</codeph>. Если параметру <codeph>expression</codeph> присвоено значение, метод оценивает его и возвращает результат в виде логического значения согласно правилам в глобальной функции <codeph>Boolean()</codeph>.
 
 </apiDesc><example>Следующий код создает новый объект Boolean, инициализируемый со значением <codeph>false</codeph> и именем <codeph>myBoolean</codeph>:
 <codeblock rev="3.0">
 var myBoolean:Boolean = new Boolean();
 </codeblock>
 
 </example></apiConstructorDetail><related-links><link href="package.html#Boolean()"><linktext>Boolean()</linktext></link></related-links></apiConstructor><apiOperation id="Boolean:AS3:toString"><apiName>toString</apiName><shortdesc>
	  Возвращает строковое представление (true или false) объекта Boolean.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строка <codeph>true</codeph> или <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  Возвращает строковое представление (<codeph>true</codeph> или <codeph>false</codeph>) объекта Boolean. Выводимая информация не локализуется и принимает значение <codeph>true</codeph> или <codeph>false</codeph> независимо от языка системы.
	 
 	 </apiDesc><example>В этом примере создается переменная типа Boolean, а затем метод <codeph>toString()</codeph> применяется для преобразования значения в строку для использования в массиве строк:
	 <codeblock rev="3.0">
	 var myStringArray:Array = new Array("yes", "could be");
	 var myBool:Boolean = 0;
	 myBool.toString();
	 myStringArray.push(myBool);
	 trace(myStringArray); // yes,could be,false
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="Boolean:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Возвращает true, если указанный объект Boolean имеет значение true, в противном случае возвращает false.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.valueOf, valueOf
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Логическое значение.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает <codeph>true</codeph>, если указанный объект Boolean имеет значение true, в противном случае возвращает <codeph>false</codeph>.  
	 
	 </apiDesc><example>В следующем примере показано действие этого метода. Кроме того, указано, что значение нового объекта Boolean – <codeph>false</codeph>:
	 <codeblock rev="3.0">
	 var myBool:Boolean = new Boolean();
	 trace(myBool.valueOf());   // false
	 myBool = (6==3+3);
	 trace(myBool.valueOf());   // true  
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:XMLList"><apiName>XMLList</apiName><shortdesc>
 Класс XMLList содержит методы для работы с одним или несколькими XML-элементами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XMLList
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс XMLList содержит методы для работы с одним или несколькими XML-элементами. Объект XMLList может представлять один или несколько объектов или элементов XML (включая несколько узлов или атрибутов). Поэтому можно вызывать методы по отношению к элементам в виде группы или к отдельным элементам в коллекции.
 <p>Если объект XMLList имеет только один элемент XML, методы класса XML можно применять к объекту XMLList напрямую. В следующем примере <codeph>example.two</codeph> – это объект XMLList длиной 1, и для него можно вызвать любой метод XML.</p>
 <codeblock>
 var example2 = &lt;example>&lt;two>2&lt;/two>&lt;/example>;</codeblock>
 <p>Если вы попытаетесь использовать методы класса XML в отношении объекта XMLList, содержащего более одного объекта XML, возникнет исключение. Вместо этого следует выполнить итерацию в коллекции XMLList (например, с помощью оператора <codeph>for each.. in</codeph>) и применить эти методы к каждому объекту XML в коллекции.</p>
 
 </apiDesc><example conref="examples\XMLListExample.as"> В следующем примере создается свойство XML <codeph>books</codeph> и добавляются несколько элементов с тегами <codeph>book publisher</codeph> и <codeph>name</codeph> в узел <codeph>books</codeph>. Затем вызывается метод <codeph>showBooksByPublisher()</codeph>, который обрабатывает XMLList и возвращает все элементы с издателем Addison-Wesley.
<codeblock>
package {
    import flash.display.Sprite;

    public class XMLListExample extends Sprite {
        private var books:XML;

        public function XMLListExample() {
            books =    &lt;books>
                        &lt;book publisher="Addison-Wesley" name="Design Patterns" />
                        &lt;book publisher="Addison-Wesley" name="The Pragmatic Programmer" />
                        &lt;book publisher="Addison-Wesley" name="Test Driven Development" />
                        &lt;book publisher="Addison-Wesley" name="Refactoring to Patterns" />
                        &lt;book publisher="O'Reilly Media" name="The Cathedral &amp; the Bazaar" />
                        &lt;book publisher="O'Reilly Media" name="Unit Test Frameworks" />
                    &lt;/books>;

            showBooksByPublisher("Addison-Wesley");
        }

        private function showBooksByPublisher(name:String):void {
            var results:XMLList = books.book.(@publisher == name);
            showList(results);
        }

        private function showList(list:XMLList):void {
            var item:XML;
            for each(item in list) {
                trace("item: " + item.toXMLString());
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="statements.html#for_each..in"><linktext>for each.. in</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#QName"><linktext>QName</linktext></link></related-links><apiConstructor id="XMLList:XMLList"><apiName>XMLList</apiName><shortdesc>
	Создает новый объект XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList 
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Любой объект, который может быть преобразован в объект XMLList с помощью функции верхнего уровня <codeph>XMLList()</codeph>.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Создает новый объект XMLList.
	
	</apiDesc></apiConstructorDetail><related-links><link href="#global/XMLList()"><linktext>функция верхнего уровня XMLList()</linktext></link></related-links></apiConstructor><apiOperation id="XMLList:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	Вызывает метод attribute() каждого объекта XML и возвращает объект XMLList, состоящий из результатов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList из совпадающих объектов XML или пустой объект XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>Название атрибута, который требуется включить в объект XMLList.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Вызывает метод <codeph>attribute()</codeph> каждого объекта XML и возвращает объект XMLList, состоящий из результатов. Результаты соответствуют заданному параметру <codeph>attributeName</codeph>. Если совпадения нет, метод <codeph>attribute()</codeph> возвращает пустой объект XMLList.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	Вызывает метод attributes() каждого объекта XML и возвращает объект XMLList, состоящий из атрибутов каждого объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList с атрибутами каждого объекта XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Вызывает метод <codeph>attributes()</codeph> каждого объекта XML и возвращает объект XMLList, состоящий из атрибутов каждого объекта XML. 
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:child"><apiName>child</apiName><shortdesc>
	Вызывает метод child() каждого объекта XML и возвращает объект XMLList, содержащий упорядоченные результаты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList с узлами нижестоящих элементов, соответствующими введенному параметру.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Имя элемента или целого числа нижестоящего элемента XML.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Вызывает метод <codeph>child()</codeph> каждого объекта XML и возвращает объект XMLList, содержащий упорядоченные результаты.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:children"><apiName>children</apiName><shortdesc>
	Вызывает метод children() каждого объекта XML и возвращает объект XMLList, содержащий результаты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList с нижестоящими элементами объектов XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Вызывает метод <codeph>children()</codeph> каждого объекта XML и возвращает объект XMLList, содержащий результаты.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/children()"><linktext>XML.children()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:comments"><apiName>comments</apiName><shortdesc>
	Вызывает метод comments() каждого объекта XML и возвращает объект XMLList, состоящий из комментариев.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XMLList с комментариями в объектах XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Вызывает метод <codeph>comments()</codeph> каждого объекта XML и возвращает объект XMLList, состоящий из комментариев.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/comments()"><linktext>XML.comments()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:contains"><apiName>contains</apiName><shortdesc>
	Проверяет наличие в объекте XMLList объекта XML, равного заданному параметру value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если XMLList содержит объект XML, объявленный в параметре<codeph>value</codeph>, то присваивается значение <codeph>true</codeph>; в противном случае – значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Объект XML, сравниваемый с текущим объектом XMLList. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Проверяет наличие в объекте XMLList объекта XML, равного заданному параметру <codeph>value</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:copy"><apiName>copy</apiName><shortdesc>
	Возвращает копию заданного объекта XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия объекта XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию заданного объекта XMLList. Копия – это дубликат всего дерева узлов. Скопированный объект XML не имеет вышестоящего элемента и возвращает <codeph>null</codeph>, если Вы пытаетесь вызвать метод <codeph>parent()</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	Возвращает всех потомков (нижестоящие элементы всех уровней) объекта XML, обладающих данным параметром name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList совпадающих потомков (нижестоящих элементов всех уровней) объектов XML в исходном списке. Если нижестоящих элементов не существует, возвращается пустой объект XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Имя совпадающего элемента.
	
 	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Возвращает все нижестоящие элементы (нижестоящие элементы всех уровней) объекта XML, обладающие данным параметром <codeph>name</codeph>. Параметр <codeph>name</codeph> может представлять собой объект QName, тип данных String или любой другой тип данных, который затем преобразуется в тип данных String.
	
	<p>Чтобы показать всех потомков, воспользуйтесь параметром «звездочки» (~~). Если параметр не задан, передается строка «~~» и отображаются все потомки объекта XML.</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/descendants()"><linktext>XML.descendants()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:elements"><apiName>elements</apiName><shortdesc>
	Вызывает метод elements() каждого объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.elements, elements
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList совпадающих нижестоящих элементов объектов XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Имена искомых элементов.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Вызывает метод <codeph>elements()</codeph> каждого объекта XML. Параметр <codeph>name</codeph> передается методу <codeph>descendants()</codeph>. Если параметр не задан, строка «~~» передается методу <codeph>descendants()</codeph>.
	
 	</apiDesc></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	Проверяет наличие в объекте XMLList сложного содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если объект XMLList содержит сложное содержимое, то выбирается значение <codeph>true</codeph>; в противном случае выбирается значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Проверяет наличие в объекте XMLList сложного содержимого. Объект XMLList считается имеющим сложное содержимое, если он не является пустым и верно одно из следующих условий: 
	
	<ul>
	  <li>Объект XMLList содержит один элемент XML, имеющий сложное содержимое.</li>
	  <li>Объект XMLList содержит элементы.</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	Проверяет наличие свойства, заданного параметром p.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если параметр существует, указывается значение <codeph>true</codeph>; в противном случае выбирается значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Совпадающее свойство.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Проверяет наличие свойства, заданного параметром <codeph>p</codeph>. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	Проверяет наличие в объекте XMLList простого содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если XMLList содержит сложное содержимое, то выбирается значение <codeph>true</codeph>; в противном случае выбирается значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Проверяет наличие в объекте XMLList простого содержимого. Объект XMLList считается имеющим сложное содержимое, если выполняется одно или несколько следующих условий:
	<ul>
	  <li>Объект XMLList не является пустым.</li>
	  <li>Объект XMLList содержит один элемент XML, имеющий простое содержимое.</li>
	  <li>Объект XMLList не содержит элементы.</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:length"><apiName>length</apiName><shortdesc>
	Возвращает число свойств в объекте XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Число свойств в объекте XMLList. 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает число свойств в объекте XMLList.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	Выполняет слияние смежных текстовых узлов и удаляет пустые текстовые узлы для следующих объектов: всех текстовых узлов в объекте XMLList, всех объектов XML в объекте XMLList, а также потомков всех объектов XML в объекте XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Нормализованный объект XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Выполняет слияние смежных текстовых узлов и удаляет пустые текстовые узлы для следующих объектов: всех текстовых узлов в объекте XMLList, всех объектов XML в объекте XMLList, а также потомков всех объектов XML в объекте XMLList. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:parent"><apiName>parent</apiName><shortdesc>
	Возвращает вышестоящий объект для объекта XMLList, если вышестоящий объект у всех элементов в объекте XMLList общий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Возвращает вышестоящий объект XML.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает вышестоящий объект для объекта XMLList, если вышестоящий объект у всех элементов в объекте XMLList общий. Если объект XMLList лишен вышестоящего объекта или имеет другие вышестоящие объекты, метод возвращает значение <codeph>undefined</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	Если параметр name введен, отображает список всех нижестоящих объектов для объекта XMLList, содержащих инструкции обработки с данным именем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList содержащий инструкции по обработке для каждого объекта XML.
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>Имя совпадающих инструкций по обработке.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Если параметр <codeph>name </codeph> введен, отображает список всех нижестоящих объектов для объекта XMLList, содержащих инструкции обработки с данным именем. Если параметры не указаны, метод перечисляет все нижестоящие объекты объекта XMLList, содержащего инструкции по обработке.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/processingInstructions()"><linktext>XML.processingInstructions()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	Проверяет, находится ли свойство p в наборе свойств, которые можно итерировать в операторе for.. in, примененном к объекту XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если это свойство можно итерировать в операторе <codeph>for.. in</codeph>, выбирается значение <codeph>true</codeph>; в противном случае указывается значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Индекс проверяемого свойства.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Проверяет, находится ли <codeph>p</codeph> в наборе свойств, которые можно итерировать в операторе <codeph>for.. in</codeph>, примененном к объекту XMLList. Значение <codeph>true</codeph> присваивается только в том случае, когда параметр <codeph>toNumber(p)</codeph>больше или равен 0 и не превышает длины объекта XMLList. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:text"><apiName>text</apiName><shortdesc>
	Вызывает метод text() каждого объекта XML и возвращает объект XMLList, содержащий результаты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Возвращает объект XMLList всех свойств XML объекта XMLList, представляющих текстовые узлы XML.
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Вызывает метод <codeph>text()</codeph> каждого объекта XML и возвращает объект XMLList, содержащий результаты.
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/text()"><linktext>XML.text()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toString"><apiName>toString</apiName><shortdesc>
	Возвращает строковое представление всех объектов XML в объекте XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает строковое представление всех объектов XML в объекте XMLList. Правила этого преобразования зависят от наличия простого или сложного содержимого в объекте XML:
	
	<ul>
		<li>Если объект XML имеет простое содержимое, <codeph>toString()</codeph> возвращает строковое содержимое объекта XML, за исключением следующих компонентов: начального тега, атрибутов, объявлений пространства имен и конечного тега.</li> 
	</ul>
	
	<ul>
		<li> Если объект XML имеет сложное содержимое, <codeph>toString()</codeph> возвращает строку в формате XML, представляющую весь объект XML, включая начальный тег, атрибуты, объявления пространства имен и конечный тег.</li>
	</ul>
	
	<p>Чтобы каждый раз возвращать весь объект XML, воспользуйтесь методом <codeph>toXMLString()</codeph>.</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> В следующем примере показано, что возвращает метод <codeph>toString()</codeph>, когда объект XML имеет простое содержимое:
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> В следующем примере показано, что возвращает метод <codeph>toString()</codeph>, когда объект XML имеет сложное содержимое:
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XMLList/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	Возвращает строковое представление всех объектов XML в объекте XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает строковое представление всех объектов XML в объекте XMLList. В отличие от метода <codeph>toString()</codeph> метод <codeph>toXMLString()</codeph> всегда возвращает начальный тег, атрибуты и конечный тег объекта XML независимо от того, имеет ли объект XML простое или сложное содержимое. (Метод <codeph>toString()</codeph> приводит к удалению этих компонентов в объектах XML, имеющих простое содержимое.)
	
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	Возвращает объект XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Возвращает текущий объект XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает объект XMLList. 
	
	</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:Error"><apiName>Error</apiName><shortdesc>
 Класс Error содержит информацию об ошибке, возникшей в сценарии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Исключение Error создается, когда в сценарии происходит ошибка.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Error содержит информацию об ошибке, возникшей в сценарии. Когда при разработке приложений на языке ActionScript 3.0 скомпилированный код выполняется в отладочной версии Flash Player, появляется диалоговое окно с исключениями типа Error или подкласса, помогающее устранить ошибки кода. Объект Error создается с помощью функции конструктора <codeph>Error</codeph>. Как правило, новый объект Error создается из кодового блока <codeph>try</codeph>, данные из которого поступают в кодовый блок <codeph>catch</codeph> или <codeph>finally</codeph>.
 <p>Кроме того, можно создать подкласс класса Error и генерировать экземпляры этого подкласса.</p>
 
 </apiDesc><example conref="examples\ErrorExample.as"> В следующем примере используется класс <codeph>ErrorExample</codeph>, на примере которого демонстрируется процесс генерации пользовательской ошибки. Это можно сделать, выполнив следующие действия:
 <ol>
     <li>Объявляется локальная переменная <codeph>nullArray</codeph> типа Array, но обратите внимание, что новый объект Array никогда не создается.</li>
     <li>Конструктор пытается загрузить значение в неинициализированный массив методом <codeph>push()</codeph> в сегменте кода для обработки ошибок, который перехватывает пользовательскую ошибку с помощью класса <codeph>CustomError</codeph>, который является расширением класса <codeph>Error</codeph>.</li>
     <li>При создании класса CustomError конструктор регистрирует его, а затем выдает сообщение об ошибке с помощью выражения <codeph>trace()</codeph>. </li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    public class ErrorExample extends Sprite 
    {
        private var nullArray:Array;
        public function ErrorExample() 
        {
            try 
            {
                nullArray.push("item");
            }
            catch(e:Error) 
            {
                throw new CustomError("nullArray is null");
            }
        }
    }
}

class CustomError extends Error 
{
    public function CustomError(message:String) 
    {
        super(message);
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Error:Error"><apiName>Error</apiName><shortdesc>
	 Создает новый объект Error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Строка, связанная с объектом Error; этот параметр является необязательным. 
     </apiDesc></apiParam><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Ссылочный номер, связываемый с конкретным сообщением об ошибке.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Создает новый экземпляр объекта Error с заданным сообщением об ошибке.
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Создает новый объект Error. Если указано <codeph>message</codeph>, его значение присваивается свойству <codeph>Error.message</codeph> объекта.
	 
	 
	 </apiDesc><example conref="examples\Error.1.as"> В следующем примере создается новый объект Error <codeph>err</codeph>, а затем с помощью конструктора <codeph>Error()</codeph> строка <codeph>New Error Message</codeph> («Новое сообщение об ошибке») присваивается <codeph>err</codeph>.
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message
</codeblock></example></apiConstructorDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try.. catch.. finally</linktext></link></related-links></apiConstructor><apiOperation id="Error:getStackTrace"><apiName>getStackTrace</apiName><shortdesc>
	 Возвращает стек вызовов для ошибки в виде строки при конструировании ошибки (только для отладочных версий Flash Player и AIR Debug Launcher (ADL); возвращает null, если не используются отладочные версии Flash Player или ADL).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, call stack
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строковое представление списка вызовов.
	 
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Возвращает список вызовов для ошибки в удобочитаемом виде.
	 
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает стек вызовов для ошибки в виде строки при конструировании ошибки (только для отладочных версий Flash Player и AIR Debug Launcher (ADL); возвращает <codeph>null</codeph>, если не используются отладочные версии Flash Player или ADL). Как показано в следующем примере, первая строка возвращаемого значения представляет собой строковое представление объекта исключения, вслед за которой указываются элементы трассировки стека.
	 
	 <codeblock>
	 TypeError: null cannot be converted to an object
	     at com.xyz.OrderEntry.retrieveData(OrderEntry.as:995)
	     at com.xyz.OrderEntry.init(OrderEntry.as:200)
	     at com.xyz.OrderEntry.$construct(OrderEntry.as:148)
   	 </codeblock>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Error:toString"><apiName>toString</apiName><shortdesc>
	
	Возвращает строку Error по умолчанию или значение, содержащееся в свойстве Error.message, если оно определено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.toString, toString
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Сообщение об ошибке.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Возвращает сообщение об ошибке либо слово «Error», если сообщение не определено.
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	
	Возвращает строку <codeph>Error</codeph> по умолчанию или значение, содержащееся в свойстве <codeph>Error.message</codeph>, если оно определено.
	
    </apiDesc><example conref="examples\Error.toString.1.as"> В следующем примере создается новый объект Error <codeph>err</codeph>, а затем с помощью конструктора <codeph>Error()</codeph> строка <codeph>New Error Message </codeph> («Новое сообщение об ошибке») присваивается <codeph>err</codeph>. В итоге, свойству <codeph>message</codeph> присваивается значение <codeph>Another New Error Message</codeph> («Еще одно новое сообщение об ошибке»), которое заменяет значение <codeph>New Error Message</codeph> («Новое сообщение об ошибке»).
 
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message

err.message = "Another New Error Message";
trace(err.toString());    // Error: Another New Error Message
</codeblock></example></apiOperationDetail><related-links><link href="#Error/message"><linktext>Error.message</linktext></link><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try.. catch.. finally</linktext></link></related-links></apiOperation><apiValue id="Error:message"><apiName>message</apiName><shortdesc>
	 Содержит сообщение, связанное с объектом Error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.message, message
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Содержит сообщение об ошибке, связанное с экземпляром Error.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Содержит сообщение, связанное с объектом Error. По умолчанию в качестве значения этого свойства выбрано <codeph>Error</codeph>. Свойство <codeph>message</codeph> можно указать при создании объекта Error, передав строку ошибки функции конструктора <codeph>Error</codeph>.
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try.. catch.. finally</linktext></link></related-links></apiValue><apiValue id="Error:name"><apiName>name</apiName><shortdesc>
	  Содержит имя объекта Error.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Имя экземпляра Error.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	  Содержит имя объекта Error. По умолчанию в качестве значения этого свойства выбрано <codeph>Error</codeph>.
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try.. catch.. finally</linktext></link></related-links></apiValue><apiValue id="Error:errorID:get"><apiName>errorID</apiName><shortdesc>
     Содержит номер ссылки, связанный с конкретным сообщением об ошибке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.errorID, errorID
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Содержит номер ошибки.
     
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Содержит номер ссылки, связанный с конкретным сообщением об ошибке. Для пользовательского объекта Error это число является значением параметра <codeph>id</codeph>, представленным в конструкторе.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:TypeError"><apiName>TypeError</apiName><shortdesc>
 Исключение TypeError возникает, если фактический тип операнда отличается от ожидаемого типа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, TypeError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 Исключение TypeError возникает, если фактический тип операнда отличается от ожидаемого типа. 
 <p>
 Кроме того, оно создается в следующих случаях:
  <ul>
  <li>Фактический параметр функции или метода не удается принудительно привязать к типу формального параметра.</li>
  <li>Переменной присваивается значение, которое невозможно привязать к типу переменной.</li>
  <li>Правая сторона оператора <codeph>is</codeph> или <codeph>instanceof</codeph> не принадлежит действительному типу.</li>
  <li>Ключевое слово <codeph>super</codeph> используется неправомерно.</li>
  <li>При поиске свойства найдено более одной привязки, и из-за этого результаты противоречивы.</li>
  <li>Метод инициирован по отношению к несовместимому объекту. Например, исключение TypeError создается, если метод класса RegExp «прививается» на родовой объект, а затем инициируется.</li>
 </ul>
 </p>
 
 </apiDesc><example conref="examples\TypeErrorExample.as"> В следующем примере показано, как генерируется и обрабатывается исключение TypeError в операторе <codeph>try.. catch</codeph>. 
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class TypeErrorExample extends Sprite {
        public function TypeErrorExample() {
            try {
                var child:Object = new Object();
                addChild(DisplayObject(child));
            }
            catch(e:TypeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#is"><linktext>оператор is</linktext></link><link href="operators.html#instanceof"><linktext>оператор instanceof</linktext></link><link href="statements.html#super"><linktext>инструкция super</linktext></link><link href="#RegExp"><linktext>Класс RegExp</linktext></link></related-links><apiConstructor id="TypeError:TypeError"><apiName>TypeError</apiName><shortdesc>
	 Создает новый объект TypeError.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Содержит сообщение, связанное с объектом TypeError. 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект TypeError.
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:arguments"><apiName>arguments</apiName><shortdesc>
 Объект arguments используется для хранения аргументов функции и доступа к ним.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Объект arguments используется для хранения аргументов функции и доступа к ним.
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Объект arguments используется для хранения аргументов функции и доступа к ним. В теле функции объект arguments можно вызывать с помощью переменной локальных аргументов.
 <p>
 Аргументы сохраняются как элементы массива: доступ к первому из них выполняется по имени <codeph>arguments[0]</codeph>, ко второму – по имени <codeph>arguments[1]</codeph> и т.д. Свойство <codeph>arguments.length</codeph> означает количество аргументов, переданных функции. Количество переданных аргументов может отличаться от количества, объявленного функцией.
 </p>
 <p>
 В отличие от предыдущих версий ActionScript в ActionScript 3.0 нет свойства <codeph>arguments.caller</codeph>. Чтобы получить ссылку на функцию, которая названа текущей, необходимо передать ссылку на эту функцию в виде аргумента. Случай применения этого метода см. в примере, относящемся к свойству <codeph>arguments.callee</codeph>.
 </p>
 <p>ActionScript 3.0 включает новое ключевое слово <codeph>...(rest)</codeph>, которое рекомендуется использовать вместо класса arguments.</p>
 
 </apiDesc><example conref="examples\ArgumentsExample.as"> В следующем примере показано использование различных свойств <codeph>arguments</codeph> (например, <codeph>callee</codeph> и <codeph>length</codeph>).
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        public function ArgumentsExample() {
                println("Hello World");
        }
        
        public function println(str:String):void {
            trace(arguments.callee == this.println); // true
            trace(arguments.length);                 // 1
            trace(arguments[0]);                     // Hello World
            trace(str);                                // Hello World
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#..._(rest)_parameter"><linktext>...(rest)</linktext></link><link href="#Function"><linktext>Функция</linktext></link></related-links><apiValue id="arguments:callee"><apiName>callee</apiName><shortdesc>
	 Ссылка на функцию, выполняемую в настоящий момент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Function</apiValueClassifier><apiTipTexts><apiTipText>Ссылка на функцию, выполняемую в настоящий момент.
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ссылка на функцию, выполняемую в настоящий момент.
	 
	 </apiDesc><example conref="examples\arguments.callee.1.as"> В следующем коде показано, как получить ссылку на функцию, которая вызывает функцию <codeph>secondFunction()</codeph>. Функции <codeph>firstFunction()</codeph> присвоен логический аргумент <codeph>true</codeph>, указывающий на то, что <codeph>secondFunction()</codeph> успешно вызывает <codeph>firstFunction()</codeph>, и предотвращающий появление бесконечного цикла поочередного вызова функциями друг друга.
  
 <p>Поскольку параметру <codeph>callSecond</codeph> присвоено значение <codeph>true</codeph>, <codeph>firstFunction()</codeph> вызывает <codeph>secondFunction()</codeph> и передает себе ссылку в качестве единственного аргумента. Функция <codeph>secondFunction()</codeph> получает аргумент и сохраняет его с помощью параметра <codeph>caller</codeph>, который относится к типу данных Function. В <codeph>secondFunction()</codeph> используется параметр <codeph>caller</codeph> для вызова функции <codeph>firstFunction</codeph>, но на этот раз аргументу <codeph>callSecond</codeph> присваивается значение <codeph>false</codeph>.</p>
 <p>Когда в ходе выполнения возвращается <codeph>firstFunction()</codeph>, выполняется выражение <codeph>trace()</codeph>, поскольку <codeph>callSecond</codeph> имеет значение <codeph>false</codeph>.</p>
<codeblock>
  package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        private var count:int = 1;
        
        public function ArgumentsExample() {
            firstFunction(true);
        }

        public function firstFunction(callSecond:Boolean) {
            trace(count + ": firstFunction");
            if(callSecond) {
                secondFunction(arguments.callee);
            }
            else {
                trace("CALLS STOPPED");
            }
        }

        public function secondFunction(caller:Function) {
            trace(count + ": secondFunction\n");
            count++;
            caller(false);
        }        
    }
} 
</codeblock></example></apiValueDetail></apiValue><apiValue id="arguments:length"><apiName>length</apiName><shortdesc>
	 Число аргументов, переданных функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Число параметров, переданных функции.
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Число аргументов, переданных функции. Оно может быть выше или ниже объявленного функцией.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:String"><apiName>String</apiName><shortdesc>
 Класс String является типом данных, представляющим строку символов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс String является типом данных, представляющим строку символов. Класс String обладает методами и свойствами, позволяющими оперировать типами элементарных строковых значений. Значение любого объекта можно преобразовать в объект типа данных String с помощью функции <codeph>String()</codeph>. 
 <p> 
 Все методы класса String, кроме <codeph>concat()</codeph>, <codeph>fromCharCode()</codeph>, <codeph>slice()</codeph> и <codeph>substr()</codeph>, являются универсальными. Это означает, что они вызывают <codeph>toString()</codeph> перед выполнением операций и что их можно использовать по отношению к другим объектам, не относящимся к классу String. 
 </p><p>
 Поскольку все индексы строк начинаются с нуля, индекс последнего символа любой строки <codeph>x</codeph> равняется <codeph>x.length - 1</codeph>.
 </p><p>
 Можно вызвать любой метод класса String. При этом для создания новой строковой переменной можно воспользоваться методом конструктора <codeph>new String()</codeph> или просто присвоить строковое литеральное значение. В отличие от предыдущих версий ActionScript не имеет значения, используется ли конструктор, глобальная функция или просто присваивается значение строкового литерала. Следующие строки кода эквивалентны:
 </p>
 <codeblock rev="3.0">
 var str:String = new String("foo");
 var str:String = "foo";
 var str:String = String("foo");</codeblock>
 <p>При выборе для строковой переменной значения <codeph>undefined</codeph> Adobe<sup>®</sup> Flash<sup>®</sup> Player принудительно заменяет значение <codeph>undefined</codeph> значением <codeph>null</codeph>. Поэтому выражение:</p>
 <pre>
 var s:String = undefined;</pre>
 устанавливает значение <codeph>null</codeph> вместо <codeph>undefined</codeph>. Воспользуйтесь функцией <codeph>String()</codeph>, если необходимо использовать значение <codeph>undefined</codeph>.
 </apiDesc><example conref="examples\StringExample.as"> В следующем примере классы StringExample и StringHelper используются для того, чтобы продемонстрировать порядок применения различных методов класса String. Это можно сделать, выполнив следующие действия:
 <ol>
    <li>Конструктор для StringExample объявляет несколько локальных экземпляров String, которые инициализируются с помощью различных строк и нового объекта StringHelper.</li>
    <li>Класс StringHelper имеет ряд методов.
    <ul>
        <li><codeph>replace()</codeph>: вызывает методы <codeph>split()</codeph> и <codeph>join()</codeph> класса String, чтобы удалить подстроку строки, переданную с новой подстрокой.</li>
        <li><codeph>trim()</codeph>: вызывает одновременно методы <codeph>trimBack()</codeph> и <codeph>trimFront()</codeph> с помощью переданных строк и возвращает обновленную строку.</li>
        <li><codeph>trimFront()</codeph>: рекурсивно удаляет все символы, которые совпадают с параметром <codeph>char</codeph>, начиная с переднего конца строки назад вплоть до первого символа в строке, не совпадающего с параметром <codeph>char</codeph>, и возвращает обновленную строку.</li>
        <li><codeph>trimBack()</codeph>: рекурсивно удаляет все символы, которые совпадают с параметром <codeph>char</codeph>, начиная с заднего конца строки вперед вплоть до последнего символа в строке, не совпадающего с параметром <codeph>char</codeph> и возвращает обновленную строку.</li>
        <li><codeph>stringToCharacter()</codeph>: возвращает первый символ переданной строки.</li>
    </ul>
  </li>
    <li>Затем создаются три строки с помощью объявленных строковых переменных с вызовом метода <codeph>replace()</codeph>, использованного для создания второй строки, и метода <codeph>trim()</codeph> для создания третьей строки.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class StringExample extends Sprite {
        public function StringExample() {
            var companyStr:String = new String("     Company X");
            var productStr:String = "Product Z Basic     ";
            var emptyStr:String = " ";
            var strHelper:StringHelper = new StringHelper();

            var companyProductStr:String = companyStr + emptyStr + productStr;
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Basic     '

            companyProductStr = strHelper.replace(companyProductStr, "Basic", "Professional");
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Professional     '

            companyProductStr = strHelper.trim(companyProductStr, emptyStr);
            trace("'" + companyProductStr + "'");    // 'Company X Product Z Professional'
        }
    }
}

class StringHelper {
    public function StringHelper() {
    }

    public function replace(str:String, oldSubStr:String, newSubStr:String):String {
        return str.split(oldSubStr).join(newSubStr);
    }

    public function trim(str:String, char:String):String {
        return trimBack(trimFront(str, char), char);
    }

    public function trimFront(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(0) == char) {
            str = trimFront(str.substring(1), char);
        }
        return str;
    }

    public function trimBack(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(str.length - 1) == char) {
            str = trimBack(str.substring(0, str.length - 1), char);
        }
        return str;
    }

    public function stringToCharacter(str:String):String {
        if (str.length == 1) {
            return str;
        }
        return str.slice(0, 1);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="package.html#String()"><linktext>Функция String</linktext></link></related-links><apiConstructor id="String:String"><apiName>String</apiName><shortdesc>
  Создает новый объект String, инициализированный для заданной строки.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, new string, new, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Начальное значение нового объекта String.
  
  </apiDesc></apiParam></apiConstructorDef><apiDesc>
  Создает новый объект String, инициализированный для заданной строки.
  
  <p>
  <b>Примечание.</b> Поскольку строковые литералы используют меньше служебной информации, чем объекты String, и их обычно проще применять, необходимо использовать строковые литералы вместо класса String, если нет весомой причины выбрать объект String вместо строкового литерала.
  </p>
  
  </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="String:AS3:charAt"><apiName>charAt</apiName><shortdesc>
     Возвращает символ в позиции, заданной параметром  индекса.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charat, charat, character at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Символ в указанном индексе. Пустая строка, если указанный индекс выходит за пределы диапазона индексов для этой строки.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число, указывающее на позицию символа в строке. Первый символ обозначается <codeph>0</codeph>, а последний символ – <codeph>my_str.length - 1</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает символ в позиции, заданной параметром <codeph> индекса</codeph>. Если <codeph>index</codeph> не является числом от 0 до <codeph>string.length - 1</codeph>, возвращается пустая строка.
	 <p>
	 Этот метод напоминает <codeph>String.charCodeAt()</codeph>, за исключением того, что возвращаемое значение является символом, а не 16-разрядным целочисленным кодом символа.
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charCodeAt()"><linktext>charCodeAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:charCodeAt"><apiName>charCodeAt</apiName><shortdesc>
	 Возвращает числовой код символа Юникод для символа в заданном индексе.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charcodeat, charcodeat, character code at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Числовой код символа Юникод для символа в заданном индексе. Или <codeph> NaN</codeph>, если индекс выходит за пределы диапазона строковых индексов.
	 <p><xref href="" scope="external"/> </p>		 
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число, указывающее на позицию символа в строке. Первый символ обозначается <codeph>0</codeph>, а последний символ – <codeph>my_str.length - 1</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает числовой код символа Юникод для символа в заданном <codeph>индексе</codeph>. Если <codeph>индекс</codeph> не является числом от 0 до <codeph>string.length - 1</codeph>, возвращается <codeph>NaN</codeph>.
	 <p>
	 Этот метод напоминает метод <codeph>String.charAt(),</codeph>, за исключением того, что возвращаемое значение является 16-разрядным целочисленным кодом символа, а не фактическим символом.
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charAt()"><linktext>charAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:concat"><apiName>concat</apiName><shortdesc>
	 Добавляет переданные аргументы к концу объекта String, при необходимости преобразуя их в строки, затем возвращает получившуюся строку.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новая строка, состоящая из этой строки и указанных параметров.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Необходимо добавить 0 или более параметров.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Добавляет переданные аргументы к концу объекта String, при необходимости преобразуя их в строки, затем возвращает получившуюся строку. Первоначальное значение исходного объекта String остается неизменным.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:fromCharCode"><apiName>fromCharCode</apiName><shortdesc>
	Возвращает строку с символами, представленными в параметрах кодами Юникод.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.fromcharcode, fromcharcode, from character code
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Строковое значение указанных кодов Юникод.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>charCodes</apiItemName><apiType value="restParam"/><apiDesc>Серия целых десятичных чисел, представляющих собой значения Юникод.
	<p><xref href="" scope="external"/> </p>	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Возвращает строку с символами, представленными в параметрах кодами Юникод.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 Выполняет поиск строки и возвращает позицию первого вхождения параметра val, обнаруженного после элемента startIndex (включая этот элемент), в пределах вызывающей строки.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.indexof, indexof, index
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Индекс первого вхождения указанной подстроки или <codeph>-1</codeph>.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Искомая подстрока.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Необязательное целое число, указывающее начальный индекс поиска.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет поиск строки и возвращает позицию первого вхождения параметра <codeph>val</codeph>, обнаруженного после элемента <codeph>startIndex</codeph> (включая этот элемент), в пределах вызывающей строки. Этот индекс начинается с нуля. Это означает, что первый символ в строке имеет индекс 0, а не 1. Если значение <codeph>val</codeph> не найдено, метод возвращает «-1».
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/lastIndexOf()"><linktext>lastIndexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 Выполняет поиск строки справа налево и возвращает индекс последнего вхождения параметра val, обнаруженного перед элементом startIndex.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.lastindexof, lastindexof, last index of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Позиция последнего вхождения указанной подстроки или «-1», если она не найдена.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Искомая строка.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7FFFFFFF</apiData><apiDesc>Необязательное целое число, указывающее начальный индекс, с которого начинается поиск <codeph>val</codeph>. Значение по умолчанию – максимально допустимое значение индекса. Если <codeph>startIndex</codeph> не указан, поиск начинается с последнего элемента в строке.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет поиск строки справа налево и возвращает индекс последнего вхождения параметра <codeph>val</codeph>, обнаруженного перед элементом <codeph>startIndex</codeph>. Этот индекс начинается с нуля. Это означает, что первый символ имеет индекс 0, а последний – <codeph>string.length - 1</codeph>. Если значение <codeph>val</codeph> не найдено, метод возвращает <codeph>-1</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/indexOf()"><linktext>indexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:localeCompare"><apiName>localeCompare</apiName><shortdesc>
	 Сравнивает порядок сортировки двух или более строк и возвращает результат сравнения в виде целого числа.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Значение 0, если строки равны. В противном случае отрицательное целое число, если исходная строка предшествует аргументу строки, или положительное целое число, если аргумент строки предшествует исходной строке. В обоих случаях абсолютное значение числа выражает разницу между двумя строками.
	  
	  </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Сравниваемая строковая величина.
     </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>Необязательный набор дополнительных сравниваемых строк.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Сравнивает порядок сортировки двух или более строк и возвращает результат сравнения в виде целого числа. Хотя этот метод предназначен для проведения регионального сравнения, реализация ActionScript 3.0 не приводит к появлению другого результата при сравнении других строк, например, операторов равенства (<codeph>==</codeph>) или неравенства (<codeph>! =</codeph>). Если строки эквивалентны, возвращается значение 0. Если исходное строковое значение предшествует строковому значению, указанному в параметре <codeph>other</codeph>, возвращается отрицательное целое число, абсолютное значение которого отражает количество символов, разделяющих два этих строковых значения. Если исходное строковое следует за параметром <codeph>other</codeph>, возвращается положительное целое число, абсолютное значение которого отражает количество символов, разделяющих два этих строковых значения.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:match"><apiName>match</apiName><shortdesc>
	Сопоставляет заданный pattern со строкой.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
		 var myPattern:RegExp = /sh./g;  
			// The dot (.) matches any character.
	 var str:String = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: she,sho
	
		 myPattern = /sh./gi;  
			// This time, make it case insensitive (with the i flag).
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: She,she,sho	
	
		 myPattern = RegExp = new RegExp("sh(.)", "gi")  
			// Note the grouping parentheses.
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
		// Output: She,e,she,e,sho,o
		 	// Note that the result array is 
			// [[She,e],[she,e],[sho,o]] 
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив строк, состоящий из всех подстрок в строке, которая совпадает с заданным <codeph>шаблоном</codeph>.
	
	<p>Если <codeph>шаблон</codeph> является регулярным выражением, необходимо установить в нем флаг <codeph>g</codeph> (global), чтобы вернуть массив с более, чем одной совпадающей подстрокой: </p>
	
	<ul>
	
		<li>Если флаг <codeph>g</codeph> (global) <i>не</i> установлен, возвращаемый массив будет содержать не более одного совпадения, а свойство <codeph>lastIndex</codeph> регулярного оператора останется неизменным.</li> 
	
		<li>Если флаг <codeph>g</codeph> (global) <i>установлен</i>, метод начинает поиск с начала строки (позиция в индексе 0). Если совпадающая подстрока является пустой строкой (это может происходить в регулярном выражении типа <codeph>/x~~/</codeph>), метод добавляет пустую строку в массив совпадений, а затем продолжает поиск со следующей позиции индекса. Свойство <codeph>lastIndex</codeph> регулярного выражения приравнивается 0 после завершения выполнения метода. </li>
	
	</ul>
	
	<p>Если совпадение не найдено, метод возвращает <codeph>null</codeph>. Если значение не передано (или является неопределенным) как параметр <codeph>pattern</codeph>, метод возвращает <codeph>null</codeph>.</p>
	
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Искомый шаблон, в роли которого может выступать любой тип объекта. Как правило, это строка или регулярное выражение. Если <codeph>pattern</codeph> не является регулярным выражением или строкой, то перед выполнением этот метод преобразует его в строку. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Сопоставляет заданный <codeph>pattern</codeph> со строкой.
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:replace"><apiName>replace</apiName><shortdesc>
	Сопоставляет заданный шаблон со строкой и возвращает новую строку, в которой первое совпадение шаблона заменяется содержимым, заданным параметром repl.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строка, которая получается в результате. Учтите, что исходная строка остается неизменной.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Искомый шаблон, в роли которого может выступать любой тип объекта. Как правило, это строка или регулярное выражение. Если указать параметр <codeph>pattern</codeph>, который представляет собой любой объект, отличающийся от строки или регулярного выражения, метод <codeph>toString()</codeph> применяется к параметру, а метод <codeph>replace()</codeph> выполняется с использованием итоговой строки в качестве параметра <codeph>pattern</codeph>. 
	
	</apiDesc></apiParam><apiParam><apiItemName>repl</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Как правило, строка, которая вставляется вместо совпадающего содержимого. Однако в качестве этого параметра можно также указать функцию. Если указать функцию, строка, возвращаемая этой функцией, вставляется вместо совпадающего содержимого.
	
	<p>Если в качестве параметра <codeph>repl</codeph> указывается строка, а в качестве регулярного выражения – параметр <codeph>pattern</codeph>, можно воспользоваться следующими специальными <i>кодами замены $</i> в параметре <codeph>repl</codeph>:</p>
	
	<adobetable class="innertable">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<tgroup cols="2"><thead><row><entry NOWRAP="true">$ Code
		</entry><entry>Замещающий текст
		</entry></row></thead><tbody><row>
	
		<entry><codeph>$$</codeph>
		</entry>
	
		<entry><codeph>$</codeph>
		</entry>
	
	</row><row>
	
		<entry><codeph>$&amp;</codeph>
		</entry>
	
		<entry>Совпавшая подстрока.
		</entry>
	
	</row><row>
	
		<entry><codeph>$`</codeph>	
		</entry>
	
		<entry>Часть строки, предшествующая совпавшей подстроке. Учтите, что в этом коде используется прямая левая одинарная кавычка (`), а не одинарный символ прямой кавычки (') или одинарный символ левой фигурной кавычки ().
		</entry>
	
	</row><row>
	
		<entry><codeph>$'</codeph>
		</entry>
	
		<entry>Часть строки, которая следует за совпавшей подстрокой. Учтите, что в этом коде используется прямая одинарная кавычка. (').
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>n</i>
		</entry>
	
		<entry>Зарегистрированное совпадение группы в скобках <i>n</i>, где <i>n</i> — это цифра от 1 до 9, а за <codeph>$</codeph><i>n</i> не следует десятичное число. 
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>nn</i>
		</entry>
	
		<entry>Зарегистрированное совпадение группы в скобках <i>nn</i>, где <i>nn</i> десятичное двузначное число (от 01 до 99). Если запись <i>nn</i> не определена, в качестве замещающего текста используется пустая строка. 
		</entry>
	
	</row></tbody></tgroup></adobetable>
	
	<p>Например, ниже показано применение замещающих кодов <codeph>$2</codeph> и <codeph>$1</codeph>, представляющих первую и вторую зарегистрированные совпавшие группы:</p>
	
	<codeblock>var str:String = "flip-flop";
	var pattern:RegExp = /(\w+)-(\w+)/g;
	trace(str.replace(pattern, "$2-$1")); // flop-flip</codeblock>
	
	<p>Если в качестве параметра <codeph>repl</codeph> указана функция, метод <codeph>replace()</codeph>передает этой функции следующие параметры:
	</p>
	
	<ul>
	
		<li>
		Совпадающая часть строки.
		</li>
	
		<li>
		Любые зарегистрированные совпадения групп в скобках предоставляются в качестве следующих аргументов. Количество переданных таким образом аргументов варьируется в зависимости от количества совпадений в скобках. Количество совпадений в скобках можно определить, проверив значение параметра <codeph>arguments.length - 3</codeph> в коде функции.
		</li>
	
		<li>
		Позиция в индексе в строке, где начинается совпадение.
		</li>
	
		<li>
		Строка полностью.
		</li>
	
	</ul>
	
	<p>Например, рассмотрите один из следующих вариантов.</p>
	
	<codeblock>
	var str1:String = "abc12 def34";
	var pattern:RegExp = /([a-z]+)([0-9]+)/;
	var str2:String = str1.replace(pattern, replFN);
	trace (str2);   // 12abc 34def
	
	function replFN():String {
		return arguments[2] + arguments[1];
	}</codeblock>
	
	
	<p>Вызов метода <codeph>replace()</codeph> использует функцию в качестве параметра <codeph>repl</codeph>. Регулярное выражение (<codeph>/([a-z]([0-9]/g</codeph>) совпадает дважды. В первый раз шаблон совпадает с подстрокой <codeph>abc12</codeph>, а функции передается следующий список аргументов:
	</p>
	
	<codeblock>
	{"abc12", "abc", "12", 0, "abc12 def34"}</codeblock>
	
	
	<p>Во второй раз шаблон совпадает с подстрокой <codeph>def23</codeph>, а функции передается следующий список аргументов:
	</p>
	
	<codeblock>
	{"def34", "def", "34", 6, "abc123 def34"}</codeblock>
	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Сопоставляет заданный <codeph>шаблон</codeph> со строкой и возвращает новую строку, в которой первое совпадение <codeph>шаблона</codeph> заменяется содержимым, заданным параметром <codeph>repl</codeph>. Параметр <codeph>pattern</codeph> может быть представлен строкой или регулярным выражением. Параметр <codeph>repl</codeph> может быть строкой или функцией; если он является функцией, возвращаемая функцией строка вставляется вместо совпадения. Исходная строка не изменяется.
	
	<p>В следующем примере заменяется только первый экземпляр «sh» (зависит от регистра). </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seashore.</codeblock>
	
	<p>В следующем примере заменяются все экземпляры «sh» (зависит от регистра), поскольку в регулярном выражении установлен флаг <codeph>g</codeph> (global): </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/g;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seaschore.</codeblock>
	
	<p>В следующем примере заменяются все экземпляры «sh», поскольку в регулярном выражении установлен флаг <codeph>g</codeph> (global), а совпадения <i>не</i> зависят от регистра, так как установлен флаг <codeph>i</codeph> (ignoreCase):</p>
	
	<codeblock>
	var myPattern:RegExp = /sh/gi;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // sche sells seaschells by the seaschore.</codeblock>
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:search"><apiName>search</apiName><shortdesc>
	Выполняет поиск заданного шаблона и возвращает индекс первой совпадающей подстроки.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
	 var str:String = "She sells seashells by the seashore.";
		 var myPattern:RegExp = /sh/;  
			// This time, make it case insensitive (with the i flag).
	 trace(str.match(myPattern));  
	
		// Output: 13
		// (The substring match starts at character position 13.)
	
		 var myPattern:RegExp = /sh/i;
	 trace(str.match(myPattern));  
	
		// Output: 0
		// (The substring match starts at character position 0 
			//   -- the first character of the source string.)
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Индекс первой совпадающей подстроки или <codeph>-1</codeph>, если совпадений не найдено. Учтите, что если строка начинается нулевого индекса, первый символ строки имеет индекс 0, а последний – <codeph>string.length - 1</codeph>. 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>Искомый шаблон, в роли которого может выступать любой тип объекта. Как правило, это строка или регулярное выражение. Если <codeph>pattern</codeph> не является регулярным выражением или строкой, то перед выполнением этот метод преобразует его в строку. Учтите, что если регулярное выражение указано, метод игнорирует глобальный флаг (g) регулярного выражения и свойство <codeph>lastIndex</codeph> (оставляя его без изменений). Если передать неопределенное значение (или не передавать значение), метод возвращает <codeph>-1</codeph>.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Выполняет поиск заданного <codeph>шаблона</codeph> и возвращает индекс первой совпадающей подстроки. Если совпадающей подстроки нет, метод возвращает <codeph>-1</codeph>.
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:slice"><apiName>slice</apiName><shortdesc>
	 Возвращает строку с символом startIndex и все символы вплоть до символа endIndex (но не включая его).</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Подстрока, основанная на заданных индексах.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Индекс начальной позиции среза, начинающийся с нуля. Если <codeph>startIndex</codeph> – отрицательное число, срез создается справа налево, а последнему символу присваивается значение «-1».
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Целое число, которое больше индекса конечной позиции среза. Символ, индексированный параметром <codeph>endIndex</codeph>, не включен в извлеченную строку. Если параметру <codeph>endIndex</codeph> присвоено отрицательное число, конечная позиция определяется путем отсчета от конца строки, где последний символ имеет позицию «-1». Значение по умолчанию – максимально допустимое значение индекса. Если этот параметр пропустить, используется параметр <codeph>String.length</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строку с символом <codeph>startIndex</codeph> и все символы вплоть до символа <codeph>endIndex</codeph> (но не включая его). Исходный объект String не изменяется. Если параметр <codeph>endIndex</codeph> не указан, то конец подстроки считается концом строки. Если позиция символа, индексированного с помощью параметра <codeph>startIndex</codeph>, совпадает или находится справа от символа, индексированного параметром <codeph>endIndex</codeph>, метод возвращает пустую строку.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/substr()"><linktext>substr()</linktext></link><link href="#String/substring()"><linktext>substring()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:split"><apiName>split</apiName><shortdesc>
	 Преобразует объект String в массив подстрок путем разделения объекта каждый раз, когда встречается заданный параметр delimiter.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.split, split
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив подстрок.
	 
	 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>delimiter</apiItemName><apiType value=""/><apiDesc>Шаблон, который указывает место разделения строки. В роли шаблона может выступать любой тип объекта. Как правило, это строка или регулярное выражение. Если <codeph>delimiter</codeph> не является регулярным выражением или строкой, то метод перед выполнением преобразует его в строку. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>limit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Максимальное количество элементов, включаемых в массив. Максимально допустимое значение является значением по умолчанию. 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует объект String в массив подстрок путем разделения объекта каждый раз, когда встречается заданный параметр <codeph>delimiter</codeph>. 
	 
	 <p>Если параметр <codeph>delimiter</codeph> является регулярным выражением, учитывается только первое совпадение на заданной позиции строки, даже если при отслеживании в обратном порядке на этой позиции найдена совпадающая непустая подстрока. Например:</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "ab";
	 var results:Array = str.split(/a~~?/); // results == ["","b"]
	 
	 results = str.split(/a~~/); // results == ["","b"].)</codeblock>
	 
	 
	 <p>Если параметр <codeph>delimiter</codeph> – это регулярное выражение, содержащее скобки для группы, то при каждом совпадении параметра <codeph>delimiter</codeph> результаты (включая любые неопределенные результаты) группировки в скобках разделены в выходном массиве. Например</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "Thi5 is a tricky-66 example.";
	 var re:RegExp = /(\d+)/;
	 var results:Array = str.split(re);
	     // results == ["Thi","5"," is a tricky-","66"," example."]</codeblock>
	 
	 
	 <p>Если указан параметр <codeph>limit</codeph>, то возвращенный массив будет содержать не больше указанного количества элементов.</p>
     <p>Если <codeph>delimiter</codeph> является пустой строкой, в качестве элемента массива выдается пустое регулярное выражение либо регулярное выражение, которое может соответствовать пустой строке. Каждый отдельный символ в строке выдается в качестве элемента массива.</p>
     
     <p>Если параметр <codeph>delimiter</codeph> не определен, в качестве первого элемента возвращаемого массива включается вся строка. </p>     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/join()"><linktext>Array.join()</linktext></link><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:substr"><apiName>substr</apiName><shortdesc>
	 Возвращает подстроку из символов, начинающихся с заданного элемента startIndex. Длина этой строки определяется параметром len.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substr, substr, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Подстрока, основанная на заданных параметрах.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число, которое указывает на индекс первого символа, который используется для создания подстроки. Если параметру <codeph>startIndex</codeph> присвоено отрицательное число, начальный индекс определяется, начиная с конца строки, где последний символ имеет позицию <codeph>-1</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Количество символов в создаваемой подстроке. Максимально допустимое значение является значением по умолчанию. Если параметр <codeph>len</codeph> не указан, подстрока включает все символы, начиная с <codeph>startIndex</codeph> до конца строки.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает подстроку из символов, начинающихся с заданного элемента <codeph>startIndex</codeph>. Длина этой строки определяется параметром <codeph>len</codeph>. Исходная строка не менялась.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:substring"><apiName>substring</apiName><shortdesc>
	 Возвращает строку из символа, заданного startIndex, и всех символов вплоть до позиции endIndex - 1.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substring, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Подстрока, основанная на заданных параметрах.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число, указывающее на индекс первого символа, который используется для создания подстроки. Действительные значения параметра <codeph>startIndex</codeph> находятся в диапазоне от <codeph>0</codeph> до <codeph>String.length</codeph>. Если в качестве <codeph>startIndex</codeph> выбрано отрицательное значение, используется <codeph>0 </codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Целое число, которое больше индекса последнего символа в извлеченной подстроке. Действительные значения параметра <codeph>endIndex</codeph> лежат в диапазоне от <codeph>0</codeph> до <codeph>String.length</codeph>. Символ с позицией <codeph>endIndex</codeph> не включен в подстроку. Значение по умолчанию – максимально допустимое значение индекса. Если этот параметр пропустить, используется параметр <codeph>String.length</codeph>. Если для этого параметра выбрано отрицательное значение, используется <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строку из символа, заданного <codeph>startIndex</codeph>, и всех символов вплоть до позиции <codeph>endIndex - 1</codeph>. Если параметр <codeph>endIndex</codeph> не указан, используется параметр <codeph>String.length</codeph>. Если значение <codeph>startIndex</codeph> равняется значению <codeph>endIndex</codeph>, метод возвращает пустую строку. Если значение <codeph>startIndex</codeph> превышает значение <codeph> endIndex</codeph>, параметры автоматически заменяются перед выполнением функции. Исходная строка не менялась.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:toLocaleLowerCase"><apiName>toLocaleLowerCase</apiName><shortdesc>
	 Возвращает копию этой строки с преобразованием всех прописных символов в строчные.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия этой строки с преобразованием всех прописных символов в строчные.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает копию этой строки с преобразованием всех прописных символов в строчные. Исходная строка не менялась. Хотя этот метод предназначается для обработки регионального преобразования, реализация ActionScript 3.0 не приводит к результатам, отличным от результатов метода <codeph>toLowerCase()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLocaleUpperCase"><apiName>toLocaleUpperCase</apiName><shortdesc>
	 Возвращает копию этой строки с преобразованием всех строчных символов в прописные.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия этой строки с преобразованием всех строчных символов в прописные.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает копию этой строки с преобразованием всех строчных символов в прописные. Исходная строка не менялась. Хотя этот метод предназначается для обработки регионального преобразования, реализация ActionScript 3.0 не приводит к результатам, отличным от результатов метода <codeph>toUpperCase()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLowerCase"><apiName>toLowerCase</apiName><shortdesc>
	 Возвращает копию этой строки с преобразованием всех прописных символов в строчные.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.tolowercase, tolowercase, to lowercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия этой строки с преобразованием всех прописных символов в строчные.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает копию этой строки с преобразованием всех прописных символов в строчные. Исходная строка не менялась.
	 
	 <p>Этот метод преобразует все символы (не только в диапазоне от A до Z), для которых существуют строчные эквиваленты в Юникоде:</p>
	 
	 <codeblock>
	 var str:String = " JOSÉ BARÇA";
	 trace(str.toLowerCase()); // josé barça</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toUpperCase"><apiName>toUpperCase</apiName><shortdesc>
	 Возвращает копию этой строки с преобразованием всех строчных символов в прописные.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.touppercase, touppercase, to uppercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия этой строки с преобразованием всех строчных символов в прописные.
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает копию этой строки с преобразованием всех строчных символов в прописные. Исходная строка не менялась.
	 
	 <p>Этот метод преобразует все символы (не только в диапазоне от A до Я), для которых существуют прописные эквиваленты в Юникоде:</p>
	 
	 <codeblock>
	 var str:String = "José Barça";
	 trace(str.toUpperCase()); // JOSÉ BARÇA</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Возвращает элементарное значение экземпляра String.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new instance of the String class
	 and then shows that the <code>valueOf</code> method returns 
	 the <i>primitive</i> value, rather than a reference to the new instance.
	 
	 <listing version="2.0">
	 var str:String = new String("Hello World");
	 var value:String = str.valueOf();
	 trace(str instanceof String); // true
	 trace(value instanceof String); // false
	 trace(str === value); // false</listing>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Значение строки.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает элементарное значение экземпляра String. Этот метод разработан для преобразования объекта String в элементарное строковое значение. Поскольку Flash Player автоматически вызывает при необходимости <codeph>valueOf()</codeph>, вызывать этот метод явным образом приходится нечасто.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="String:length:get"><apiName>length</apiName><shortdesc>
	 Целое число, определяющее количество символов в заданном объекте String.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Целое число, определяющее количество символов в заданном объекте String.
	 <p>
	 Поскольку все индексы строк начинаются с нуля, индекс последнего символа любой строки <codeph>x</codeph> равняется <codeph>x.length - 1</codeph>.
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Class"><apiName>Class</apiName><shortdesc>
 Для каждого определения класса в программе создается объект Class.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Для каждого определения класса в программе создается объект Class. Каждый объект Class – это экземпляр класса Class. Объект Class содержит статические свойства и методы класса. Объект класса создает экземпляры класса, когда вызывается с помощью оператора <codeph>new</codeph>.
 
 <p>Некоторые методы, например <codeph>flash.net.getClassByAlias()</codeph>, возвращают объект типа Class. Другие методы (например, <codeph>flash.net.registerClassAlias()</codeph>) могут иметь параметр типа Class. </p>
 <p>Имя класса – это ссылка на объект Class, как показано в данном примере:</p>
 <pre> 
 class Foo {
 }
 </pre> 
 <p>Инструкция <codeph>class Foo{}</codeph> является определением класса, создающим объект Class с именем Foo. Кроме того, инструкция <codeph>new Foo()</codeph> создаст новый экземпляр класса Foo. Результат также будет принадлежать типу Foo.</p>
 <p>Для объявления классов воспользуйтесь инструкцией <codeph>class</codeph>. Объекты Class полезны в случае применения таких расширенных методов, как присвоение классов существующему объекту экземпляра при исполнении (см. раздел «Примеры» ниже).</p>
 <p>Любые статические свойства и методы класса, относящиеся к текущему объекту Class класса. Сам класс при этом объявляет <codeph>прототип</codeph>.</p>
 
 <p>Как правило, объявлять или создавать переменные типа Class вручную не требуется. Однако в следующем коде класс присваивается в качестве свойства общедоступного класса <codeph>circleClass</codeph>, и на это свойство можно ссылаться как на свойство основного класса Library:</p>
 <codeblock>
 package {
  import flash.display.Sprite;
  public class Library extends Sprite {
      
      public var circleClass:Class = Circle;
      public function Library() {
      }
  }
 }
  
 import flash.display.Shape;
 class Circle extends Shape {
  public function Circle(color:uint = 0xFFCC00, radius:Number = 10) {
      graphics.beginFill(color);
      graphics.drawCircle(radius, radius, radius);
  }
 }
 </codeblock>
 
 <p>Другой SWF-файл может загрузить итоговый файл Library.swf, а затем создать экземпляры объектов типа Circle. В следующем примере показан способ получения доступа к ресурсам нижестоящего элемента SWF-файла. (Помимо этого можно выбрать <codeph>flash.utils.getDefnitionByName()</codeph> или импортировать определения заглушек нижестоящего элемента SWF-файла).</p>
 
 <codeblock>
 package {
  import flash.display.Sprite;
  import flash.display.Shape;
  import flash.display.Loader;
  import flash.net.URLRequest;
  import flash.events.Event;
  public class LibaryLoader extends Sprite {
      public function LibaryLoader() {
          var ldr:Loader = new Loader();
          var urlReq:URLRequest = new URLRequest("Library.swf");
          ldr.load(urlReq);
          ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
      }
      private function loaded(event:Event):void {
          var library:Object = event.target.content;
          var circle:Shape = new library.circleClass();
          addChild(circle);
      }
  }
 }
 </codeblock>
 <p>В ActionScript 3.0 можно создавать встроенные классы для внешних ресурсов (например, изображений, звуков или шрифтов), которые компилируются в SWF-файлы. В более ранних версиях ActionScript эти ресурсы связывались с помощью идентификатора связи с методом <codeph>MovieClip.attachMovie()</codeph>. В ActionScript 3.0 каждый встроенный ресурс представлен уникальным встроенным классом ресурсов. Поэтому можно воспользоваться оператором <codeph>new</codeph>, чтобы создать экземпляр связанного класса ресурса, а затем вызвать методы и свойства по отношению к этому ресурсу.</p>
 <p product="flex">Например, при использовании компилятора MXML для создания SWF-файлов встроенный класс будет создаваться следующим образом:</p>
 <codeblock product="flex">
     [Embed(source="bratwurst.jpg")]
     public var imgClass:Class;
 </codeblock>
 <p product="flex">А для создания его экземпляра будет использоваться следующая строка:</p>
 <codeblock product="flex">
     var myImg:Bitmap = new imgClass();
 </codeblock>
 
 </apiDesc><example conref="examples\Class.1.as"> В следующем примере показано, как использовать объекты Class, чтобы отложить до момента выполнения выбор класса, для которого следующим образом создаются экземпляры:
 <ol>
     <li>Объявите два класса как <codeph>ClassA</codeph> и <codeph>ClassB</codeph>. </li>
     <li>Объявите одну переменную типа Class <codeph>classToConstruct</codeph>, а другую типа Boolean <codeph>chooseClassA</codeph>, для которой в данном случае выбрано значение <codeph>true</codeph>. Однако в вашем коде может применяться пользовательское тестовое выражение, устанавливающее значение этой переменной. </li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ClassExample extends Sprite {
        public function ClassExample() {
            var classToConstruct:Class;            
            var classInstance:Object;

            classToConstruct = ClassA;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassA]

            classToConstruct = ClassB;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassB]
        }
    }
}

class ClassA {
}
    
class ClassB {
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>Object.prototype</linktext></link><link href="operators.html#new"><linktext>оператор new</linktext></link></related-links></apiClassifier><apiClassifier id="globalClassifier:Namespace"><apiName>Namespace</apiName><shortdesc>

Класс Namespace содержит методы и свойства, позволяющие задавать пространства имен и работать с ними.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Namespace
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Класс Namespace содержит методы и свойства, позволяющие определять пространства имен объектов XML и работать с ними.

</apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Класс Namespace содержит методы и свойства, позволяющие задавать пространства имен и работать с ними. Существует три сценария применения пространства имен.

<ul>
<li> <b>Пространства имен объектов XML</b>. В пространствах имен префикс пространства имен связан с универсальным идентификатором ресурса (URI), который их определяет. Префикс – это строка, используемая при создании ссылки на пространство имен в объекте XML. Если префикс не определен, когда XML-файл преобразуется в строку, он генерируется автоматически.
</li>

<li> <b>Пространство имен для различения методов</b> Пространства имен могут разграничивать одноименные методы, которым предстоит выполнять разные задачи. Если два метода названы одинаково, но их пространства имен различны, они могут выполнять разные задачи.
</li>

<li> <b>Пространства имен для контроля доступа</b> Пространства имен могут применяться для управления доступом к группе свойств и методов в рамках класса. Если свойства и методы поместить в частное пространство имен, они станут недоступны для любого кода, не имеющего доступа к данному пространству имен. Можно предоставить доступ к группе свойств и методов, передав пространство имен другим классам, методам или функциям.
</li>
</ul>

<p>В этом классе показаны два вида метода конструктора, поскольку каждый из них поддерживает разные параметры.</p>

<p>В этом классе (а также в классах XML, XMLList и QName) реализованы мощные стандарты обработки XML, определенные в сценарии ECMAScript для спецификации XML E4X (ECMA-357, второе издание).</p>

</apiDesc><example conref="examples\NamespaceExample.as"> В следующем примере показано, как работать с пространствами имен, определенными в объектах XML. Это можно сделать, выполнив следующие действия:
 <ol>
    <li>В этом примере определены три объекта Namespace, каждый из которых имеет уникальный URI, определяющий пространство имен.</li>
    <li>В примере определяется переменная XML с именем <codeph>myXML</codeph>, которая присваивается возвращаемому значению <codeph>getRSS()</codeph>. Метод <codeph>getRSS()</codeph> применяется для определения объекта XML, содержащего несколько пространств имен и возврата данного объекта.</li>
    <li>В примере объявляется и оценивается переменная Array путем вызова метода <codeph>parseRSS()</codeph>, которому передается <codeph>myXML</codeph>. В <codeph>parseRSS()</codeph> пространство имен XML по умолчанию определяется как <codeph>rss</codeph>. Переменная XMLList определяется в примере путем присвоения списка объектов <codeph>item</codeph> переменной <codeph>myXML</codeph>. Создается массив, который заполняется данными о различных узлах, входящих в <codeph>myXML.item</codeph>. Затем этот массив возвращается.</li>
    <li>Печать элементов массива выполняется с помощью цикла <codeph>for</codeph> и трех вызовов выражения <codeph>trace()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class NamespaceExample extends Sprite {
        private var rss:Namespace = new Namespace("http://purl.org/rss/1.0/");
        private var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
        private var dc:Namespace  = new Namespace("http://purl.org/dc/elements/1.1/");

        public function NamespaceExample() {
            var myXML:XML = getRSS();
            var rssItems:Array = parseRSS(myXML);
            
            var len:uint = rssItems.length;
            for (var i:uint; i &lt; len; i++) {
                trace(rssItems[i].title);
                trace(rssItems[i].creator);
                trace(rssItems[i].date);
                // Adobe Flash Developer Center
                // Adobe
                // 2005-08-08
                // Flex Developer Center
                // Adobe
                // 2005-10-16                
            }
        }
        
        private function parseRSS(rssXML:XML):Array {
            default xml namespace = rss;

            var items:XMLList = rssXML.item;

            var arr:Array = new Array();            
            var len:uint = items.length();
            for (var i:uint; i &lt; len; i++) {
                arr.push({title:items[i].title, creator:items[i].dc::creator, date:items[i].dc::date});
            }
            
            return arr;
        }

        private function getRSS():XML {
            var myXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/"
            >
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Adobe Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            return myXML;
        }
    }
}
</codeblock></example><example conref="examples\Namespace_2_Example.as"> В следующем примере показано, как пространства имен можно использовать для разграничения одноименных методов, выполняющих разные задачи. В данном примере три метода <codeph>hello()</codeph> находятся в отдельных пространствах имен, и каждый из них при вызове возвращает разную строку.
<codeblock>
package {

    import flash.display.Sprite;

    public class Namespace_2_Example extends Sprite {    
        public function Namespace_2_Example() {
            var vocab:MultilingualVocabulary = new MultilingualVocabulary();

            trace(vocab.hello());    // hello
            
            var languages:Array = vocab.getLanguages();
            
            for (var i:uint; i &lt; languages.length; i++) {
                var ns:Namespace = languages[i];
                if (ns != null) {
                    trace(ns.toString() + ": " + vocab.ns::hello());
                    // hello
                    // MultilingualVocabulary:Hawaiian: aloha
                    // MultilingualVocabulary:French: bon jour
                }
            }
        }
    }    
}

class MultilingualVocabulary {
    public namespace French;
    public namespace Hawaiian;
    private var languages:Array;

    public function MultilingualVocabulary() {
        languages = new Array(Hawaiian, French);
    }
        
    public function hello():String { 
        return "hello";
    }

    Hawaiian function hello():String {
        return "aloha";
    }

    French function hello():String { 
        return "bon jour";
    }
        
    public function getLanguages():Array {
        return languages;
    }
}
</codeblock></example><example conref="examples\Namespace_3_Example.as"> В следующем примере имена из пространства имен применяются для выбора подходящего значения переменной. Здесь показано, как сохранять значение пространства имен в виде переменной и использовать ее для ссылок на объекты в этом пространстве имен.
 <p>В примере определяются пространства имен и цвета, соответствующие состояниям мыши для прямоугольной кнопки. Каждый раз при создании кнопки в примере применяется подходящий цвет (красный – для курсора за пределами кнопки; желтый – для курсора на кнопке; белый – для нажатия) путем ссылки на переменную <codeph>bgcolor</codeph> для соответствующего пространства имен (<codeph>out</codeph>, <codeph>over</codeph>, <codeph>down</codeph>). </p>
<codeblock>
package {
    import flash.display.Sprite;
  
    public class Namespace_3_Example extends Sprite {     
        public function Namespace_3_Example() {
            addChild(new StateButton("Press Me."));
        }
    }
}

import flash.display.Sprite;
import flash.text.TextField;
import flash.events.Event;
import flash.events.MouseEvent;

class StateButton extends Sprite{
    private namespace out;
    private namespace over;
    private namespace down;
    private var label:TextField;
    private var labelTxt:String;
    private var ns:Namespace;
    out var bgColor:Number = 0xFF0000;
    over var bgColor:Number = 0xFFFF00;
    down var bgColor:Number = 0xFFFFFF;
      
    public function StateButton(str:String) {
        buttonMode = true;
        labelTxt = str;
        ns = out;
        draw();
        addLabel();
        addListeners();
    }

    private function addLabel():void {
        label = new TextField();
        label.text = labelTxt;
        label.width = 50;
        label.height = 20;
        label.mouseEnabled = false;
        addChild(label);
    }
      
    private function addListeners():void {
        addEventListener(MouseEvent.MOUSE_UP, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
    }
 
    private function mouseOutHandler(e:Event):void {
        ns = out;
        draw();
    }
 
    private function mouseOverHandler(e:Event):void {
        ns = over;
        draw();
    }
 
    private function mouseDownHandler(e:Event):void {
        ns = down;
        draw();
    }
 
    private function draw():void {
        this.graphics.clear();
        this.graphics.beginFill(ns::bgColor);
        this.graphics.drawRect(0, 0, 60, 20);
    }
} 
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Спецификация языка ECMAScript для XML E4X (ECMA-357, второе издание)</linktext></link></related-links><apiConstructor id="Namespace:Namespace_0"><apiName>Namespace</apiName><shortdesc> 
	Создает объект Namespace.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>Унифицированный идентификатор ресурса (URI-адрес) пространства имен.
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Создает объект Namespace при заданном параметре uriValue.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	Создает объект Namespace. Значения, присвоенные свойствам <codeph>uri</codeph> и <codeph>prefix</codeph> нового объекта Namespace, зависят от типа значения, переданного параметру <codeph>uriValue</codeph>:
	<ul>
	  <li>Если значение не передано, свойствам <codeph>prefix</codeph> и <codeph>uri</codeph> присваивается пустая строка.</li>
	  <li>Если в качестве значения выбран объект Namespace, создается копия этого объекта.</li>
	  <li>Если в роли значения выступает объект QName, свойство <codeph>uri</codeph> принимает значение свойства <codeph>uri</codeph> объекта QName.</li>
	</ul>
    <p><b>Примечание.</b> В этом классе показаны две записи конструктора, поскольку каждая из них поддерживает разные параметры. Режим работы конструктора меняется в зависимости от типа и количества переданных параметров (см. описание в записях). ActionScript 3.0 не поддерживает переопределение метода или конструктора.</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="Namespace:Namespace_1"><apiName>Namespace</apiName><shortdesc> 
	Создает объект Namespace, исходя из значений параметров prefixValue и uriValue.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>prefixValue</apiItemName><apiType value=""/><apiDesc>Префикс, используемый для пространства имен.   
	
	</apiDesc></apiParam><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>Унифицированный идентификатор ресурса (URI-адрес) пространства имен.
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Создает объект Namespace при заданных параметрах prefixValue и uriValue.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	Создает объект Namespace, исходя из значений параметров <codeph>prefixValue</codeph> и <codeph>uriValue</codeph>. Для этого конструктора обязательны оба параметра.
	<p>Значение параметра <codeph>prefixValue</codeph> присваивается свойству <codeph>prefix</codeph> следующим образом:</p>
	<ul>
	  <li>Если передается <codeph>undefined</codeph>, для <codeph>префикса</codeph> выбирается значение <codeph>undefined</codeph>.</li>
	  <li>Если в качестве значения выбрано действительное имя XML, определенное функцией <codeph>isXMLName()</codeph>, оно преобразуется в строку и присваивается свойству <codeph>prefix</codeph>.</li>
	  <li>Если в качестве значения выбрано недействительное имя XML, свойству <codeph>prefix</codeph> присваивается значение <codeph>undefined</codeph>.</li>
	</ul>
	
	<p>Значение параметра <codeph>uriValue</codeph> присваивается свойству <codeph>uri</codeph> следующим образом:</p>
	<ul>
	  <li>Если передается объект QName, свойству <codeph>uri</codeph> присваивается значение свойства <codeph>uri</codeph> объекта QName.</li>
	  <li> В противном случае параметр <codeph>uriValue</codeph> преобразуется в строку и присваивается свойству <codeph>uri</codeph>.</li>
	</ul>
    <p><b>Примечание.</b> В этом классе показаны две записи метода конструктора, поскольку каждая из них поддерживает разные параметры. Режим работы конструктора меняется в зависимости от типа и количества переданных аргументов (см. описание в записях). ActionScript 3.0 не поддерживает переопределение метода или конструктора.</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Namespace:AS3:toString"><apiName>toString</apiName><shortdesc>
	Эквивалент свойства Namespace.uri.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Унифицированный идентификатор ресурса (URI) пространства имен в виде строки.
	
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Эквивалент свойства Namespace.uri. 
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Эквивалент свойства <codeph>Namespace.uri</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="Namespace:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    Возвращает значение URI заданного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Унифицированный идентификатор ресурса (URI) пространства имен в виде строки.
    
    
    </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Эквивалент свойства Namespace.uri. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Возвращает значение URI заданного объекта. 
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="Namespace:prefix:get"><apiName>prefix</apiName><shortdesc>
	Префикс пространства имен.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.prefix, prefix
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Префикс пространства имен.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Префикс пространства имен.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="Namespace:uri:get"><apiName>uri</apiName><shortdesc>
	Унифицированный идентификатор ресурса (URI-адрес) пространства имен.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Унифицированный идентификатор ресурса (URI-адрес) пространства имен.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Унифицированный идентификатор ресурса (URI-адрес) пространства имен.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:XML"><apiName>XML</apiName><shortdesc>
	Класс XML содержит методы и свойства для работы с объектами XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XML
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Класс XML содержит методы и свойства для работы с объектами XML. В классе XML (а также в классах XMLList, Namespace и QName) реализованы мощные стандарты обработки XML, определенные в языке ECMAScript для спецификации XML E4X (ECMA-357, второе издание).
	
	<p>Воспользуйтесь методом <codeph>toXMLString()</codeph>, чтобы вернуть строковое представление объекта XML независимо от того, простое или сложное содержимое находится в этом объекте.</p>
	
	<p><b>Примечание.</b> Класс XML (вместе со связанными классами) из ActionScript 2.0 теперь называется XMLDocument и находится в пакете flash.xml. Он включен в ActionScript 3.0 в целях обеспечения обратной совместимости.</p> 
	
	
    </apiDesc><example conref="examples\XMLExample.as"> В следующем примере сначала создается переменная XML, а затем к ней добавляются узлы. Потом для поиска и печати узлов XML используются свойства XML. Заметьте, что символ «собака» (<codeph>@</codeph>) используется в нескольких вызовах <codeph>trace()</codeph> для поиска информации по имени атрибута.
<codeblock>
package {
    import flash.display.Sprite;

    public class XmlExample extends Sprite {        
        public function XmlExample() {
            var employees:XML =
                &lt;employees>
                    &lt;employee ssn="123-123-1234">
                        &lt;name first="John" last="Doe"/>
                        &lt;address>
                            &lt;street>11 Main St.&lt;/street>
                            &lt;city>San Francisco&lt;/city>
                            &lt;state>CA&lt;/state>
                            &lt;zip>98765&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                    &lt;employee ssn="789-789-7890">
                        &lt;name first="Mary" last="Roe"/>
                        &lt;address>
                            &lt;street>99 Broad St.&lt;/street>
                            &lt;city>Newton&lt;/city>
                            &lt;state>MA&lt;/state>
                            &lt;zip>01234&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                &lt;/employees>;

            trace(employees.employee[0].address.zip);   // 98765

            trace(employees.employee[1].@ssn);          // 789-789-7890

            trace(employees.employee.name);             // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees..zip[0]);                   // 98765

            trace(employees..@ssn[1]);                  // 789-789-7890

            trace(employees..name);                     // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees.employee[0].address.*);     // &lt;street>11 Main St.&lt;/street>    
                                                        // &lt;city>San Francisco&lt;/city>
                                                        // &lt;state>CA&lt;/state>
                                                        // &lt;zip>98765&lt;/zip>
            var node:String = "zip";
            trace(employees.employee[0].address[node]); // 98765
            
            var attribute:String = "ssn";
            trace(employees.employee[1].@[attribute]);  // 789-789-7890
            
            for each (var num:XML in employees..@ssn) {
                trace(num);                             // 123-123-1234
            }                                           // 789-789-7890
            
            var ssnToFind:String = "789-789-7890";
            trace(employees.employee.(@ssn == ssnToFind).toXMLString());
                                                        // &lt;employee ssn="789-789-7890">
                                                        // &lt;name first="Mary" last="Roe"/>
                                                        // &lt;address>
                                                        // &lt;street>99 Broad St.&lt;/street>
                                                        // &lt;city>Newton&lt;/city>
                                                        // &lt;state>MA&lt;/state>
                                                        // &lt;zip>01234&lt;/zip>
                                                        // &lt;/address>
                                                        // &lt;/employee>
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Спецификация языка ECMAScript для XML E4X (ECMA-357, второе издание)</linktext></link></related-links><apiConstructor id="XML:XML"><apiName>XML</apiName><shortdesc> 
	Создает новый объект XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Любой объект, который можно преобразовать в формат XML с помощью функции верхнего уровня <codeph>XML()</codeph>.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc> 
	Создает новый объект XML. Перед вызовом любых методов класса необходимо использовать конструктор для создания объекта XML. 
	
	<p>Воспользуйтесь методом <codeph>toXMLString()</codeph>, чтобы вернуть строковое представление объекта XML независимо от того, простое или сложное содержимое находится в этом объекте.</p>
	
	</apiDesc></apiConstructorDetail><related-links><link href="package.html#XML()"><linktext>функция верхнего уровня XML()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiConstructor><apiOperation id="XML:AS3:addNamespace"><apiName>addNamespace</apiName><shortdesc>
	Добавляет пространство имен в набор внутренних пространств имен для объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.addNamespace, addNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новый объект XML с добавленным пространством имен.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Пространство имен, добавляемое в объект XML.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Добавляет пространство имен в набор внутренних пространств имен для объекта XML. Если пространство имен уже существует во внутренних пространствах имен для объекта XML (с префиксом, соответствующим префиксу заданного параметра), то префиксу существующего пространства имен присваивается значение <codeph>undefined</codeph>. Если введенный параметр – это объект Namespace, он используется напрямую. Если это объект QName, для создания нового пространства имен применяется URI введенного параметра. В противном случае он преобразуется в объект String, на основе которого создается пространство имен.
	
	</apiDesc><example conref="examples\XML.addNamespace.1.as"> В этом примере использовано пространство имен, определенное в одном объекте XML и примененное к другому объекту XML:
<codeblock>
var xml1:XML = &lt;ns:foo xmlns:ns="www.example.com/ns" />;
var nsNamespace:Namespace = xml1.namespace();

var xml2:XML = &lt;bar />;
xml2.addNamespace(nsNamespace);
trace(xml2.toXMLString()); // &lt;bar xmlns:ns="www.example.com/ns"/>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:appendChild"><apiName>appendChild</apiName><shortdesc>
	Добавляет данный нижестоящий элемент в конце свойств объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.appendChild, appendChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый объект XML.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Добавляемый объект XML.
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
	Добавляет данный нижестоящий элемент в конце свойств объекта XML. Метод <codeph>appendChild()</codeph> принимает объект XML, объект XMLList или любой другой тип данных, который затем преобразуется в объект String. 
    
    <p>Воспользуйтесь оператором <codeph>delete</codeph> (XML), чтобы удалить узлы XML.</p>
	
	</apiDesc><example conref="examples\XML.appendChild.1.as"> В этом примере новый элемент добавляется в конец списка нижестоящих элементов объекта XML:
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.appendChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>hello&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>world&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>оператор delete (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	Возвращает XML-значение атрибута с именем, соответствующим параметру attributeName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList или пустой объект XMLList. Возвращает пустой объект XMLList, когда значение атрибута не определено.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>Имя атрибута.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Возвращает XML-значение атрибута с именем, соответствующим параметру <codeph>attributeName</codeph>. Поиск атрибутов выполняется в элементах XML. В следующем примере у элемента есть атрибут <codeph>gender</codeph> со значением <codeph>boy</codeph>: <codeph>&lt;first gender="boy">John&lt;/first></codeph>.
	
	<p>Параметр <codeph>attributeName</codeph> может относиться к любому типу данных; однако наиболее часто используется тип данных String. При передаче любого объекта, отличного от объекта QName, параметр <codeph>attributeName</codeph> использует метод <codeph>toString()</codeph>, чтобы преобразовать этот параметр в строку. </p>
	
	<p>Если необходима ссылка на полное имя, можно передать объект QName. Объект QName определяет пространство имени локальное имя, которые можно использовать для определения полного имени атрибута. Поэтому вызов <codeph>attribute(qname)</codeph> отличается от вызова <codeph>attribute(qname.toString())</codeph>.</p>
	
	</apiDesc><example conref="examples\XMLAttributeExample1.as"> В этом примере показан объект QName, переданный методу <codeph>attribute()</codeph>. Свойство <codeph>localName</codeph> имеет значение <codeph>attr</codeph>, а свойство <codeph>namespace</codeph> – значение <codeph>ns</codeph>.
<codeblock>
 var xml:XML = &lt;ns:node xmlns:ns = "http://uri" ns:attr = '7' />       
 var qn:QName = new QName("http://uri", "attr");
 trace (xml.attribute(qn)); // 7
</codeblock></example><example conref="examples\XMLAttributeExample2.as"> Чтобы вернуть атрибут с именем, совпадающим с зарезервированным словом ActionScript, воспользуйтесь методом <codeph>attribute()</codeph> вместо оператора идентификатора атрибута (@) (см. пример ниже):
<codeblock>
 var xml:XML = &lt;example class="first" />
 trace(xml.attribute("class"));
 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="operators.html#attribute_identifier"><linktext>оператор (&amp;#064;) идентификатора атрибута</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	Возвращает список значений атрибутов для данного объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Список значений атрибута.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает список значений атрибутов для данного объекта XML. Чтобы вернуть имя атрибута, воспользуйтесь методом <codeph>name()</codeph> вместе с методом <codeph>attributes()</codeph>. <codeph>xml.attributes()</codeph> выступает в качестве эквивалента <codeph>xml.@*</codeph>.
	
	</apiDesc><example conref="examples\XMLAttributesExample1.as"> В следующем примере возвращается имя атрибута:

<codeblock>
var xml:XML=&lt;example id='123' color='blue'/>
trace(xml.attributes()[1].name()); //color
</codeblock></example><example conref="examples\XMLAttributesExample2.as"> В этом примере возвращаются имена всех атрибутов:
<codeblock>
 
var xml:XML = &lt;example id='123' color='blue'/>
var attNamesList:XMLList = xml.@*;

trace (attNamesList is XMLList); // true
trace (attNamesList.length()); // 2

for (var i:int = 0; i &lt; attNamesList.length(); i++)
{ 
    trace (typeof (attNamesList[i])); // xml
    trace (attNamesList[i].nodeKind()); // attribute
    trace (attNamesList[i].name()); // id and color
} 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/name()"><linktext>XML.name()</linktext></link><link href="operators.html#attribute_identifier"><linktext>&amp;#064; operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:child"><apiName>child</apiName><shortdesc>
	Отображает список нижестоящих элементов объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList с нижестоящими узлами, соответствующими введенному параметру. 
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Имя элемента или целого числа дочернего XML. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Отображает список дочерних элементов объекта XML. Нижестоящий элемент XML – это элемент XML, текстовый узел, комментарий или инструкция по обработке. 
	
	<p>Чтобы перечислить содержимое конкретного нижестоящего элемента XML, воспользуйтесь параметром <codeph>propertyName</codeph>. Например, чтобы вернуть содержимое дочернего элемента <codeph>&lt;first></codeph>, укажите <codeph>child.name("first")</codeph>. Те же результаты можно получить, воспользовавшись номером индекса нижестоящего элемента. Номер индекса указывает на положение нижестоящего элемента в списке других дочерних элементов XML. Например, <codeph>name.child(0)</codeph> возвращает первый нижестоящий элемент в списке. </p>
	
	<p>Укажите «звездочку» (~~), чтобы вывести все нижестоящие объекты в документе XML. Например, <codeph>doc.child("~~")</codeph>.</p>  
	
	<p>Воспользуйтесь методом <codeph>length()</codeph> с параметром «звездочки» (~~) метода <codeph>child()</codeph>, чтобы вывести общее число нижестоящих объектов. Например, <codeph>numChildren = doc.child("~~").length()</codeph>.</p>
	
	</apiDesc><example conref="examples\XML.child.1.as"> В этом примере показано применение метода <codeph>child()</codeph> для обнаружения нижестоящих элементов с указанным именем:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;bar>text1&lt;/bar>
            &lt;bar>text2&lt;/bar>
        &lt;/foo>;
trace(xml.child("bar").length());  // 2
trace(xml.child("bar")[0].toXMLString()); // &lt;bar>text1&lt;/bar>
trace(xml.child("bar")[1].toXMLString()); // &lt;bar>text2&lt;/bar>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="#XMLList"><linktext>Класс XMLList</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:childIndex"><apiName>childIndex</apiName><shortdesc>
	Определяет нулевую позицию индекса данного объекта XML в контексте его вышестоящего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.childindex, childindex
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Позиция объекта. Возвращает как значение «-1», так и положительные целые числа.
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Определяет нулевую позицию индекса данного объекта XML в контексте его вышестоящего объекта.
	
	</apiDesc><example conref="examples\XML.childIndex.1.as"> В этом примере демонстрируется применение метода <codeph>childIndex()</codeph>:
<codeblock>
var xml:XML = 
            &lt;foo>
                &lt;bar />
                text
                &lt;bob />
            &lt;/foo>;
trace(xml.bar.childIndex()); // 0
trace(xml.bob.childIndex()); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:children"><apiName>children</apiName><shortdesc>
	Отображает список нижестоящих элементов объекта XML в порядке их расположения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList нижестоящих элементов объекта XML.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Отображает список нижестоящих элементов объекта XML в порядке их расположения. Нижестоящий элемент XML – это элемент XML, текстовый узел, комментарий или инструкция по обработке. 
	
	</apiDesc><example conref="examples\XML.children.1.as"> В этом примере демонстрируется применение метода <codeph>children()</codeph>:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var xml:XML = 
        &lt;foo id="22">
            &lt;bar>44&lt;/bar>
            text
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml.children().length()); // 4
trace(xml.children()[0].toXMLString()); // &lt;bar>44&lt;/bar>
trace(xml.children()[1].toXMLString()); // text
trace(xml.children()[2].toXMLString()); // &lt;!-- comment -->
trace(xml.children()[3].toXMLString()); // &lt;?instruction ?>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:comments"><apiName>comments</apiName><shortdesc>
	Отображает список свойств объекта XML, содержащих XML-комментарии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList свойств, содержащих комментарии.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Отображает список свойств объекта XML, содержащих XML-комментарии.
	
	</apiDesc><example conref="examples\XML.comments.1.as"> В этом примере демонстрируется применение метода <codeph>comments()</codeph>:
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;foo>
            &lt;!-- example -->
            &lt;!-- example2 -->
        &lt;/foo>;
trace(xml.comments().length()); // 2
trace(xml.comments()[1].toXMLString()); // &lt;!-- example2 -->
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:contains"><apiName>contains</apiName><shortdesc>
	Сравнивает объект XML с данным параметром value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если объект XML совпадает с параметром <codeph>value</codeph>, выбирается значение <codeph>true</codeph>. В противном случае возвращается <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Значение, сравниваемое с текущим объектом XML.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Сравнивает объект XML с данным параметром <codeph>value</codeph>. 
	
	</apiDesc><example conref="examples\XML.contains.1.as"> В этом примере демонстрируется применение метода <codeph>contains()</codeph>:
<codeblock>
var xml:XML = 
        &lt;order>
            &lt;item>Rice&lt;/item>
            &lt;item>Kung Pao Shrimp&lt;/item>
        &lt;/order>;
trace(xml.item[0].contains(&lt;item>Rice&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>Kung Pao Shrimp&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>MSG&lt;/item>)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:copy"><apiName>copy</apiName><shortdesc>
	Возвращает копию данного объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия объекта.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта XML. Копия – это дубликат всего дерева узлов. Скопированный объект XML не имеет вышестоящего элемента и возвращает <codeph>null</codeph> при попытке вызвать метод <codeph>parent()</codeph>.
    
	</apiDesc><example conref="examples\XML.copy.1.as"> В этом примере показано, что метод <codeph>copy()</codeph> приводит к созданию нового экземпляра объекта XML. При модификации копии оригинал остается неизменным:
<codeblock>
var xml1:XML = &lt;foo />;
var xml2:XML = xml1.copy();
xml2.appendChild(&lt;bar />);
trace(xml1.bar.length()); // 0
trace(xml2.bar.length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:defaultSettings"><apiName>defaultSettings</apiName><shortdesc>
	Возвращает объект со значениями по умолчанию для следующих свойств: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent и prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.defaultSettings, defaultSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Объект, свойствам которого присвоены настройки по умолчанию.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает объект со значениями по умолчанию для следующих свойств: <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> и <codeph>prettyPrinting</codeph>. Значения по умолчанию таковы:
	
	<ul>
	   <li><codeph>ignoreComments = true</codeph></li>
	   <li><codeph>ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>ignoreWhitespace = true</codeph></li>
	 <li><codeph>prettyIndent = 2</codeph></li>
	   <li><codeph>prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>Примечание.</b> Этот метод не применяется к экземпляру класса XML; его следует применять к <codeph>XML</codeph> так, как указано в следующем коде: <codeph>var df:Object = XML.defaultSettings()</codeph>. </p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> В следующем примере показано, как применять ряд значений по умолчанию (для включения комментариев и инструкций по обработке) перед настройкой объекта XML, как вернуть настройки по умолчанию перед переходом к другому объекту XML и затем, как снова установить пользовательские настройки для работы с другими объектами XML:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link><link href="#XML/settings()"><linktext>XML.settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	Возвращает всех потомков (нижестоящие объекты всех уровней) объекта XML, обладающих данным параметром name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList совпадающих потомков. Если потомков не существует, возвращается пустой объект XMLList.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Имя совпадающего элемента.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Возвращает всех потомков (нижестоящие объекты всех уровней) объекта XML, обладающих данным параметром <codeph>name</codeph>. Параметр <codeph>name</codeph> является необязательным. Параметр <codeph>name</codeph> может представлять собой объект QName, тип данных String или любой другой тип данных, который затем преобразуется в тип данных String.
	
	<p>Чтобы показать всех потомков, воспользуйтесь параметром (~~). Если параметр не задан, передается строка «~~» и отображаются все потомки объекта XML.</p>
	
	</apiDesc><example conref="examples\XMLDescendantsExample1.as"> Чтобы вернуть потомков, имена которых совпадают с зарезервированными словами ActionScript, воспользуйтесь методом <codeph>descendants()</codeph> вместо оператора descendant (..), как показано в следующем примере. 
<codeblock>
var xml:XML = 
  &lt;enrollees>
    &lt;student id="239">
        &lt;class name="Algebra" />
        &lt;class name="Spanish 2"/>
    &lt;/student>
    &lt;student id="206">
        &lt;class name="Trigonometry" />
        &lt;class name="Spanish 2" />
    &lt;/student>
  &lt;/enrollees>
trace(xml.descendants("class")); 
</codeblock></example><example conref="examples\XML.descendants.1.as"> В следующем примере указано, что метод <codeph>descendants()</codeph> возвращает объект XMLList, содержащий <i>все</i> объекты нижестоящих элементов любого уровня:
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;body>
            &lt;!-- comment -->
            text1
            &lt;a>
                &lt;b>text2&lt;/b>
            &lt;/a>
        &lt;/body>;
trace(xml.descendants("*").length()); // 5
trace(xml.descendants("*")[0]); // // &lt;!-- comment -->
trace(xml.descendants("*")[1].toXMLString()); // text1
trace(xml.descendants("a").toXMLString()); // &lt;a>&lt;b>text2&lt;/b>&lt;/a>
trace(xml.descendants("b").toXMLString()); // &lt;b>text2&lt;/b>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#descendant_accessor"><linktext>доступ к дочерним элементам (..) оператор</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:elements"><apiName>elements</apiName><shortdesc>
	 Отображает список элементов объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.elements, elements
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Объект XMLList содержимого элемента. Содержимое элемента находится между начальным и конечным тегом. Если для вызова всех элементов используется «звездочка» (~~), возвращаются как теги элемента, так и содержимое.
	 
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>Имя элемента. Имя элемента в угловых кавычках. Например, "<codeph>first</codeph>" является <codeph>именем</codeph> в примере <codeph>&lt;first>&lt;/first></codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает список элементов объекта XML. Элемент состоит из начального и конечного тега; например, <codeph>&lt;first>&lt;/first></codeph>. Параметр <codeph>name</codeph> является необязательным. Параметр <codeph>name</codeph> может представлять собой объект QName, тип данных String или любой другой тип данных, который затем преобразуется в тип данных String. Параметр <codeph>name</codeph> используется для включения определенного элемента в список. Например, элемент "<codeph>first</codeph>" возвращает "<codeph>John</codeph>" в примере <codeph>&lt;first>John&lt;/first></codeph>. 
	 
	 <p>Чтобы включить в список все элементы, воспользуйтесь параметром «звездочки» (~~). Звездочка также является параметром по умолчанию. </p>
	 
	 <p>Воспользуйтесь методом <codeph>length()</codeph> с параметром звездочки, чтобы вывести общее количество элементов. Например, <codeph>numElement = addressbook.elements("~~").length()</codeph>.</p>
	 
	 </apiDesc><example conref="examples\XML.elements.1.as"> В следующем примере показано, как метод <codeph>elements()</codeph> возвращает список, состоящий только из элементов, без комментариев, свойств текста или инструкций по обработке:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
            text
            &lt;a>1&lt;/a>
            &lt;b>2&lt;/b>
        &lt;/foo>;
trace(xml.elements("*").length()); // 2
trace(xml.elements("*")[0].toXMLString()); // &lt;a>1&lt;/a>
trace(xml.elements("b").length()); // 1
trace(xml.elements("b")[0].toXMLString()); // &lt;b>2&lt;/b>
</codeblock></example><example conref="examples\XMLElementsExample1.as"> Чтобы вернуть элементы, имена которых совпадают с зарезервированными словами ActionScript, воспользуйтесь методом <codeph>elements()</codeph> вместо оператора XML dot (.), как показано в следующем примере.
<codeblock>
var xml:XML =
 &lt;student id="206">
    &lt;class name="Trigonometry" />
    &lt;class name="Spanish 2" />
 &lt;/student>
trace(xml.elements("class")); 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XMLList"><linktext>Класс XMLList</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="operators.html#dot_(XML)"><linktext>XML dot (.) оператор</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	Проверяет наличие в объекте XML сложного содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если объект XML имеет сложное содержимое, возвращается значение <codeph>true</codeph>. В противном случае возвращается <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Проверяет наличие в объекте XML сложного содержимого. Объект XML имеет сложное содержимое, если у него есть нижестоящие элементы. Объекты XML, которые представляют собой атрибуты, комментарии, инструкции обработки и текстовые узлы, не имеют сложного содержимого. Однако объект, в котором они <i>содержатся</i>, может считаться имеющим сложное содержимое (если у него есть нижестоящие элементы).
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> В следующем примере показан объект XML, первое свойство <codeph>a</codeph> которого имеет простое содержимое, а второе свойство <codeph>a</codeph> – сложное содержимое.
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	Проверяет наличие у объекта свойства, заданного параметром p.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если свойство существует, указывается значение <codeph>true</codeph>; в противном случае выбирается значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Совпадающее свойство.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Проверяет наличие у объекта свойства, заданного параметром <codeph>p</codeph>. 
	
	</apiDesc><example conref="examples\XML.hasOwnProperty.1.as"> В следующем примере используется метод <codeph>hasOwnProperty()</codeph>, позволяющий убедиться в том, что свойство (<codeph>b</codeph>) существует перед оценкой выражения (<codeph>b == "11"</codeph>), в котором используется этот параметр:
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a />
            &lt;a>
                &lt;b>10&lt;/b>
            &lt;/a>
            &lt;a>
                &lt;b>11&lt;/b>
            &lt;/a>
        &lt;/foo>;
trace(xml.a.(hasOwnProperty("b") &amp;&amp; b == "11")); 
</codeblock> Flash Player создает исключение, поскольку первый элемент с именем <codeph>a</codeph> не имеет свойства <codeph>b</codeph>, если последняя строка в данном примере выглядит следующим образом:
 <p>
 <pre>trace(xml.a.(b == "11"));</pre>
 </p>
</example><example conref="examples\XML.hasOwnProperty.2.as"> В следующем примере используется метод <codeph>hasOwnProperty()</codeph>, позволяющий убедиться в том, что свойство (<codeph>item</codeph>) существует перед оценкой выражения (<codeph>item.contains("toothbrush")</codeph>), в котором применяется этот параметр:
<codeblock>
var xml:XML = 
        &lt;orders>
            &lt;order id='1'>
                &lt;item>toothbrush&lt;/item>
                &lt;item>toothpaste&lt;/item>
            &lt;/order>
            &lt;order>
                &lt;returnItem>shoe polish&lt;/returnItem>
            &lt;/order>
        &lt;/orders>;
trace(xml.order.(hasOwnProperty("item") &amp;&amp; item.contains("toothbrush"))); 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	Поверяет наличие в объекте XML простого содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если объект XML имеет простое содержимое, возвращается значение <codeph>true</codeph>. В противном случае возвращается <codeph>false</codeph>.
	
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Поверяет наличие в объекте XML простого содержимого. Объект XML имеет простое содержимое, если он представляет текстовый узел, узел атрибута или элемент XML, лишенный нижестоящих элементов. Объекты XML, представляющие комментарии и инструкции обработки, <i>не</i> имеют простого содержимого.
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> В следующем примере показан объект XML, первое свойство <codeph>a</codeph> которого имеет простое содержимое, а второе свойство <codeph>a</codeph> – сложное содержимое.
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:inScopeNamespaces"><apiName>inScopeNamespaces</apiName><shortdesc>
	Отображает список пространств имен объекта XML на основе вышестоящего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.inScopeNamespaces, inScopeNamespaces
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив объектов Namespace. 
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Отображает список пространств имен объекта XML на основе вышестоящего объекта. 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:insertChildAfter"><apiName>insertChildAfter</apiName><shortdesc>
	Вставляет данный параметр child2 после параметра child1 в этом объекте XML и возвращает полученный объект.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildAfter, insertChildAfter
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый объект XML или значение <codeph>undefined</codeph>.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект в исходном объекте, который вставляется перед <codeph>child2</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Вставляемый объект.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Вставляет данный параметр <codeph>child2</codeph> после параметра <codeph>child1</codeph> в этом объекте XML и возвращает полученный объект. Если параметру <codeph>child1</codeph> присвоено значение <codeph>null</codeph>, метод вставляет содержимое <codeph>child2</codeph> <i>перед</i> всеми нижестоящими объектами объекта XML (иными словами, после <i>none</i>). Если указан параметр <codeph>child1</codeph>, но он не существует в объекте XML, объект XML не изменяется и возвращается значение <codeph>undefined</codeph>.
	
	<p>Если этот метод вызывается по отношению к нижестоящему объекту XML, который не относится к числу элементов (текст, атрибуты, комментарии, число «пи» и т.д.), возвращается значение <codeph>undefined</codeph>.</p>
    
    <p>Воспользуйтесь оператором <codeph>delete</codeph> (XML), чтобы удалить узлы XML.</p>
	
	</apiDesc><example conref="examples\XML.insertChildAfter.1.as"> В следующем примере в конец списка нижестоящих элементов объекта XML добавляется элемент:
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildAfter(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> Метод <codeph>trace()</codeph> выводит следующее:
 <pre><codeph> &lt;menu>
     &lt;item>burger&lt;/item>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>soda&lt;/item>
 &lt;/menu></codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildBefore()"><linktext>XML.insertChildBefore()</linktext></link><link href="operators.html#delete_(XML)"><linktext>оператор delete (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:insertChildBefore"><apiName>insertChildBefore</apiName><shortdesc>
	Вставляет данный параметр child2 перед параметром child1 в этом объекте XML и возвращает полученный объект.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildBefore, insertChildBefore
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый объект XML или значение <codeph>undefined</codeph>.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект в исходном объекте, который вставляется после <codeph>child2</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Вставляемый объект.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Вставляет данный параметр <codeph>child2</codeph> перед параметром <codeph>child1</codeph> в этом объекте XML и возвращает полученный объект. Если параметру <codeph>child1</codeph> присвоено значение <codeph>null</codeph>, метод вставляет содержимое <codeph>child2</codeph> <i>после</i> всех нижестоящих объектов объекта XML (иными словами, перед <i>none</i>). Если указан параметр <codeph>child1</codeph>, но он не существует в объекте XML, объект XML не изменяется и возвращается значение <codeph>undefined</codeph>.
	
	<p>Если этот метод вызывается по отношению к нижестоящему объекту XML, который не относится к числу элементов (текст, атрибуты, комментарии, число «пи» и т.д.), возвращается значение <codeph>undefined</codeph>.</p>
    
    <p>Воспользуйтесь оператором <codeph>delete</codeph> (XML), чтобы удалить узлы XML.</p>
	
	</apiDesc><example conref="examples\XML.insertChildBefore.1.as"> В следующем примере в конец списка нижестоящих элементов объекта XML добавляется элемент:
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildBefore(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> Метод <codeph>trace()</codeph> выводит следующее:
 <pre>
 &lt;menu>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>burger&lt;/item>
     &lt;item>soda&lt;/item>
 &lt;/menu></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildAfter()"><linktext>XML.insertChildAfter()</linktext></link><link href="operators.html#delete_(XML)"><linktext>оператор delete (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:length"><apiName>length</apiName><shortdesc>
	Для объектов XML этот метод всегда возвращает целое число 1.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Всегда возвращает <codeph>1</codeph> для любого объекта XML.
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Для объектов XML этот метод всегда возвращает целое число <codeph>1</codeph>. Метод <codeph>length()</codeph> класса XMLList возвращает значение <codeph>1</codeph> для объекта XMLList, который содержит только одно значение.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:localName"><apiName>localName</apiName><shortdesc>
	Выдает часть полного имени объекта XML, содержащую локальное имя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.localName, localName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>В качестве локального имени выбирается String или <codeph>null</codeph>.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Выдает часть полного имени объекта XML, содержащую локальное имя.
	
	</apiDesc><example conref="examples\XML.localName.1.as"> В следующем примере демонстрируется использование метода <codeph>localName()</codeph>:
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.localName()); // Envelope
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:name"><apiName>name</apiName><shortdesc>
	Выдает полное имя объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.name, name
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>В качестве полного имени указывается QName или <codeph>null</codeph>.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Выдает полное имя объекта XML. 
	
	</apiDesc><example conref="examples\XML.name.1.as"> Следующий пример служит иллюстрацией применения метода <codeph>name()</codeph> для получения полного имени объекта XML:
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.name().localName); // Envelope
trace(xml.name().uri); // "http://www.w3.org/2001/12/soap-envelope"
</codeblock></example><example conref="examples\XML.name.2.as"> В следующем примере показано, как метод <codeph>name()</codeph> вызывается по отношению к свойству XML, текстовому элементу и атрибуту:
<codeblock>
var xml:XML = 
        &lt;foo x="15" y="22">
            text
        &lt;/foo>;
        
trace(xml.name().localName); // foo
trace(xml.name().uri == ""); // true
trace(xml.children()[0]); // text
trace(xml.children()[0].name()); // null
trace(xml.attributes()[0]); // 15
trace(xml.attributes()[0].name()); // x
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="operators.html#attribute_identifier"><linktext>идентификатор атрибута</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:namespace"><apiName>namespace</apiName><shortdesc>
	Если параметр не предусмотрен, выдает пространство имен, связанное с полным именем этого объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespace, namespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Возвращает <codeph>null</codeph>, <codeph>undefined</codeph> или пространство имен.
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>prefix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Совпадающий префикс.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Если параметр не предусмотрен, выдает пространство имен, связанное с полным именем этого объекта XML. Если указан параметр <codeph>prefix</codeph>, метод возвращает пространство имен, которое совпадает с параметром <codeph>prefix</codeph> и является внутренним для объекта XML. Если такого пространства имен не существует, метод возвращает значение <codeph>undefined</codeph>.
	
	</apiDesc><example conref="examples\XML.namespace.1.as"> В следующем примере метод <codeph>namespace()</codeph> используется для определения пространства имен объекта XML и его присвоения объекту Namespace с именем <codeph>soap</codeph>, который затем применяется для идентификации свойства объекта <codeph>xml</codeph> (<codeph>xml.soap::Body[0]</codeph>):
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
var soap:Namespace = xml.namespace();
trace(soap.prefix); // soap
trace(soap.uri); // http://www.w3.org/2001/12/soap-envelope

var body:XML = xml.soap::Body[0];
trace(body.namespace().prefix); // soap
trace(xml.namespace().uri); // http://www.w3.org/2001/12/soap-envelope
trace(body.namespace("wx").uri); // "http://example.com/weather"
</codeblock></example><example conref="examples\XML.namespace.2.as"> В следующем примере метод <codeph>namespace()</codeph> используется для того, чтобы определить пространство имен по умолчанию для узла, а также пространство имен для конкретного префикса (<codeph>"dc"</codeph>):
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">
                &lt;!-- ... -->
        &lt;/rdf:RDF>;
                    
trace(xml.namespace()); // http://www.w3.org/1999/02/22-rdf-syntax-ns#
trace(xml.namespace("dc")); // http://purl.org/dc/elements/1.1/
trace(xml.namespace("foo")); // undefined
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:namespaceDeclarations"><apiName>namespaceDeclarations</apiName><shortdesc>
	Отображает список объявлений пространств имен, связанных с объектом XML в контексте его вышестоящего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespaceDeclarations, namespaceDeclarations
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Массив объектов Namespace.
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Отображает список объявлений пространств имен, связанных с объектом XML в контексте его вышестоящего объекта. 
	
	</apiDesc><example conref="examples\XML.namespaceDeclarations.1.as"> В следующем примере выводятся объявления пространств имен для объекта XML.
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">

            &lt;!-- ... -->
            
        &lt;/rdf:RDF>;
                    
for (var i:uint = 0; i &lt; xml.namespaceDeclarations().length; i++) {
    var ns:Namespace = xml.namespaceDeclarations()[i]; 
    var prefix:String = ns.prefix;
    if (prefix == "") {
        prefix = "(default)";
    }
    trace(prefix + ":" , ns.uri);
}
</codeblock> Метод <codeph>trace()</codeph> выводит следующее:
 <pre><codeph>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
 dc: http://purl.org/dc/elements/1.1/
 (default): http://purl.org/rss/1.0/</codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/namespace()"><linktext>XML.namespace()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:nodeKind"><apiName>nodeKind</apiName><shortdesc>
	Задает тип узла: текст, комментарий, инструкцию обработки, атрибут или элемент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.nodeKind, nodeKind
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Используемый тип узла.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Задает тип узла: текст, комментарий, инструкцию обработки, атрибут или элемент. 
	
	</apiDesc><example conref="examples\XMLNodeKindExample1.as"> В этом примере отслеживаются все пять типов узлов:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;

var xml:XML = 
    &lt;example id="10">
        &lt;!-- this is a comment -->
        &lt;?test this is a pi ?>
        and some text
    &lt;/example>;

trace(xml.nodeKind()); // element
trace(xml.children()[0].nodeKind()); // comment
trace(xml.children()[1].nodeKind()); // processing-instruction
trace(xml.children()[2].nodeKind()); // text
trace(xml.@id[0].nodeKind()); // attribute
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#attribute_identifier"><linktext>идентификатор атрибута</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	Для объекта XML и всех объектов XML, которые являются его потомками, выполняет слияние смежных текстовых узлов и удаляет пустые текстовые узлы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый нормализованный объект XML.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Для объекта XML и всех объектов XML, которые являются его потомками, выполняет слияние смежных текстовых узлов и удаляет пустые текстовые узлы.
	
	</apiDesc><example conref="examples\XML.normalize.1.as"> В следующем примере показан эффект вызова метода <codeph>normalize()</codeph>:
<codeblock>
var xml:XML = &lt;body>&lt;/body>;
xml.appendChild("hello");
xml.appendChild(" world");
trace(xml.children().length()); // 2
xml.normalize();
trace(xml.children().length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:parent"><apiName>parent</apiName><shortdesc>
	Возвращает вышестоящий объект для объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Ссылка XML на родительский узел или значение <codeph>undefined</codeph>, если вышестоящий объект отсутствует для объекта XML.
	
	</apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	Возвращает вышестоящий объект для объекта XML. Если объект XML не имеет вышестоящего объекта, этот метод возвращает значение <codeph>undefined</codeph>.
	
	</apiDesc><example conref="examples\XML.parent.1.as"> В следующем примере метод <codeph>parent()</codeph> используется для определения вышестоящего элемента конкретного элемента в структуре XML:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p id="p1">Hello&lt;/p>
        &lt;p id="p2">Test:
            &lt;ul>
                &lt;li>1&lt;/li>
                &lt;li>2&lt;/li>
            &lt;/ul>
        &lt;/p>
    &lt;/body>;
var node:XML = xml.p.ul.(li.contains("1"))[0]; // == &lt;ul> ... &lt;/ul>
trace(node.parent().@id); // p2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:prependChild"><apiName>prependChild</apiName><shortdesc>
	Вставляет копию введенного нижестоящего объекта в элемент XML перед любыми существующими свойствами XML для этого элемента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prependChild, prependChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый объект XML.
    
    </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Вставляемый объект.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Вставляет копию введенного объекта <codeph>child</codeph> объекта в элемент XML перед любыми существующими свойствами XML для этого элемента.
    
    <p>Воспользуйтесь оператором <codeph>delete</codeph> (XML), чтобы удалить узлы XML.</p> 
	
	</apiDesc><example conref="examples\XML.prependChild.1.as"> В следующем примере метод <codeph>prependChild()</codeph> используется для добавления элемента в начало списка нижестоящих объектов объекта XML:
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.prependChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>world&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>оператор delete (XML)</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	Если параметр name введен, отображает список всех нижестоящих объектов для объекта XML, содержащих инструкции обработки с таким параметром.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Список совпадающих дочерних объектов.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>Имя совпадающих инструкций по обработке.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Если параметр <codeph>name</codeph> введен, отображает список всех дочерних объектов для объекта XML, содержащих инструкции обработки с таким <codeph>параметром</codeph>. Если параметры не указаны, метод перечисляет все нижестоящие объекты объекта XML, содержащего инструкции по обработке.
	
	</apiDesc><example conref="examples\XML.processingInstructions.1.as"> В следующем примере показано применение метода <codeph>processingInstructions()</codeph> для получения массива инструкций по обработке для объекта XML:
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml:XML =
    &lt;body>
            foo
            &lt;?xml-stylesheet href="headlines.css" type="text/css" ?>
            &lt;?instructionX ?>
            
    &lt;/body>;

trace(xml.processingInstructions().length()); // 2
trace(xml.processingInstructions()[0].name()); // xml-stylesheet
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	Проверяет, находится ли p в наборе свойств, которые можно итерировать в операторе for.. in, примененном к объекту XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Если это свойство можно итерировать в операторе <codeph>for.. in</codeph>, выбирается значение <codeph>true</codeph>; в противном случае указывается значение <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Проверяемое свойство.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Проверяет, находится ли <codeph>p</codeph> в наборе свойств, которые можно итерировать в операторе <codeph>for.. in</codeph>, примененном к объекту XML. Значение <codeph>true</codeph> возвращается только тогда, когда <codeph>toString(p) == "0"</codeph>. 
	
	</apiDesc><example conref="examples\XML.propertyIsEnumerable.1.as"> В следующем примере показано, что для объекта XML метод <codeph>propertyNameIsEnumerable()</codeph> возвращает значение <codeph>true</codeph> только при значении <codeph>0</codeph>, тогда как в случае объекта XMLList возвращается значение <codeph>true</codeph> для каждого действительного значения индекса, относящегося к объекту XMLList:
<codeblock>
var xml:XML = 
        &lt;body>
             &lt;p>Hello&lt;/p>
               &lt;p>World&lt;/p>
        &lt;/body>;

trace(xml.propertyIsEnumerable(0)); // true
trace(xml.propertyIsEnumerable(1)); // false

for (var propertyName:String in xml) {
    trace(xml[propertyName]);
}

var list:XMLList = xml.p;
trace(list.propertyIsEnumerable(0)); // true
trace(list.propertyIsEnumerable(1)); // true
trace(list.propertyIsEnumerable(2)); // false

for (var propertyName:String in list) { 
    trace(list[propertyName]);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:removeNamespace"><apiName>removeNamespace</apiName><shortdesc>
	Удаляет данное пространство имен для этого объекта и всех его потомков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.removeNamespace, removeNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Копия итогового объекта XML.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Удаляемое пространство имен.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Удаляет данное пространство имен для этого объекта и всех его потомков. Метод <codeph>removeNamespaces()</codeph> не удаляет пространство имен, если ссылка на него содержится в полном имени объекта или полных именах атрибутов объектов.
	
	</apiDesc><example conref="examples\XML.removeNamespace.1.as"> В следующем примере показано, как объявление пространства имен удаляется из объекта XML.
<codeblock>
var xml:XML = 
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
        xmlns:dc="http://purl.org/dc/elements/1.1/" 
        xmlns="http://purl.org/rss/1.0/">
    
        &lt;!-- ... -->
        
    &lt;/rdf:RDF>;

trace(xml.namespaceDeclarations().length); // 3
trace(xml.namespaceDeclarations()[0] is String); // 
var dc:Namespace = xml.namespace("dc");
xml.removeNamespace(dc);
trace(xml.namespaceDeclarations().length); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:replace"><apiName>replace</apiName><shortdesc>
	Заменяет свойства, заданные параметром propertyName, на данный параметр value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.replace, replace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый объект XML, у которого заменены совпадающие свойства.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Может являться числовым значением, неполным именем набора элементов XML, полным именем набора элементов XML или подстановочным символом «звездочка» («*»). Воспользуйтесь неполным именем, чтобы определить элементы XML в пространстве имен по умолчанию. 
	
	</apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Замещающее значение. Им может являться объект XML, объект XMLList или любое значение, которое можно преобразовать с помощью метода <codeph>toString()</codeph>. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Заменяет свойства, заданные параметром <codeph>propertyName</codeph>, на данный параметр <codeph>value</codeph>. Если ни одно из свойств не соответствует <codeph>propertyName</codeph>, объект XML остается неизменным.
	
	</apiDesc><example conref="examples\XML.replace.1.as"> В следующем примере показан вызов метода <codeph>replace()</codeph> с целым числом в качестве первого параметра:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace(1, &lt;p>Bob&lt;/p>);
trace(xml);
</codeblock> Это приводит к следующему выводу <codeph>trace()</codeph>:
 <pre><codeph>
 &lt;body>
     &lt;p>Hello&lt;/p>
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/body>
 </codeph></pre>
</example><example conref="examples\XML.replace.2.as"> В примере ниже метод <codeph>replace()</codeph> вызывается со строкой в качестве первого параметра:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("p", &lt;p>Hi&lt;/p>); 
trace(xml);
</codeblock> Это приводит к следующему выводу <codeph>trace()</codeph>:
 
 <pre><codeph>
 &lt;body>
     &lt;p>Hi&lt;/p>
     &lt;hr/>
 &lt;/body>;
 </codeph></pre>
</example><example conref="examples\XML.replace.3.as"> В этом примере показан вызов метода <codeph>replace()</codeph> с объектом QName в качестве первого параметра:
<codeblock>
var xml:XML = 
    &lt;ns:body xmlns:ns = "myNS">
        &lt;ns:p>Hello&lt;/ns:p>
        &lt;ns:p>World&lt;/ns:p>
        &lt;hr/>
    &lt;/ns:body>;

var qname:QName = new QName("myNS", "p");
xml.replace(qname, &lt;p>Bob&lt;/p>);
trace(xml);

</codeblock> Это приводит к следующему выводу <codeph>trace()</codeph>:
 
 <pre><codeph>
 &lt;ns:body xmlns:ns = "myNS">
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/ns:body>
 </codeph></pre>
</example><example conref="examples\XML.replace.4.as"> В данном примере демонстрируется вызов метода <codeph>replace()</codeph> со строкой <codeph>"*"</codeph> в качестве первого параметра:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("*", &lt;img src = "hello.jpg"/>);
trace(xml);
</codeblock> Это приводит к следующему выводу <codeph>trace()</codeph>:
 
 <pre><codeph>
 &lt;body>
     &lt;img src="hello.jpg"/>
 &lt;/body>
 </codeph></pre>
</example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setChildren"><apiName>setChildren</apiName><shortdesc>
	Заменяет свойства нижестоящего объекта XML заданным набором свойств XML из параметра value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setChildren, setChildren
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Итоговый объект XML. 
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Замещающие свойства XML. Может быть единичным объектом XML или объектом XMLList. 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Заменяет свойства нижестоящего объекта XML заданным набором свойств XML из параметра <codeph>value</codeph>.
	
	</apiDesc><example conref="examples\XML.setChildren.1.as"> В следующем примере показан вызов метода <codeph>setChildren()</codeph>. Сначала он выполняется с параметром в виде объекта XML, а затем с параметром, для которого выбран объект XMLList:
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
    &lt;/body>;

var list:XMLList = xml.p;

xml.setChildren(&lt;p>hello&lt;/p>);
trace(xml);

//    &lt;body>
//        &lt;p>hello&lt;/p>
//    &lt;/body>

xml.setChildren(list);
trace(xml);

//    &lt;body>
//        &lt;p>Hello&lt;/p>
//        &lt;p>World&lt;/p>
//    &lt;/body>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setLocalName"><apiName>setLocalName</apiName><shortdesc>
	Изменяет локальное имя объекта XML на заданное значение параметра name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setLocalName, setLocalName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Замещающее имя локального имени.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Изменяет локальное имя объекта XML на заданное значение параметра <codeph>name</codeph>. 
	
	</apiDesc><example conref="examples\XML.setLocalName.1.as"> Метод <codeph>setLocalName()</codeph> используется в этом примере для изменения локального имени элемента XML:
<codeblock>
var xml:XML = 
    &lt;ns:item xmlns:ns="http://example.com">
        toothbrush
    &lt;/ns:item>;
    
xml.setLocalName("orderItem");
trace(xml.toXMLString()); // &lt;ns:orderItem xmlns:ns="http://example.com">toothbrush&lt;/ns:orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setName"><apiName>setName</apiName><shortdesc>
	Задает имя объекта XML по данному полному имени или имени атрибута.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setName, setName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Новое имя объекта.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Задает имя объекта XML по данному полному имени или имени атрибута. 
	
	</apiDesc><example conref="examples\XML.setName.1.as"> Метод <codeph>setName()</codeph> используется в этом примере для изменения имени элемента XML:
<codeblock>
var xml:XML = 
    &lt;item>
        toothbrush
    &lt;/item>;
    
xml.setName("orderItem");
trace(xml.toXMLString()); // &lt;orderItem>toothbrush&lt;/orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setNamespace"><apiName>setNamespace</apiName><shortdesc>
	Задает пространство имен, связанное с объектом XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setNamespace, setNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>Новое пространство имен.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Задает пространство имен, связанное с объектом XML.
	
	</apiDesc><example conref="examples\XML.setNamespace.1.as"> В следующем примере используется пространство имен <codeph>soap</codeph>, определенное в одном из объектов XML, которое применяется к пространству имен другого объекта XML (<codeph>xml2</codeph>):
<codeblock>
var xml1:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
            &lt;!-- ... -->
        &lt;/soap:Envelope>;
var ns:Namespace = xml1.namespace("soap");

var xml2:XML = 
    &lt;Envelope>
        &lt;Body/>
    &lt;/Envelope>;
    
xml2.setNamespace(ns);

trace(xml2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setSettings"><apiName>setSettings</apiName><shortdesc>
	Задает значения для следующих свойств XML: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent и prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setSettings, setSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Объект с каждым из указанных ниже свойств: 
	
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Задает значения для следующих свойств XML: <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> и <codeph>prettyPrinting</codeph>. Ниже приводятся настройки по умолчанию, применяемые в том случае, если не указан параметр <codeph>setObj</codeph>.
	
	<ul>
	   <li><codeph>XML.ignoreComments = true</codeph></li>
	   <li><codeph>XML.ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>XML.ignoreWhitespace = true</codeph></li>
	   <li><codeph>XML.prettyIndent = 2</codeph></li>
	   <li><codeph>XML.prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>Примечание.</b> Этот метод не применяется к экземпляру класса XML; его следует применять к <codeph>XML</codeph> так же, как в следующем коде: <codeph>XML.setSettings()</codeph>.</p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> В следующем примере показано, как применять ряд значений по умолчанию (для включения комментариев и инструкций по обработке) перед настройкой объекта XML, как вернуть настройки по умолчанию перед переходом к другому объекту XML и затем, как снова установить пользовательские настройки для работы с другими объектами XML:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>defaultSettings()</linktext></link><link href="#XML/settings()"><linktext>settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:settings"><apiName>settings</apiName><shortdesc>
	Получает следующие свойства: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent и prettyPrinting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.settings, settings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>Объект со следующими свойствами XML:
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Получает следующие свойства: <codeph>ignoreComments</codeph>, <codeph>ignoreProcessingInstructions</codeph>, <codeph>ignoreWhitespace</codeph>, <codeph>prettyIndent</codeph> и <codeph>prettyPrinting</codeph>.
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> В следующем примере показано, как применять ряд значений по умолчанию (для включения комментариев и инструкций по обработке) перед настройкой объекта XML, как вернуть настройки по умолчанию перед переходом к другому объекту XML и затем, как снова установить пользовательские настройки для работы с другими объектами XML:
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>XML.defaultSettings()</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:text"><apiName>text</apiName><shortdesc>
	Возвращает объект XMLList всех свойств XML объекта XML, представляющих текстовые узлы XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Список свойств.
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает объект XMLList всех свойств XML объекта XML, представляющих текстовые узлы XML.
	
	</apiDesc><example conref="examples\XML.text.1.as"> В следующем примере метод <codeph>text()</codeph> используется для вывода текстовых узлов объекта XML:
<codeblock>
var xml:XML =
        &lt;body>
            text1
            &lt;hr/>
            text2
        &lt;/body>;
trace(xml.text()[0]); // text1
trace(xml.text()[1]); // text2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:toString"><apiName>toString</apiName><shortdesc>
	Возвращает строковое представление объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает строковое представление объекта XML. Правила этого преобразования зависят от наличия простого или сложного содержимого в объекте XML:
	
	<ul>
		<li>Если объект XML имеет простое содержимое, <codeph>toString()</codeph> возвращает строковое содержимое объекта XML, за исключением следующих компонентов: начального тега, атрибутов, объявлений пространства имен и конечного тега.</li> 
	</ul>
	
	<ul>
		<li> Если объект XML имеет сложное содержимое, <codeph>toString()</codeph> возвращает строку в формате XML, представляющую весь объект XML, включая начальный тег, атрибуты, объявления пространства имен и конечный тег.</li>
	</ul>
	
	<p>Чтобы каждый раз возвращать весь объект XML, воспользуйтесь методом <codeph>toXMLString()</codeph>.</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> В следующем примере показано, что возвращает метод <codeph>toString()</codeph>, когда объект XML имеет простое содержимое:
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> В следующем примере показано, что возвращает метод <codeph>toString()</codeph>, когда объект XML имеет сложное содержимое:
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	Возвращает строковое представление объекта XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта XML.
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает строковое представление объекта XML. В отличие от метода <codeph>toString()</codeph> метод <codeph>toXMLString()</codeph> всегда возвращает начальный тег, атрибуты и конечный тег объекта XML независимо от того, имеет ли объект XML простое или сложное содержимое. (Метод <codeph>toString()</codeph> приводит к удалению этих компонентов в объектах XML, имеющих простое содержимое.)
	
	</apiDesc><example conref="examples\XML.toXMLString.1.as"> В следующем примере показана разница между использованием метода <codeph>toString()</codeph> (который применяется ко всем параметрам метода <codeph>trace()</codeph> по умолчанию) и применением метода <codeph>toXMLString()</codeph>:
<codeblock>
var xml:XML =
        &lt;p>hello&lt;/p>;
trace(xml); // hello
trace(xml.toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/toString()"><linktext>XML.toString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	Возвращает объект XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Элементарное значение экземпляра XML.
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает объект XML. 
	
	</apiDesc><example conref="examples\XML.valueOf.1.as"> В примере ниже видно, что значение, возвращаемое методом <codeph>valueOf()</codeph>, аналогично исходному объекту XML:
<codeblock>
var xml:XML = &lt;p>hello&lt;/p>;
trace(xml.valueOf() === xml); // true
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="XML:ignoreComments:get"><apiName>ignoreComments</apiName><shortdesc>
	Определяет, будут ли игнорироваться XML-комментарии при анализе исходных XML-данных объектами XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreComments, ignoreComments
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, будут ли игнорироваться XML-комментарии при анализе исходных XML-данных объектами XML. По умолчанию комментарии игнорируются (значение <codeph>true</codeph>). Чтобы включить XML-комментарии, установите для этого свойства значение <codeph>false</codeph>. Свойство <codeph>ignoreComments</codeph> используется только при разборе XML, а не во время вызова того или иного метода (например, <codeph>myXMLObject.child(~~).toXMLString()</codeph>). Если исходный XML включает узлы комментариев, они сохраняются или пропускаются при разборе XML. 
	
	</apiDesc><example conref="examples\XML.ignoreComments.1.as"> В этом примере показано, что происходит, если <codeph>XML.ignoreComments</codeph> присвоить значения <codeph>false</codeph> и <codeph>true</codeph>:
<codeblock>
XML.ignoreComments = false;
var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;!-- comment -->&lt;/foo>

XML.ignoreComments = true;
var xml2:XML = 
        &lt;foo>
            &lt;!-- example -->
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreProcessingInstructions:get"><apiName>ignoreProcessingInstructions</apiName><shortdesc>
	Определяет, будут ли игнорироваться инструкции обработки XML при анализе исходных XML-данных объектами XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreProcessingInstructions, ignoreProcessingInstructions
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, будут ли игнорироваться инструкции обработки XML при анализе исходных XML-данных объектами XML. По умолчанию инструкции обработки игнорируются (значение <codeph>true</codeph>). Чтобы включить инструкции обработки XML, установите для этого свойства значение <codeph>false</codeph>. Свойство <codeph>ignoreProcessingInstructions</codeph> используется только при разборе XML, а не во время вызова того или иного метода (например, <codeph>myXMLObject.child(~~).toXMLString()</codeph>). Если исходный XML включает узлы инструкций обработки, они сохраняются или пропускаются при разборе XML.
	
	</apiDesc><example conref="examples\XML.ignoreProcessingInstructions.1.as"> В этом примере показано, что происходит, если <codeph>XML.ignoreProcessingInstructions</codeph> присвоить значения <codeph>false</codeph> и <codeph>true</codeph>:
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml1:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;?exampleInstruction ?>&lt;/foo>

XML.ignoreProcessingInstructions = true;
var xml2:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreWhitespace:get"><apiName>ignoreWhitespace</apiName><shortdesc>
	Определяет, будут ли игнорироваться при анализе разделители в начале и в конце текстовых узлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreWhitespace, ignoreWhitespace
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, будут ли игнорироваться при анализе разделители в начале и в конце текстовых узлов. По умолчанию они игнорируются (значение <codeph>true</codeph>). Если текстовый узел на 100% состоит из разделителей, а свойству <codeph>ignoreWhitespace</codeph> присвоено значение <codeph>true</codeph>, то узел не создается. Чтобы показывать разделители в текстовом узле, присвойте свойству <codeph>ignoreWhitespace</codeph> значение <codeph>false</codeph>. 
	
	</apiDesc><example conref="examples\XML.ignoreWhitespace.1.as"> В этом примере показано, что происходит, если <codeph>XML.ignoreWhitespace</codeph> присвоить значения <codeph>false</codeph> и <codeph>true</codeph>:
<codeblock>
XML.ignoreWhitespace = false;
var xml1:XML = &lt;foo>    &lt;/foo>;
trace(xml1.children().length()); // 1

XML.ignoreWhitespace = true;
var xml2:XML = &lt;foo>    &lt;/foo>;
trace(xml2.children().length()); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="XML:prettyIndent:get"><apiName>prettyIndent</apiName><shortdesc>
	Определяет размер отступа, создаваемого методами toString() и toXMLString(), когда для свойства XML.prettyPrinting выбрано значение true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyIndent, prettyIndent
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Определяет размер отступа, создаваемого методами <codeph>toString()</codeph> и <codeph>toXMLString()</codeph>, когда для свойства <codeph>XML.prettyPrinting</codeph> выбрано значение <codeph>true</codeph>. Отступ определяется символом пробела, а не табуляции. По умолчанию используется значение <codeph>2</codeph>.
	
	</apiDesc><example conref="examples\XML.prettyIndent.1.as"> В этом примере показан эффект параметра статического свойства <codeph>XML.prettyIndent</codeph>:
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyIndent = 0;
trace(xml.toXMLString());

XML.prettyIndent = 1;
trace(xml.toXMLString());

XML.prettyIndent = 2;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:prettyPrinting:get"><apiName>prettyPrinting</apiName><shortdesc>
	Определяет, будут ли методы toString() и toXMLString() выполнять нормализацию разделителей между некоторыми тегами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyPrinting, prettyPrinting
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, будут ли методы <codeph>toString()</codeph> и <codeph>toXMLString()</codeph> выполнять нормализацию разделителей между некоторыми тегами. По умолчанию используется значение <codeph>true</codeph>.
	
	</apiDesc><example conref="examples\XML.prettyPrinting.1.as"> В этом примере показан эффект установки статического свойства <codeph>XML.prettyPrinting</codeph>:
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyPrinting = false;
trace(xml.toXMLString());

XML.prettyPrinting = true;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:Array"><apiName>Array</apiName><shortdesc>
	 Создает новый массив.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Массив нулевой или большей длины.
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Пустому массиву можно не передавать никаких аргументов, передать единичный целочисленный аргумент для массива конкретной длины или серию значений различных типов, разделенных запятыми, для массива, заполненного этими значениями.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Создает новый массив. Он может иметь длину не меньше нуля или заполняться списком указанных элементов, возможно, принадлежащих разным типам данных. Количество и тип данных используемых аргументов определяет содержимое возвращаемого массива.
	 <ul>
	   <li>Вызов функции <codeph>Array()</codeph> без аргументов возвращает пустой массив.</li>
	   <li>Вызов функции <codeph>Array()</codeph> с единственным целочисленным аргументом возвращает массив указанной длины, значения элементов которого, тем не менее, не определены.</li>
	   <li>Вызов функции <codeph>Array()</codeph> со списком конкретных значений возвращает массив с элементами, содержащими каждое из указанных значений.</li>
	 </ul>
	 Использование функции <codeph>Array()</codeph> напоминает создание массива с конструктором класса Array.
	 <p>Воспользуйтесь оператором <codeph>as</codeph> для явного преобразования или приведения типов, когда аргумент не является элементарным значением. Дополнительную информацию см. в разделе «Пример» данной записи. </p>
	 </apiDesc><example conref="examples\Array.func.4.as"> В следующем примере демонстрируется поведение функции <codeph>Array()</codeph> в том случае, если аргумент не является элементарным значением. Часто возникает ситуация, когда приведение типов к массиву состоит в преобразовании экземпляра Object, сохраняющего свои значения в формате массива. Если функция <codeph>Array()</codeph> вызывается с аргументом типа <codeph>Object</codeph> или любого другого типа данных, не относящихся к элементарным, ссылка на объект сохраняется в элементе нового массива. Иными словами, если единственный переданный аргумент является объектом, ссылка на этот объект становится первым элементом нового массива.
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = Array( obj );

trace(newArray == obj);    // false
trace(newArray[0] == obj); // true
trace(newArray[0][0])      // a
trace(newArray[0][1])      // b
trace(newArray[0][2])      // c
</codeblock></example><example conref="examples\Array.func.5.as"> Чтобы привести тип <codeph>obj</codeph> к массиву, воспользуйтесь оператором <codeph>as</codeph>, который возвращает ссылку на массив, если <codeph>obj</codeph> является действительным массивом. В противном случае возвращается <codeph>null</codeph>:
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = obj as Array;

trace(newArray == obj); // true
trace(newArray[0]);     // a
trace(newArray[1]);     // b
trace(newArray[2]);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array"><linktext>Класс Array</linktext></link><link href="operators.html#as"><linktext>Оператор as</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:Boolean"><apiName>Boolean</apiName><shortdesc>
	 Преобразует параметр expression в логическое значение и возвращает его.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Результат преобразования в логическое значение.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Выражение или объект, преобразуемые в логическое значение.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует параметр <codeph>expression</codeph> в логическое значение и возвращает его. 
	 <p>Возвращаемое значение зависит от типа данных и значения аргумента (см. таблицу ниже):</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Введенное значение</entry><entry>Пример</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>Boolean(0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Boolean(NaN)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Число (не <codeph>0</codeph> или <codeph>нечисловое значение</codeph>)</entry>
	     <entry><codeph>Boolean(4)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Пустая строка</entry>
	     <entry><codeph>Boolean("")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Непустая строка</entry>
	     <entry><codeph>Boolean("6")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>Boolean(null)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>Boolean(undefined)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Экземпляр класса Object</entry>
	     <entry><codeph>Boolean(new Object())</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Нет аргумента</entry>
	     <entry><codeph>Boolean()</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 <p>В отличие от предыдущих версий ActionScript функция <codeph>Boolean()</codeph> возвращает те же результаты, что и конструктор класса Boolean.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Number"><apiName>Number</apiName><shortdesc>
	 Преобразует данное значение в значение Number.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Преобразованное числовое значение
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Значение, преобразуемое в число.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует данное значение в значение Number. В таблице ниже приведены результаты при различных типах ввода.
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Тип/значение ввода</entry><entry>Пример</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>Number(undefined)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>Number(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>Number(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>Number(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Number(NaN)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry>Пустая строка</entry>
	     <entry><codeph>Number("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Строка, преобразуемая в значение Number</entry>
	     <entry><codeph>Number("5")</codeph></entry>
	     <entry>Число (например, <codeph>5</codeph>)</entry>
	   </row><row>
	     <entry>Строка, которая не преобразуется в значение Number</entry>
	     <entry><codeph>Number("5a")</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Object"><apiName>Object</apiName><shortdesc>
	 Все значения в ActionScript 3.0 являются объектами. Это означает, что при вызове метода Object() для значения возвращается данное значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Значение, указанное параметром <codeph>value</codeph>.
     </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Преобразуемый объект или число, строка и логическое значение.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Все значения в ActionScript 3.0 являются объектами. Это означает, что при вызове метода <codeph>Object()</codeph> для значения возвращается данное значение.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:String"><apiName>String</apiName><shortdesc>
	 Возвращает строковое представление заданного параметра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строковое представление значения, переданного для параметра <codeph>expression</codeph>.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc> Выражение, преобразуемое в строку.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строковое представление заданного параметра.
	 <p>В таблице ниже приведены результаты при различных типах ввода.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Тип/значение ввода</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>undefined</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>"NaN"</codeph></entry>
	   </row><row>
	     <entry>Строка</entry>
	     <entry>Строка</entry>
	   </row><row>
	     <entry>Object</entry>
	     <entry>Object.toString()</entry>
	   </row><row>
	     <entry>Number</entry>
	     <entry>Строковое представление числа</entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Vector"><apiName>Vector</apiName><shortdesc>
	 Создает новый экземпляр вектора, элементы которого являются экземплярами указанного типа данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><commentPrivate>The reason this compiles with the .&lt;T> designation is because
	 a dummy class "T" is declared in the top level Vector.as file. If this file is
	 built without that one, the build will fail.
	 
	 </commentPrivate></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если аргумент <codeph>sourceArray</codeph> содержит элемент, который невозможно преобразовать в указанный тип данных.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Экземпляр вектора, заполненный элементами массива <codeph>sourceArray</codeph>.
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>sourceArray</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Экземпляр Array или Vector, элементы которого становятся элементами итогового объекта Vector. Если аргумент – это экземпляр вектора, тип данных которого совпадает с указанным типом данных, этот аргумент возвращается в качестве результата функции.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Создает новый экземпляр вектора, элементы которого являются экземплярами указанного типа данных. При вызове этой функции указывается тип данных для элементов итогового вектора (<i>базового типа</i> вектора) с помощью параметра типа. В этой функции используется тот же синтаксис, что и при объявлении экземпляра вектора или вызове конструктора <codeph>new Vector. &lt;T>()</codeph>:
	 
	 <codeblock>var v:Vector.&lt;String> = Vector.&lt;String>(["Hello", "World"]);</codeblock>
	 
	 <p>Итоговый вектор заполняется значениями, указанными в элементах аргумента <codeph>sourceArray</codeph>. Если аргумент <codeph>sourceArray</codeph> уже является экземпляром Vector. &lt;T>, где <codeph>T</codeph> это базовый тип, функция возвращает данный вектор. В противном случае итоговый вектор заполняется элементами массива или вектора, представленного аргументом <codeph>sourceArray</codeph>.</p>
	 
	 <p>В любом случае тип данных всех элементов аргумента <codeph>sourceArray</codeph> должен совпадать с базовым типом <codeph>T</codeph>, который указан в вызове функции.</p>
	 
	 <p>Если аргумент <codeph>sourceArray</codeph> имеет нулевое значение свойства <codeph>length</codeph>, функция возвращает пустой вектор.</p>
	 
	 <p>Если вектор передан как аргумент <codeph>sourceArray</codeph>, а его базовый тип – не <codeph>T</codeph>, или если передан массив, и не все его элементы имеют тип данных <codeph>T</codeph>, выполняется попытка преобразовать значения в базовый тип. Если значения удается автоматически преобразовать, итоговый вектор содержит преобразованные значения. Если преобразование выполнить не удается, происходит ошибка.</p>
	 
	 <p>Точно так же, если элемент в аргументе <codeph>sourceArray</codeph> является экземпляром подкласса базового типа <codeph>T</codeph>, вызов выполняется успешно, и элемент добавляется в итоговый вектор. Это происходит даже тогда, когда аргумент <codeph>sourceArray</codeph> является вектором, чей базовый тип является подклассом <codeph>T</codeph>. Фактически, только так можно преобразовать вектор с базовым типом <codeph>T</codeph> в вектор с базовым типом, который является суперклассом <codeph>T</codeph>.</p>
	 
	 <p>Например, следующий код приводит к появлению ошибки компиляции в строгом режиме или ошибки TypeError во время выполнения, поскольку он пытается присвоить Vector. &lt;Sprite> переменной Vector. &lt;DisplayObject> (Sprite – это подкласс DisplayObject).</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = v1;
	 </codeblock>
	 
	 <p>Следующая альтернативная версия кода приводит к успешному копированию элементов экземпляра Vector. &lt;Sprite> в экземпляр Vector. &lt;DisplayObject>.</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = Vector.&lt;DisplayObject>(v1);
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Vector"><linktext>Класс Vector</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XMLList"><apiName>XMLList</apiName><shortdesc>
     Преобразует объект в объект XMLList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект XMLList, содержащий значения, которые записаны в преобразованном объекте.
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект, преобразуемый в объект XMLList
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Преобразует объект в объект XMLList.
     <p>В таблице ниже дается описание значений, возвращаемых при различных типах ввода.</p>
	 <adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>Тип параметра</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	 		<entry>Логическое значение</entry>
	 		<entry>Значение сначала преобразуется в строку, а затем – в объект XMLList.</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>Происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>Значение сначала преобразуется в строку, а затем – в объект XMLList.</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>Преобразование в XMLList выполняется только тогда, когда значение относится к типам String, Number или Boolean. В противном случае происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row><row>
	 		<entry>Строка</entry>
	 		<entry>Значение преобразуется в объект XMLList</entry>
	 	</row><row>
	 		<entry>Не определен</entry>
	 		<entry>Происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>Значение преобразуется в объект XMLList</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>Вводимое значение возвращается без изменений.</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XML()"><linktext>XML()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XML"><apiName>XML</apiName><shortdesc>
	 Преобразует объект в объект XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект XML, содержащий значения, которые записаны в преобразуемом объекте.
	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект, преобразуемый в формат XML.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует объект в объект XML. 
	 <p>В таблице ниже дается описание значений, возвращаемых при различных типах ввода.</p>
	 	<adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>Тип параметра</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	 		<entry>Логическое значение</entry>
	 		<entry>Значение сначала преобразуется в строку, а затем – в объект XML.</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>Происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>Значение сначала преобразуется в строку, а затем – в объект XML.</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>Преобразование в XML выполняется только тогда, когда значение относится к типам String, Number или Boolean. В противном случае происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row><row>
	 		<entry>Строка</entry>
	 		<entry>Значение преобразуется в XML.</entry>
	 	</row><row>
	 		<entry>Не определен</entry>
	 		<entry>Происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>Вводимое значение возвращается без изменений.</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>Возвращает объект XML только в том случае, если объект XMLList содержит только одно свойство типа XML. В противном случае происходит ошибка при выполнении (исключение TypeError).</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XMLList()"><linktext>XMLList()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURIComponent"><apiName>decodeURIComponent</apiName><shortdesc>
	 Расшифровывает зашифрованный URI-компонент в строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, все символы в которой были ранее маскированы с помощью функции <codeph>encodeURIComponent</codeph>, восстанавливаются в немаскированном представлении.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, закодированная с помощью функции <codeph>encodeURIComponent</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Расшифровывает зашифрованный URI-компонент в строку. Строка, все символы в которой были ранее маскированы с помощью функции <codeph>encodeURIComponent</codeph>, восстанавливается в немаскированном представлении.
	 <p>Отличие этой функции от функции <codeph>decodeURI()</codeph> состоит в том, что она предназначена для использования только по отношению к части строки URI, которая называется компонентом URI. Компонент URI – это любой текст, который заключен между специальными символами, названными <i>разделителями компонентов</i> (<codeph>«:», «/», «;» и «?» </codeph>). Распространенные примеры компонентов URI: «http» и «www.adobe.com».</p>
	 <p>Другое важное различие между этой функцией и <codeph>decodeURI()</codeph> обусловлено предположением о том, что она обрабатывает компонент URI. При этом специальные символы разделителей (<codeph>; / ? : @ &amp; = + $ , #</codeph>) рассматриваются в качестве обычного текста, который следует декодировать. </p>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURI"><apiName>decodeURI</apiName><shortdesc>
	 Расшифровывает зашифрованный URI-адрес в строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, все символы в которой, ранее маскированные с помощью функции <codeph>encodeURI</codeph>, восстанавливаются в немаскированном представлении.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, закодированная с помощью функции <codeph>encodeURI</codeph>.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Расшифровывает зашифрованный URI-адрес в строку. Строка, все символы в которой были ранее закодированы с помощью функции <codeph>encodeURI</codeph>, восстанавливается и выводится в раскодированном представлении.
	 <p>В следующей таблице показан набор управляющих последовательностей, которые <i>не</i> раскодируются в виде символов функцией <codeph>decodeURI</codeph>. Воспользуйтесь методом <codeph>decodeURIComponent()</codeph>, чтобы раскодировать управляющие последовательности в этой таблице.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Нераскодированные управляющие последовательности</entry><entry>Эквиваленты символов</entry></row></thead><tbody><row>
	     <entry><codeph>%23</codeph></entry>
	     <entry><codeph>#</codeph></entry>
	   </row><row>
	     <entry><codeph>%24</codeph></entry>
	     <entry><codeph>$</codeph></entry>
	   </row><row>
	     <entry><codeph>%26</codeph></entry>
	     <entry><codeph>&amp;</codeph></entry>
	   </row><row>
	     <entry><codeph>%2B</codeph></entry>
	     <entry><codeph>+</codeph></entry>
	   </row><row>
	     <entry><codeph>%2C</codeph></entry>
	     <entry><codeph>,</codeph></entry>
	   </row><row>
	     <entry><codeph>%2F</codeph></entry>
	     <entry><codeph>/</codeph></entry>
	   </row><row>
	     <entry><codeph>%3A</codeph></entry>
	     <entry><codeph>:</codeph></entry>
	   </row><row>
	     <entry><codeph>%3B</codeph></entry>
	     <entry><codeph>;</codeph></entry>
	   </row><row>
	     <entry><codeph>%3D</codeph></entry>
	     <entry><codeph>=</codeph></entry>
	   </row><row>
	     <entry><codeph>%3F</codeph></entry>
	     <entry><codeph>?</codeph></entry>
	   </row><row>
	     <entry><codeph>%40</codeph></entry>
	     <entry><codeph>@</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example conref="examples\DecodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class DecodeURIExample extends Sprite {
        public function DecodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURIComponent"><apiName>encodeURIComponent</apiName><shortdesc>
	 Зашифровывает строку в допустимый URI-компонент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 Зашифровывает строку в допустимый URI-компонент. Преобразует подстроку URI-адреса в строку, в которой все символы кодируются в виде управляющих последовательностей UTF-8, если не принадлежат к очень ограниченному числу базисных символов.
	 <p>Отличие функции <codeph>encodeURIComponent()</codeph> от функции <codeph>encodeURI()</codeph> состоит в том, что она предназначена для использования только по отношению к части строки URI, которая называется компонентом URI. Компонент URI — это любой текст, который заключен между специальными символами, названными <i>разделителями компонентов</i> (<codeph>«:», «/», «;» и «?» </codeph>). Распространенные примеры компонентов URI: «http» и «www.adobe.com».</p>
	 <p>Другое важное различие между этой функцией и <codeph>encodeURI()</codeph> обусловлено предположением о том, что она обрабатывает компонент URI. При этом специальные символы разделителей (<codeph>; / ? : @ &amp; = + $ , #</codeph>) рассматриваются в качестве обычного текста, который следует закодировать. </p>
	 <p>В таблице ниже приведены все символы, которые <i>не</i> преобразуются в управляющие последовательности UTF-8 функцией <codeph>encodeURIComponent</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Символы, которые не кодируются</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>- _ . ! ~ ~~ ' ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURI"><apiName>encodeURI</apiName><shortdesc>
	 Зашифровывает строку в допустимый URI-адрес (унифицированный идентификатор ресурса).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, где определенные символы закодированы в виде управляющих последовательностей UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, представляющая весь URI-адрес.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Зашифровывает строку в допустимый URI-адрес (унифицированный идентификатор ресурса). Преобразует полный URI-адрес в строку, в которой все символы имеют кодировку UTF-8, если не принадлежат к небольшой группе базисных символов.
	 <p>В таблице ниже полностью приведен список базисных символов, которые <i>не</i> преобразуются в управляющие последовательности UTF-8 с помощью функции <codeph>encodeURI</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Символы, которые не кодируются</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>; / ? : @ &amp; = + $ , #</codeph></entry>
	   </row><row>
	     <entry><codeph>- _ . ! ~ ~~ ' ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc><example conref="examples\EncodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class EncodeURIExample extends Sprite {
        public function EncodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:escape"><apiName>escape</apiName><shortdesc>
	 Преобразует параметр в строку и кодирует ее в формат кодировки URL-адреса, где большинство символов, не являющихся алфавитно-цифровыми, заменяются шестнадцатеричными последовательностями %.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка в кодировке URL-адреса
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Выражение, преобразуемое в строку с кодировкой URL-адреса.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует параметр в строку и кодирует ее в формат кодировки URL-адреса, где большинство символов, не являющихся алфавитно-цифровыми, заменяются шестнадцатеричными последовательностями <codeph>%</codeph>. Когда в строке с кодировкой URL-адреса используется символ процента (<codeph>%</codeph>), он служит для включения управляющих символов и не эквивалентен оператору модуля (<codeph>%</codeph>).
	 <p>В таблице ниже приведены все символы, которые <i>не</i> преобразуются в управляющие последовательности функцией <codeph>escape()</codeph>.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>Символы, которые не кодируются</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>@ - _ . ~~ + /</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/unescape()"><linktext>unescape()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:int"><apiName>int</apiName><shortdesc>
	 Преобразует данное числовое значение в целочисленное значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Преобразованное целочисленное значение.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Значение, которое необходимо преобразовать в целочисленное.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует данное числовое значение в целочисленное значение. Десятичные значения усекаются до целых чисел.
	 </apiDesc></apiOperationDetail><related-links><link href="#global/uint()"><linktext>uint()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:isFinite"><apiName>isFinite</apiName><shortdesc>
	 Возвращает true, если значение является конечным числом, либо false, если значение является бесконечностью или минус бесконечностью.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0."/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Возвращает <codeph>true</codeph>, если оно является конечным числом или <codeph>false</codeph>, если это бесконечность или минус бесконечность
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, оцениваемое как конечное или бесконечное.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает <codeph>true</codeph>, если значение является конечным числом, либо <codeph>false</codeph>, если значение является <codeph>бесконечностью </codeph> или <codeph>минус бесконечностью</codeph>. Присутствие <codeph>Infinity</codeph> или <codeph>-Infinity</codeph> указывает на возникновение математической ошибки (например, при попытке деления на ноль).
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isNaN"><apiName>isNaN</apiName><shortdesc>
	 Возвращает true, если значение относится к разряду NaN (нечисловое).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Возвращает <codeph>true</codeph> при наличии значения <codeph>NaN</codeph> (нечисловое) и <codeph>false</codeph> в противном случае.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Оцениваемое числовое значение или математическое выражение.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает <codeph>true</codeph>, если значение относится к разряду <codeph>NaN</codeph> (нечисловое). Функция <codeph>isNaN()</codeph> полезна при проверке успешности оценки математического выражения с помощью числа. Как правило, функция <codeph>isNaN()</codeph> используется для проверки значения, возвращенного функциями <codeph>parseInt()</codeph> и <codeph>parseFloat()</codeph>. Значение <codeph>NaN</codeph> – это специальный элемент типа данных Number, представляющий значение, которое «не является числом». 
	 <p><b>Примечание</b>. Значение <codeph>NaN</codeph> не принадлежит типам данных int или uint.</p>
	 <p>В таблице ниже описаны значения, возвращаемые <codeph>isNaN()</codeph> при различных типах и значениях ввода. (Если для предупреждений компилятора задан «Строгий режим», некоторые из следующих операций вызовут появление предупреждений компилятора.)</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Тип/значение ввода</entry><entry>Пример</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	     <entry>0, разделенный на 0</entry>
	     <entry><codeph>isNaN(0/0)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Число, отличное от ноля, разделенное на <codeph>0</codeph></entry>
	     <entry><codeph>isNaN(5/0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Квадратный корень отрицательного числа</entry>
	     <entry><codeph>isNaN(Math.sqrt(-1))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Арксинус числа, которое больше 1 или меньше 0</entry>
	     <entry><codeph>isNaN(Math.asin(2))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>Строка, которую можно преобразовать в тип данных Number</entry>
	     <entry><codeph>isNaN("5")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Строка, которую невозможно преобразовать в тип данных Number</entry>
	     <entry><codeph>isNaN("5a")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isXMLName"><apiName>isXMLName</apiName><shortdesc>
	 Определяет, является ли заданная строка допустимым именем для элемента или атрибута XML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Возвращает <codeph>true</codeph>, если аргументом <codeph>str</codeph> является действительное имя XML. В противном случае возвращается <codeph>false</codeph>.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Оцениваемая строка.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, является ли заданная строка допустимым именем для элемента или атрибута XML.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseFloat"><apiName>parseFloat</apiName><shortdesc>
	 Преобразует строку в число с плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Число или значение <codeph>NaN</codeph> (нечисловое).
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, которая считывается и преобразуется в число с плавающей запятой.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует строку в число с плавающей запятой. Эта функция считывает или <i>выполняет анализ</i> чисел, которые возвращаются в виде строки до тех пор, пока не доходит до символа, который не входит в исходное число. Если строка не начинается с числа, которое можно проанализировать, <codeph>parseFloat()</codeph> возвращает значение <codeph>NaN</codeph>. Символ пробела, указанный перед допустимыми целыми числами, игнорируется так же, как и нечисловые символы после них.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseInt"><apiName>parseInt</apiName><shortdesc>
	 Преобразует строку в целое число.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Число или значение <codeph>NaN</codeph> (нечисловое).
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, преобразуемая в целое число.
	 </apiDesc></apiParam><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число, представляющее основание (базу) разбираемого числа. Допускаются значения от 2 до 36.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует строку в целое число. Если указанную в параметрах строку не удается преобразовать в число, функция возвращает <codeph>NaN</codeph>. Строки, которые начинаются с 0x, считаются шестнадцатеричными числами. В отличие от предыдущих версий ActionScript целые числа, которые начинаются с 0 <i>не</i> рассматриваются в качестве восьмеричных. Для восьмеричных чисел указывается основание равное 8. Символы пробела и нули, стоящие перед целыми числами, игнорируются так же, как и нечисловые символы.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:trace"><apiName>trace</apiName><shortdesc>
	 Отображает выражения либо выполняет запись в файлы журнала во время отладки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Одно или несколько выражений для оценки, разделенных запятыми. Если указывается несколько выражений, между выводимыми выражениями вставляются пробелы.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает выражения либо выполняет запись в файлы журнала во время отладки. Единичная инструкция trace может поддерживать несколько аргументов. Если любой аргумент инструкции trace включает тип данных, отличающийся от String, функция trace вызывает связанный метод <codeph>toString()</codeph> для этого типа данных. Например, если аргумент – это логическое значение, функция trace вызывает метод <codeph>Boolean.toString()</codeph> и показывает возвращаемое значение. 
	 </apiDesc><example conref="examples\TraceExample.as"> В следующем примере класс <codeph>TraceExample</codeph> используется для того, чтобы показать, как метод <codeph>trace()</codeph> можно использовать для печати простой строки. Обычно это сообщение выводится на печать с помощью консоли «Отладка».
<codeblock>
package {
    import flash.display.Sprite;

    public class TraceExample extends Sprite {

        public function TraceExample() {
            trace("Hello World");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:uint"><apiName>uint</apiName><shortdesc>
	 Преобразует данное числовое значение в целочисленное значение без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Преобразованное целочисленное значение.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Значение, которое необходимо преобразовать в целочисленное.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует данное числовое значение в целочисленное значение без знака. Десятичные значения усекаются до целых чисел.
	 <p>В таблице ниже описано значение, возвращаемое <codeph>uint()</codeph> при различных типах и значениях ввода.</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>Тип/значение ввода</entry><entry>Пример</entry><entry>Возвращаемое значение</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>uint(undefined)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>uint(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>uint(0)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>uint(NaN)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Положительное число с плавающей запятой</entry>
	     <entry><codeph>uint(5.31)</codeph></entry>
	     <entry>Усеченное целое число без знака (например, <codeph>5</codeph>)</entry>
	   </row><row>
	     <entry>Отрицательное число с плавающей запятой</entry>
	     <entry><codeph>uint(-5.78)</codeph></entry>
	     <entry>Усекает целое число, а затем применяет правило для отрицательных целых чисел</entry>
	   </row><row>
	     <entry>Отрицательное число</entry>
	     <entry><codeph>uint(-5)</codeph></entry>
         <entry>Сумма значения <codeph>uint.MAX_VALUE</codeph> и отрицательного целого числа (например, <codeph>uint.MAX_VALUE + (-5)</codeph>)</entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>uint(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>uint(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Пустая строка</entry>
	     <entry><codeph>uint("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>Строка, преобразуемая в значение Number</entry>
	     <entry><codeph>uint("5")</codeph></entry>
	     <entry>Число</entry>
	   </row><row>
	     <entry>Строка, которая не преобразуется в значение Number</entry>
	     <entry><codeph>uint("5a")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row></tbody></tgroup></adobetable>

	 </apiDesc></apiOperationDetail><related-links><link href="#global/int()"><linktext>int()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:unescape"><apiName>unescape</apiName><shortdesc>
	 Вычисляет параметр str как строку, раскодирует строку из формата кодировки URL (с преобразованием всех шестнадцатеричных последовательностей в символы ASCII) и возвращает строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, полученная в результате раскодирования параметра в кодировке URL-адреса.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, где необходимо маскировать шестнадцатеричные последовательности.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Вычисляет параметр <codeph>str</codeph> как строку, раскодирует строку из формата кодировки URL (с преобразованием всех шестнадцатеричных последовательностей в символы ASCII) и возвращает строку.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="globalValue:Infinity"><apiName>Infinity</apiName><shortdesc>
 Специальное значение, представляющее плюс бесконечность.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Специальное значение, представляющее плюс <codeph>бесконечность</codeph>. Значение этой константы совпадает со значением <codeph>Number.POSITIVE_INFINITY</codeph>.
 </apiDesc><example conref="examples\Constants.Infinity.1.as"> Результатом деления на 0 является <codeph>бесконечность</codeph>, но лишь тогда, когда делитель – положительное число.
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/POSITIVE_INFINITY"><linktext>Number.POSITIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:-Infinity"><apiName>-Infinity</apiName><shortdesc>
 Специальное значение, представляющее минус бесконечность.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Специальное значение, представляющее минус <codeph>бесконечность</codeph>. Значение этой константы совпадает со значением <codeph>Number.NEGATIVE_INFINITY</codeph>.
 </apiDesc><example conref="examples\Constants.NegInfinity.1.as"> Результатом деления на 0 является <codeph>минус бесконечность</codeph>, но лишь тогда, когда делитель – отрицательное число.
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/NEGATIVE_INFINITY"><linktext>Number.NEGATIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:NaN"><apiName>NaN</apiName><shortdesc>
 Специальный элемент типа Number, представляющий значение NaN (не число).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Специальный элемент типа Number, представляющий значение NaN (<codeph>не число</codeph>). Когда результатом математического выражения является значение, которое невозможно представить в виде числа, ему присваивается обозначение <codeph>NaN</codeph>. В списке ниже описаны распространенные выражения, приводящие к появлению значения <codeph>NaN</codeph>.
 <ul>
   <li>В результате деления на 0 <codeph>NaN</codeph> указывается только тогда, когда делителем является также 0. Если делитель больше 0, результатом деления на 0 является <codeph><codeph>бесконечность</codeph></codeph>. Если делитель меньше 0, результатом деления на 0 является <codeph><codeph>минус бесконечность</codeph></codeph>;</li>
   <li>квадратный корень отрицательного числа;</li>
   <li>арксинус числа за пределами действительного диапазона от 0 до 1;</li>
   <li><codeph>бесконечность</codeph>, отнятая от <codeph>бесконечности</codeph>;</li>
   <li><codeph>бесконечность</codeph> или <codeph>минус бесконечность</codeph>, деленная на <codeph>бесконечность</codeph> или <codeph>минус бесконечность</codeph>;</li>
   <li><codeph>Infinity</codeph> или <codeph>-Infinity</codeph>, умноженная на 0;</li>
  </ul>
 <p>Значение <codeph>NaN</codeph> не принадлежит типам данных int или uint.</p>
 <p>Значение <codeph>NaN</codeph> не считается равным какому-либо другому значению, включая <codeph>NaN</codeph>. По этой причине невозможно проверить с помощью оператора равенства, имеет ли выражение значение <codeph>NaN</codeph>. Чтобы определить, является ли число функцией <codeph>NaN</codeph>, воспользуйтесь функцией <codeph>isNaN()</codeph>.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="#global/isNaN()"><linktext>isNaN()</linktext></link><link href="#Number/NaN"><linktext>Number.NaN</linktext></link></related-links></apiValue><apiValue id="globalValue:undefined"><apiName>undefined</apiName><shortdesc>
 Специальное значение, применяемое к неинициализированным переменным без типа или неинициализированным свойствам динамического объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
 Специальное значение, применяемое к неинициализированным переменным без типа или неинициализированным свойствам динамического объекта. В ActionScript 3.0 только переменные без определенного типа могут сохранять значение <codeph>undefined</codeph> в отличие от ActionScript 1.0 и ActionScript 2.0. Например, обе следующие переменные являются <codeph>undefined</codeph>, так как для них не определен тип, и они не инициализированы:
 <ul>
   <li><codeph>var foo;</codeph></li>
   <li><codeph>var bar:~~;</codeph></li>
 </ul>
 <p>Значение <codeph>undefined</codeph> применяется также к неинициализированным или неопределенным свойствам динамических объектов. Например, если в роли объекта выступает экземпляр класса Object, значением любого динамически добавленного свойства является <codeph>undefined</codeph> до тех пор, пока данному свойству не будет присвоено значение.
 </p>
 <p>Если значение <codeph>undefined</codeph> используется в сочетании с разными функциями, результаты варьируют:</p>
 <ul>
 <li><codeph>String(undefined)</codeph> возвращает значение <codeph>"undefined"</codeph> (<codeph>undefined</codeph> преобразуется в строку).</li> 
 <li><codeph>Number(undefined)</codeph> возвращает значение <codeph>NaN</codeph>.</li> 
 <li><codeph>int(undefined)</codeph> и <codeph>uint(undefined)</codeph> возвращают 0.</li>
 <li><codeph>Object(undefined)</codeph> возвращает значение в виде нового экземпляра Object.</li>
 <li>Если значение <codeph>undefined</codeph> присвоено переменной определенного типа, оно преобразуется в значение по умолчанию для этого типа данных.</li>
 </ul>
 <p>Не путайте значения <codeph>undefined</codeph> и <codeph>null</codeph>. Если значения <codeph>null</codeph> и <codeph>undefined</codeph> сравниваются с оператором равенства (<codeph>==</codeph>), они считаются равными. Однако когда значения <codeph>null</codeph> и <codeph>undefined</codeph> сравниваются с оператором строгого равенства (<codeph>===</codeph>), они не рассматриваются как равные.</p>
 </apiDesc><example conref="examples\Constants.undefined.1.as"> В следующем примере объявляется, но не инициализируется переменная без типа <codeph>myVar</codeph>. Переменная <codeph>myVar</codeph> принимает значение <codeph>undefined</codeph>, так как не относится к какому-либо типу. Это происходит, когда эта переменная не имеет аннотации с указанием типа или снабжена специальной аннотацией (~~) об отсутствии типа (<codeph>var myVar:~~;</codeph>).
<codeblock>

// trace value of untyped and uninitialized variable
var myVar;
trace(myVar); // undefined
</codeblock></example><example conref="examples\Constants.undefined.2.as"> То же самое правило применяется к неинициализированным свойствам динамического объекта. Например, если имеется экземпляр <codeph>obj</codeph> динамического класса <codeph>A</codeph>, неинициализированному свойству <codeph>obj.propName</codeph> экземпляра <codeph>obj</codeph> присваивается значение <codeph>undefined</codeph>.
<codeblock>

dynamic class A {}
var obj:A = new A()

// trace undefined property of obj
trace(obj.propName); // undefined

</codeblock></example></apiValueDetail><related-links><link href="statements.html#null"><linktext>null</linktext></link></related-links></apiValue><apiClassifier id="globalClassifier:uint"><apiName>uint</apiName><shortdesc>
 В классе uint предусмотрены методы для работы с типом данных, представляющим 32-разрядное число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint object, uint, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 В классе uint предусмотрены методы для работы с типом данных, представляющим 32-разрядное число без знака. Поскольку целое число без знака может быть только положительным, его максимальное значение вдвое превышает максимальное значение класса int.
 <p>Диапазон значений представленных классом uint составляет от 0 до 4294967295 (2 в степени 32 - 1).</p>
 <p>Объект uint можно создать, объявив переменную типа uint и присвоив ей литеральное значение. Значение по умолчанию переменной типа uint составляет <codeph>0</codeph>.</p>
 <p>Класс uint в основном используется для значений цветов пикселей (ARGB и RGBA) и других ситуаций, когда данные типа int неэффективны. Например, число 0xFFFFFFFF, представляющее собой значение белого цвета со значением альфа, которое равно 255, не может выражаться данными типа int, потому что оно не находится в действительном диапазоне значений int.</p> 
 
 <p>В следующем примере создается объект uint и вызывается метод <codeph> toString()</codeph>:</p>
 <pre>
 var myuint:uint = 1234;
 trace(myuint.toString()); // 1234
 </pre>
 <p>В следующем примере значение свойства <codeph>MIN_VALUE</codeph> присваивается переменной без использования конструктора:</p>
 <pre>
 var smallest:uint = uint.MIN_VALUE;
 trace(smallest.toString()); // 0
 </pre> 
 
 </apiDesc><example conref="examples\UintExample.as"> В следующем примере объявляется значение uint <codeph>i</codeph> в цикле <codeph>for</codeph>, который выводит на печать цифры от 0 до 9 (поскольку значение uint по умолчанию равно 0).
<codeblock>

package {
    import flash.display.Sprite;

    public class UintExample extends Sprite {
        public function UintExample() {
            for(var i:uint; i &lt; 10; i++) {
                trace(i);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="uint:uint"><apiName>uint</apiName><shortdesc>
	 Создает новый объект uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Числовое значение создаваемого объекта uint или значение, которое должно быть преобразовано в число. Если значение <codeph>num</codeph> не указано, значение по умолчанию равно <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект uint. Можно создать переменную типа uint и присвоить ей значение литерала. Конструктор <codeph>new uint()</codeph> используется в основном в качестве заполнителя. Объект uint не аналогичен функции <codeph> uint()</codeph>, которая преобразует параметр в элементарное значение.
	 
	 </apiDesc><example>Следующий код приводит к созданию двух новых объектов uint; первый создается путем присвоения литерального значения, а второй – путем использования функции конструктора:
	 <pre>
	 var n1:uint = 3;
	 var n2:uint = new uint(10);
	 </pre>
	 
	 </example></apiConstructorDetail></apiConstructor><apiOperation id="uint:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      Возвращает экспоненциальное строковое представление числа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>fractionDigits</codeph> выходит за пределы диапазона от 0 до 20.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 0 до 20 включительно, которое соответствует необходимому количеству регистров после запятой.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Возвращает экспоненциальное строковое представление числа. Строка содержит одну цифру перед запятой и до 20 цифр после запятой, как указано в параметре <codeph>fractionDigits</codeph>.
      </apiDesc><example conref="examples\Number.toExponential.1.as"> В следующем примере показано, как <codeph>toExponential(2)</codeph> возвращает строку в экспоненциальном представлении.
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     Возвращает строковое представление числа в нотации с фиксированной запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>fractionDigits</codeph> выходит за пределы диапазона от 0 до 20.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 0 до 20 включительно, которое соответствует необходимому количеству регистров после запятой.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает строковое представление числа в нотации с фиксированной запятой. Представление с фиксированной запятой означает, что строка будет содержать определенное количество цифр после запятой, исходя из значения параметра <codeph>fractionDigits</codeph>. Действительный диапазон параметра <codeph>fractionDigits</codeph>составляет от 0 до 20. Выбор значения за пределами этого диапазона приводит к созданию исключения.
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> В следующем примере показано, как <codeph>toFixed(3)</codeph> возвращает строку, которая округляется до трех цифр после запятой.
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> В следующем примере показано, как <codeph>toFixed(2)</codeph> возвращает строку, добавляющую в конце нули.
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      Возвращает строковое представление числа в нотации с фиксированной запятой либо в экспоненциальной нотации.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Выдает исключение, если аргумент <codeph>precision</codeph> выходит за пределы диапазона от 1 до 21.
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число от 1 до 21 включительно, которое представляет необходимое количество цифр в строке результатов.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Возвращает строковое представление числа в нотации с фиксированной запятой либо в экспоненциальной нотации. Строка будет содержать количество цифр, указанное в параметре <codeph>precision</codeph>.
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> В следующем примере показано, как <codeph>toPrecision(3)</codeph> возвращает строку только с тремя цифрами. Эта строка представлена в нотации с фиксированной запятой, поскольку экспоненциальная нотация не требуется.
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> В следующем примере показано, как <codeph>toPrecision(3)</codeph> возвращает строку только с тремя цифрами. Строка представлена в экспоненциальной нотации, поскольку итоговое число не содержит достаточно цифр для нотации с фиксированной запятой.
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toString"><apiName>toString</apiName><shortdesc>
	 Возвращает строковое представление объекта uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строковое представление объекта uint.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Указывает числовую основу (от 2 до 36), используемую при преобразовании чисел в строку. Если параметр <codeph>radix</codeph> не указан, значение по умолчанию равно <codeph>10</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строковое представление объекта uint.
	 
     </apiDesc><example>В следующем примере для параметров <codeph>radix</codeph> выбраны значения 2 и 8. При этом возвращается строковое значение с соответствующим представлением цифры 9:
	 <pre>
	 var myuint:uint = 9;
	 trace(myuint.toString(2)); // 1001
	 trace(myuint.toString(8)); // 11
	 </pre>
	 В примере ниже создаются шестнадцатеричные значения:
	 <pre>
	 var r:uint = 250;
	 var g:uint = 128;
	 var b:uint = 114;
	 var rgb:String = "0x" + r.toString(16) + g.toString(16) + b.toString(16);
	 trace(rgb); // 0xfa8072 
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 Возвращает элементарное значение типа uint для заданного объекта uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Элементарное значение типа uint объекта uint.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает элементарное значение типа uint для заданного объекта uint.
	 
	 </apiDesc><example>В следующем примере указано элементарное значение объекта <codeph>numSocks</codeph>.
	 <pre>
	 var numSocks:uint = 2;
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="uint:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	Наибольшее представимое 32-разрядное целое число без знака, а именно 4 294 967 295.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4294967295</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
	Наибольшее представимое 32-разрядное целое число без знака, а именно 4 294 967 295.
	
   	</apiDesc><example>Следующий ActionScript показывает самое большое и самое маленькое представимое значение <codeph>uint</codeph>:
	<pre>
	trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	</pre>
	<p>Имеются следующие значения:</p>
	<pre>
	uint.MIN_VALUE = 0
	uint.MAX_VALUE = 4294967295
	</pre>
	
	</example></apiValueDetail></apiValue><apiValue id="uint:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 Наименьшее представимое целое число без знака, а именно 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Наименьшее представимое целое число без знака, а именно <codeph>0</codeph>.
	 
	 </apiDesc><example>Следующий ActionScript показывает самое большое и самое маленькое представимое значение <codeph>uint</codeph>:
	 <pre>
	 trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	 trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	 </pre>
	 <p>Имеются следующие значения:</p>
	 <pre>
	 uint.MIN_VALUE = 0
	 uint.MAX_VALUE = 4294967295
	 </pre>
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Vector"><apiName>Vector</apiName><shortdesc>
 Класс Vector позволяет вызвать и обработать вектор &amp;#8212, массив, элементы которого относятся к одному и тому же типу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector, Vector object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Позволяет определять векторы (массивы однотипных данных)
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Vector позволяет открывать и манипулировать векторами (массивами, все элементы которых относятся к одному и тому же типу). Тип данных элементов Vector известен как <i>базовый тип</i> Vector. Базовый тип может принадлежать любому классу, включая встроенные и пользовательские классы. Базовый тип указывается при объявлении переменной Vector, а также при создании экземпляра путем вызова конструктора класса.
 
 <p>Как и в случае с объектом Array, можно использовать оператор доступа к массиву (<codeph>[]</codeph>), чтобы задать или определить значение элемента Vector. Несколько методов вектора также имеют механизмы присвоения и определения значений переменных. В их число среди прочих входят методы <codeph>push()</codeph>, <codeph>pop()</codeph>, <codeph>shift()</codeph>, <codeph>unshift()</codeph>. Свойства и методы объекта Vector подобны (и в большинстве случаев идентичны) свойствам и методам объекта Array. В любом случае, когда используется объект Array, все элементы которого относятся к одному и тому же типу данных, предпочтительным является экземпляр Vector.</p>
 
 <p>Базовый тип вектора указывается с помощью постфиксного синтаксиса параметров. Синтаксис параметра типа представляет собой последовательность, состоящую из точки (<codeph>. </codeph>), открывающей угловой скобки (<codeph>&lt;</codeph>), имени класса и закрывающей угловой скобки (<codeph>></codeph>), как показано в примере:</p>
 
 <codeblock>
 var v:Vector.&lt;String>;
 v = new Vector.&lt;String>();
 </codeblock>
 
 <p>В первой строке примера переменная <codeph>v</codeph> объявлена как Vector. Экземпляр &lt;String>. Другими словами, он представляет вектор (массив), который может содержать лишь экземпляры String и из которого можно извлечь только них. Вторая строка создает экземпляр того же типа вектора (вектор, все элементы которого являются объектами String) и присваивает его <codeph>v</codeph>.</p>
 
 <p>Переменная, объявленная вместе с экземпляром вектора. Тип данных &lt;T> может хранить экземпляр Vector только в том случае, если он создан с идентичным базовым типом <codeph>T</codeph>. Например, вектор, созданный путем вызова метода<codeph>new Vector. &lt;String>()</codeph> нельзя присвоить переменной, которая объявлена вместе с ним. Тип данных &lt;int>. Базовые типы должны быть полностью идентичны. Например, следующий код не компилируется, поскольку базовый тип объекта отличается от базового типа, объявленного для переменной (несмотря на то, что Sprite – подкласс класса DisplayObject):</p>
 
 <codeblock>
 // This code doesn't compile even though Sprite is a DisplayObject subclass
 var v:Vector.&lt;DisplayObject> = new Vector.&lt;Sprite>();
 </codeblock>
 
 <p>Чтобы преобразовать вектор с базовым типом <codeph>T</codeph> в вектор суперкласса <codeph>T</codeph>, воспользуйтесь глобальной функцией <codeph>Vector()</codeph>.</p>
 
 <p>Помимо ограничения, связанного с типом данных, класс Vector имеет другие ограничения, которые отличают его от класса Array:</p>
 
 <ul>
   <li>Вектор принадлежит к числу плотных массивов. В отличие от объекта Array, который может иметь значения с индексами 0 и 7 даже в том случае, когда на позициях с 1 по 6 значений нет, Vector должен иметь значения (или значение <codeph>null</codeph>) на каждой позиции индекса.</li>
   <li>Вектор может иметь фиксированную длину. Это означает, что число содержащихся в нем элементов не может изменяться.</li>
   <li>Доступ к элементам вектора осуществляется с контролем границ. Вам никогда не удастся прочесть значение с индексом, превышающим индекс финального элемента (<codeph>length - 1</codeph>). Вам также не удастся задать значение, индекс которого превышает текущий последний индекс (иначе говоря, значение можно присваивать только с существующим индексом или с индексом <codeph>[length]</codeph>).</li>
 </ul>
 
 <p>В результате этих ограничений экземпляр Vector имеет два основных преимущества перед экземпляром Array, все элементы которого представляют собой экземпляры одного класса:</p>
 <ul>
   <li>Производительность: доступ к массиву и итерация осуществляются гораздо быстрее при использовании экземпляра Vector, чем при использовании экземпляра Array.</li>
   <li>Безопасность типов: в строгом режиме компилятор может идентифицировать ошибки типов данных (например, присвоение вектору значения, имеющего неверный тип данных, или ожидание неверного типа данных при считывании значения из вектора). Учтите однако, что при использовании метода <codeph>push()</codeph> или <codeph>unshift()</codeph> для добавления значений в вектор типы данных для аргументов проверяются не во время компиляции, а во время выполнения.</li>
 </ul> 
 
 </apiDesc></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] array access</linktext></link><link href="#global/Vector()"><linktext>Функция Vector()</linktext></link><link href="#Array"><linktext>Класс Array</linktext></link></related-links><apiConstructor id="Vector:Vector"><apiName>Vector</apiName><shortdesc>
	 Создает вектор с указанным базовым типом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Исходная длина (число элементов) вектора. Если этот параметр больше нуля, создается указанное число элементов вектора со значениями по умолчанию для данного базового типа (для ссылочных типов – <codeph>null</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fixed</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Независимо от того, фиксированная ли длина вектора (<codeph>true</codeph>) или ее можно изменять (<codeph>false</codeph>). Значение также можно задать с помощью свойства <codeph>fixed</codeph>.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает вектор с указанным базовым типом.
	 
	 <p>При вызове конструктора <codeph>Vector. &lt;T>()</codeph> укажите базовый тип с помощью синтаксиса параметра типа. Синтаксис параметра типа представляет собой последовательность, состоящую из точки (<codeph>. </codeph>), открывающей угловой скобки (<codeph>&lt;</codeph>), имени класса и закрывающей угловой скобки (<codeph>></codeph>), как показано в примере:</p>
	 
	 <pre product="flash">
	 var v:Vector.&lt;String> = new Vector.&lt;String>();
	 </pre>
	 
	 <p>В отличие от класса Array конструктор <codeph>Vector. &lt;T>()</codeph> нельзя использовать для создания предварительно заполненного экземпляра Vector. Чтобы создать экземпляр Vector на основе экземпляра Array или другого экземпляра Vector (который, например, имеет другой базовый тип), воспользуйтесь глобальной функцией <codeph>Vector()</codeph>.</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="#global/Vector()"><linktext>Функция Vector()</linktext></link></related-links></apiConstructor><apiOperation id="Vector:AS3:concat"><apiName>concat</apiName><shortdesc>
     Указанные в параметрах элементы сцепляются с элементами в векторе, и создается новый вектор.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.concat, concat, concatenate
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Если какой-либо аргумент не является экземпляром базового типа, и его невозможно преобразовать в базовый тип.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Вектор с тем же базовым типом, что и данный вектор, содержащий элементы данного вектора, вслед за которыми указываются элементы из параметров.
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Одно или несколько значений базового типа данного вектора, которые сцепляются с новым вектором. Если значения не передаются, новый вектор дублирует исходный вектор.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Сцепляет элементы, заданные в параметрах.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Указанные в параметрах элементы сцепляются с элементами в векторе, и создается новый вектор. Если параметры задают вектор, элементы этого вектора сцепляются. 
	 
	 <codeblock>hello world</codeblock>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:every"><apiName>every</apiName><shortdesc>
	Выполняет тестовую функцию для каждого элемента вектора, пока не будет достигнут элемент, возвращающий значение false для заданной функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Логическое значение <codeph>true</codeph>, если указанная функция возвращает <codeph>true</codeph> при вызове по отношению ко всем элементам вектора. В противном случае возвращается <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом вектора. Эта функция вызывается с тремя аргументами: текущим элементом из вектора, индексом элемента и объектом Vector.
	<pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre> 
	
	<p>Функция обратного вызова должна возвращать логическое значение.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, к которому относится идентификатор <codeph>this</codeph> в функции обратного вызова при ее вызове.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Выполняет тестовую функцию для каждого элемента вектора, пока не будет достигнут элемент, возвращающий значение <codeph>false</codeph> для заданной функции. Этот метод используется для того, чтобы определить, все ли элементы вектора соответствуют критерию (например, их значения должны быть меньше определенного числа).
	
	<p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Чаще всего данный метод используется именно так.</p>
	
	<p product="flash">Однако предположим, что вы создаете функцию для кадра на основной временной шкале с помощью Flash Professional, но хотите, чтобы она вызывалась в другом контексте <codeph>this</codeph>:</p>
	
	<pre product="flash">
	function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre>
	
	<p product="flash">Допустим, что используется метод <codeph>every()</codeph> по отношению к вектору <codeph>myVector</codeph>:</p>
	
	<pre product="flash">
	myVector.every(myFunction, someObject);
	</pre>
	
	<p product="flash">Поскольку функция <codeph>myFunction</codeph> принадлежит основному классу этого SWF-файла, ее нельзя выполнить с другим контекстом <codeph>this</codeph>. Flash Player или AIR выдает исключение при выполнении этого кода. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
	
	<pre product="flash">
	var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	    //your code here
	};
	myVector.every(myFunction, someObject);
	</pre>
	
	</apiDesc></apiOperationDetail><related-links><link href="#Vector/some()"><linktext>Vector.some()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:filter"><apiName>filter</apiName><shortdesc>
     Выполняет тестовую функцию для каждого элемента вектора и формирует новый вектор из всех элементов, возвращающих значение true для заданной функции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новый вектор, содержащий все элементы исходного вектора, для которого функция <codeph>обратного вызова</codeph> возвратила значение <codeph>true</codeph>.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом вектора. Эта функция вызывается с тремя аргументами: текущим элементом из вектора, индексом элемента и объектом Vector.
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, к которому относится идентификатор <codeph>this</codeph> в функции обратного вызова при ее вызове.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет тестовую функцию для каждого элемента вектора и формирует новый вектор из всех элементов, возвращающих значение <codeph>true</codeph> для заданной функции. Если элемент возвращает значение <codeph>false</codeph>, он не включается в получившийся вектор. Базовый тип возвращаемого вектора совпадает с базовым типом вектора, по которому вызывается метод.
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Чаще всего данный метод используется именно так.</p>
	 
	 <p product="flash">Однако предположим, что вы создаете функцию для кадра на основной временной шкале с помощью Flash Professional, но хотите, чтобы она вызывалась в другом контексте <codeph>this</codeph>:</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">Допустим, что используется метод <codeph>filter()</codeph> по отношению к вектору <codeph>myVector</codeph>:</p>
	 
     <pre product="flash">
     var result:Vector.&lt;T> = myVector.filter(myFunction, someObject);
     </pre>
	 
     <p product="flash">Поскольку функция <codeph>myFunction</codeph> принадлежит основному классу этого SWF-файла, ее нельзя выполнить с другим контекстом <codeph>this</codeph>. Flash Player выдает исключение при выполнении этого кода. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.filter(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/map()"><linktext>Vector.map()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:forEach"><apiName>forEach</apiName><shortdesc>
     Выполняет функцию для каждого элемента вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом вектора. Эта функция вызывается с тремя аргументами: текущим элементом из вектора, индексом элемента и объектом Vector.
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):void;</pre>
	 <p>Любое возвращаемое в результате вызова функции значение пропускается.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, к которому относится идентификатор <codeph>this</codeph> в функции обратного вызова при ее вызове.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет функцию для каждого элемента вектора.
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Чаще всего данный метод используется именно так.</p>
	 
	 <p product="flash">Однако предположим, что вы создаете функцию для кадра на основной временной шкале с помощью Flash Professional, но хотите, чтобы она вызывалась в другом контексте <codeph>this</codeph>:</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):void {
        // your code here
     }
     </pre>
	 
     <p product="flash">Допустим, что используется метод <codeph>forEach()</codeph> по отношению к вектору <codeph>myVector</codeph>:</p>
	 
     <pre product="flash">
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     <p product="flash">Поскольку функция <codeph>myFunction</codeph> принадлежит основному классу этого SWF-файла, ее нельзя выполнить с другим контекстом <codeph>this</codeph>. Flash Player выдает исключение при выполнении этого кода. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
     Выполняет поиск элемента в векторе и возвращает позицию индекса элемента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Позиция индекса, начинающегося с нуля, для элемента вектора. Если аргумент <codeph>searchElement</codeph> не найден, возвращается значение «-1».
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>Элемент, который нужно найти в векторе.
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Место в векторе, с которого начинается поиск элемента. Если этот параметр имеет отрицательное значение, он воспринимается как <codeph>length + fromIndex</codeph>. Это означает, что поиск начинается с <codeph>-fromIndex</codeph> элементов с конца и продолжается с этой позиции вплоть до конца вектора.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет поиск элемента в векторе и возвращает позицию индекса элемента. Этот элемент сравнивается с элементами вектора с помощью строгого равенства (<codeph>===</codeph>).
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/lastIndexOf()"><linktext>Vector.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:join"><apiName>join</apiName><shortdesc>
     Преобразует элементы вектора в строки, вставляет указанный разделитель между элементами, сцепляет их и возвращает получившуюся строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.join, join
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Строка, состоящая из элементов вектора, преобразованных в строки и разделенных указанной строкой.
     
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>,</apiData><apiDesc>Символ или строка, которые разделяют элементы вектора в возвращенной строке. Если этот параметр пропустить, в качестве разделителя по умолчанию используется запятая. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Преобразует элементы вектора в строки.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Преобразует элементы вектора в строки, вставляет указанный разделитель между элементами, сцепляет их и возвращает получившуюся строку. Вложенный вектор всегда разделяется запятой (,), а не разделителем, переданным методу <codeph>join()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
     Поиск элемента в векторе, выполняемый в обратном направлении от указанной позиции индекса, и возврат позиции индекса совпадающего элемента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Позиция индекса, начинающегося с нуля, для элемента вектора. Если аргумент <codeph>searchElement</codeph> не найден, возвращается значение «-1».
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>Элемент, который нужно найти в векторе.
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>Место в векторе, с которого начинается поиск элемента. Значением по умолчанию является максимально разрешенное значение индекса, что означает, что поиск начинается с последнего элемента вектора.
	 <p>Если этот параметр имеет отрицательное значение, он воспринимается как <codeph>length + fromIndex</codeph>. При этом поиск начинается с <codeph>-fromIndex</codeph> элементов с конца и выполняется с этой позиции в обратном направлении до индекса 0.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Поиск элемента в векторе, выполняемый в обратном направлении от указанной позиции индекса, и возврат позиции индекса совпадающего элемента. Этот элемент сравнивается с элементами вектора с помощью строгого равенства (<codeph>===</codeph>).
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/indexOf()"><linktext>Vector.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:map"><apiName>map</apiName><shortdesc>
     Выполняет функцию, относящуюся к каждому элементу вектора, и возвращает новый вектор, состоящий из элементов, соответствующих результатам вызова функции, которая выполняется для каждого элемента данного вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Новый вектор, который содержит результаты вызова функции для каждого элемента данного вектора. Итоговый вектор имеет тот же базовый тип и <codeph>length</codeph>, что и исходный.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом вектора. Эта функция вызывается с тремя аргументами: текущим элементом из вектора, индексом элемента и объектом Vector.
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):T;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, к которому относится идентификатор <codeph>this</codeph> в функции обратного вызова при ее вызове.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет функцию, относящуюся к каждому элементу вектора, и возвращает новый вектор, состоящий из элементов, соответствующих результатам вызова функции, которая выполняется для каждого элемента данного вектора. Итоговый вектор имеет тот же базовый тип и <codeph>length</codeph>, что и исходный. Элемент с индексом <codeph>i</codeph> в получаемом векторе является результатом вызова элемента с индексом <codeph>i</codeph> в исходном векторе.
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Чаще всего данный метод используется именно так.</p>
	 
	 <p product="flash">Однако предположим, что вы создаете функцию для кадра на основной временной шкале с помощью Flash Professional, но хотите, чтобы она вызывалась в другом контексте <codeph>this</codeph>:</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):T {
        // your code here
     }
     </pre>
	 
     <p product="flash">Допустим, что используется метод <codeph>map()</codeph> по отношению к вектору <codeph>myVector</codeph>:</p>
	 
     <pre product="flash">
     myVector.map(myFunction, someObject);
     </pre>
	 
     <p product="flash">Поскольку функция <codeph>myFunction</codeph> принадлежит к основному классу этого SWF-файла, ее нельзя выполнить с другим контекстом <codeph>this</codeph>. Flash Player выдает исключение при выполнении этого кода. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.map(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/filter()"><linktext>Vector.filter()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:pop"><apiName>pop</apiName><shortdesc>
     Удаляет последний элемент из вектора и возвращает его.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.pop, pop
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Если метод вызывается при значении <codeph>true</codeph> параметра <codeph>fixed</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение последнего элемента в указанном векторе.
	 
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет последний элемент из вектора и возвращает его. Значение свойства <codeph>length</codeph> этого вектора уменьшается на 1 при вызове этой функции.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:push"><apiName>push</apiName><shortdesc>
     Добавляет один или несколько элементов в конец вектора и возвращает новую длину вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.push, push
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Если какой-либо аргумент не является экземпляром базового типа <codeph>T</codeph> вектора.
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Если метод вызывается при значении <codeph>true</codeph> параметра <codeph>fixed</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Длина вектора после добавления новых элементов.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Одно или несколько значений, добавляемых в вектор.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет один или несколько элементов в конец вектора и возвращает новую длину вектора.
	 
	 <p>Поскольку эта функция поддерживает несколько аргументов, тип данных этих аргументов не проверяется во время компиляции даже тогда, когда она выполняется в строгом режиме. Однако, если передан аргумент, который не является экземпляром базового типа, во время выполнения возникает исключение.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:reverse"><apiName>reverse</apiName><shortdesc>
     Меняет порядок элементов вектора на обратный.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.reverse, reverse
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Вектор, элементы которого представлены в обратном порядке.
	 
     </apiDesc><apiType value="Vector$T"/></apiReturn></apiOperationDef><apiDesc>
     Меняет порядок элементов вектора на обратный. Этот метод изменяет вектор, для которого он вызывается.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:shift"><apiName>shift</apiName><shortdesc>
     Удаляет последний элемент из вектора и возвращает этот элемент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.shift, shift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Если <codeph>fixed</codeph> принимает значение <codeph>true</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Первый элемент вектора.
     
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет последний элемент из вектора и возвращает этот элемент. Оставшиеся элементы вектора перемещаются с исходной позиции «i» на позицию «i-1».
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:slice"><apiName>slice</apiName><shortdesc>
     Возвращает новый вектор, состоящий из диапазона элементов исходного вектора, не модифицируя исходный вектор.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.slice, slice
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Вектор, состоящий из диапазона элементов исходного вектора.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Число, указывающее на индекс начальной позиции среза. Если <codeph>startIndex</codeph> – отрицательное число, начальной позицией становится конец вектора, последнему элементу которого присваивается позиция «-1».  
     
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>Число, указывающее на индекс конечной позиции среза. Если этот параметр пропустить, срез включает все элементы от начальной позиции до конца вектора. Если <codeph>endIndex</codeph> – отрицательное число, конечная позиция указывается с конца вектора, последнему элементу которого присваивается позиция «-1».
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает новый вектор, состоящий из диапазона элементов исходного вектора.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Возвращает новый вектор, состоящий из диапазона элементов исходного вектора, не модифицируя исходный вектор. Возвращенный вектор включает элемент <codeph>startIndex</codeph> и все элементы вплоть до него, исключая элемент <codeph>endIndex</codeph>.
	 
     <p>Если параметры не переданы, создается дубликат исходного вектора.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:some"><apiName>some</apiName><shortdesc>
     Выполняет тестовую функцию для каждого элемента вектора, пока не будет достигнут элемент, возвращающий значение true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Логическое значение <codeph>true</codeph> присваивается, если какие-либо элементы в векторе возвращают значение <codeph>true</codeph> для указанной функции; в противном случае присваивается значение <codeph>false</codeph>.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция, выполняемая с каждым элементом вектора. Эта функция вызывается с тремя аргументами: текущим элементом из вектора, индексом элемента и объектом Vector.
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean</pre> 
     
     <p>Функция обратного вызова должна возвращать логическое значение.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, к которому относится идентификатор <codeph>this</codeph> в функции обратного вызова при ее вызове.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет тестовую функцию для каждого элемента вектора, пока не будет достигнут элемент, возвращающий значение <codeph>true</codeph>. Этот метод используется для того, чтобы определить, все ли элементы вектора соответствуют критерию (например, их значения должны быть меньше определенного числа).
     
     <p product="flash">Второй параметр этого метода, <codeph>thisObject</codeph>, должен иметь значение <codeph>null</codeph>, если первый параметр, <codeph>callback</codeph>, завершает метод. Чаще всего данный метод используется именно так.</p>
	 
	 <p product="flash">Однако предположим, что вы создаете функцию для кадра на основной временной шкале, но хотите, чтобы она вызывалась в другом контексте <codeph>this</codeph>:</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">Допустим, что используется метод <codeph>some()</codeph> по отношению к вектору <codeph>myVector</codeph>:</p>
	 
     <pre product="flash">
     myVector.some(myFunction, someObject);
     </pre>
	 
     <p product="flash">Поскольку функция <codeph>myFunction</codeph> принадлежит к основному классу этого SWF-файла, ее нельзя выполнить с другим контекстом <codeph>this</codeph>. Flash Player выдает исключение при выполнении этого кода. Этой ошибки при выполнении можно избежать, присвоив функцию переменной следующим образом:</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.some(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:sort"><apiName>sort</apiName><shortdesc>
     Сортирует элементы вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.sort, sort
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Этот вектор, элементы которого расположены в новом порядке.
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>compareFunction</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Метод сравнения, определяющий поведение при сортировке.
	 
     <p>Указанный метод должен взять два аргумента базового типа (<codeph>T</codeph>) вектора и возвратить число:</p>
	 
	 <codeblock>function compare(x:T, y:T):Number {}</codeblock>
	 
	 <p>Логика функции <codeph>compareFunction</codeph> такова, что при наличии двух элементов <codeph>x</codeph> и <codeph>y</codeph> функция возвращает одно из следующих трех значений:</p>
	 
     <ul>
       <li>отрицательное число, если <codeph>x</codeph> стоит перед <codeph>y</codeph> после сортировки;</li>
       <li>0, если <codeph>x</codeph> равно <codeph>y</codeph>;</li>
       <li>положительное число, если элемент <codeph>x</codeph> должен следовать за <codeph>y</codeph> в отсортированной последовательности.</li>
     </ul>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Сортирует элементы вектора. Этот метод выполняет сортировку согласно функции, которая указана в параметре <codeph>compareFunction</codeph>.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:splice"><apiName>splice</apiName><shortdesc>
     Добавляет и удаляет элементы из вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.splice, splice
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Если аргументы <codeph>startIndex</codeph> и <codeph>deleteCount</codeph> указывают подлежащий удалению индекс, который находится за границами вектора.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Если этот метод вызывается, когда свойству <codeph>fixed</codeph> присвоено значение <codeph>true</codeph>, а операция <codeph>splice()</codeph> приводит к изменению <codeph>length</codeph> вектора.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Вектор, содержащий элементы, удаленные из исходного вектора.
     
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Целое число, указывающее индекс элемента в векторе, откуда начинается вставка или удаление. Чтобы указать позицию относительно конца вектора, можно использовать отрицательное число (например, «-1» – это последний элемент вектора).
	 
     </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целое число, указывающее количество удаляемых элементов. Это число включает элемент, указанный в параметре <codeph>startIndex</codeph>. Если значение параметра <codeph>deleteCount</codeph> не указано, метод удаляет все значения, начиная с элемента <codeph>startIndex</codeph> до последнего элемента в векторе. Если значение равно 0, элементы не удаляются.
	 
     </apiDesc></apiParam><apiParam><apiItemName>items</apiItemName><apiType value="restParam"/><apiDesc>Необязательный список, состоящий из одного или нескольких значений, разделенных запятыми, которые вставляется в вектор на позиции, указанной параметром <codeph>startIndex</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет и удаляет элементы из вектора. Этот метод изменяет вектор, не создавая копии.
	 
     <p><b>Примечание.</b> Чтобы переопределить этот метод в подклассе Vector, укажите для параметров значение <codeph>...args</codeph> как показано в примере:</p>
	 
     <pre>
     public override function splice(...args) {
       // your statements here
     }
     </pre>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     Возвращает строку, представляющую элементы указанного вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка с элементами вектора.
	 
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Возвращает строку, представляющую элементы указанного вектора. Каждый элемент в векторе, начиная с индекса 0 и заканчивая наибольшим индексом, преобразуется в сцепленную строку, разделенную запятыми. В рамках ActionScript 3.0 этот метод возвращает то же значение, что и метод <codeph>Vector.toString()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/toString()"><linktext>Vector.toString()</linktext></link></related-links></apiOperation><apiOperation id="Vector:toString"><apiName>toString</apiName><shortdesc>
     Возвращает строку, представляющую элементы вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.toString, toString
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка с элементами вектора.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Возвращает строку, представляющую элементы вектора. Каждый элемент в векторе, начиная с индекса 0 и заканчивая наибольшим индексом, преобразуется в сцепленную строку, разделенную запятыми. Чтобы указать пользовательский разделитель, примените метод <codeph>Vector.join()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Vector/join()"><linktext>Vector.join()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     Добавляет один или несколько элементов в начало вектора и возвращает новую длину вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.unshift, unshift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>Если какой-либо аргумент не является экземпляром базового типа <codeph>T</codeph> вектора.
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Если метод вызывается при значении <codeph>true</codeph> параметра <codeph>fixed</codeph>.
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Целое число, выражающее новую длину вектора.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>Один или несколько экземпляров базового типа вектора, которые вставляются в начало вектора.  
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет один или несколько элементов в начало вектора и возвращает новую длину вектора. Другие элементы вектора перемещаются с исходной позиции (i) на позицию (i + количество новых элементов).
     
	 <p>Поскольку эта функция поддерживает несколько аргументов, тип данных этих аргументов не проверяется во время компиляции даже тогда, когда она выполняется в строгом режиме. Однако, если передан аргумент, который не является экземпляром базового типа, во время выполнения возникает исключение.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link></related-links></apiOperation><apiValue id="Vector:fixed:get"><apiName>fixed</apiName><shortdesc>
     Указывает, можно ли изменить свойство length вектора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.fixed, fixed
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, можно ли изменить свойство <codeph>length</codeph> вектора. Если присвоено значение <codeph>false</codeph>, свойство <codeph>length</codeph> невозможно изменить. Это означает, что если свойству <codeph>fixed</codeph> присвоено значение <codeph>true</codeph>, следующие операции не разрешены:
	 
	 <ul>
	   <li>установка свойства <codeph>length</codeph> напрямую;</li>
	   <li>присвоение значения позиции индекса <codeph>length</codeph>;</li>
	   <li>вызов метода, изменяющего свойство <codeph>length</codeph>, включая
	     <ul>
	       <li><codeph>pop(),</codeph></li>
	       <li><codeph>push(),</codeph></li>
	       <li><codeph>shift(),</codeph></li>
	       <li><codeph>unshift(),</codeph></li>
	       <li><codeph>splice()</codeph> (если вызов метода <codeph>splice()</codeph> приводит к изменению <codeph>length</codeph> вектора).</li>
	     </ul>
	   </li>
	 </ul>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="Vector:length:get"><apiName>length</apiName><shortdesc>
     Диапазон действительных индексов, которые доступны в векторе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.length, length
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Если это свойство изменяется, когда свойству <codeph>fixed</codeph> присвоено значение <codeph>true</codeph>.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Если этому свойству присваивается значение, превышающее максимально допустимый индекс (2<sup>32</sup>).
	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Диапазон действительных индексов, которые доступны в векторе. Экземпляр вектора обладает позициями индекса вплоть до значения <codeph>length</codeph>, но не включает само это значение.
	 
	 <p>Каждому элементу вектора всегда присваивается либо экземпляр базового типа, либо значение <codeph>null</codeph>. Когда свойству <codeph>length</codeph> присваивается значение, которое превышает предыдущее значение, создаются дополнительные элементы, которые заполняются значениями по умолчанию, соответствующими базовому типу (<codeph>null</codeph> для ссылочных типов).</p>
	 
	 <p>Когда свойству <codeph>length</codeph> присваивается значение, которое меньше предыдущего значения, из вектора удаляются все значения с позициями индекса, которые превышают или равняются новому значению <codeph>length</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>