<?xml version="1.0"?>
<apiPackage id="flash.data"><apiName>flash.data</apiName><apiDetail/><apiClassifier id="flash.data:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
 Экземпляр SQLViewSchema используется для хранения сведений об определенном представлении базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLTableSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLViewSchema используется для хранения сведений об определенном представлении базы данных. Он содержит имя представления (свойство <codeph>name</codeph>), инструкцию SQL, используемую для создания представления (свойство <codeph>sql</codeph>) и сведения о столбцах представления (свойство <codeph>columns</codeph>).
 
 <p>Для получения сведений о схеме представления используется метод <codeph>SQLConnection.loadSchema()</codeph>, с помощью которого загружаются сведения о схеме. Следует предварительно убедиться, что в качестве аргумента <codeph>type</codeph> используются значение <codeph>null</codeph> или <codeph>SQLViewSchema</codeph>. В полученном экземпляре SQLSchemaResult свойство <codeph>views</codeph> содержит массив экземпляров SQLViewSchema, представляющих представления базы данных.</p>
 
 <p>Как правило, экземпляры SQLViewSchema не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLViewSchema:SQLViewSchema"><apiName>SQLViewSchema</apiName><shortdesc>
     Создает экземпляр SQLViewSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя связанной базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя вида.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Инструкция SQL, используемая для создания представления.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив экземпляров SQLColumnSchema, которые описывают столбцы данного представления.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLViewSchema. Как правило, конструктор SQLViewSchema не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.data:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
 Класс SQLColumnSchema используется для хранения сведений о характеристиках определенного столбца в таблице базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SQLColumnSchema используется для хранения сведений о характеристиках определенного столбца в таблице базы данных.
 
 <p>Для получения сведений о схеме данных одной или нескольких таблиц базы данных используется метод <codeph>SQLConnection.loadSchema()</codeph>, с помощью которого загружаются сведения о схеме. Следует предварительно убедиться, что аргумент <codeph>includeColumnSchema</codeph> имеет значение <codeph>true</codeph>. В результирующем экземпляре SQLSchemaResult определение каждой таблицы и каждого представления содержит свойство <codeph>columns</codeph> – массив экземпляров SQLColumnSchema, представляющих столбцы таблицы или представления.</p>
 
 <p>Как правило, экземпляры SQLColumnSchema не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLColumnSchema:SQLColumnSchema"><apiName>SQLColumnSchema</apiName><shortdesc>
     Создает экземпляр SQLColumnSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя столбца.
     
     </apiDesc></apiParam><apiParam><apiItemName>primaryKey</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Указывает, входит ли данный столбец в состав первичного ключа соответствующей таблицы.
     
     </apiDesc></apiParam><apiParam><apiItemName>allowNull</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Указывает, может ли данный столбец содержать значения <codeph>NULL</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoIncrement</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Указывает, является ли столбец автоинкрементным.
     
     </apiDesc></apiParam><apiParam><apiItemName>dataType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Объявленный тип столбца.
     
     </apiDesc></apiParam><apiParam><apiItemName>defaultCollationType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Порядок сортировки, определенный для данного столбца. Это значение соответствует одной из констант класса SQLCollationType:
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> означает, что в столбце используется порядок сортировки <codeph>BINARY</codeph>.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> означает, что в столбце используется порядок сортировки <codeph>NOCASE</codeph>, при котором сравнение текстов выполняется без учета регистра.</li>
     </ul>
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLColumnSchema. Как правило, конструктор SQLColumnSchema не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLColumnSchema:allowNull:get"><apiName>allowNull</apiName><shortdesc>
     Указывает, допустимы ли в данном столбце значения NULL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, допустимы ли в данном столбце значения <codeph>NULL</codeph>. У столбца, для которого объявлено ограничение <codeph>NOT NULL</codeph>, свойство <codeph>allowNull</codeph> имеет значение <codeph>false</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:autoIncrement:get"><apiName>autoIncrement</apiName><shortdesc>
     Указывает, является ли столбец автоинкрементным.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, является ли столбец автоинкрементным. Автоинкрементный столбец – это особый вид столбца <codeph>PRIMARY KEY</codeph>. Для него создается последовательность целых чисел, и значение этого столбца автоматически принимает значение следующего числа в последовательности, когда в таблицу добавляется новая строка.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:dataType:get"><apiName>dataType</apiName><shortdesc>
     Определяет тип данных столбца в виде строки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Определяет тип данных столбца в виде строки. Значение представляет собой символьное имя типа данных, указанное в инструкции <codeph>CREATE TABLE</codeph>, которая использовалась для определения таблицы, или <codeph>null</codeph>, если тип данных не был указан.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:defaultCollationType:get"><apiName>defaultCollationType</apiName><shortdesc>
     Указывает порядок сортировки данного столбца, используемый по умолчанию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает порядок сортировки данного столбца, используемый по умолчанию. Значение этого свойства соответствует одной из констант класса SQLCollationType:
     <ul>
       <li><codeph>SQLCollationType.BINARY</codeph> означает, что в столбце используется порядок сортировки <codeph>BINARY</codeph>.</li>
       <li><codeph>SQLCollationType.NO_CASE</codeph> означает, что в столбце используется порядок сортировки <codeph>NOCASE</codeph>, при котором сравнение текстов выполняется без учета регистра.</li>
     </ul>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLCollationType"><linktext>flash.data.SQLCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnSchema:name:get"><apiName>name</apiName><shortdesc>
     Определяет имя столбца.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Определяет имя столбца.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLColumnSchema:primaryKey:get"><apiName>primaryKey</apiName><shortdesc>
     Указывает, является ли столбец первичным ключом (или одним из столбцов, образующих составной ключ) соответствующей таблицы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, является ли столбец первичным ключом (или одним из столбцов, образующих составной ключ) соответствующей таблицы.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLColumnNameStyle"><apiName>SQLColumnNameStyle</apiName><shortdesc>
 Этот класс содержит константы, представляющие возможные значения свойства SQLConnection.columnNameStyle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс содержит константы, представляющие возможные значения свойства <codeph>SQLConnection.columnNameStyle</codeph>. Эти значения обозначают различные параметры, которые управляют форматированием имен столбцов (имен свойств) в объектах, возвращаемых в результате выполнения инструкции SQL <codeph>SELECT</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links><apiValue id="flash.data:SQLColumnNameStyle:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
     Означает, что имена столбцов, возвращаемых инструкцией SELECT, имеют формат по умолчанию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Означает, что имена столбцов, возвращаемых инструкцией <codeph>SELECT</codeph>, имеют формат по умолчанию. В формате по умолчанию имена столбцов имеют вид <codeph>[table-name]_[column-name]</codeph>, если в инструкцию <codeph>SELECT</codeph> входят несколько таблиц, или <codeph>[column-name]</codeph>, если в инструкцию <codeph>SELECT</codeph> входит только одна таблица.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:LONG"><apiName>LONG</apiName><shortdesc>
     Означает, что имена столбцов, возвращаемых инструкцией SELECT, имеют полный формат.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>long</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Означает, что имена столбцов, возвращаемых инструкцией <codeph>SELECT</codeph>, имеют полный формат. В этом формате имена столбцов имеют вид <codeph>[table-name]_[column-name]</codeph> независимо от количества таблиц в инструкции <codeph>SELECT</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLColumnNameStyle:SHORT"><apiName>SHORT</apiName><shortdesc>
     Означает, что имена столбцов, возвращаемых инструкцией SELECT, имеют краткий формат.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>short</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Означает, что имена столбцов, возвращаемых инструкцией <codeph>SELECT</codeph>, имеют краткий формат. В этом формате имена столбцов имеют вид <codeph>[column-name]</codeph> независимо от количества таблиц в инструкции <codeph>SELECT</codeph>.
	 
	 <p>Если в результирующем наборе содержится несколько столбцов с одинаковыми именами, в объект, полученный в результате, будет добавлено только одно свойство с таким именем. Этому свойству будет присвоено значение последнего столбца с таким именем в результирующем наборе. Например, рассмотрим следующую инструкцию <codeph>SELECT</codeph>:</p>
	 
	 <pre>
	 SELECT customers.customerId, addresses.customerId
	 FROM customers INNER JOIN addresses
	    ON customers.customerId = addresses.customerId
	 </pre>
	 
	 <p>Если эту инструкцию выполнить применительно к экземпляру SQLConnection, в котором имена столбцов имеют краткий формат, свойство <codeph>customerId</codeph> каждого полученного в результате объекта будет иметь значение столбца <codeph>customerId</codeph> таблицы <codeph>addresses</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>flash.data.SQLConnection.columnNameStyle</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
 Класс SQLSchema является базовым классом для сведений о схеме таких объектов базы данных, как таблицы, представления и индексы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SQLSchema является базовым классом для сведений о схеме таких объектов базы данных, как таблицы, представления и индексы.
 
 <p>Для получения сведений о схеме таблицы базы данных используется метод <codeph>SQLConnection.loadSchema()</codeph>, с помощью которого загружаются сведения о схеме. В полученном экземпляре SQLSchemaResult содержатся массивы экземпляров, представляющих объекты базы данных.</p>
 
 <p>Как правило, экземпляры SQLSchema не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchema:SQLSchema"><apiName>SQLSchema</apiName><shortdesc>
     Создает экземпляр SQLSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя связанной базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя объекта базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Инструкция SQL, используемая для создания объекта базы данных.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLSchema. Как правило, конструктор SQLSchema не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLSchema:database:get"><apiName>database</apiName><shortdesc>
     Имя базы данных, к которой относится данный объект схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Имя базы данных, к которой относится данный объект схемы. Главная база данных, связанная с экземпляром SQLConnection, называется main (файл базы данных, открытый с помощью метода <codeph>open()</codeph> или <codeph>openAsync()</codeph> экземпляра SQLConnection). Остальные базы данных, с которыми установлено соединение с помощью метода <codeph>SQLConnection.attach()</codeph>, называются так, как это указано в вызове метода <codeph>attach()</codeph>.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>flash.data.SQLConnection.attach()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchema:name:get"><apiName>name</apiName><shortdesc>
     Имя объекта данной схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Имя объекта данной схемы. У каждого объекта базы данных есть уникальное имя. Имя определяется в инструкции SQL, создающей данный объект (например, в инструкции <codeph>CREATE TABLE</codeph> для таблицы).
	 
	 <p>Например, если индекс базы данных создан с помощью следующей инструкции SQL, свойство <codeph>name</codeph> схемы этого индекса будет иметь значение <codeph>customer_index</codeph>:</p>
	 
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLSchema:sql:get"><apiName>sql</apiName><shortdesc>
     Возвращает весь текст инструкции SQL, используемой при создании объекта схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает весь текст инструкции SQL, используемой при создании объекта схемы. Каждый объект базы данных создается с помощью инструкции SQL.
	 
	 <p>Например, если индекс базы данных создан с помощью следующей инструкции SQL:</p>
	 <codeblock>CREATE INDEX customer_index ON customers (id)</codeblock>
	 <p>свойство <codeph>sql</codeph> схемы этого индекса будет содержать весь текст инструкции.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLCollationType"><apiName>SQLCollationType</apiName><shortdesc>
 Этот класс содержит константы, представляющие возможные значения параметра defaultCollationType конструктора SQLColumnSchema, а также свойства SQLColumnSchema.defaultCollationType.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс содержит константы, представляющие возможные значения параметра <codeph>defaultCollationType</codeph> конструктора SQLColumnSchema, а также свойства <codeph>SQLColumnSchema.defaultCollationType</codeph>.
 
 <p>Эти значения представляют различные порядки сортировки, которые могут быть заданы для столбца в таблице базы данных. <i>Порядок сортировки</i> – это способ сортировки и сравнения данных, например, различаются ли в базе данных символы верхнего и нижнего регистра.</p>
 
 <p>Дополнительные сведения об определении и использовании порядка сортировки см. в разделе <xref href="../../localDatabaseSQLSupport.html#collate">«COLLATE»</xref> приложения <xref href="../../localDatabaseSQLSupport.html">«Поддержка SQL в локальных базах данных»</xref>.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links><apiValue id="flash.data:SQLCollationType:BINARY"><apiName>BINARY</apiName><shortdesc>
     Указывает, что для столбца определен порядок сортировки BINARY.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, что для столбца определен порядок сортировки <codeph>BINARY</codeph>. При сортировке типа <codeph>SQLCollationType.BINARY</codeph> байтовые значения двух значений сравниваются независимо от кодировки текста.
	 
	 <p>Если для значений класса хранения <codeph>TEXT</codeph> используется двоичная сортировка, то при сортировке и сравнении значений столбцов в базе данных различаются символы верхнего и нижнего регистра.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLCollationType:NO_CASE"><apiName>NO_CASE</apiName><shortdesc>
     Указывает, что для столбца определен порядок сортировки NOCASE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noCase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, что для столбца определен порядок сортировки <codeph>NOCASE</codeph>. Если задана сортировка типа <codeph>SQLCollationType.NO_CASE</codeph>, то при сортировке и сравнении двух значений регистр не учитывается.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema/defaultCollationType"><linktext>flash.data.SQLColumnSchema.defaultCollationType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTransactionLockType"><apiName>SQLTransactionLockType</apiName><shortdesc>
 Этот класс содержит константы, представляющие возможные значения параметра option метода SQLConnection.begin().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс содержит константы, представляющие возможные значения параметра <codeph>option</codeph> метода <codeph>SQLConnection.begin()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links><apiValue id="flash.data:SQLTransactionLockType:DEFERRED"><apiName>DEFERRED</apiName><shortdesc>
     Указывает параметр отложенной блокировки транзакции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает параметр отложенной блокировки транзакции. Для транзакции с отложенной блокировкой блокировка базы данных не требуется до первого обращения к базе данных. При отложенной транзакции до первой операции чтения или записи блокировка не требуется.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:EXCLUSIVE"><apiName>EXCLUSIVE</apiName><shortdesc>
     Указывает параметр монопольной блокировки транзакции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exclusive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает параметр монопольной блокировки транзакции. Для транзакции с монопольной блокировкой требуется немедленная блокировка базы данных. Другие объекты SQLStatement, выполняемые применительно к этой же базе данных с использованием другого подключения SQLConnection (в этом же или другом приложении AIR), не смогут осуществлять в ней операции чтения или записи.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLTransactionLockType:IMMEDIATE"><apiName>IMMEDIATE</apiName><shortdesc>
     Указывает параметр немедленной блокировки транзакции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>immediate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает параметр немедленной блокировки транзакции. Для транзакции с немедленной блокировкой требуется немедленная блокировка базы данных. Другие объекты SQLStatement, выполняемые применительно к этой же базе данных с использованием другого подключения SQLConnection (в этом же или другом приложении AIR), смогут осуществлять в ней операции чтения, но не смогут осуществлять операции записи. Однако для других подключений, используемых для чтения данных из базы данных, первоначальное состояние данных в базе идентично состоянию базы данных до вызова метода <codeph>begin()</codeph> экземпляра подключения SQLConnection внутри транзакции. Любые незафиксированные изменения данных, произведенные в немедленно заблокированной транзакции, не доступны для других подключений.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>flash.data.SQLConnection.begin()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
 Экземпляр SQLSchemaResult содержит данные, полученные в результате вызова метода SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLSchemaResult содержит данные, полученные в результате вызова метода <codeph>SQLConnection.loadSchema()</codeph>. Он содержит четыре свойства типа Array с данными требуемой схемы в зависимости от значений аргументов, указанных при вызове метода <codeph>SQLConnection.loadSchema()</codeph>.
 
 <p>Чтобы получить экземпляр SQLSchemaResult для вызова метода <codeph>SQLConnection.loadSchema()</codeph>, необходимо вызвать метод <codeph>getSchemaResult()</codeph> экземпляра SQLConnection. Как правило, экземпляры SQLSchemaResult не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link></related-links><apiConstructor id="flash.data:SQLSchemaResult:SQLSchemaResult"><apiName>SQLSchemaResult</apiName><shortdesc>
     Создает экземпляр SQLSchemaResult.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>tables</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив экземпляров SQLTableSchema, как указано в запросе <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>views</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив экземпляров SQLViewSchema, как указано в запросе <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив экземпляров SQLIndexSchema, как указано в запросе <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>triggers</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив экземпляров SQLTriggerSchema, как указано в запросе <codeph>loadSchema()</codeph>.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLSchemaResult. Как правило, конструктор SQLSchemaResult не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLSchemaResult:indices:get"><apiName>indices</apiName><shortdesc>
     Массив экземпляров SQLIndexSchema, требуемых для вызова метода SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив экземпляров SQLIndexSchema, требуемых для вызова метода <codeph>SQLConnection.loadSchema()</codeph>. Если заданные базы данных не содержат индексов или в вызове метода <codeph>loadSchema()</codeph> указано, что индексы следует исключить из результата, свойство <codeph>indices</codeph> будет содержать пустой массив (массив, у которого свойство <codeph>length</codeph> равно 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:tables:get"><apiName>tables</apiName><shortdesc>
     Массив экземпляров SQLTableSchema, требуемых для вызова метода SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив экземпляров SQLTableSchema, требуемых для вызова метода <codeph>SQLConnection.loadSchema()</codeph>. Если заданные базы данных не содержат индексов или в вызове метода <codeph>loadSchema()</codeph> указано, что таблицы следует исключить из результата, свойство <codeph>tables</codeph> будет содержать пустой массив (массив, у которого свойство <codeph>length</codeph> равно 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:triggers:get"><apiName>triggers</apiName><shortdesc>
     Массив экземпляров SQLTriggerSchema, требуемых для вызова метода SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив экземпляров SQLTriggerSchema, требуемых для вызова метода <codeph>SQLConnection.loadSchema()</codeph>. Если заданные базы данных не содержат индексов или в вызове метода <codeph>loadSchema()</codeph> указано, что триггеры следует исключить из результата, свойство <codeph>triggers</codeph> будет содержать пустой массив (массив, у которого свойство <codeph>length</codeph> равно 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLSchemaResult:views:get"><apiName>views</apiName><shortdesc>
     Массив экземпляров SQLViewSchema, требуемых для вызова метода SQLConnection.loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив экземпляров SQLViewSchema, требуемых для вызова метода <codeph>SQLConnection.loadSchema()</codeph>. Если заданные базы данных не содержат индексов или в вызове метода <codeph>loadSchema()</codeph> указано, что представления следует исключить из результата, свойство <codeph>views</codeph> будет содержать пустой массив (массив, у которого свойство <codeph>length</codeph> равно 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
 Экземпляр SQLConnection используется для управления созданием файлов локальной базы данных SQL (локальных баз данных) и подключением к ним.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLConnection используется для управления созданием файлов локальной базы данных SQL (локальных баз данных) и подключением к ним.
 
 <p>Функциональные возможности класса SQLConnection подразделяются на несколько категорий:</p>
 
 <ul>
   <li><p>Для создания или открытия файла локальной базы данных SQL используется метод <codeph>open()</codeph> или <codeph>openAsync()</codeph>. Если файл базы данных отсутствует, с помощью этих методов его можно создать при открытии подключения (необязательно). После того как подключение к базе данных будет создано, можно создавать и выполнять инструкции SQL в базе данных,.создав экземпляр SQLStatement и назначив экземпляр SQLConnection свойству <codeph>sqlConnection</codeph> объекта SQLStatement.</p></li>
 
   <li><p>Класс SQLConnection также предоставляет состояние для инструкций SQL, включая механизм выполнения нескольких инструкций в одной транзакции с помощью методов <codeph>begin()</codeph>, <codeph>commit()</codeph> и <codeph>rollback()</codeph>.</p></li>
 
   <li><p>Класс SQLConnection обеспечивает доступ к сведениям о схемах подключенных баз данных. Схема базы данных содержит определения ее таблиц, столбцов, индексов и триггеров. Дополнительные сведения см. в описании метода <codeph>loadSchema()</codeph>.</p></li>
 
   <li><p>Класс SQLConnection предоставляет возможность шифрования баз данных с использованием стандарта AES в режиме CCM. Это обеспечивает как проверку подлинности, так и конфиденциальность данных. Для шифрования базы данных необходимо при ее создании указать 16-байтный ключ (с помощью ByteArray). В дальнейшем этот ключ можно изменить с помощью метода <codeph>SQLConnection.reencrypt()</codeph>. Шифрование снижает производительность при выполнении операций записи и чтения в отношении базы данных. Шифрование применяется к данным, хранящимся на диске, но не к данным во временной кэш-памяти. Шифрование <i>не</i> поддерживается для баз данных в памяти.</p></li>
 
   <li><p>Экземпляр SQLConnection может использоваться для получения уведомлений о событиях на уровне базы данных и контроля всех аспектов конфигурации базы данных, включая размер страниц кэша, параметры отмены обработки и выполнения инструкций.</p></li>
 </ul>
 
 <p>Экземпляр <codeph>SQLConnection</codeph> работает в одном или двух отдельных режимах выполнения: асинхронном и синхронном. Для синхронного выполнения при подключении к главной базе данных экземпляра SQLConnection необходимо использовать метод <codeph>open()</codeph>. Для асинхронного выполнения при подключении к главной базе данных экземпляра подключения необходимо использовать метод <codeph>openAsync()</codeph>.</p>
 
 <p>При асинхронном выполнении для определения завершения или сбоя операции используются прослушиватели или экземпляр Responder. Операции выполняются не в основном, а в фоновом потоке приложения, поэтому оно будет продолжать работать и взаимодействовать с пользователем даже во время выполнения операций с базой данных.</p>
 
 <p>При асинхронном режиме выполнения сначала с помощью соответствующего метода вызывается определенная операция, а для определения ее завершения (или сбоя) необходимо зарегистрировать прослушиватель соответствующего события. Каждой операции соответствует событие, которое отправляется при ее успешном завершении. Например, если метод <codeph>openAsync()</codeph> завершается успешно (если открыто подключение базы данных), отправляется событие <codeph>open</codeph>. При сбое какой-либо операции отправляется событие <codeph>error</codeph>. Экземпляр SQLError в свойстве <codeph>error</codeph> объекта SQLErrorEvent содержит сведения об определенной ошибке, включая выполняемую операцию и причину ее сбоя.</p>
 
 <p>При синхронном выполнении для определения завершения или сбоя операции не нужно регистрировать прослушиватели событий. Чтобы определить ошибки, заключите инструкции, которые их вызывают, в блоки <codeph>try.. catch</codeph>. Из-за того что синхронные операции выполняются в основном потоке, при выполнении одной или нескольких операций с базой данных все функции приложения (включая обновление экрана и возможность работы с мышью и клавиатурой) приостанавливаются. Продолжительные операции могут привести к заметной остановке работы приложения.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link><link href="flash.events.xml#SQLEvent"><linktext>flash.events.SQLEvent</linktext></link><link href="flash.events.xml#SQLErrorEvent"><linktext>flash.events.SQLErrorEvent</linktext></link><link href="flash.errors.xml#SQLError"><linktext>flash.errors.SQLError</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_en"><linktext>Быстрое начало работы: асинхронная работа с локальной базой данных SQL (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_flash_en"><linktext>Быстрое начало работы: асинхронная работа с локальной базой данных SQL (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLasynch_html_en"><linktext>Быстрое начало работы: асинхронная работа с локальной базой данных SQL (HTML)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_en"><linktext>Быстрое начало работы: синхронная работа с локальной базой данных SQL (Flex)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_flash_en"><linktext>Быстрое начало работы: синхронная работа с локальной базой данных SQL (Flash)</linktext></link><link href="http://www.adobe.com/go/learn_air_qs_SQLsynch_html_en"><linktext>Быстрое начало работы: синхронная работа с локальной базой данных SQL (HTML)</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.UPDATE_update"><apiName>update</apiName><shortdesc>
 Отправляется при изменении данных в любой таблице любой подключенной базы данных в результате выполнения команды SQL UPDATE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.UPDATE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при изменении данных в любой таблице любой подключенной базы данных в результате выполнения команды SQL <codeph>UPDATE</codeph>. Данные могут измениться непосредственно в результате выполнения инструкции <codeph>UPDATE</codeph> с помощью экземпляра SQLStatement или косвенно, в результате запуска триггера в ответ на выполнение инструкции.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.SCHEMA_schema"><apiName>schema</apiName><shortdesc>
 Отправляется при успешном вызове метода loadSchema() и готовности результатов схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.SCHEMA</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>loadSchema()</codeph> и готовности результатов схемы.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ROLLBACK_rollback"><apiName>rollback</apiName><shortdesc>
 Отправляется при успешном вызове метода rollback().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ROLLBACK</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>rollback()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.REENCRYPT_reencrypt"><apiName>reencrypt</apiName><shortdesc>
 Отправляется при успешном завершении операции вызова метода reencrypt().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.REENCRYPT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном завершении операции вызова метода <codeph>reencrypt()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/reencrypt()"><linktext>reencrypt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.OPEN_open"><apiName>open</apiName><shortdesc>
 Отправляется при успешном вызове метода openAsync().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.OPEN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>openAsync()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.INSERT_insert"><apiName>insert</apiName><shortdesc>
 Отправляется при изменении данных в любой таблице любой подключенной базы данных в результате выполнения команды SQL INSERT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.INSERT</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при изменении данных в любой таблице любой подключенной базы данных в результате выполнения команды SQL <codeph>INSERT</codeph>. Данные могут измениться непосредственно в результате выполнения инструкции <codeph>INSERT</codeph> с помощью экземпляра SQLStatement или косвенно, в результате запуска триггера в ответ на выполнение инструкции.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Отправляется, если любая из асинхронных операций объекта SQLConnection вызывает ошибку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если любая из асинхронных операций объекта SQLConnection вызывает ошибку. Экземпляр события SQLErrorEvent, которое отправляется в том случае, если свойство <codeph>error</codeph> объекта события содержит сведения об операции, при выполнении которой возникла ошибка.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DETACH_detach"><apiName>detach</apiName><shortdesc>
 Отправляется при успешном вызове метода detach().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DETACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>detach()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLUpdateEvent.DELETE_delete"><apiName>delete</apiName><shortdesc>
 Отправляется при изменении данных в любой таблице любой подключенной базы данных в результате выполнения команды SQL DELETE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLUpdateEvent.DELETE</apiEventType><adobeApiEventClassifier>flash.events.SQLUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при изменении данных в любой таблице любой подключенной базы данных в результате выполнения команды SQL <codeph>DELETE</codeph>. Данные могут измениться непосредственно в результате выполнения инструкции <codeph>DELETE</codeph> с помощью экземпляра SQLStatement или косвенно, в результате запуска триггера в ответ на выполнение инструкции.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.DEANALYZE_deanalyze"><apiName>deanalyze</apiName><shortdesc>
 Отправляется при успешном вызове метода deanalyze().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.DEANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>deanalyze()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMMIT_commit"><apiName>commit</apiName><shortdesc>
 Отправляется при успешном вызове метода commit().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMMIT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>commit()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CLOSE_close"><apiName>close</apiName><shortdesc>
 Отправляется при успешном вызове метода close().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>close()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.COMPACT_compact"><apiName>compact</apiName><shortdesc>
 Отправляется при успешном вызове метода compact().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.COMPACT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>compact()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/compact()"><linktext>compact()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Отправляется при успешном вызове метода cancel().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>cancel()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/cancel()"><linktext>cancel()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.BEGIN_begin"><apiName>begin</apiName><shortdesc>
 Отправляется при успешном вызове метода begin().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.BEGIN</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>begin()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ATTACH_attach"><apiName>attach</apiName><shortdesc>
 Отправляется при успешном вызове метода attach().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ATTACH</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>attach()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection_flash.events.SQLEvent.ANALYZE_analyze"><apiName>analyze</apiName><shortdesc>
 Отправляется при успешном завершении операции analyze().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.ANALYZE</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном завершении операции <codeph>analyze()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLConnection:SQLConnection"><apiName>SQLConnection</apiName><shortdesc>
     Создает экземпляр SQLConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>если конструктор вызывается из какой-либо изолированной среды за пределами главной изолированной среды приложения. 
      
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Создает экземпляр SQLConnection.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLConnection:addEventListener"><apiName>addEventListener</apiName><shortdesc>
     
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция прослушивателя, обрабатывающая событие. Эта функция должна принимать объект Event в качестве единственного параметра и не должна что-либо возвращать <ph platform="actionscript">, как показано в примере:</ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Эта функция может иметь любое имя.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Этот параметр применяется для отображения объектов в архитектуре списка отображения ActionScript 3.0, используемой в SWF-содержимом. </ph> <ph platform="actionscript">Определяет, работает ли прослушиватель в фазе захвата или в целевой фазе и в фазе восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>true</codeph>, прослушиватель обрабатывает событие только во время фазы захвата, но не во время целевой фазы или фазы восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>false</codeph>, то прослушиватель обрабатывает событие только в целевой фазе или фазе восходящей цепочки. Чтобы прослушивать событие во всех трех фазах, необходимо вызвать <codeph>addEventListener()</codeph> дважды: один раз с <codeph>useCapture</codeph> в значении <codeph>true</codeph>, а другой – с <codeph>useCapture</codeph> в значении <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Уровень приоритета прослушивателя событий. Приоритет определяется 32-разрядным целым числом со знаком. Чем больше число, тем выше приоритет. Все прослушиватели событий с приоритетом <i>n</i> обрабатываются перед прослушивателями с приоритетом <i>n</i>-1. Прослушиватели с одинаковым приоритетом обрабатываются в порядке их добавления. Значение приоритета по умолчанию равно 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли ссылка на прослушивателя «сильной» или «слабой». «Сильная» ссылка (по умолчанию) предотвращает удаление прослушивателя сборщиком мусора. «Слабая» ссылка позволяет удалить прослушиватель. <p>Функции элементов уровня класса не подлежат удалению в качестве мусора, вследствие чего можно установить <codeph>useWeakReference</codeph> равным <codeph>true</codeph> для функций элементов уровня класса, не подвергая их возможности подобного удаления. Если свойству <codeph>useWeakReference</codeph> присвоить значение <codeph>true</codeph> для прослушивателя, который является вложенной внутренней функцией, то функция будет очищена и перестанет быть постоянной. При создании ссылок на внутреннюю функцию (возможно сохранение в другой переменной) она не будет собираться в качестве мусора и останется устойчивой.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии. <ph platform="actionscript">Можно регистрировать прослушиватели событий в любом узле из списка отображения для каждого типа события, фазы и приоритета.</ph>
	
	<p platform="javascript">В коде JavaScript в среде выполнения AIR этот метод используется в целях регистрации прослушивателей событий, определенных интерфейсами AIR API. Для других событий JavaScript (таких как событие <codeph>onload</codeph> объекта <codeph>body</codeph> в модели DOM) можно использовать те же стандартные способы обработки событий, что и для содержимого в обозревателе.</p>
	
	<p>После успешной регистрации прослушивателя событий невозможно изменить его приоритет путем дополнительных вызовов <codeph>addEventListener()</codeph>. Чтобы изменить приоритет прослушивателя, необходимо сначала вызвать метод <codeph>removeListener()</codeph>. Затем можно снова зарегистрировать прослушиватель с новым приоритетом. </p>
	
	<p>Следует учесть, что после регистрации прослушивателя последующие вызовы метода <codeph>addEventListener()</codeph> с другим значением свойства <codeph>type</codeph> или <codeph>useCapture</codeph> приводят к регистрации другого прослушивателя. <ph platform="actionscript">Например, прослушиватель, изначально зарегистрированный со значением <codeph>useCapture</codeph>, равным <codeph>true</codeph>, прослушивает только во время фазы захвата. Если вызвать метод <codeph>addEventListener()</codeph> еще раз с тем же объектом прослушивателя, но со свойством <codeph>useCapture</codeph> в значении <codeph>false</codeph>, то будет два прослушивателя: один – прослушивающий в фазе захвата, а другой – в целевой фазе и фазе восходящей цепочки. </ph>
	</p>
	
	<p platform="actionscript">Невозможно зарегистрировать прослушиватель события только для целевой фазы или для фазы восходящей цепочки. Эти фазы соединены при регистрации, поскольку восходящая цепочка применяется только к предшественникам целевого узла.</p>
	
	<p>Если прослушиватель событий больше не нужен, его можно удалить, вызвав метод <codeph>removeEventListener()</codeph>, иначе могут возникнуть проблемы с памятью. Прослушиватели событий не удаляются из памяти автоматически, так как сборщик мусора не удаляет прослушиватель, пока существует объект, отправляющий соответствующее событие (если параметру <codeph>useWeakReference</codeph> не задано значение <codeph>true</codeph>).</p>
		
	<p>Копирование экземпляра EventDispatcher не приводит к копированию прослушивателей событий, присоединенных к нему. (Если для вновь создаваемого узла требуется прослушиватель событий, его необходимо присоединить после создания узла.) При этом при перемещении экземпляра EventDispatcher присоединенные к нему прослушиватели событий перемещаются вместе с ним.</p>
	
	
	<p platform="actionscript">Если прослушиватель регистрируется для узла в тот момент, когда на нем обрабатывается событие, то в текущей фазе он не запускается, однако может запуститься в следующей фазе потока события, например в фазе восходящей цепочки.</p>
	
	<p platform="actionscript">Прослушиватель событий, удаленный из узла во время обработки события на этом узле, будет запускаться текущими операциями. После удаления прослушиватель событий больше не вызывается (если не будет снова зарегистрирован для дальнейшей обработки). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:analyze"><apiName>analyze</apiName><shortdesc>
     Собирает статистику об индексах базы данных и сохраняет ее в базе данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если этот метод вызван, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>resourceName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Имя базы данных или таблицы, индексы которых требуется проанализировать. Если указанный ресурс является таблицей, которая имеет уникальное среди всех подключенных баз данных имя, необходимо указать только имя таблицы. Тем не менее, чтобы избежать неоднозначности, если имя таблицы окажется неуникальным, его можно указать в виде <codeph>[database-name]. [table-name]</codeph>. Если параметр <codeph>resourceName</codeph> имеет значение <codeph>null</codeph> (по умолчанию), анализируются все индексы подключенных баз данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. В асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>analyze</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Собирает статистику об индексах базы данных и сохраняет ее в базе данных. Статистика может использоваться оптимизатором запросов (той частью ядра СУБД, которая определяет самый эффективный способ выполнения каждой инструкции). Статистика помогает оптимизатору запросов лучшим образом выбрать один или несколько индексов при выполнении определенного запроса.
	 
	 <p>Если в базе данных определены индексы, но метод <codeph>analyze()</codeph> не вызван, среда выполнения все равно будет использовать их при выполнении инструкции. Но без дополнительных статистических данных, которые формируются с помощью метода <codeph>analyze()</codeph>, среда выполнения может выбрать не самый эффективный индекс для определенного запроса.</p>
	 
	 <p>При изменении данных таблицы (в результате выполнения операторов <codeph>INSERT</codeph>, <codeph>UPDATE</codeph> или <codeph>DELETE</codeph>) изменяются также и индексы, связанные с этой таблицей. Статистические данные, которые формируются с помощью метода <codeph>analyze()</codeph>, не обновляются автоматически. Следовательно, после большого числа изменений данных может быть полезным повторный вызов метода <codeph>analyze()</codeph>. Однако польза, полученная от вызова метода <codeph>analyze()</codeph>, зависит от нескольких факторов, включая число индексов в таблице, соотношение числа измененных строк и общего числа строк в таблице, степень изменения проиндексированных данных таблицы и того, насколько измененные данные отличаются от ранее измененных данных.</p>
     
     <p>Параметр <codeph>resourceName</codeph> указывает, выполняется ли операция для индексов всех подключенных баз данных, определенной базы данных или определенной таблицы.</p>
     
     <p>Каждый раз при вызове данного метода все ранее созданные статистические данные стираются и повторно создаются для базы данных или таблицы, указанной в параметре <codeph>resourceName</codeph> (или для всех таблиц всех подключенных баз данных, если параметр <codeph>resourceName</codeph> имеет значение <codeph>null</codeph>). Этот метод можно вызывать в любое время, пока открыто подключение базы данных. Операция <codeph>analyze()</codeph> и ее статистические данные не включаются в транзакцию. Несмотря на это, не рекомендуется вызывать метод <codeph>analyze()</codeph>, если в данный момент в базе данных открыта транзакция (свойство <codeph>inTransaction</codeph> имеет значение <codeph>true</codeph>). Это связано с тем, что при вызове метода <codeph>analyze()</codeph> не учитываются любые изменения данных, схем таблиц или индексов, которые были выполнены в транзакции, но ещё не были зафиксированы, следовательно, на момент фиксации транзакции данные метода <codeph>analyze()</codeph> будут устаревшими.</p>
     
     <p>Для удаления статистических данных, созданных с помощью метода <codeph>analyze()</codeph>, используется метод <codeph>deanalyze()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/deanalyze()"><linktext>deanalyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:analyze_analyze"><apiName>analyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:analyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:attach"><apiName>attach</apiName><shortdesc>
     Добавляет новую базу данных в экземпляр SQLConnection, присваивая ей заданное имя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Когда параметр <codeph>name</codeph> является пустой строкой (<codeph>""</codeph>) или имеет значение <codeph>null</codeph>
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если параметр <codeph>reference</codeph> имеет значение, отличное от экземпляра flash.filesystem.File
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Когда аргумент <codeph>encryptionKey</codeph> не имеет значение <codeph>null</codeph> и его свойство <codeph>length</codeph> не равно 16 байтам
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Когда параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>, а аргумент <codeph>encryptionKey</codeph> не имеет значение <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>), или если в данный момент открыта транзакция (свойство <codeph>inTransaction</codeph> имеет значение <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя, используемое для определения только что подключенной базы данных. Это имя можно использовать в операторах SQL, чтобы в явном виде указать принадлежность таблицы определенной базе данных в формате <codeph>[database-name]. [table-name]</codeph>. Имена main и temp зарезервированы и не могут использоваться.
     
     </apiDesc></apiParam><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Ссылка на подключаемый файл базы данных (экземпляр flash.filesystem.File). Если ссылка ссылается на отсутствующий файл, то создается новый файл базы данных или генерируется ошибка в зависимости от значения, указанного в параметре <codeph>openMode</codeph> при вызове метода <codeph>open()</codeph> или <codeph>openAsync()</codeph> для подключения главной базы данных.
	 
     <p>Если параметр имеет значение <codeph>null</codeph>, то создается и подключается база данных в оперативной памяти.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>attach</codeph> или <codeph>error</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Ключ шифрования для файла базы данных. Если вызов метода <codeph>attach()</codeph> создает базу данных, эта база данных шифруется, а указанный ключ используется в качестве ключа шифрования базы данных. Если вызов этого метода присоединяет существующую зашифрованную базу данных, это значение должно совпадать с ключом шифрования базы данных, иначе произойдет ошибка. Если присоединяемая база данных не зашифрована или требуется создать незашифрованную базу данных, это значение должно быть <codeph>null</codeph> (по умолчанию).
	 
	 <p>Действительным считается ключ шифрования длиной 16 байтов. Базу данных в памяти зашифровать невозможно, поэтому этот параметр должен иметь значение <codeph>null</codeph>, если параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>.</p>
	 
	 <p>Если при присоединении зашифрованной базы данных предоставленный ключ шифрования не совпадает с ключом шифрования базы данных, выдается исключение. В синхронном режиме выполнения выдается исключение SQLError. В асинхронном режиме выполнения отправляется событие SQLErrorEvent, а свойство <codeph>error</codeph> объекта события содержит экземпляр SQLError. В любом из этих случаев свойство <codeph>errorID</codeph> объекта SQLError имеет значение 3138 («Открытый файл не является файлом базы данных»).</p>
	 
	 <p>Параметр <codeph>encryptionKey</codeph> доступен, начиная с AIR 1.5.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет новую базу данных в экземпляр SQLConnection, присваивая ей заданное имя. Подключение базы данных позволяет использовать ее в инструкциях SQL, выполняемых применительно к экземпляру SQLConnection.
     
     <p>Если база данных уже подключена с использованием заданного имени, вызов метода <codeph>attach()</codeph> приведет к отправке события <codeph>error</codeph>. Тем не менее, одну и ту же базу данных можно подключить несколько раз, используя уникальные имена. К одному экземпляру SQLConnection можно подключить не более 10 баз данных.</p>
     
     <p>Любой оператор SQL можно выполнить применительно к базе данных, которая подключена с помощью метода <codeph>attach()</codeph>, вызванного для главной базы данных (базы данных, которая подключена с помощью метода <codeph>open()</codeph> или <codeph>openAsync()</codeph>). Оператор SQL может обращаться к таблицам из любых баз данных, которые подключены к экземпляру SQLConnection, связанному с оператором, включая возможность обращения к таблицам из нескольких баз данных в одном операторе. Когда среда выполнения анализирует имена таблиц в инструкции, она осуществляет поиск по базам данных экземпляра SQLConnection в порядке их подключения, начиная с базы данных, которая была подключена с помощью метода <codeph>open()</codeph> или <codeph>openAsync()</codeph>. Чтобы в явном виде указать имя таблицы, в инструкции нужно использовать имя базы данных (как указано в передаваемом в метод <codeph>attach()</codeph> параметре <codeph>name</codeph>).</p>
     
     <p>Для удаления базы данных, подключенной с помощью метода <codeph>attach()</codeph>, используется метод <codeph>detach()</codeph>. При закрытии экземпляра SQLConnection (с помощью метода <codeph>close()</codeph>) все подключенные базы данных отсоединяются.</p>
     
     <p>Подключенная база данных использует тот же режим выполнения (синхронный или асинхронный), что и главная, в зависимости от метода, с помощью которого была подключена главная база данных <codeph>open()</codeph> или <codeph>openAsync()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/detach()"><linktext>detach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:attach_attach"><apiName>attach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:attach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:begin"><apiName>begin</apiName><shortdesc>
     Начинает транзакцию, в рамках которой в отношении базы данных подключения или сгруппированных баз данных выполняются инструкции SQL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если этот метод вызван, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если указанный параметр не является одной из констант класса <codeph>SQLTransactionLockType</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>option</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает стратегию блокировки, используемую данной транзакцией. Может принимать значение одной из констант, определенных в классе SQLTransactionLockType:
     <ul>
        <li><codeph>SQLTransactionLockType.DEFERRED</codeph> обозначает, что блокировка не выполняется до первой операции чтения или записи.</li>
        <li><codeph>SQLTransactionLockType.EXCLUSIVE</codeph> обозначает, что блокировка выполняется при первой возможности, при этом другие экземпляры подключения SQLConnection не осуществлять в базе данных операции чтения и записи.</li>
        <li><codeph>SQLTransactionLockType.IMMEDIATE</codeph> обозначает, что блокировка выполняется при первой возможности, при этом другие экземпляры SQLConnection смогут осуществлять операции чтения из базы данных, но не смогут осуществлять операции записи.</li>
     </ul>
	 <p>Значение по умолчанию (<codeph>null</codeph>) эквивалентно константе <codeph>SQLTransactionLockType.DEFERRED</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>begin</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Начинает транзакцию, в рамках которой в отношении базы данных подключения или сгруппированных баз данных выполняются инструкции SQL.
     
     <p>По умолчанию каждая инструкция SQL выполняется в рамках своей транзакции, которая завершается после успешного выполнения или сбоя инструкции. При создании транзакции с помощью метода <codeph>begin()</codeph> создается новая ручная транзакция. После этого все инструкции SQL, выполненные применительно к экземпляру SQLConnection, находятся внутри транзакции, поэтому все действия и изменения, которые ими выполнены, можно зафиксировать (сделать постоянными) или откатить (отменить) не по одному, а только все одновременно.</p>
     
     <p>Вложенные транзакции запрещены (вложенные вызовы метода <codeph>begin()</codeph> игнорируются). Для завершения транзакции используется метод <codeph>commit()</codeph> или <codeph>rollback()</codeph> в зависимости от того, что необходимо сделать с изменениями, сделанными инструкциями из транзакции: сделать их постоянными или отменить.</p>
	 
	 <p>Если подключение к базе данных закрывается при открытой транзакции, AIR автоматически выполняет откат транзакции. (Примечание. В AIR 1.1 и в предыдущих версиях при закрытии подключения открытая транзакция автоматически фиксируется.)</p>
     
     <p>В транзакции могут быть как инструкции, выполняемые в одной базе данных, так и инструкции, выполняемые в различных подключенных базах данных.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link><link href="flash.data.xml#SQLTransactionLockType"><linktext>flash.data.SQLTransactionLockType</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:begin_begin"><apiName>begin</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:begin_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:cancel"><apiName>cancel</apiName><shortdesc>
     Прерывает все инструкции SQL, выполняемые в текущий момент в базах данных, подключенных к данному экземпляру SQLConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если этот метод вызван, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>cancel</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Прерывает все инструкции SQL, выполняемые в текущий момент в базах данных, подключенных к данному экземпляру SQLConnection. Этот метод используется для завершения продолжительных или вышедших из-под контроля запросов.
     
     <p>Если в момент вызова метода <codeph>cancel()</codeph> выполняются инструкции, этот метод прерывает их выполнение и выполняет откат всех незавершенных обновлений или транзакций. Если в текущий момент нет выполняемых инструкций, этот метод выполняет откат открытой транзакции, в противном случае ничего не происходит.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement"><linktext>flash.data.SQLStatement</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:cancel_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:cancel_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:close"><apiName>close</apiName><shortdesc>
     Закрывает текущее подключение базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>close</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Закрывает текущее подключение базы данных. Также происходит отсоединение всех подключенных баз данных.
     
     <p>Если во время вызова метода <codeph>close()</codeph> есть открытая транзакция, она фиксируется. При очистке экземпляра SQLConnection среда выполнения автоматически вызывает метод <codeph>close()</codeph>, включая те случаи, когда приложение AIR закрыто, а экземпляр SQLConnection по-прежнему подключен к базе данных.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:close_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:commit"><apiName>commit</apiName><shortdesc>
     Фиксирует существующую транзакцию, в результате чего все действия, выполненные ее инструкциями, применяются к базе данных окончательно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>), или если в текущий момент нет открытых транзакций (свойство <codeph>inTransaction</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>commit</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Фиксирует существующую транзакцию, в результате чего все действия, выполненные ее инструкциями, применяются к базе данных окончательно.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:commit_commit"><apiName>commit</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:commit_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбойного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбойного завершения операции.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:compact"><apiName>compact</apiName><shortdesc>
     Освобождает все неиспользуемое место в базе данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>), или если в данный момент открыта транзакция (свойство <codeph>inTransaction</codeph> имеет значение <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>compact</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Освобождает все неиспользуемое место в базе данных. После удаления объекта (таблицы, индекса или триггера) из базы данных остается пустое место. Из-за этого файл базы данных становится больше, чем необходимо, но операции <codeph>INSERT</codeph> выполняются быстрее. Со временем из-за операций <codeph>INSERT</codeph> и <codeph>DELETE</codeph> структура файла базы данных становится фрагментированной, из-за чего замедляется доступ к содержимому базы данных. Данный метод сжимает файл базы данных, уничтожая пустые страницы и располагая данные таблиц без разрывов, а в противном случае – очищает структуру файла базы данных.
     
     <p>Операцию <codeph>compact()</codeph> невозможно выполнить для файла подключенной базы данных, выполнение возможно только для файла главной (исходной) базы данных, который открыт с помощью экземпляра SQLConnection. Эта операция завершается сбоем, если есть активная транзакция, и не выполняет никаких действий применительно к базе данных, которая хранится в оперативной памяти.</p>
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.data:SQLConnection:compact_compact"><apiName>compact</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:compact_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:deanalyze"><apiName>deanalyze</apiName><shortdesc>
     Удаляет все статистические данные, созданные методом analyze().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если этот метод вызван, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>deanalyze</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Удаляет все статистические данные, созданные методом <codeph>analyze()</codeph>.
	 
	 <p>Так как статистика, создаваемая методом <codeph>analyze()</codeph>, занимает место в базе данных, с помощью вызова метода <codeph>deanalyze()</codeph> можно его освободить, например после удаления некоторых индексов или таблиц.</p>
     
     <p>Данная операция не включена в активную транзакцию.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/analyze()"><linktext>analyze()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:deanalyze_deanalyze"><apiName>deanalyze</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:deanalyze_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:detach"><apiName>detach</apiName><shortdesc>
     Отсоединяет дополнительную базу данных, ранее подключенную к экземпляру SQLConnection с помощью метода attach().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если аргумент <codeph>name</codeph> имеет значение <codeph>null</codeph> или содержит пустую строку (<codeph>""</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если этот метод вызван, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>) или в рамках экземпляра подключения SQLConnection открыта транзакция (свойство <codeph>inTransaction</codeph> имеет значение <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Заданное имя отсоединяемой базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>detach</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Отсоединяет дополнительную базу данных, ранее подключенную к экземпляру SQLConnection с помощью метода <codeph>attach()</codeph>. Один и тот же файл базы данных может быть подключен несколько раз под разными именами, поэтому, если отсоединить одно подключение, остальные продолжат работать. Базу данных нельзя отсоединить, если в ней открыта транзакция (если свойство <codeph>inTransaction</codeph> имеет значение <codeph>true</codeph>).
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:detach_detach"><apiName>detach</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:detach_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:getSchemaResult"><apiName>getSchemaResult</apiName><shortdesc>
     Обеспечивает доступ к результату вызова метода loadSchema().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.data:SQLSchemaResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Обеспечивает доступ к результату вызова метода <codeph>loadSchema()</codeph>. Метод <codeph>getSchemaResult()</codeph> работает как очередь результатов с порядком доступа к элементам «первым поступил – первым обслужен» (FIFO, First In – First Out). Каждый раз после завершения вызова метода <codeph>loadSchema()</codeph> (каждый раз, когда в асинхронном режиме выполнения отправляется событие <codeph>schema</codeph>) в очередь добавляется новый объект SQLSchemaResult. Каждый раз при вызове метода <codeph>getSchemaResult()</codeph> возвращается и удаляется из очереди самый первый результат (тот, который был добавлен в очередь первым). Если в очереди не осталось объектов, метод <codeph>getSchemaResult()</codeph> возвращает <codeph>null</codeph>.
     
     <p>Если подключение базы данных закрыто, метод возвращает <codeph>null</codeph>.</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>loadSchema()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>схема данных</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLConnection:loadSchema"><apiName>loadSchema</apiName><shortdesc>
     Загружает сведения о схеме данных из присоединенной или любой подключенной базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если данный метод вызывается, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Когда указанное значение аргумента <codeph>type</codeph> представляет собой недопустимый тип.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если при использовании синхронного режима выполнения в качестве параметров имени или базы данных указано недопустимое значение.
	 
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает тип загружаемой схемы данных. Значение <codeph>null</codeph> (по умолчанию) обозначает, что должны быть загружены все данные схемы. Если в качестве этого параметра указать значение, отличное от <codeph>null</codeph>, это сузит область полученной в результате схемы данных, при этом из результатов будут удалены все потенциально ненужные сведения, а сама операция станет более эффективной. Значение должно представлять собой имя одного из следующих классов:
	 <ul>
	     <li>SQLIndexSchema</li>
	     <li>SQLTableSchema</li>
	     <li>SQLTriggerSchema</li>
	     <li>SQLViewSchema</li>
	 </ul>
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывают, для каких ресурсов загружается схема данных. Использование данного значения в зависимости от заданного аргумента <codeph>type</codeph>. Обычно это значение представляет собой имя объекта базы данных, например, имя таблицы, индекса, представления и т. д. Если оно задано, то в результат попадает только схема объекта базы данных с указанным именем.
	 
	 <p>Если задано недопустимое значение, отправляется событие <codeph>error</codeph> (или генерируется ошибка в синхронном режиме выполнения). Чтобы значение параметра <codeph>type</codeph> было допустимым, оно должно соответствовать типу указанного объекта, как указано в описании метода.</p>
	 
	 <p>Если аргумент <codeph>name</codeph> имеет значение <codeph>null</codeph>, в результат попадут все схемы заданного типа. Если задано недопустимое значение, отправляется событие <codeph>error</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>main</apiData><apiDesc>Имя базы данных, для которой загружается схема данных. Если задано недопустимое значение, отправляется событие <codeph>error</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>includeColumnSchema</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Указывает, содержит ли в результат сведения о схеме столбцов таблиц и представлений.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>schema</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Загружает сведения о схеме данных из присоединенной или любой подключенной базы данных. Схема данных отражает структуру таблиц, столбцов, индексов и триггеров базы данных.
	 
     <p>Для обращения к загруженной схеме данных используется метод <codeph>SQLConnection.getSchemaResult()</codeph>.</p>
	 
     <p>В асинхронном режиме выполнения событие <codeph>schema</codeph> отправляется в случае успешного завершения операции. В случае сбоя операции отправляется событие <codeph>error</codeph>.</p>
	 
	 <p>Сочетание значений параметров <codeph>type</codeph> и <codeph>name</codeph> определяет тип данных схемы, создаваемой с помощью метода <codeph>loadSchema()</codeph>, а следовательно, и значения свойств создаваемого экземпляра SQLSchemaResult. В нижеприведенной таблице перечислены допустимые пары аргументов <codeph>type</codeph> и <codeph>name</codeph> и формируемые в результате данные схемы:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>аргумент <codeph>type</codeph></entry><entry>аргумент <codeph>name</codeph></entry><entry>Объекты, для которых извлекаются данные схемы: </entry></row></thead><tbody><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>все объекты базы данных (все таблицы, представления, триггеры и индексы)</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>все индексы базы данных</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>допустимое имя таблицы</entry>
	     <entry>все индексы, определенные для заданной таблицы</entry>
	   </row><row>
	     <entry><codeph>SQLIndexSchema</codeph></entry>
	     <entry>допустимое имя индекса</entry>
	     <entry>заданный индекс</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>все таблицы базы данных</entry>
	   </row><row>
	     <entry><codeph>SQLTableSchema</codeph></entry>
	     <entry>допустимое имя таблицы</entry>
	     <entry>заданная таблица</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>все триггеры базы данных</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>допустимое имя таблицы</entry>
	     <entry>все триггеры, связанные с заданной таблицей</entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>допустимое имя представления</entry>
	     <entry>все триггеры, связанные с заданным представлением </entry>
	   </row><row>
	     <entry><codeph>SQLTriggerSchema</codeph></entry>
	     <entry>допустимое имя триггера</entry>
	     <entry>заданный триггер </entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry><codeph>null</codeph></entry>
	     <entry>все представления базы данных</entry>
	   </row><row>
	     <entry><codeph>SQLViewSchema</codeph></entry>
	     <entry>допустимое имя представления</entry>
	     <entry>заданное представление </entry>
	   </row></tbody></tgroup></adobetable>
	 
	 <p>Если сочетание аргументов <codeph>type</codeph> и <codeph>name</codeph> не соответствует ни одному из перечисленных, в асинхронном режиме выполнения отправляется событие <codeph>error</codeph>, а в синхронном – генерируется исключение. Например, если аргумент <codeph>type</codeph> имеет значение <codeph>SQLViewSchema</codeph>, а аргумент <codeph>name</codeph> содержит имя таблицы (вместо имени представления), возникнет ошибка, указывающая на отсутствие в базе данных объекта указанного типа с заданным именем.</p>
	 
	 <p>Если база данных пуста (не содержит таблиц, представлений, триггеров или индексов), вызов метода <codeph>loadSchema()</codeph> приведет к ошибке.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>getSchemaResult()</linktext></link><link href="flash.data.xml#SQLConnection/schema"><linktext>схема данных</linktext></link><link href="flash.data.xml#SQLIndexSchema"><linktext>flash.data.SQLIndexSchema</linktext></link><link href="flash.data.xml#SQLTableSchema"><linktext>flash.data.SQLTableSchema</linktext></link><link href="flash.data.xml#SQLTriggerSchema"><linktext>flash.data.SQLTriggerSchema</linktext></link><link href="flash.data.xml#SQLViewSchema"><linktext>flash.data.SQLViewSchema</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:loadSchema_schema"><apiName>schema</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:loadSchema_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбойного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбойного завершения операции.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:open"><apiName>open</apiName><shortdesc>
     Открывает синхронное подключение к файлу базы данных с заданным местоположением в файловой системе, создает и открывает новый файл базы данных с заданным местоположением или создает и открывает базу данных в оперативной памяти.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если экземпляр SQLConnection уже имеет открытое подключение к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>true</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>При сбое операции. Соединение никогда не остается открытым после сбоя операции.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiException><apiDesc>Если параметр <codeph>reference</codeph> имеет значение, отличное от экземпляра flash.filesystem.File
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Когда аргумент <codeph>encryptionKey</codeph> не имеет значение <codeph>null</codeph> и его свойство <codeph>length</codeph> не равно 16 байтам
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Когда параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>, а аргумент <codeph>encryptionKey</codeph> не имеет значение <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если задан недопустимый параметр <codeph>pageSize</codeph>. Включает передачу размера страницы, если используется режим <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Местоположение открытого файла базы данных. Значение должно быть экземпляром класса flash.filesystem.File. Если параметр имеет значение <codeph>null</codeph>, то создается и подключается база данных в оперативной памяти.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Указывает режим, в котором будет открыта база данных. Может принимать значение любой константы, определенной в классе SQLMode. Значением по умолчанию является <codeph>SQLMode.CREATE</codeph>, которое указывает, что в случае отсутствия файла базы данных с заданным местоположением он будет создан. Если параметр <codeph>openMode</codeph> имеет значение <codeph>SQLMode.READ</codeph>, а указанный файл отсутствует, отправляется событие ошибки. Этот параметр игнорируется, если параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, выполняется ли в базе данных автоматическое занятие неиспользуемого места. Этот параметр допустим только при создании новой базы данных или при открытии файла базы данных, в которой нет созданных таблиц. По умолчанию место, которое освобождается при удалении данных, остается в базе данных и при необходимости используется повторно. Если этому параметру задать значение <codeph>true</codeph>, свободное место будет повторно использоваться базой данных автоматически. Это может со временем привести к фрагментации данных в базе данных и отрицательно сказаться на производительности, потому что каждый раз при записи данных в базу потребуется дополнительная обработка. Чтобы в любое время принудительно восстановить неиспользуемое место в файле базы данных и дефрагментировать этот файл, используется метод <codeph>compact()</codeph>.
	 
	 <p>Этот параметр игнорируется, если параметр <codeph>openMode</codeph> имеет значение <codeph>SQLMode.READ</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Указывает размер страницы базы данных (в байтах). Этот параметр допустим только при создании новой базы данных или при открытии файла базы данных, в которой нет созданных таблиц. Значением должна быть степень двойки, которая больше или равна 512, но меньше или равна 32768. Значением по умолчанию является 1024 байта. Данное значение можно задать только до создания таблиц. При попытке изменить это значение после создания таблиц будет выдана ошибка. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Ключ шифрования для файла базы данных. Если вызов метода <codeph>open()</codeph> создает базу данных, эта база данных шифруется, а указанный ключ используется в качестве ключа шифрования базы данных. Если вызов этого метода открывает зашифрованную базу данных, это значение должно совпадать с ключом шифрования базы данных, иначе произойдет ошибка. Если открываемая база данных не зашифрована или требуется создать незашифрованную базу данных, это значение должно быть <codeph>null</codeph> (по умолчанию), иначе произойдет ошибка.
	 
	 <p>Действительным считается ключ шифрования длиной 16 байтов. Базу данных в памяти зашифровать невозможно, поэтому этот параметр должен иметь значение <codeph>null</codeph>, если параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>.</p>
	 
	 <p>Если при открытии зашифрованной базы данных предоставленный ключ шифрования не совпадает с ключом шифрования базы данных, выдается исключение SQLError. В таком случае свойство <codeph>errorID</codeph> объекта SQLError имеет значение 3138 («Открытый файл не является файлом базы данных»).</p>
	 
	 <p>Параметр <codeph>encryptionKey</codeph> доступен, начиная с AIR 1.5.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Открывает синхронное подключение к файлу базы данных с заданным местоположением в файловой системе, создает и открывает новый файл базы данных с заданным местоположением или создает и открывает базу данных в оперативной памяти. Операции создания и открытия базы данных, а также все остальные операции, выполняемые с использованием данного экземпляра SQLConnection, выполняются <i>синхронно</i> при открытии базы данных с помощью этого метода. Это включает в себя выполнение инструкций и другие операции, выполняемые экземпляром SQLStatement, связанным с данным экземпляром SQLConnection. Для асинхронного выполнения операций вместо него подключение базы данных следует открывать с помощью метода <codeph>openAsync()</codeph>.
	 
	 <p>Подключив базу данных, используйте экземпляр <xref href="SQLStatement.html">SQLStatement</xref> для выполнения инструкций SQL. Операции на уровне базы данных, такие как начало или завершение транзакций, загрузка данных схемы и другие, выполняются при помощи экземпляра SQLConnection.</p>
     
     <p>Базе данных, присоединенной с помощью метода <codeph>open()</codeph>, автоматически назначается имя main, которое можно использовать для явного указания имен таблиц в операторах SQL в формате <codeph>[database-name]. [table-name]</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:open_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:openAsync"><apiName>openAsync</apiName><shortdesc>
     Открывает асинхронное подключение к файлу базы данных с заданным местоположением в файловой системе, создает и открывает новый файл базы данных с заданным местоположением или создает и открывает базу данных в оперативной памяти.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если экземпляр SQLConnection уже имеет открытое подключение к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>true</codeph>).
     
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если параметр <codeph>reference</codeph> имеет значение, отличное от экземпляра flash.filesystem.File
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Когда аргумент <codeph>encryptionKey</codeph> не имеет значение <codeph>null</codeph> и его свойство <codeph>length</codeph> не равно 16 байтам
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Когда параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>, а аргумент <codeph>encryptionKey</codeph> не имеет значение <codeph>null</codeph>
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если задан недопустимый параметр <codeph>pageSize</codeph>. Включает передачу размера страницы, если используется режим <codeph>SQLMode.READ</codeph>.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>reference</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Местоположение открытого файла базы данных. Значение должно быть экземпляром класса flash.filesystem.File. Если параметр имеет значение <codeph>null</codeph>, то создается и подключается база данных в оперативной памяти.
     
     </apiDesc></apiParam><apiParam><apiItemName>openMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>create</apiData><apiDesc>Указывает режим, в котором будет открыта база данных. Может принимать значение любой константы, определенной в классе SQLMode. Значением по умолчанию является <codeph>SQLMode.CREATE</codeph>, которое указывает, что в случае отсутствия файла базы данных с заданным местоположением он будет создан. Если параметр <codeph>openMode</codeph> имеет значение <codeph>SQLMode.READ</codeph>, а указанный файл отсутствует, отправляется событие ошибки. Этот параметр игнорируется, если параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. Если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>open</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>autoCompact</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, выполняется ли в базе данных автоматическое занятие неиспользуемого места. Этот параметр допустим только при создании новой базы данных или при открытии файла базы данных, в которой нет созданных таблиц. По умолчанию место, которое освобождается при удалении данных, остается в базе данных и при необходимости используется повторно. Если этому параметру задать значение <codeph>true</codeph>, свободное место будет повторно использоваться базой данных автоматически. Это может со временем привести к фрагментации данных в базе данных и отрицательно сказаться на производительности, потому что каждый раз при записи данных в базу потребуется дополнительная обработка. Чтобы в любое время принудительно восстановить неиспользуемое место в файле базы данных и дефрагментировать этот файл, используется метод <codeph>compact()</codeph>.
	 
	 <p>Этот параметр игнорируется, если параметр <codeph>openMode</codeph> имеет значение <codeph>SQLMode.READ</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>pageSize</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1024</apiData><apiDesc>Указывает размер страницы базы данных (в байтах). Этот параметр допустим только при создании новой базы данных или при открытии файла базы данных, в которой нет созданных таблиц. Значением должна быть степень двойки, которая больше или равна 512, но меньше или равна 32768. Значением по умолчанию является 1024 байта. Данное значение можно задать только до создания таблиц. При попытке изменить это значение после создания таблиц будет выдана ошибка. 
     
	 </apiDesc></apiParam><apiParam><apiItemName>encryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Ключ шифрования для файла базы данных. Если вызов метода <codeph>openAsync()</codeph> создает базу данных, эта база данных шифруется, а указанный ключ используется в качестве ключа шифрования базы данных. Если вызов этого метода открывает зашифрованную базу данных, это значение должно совпадать с ключом шифрования базы данных, иначе произойдет ошибка. Если открываемая база данных не зашифрована, это значение должно быть <codeph>null</codeph> (по умолчанию), иначе произойдет ошибка.
	 
	 <p>Действительным считается ключ шифрования длиной 16 байтов. Базу данных в памяти зашифровать невозможно, поэтому этот параметр должен иметь значение <codeph>null</codeph>, если параметр <codeph>reference</codeph> имеет значение <codeph>null</codeph>.</p>
	 
	 <p>Если при открытии зашифрованной базы данных предоставленный ключ шифрования не совпадает с ключом шифрования базы данных, отправляется событие SQLErrorEvent. Свойство <codeph>error</codeph> объекта события содержит экземпляр SQLError. Свойство <codeph>errorID</codeph> этого объекта SQLError имеет значение 3138 («Открытый файл не является файлом базы данных»).</p>
	 
	 <p>Параметр <codeph>encryptionKey</codeph> доступен, начиная с AIR 1.5.</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Открывает асинхронное подключение к файлу базы данных с заданным местоположением в файловой системе, создает и открывает новый файл базы данных с заданным местоположением или создает и открывает базу данных в оперативной памяти. Операции создания и открытия базы данных, а также все остальные операции, выполняемые с использованием данного экземпляра SQLConnection, выполняются <i>асинхронно</i> при открытии базы данных с помощью этого метода. Это включает в себя выполнение инструкций и другие операции, выполняемые экземпляром SQLStatement, связанным с данным экземпляром SQLConnection. Для синхронного выполнения операций вместо него подключение базы данных следует открывать с помощью метода <codeph>open()</codeph>.
     
	 <p>Подключив базу данных, используйте экземпляр <xref href="SQLStatement.html">SQLStatement</xref> для выполнения инструкций SQL. Операции на уровне базы данных, такие как начало или завершение транзакций, загрузка данных схемы и другие, выполняются при помощи экземпляра SQLConnection.</p>
     
     <p>Базе данных, присоединенной с помощью метода <codeph>openAsync()</codeph>, автоматически назначается имя main, которое можно использовать для явного указания имен таблиц в операторах SQL в формате <codeph>[database-name]. [table-name]</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link><link href="flash.data.xml#SQLMode"><linktext>flash.data.SQLMode</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:openAsync_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:openAsync_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции. Соединение никогда не остается открытым после сбоя операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:reencrypt"><apiName>reencrypt</apiName><shortdesc>
	 Изменяет ключ шифрования зашифрованной базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Когда значение <codeph>newEncryptionKey</codeph> имеет значение <codeph>null</codeph> или его свойство <codeph>length</codeph> не равно 16 байтам.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если подключение не открыто или имеется открытая транзакция.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newEncryptionKey</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, содержащий новый ключ шифрования базы данных. Действительным считается ключ шифрования длиной 16 байтов.
	 
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. Если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>reencrypt</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Изменяет ключ шифрования зашифрованной базы данных. Этот метод влияет на ключ шифрования только главной базы данных (базы данных, подключенной с помощью метода <codeph>open()</codeph> или <codeph>openAsync()</codeph>). Метод <codeph>reencrypt()</codeph> можно вызвать только для базы данных, которая была зашифрована при создании. После создания зашифрованной базы данных она не может быть расшифрована. Таким же образом база данных, созданная без шифрования, не может быть впоследствии зашифрована.
	 
	 <p>Операция повторного шифрования выполняется в собственной транзакции. Если процесс повторного шифрования прерывается, база данных выполняет откат транзакции и ключ шифрования не меняется.</p> 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/attach()"><linktext>attach()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:reencrypt_reencrypt"><apiName>reencrypt</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:reencrypt_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLConnection:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
     
	Удаляет прослушиватель из объекта EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Удаляемый объект прослушивателя.
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Этот параметр применяется для отображения объектов в архитектуре списка отображения ActionScript 3.0, используемой в SWF-содержимом. </ph> <ph platform="actionscript">Указывает, был ли прослушиватель зарегистрирован для фазы захвата или целевой фазы и фазы восходящей цепочки. Если прослушиватель зарегистрирован и для фазы захвата, и для фаз цели и восходящей цепочки, метод <codeph>removeEventListener()</codeph> необходимо вызвать дважды: один раз с <codeph>useCapture()</codeph> в значении <codeph>true</codeph>, а другой раз с <codeph>useCapture()</codeph> в значении <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
     
	Удаляет прослушиватель из объекта EventDispatcher. При отсутствии прослушивателя, зарегистрированного с объектом EventDispatcher, вызов этого метода не оказывает эффекта.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLConnection:rollback"><apiName>rollback</apiName><shortdesc>
     Выполняет откат существующей транзакции, созданной с помощью метода begin(), то есть все изменения, внесенные любыми инструкциями SQL в рамках данной транзакции, отменяются.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>), или если в текущий момент нет открытых транзакций (свойство <codeph>inTransaction</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
     </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>rollback</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет откат существующей транзакции, созданной с помощью метода <codeph>begin()</codeph>, то есть все изменения, внесенные любыми инструкциями SQL в рамках данной транзакции, отменяются.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLConnection:rollback_rollback"><apiName>rollback</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLConnection:rollback_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLConnection:autoCompact:get"><apiName>autoCompact</apiName><shortdesc>
     Указывает, было ли включено автоматическое сжатие при создании текущей базы данных (значение параметра autoCompact, указанное при вызове метода open() или openAsync(), с помощью которого была создана база данных).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, было ли включено автоматическое сжатие при создании текущей базы данных (значение параметра <codeph>autoCompact</codeph>, указанное при вызове метода <codeph>open()</codeph> или <codeph>openAsync()</codeph>, с помощью которого была создана база данных). Если это свойство имеет значение <codeph>true</codeph>, неиспользуемое место автоматически удаляется из базы данных после каждой операции записи, тем самым уменьшая размер файла базы данных. Если это свойство имеет значение <codeph>false</codeph>, место, занимаемое данными до удаления, остается в базе данных и при необходимости используется повторно. Даже если свойство <codeph>autoCompact</codeph> имеет значение <codeph>false</codeph>, с помощью метода <codeph>compact()</codeph> можно выполнить принудительное восстановление неиспользуемого места.
     
     <p>Если свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>, это свойство имеет значение <codeph>false</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:cacheSize:get"><apiName>cacheSize</apiName><shortdesc>
     Обеспечивает доступ к величине размера кэша данного подключения. Эта величина – максимальное количество дисковых страниц базы данных, которые могут одновременно находиться в памяти.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Если осуществляется попытка задать это свойство, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>), или если в текущий момент открыта транзакция (свойство <codeph>inTransaction</codeph> имеет значение <codeph>true</codeph>).
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Обеспечивает доступ к величине размера кэша данного подключения. Эта величина – максимальное количество дисковых страниц базы данных, которые могут одновременно находиться в памяти. Каждая страница использует около 1,5 КБ памяти (в зависимости от значения параметра <codeph>pageSize</codeph>, указанного при вызове метода <codeph>open()</codeph> или <codeph>openAsync()</codeph>, с помощью которого была создана база данных). Размер кэша по умолчанию равен 2000. Если в приложении выполняются операции <codeph>UPDATE</codeph> или <codeph>DELETE</codeph>, которые изменяют большое количество строк в базе данных, увеличив размер кэша, можно ускорить работу за счет повышенного потребления памяти.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:columnNameStyle:get"><apiName>columnNameStyle</apiName><shortdesc>
     Указывает, в каком виде имена столбцов представлены в результате выполнения инструкции SELECT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Если предпринимается попытка задать это свойство, когда экземпляр SQLConnection не подключен к базе данных (свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Указывает, в каком виде имена столбцов представлены в результате выполнения инструкции <codeph>SELECT</codeph>.
     
     <p>Константы, определенные в классе SQLColumnNameStyle, представляют собой возможные значения данного свойства:</p>
     
     <ul>
         <li><codeph>SQLColumnNameStyle.LONG</codeph> обозначает, что имена столбцов возвращаются в формате <codeph>[table-name]_[column-name]</codeph>.</li>
         <li><codeph>SQLColumnNameStyle.SHORT</codeph> обозначает, что имена столбцов имеют формат <codeph>[column-name]</codeph>. Если существует несколько столбцов с одинаковым именем, в результирующий объект будет добавлено только одно свойство с таким именем.</li>
         <li><codeph>SQLColumnNameStyle.DEFAULT</codeph> является значением по умолчанию. Если используется это значение, то имена столбцов в результате форматируются в соответствии с количеством таблиц в инструкции <codeph>SELECT</codeph>, в которых есть столбцы с одинаковыми именами. Если в инструкции <codeph>SELECT</codeph> содержится только одна таблица, используется краткий формат имен <codeph>[column-name]</codeph>. Если в инструкции <codeph>SELECT</codeph> содержится несколько таблиц, соединенных вместе, всякий раз, когда из-за двух столбцов с одинаковым именем возникает конфликт имен, для них используется длинный формат имен <codeph>[table-name]_[column-name]</codeph>.</li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnNameStyle"><linktext>flash.data.SQLColumnNameStyle</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:connected:get"><apiName>connected</apiName><shortdesc>
     Указывает, имеет ли экземпляр SQLConnection открытое подключение к файлу базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, имеет ли экземпляр SQLConnection открытое подключение к файлу базы данных.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link><link href="flash.data.xml#SQLConnection/close()"><linktext>close()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:inTransaction:get"><apiName>inTransaction</apiName><shortdesc>
	 Указывает, используется ли это подключение транзакциями в данный момент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, используется ли это подключение транзакциями в данный момент.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/begin()"><linktext>begin()</linktext></link><link href="flash.data.xml#SQLConnection/commit()"><linktext>commit()</linktext></link><link href="flash.data.xml#SQLConnection/rollback()"><linktext>rollback()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     Последний идентификатор строки, созданный инструкцией SQL INSERT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Последний идентификатор строки, созданный инструкцией SQL <codeph>INSERT</codeph>. Уникальный идентификатор строки в таблице, используемый для поиска в базе данных. Это значение часто генерируется базой данных.
	 
     <p>Значение равно нулю, если ни одна база данных не подключена или не выполнено ни одной инструкции <codeph>INSERT</codeph>.</p>
	 
	 <p>Идентификатор строки для однократного выполнения инструкции SQL <codeph>INSERT</codeph> можно получить через свойство <codeph>lastInsertRowID</codeph> объекта SQLResult, возвращенного методом <codeph>getResult()</codeph> объекта SQLStatement (когда он вызывается после отправки объектом SQLStatement события <codeph>result</codeph>).</p>
	 
	 <p>Дополнительные сведения о первичных ключах и генерируемых идентификаторах строк см. в разделах <xref href="../../localDatabaseSQLSupport.html#createTable">CREATE TABLE</xref> и <xref href="../../localDatabaseSQLSupport.html#expressions">«Выражения»</xref> приложения <xref href="../../localDatabaseSQLSupport.html">«Поддержка SQL в локальных базах данных»</xref>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/lastInsertRowID"><linktext>flash.data.SQLResult.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:pageSize:get"><apiName>pageSize</apiName><shortdesc>
     Указывает размер страницы базы данных (в байтах), заданный при создании текущей базы данных (значение параметра pageSize, указанное при вызове метода open() или openAsync(), с помощью которого была создана база данных).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Указывает размер страницы базы данных (в байтах), заданный при создании текущей базы данных (значение параметра <codeph>pageSize</codeph>, указанное при вызове метода <codeph>open()</codeph> или <codeph>openAsync()</codeph>, с помощью которого была создана база данных).
     
     <p>Если свойство <codeph>connected</codeph> имеет значение <codeph>false</codeph>, это значение данного свойства равно 0.</p>
     
	 <p>Размер страницы базы данных можно менять (с помощью методов <codeph>open()</codeph> или <codeph>openAsync()</codeph>), пока в базе данных не будет создана первая таблица.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLConnection:totalChanges:get"><apiName>totalChanges</apiName><shortdesc>
     Содержит общее число изменений данных, выполненных с момента открытия подключения к базе данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Содержит общее число изменений данных, выполненных с момента открытия подключения к базе данных. Кроме отслеживания изменений, сделанных с помощью инструкций <codeph>INSERT</codeph>, <codeph>DELETE</codeph> и <codeph>UPDATE</codeph>, это значение включает изменения, вызванные триггерами.
	 
	 <p>При закрытии подключения к базе данных это значение сбрасывается в 0. Когда экземпляр SQLConnection не подключен к файлу базы данных, значение равно 0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/rowsAffected"><linktext>flash.data.SQLResult.rowsAffected</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
 Экземпляр SQLTriggerSchema используется для хранения сведений об определенном триггере базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLTriggerSchema используется для хранения сведений об определенном триггере базы данных. Он содержит имя триггера (свойство <codeph>name</codeph>), имя связанной таблицы (свойство <codeph>table</codeph>) и инструкцию SQL, используемый для создания триггера (свойство <codeph>sql</codeph>).
 
 <p>Для получения сведений о схеме триггера базы данных используется метод <codeph>SQLConnection.loadSchema()</codeph>, с помощью которого загружаются данные схемы. Следует предварительно убедиться, что в качестве аргумента <codeph>type</codeph> используется значение <codeph>null</codeph> или <codeph>SQLTriggerSchema</codeph>. В полученном экземпляре SQLSchemaResult свойство <codeph>triggers</codeph> содержит массив экземпляров SQLTriggerSchema, представляющих триггеры базы данных.</p>
 
 <p>Как правило, экземпляры SQLTriggerSchema не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLTriggerSchema:SQLTriggerSchema"><apiName>SQLTriggerSchema</apiName><shortdesc>
     Создает экземпляр SQLTriggerSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя связанной базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя триггера.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Инструкция SQL, используемая для создания триггера.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя таблицы, связанной с триггером.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLTriggerSchema. Как правило, конструктор SQLTriggerSchema не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLTriggerSchema:table:get"><apiName>table</apiName><shortdesc>
     Имя таблицы, для которой определен триггер, или имя представления, если триггер определен для представления.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Имя таблицы, для которой определен триггер, или имя представления, если триггер определен для представления.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
 Экземпляр SQLStatement используется для выполнения инструкции SQL в локальной базе данных SQL, открытой с помощью экземпляра SQLConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLStatement используется для выполнения инструкции SQL в локальной базе данных SQL, открытой с помощью экземпляра SQLConnection.
 
 <p>Чтобы связать экземпляр SQLStatement с экземпляром SQLConnection, необходимо задать экземпляр SQLConnection в качестве значения свойства <codeph>sqlConnection</codeph> экземпляра SQLStatement. Свойство <codeph>text</codeph> заполняется имеющимся текстом выполняемой инструкции SQL. При необходимости значения параметров инструкции SQL задаются с помощью свойства <codeph>parameters</codeph>, а для выполнения самой инструкции нужно вызвать метод <codeph>execute()</codeph>.</p>
 
 <p>Полное описание диалекта SQL, поддерживаемого в локальных базах данных SQL, см. в приложении <xref href="../../localDatabaseSQLSupport.html">«Поддержка SQL в локальных базах данных»</xref>.</p>
 
 <p>В асинхронном режиме выполнения методы <codeph>execute()</codeph> и <codeph>next()</codeph> выполняются в фоновом потоке, и при завершении или сбое операций среда выполнения отправляет события зарегистрированным прослушивателям событий или заданному экземпляру Responder. В синхронном режиме методы выполняются в основном потоке приложения. Это означает, что никакой другой код не может быть выполнен до тех пор, пока не завершатся текущие операции в базе данных. Кроме того, если в синхронном режиме выполнения произошел сбой метода, вместо отправки события ошибки среда выполнения генерирует исключение.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection"><linktext>flash.data.SQLConnection</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc>
 Отправляется, если во время операции произошла ошибка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если во время операции произошла ошибка.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>выполнить()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement_flash.events.SQLEvent.RESULT_result"><apiName>result</apiName><shortdesc>
 Отправляется при успешном вызове метода execute() или next().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SQLEvent.RESULT</apiEventType><adobeApiEventClassifier>flash.events.SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при успешном вызове метода <codeph>execute()</codeph> или <codeph>next()</codeph>. После того как было отправлено событие <codeph>result</codeph>, для получения результатов выполнения инструкции можно вызвать метод <codeph>getResult()</codeph>.
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>выполнить()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.data:SQLStatement:SQLStatement"><apiName>SQLStatement</apiName><shortdesc>
     Создает экземпляр SQLStatement.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Если конструктор вызывается из какой-либо изолированной среды за пределами главной изолированной среды приложения. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
     Создает экземпляр SQLStatement.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.data:SQLStatement:cancel"><apiName>cancel</apiName><shortdesc>
     Отменяет выполнение инструкции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Отменяет выполнение инструкции. Как и метод <codeph>SQLConnection.cancel()</codeph>, данный метод используется, чтобы остановить продолжительный запрос или отменить запрос, находящийся в процессе выполнения. Однако, в отличие от метода <codeph>SQLConnection.cancel()</codeph>, этот метод отменяет только одну инструкцию. Если инструкции в текущий момент не выполняются, в результате вызова этого метода ничего не произойдет.
	 
	 <p>Непосредственно в ответ на завершение операции <codeph>cancel()</codeph> события не отправляются. Однако, если завершается операция <codeph>cancel()</codeph> и отменяется выполнение инструкции, экземпляр SQLStatement отправляет событие <codeph>error</codeph>, которое обозначает, что выполнение инструкции (вызов метода <codeph>execute()</codeph> или <codeph>next()</codeph>) не завершено. Если же при вызове метода <codeph>execute()</codeph> или <codeph>next()</codeph> задано значение параметра <codeph>responder</codeph>, будет вызван соответствующий обработчик ошибки. В любом случае у экземпляра SQLError, передаваемого прослушивателям, свойство <codeph>errorID</codeph> будет иметь значение 3118 («Операция прервана»).</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:SQLStatement:clearParameters"><apiName>clearParameters</apiName><shortdesc>
     Удаляет все текущие значения параметров.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет все текущие значения параметров.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/parameters"><linktext>параметры</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:execute"><apiName>execute</apiName><shortdesc>
     Выполняет инструкцию SQL, которая содержится в свойстве text, применительно к базе данных, подключенной к объекту SQLConnection в свойстве sqlConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если свойство <codeph>text</codeph> имеет значение <codeph>null</codeph> или содержит пустую строку (<codeph>""</codeph>); если свойство <codeph>sqlConnection</codeph> не задано; если экземпляр SQLConnection, указанный в свойстве <codeph>sqlConnection</codeph>, не подключен или если оператор выполняется в текущий момент.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если произошел сбой операции в синхронном режиме выполнения.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Когда в свойстве <codeph>text</codeph> задана инструкция <codeph>SELECT</codeph>, это значение обозначает количество строк, возвращаемых инструкцией за один раз. Значение по умолчанию равно -1. Это значит, что все строки результата будут возвращены инструкцией за один раз. Этот параметр используется совместно с методом <codeph>next()</codeph> для разделения больших результирующих наборов на меньшие наборы данных. При более быстром возврате результатов и разделении операций по их обработке приложение будет восприниматься пользователями как более производительное.
     
     <p>Если инструкция SQL представляет собой запрос <codeph>SELECT</codeph> и задан аргумент <codeph>prefetch</codeph>, значение которого больше нуля, данная инструкция будет выполняться до тех пор, пока не будет возвращен весь результирующий набор или не будет вызван один из методов <codeph>SQLStatement.cancel()</codeph> или <codeph>SQLConnection.cancel()</codeph>. Следует заметить, что из-за того, что во время выполнения количество строк в результирующем наборе неизвестно, курсор базы данных должен переместиться за последнюю строку результирующего набора до того, как завершится выполнение оператора. Если аргумент <codeph>prefetch</codeph> задан при вызове метода <codeph>execute()</codeph>, необходимо запросить не менее чем на одну запись больше, чем общее количество записей в результирующем наборе (либо с помощью значения <codeph>prefetch</codeph>, которое превышает количество строк в результирующем наборе, либо с помощью последующих вызовов метода <codeph>next()</codeph>), прежде чем свойство <codeph>complete</codeph> экземпляра SQLResult станет равным <codeph>true</codeph>.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. При асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>result</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет инструкцию SQL, которая содержится в свойстве <codeph>text</codeph>, применительно к базе данных, подключенной к объекту SQLConnection в свойстве <codeph>sqlConnection</codeph>.
     
	 <p>В асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение, отличное от <codeph>null</codeph>, указанный объект Responder обозначает методы, вызываемые для обработки результатов операции. Если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, при успешном завершении операции отправляется событие <codeph>result</codeph>, а при сбое – событие <codeph>error</codeph>.</p>
	 
	 <p>Чтобы просмотреть результат выполнения инструкции, например строки, созданные в результате выполнения инструкции <codeph>SELECT</codeph>, или первичный ключ инструкции <codeph>INSERT</codeph>, созданный базой данных, необходимо вызвать метод <codeph>getResult()</codeph>. Результаты можно просмотреть сразу после выполнения инструкции в синхронном режиме, а также после отправки события <codeph>result</codeph> в асинхронном режиме.</p>
     
     <p>Перед выполнением каждая инструкция должна быть подготовлена (скомпилирована). При первом вызове метода <codeph>execute()</codeph> экземпляра SQLStatement среда выполнения подготавливает инструкцию. Когда инструкция подготовлена, она больше не требует повторной подготовки до тех пор, пока не изменится свойство <codeph>text</codeph>. Задание одного или нескольких параметров не требует повторной подготовки инструкции.</p>
	 
     </apiDesc><example conref="examples\SQLStatement.execute.1.as"> Следующий пример иллюстрирует выполнение SQLStatement с использованием прослушивателей событий для определения завершения или сбоя выполнения инструкции.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example><example conref="examples\SQLStatement.execute.2.as"> Следующий пример иллюстрирует выполнение SQLStatement с использованием объекта Responder для указания на функции, вызываемые при завершении или сбое выполнения инструкции.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;
var employeeResponder:Responder;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    employeeResponder = new Responder(resultHandler, errorHandler);
    dbStatement.execute(-1, employeeResponder);
}

function resultHandler(result:SQLResult):void
{
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
    }
}

function errorHandler(error:SQLError):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/getResult()"><linktext>getResult()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:execute_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного выполнения инструкции или в том случае, если указано значение аргумента <codeph>prefetch</codeph>, а инструкция <codeph>SELECT</codeph> возвращает одну или несколько строк данных.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного выполнения инструкции или в том случае, если задано значение аргумента prefetch, а инструкция SELECT возвращает одну или несколько строк данных.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:execute_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.data:SQLStatement:getResult"><apiName>getResult</apiName><shortdesc>
     Обеспечивает доступ к объекту SQLResult, который содержит результаты выполнения инструкции, включая все строки результата выполнения инструкции SELECT и другие сведения о выполнении всех выполненных инструкций.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект SQLResult, который содержит результат вызова метода <codeph>execute()</codeph> или <codeph>next()</codeph>.
     
     </apiDesc><apiOperationClassifier>flash.data:SQLResult</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Обеспечивает доступ к объекту SQLResult, который содержит результаты выполнения инструкции, включая все строки результата выполнения инструкции <codeph>SELECT</codeph> и другие сведения о выполнении всех выполненных инструкций. В асинхронном режиме выполнения данные результата не будут доступны, пока не отправлено событие <codeph>result</codeph>.
     
     <p>Если при выполнении инструкции <codeph>SELECT</codeph> метод <codeph>execute()</codeph> вызван с аргументом <codeph>prefetch</codeph>, имеющим значение по умолчанию -1, возвращаемый объект SQLResult будет содержать весь результирующий набор запроса.</p>
     
     <p>Если аргумент <codeph>prefetch</codeph> указан при вызове метода <codeph>execute()</codeph> или <codeph>next()</codeph>, метод <codeph>getResult()</codeph> работает как очередь результатов с порядком доступа к элементам «первым поступил – первым обслужен» (FIFO, First In – First Out). Каждый раз при отправке события <codeph>result</codeph> к очереди добавляется новый объект SQLResult. Каждый раз при вызове метода <codeph>getResult()</codeph> возвращается и удаляется из очереди самый первый объект SQLResult (тот, который был добавлен в очередь первым). Если в очереди не осталось объектов SQLResult, метод <codeph>getResult()</codeph> возвращает <codeph>null</codeph>.</p>
	 
	 <p>Следует заметить, что до удаления с помощью метода <codeph>getResult()</codeph> объекты SQLResult остаются в очереди. Например, если метод <codeph>execute()</codeph> вызывается несколько раз без вызова метода <codeph>getResult()</codeph>, объекты SQLResult, связанные с каждым вызовом метода <codeph>execute()</codeph>, остаются в очереди.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>выполнить()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>next()</linktext></link><link href="flash.data.xml#SQLStatement/result"><linktext>result</linktext></link></related-links></apiOperation><apiOperation id="flash.data:SQLStatement:next"><apiName>next</apiName><shortdesc>
     Извлекает следующую часть результирующего набора инструкции SELECT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если метод вызывается, а оператор в текущий момент не выполняется (свойство <codeph>executing</codeph> имеет значение <codeph>false</codeph>).
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>если произошел сбой операции в синхронном режиме выполнения.
     
	 </apiDesc><apiItemName>SQLError</apiItemName><apiOperationClassifier>flash.errors:SQLError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>prefetch</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Когда в свойстве <codeph>text</codeph> задана инструкция <codeph>SELECT</codeph>, это значение обозначает количество строк, возвращаемых инструкцией за один раз. Значение по умолчанию равно -1. Это значит, что все строки результата будут возвращены инструкцией за один раз. При более быстром возврате результатов и разделении операций по их обработке приложение будет восприниматься пользователями как более производительное.
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, для которого определены методы, вызываемые при успешном выполнении или сбое операции. Если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, по окончании выполнения отправляется событие <codeph>result</codeph> или <codeph>error</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Извлекает следующую часть результирующего набора инструкции <codeph>SELECT</codeph>. Если в результирующем наборе больше не осталось строк, событие <codeph>result</codeph> отправляется, но в очередь <codeph>getResult()</codeph> больше не добавляются объекты SQLResult.
     
     <p>В асинхронном режиме выполнения, если аргумент <codeph>responder</codeph> имеет значение, отличное от <codeph>null</codeph>, указанный объект Responder обозначает методы, вызываемые для обработки результатов операции. Если аргумент <codeph>responder</codeph> имеет значение <codeph>null</codeph>, при успешном завершении операции отправляется событие <codeph>result</codeph>, а при сбое – событие <codeph>error</codeph>.</p>
     
     <p>Этот метод может быть вызван только во время выполнения оператора. Если инструкция SQL представляет собой запрос <codeph>SELECT</codeph> и задан аргумент <codeph>prefetch</codeph>, значение которого больше нуля, инструкции будут выполняться до тех пор, пока не будет возвращен весь результирующий набор или не будет вызван метод <codeph>SQLStatement.cancel()</codeph> или <codeph>SQLConnection.cancel()</codeph>.</p>
     
     </apiDesc><example conref="examples\SQLStatement.next.1.as"> Следующий пример иллюстрирует выполнение SQLStatement с явным указанием того, что при первом возврате результатов необходимо возвратить только первые 10 строк набора результатов. Код проверяет свойство <codeph>complete</codeph> объекта SQLResult и, если получены не все строки, вызывает метод <codeph>next()</codeph>.
<codeblock>
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);
    dbStatement.execute(10);
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            var row:Object = result.data[i];
            trace("id:", row.id, ", name:", row.name, ", ssn:", row.ssn);
        }
        if (!result.complete)
        {
            dbStatement.next(10);
        }
    }
}

function errorHandler(event:SQLErrorEvent):void
{
    trace("An error occured while executing the statement.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>выполнить()</linktext></link></related-links><adobeApiEvent id="flash.data:SQLStatement:next_result"><apiName>result</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного выполнения инструкции или в том случае, если указано значение аргумента <codeph>prefetch</codeph> и метод <codeph>next()</codeph> возвращает одну или несколько строк данных.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного выполнения инструкции или в том случае, если задано значение аргумента prefetch и метод next() возвращает одну или несколько строк данных.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.data:SQLStatement:next_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SQLErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после сбоя операции в асинхронном режиме выполнения.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после сбоя операции в асинхронном режиме выполнения.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.data:SQLStatement:executing:get"><apiName>executing</apiName><shortdesc>
     Указывает, выполняется ли инструкция в текущий момент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, выполняется ли инструкция в текущий момент.
     
     <p>Это свойство имеет значение true, если после вызова метода <codeph>execute()</codeph> из базы данных были возвращены не все результаты.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>выполнить()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:itemClass:get"><apiName>itemClass</apiName><shortdesc>
     Обозначает класс (тип данных), который используется для каждой строки, возвращенной в результате выполнения инструкции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Class</apiValueClassifier></apiValueDef><apiDesc>
     Обозначает класс (тип данных), который используется для каждой строки, возвращенной в результате выполнения инструкции.
     
     <p platform="javascript">Это свойство предназначено для использования только в приложении AIR на основе SWF. Оно недоступно в JavaScript. (ActionScript позволяет определить пользовательские классы, которые можно использовать с этим свойством.)</p>
     
     <p platform="actionscript">По умолчанию каждая строка, возвращаемая инструкцией <codeph>SELECT</codeph>, создается в виде экземпляра Object, при этом имена столбцов результирующего набора совпадают с именами свойств объекта, а значение каждого столбца равно значению соответствующего свойства.</p>
     
     <p platform="actionscript">Если в свойстве <codeph>itemClass</codeph> указать класс, каждая строка, возвращаемая инструкцией <codeph>SELECT</codeph>, которая выполняется данным экземпляром SQLStatement, создается в виде объекта заданного класса. Каждому свойству экземпляра <codeph>itemClass</codeph> присваивается значение из столбца с таким же именем, как и у свойства.</p>
     
     <p platform="actionscript">Любой класс, указанный в этом свойстве, должен иметь конструктор без параметров. Кроме того, в этом классе должно быть определено по одному свойству для каждого столбца, возвращаемого инструкцией <codeph>SELECT</codeph>. Считается ошибкой, если у столбца из списка <codeph>SELECT</codeph> в классе <codeph>itemClass</codeph> нет свойства с соответствующим именем.</p>
     
     </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> Следующий код иллюстрирует использование свойства <codeph>itemClass</codeph> для создания во время выполнения экземпляров пользовательского класса из результатов, возвращенных инструкцией SQL <codeph>SELECT</codeph>.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLResult/data"><linktext>flash.data.SQLResult.data</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:parameters:get"><apiName>parameters</apiName><shortdesc>
     Служит в качестве ассоциативного массива, в который добавляются значения параметров, заданных в свойстве text инструкции SQL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Служит в качестве ассоциативного массива, в который добавляются значения параметров, заданных в свойстве <codeph>text</codeph> инструкции SQL. Ключами массива являются имена параметров. Если в тексте инструкции имеется параметр без имени, его ключом является индекс параметра.
     
     <p>Внутри текста инструкции SQL параметры обозначаются с помощью одного из следующих символов: «?», «:» или «@».</p>
     
     <p>Маркеры «:» и «@» обозначают именованный параметр, а символы, следующие после маркера, обозначают имя параметра.</p>
     
     <p>Например, в следующей инструкции SQL параметр с именем <codeph>firstName</codeph> задан с помощью символа «:»:</p>
     
     <pre>SELECT FROM employees WHERE firstName = :firstName</pre>
     
     <p>Маркер «?» обозначает проиндексированный (нумерованный) параметр. Каждому параметру автоматически назначается индекс в зависимости от последовательности параметров в тексте инструкции. Индексы параметров начинаются с нуля. Иными словами, индекс первого параметра равен 0.</p>
     
     <p>Параметры используются для типизированной подстановки значений, которые неизвестны во время создания инструкции SQL. Использование параметров — это единственный способ обеспечить класс хранения значения, передаваемого в базу данных. Если параметры не используются, все значения преобразуются из своего текстового представления к классу хранения с учетом типов соответствующих столбцов. Дополнительные сведения о классах хранения и соответствии столбцов см. в разделе <xref href="../../localDatabaseSQLSupport.html#dataTypes">«Поддержка типов данных»</xref> в приложении <xref href="../../localDatabaseSQLSupport.html">«Поддержка SQL в локальных базах данных»</xref>.</p>
     
     <p>Параметры также используются как мера безопасности с целью предотвращения такого метода взлома, как атака путем внедрения кода SQL (SQL-инъекция). При атаке путем внедрения кода SQL пользователь вводит код SQL в доступное ему место (например, в поле ввода данных). Если приложение формирует инструкции SQL, непосредственно добавляя в текст инструкции данные, введенные пользователем, то в базе данных выполнится код SQL, введенный злоумышленником. В следующем примере показано добавление данных, введенных пользователем, в текст инструкции SQL. <b>Этот способ использовать нельзя</b>:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = '" + username + "' " +
         "    AND password = '" + password + "'";
     var statement = new air.SQLStatement();
     statement.text = sql;
     </codeblock>
     
     <p>Использование параметров инструкции вместо добавления в его текст пользовательских значений предотвращает атаку путем внедрения кода SQL, потому что значения параметров обрабатываются явным образом как подставляемые значения, а не становятся частью текста инструкции. Ниже приведена рекомендуемая альтернатива предыдущему примеру:</p>
     
     <codeblock platform="actionscript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql:String =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement:SQLStatement = new SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <codeblock platform="javascript">
	 // assume the variables "username" and "password"
     // contain user-entered data
     var sql =
         "SELECT userId " +
         "FROM users " +
         "WHERE username = :username " +
         "    AND password = :password";
     var statement = new air.SQLStatement();
     statement.text = sql;
     // set parameter values
     statement.parameters[":username"] = username;
     statement.parameters[":password"] = password;
     </codeblock>
     
     <p>Перед выполнением инструкции должны быть заданы значения всех параметров. Связывание (т. е. объединение с текстом инструкции) значений параметров, заданных в массиве <codeph>parameters</codeph>, осуществляется при вызове метода <codeph>execute()</codeph>. После вызова метода <codeph>execute()</codeph> никакие последующие изменения значений не будут применены к выполняемой инструкции. Однако при последующем вызове метода <codeph>execute()</codeph> будут использоваться измененные значения. Если в тексте инструкции есть параметр, для которого в свойстве <codeph>parameters</codeph> не задано значение, возникнет ошибка.</p>
     
     <p>Чтобы удалить значения всех параметров в свойстве <codeph>parameters</codeph>, используется метод <codeph>clearParameters()</codeph>.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.parameters.1.as"> Следующий пример иллюстрирует использование именованного параметра <codeph>:firstName</codeph> в инструкции SQL.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = :firstName";
employees.parameters[":firstName"] = "Sam";
employees.execute();
</codeblock></example><example conref="examples\SQLStatement.parameters.2.as"> Следующий пример иллюстрирует использование параметра без имени в инструкции SQL.
<codeblock>
// employees is a SQLStatement instance
employees.text = "SELECT FROM employees WHERE first = ?";
employees.parameters[0] = "Sam";
employees.execute();
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/text"><linktext>text</linktext></link><link href="flash.data.xml#SQLStatement/clearParameters()"><linktext>clearParameters()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLStatement:sqlConnection:get"><apiName>sqlConnection</apiName><shortdesc>
     Объект SQLConnection, который управляет подключением к одной или нескольким базам данных, применительно к которым выполняется инструкция.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.data:SQLConnection</apiValueClassifier><apiException><apiDesc>Если во время выполнения инструкции была предпринята попытка изменить значение этого свойства.
	 
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Объект SQLConnection, который управляет подключением к одной или нескольким базам данных, применительно к которым выполняется инструкция.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.data:SQLStatement:text:get"><apiName>text</apiName><shortdesc>
     Фактический текст инструкции SQL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Если во время выполнения инструкции была предпринята попытка изменить значение свойства <codeph>text</codeph>.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Фактический текст инструкции SQL.
	 
     <p>Текстом может быть любая допустимая конструкция языка SQL. Полное описание диалекта SQL, поддерживаемого в локальных базах данных SQL, см. в приложении <xref href="../../localDatabaseSQLSupport.html">«Поддержка SQL в локальных базах данных»</xref>.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLMode"><apiName>SQLMode</apiName><shortdesc>
 Этот класс содержит константы, представляющие возможные значения параметра openMode методов SQLConnection.open() и SQLConnection.openAsync().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс содержит константы, представляющие возможные значения параметра <codeph>openMode</codeph> методов <codeph>SQLConnection.open()</codeph> и <codeph>SQLConnection.openAsync()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links><apiValue id="flash.data:SQLMode:CREATE"><apiName>CREATE</apiName><shortdesc>
	 Указывает, что подключение открыто для обновлений и в случае отсутствия указанного файла базы данных создается новый.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>create</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что подключение открыто для обновлений и в случае отсутствия указанного файла базы данных создается новый. В этом режиме для базы данных разрешены чтение и запись. Если база данных отсутствует, она создается до завершения операции.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:READ"><apiName>READ</apiName><shortdesc>
	 Указывает, что подключение открыто в режиме только для чтения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что подключение открыто в режиме только для чтения. В этом режиме запрещены операции записи в базу данных. Если база данных отсутствует, происходит сбой операции открытия.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLMode:UPDATE"><apiName>UPDATE</apiName><shortdesc>
	 Указывает, что подключение открыто для обновлений, но в случае отсутствия указанного файла базы данных новый не создается.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что подключение открыто для обновлений, но в случае отсутствия указанного файла базы данных новый не создается. В этом режиме для базы данных разрешены чтение и запись. Если база данных отсутствует, происходит сбой операции открытия.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/open()"><linktext>flash.data.SQLConnection.open()</linktext></link><link href="flash.data.xml#SQLConnection/openAsync()"><linktext>flash.data.SQLConnection.openAsync()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:EncryptedLocalStore"><apiName>EncryptedLocalStore</apiName><shortdesc>
	Класс EncryptedLocalStore содержит методы задания и получения объектов в зашифрованном локальном хранилище данных приложения AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Класс EncryptedLocalStore содержит методы задания и получения объектов в зашифрованном локальном хранилище данных приложения AIR. Устойчивое зашифрованное локальное хранилище доступно для каждого приложения AIR, установленного на пользовательском компьютере. Это позволяет сохранять и извлекать данные, которые хранятся на локальном жестком диске пользователя в зашифрованном формате, который не может быть расшифрован другими приложениями или пользователями. Отдельное зашифрованное локальное хранилище используется для каждого приложения AIR, а каждое приложение AIR использует такое хранилище для каждого пользователя. 
	
	<p>Зашифрованное локальное хранилище может использоваться для хранения информации, требующей защиты, например, учетных данных для входа, используемых web-службами.</p>
	
	<p>Во время тестирования приложения в AIR Debug Launcher (ADL) оно использует зашифрованное локальное хранилище, отличное от того, которое используется установленным приложением AIR.</p>
	
	<p>Для сопоставления зашифрованного локального хранилища каждому приложению и пользователю AIR использует DPAPI в Windows<sup>®</sup>, KeyChain в Mac<sup>®</sup> OS<sup>®</sup> и KeyRing или KWallet в Linux<sup>®</sup>. В зашифрованном локальном хранилище используется 128-разрядное шифрование AES-CBC.</p>
	
	<p>Данные зашифрованного локального хранилища доступны только для содержимого приложения AIR в безопасной изолированной среде приложения. </p>
	
	<p>Идентификатором элементов зашифрованного локального приложения является строка. Все элементы хранятся в виде массива байтов.</p>
	
	<p>Если размер сохраняемых данных превышает 10 МБ, работа зашифрованного локального хранилища может быть замедлена.</p>
	
	<p>При удалении приложения AIR программа удаления не удаляет данные из зашифрованного локального хранилища.</p>
	
	<p>Данные зашифрованного локального хранилища помещаются во вложенный каталог, который находится внутри пользовательского каталога данных приложения. Путь к вложенному каталогу – Adobe/AIR/ELS/ с идентификатором приложения в конце.</p>
	
	</apiDesc><example conref="examples\EncryptedLocalStore.1.as"> Следующий код сохраняет строку в зашифрованном локальном хранилище, извлекает ее, а затем удаляет.
<codeblock>
var str:String = "Bob";
var bytes:ByteArray = new ByteArray();
bytes.writeUTFBytes(str);
EncryptedLocalStore.setItem("firstName", bytes);

var storedValue:ByteArray = EncryptedLocalStore.getItem("firstName");
trace(storedValue.readUTFBytes(storedValue.length)); // "Bob"

EncryptedLocalStore.removeItem("firstName");
</codeblock></example></apiClassifierDetail><apiOperation id="flash.data:EncryptedLocalStore:getItem"><apiName>getItem</apiName><shortdesc>
		Возвращает данные для элемента с заданным именем из зашифрованного локального хранилища.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Аргумент <codeph>name</codeph> имеет значение <codeph>null</codeph> или представляет собой пустую строку.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Данные ByteArray. Если элемент с заданным свойством <codeph>name</codeph> не содержит данных, метод возвращает <codeph>null</codeph>.
		
		</apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя элемента в зашифрованном локальном хранилище.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Возвращает данные для элемента с заданным именем из зашифрованного локального хранилища. Если элемент с заданным именем отсутствует, метод возвращает <codeph>null</codeph>.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:removeItem"><apiName>removeItem</apiName><shortdesc>
		Удаляет элемент с заданным именем из зашифрованного локального хранилища.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Аргумент <codeph>name</codeph> имеет значение <codeph>null</codeph> или представляет собой пустую строку.
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя элемента в зашифрованном локальном хранилище.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Удаляет элемент с заданным именем из зашифрованного локального хранилища.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:reset"><apiName>reset</apiName><shortdesc>
		Очищает все зашифрованное локальное хранилище, удаляя все данные.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		Очищает все зашифрованное локальное хранилище, удаляя все данные.
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.data:EncryptedLocalStore:setItem"><apiName>setItem</apiName><shortdesc>
		Задает данные ByteArray для элемента с указанным именем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Аргумент <codeph>name</codeph> имеет значение <codeph>null</codeph> или представляет собой пустую строку.
		
		<p>По умолчанию приложение AIR не может считывать данные зашифрованного локального хранилища другого приложения. Параметр <codeph>stronglyBound</codeph> обеспечивает дополнительное связывание (данных, которые находятся в битах приложения), которое предотвращает считывание данных зашифрованного локального хранилища злонамеренным приложением путем перехвата идентификатора издателя приложения.</p> 
		
		</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя элемента в зашифрованном локальном хранилище.
		
		</apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Данные.
		
		</apiDesc></apiParam><apiParam><apiItemName>stronglyBound</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Если параметр имеет значение <codeph>true</codeph>, то для хранимого элемента помимо связывания с идентификатором издателя приложения, выполняется сильное связывание с цифровой подписью и битами приложения AIR (содержимым каталога приложения). Если при последующем вызове метода <codeph>getItem()</codeph> для данного элемента биты вызывающего приложения AIR не совпадут с битами хранимого приложения, возникнет исключение времени выполнения. После обновления приложение не сможет считать данные с сильным связыванием, которые были ранее записаны в зашифрованное локальное хранилище. 
		
		<p>Если параметр <codeph>stronglyBound</codeph> имеет значение <codeph>false</codeph> (по умолчанию), то для считывания данных должен оставаться без изменения только идентификатор издателя приложения. Биты приложения могут измениться (и они должны быть подписаны издателем), но они могут не совпадать с битами в приложении, выполнившем сохранение данных.</p>
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		Задает <codeph>данные</codeph> ByteArray для элемента с указанным именем.
		
		</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.data:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
 Экземпляр SQLIndexSchema используется для хранения сведений об определенном индексе базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLIndexSchema используется для хранения сведений об определенном индексе базы данных. Доступны следующие сведения: имя связанной таблицы (свойство <codeph>table</codeph>), инструкция SQL, используемая для создания индекса (свойство <codeph>sql</codeph>), и имя индекса (свойство <codeph>name</codeph>).
 
 <p>Для получения сведений о схеме индекса базы данных используется метод <codeph>SQLConnection.loadSchema()</codeph>, с помощью которого загружаются сведения о схеме. Следует предварительно убедиться, что в качестве аргумента <codeph>type</codeph> используется значение <codeph>null</codeph> или <codeph>SQLIndexSchema</codeph>. В полученном экземпляре SQLSchemaResult свойство <codeph>indices</codeph> содержит массив экземпляров SQLIndexSchema, представляющих индексы базы данных.</p>
 
 <p>Как правило, экземпляры SQLIndexSchema не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links><apiConstructor id="flash.data:SQLIndexSchema:SQLIndexSchema"><apiName>SQLIndexSchema</apiName><shortdesc>
     Создает экземпляр SQLIndexSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя связанной базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя индекса.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Инструкция SQL, используемая для создания данного индекса.
     
     </apiDesc></apiParam><apiParam><apiItemName>table</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя таблицы, к которой относится данный индекс.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLIndexSchema. Как правило, конструктор SQLIndexSchema не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/indices"><linktext>flash.data.SQLSchemaResult.indices</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLIndexSchema:table:get"><apiName>table</apiName><shortdesc>
     Имя таблицы, к которой относится данный индекс.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Имя таблицы, к которой относится данный индекс.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.data:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
 Экземпляр SQLTableSchema используется для хранения сведений об определенной таблице базы данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.data:SQLSchema</apiBaseClassifier></apiClassifierDef><apiDesc>
 Экземпляр SQLTableSchema используется для хранения сведений об определенной таблице базы данных. Он содержит имя таблицы (свойство <codeph>name</codeph>), инструкцию SQL для создания таблицы (свойство <codeph>sql</codeph>) и сведения о столбцах (свойство <codeph>columns</codeph>).
 
 <p>Для получения сведений о схеме таблицы базы данных используется метод <codeph>SQLConnection.loadSchema()</codeph>, с помощью которого загружаются данные схемы. Следует предварительно убедиться, что в качестве аргумента <codeph>type</codeph> используется значение <codeph>null</codeph> или <codeph>SQLTableSchema</codeph>. В полученном экземпляре SQLSchemaResult свойство <codeph>tables</codeph> содержит массив экземпляров SQLTableSchema, представляющих таблицы базы данных.</p>
 
 <p>Как правило, экземпляры SQLTableSchema не создаются непосредственно в прикладном коде.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link></related-links><apiConstructor id="flash.data:SQLTableSchema:SQLTableSchema"><apiName>SQLTableSchema</apiName><shortdesc>
     Создает экземпляр SQLTableSchema.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>database</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя связанной базы данных.
     
     </apiDesc></apiParam><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя таблицы.
     
     </apiDesc></apiParam><apiParam><apiItemName>sql</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Инструкция SQL, используемая для создания таблицы.
     
     </apiDesc></apiParam><apiParam><apiItemName>columns</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив экземпляров SQLColumnSchema, описывающих столбцы таблицы.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLTableSchema. Как правило, конструктор SQLTableSchema не вызывается непосредственно в прикладном коде. Чтобы получить сведения о схеме базы данных, нужно вызвать метод <codeph>SQLConnection.loadSchema()</codeph>.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.data.xml#SQLConnection/getSchemaResult()"><linktext>flash.data.SQLConnection.getSchemaResult()</linktext></link><link href="flash.data.xml#SQLSchemaResult/tables"><linktext>flash.data.SQLSchemaResult.tables</linktext></link></related-links></apiConstructor><apiValue id="flash.data:SQLTableSchema:columns:get"><apiName>columns</apiName><shortdesc>
     Массив экземпляров SQLColumnSchema, которые содержат сведения о схеме столбцов данной таблицы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив экземпляров SQLColumnSchema, которые содержат сведения о схеме столбцов данной таблицы. Если вызов метода <codeph>SQlConnection.loadSchema()</codeph> показывает, что из результата исключены сведения о столбцах, свойство <codeph>columns</codeph> будет содержать пустой массив (массив, у которого значение свойства <codeph>length</codeph> равно 0).
     
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLColumnSchema"><linktext>flash.data.SQLColumnSchema</linktext></link><link href="flash.data.xml#SQLConnection/loadSchema()"><linktext>flash.data.SQLConnection.loadSchema()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.data:SQLResult"><apiName>SQLResult</apiName><shortdesc>
 Класс SQLResult обеспечивает доступ к данным, возвращаемым в результате выполнения инструкции SQL (экземпляр SQLStatement).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SQLResult обеспечивает доступ к данным, возвращаемым в результате выполнения инструкции SQL (экземпляр SQLStatement).
 
 <p>Экземпляр SQLResult для инструкции SQL доступен с помощью метода <codeph>SQLStatement.getResult()</codeph> или в качестве аргумента, который передается в результирующий обработчик экземпляра Responder, указанного при вызове метода <codeph>SQLStatement.execute()</codeph> или <codeph>SQLStatement.next()</codeph>. Как правило, экземпляры SQLResult не создаются непосредственно в прикладном коде.</p>
 
 <p>Объект SQLResult используется для обращения к строкам данных, возвращаемым инструкцией <codeph>SELECT</codeph> (с помощью свойства <codeph>data</codeph>), получения идентификатора строки для инструкции <codeph>INSERT</codeph> (с помощью свойства <codeph>lastInsertRowID</codeph>), определения количества строк, обработанных инструкцией <codeph>INSERT</codeph>, <codeph>UPDATE</codeph> или <codeph>DELETE</codeph> (с помощью свойства <codeph>rowsAffected</codeph>) или определения наличия дополнительных строк результата выполнения инструкции <codeph>SELECT</codeph>, которые не были извлечены (с помощью свойства <codeph>complete</codeph>).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.data.xml#SQLStatement/getResult()"><linktext>flash.data.SQLStatement.getResult()</linktext></link><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links><apiConstructor id="flash.data:SQLResult:SQLResult"><apiName>SQLResult</apiName><shortdesc>
     Создает экземпляр SQLResult.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив строк, возвращенный в результате выполнения инструкции. Если инструкция не возвращает ни одной строки, это значение должно быть равно null.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowsAffected</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Указывает количество строк, обработанных выполненной инструкцией.
     
     </apiDesc></apiParam><apiParam><apiItemName>complete</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Указывает, имеются ли дополнительные строки для выборки или все данные были возвращены.
     
     </apiDesc></apiParam><apiParam><apiItemName>rowID</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Если инструкция является операцией SQL <codeph>INSERT</codeph>, это новый уникальный идентификатор строки.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает экземпляр SQLResult. Как правило, конструктор SQLResult не вызывается непосредственно в прикладном коде. Чтобы извлечь экземпляр SQLResult, связанный с определенным экземпляром SQLStatement, необходимо вызвать метод <codeph>getResult()</codeph> этого экземпляра. Экземпляр SQLResult также передается в качестве аргумента в функцию результирующего обработчика, если при вызове метода <codeph>execute()</codeph> или <codeph>next()</codeph> указан экземпляр Responder.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.data:SQLResult:complete:get"><apiName>complete</apiName><shortdesc>
     Указывает, все ли данные, полученные в результате выполнения инструкции, были возвращены.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, все ли данные, полученные в результате выполнения инструкции, были возвращены.
     
     <p>Если инструкция возвращает одну или несколько строк, это свойство указывает, все ли строки были возвращены. Если метод <codeph>execute()</codeph> объекта SQLStatement был вызван с заданным аргументом <codeph>prefetch</codeph>, в свойстве <codeph>data</codeph> объекта SQLResult будет возвращено только указанное количество строк полученных данных. Дополнительные данные станут доступны при последующем вызове метода <codeph>SQLStatement.next()</codeph>. Это свойство используется, чтобы определить, когда были возвращены конечные данные.</p>
     
     <p>Следует заметить, что из-за того, что во время выполнения количество строк неизвестно, курсор базы данных должен переместиться за последнюю строку до того, как завершится выполнение инструкции. Если при вызове метода <codeph>SQLStatement.execute()</codeph> задан аргумент <codeph>prefetch</codeph>, необходимо запросить не менее чем на одну запись больше, чем общее количество записей в результирующем наборе, прежде чем свойство <codeph>complete</codeph> экземпляра SQLResult получит значение <codeph>true</codeph>.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLStatement/execute()"><linktext>flash.data.SQLStatement.execute()</linktext></link><link href="flash.data.xml#SQLStatement/next()"><linktext>flash.data.SQLStatement.next()</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:data:get"><apiName>data</apiName><shortdesc>
     Данные, возвращаемые в результате выполнения инструкции, особенно инструкции SQL SELECT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Данные, возвращаемые в результате выполнения инструкции, особенно инструкции SQL <codeph>SELECT</codeph>.
     
     <p>Когда инструкция возвращает одну или несколько строк, это свойство является массивом, содержащим объекты, представляющие строки полученных данных. Каждый объект в массиве имеет свойства, имена которых соответствуют именам столбцов в полученном наборе данных.</p>
	 
	 <p>Допустим, что выполняется следующая инструкция SQL <codeph>SELECT</codeph>:</p>
	 
	 <codeblock>
	 SELECT lastName, firstName
	 FROM employees
	 </codeblock>
	 
	 <p>Предположим, что таблица <codeph>employees</codeph> (сотрудники) содержит десять строк, тогда свойство <codeph>SQLResult.data</codeph> будет представлять собой объект Array с десятью элементами. Каждый элемент — это объект с двумя свойствами: <codeph>lastName</codeph> и <codeph>firstName</codeph>.</p>
	 
	 <p>Ситуация усложняется, если инструкция <codeph>SELECT</codeph> используется со сложным столбцом результатов, например с агрегатной функцией. Допустим, что выполняется следующая инструкция SQL:</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary)
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>В результате выполнения этой инструкции каждый объект в массиве <codeph>data</codeph> имеет два свойства: <codeph>departmentId</codeph> и <codeph>SUM(salary)</codeph>. Однако SUM(salary) является недопустимым идентификатором. Если используется вычисляемый столбец, например агрегатной или другой функции, в инструкции SQL необходимо указать псевдоним для вычисляемого столбца. Псевдоним служит в качестве имени свойства в полученных объектах данных. Рассмотрим в качестве примера следующую альтернативу предыдущей инструкции:</p>
	 
	 <codeblock>
	 SELECT departmentId, SUM(salary) AS salarySubtotal
	 FROM employees
	 GROUP BY departmentId
	 </codeblock>
	 
	 <p>В массиве <codeph>data</codeph> этой инструкции полученные объекты имеют два свойства: <codeph>departmentId</codeph> и <codeph>salarySubtotal</codeph>.</p>
	 
	 <p>Свойство <codeph>data</codeph> всегда является экземпляром Array независимо от того, сколько строк и столбцов содержится в наборе результатов. Например, следующая инструкция <codeph>SELECT</codeph> возвращает одну строку и один столбец, то есть одно значение:</p>
	 
	 <codeblock>
	 SELECT COUNT(~~) AS numEmployees
	 FROM employees
	 </codeblock>
	 
	 <p>После выполнения запроса свойство <codeph>data</codeph> содержит объект Array с одним элементом. Этот элемент представляет собой объект с одним свойством <codeph>numEmployees</codeph>.</p>
	 
	 <p>Если в полученных данных содержатся повторяющиеся имена столбцов, например если инструкция <codeph>SELECT</codeph> включает два разных столбца <codeph>id</codeph> из двух разных таблиц, то полученным свойствам присваиваются имена в соответствии со значением свойства <codeph>SQLConnection.columnNameStyle</codeph>. По умолчанию имя каждого столбца используется в качестве имени свойства, но если в наборе результатов встречается несколько столбцов с одинаковым именем, то для них используется формат длинного имени <codeph>[table-name]_[column-name]</codeph>. Это поведение можно изменить, задав нужное значение для свойства <codeph>SQLConnection.columnNameStyle</codeph>.</p>
	 
	 <p>По умолчанию объекты в массиве <codeph>data</codeph> являются экземплярами класса Object. Однако если указать для свойства <codeph>SQLStatement.itemClass</codeph> определенный класс, то элементы массива <codeph>data</codeph> создаются в качестве экземпляров этого класса. Для каждого столбца в наборе результатов класс <codeph>itemClass</codeph> должен иметь свойство, имя которого точно соответствует имени столбца.</p> 
	 
	 <p>Если инструкция не возвращает данных, это свойство равно <codeph>null</codeph>. Это происходит, если выполняется не инструкция <codeph>SELECT</codeph> или если инструкция <codeph>SELECT</codeph> не возвращает ни одной строки.</p>
     
	 </apiDesc><example conref="examples\SQLStatement.itemClass.1.as"> Следующий код иллюстрирует использование свойства <codeph>itemClass</codeph> для создания во время выполнения экземпляров пользовательского класса из результатов, возвращенных инструкцией SQL <codeph>SELECT</codeph>.
<codeblock>
// Employee class definition
package
{
    public class Employee
    {
        public var name:String;
        public var ssn:String;
        public var id:uint;
        public override function toString():String
        {
            return "id: "+ id.toString() + " name: " + name + " ssn: " + ssn;
        }
    }
}


// using the Employee class as SQLStatement.itemClass
var conn:SQLConnection;
var dbStatement:SQLStatement;

function init():void
{
    conn = new SQLConnection();
    conn.addEventListener(SQLEvent.OPEN, connOpenHandler);
    
    dbStatement = new SQLStatement();
    dbStatement.sqlConnection = conn;
    dbStatement.text = "SELECT id, name, ssn FROM employees";
    dbStatement.itemClass = Employee;
    
    var dbFile:File = new File(File.separator + "employee.db");
    conn.open(dbFile);
}

function connOpenHandler(event:SQLEvent):void
{
    dbStatement.addEventListener(SQLEvent.RESULT, resultHandler);
    dbStatement.execute();
}

function resultHandler(event:SQLEvent):void
{
    var result:SQLResult = dbStatement.getResult();
    if (result != null)
    {
        var emp:Employee;
        var numRows:int = result.data.length;
        for (var i:int = 0; i &lt; numRows; i++)
        {
            emp = result.data[i];
            trace(emp.toString());
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/columnNameStyle"><linktext>SQLConnection.columnNameStyle</linktext></link><link href="flash.data.xml#SQLStatement/itemClass"><linktext>SQLStatement.itemClass</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:lastInsertRowID:get"><apiName>lastInsertRowID</apiName><shortdesc>
     Последний идентификатор строки, созданный инструкцией SQL INSERT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Последний идентификатор строки, созданный инструкцией SQL <codeph>INSERT</codeph>.
	 
     <p>Значение равно 0, если выполненная инструкция не была инструкцией <codeph>INSERT</codeph>.</p>
	 
	 <p>Уникальный идентификатор строки в таблице, используемый для поиска в базе данных. Это значение часто генерируется базой данных.</p>
	 
	 <p>Дополнительные сведения об основных клавишах и генерируемых идентификаторах строк см. в разделах <xref href="../../localDatabaseSQLSupport.html#createTable">«CREATE TABLE»</xref> и <xref href="../../localDatabaseSQLSupport.html#expressions">«Выражения»</xref> в приложении <xref href="../../localDatabaseSQLSupport.html">«Поддержка SQL в локальных базах данных»</xref>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/lastInsertRowID"><linktext>flash.data.SQLConnection.lastInsertRowID</linktext></link><link href="flash.events.xml#SQLUpdateEvent/rowID"><linktext>flash.events.SQLUpdateEvent.rowID</linktext></link></related-links></apiValue><apiValue id="flash.data:SQLResult:rowsAffected:get"><apiName>rowsAffected</apiName><shortdesc>
     Указывает количество строк, обработанных операцией.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает количество строк, обработанных операцией. Учитываются только те изменения, которые были непосредственно указаны в инструкции <codeph>INSERT</codeph>, <codeph>UPDATE</codeph> или <codeph>DELETE</codeph>.
     
     <p>Дополнительные изменения, вызванные триггерами, не учитываются. Свойство <codeph>SQLConnection.totalChanges</codeph> используется для нахождения общего числа изменений, включая изменения, вызванные триггерами.</p>
	 
	 <p>Следует учесть, что если связанной операцией SQL является инструкция <codeph>DELETE</codeph> без предложения <codeph>WHERE</codeph> (т. е. инструкция удаляет все строки таблицы), свойство <codeph>rowsAffected</codeph> всегда будет равно 0, независимо от числа удаленных строк. Чтобы узнать число удаленных строк, можно добавить предложение <codeph>WHERE</codeph> в виде <codeph>WHERE 1 = 1</codeph>. В этом случае будут удалены все строки, а свойство <codeph>rowsAffected</codeph> будет точно отражать их число. Однако, в зависимости от числа удаляемых строк, это может отрицательно сказаться на производительности инструкции.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.data.xml#SQLConnection/totalChanges"><linktext>flash.data.SQLConnection.totalChanges</linktext></link></related-links></apiValue></apiClassifier></apiPackage>