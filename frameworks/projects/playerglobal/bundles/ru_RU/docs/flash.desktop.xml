<?xml version="1.0"?>
<apiPackage id="flash.desktop"><apiName>flash.desktop</apiName><apiDetail/><apiClassifier id="flash.desktop:InvokeEventReason"><apiName>InvokeEventReason</apiName><shortdesc>
	 В классе InvokeEventReason перечислены значения, возвращенные свойством reason объекта InvokeEvent.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 В классе InvokeEventReason перечислены значения, возвращенные свойством <codeph>reason</codeph> объекта <codeph>InvokeEvent</codeph>.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#InvokeEvent/reason"><linktext>flash.events.InvokeEvent.reason</linktext></link></related-links><apiValue id="flash.desktop:InvokeEventReason:LOGIN"><apiName>LOGIN</apiName><shortdesc>
			Указывает, что событие InvokeEvent произошло вследствие входа пользователя в систему.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>login</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
			Указывает, что событие InvokeEvent произошло вследствие входа пользователя в систему.
			
			</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:InvokeEventReason:STANDARD"><apiName>STANDARD</apiName><shortdesc>
			Указывает, что событие InvokeEvent произошло по причине, отличной от входа в систему.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
			Указывает, что событие InvokeEvent произошло по причине, отличной от входа в систему.
			
			</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:InteractiveIcon"><apiName>InteractiveIcon</apiName><shortdesc>
	 Класс InteractiveIcon представляет собой базовый класс значков приложений ОС.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.desktop:Icon</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс InteractiveIcon представляет собой базовый класс значков приложений ОС. 
	 
	 <p>Чтобы получить экземпляр значка приложения, воспользуйтесь свойством <codeph>icon</codeph> объекта NativeApplication. Типом значка является один из подклассов базового класса InteractiveIcon. В Mac OS X<sup>®</sup> – это DockIcon, в Windows<sup>®</sup> и Linux – SystemTrayIcon.</p>
	 
	 <p>Создание экземпляров класса InteractiveIcon невозможно. Вызовы конструктора <codeph>new InteractiveIcon()</codeph> выдают исключение ArgumentError.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsDockIcon"><linktext>flash.desktop.NativeApplication.supportsDockIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsSystemTrayIcon"><linktext>flash.desktop.NativeApplication.supportsSystemTrayIcon</linktext></link></related-links><apiValue id="flash.desktop:InteractiveIcon:bitmaps:set"><apiName>bitmaps</apiName><shortdesc>
		  
	 Изображение значка в массиве объектов BitmapData различных размеров.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		  
	 Изображение значка в массиве объектов BitmapData различных размеров.
	   
	 <p>При отображении значка в контексте конкретной ОС из массива выбирается изображение, размер которого в максимальной степени подходит под текущий размер экрана (при необходимости масштабируется). Обычные размеры включают: 16x16, 32x32, 48x48 и 128x128. (В ближайшем будущем в некоторых ОС могут использоваться значки размером 512x512 пикселей.)</p>
	 
	 <p>В некоторых контекстах, если свойству <codeph>bitmaps</codeph> ничего присвоено не было, может использоваться значок ОС по умолчанию. В остальных контекстах значок не отображается.</p>
	 
	 <p>Чтобы изменить вид значка, присвойте свойству <codeph>bitmaps</codeph> массив объектов BitmapData.</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>Прямая модификация массива <codeph>bitmaps</codeph> ни к чему не приведет.</p>
	 
	 <p>Чтобы убрать изображение значка, присвойте свойству <codeph>bitmaps</codeph> пустой массив.</p>
	 
	 <p>
	 <b>Примечание.</b> Загружайте файлы изображений для значков в формате PNG, так как этот формат обеспечивает наилучшее альфа-смешивание. Формат GIF поддерживает только включение или отключение прозрачности, но не смешивание. Формат JPG не поддерживает прозрачность совсем.  
	 </p>
	  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:InteractiveIcon:height:get"><apiName>height</apiName><shortdesc>
		 Текущее значение высоты значка в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Текущее значение высоты значка в пикселях.
		 
		 <p>Некоторые контексты значков поддерживают динамические размеры. Свойство <codeph>height</codeph> обозначает высоту значка, выбранного из массива <codeph>bitmaps</codeph> для данного контекста. Если в ОС было использовано масштабирование, то текущее значение высоты может отличаться.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:InteractiveIcon:width:get"><apiName>width</apiName><shortdesc>
		 Текущее значение ширины значка в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Текущее значение ширины значка в пикселях. 
		 
		 <p>Некоторые контексты значков поддерживают динамические размеры. Свойство <codeph>width</codeph> обозначает ширину значка, выбранного из массива <codeph>bitmaps</codeph> для данного контекста. Если в ОС было использовано масштабирование, то текущее значение ширины может отличаться.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeDragActions"><apiName>NativeDragActions</apiName><shortdesc>
Класс NativeDragActions задает строковые константы для имен операций перетаскивания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс NativeDragActions задает строковые константы для имен операций перетаскивания.
 
 <p>Константы NativeDragActions используются в качестве значений свойства <codeph>dropAction</codeph> классов NativeDragManager и NativeDragEvent.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeDragManager"><linktext>flash.desktop.NativeDragManager</linktext></link><link href="flash.events.xml#NativeDragEvent"><linktext>flash.events.NativeDragEvent</linktext></link></related-links><apiValue id="flash.desktop:NativeDragActions:COPY"><apiName>COPY</apiName><shortdesc>
	Задает строку для операции копирования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>copy</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает строку для операции копирования.
	
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragActions:LINK"><apiName>LINK</apiName><shortdesc>
	Задает строку для операции создания связок.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>link</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает строку для операции создания связок.
	
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragActions:MOVE"><apiName>MOVE</apiName><shortdesc>
	 Задает строку для операции перемещения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>move</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Задает строку для операции перемещения.
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragActions:NONE"><apiName>NONE</apiName><shortdesc>
	Задает строку, которая будет использоваться, если операция не указана.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает строку, которая будет использоваться, если операция не указана.
	 
	 <p>В событии <codeph>nativeDragComplete</codeph> действие <codeph>none</codeph> указывает на то, что пользователь не завершил операцию перетаскивания.</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:ClipboardFormats"><apiName>ClipboardFormats</apiName><shortdesc>
Класс ClipboardFormats определяет константы имен стандартных форматов данных при использовании класса Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Clipboard, ClipboardFormats and ClipboardTransferMode were all added to AIR 1.0. These are also being added, with some exceptions listed in this file, to FP10.
</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс ClipboardFormats определяет константы имен стандартных форматов данных при использовании класса Clipboard. Flash Player 10 поддерживает только следующие форматы данных: TEXT_FORMAT, RICH_TEXT_FORMAT и HTML_FORMAT.

</apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#Clipboard"><linktext>flash.desktop.Clipboard</linktext></link></related-links><apiValue id="flash.desktop:ClipboardFormats:BITMAP_FORMAT"><apiName>BITMAP_FORMAT</apiName><shortdesc>
	Данные изображения (только для AIR).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not supported in FP10.
	</internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:bitmap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Данные изображения (только для AIR).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:FILE_LIST_FORMAT"><apiName>FILE_LIST_FORMAT</apiName><shortdesc>
	Массив файлов (только для AIR).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not supported in FP10.
	</internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:file list</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Массив файлов (только для AIR).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:HTML_FORMAT"><apiName>HTML_FORMAT</apiName><shortdesc>
	Данные HTML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:html</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Данные HTML.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:RICH_TEXT_FORMAT"><apiName>RICH_TEXT_FORMAT</apiName><shortdesc>
	Данные в формате RTF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:rtf</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Данные в формате RTF.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:TEXT_FORMAT"><apiName>TEXT_FORMAT</apiName><shortdesc>
	Строковые данные.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:text</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Строковые данные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardFormats:URL_FORMAT"><apiName>URL_FORMAT</apiName><shortdesc>
	Строка URL-адреса (только для AIR).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not supported in FP10.
	</internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>air:url</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Строка URL-адреса (только для AIR).
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeApplication"><apiName>NativeApplication</apiName><shortdesc>
	 Класс NativeApplication представляет приложение AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс NativeApplication представляет приложение AIR.
	 
	 <p>
	 Класс NativeApplication предоставляет информацию о приложении, дает доступ к самым распространенным функциям приложения и отправляет события уровня приложения.
	 </p>
	 <p>
	 Единственный экземпляр объекта NativeApplication автоматически создается при запуске. Получить экземпляр объекта NativeApplication приложения можно через статическое свойство <codeph>NativeApplication.nativeApplication</codeph>.
	 </p>
	 
	 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.USER_PRESENT_userPresent"><apiName>userPresent</apiName><shortdesc>
	 Отправляется при обнаружении нажатий клавиш или кнопок мыши в среде ОС в режиме ожидания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.USER_PRESENT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется при обнаружении нажатий клавиш или кнопок мыши в среде ОС в режиме ожидания.
	 
	 <p>Период времени, после которого наступает режим ожидания, регулируется свойством <codeph>idleThreshold</codeph>. Время, прошедшее с момента перехода в режим ожидания, определяется в свойстве <codeph>timeSinceLastUserInput</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.desktop.xml#NativeApplication/idleThreshold"><linktext>idleThreshold</linktext></link><link href="flash.desktop.xml#NativeApplication/timeSinceLastUserInput"><linktext>timeSinceLastUserInput</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.USER_IDLE_userIdle"><apiName>userIdle</apiName><shortdesc>
	 Отправляется, когда пользователь пробыл в режиме ожидания период времени, указанный в свойстве idleThreshold.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.USER_IDLE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется, когда пользователь пробыл в режиме ожидания период времени, указанный в свойстве <codeph>idleThreshold</codeph>. 
	 
	 <p>Время, прошедшее с момента перехода в режим ожидания, определяется в свойстве <codeph>timeSinceLastUserInput</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.desktop.xml#NativeApplication/idleThreshold"><linktext>idleThreshold</linktext></link><link href="flash.desktop.xml#NativeApplication/timeSinceLastUserInput"><linktext>timeSinceLastUserInput</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.NETWORK_CHANGE_networkChange"><apiName>networkChange</apiName><shortdesc>
	 Отправляется при обнаружении нового сетевого подключения или при разрыве существующего соединения.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.NETWORK_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется при обнаружении нового сетевого подключения или при разрыве существующего соединения. 
	 
	 <p>Событие <codeph>networkChange</codeph> не обязательно обозначает переход компьютера узла в оперативный или автономный режим. Оно также может обозначать переключение с одного соединения на другое. Приложения могут использовать данное событие для оптимизации задач мониторинга доступности удаленных ресурсов. При отправке события <codeph>networkChange</codeph> часто наступает удобный момент для проверки доступности любых удаленных ресурсов.
	 </p> 
	 <p><b>Примечание.</b> Между изменением состояния сети и отправкой данного события может возникнуть короткая задержка.</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.EXITING_exiting"><apiName>exiting</apiName><shortdesc>
	 Отправляется при запуске последовательности операций выхода из приложения.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXITING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется при запуске последовательности операций выхода из приложения. 
	 
	 <p>Событие выхода отправляется, когда ОС инициирует процедуру завершения приложения. Например, по нажатию комбинации клавиш <codeph>Cmd-Q</codeph> в Mac OS X или когда свойство <codeph>autoExit</codeph> объекта NativeApplication принимает значение <codeph>true</codeph> и закрывается окно последнего активного приложения. При отмене данного события выход из приложения не осуществляется.</p>
	 
	 <p><b>Примечание.</b> Вызов метода <codeph>exit()</codeph> NativeApplication не приводит к прекращению отправки события <codeph>exiting</codeph>. Для уведомления компонентов о предстоящем выходе следует отправить событие <codeph>exiting</codeph> до вызова метода <codeph>exit()</codeph></p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
	 Отправляется, когда фокус перемещается с рабочего стола на приложение.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется, когда фокус перемещается с рабочего стола на приложение.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
	 Отправляется, когда данное приложение становится приложением активного рабочего стола.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется, когда данное приложение становится приложением активного рабочего стола.
	  
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.BrowserInvokeEvent.Browser_INVOKE_browserInvoke"><apiName>browserInvoke</apiName><shortdesc>
	 Отправляется при вызове приложения SWF-файлом, выполняющимся в обозревателе пользователя.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.BrowserInvokeEvent.Browser_INVOKE</apiEventType><adobeApiEventClassifier>flash.events.BrowserInvokeEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется при вызове приложения SWF-файлом, выполняющимся в обозревателе пользователя. 
	 
	 <p>Вызов обозревателя разрешается, только если приложение указывает следующие данные в файле дескриптора приложения.</p>
	 
	 <codeblock>&lt;allowBrowserInvocation>true&lt;/allowBrowserInvocation></codeblock>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:NativeApplication_flash.events.InvokeEvent.INVOKE_invoke"><apiName>invoke</apiName><shortdesc>
	 Отправляется при вызове приложения.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.InvokeEvent.INVOKE</apiEventType><adobeApiEventClassifier>flash.events.InvokeEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется при вызове приложения. 
	 
	 <p>При повторном вызове приложения его копия не запускается. Вместо этого первой копии приложения поступает дополнительное событие о вызове. Дальнейшая реакция на повторные события <codeph>invoke</codeph> зависит от самого приложения.</p>
	 
	 <p><b>Примечание.</b> Все события <codeph>invoke</codeph> помещаются в очередь. Если прослушиватель для данного события зарегистрирован, он получает все события из очереди, а также все новые события. События из очереди доставляются как до, так и после новых событий <codeph>invoke</codeph>.</p>
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.desktop:NativeApplication:activate"><apiName>activate</apiName><shortdesc>
         Активирует данное приложение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiData>null</apiData><apiDesc>Активируемый с приложением объект NativeWindow окна.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Активирует данное приложение. 
         
         <p>При некоторых, заданных ОС, обстоятельствах данный метод не приводит к активации приложения. В большинстве ОС приложения не могут активировать сами себя. Это сделано для того, чтобы исключить возможность случайного или умышленного использования пользователем других приложений в своих целях.</p>
         
         <p>Если такая возможность поддерживается ОС, то указанное окно становится активным и появляется на рабочем столе поверх остальных окон или приложений. (Если параметр <codeph>window</codeph> принимает значение <codeph>null</codeph>, то активируется видимое окно данного приложения.)</p>
         
         <p>При работе с приложениями без видимых окон метод <codeph>activate()</codeph> не подходит.</p>
		 
		 <p>Операция активации является синхронной.</p>
		 
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.desktop:NativeApplication:activate_activate"><apiName>activate</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при изменении состояния активности.
         
         </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при изменении состояния активности.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.desktop:NativeApplication:addEventListener"><apiName>addEventListener</apiName><shortdesc>
		
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция прослушивателя, обрабатывающая событие. Эта функция должна принимать объект Event в качестве единственного параметра и не должна что-либо возвращать <ph platform="actionscript">, как показано в примере:</ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Эта функция может иметь любое имя.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Этот параметр применяется для отображения объектов в архитектуре списка отображения ActionScript 3.0, используемой в SWF-содержимом. </ph> <ph platform="actionscript">Определяет, работает ли прослушиватель в фазе захвата или в целевой фазе и в фазе восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>true</codeph>, прослушиватель обрабатывает событие только во время фазы захвата, но не во время целевой фазы или фазы восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>false</codeph>, то прослушиватель обрабатывает событие только в целевой фазе или фазе восходящей цепочки. Чтобы прослушивать событие во всех трех фазах, необходимо вызвать <codeph>addEventListener()</codeph> дважды: один раз с <codeph>useCapture</codeph> в значении <codeph>true</codeph>, а другой – с <codeph>useCapture</codeph> в значении <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Уровень приоритета прослушивателя событий. Приоритет определяется 32-разрядным целым числом со знаком. Чем больше число, тем выше приоритет. Все прослушиватели событий с приоритетом <i>n</i> обрабатываются перед прослушивателями с приоритетом <i>n</i>-1. Прослушиватели с одинаковым приоритетом обрабатываются в порядке их добавления. Значение приоритета по умолчанию равно 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли ссылка на прослушивателя «сильной» или «слабой». «Сильная» ссылка (по умолчанию) предотвращает удаление прослушивателя сборщиком мусора. «Слабая» ссылка позволяет удалить прослушиватель. <p>Функции элементов уровня класса не подлежат удалению в качестве мусора, вследствие чего можно установить <codeph>useWeakReference</codeph> равным <codeph>true</codeph> для функций элементов уровня класса, не подвергая их возможности подобного удаления. Если свойству <codeph>useWeakReference</codeph> присвоить значение <codeph>true</codeph> для прослушивателя, который является вложенной внутренней функцией, то функция будет очищена и перестанет быть постоянной. При создании ссылок на внутреннюю функцию (возможно сохранение в другой переменной) она не будет собираться в качестве мусора и останется устойчивой.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
		
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии. <ph platform="actionscript">Можно регистрировать прослушиватели событий в любом узле из списка отображения для каждого типа события, фазы и приоритета.</ph>
	
	<p platform="javascript">В коде JavaScript в среде выполнения AIR этот метод используется в целях регистрации прослушивателей событий, определенных интерфейсами AIR API. Для других событий JavaScript (таких как событие <codeph>onload</codeph> объекта <codeph>body</codeph> в модели DOM) можно использовать те же стандартные способы обработки событий, что и для содержимого в обозревателе.</p>
	
	<p>После успешной регистрации прослушивателя событий невозможно изменить его приоритет путем дополнительных вызовов <codeph>addEventListener()</codeph>. Чтобы изменить приоритет прослушивателя, необходимо сначала вызвать метод <codeph>removeListener()</codeph>. Затем можно снова зарегистрировать прослушиватель с новым приоритетом. </p>
	
	<p>Следует учесть, что после регистрации прослушивателя последующие вызовы метода <codeph>addEventListener()</codeph> с другим значением свойства <codeph>type</codeph> или <codeph>useCapture</codeph> приводят к регистрации другого прослушивателя. <ph platform="actionscript">Например, прослушиватель, изначально зарегистрированный со значением <codeph>useCapture</codeph>, равным <codeph>true</codeph>, прослушивает только во время фазы захвата. Если вызвать метод <codeph>addEventListener()</codeph> еще раз с тем же объектом прослушивателя, но со свойством <codeph>useCapture</codeph> в значении <codeph>false</codeph>, то будет два прослушивателя: один – прослушивающий в фазе захвата, а другой – в целевой фазе и фазе восходящей цепочки. </ph>
	</p>
	
	<p platform="actionscript">Невозможно зарегистрировать прослушиватель события только для целевой фазы или для фазы восходящей цепочки. Эти фазы соединены при регистрации, поскольку восходящая цепочка применяется только к предшественникам целевого узла.</p>
	
	<p>Если прослушиватель событий больше не нужен, его можно удалить, вызвав метод <codeph>removeEventListener()</codeph>, иначе могут возникнуть проблемы с памятью. Прослушиватели событий не удаляются из памяти автоматически, так как сборщик мусора не удаляет прослушиватель, пока существует объект, отправляющий соответствующее событие (если параметру <codeph>useWeakReference</codeph> не задано значение <codeph>true</codeph>).</p>
		
	<p>Копирование экземпляра EventDispatcher не приводит к копированию прослушивателей событий, присоединенных к нему. (Если для вновь создаваемого узла требуется прослушиватель событий, его необходимо присоединить после создания узла.) При этом при перемещении экземпляра EventDispatcher присоединенные к нему прослушиватели событий перемещаются вместе с ним.</p>
	
	
	<p platform="actionscript">Если прослушиватель регистрируется для узла в тот момент, когда на нем обрабатывается событие, то в текущей фазе он не запускается, однако может запуститься в следующей фазе потока события, например в фазе восходящей цепочки.</p>
	
	<p platform="actionscript">Прослушиватель событий, удаленный из узла во время обработки события на этом узле, будет запускаться текущими операциями. После удаления прослушиватель событий больше не вызывается (если не будет снова зарегистрирован для дальнейшей обработки). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:clear"><apiName>clear</apiName><shortdesc>
         Вызывает внутреннюю команду delete экранного объекта с фокусом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Вызывает внутреннюю команду delete экранного объекта с фокусом.
		 
         <p>Если объект с фокусом не поддерживает эту команду, вызов функции игнорируется. В настоящее время эту команду поддерживают только те экранные объекты, которые происходят от классов TextField или HTMLLoader.</p>
         
         <p><b>Примечание.</b> Команда <codeph>clear()</codeph> удаляет выбранный текст. При отсутствии выбранного текста весь текст не удаляется.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:copy"><apiName>copy</apiName><shortdesc>
         Вызывает внутреннюю команду copy экранного объекта с фокусом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Вызывает внутреннюю команду copy экранного объекта с фокусом.
         
         <p>Если компонент не поддерживает эту команду, вызов функции игнорируется. В настоящее время эту команду поддерживают только те экранные объекты, которые происходят от классов TextField или HTMLLoader.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:cut"><apiName>cut</apiName><shortdesc>
         Вызывает внутреннюю команду cut экранного объекта с фокусом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Вызывает внутреннюю команду cut экранного объекта с фокусом.
		 
         <p>Если компонент не поддерживает эту команду, вызов функции игнорируется. В настоящее время эти команды поддерживают только те экранные объекты, которые происходят от классов TextField или HTMLLoader.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
		
	Посылает событие в поток событий.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Значение <codeph>true</codeph> в случае успешной передачи события. Значение <codeph>false</codeph> указывает на ошибку или на то, что для события был вызван метод <codeph>preventDefault()</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>Объект события, передаваемый в поток событий. Если осуществляется повторная отправка события, автоматически создается его клон. После отправки события нельзя изменить его свойство <codeph>target</codeph>, поэтому необходимо создать новую копию события, чтобы обеспечить правильное выполнение повторной отправки.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
		
	Посылает событие в поток событий. Целью события является объект EventDispatcher, для которого вызывается метод <codeph>dispatchEvent()</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:exit"><apiName>exit</apiName><shortdesc>
		 Завершает приложение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>errorCode</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Код выхода, сообщаемый ОС при выходе приложения.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Завершает приложение. 
		 
		 <p>Вызов метода <codeph>exit()</codeph> <i>приведет</i> к возврату кода выхода. Однако до тех пор, пока не завершится выполнение текущего кода (например, работа обработчика события), процедура завершения работы не начнется. Ожидающие асинхронные операции могут быть выполнены или отменены.</p>
		 
		 <p>Имейте в виду, что событие <codeph>exiting</codeph> не отправляется. Если архитектура программы подразумевает использование события <codeph>exiting</codeph>, произведите вызов метода <codeph>NativeApplication.nativeApplication.dispatchEvent()</codeph>, передав ему в качестве аргумента объект Event типа <codeph>exiting</codeph>. При закрытии окон приложения события <codeph>closing</codeph> и <codeph>close</codeph> также не отправляются. При необходимости оповестить окна о закрытии приложения можно отправить события <codeph>closing</codeph> для каждого открытого окна. Если отправка события закрытия окна <codeph>close</codeph> является обязательной, то перед выходом следует вызвать метод <codeph>close()</codeph>.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:getDefaultApplication"><apiName>getDefaultApplication</apiName><shortdesc>
		 Определяет приложение по умолчанию для открытия файлов с указанным расширением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметр <codeph>extension</codeph> не содержит ни одного расширения файла, объявленного в дескрипторе приложения.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Путь к приложению по умолчанию.
		 
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка с интересующим расширением типа файла (без «.»).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Определяет приложение по умолчанию для открытия файлов с указанным расширением.
		 
		 <p><b>Примечание.</b> Данный метод применим только к типам файлов, объявленным в инструкции <codeph>fileTypes</codeph> дескриптора приложения.</p>
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:NativeApplication:isSetAsDefaultApplication"><apiName>isSetAsDefaultApplication</apiName><shortdesc>
		 Указывает, является ли данное приложение текущим приложением по умолчанию для обработки файлов с указанным расширением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметр <codeph>extension</codeph> не содержит ни одного расширения файла, объявленного в дескрипторе приложения.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, если по умолчанию используется данное приложение.
		 
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка с интересующим расширением типа файла (без «.»).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Указывает, является ли данное приложение текущим приложением по умолчанию для обработки файлов с указанным расширением.
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:NativeApplication:paste"><apiName>paste</apiName><shortdesc>
         Вызывает внутреннюю команду paste экранного объекта с фокусом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Вызывает внутреннюю команду paste экранного объекта с фокусом.
		 
         <p>Если компонент не поддерживает эту команду, вызов функции игнорируется. В настоящее время эту команду поддерживают только те экранные объекты, которые происходят от классов TextField или HTMLLoader.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:removeAsDefaultApplication"><apiName>removeAsDefaultApplication</apiName><shortdesc>
		 Отменяет использование данного приложения в качестве приложения по умолчанию для обработки файлов с указанным расширением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметр <codeph>extension</codeph> не содержит ни одного расширения файла, объявленного в дескрипторе приложения.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка с интересующим расширением типа файла (без «.»).
         
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Отменяет использование данного приложения в качестве приложения по умолчанию для обработки файлов с указанным расширением.
		 
		 <p><b>Примечание.</b> Данный метод применим только к типам файлов, объявленным в инструкции <codeph>fileTypes</codeph> дескриптора приложения.</p>
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:NativeApplication:removeEventListener"><apiName>removeEventListener</apiName><shortdesc>
		
	Удаляет прослушиватель из объекта EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Удаляемый объект прослушивателя.
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Этот параметр применяется для отображения объектов в архитектуре списка отображения ActionScript 3.0, используемой в SWF-содержимом. </ph> <ph platform="actionscript">Указывает, был ли прослушиватель зарегистрирован для фазы захвата или целевой фазы и фазы восходящей цепочки. Если прослушиватель зарегистрирован и для фазы захвата, и для фаз цели и восходящей цепочки, метод <codeph>removeEventListener()</codeph> необходимо вызвать дважды: один раз с <codeph>useCapture()</codeph> в значении <codeph>true</codeph>, а другой раз с <codeph>useCapture()</codeph> в значении <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
		
	Удаляет прослушиватель из объекта EventDispatcher. При отсутствии прослушивателя, зарегистрированного с объектом EventDispatcher, вызов этого метода не оказывает эффекта.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:selectAll"><apiName>selectAll</apiName><shortdesc>
         Вызывает внутреннюю команду selectAll экранного объекта с фокусом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>.
         
		 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Вызывает внутреннюю команду selectAll экранного объекта с фокусом.
		 
         <p>Если компонент не поддерживает эту команду, вызов функции игнорируется. В настоящее время эту команду поддерживают только те экранные объекты, которые происходят от классов TextField или HTMLLoader.</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeApplication:setAsDefaultApplication"><apiName>setAsDefaultApplication</apiName><shortdesc>
		 Задает данное приложение в качестве приложения по умолчанию для обработки файлов с указанным расширением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметр <codeph>extension</codeph> не содержит ни одного расширения файла, объявленного в дескрипторе приложения.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка с интересующим расширением типа файла (без «.»).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Задает данное приложение в качестве приложения по умолчанию для обработки файлов с указанным расширением.
		 
		 <p><b>Примечание.</b> Данный метод применим только к типам файлов, объявленным в инструкции <codeph>fileTypes</codeph> дескриптора приложения.</p>
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/applicationDescriptor"><linktext>applicationDescriptor</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:NativeApplication:activeWindow:get"><apiName>activeWindow</apiName><shortdesc>
         Окно активного приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
         Окно активного приложения. 
		 
		 <p>Если активное окно рабочего стола не относится к этому приложению или активные окна отсутствуют, свойство <codeph>activeWindow</codeph> имеет значение <codeph>null</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:applicationDescriptor:get"><apiName>applicationDescriptor</apiName><shortdesc> 
		 Содержимое файла дескриптора приложения данного приложения AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>XML</apiValueClassifier></apiValueDef><apiDesc> 
		 Содержимое файла дескриптора приложения данного приложения AIR.
		 
		 <p platform="javascript">Код ActionScript 3.0 в SWF-файлах поддерживает синтаксис E4X для работы с данными XML. Однако в приложениях AIR на основе HTML может потребоваться преобразование значения XML данного свойства в объект DOMParser с использованием метода <codeph>parseFromString()</codeph> объекта DOMParser.</p>
		 
		 </apiDesc><example conref="examples\NativeApplication.applicationDescriptor.1.as"> Следующий пример считывает элементы <codeph>copyright</codeph> и <codeph>version</codeph> из файла дескриптора приложения. Обратите внимание на то, что необходимо использовать пространство имен по умолчанию, определенное в XML-файле дескриптора приложения.
<codeblock>
var appDescriptor:XML = NativeApplication.nativeApplication.applicationDescriptor;
var ns:Namespace = appDescriptor.namespace();
var appCopyright:String = appDescriptor.ns::copyright;
var appVersion:String = appDescriptor.ns::version;
trace("appId:", appCopyright);
trace("version:", appVersion);
</codeblock><swfblock conref="examples\NativeApplication.applicationDescriptor.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:applicationID:get"><apiName>applicationID</apiName><shortdesc> 
		 Идентификатор приложения данного приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
		 Идентификатор приложения данного приложения. 
		 
		 <p>Значение идентификатора приложения задается в файле дескриптора приложения.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:autoExit:get"><apiName>autoExit</apiName><shortdesc>
		 Указывает, должно ли приложение автоматически завершаться при закрытии всех его окон.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает, должно ли приложение автоматически завершаться при закрытии всех его окон.  
		 
		 <p>Если <codeph>autoExit</codeph> принимает значение <codeph>true</codeph> (по умолчанию), то при закрытии всех окон приложения само приложение автоматически завершает работу. Оба события <codeph>exiting</codeph> и <codeph>exit</codeph> отправляются. Если <codeph>autoExit</codeph> принимает значение <codeph>false</codeph>, то для завершения работы приложения требуется осуществить вызов функции <codeph>NativeApplication.nativeApplication.exit()</codeph>. </p> 
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:icon:get"><apiName>icon</apiName><shortdesc>
		 Значок приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:InteractiveIcon</apiValueClassifier></apiValueDef><apiDesc>
		 Значок приложения.
		 
		 <p>Для определения класса значка используйте <codeph>NativeApplication.supportsDockIcon</codeph> и <codeph>NativeApplication.supportsSystemTrayIcon</codeph>. Выбранный тип принадлежит одному из подклассов InteractiveIcon. В ОС Mac<sup>®</sup> OS X <codeph>NativeApplication.icon</codeph> является объектом типа <codeph>DockIcon</codeph>. В ОС Windows<sup>®</sup> объект <codeph>NativeApplication.icon</codeph> принадлежит к типу <codeph>SystemTrayIcon</codeph>. В Linux значок приложения поддерживается не всегда. В этом случае свойство <codeph>icon</codeph> имеет значение <codeph>null</codeph>.</p>  
		 
		 <p>Объект <codeph>icon</codeph> создается автоматически, однако его инициализации с данными изображения не происходит. В некоторых ОС, например в Mac OS X, используется изображение по умолчанию. В остальных случаях, например в Windows, значок отображается только после присвоения ему данных изображения. Для присвоения изображения значка следует настроить свойство <codeph>icon.bitmaps</codeph> на работу с массивом, в котором содержится, по крайней мере, один объект BitmapData. Если в массиве содержится более одного объекта BitmapData, то ОС выбирает изображение, размер которого в наибольшей степени соответствует размерам значка на экране, и масштабирует его по мере необходимости.</p>  
   		 
         </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/supportsDockIcon"><linktext>supportsDockIcon</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsSystemTrayIcon"><linktext>supportsSystemTrayIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:idleThreshold:get"><apiName>idleThreshold</apiName><shortdesc>
		 Период времени в секундах с момента последнего использования клавиатуры или мыши до отправки события userIdle.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>При попытке установки свойства в недействительное значение. Приемлемый диапазон значений от 5 (5 секунд) до 86 400 (1 день) включительно.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
		 Период времени в секундах с момента последнего использования клавиатуры или мыши до отправки события <codeph>userIdle</codeph>. 
		 
		 <p>По умолчанию используется значение 300 секунд (5 минут). Приемлемый диапазон значений от 5 (5 секунд) до 86 400 (1 день) включительно.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/event:userIdle"><linktext>userIdle</linktext></link><link href="flash.desktop.xml#NativeApplication/event:userPresent"><linktext>userPresent</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:menu:get"><apiName>menu</apiName><shortdesc>
		 Меню приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Меню приложения.
		 
		 <p>Поддержка меню приложений осуществляется, если <codeph>NativeApplication.nativeApplication.supportsMenu</codeph> принимает значение <codeph>true</codeph>. Меню приложений поддерживают не все ОС. Например, меню приложений поддерживаются в Mac OS X, но не поддерживаются в Windows или Linux. Присвоить данному свойству объект NativeMenu, если <codeph>NativeApplication.nativeApplication.supportsMenu</codeph> принимает значение <codeph>false</codeph>, возможно, однако это не приведет к выполнению какого-либо действия. Свойство <codeph>NativeApplication.nativeApplication.supportsMenu</codeph> позволяет определить, поддерживает ли операционная система прикладные меню. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
		 
         <p><b>Примечание.</b> Свойство <codeph>menu</codeph> в Mac OS X ссылается на меню приложения, используемое в ОС по умолчанию. Существующую структуру меню можно модифицировать путем добавления или удаления элементов либо путем добавления прослушивателей событий. Также можно полностью заменить используемые по умолчанию меню, присвоив свойству <codeph>menu</codeph> новый объект NativeMenu.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:nativeApplication:get"><apiName>nativeApplication</apiName><shortdesc> 
		 Единственный экземпляр объекта NativeApplication.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:NativeApplication</apiValueClassifier><apiException><apiDesc>При доступе из внешней среды за пределами изолированной программной среды безопасности приложения.
		 
		 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
		 Единственный экземпляр объекта NativeApplication.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:openedWindows:get"><apiName>openedWindows</apiName><shortdesc>
		 В массиве содержатся все собственные открытые окна данного приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 В массиве содержатся все собственные открытые окна данного приложения.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:publisherID:get"><apiName>publisherID</apiName><shortdesc> 
		 Идентификатор издателя данного приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
		 Идентификатор издателя данного приложения. 
		 
		 <p>Значение этого идентификатора задается в файле идентификатора издателя приложения, который создается при установке. Данные берутся из цепочки сертификатов, используемых для подписи приложения.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:runtimePatchLevel:get"><apiName>runtimePatchLevel</apiName><shortdesc> 
		 Уровень исправления среды, в которой запускается данное приложение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		 Уровень исправления среды, в которой запускается данное приложение.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:runtimeVersion:get"><apiName>runtimeVersion</apiName><shortdesc> 
		 Номер версии среды, в которой запускается данное приложение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
		 Номер версии среды, в которой запускается данное приложение.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:startAtLogin:set"><apiName>startAtLogin</apiName><shortdesc>
        Указывает, будет ли данное приложение автоматически запускаться при входе текущего пользователя в систему.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>В Windows при наличии другого приложения с тем же именем, но с другим путем к исполняемому файлу, настроенного на запуск при входе пользователя в систему.
        
        </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если данное приложение не установлено, как это может произойти при запуске с помощью AIR Debug Launcher (ADL).
        
		</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
        Указывает, будет ли данное приложение автоматически запускаться при входе текущего пользователя в систему.
        
        <p>
        За состояние определенного ОС механизма автоматического запуска приложения при входе пользователя в систему отвечает свойство <codeph>startAtLogin</codeph>. Используя пользовательский интерфейс ОС, пользователь может самостоятельно изменить данное состояние. Это свойство отражает текущее состояние, а именно, было ли оно изменено ОС или приложением AIR.   
        </p>
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeApplication:supportsDockIcon:get"><apiName>supportsDockIcon</apiName><shortdesc> 
	   Указывает, поддерживает ли AIR в данной ОС значки панелей приложений.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	   Указывает, поддерживает ли AIR в данной ОС значки панелей приложений.
	  
	  <p>При значении <codeph>true</codeph> свойство <codeph>NativeApplication.icon</codeph> принадлежит к типу <codeph>DockIcon</codeph>.</p>
	  
      <p>В Mac OS X и различных пользовательских интерфейсах Linux<sup>®</sup> имеется своеобразная «панель» приложений со значками, которые могут использоваться часто используемыми или запущенными приложениями.</p>
	  
	  <p>Свойство <codeph>NativeApplication.supportsDockIcon</codeph> позволяет определить, поддерживает ли операционная система значки панелей приложений. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>Значок</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
	   Указывает, поддерживает ли текущая ОС глобальные строки меню приложений.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	   Указывает, поддерживает ли текущая ОС глобальные строки меню приложений.
	  
	  <p>При значении <codeph>true</codeph> свойство <codeph>NativeApplication.menu</codeph> может быть использовано для получения доступа или определения собственного меню приложения.</p> 
	  
	  <p>Свойство <codeph>NativeApplication.supportsMenu</codeph> позволяет определить, поддерживает ли операционная система строки меню приложений. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
	  
      </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/menu"><linktext>menu</linktext></link><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:supportsSystemTrayIcon:get"><apiName>supportsSystemTrayIcon</apiName><shortdesc> 
	  Указывает, поддерживает ли AIR в данной ОС значки на панели задач.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	  Указывает, поддерживает ли AIR в данной ОС значки на панели задач.
	  
	  <p>При значении <codeph>true</codeph> свойство <codeph>NativeApplication.icon</codeph> принадлежит к типу <codeph>SystemTrayIcon</codeph>.</p>
	  
	  <p>Свойство <codeph>NativeApplication.supportsSystemTrayIcon</codeph> позволяет определить, поддерживает ли операционная система значки на панели задач. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
	  
      <p><b>Примечание.</b> В Windows системная область панели задач носит официальное название <i>«Область уведомлений»</i>.</p> 
      
      </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>Значок</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeApplication:timeSinceLastUserInput:get"><apiName>timeSinceLastUserInput</apiName><shortdesc>
         Время в секундах с момента последнего использования клавиатуры или мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Время в секундах с момента последнего использования клавиатуры или мыши.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeApplication/event:userIdle"><linktext>userIdle</linktext></link><link href="flash.desktop.xml#NativeApplication/event:userPresent"><linktext>userPresent</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.desktop:Updater"><apiName>Updater</apiName><shortdesc>
     Класс Updater используется для обновления версии текущего запущенного приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     Класс Updater используется для обновления версии текущего запущенного приложения. Чтобы воспользоваться данным классом, следует создать объект Updater, а затем вызвать его метод <codeph>update()</codeph>.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="air.update.xml#ApplicationUpdater"><linktext>air.update.ApplicationUpdater</linktext></link><link href="air.update.xml#ApplicationUpdaterUI"><linktext>air.update.ApplicationUpdaterUI</linktext></link></related-links><apiConstructor id="flash.desktop:Updater:Updater"><apiName>Updater</apiName><shortdesc>
         Функция конструктора для класса Updater.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
         Функция конструктора для класса Updater. Обратите внимание, что метод <codeph>update()</codeph> не является статическим методом класса. Для вызова метода <codeph>update()</codeph> необходимо сначала создать объект Updater.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.desktop:Updater:update"><apiName>update</apiName><shortdesc>
         Производит обновление версии текущего запущенного приложения на версию приложения, указанную в файле AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Данный метод был вызван при работе в ADL. 
		 
		 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>airFile</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>Объект File, указывающий на файл AIR, в котором хранится версия приложения для обновления.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>version</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Требуемая версия нового файла AIR. Для успешного проведения обновления необходимо, чтобы строка атрибута <codeph>version</codeph> основного элемента <codeph>application</codeph> файла дескриптора приложения для файла AIR совпадала с данным значением.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Производит обновление версии текущего запущенного приложения на версию приложения, указанную в файле AIR. Необходимо, чтобы приложение в файле AIR имело тот же идентификатор (<codeph>appID</codeph>), что и текущее запущенное приложение.
		 
         <p>Вызов этого метода приводит к завершению работы приложения (как это происходит при вызове метода <codeph>NativeApplication.exit()</codeph>). Такое поведение объясняется тем, что Adobe AIR не может провести полное обновление приложения без завершения его работы. После успешного проведения обновления версии приложения на более новую, оно запускается вновь. Если установка новой версии не может быть завершена (например, если ее идентификатор приложения не совпадает с идентификатором существующего приложения), то программа установки AIR выводит сообщение об ошибке, и старая версия приложения запускается снова.</p>
		 
		 <p>Обновляемое приложение запускается снова независимо от результата проведения обновления. Ошибки в процессе обновления могут быть вызваны причинами, которые не зависят от приложения, например, отсутствие у пользователя прав для установки приложения. Приложения должны уметь определять характер ошибки, чтобы избежать повторных попыток обновления, приводящих к ошибке. В результате бесконечно повторяющегося цикла попыток обновления приложение просто откажется работать. Одним из способов проверки результата обновления приложения является сравнение версии текущего приложения до обновления и после него, когда приложение запустится вновь.</p>
		 
		 <p>При проверке приложения с использованием AIR Debug Launcher (ADL) вызов метода <codeph>update()</codeph> приводит к исключению IllegalOperationError.</p>
		 
		 <p>При обновлении версии приложения в Mac OS пользователь должен обладать всеми необходимыми правами на запись в каталог приложения. В Windows или Linux пользователь должен обладать правами администратора. </p>
		 
		 <p>Если обновленная версия приложения требует обновления среды выполнения, данное обновление устанавливается также. Для обновления среды выполнения пользователь данного компьютера должен обладать правами администратора.</p>
		 
		 <p><i>Примечание.</i> В целях безопасности указание параметра <codeph>version</codeph> является обязательным. Проверка версии приложения в файле AIR позволяет исключить возможность установки более старой версии приложения, в которой, возможно, содержится уязвимость системы безопасности, которую удалось исправить в новой версии.</p>
		 
		 </apiDesc><example conref="examples\Updater.update.1.as"> Обратите внимание на то, что метод <codeph>update()</codeph> <i>не</i> является статическим методом класса. Необходимо создать объект Updater и вызвать метод <codeph>update()</codeph> этого объекта.
<codeblock>
import flash.fileSystem.File;
import flash.desktop.Updater;
 
var updater:Updater = new Updater();
var airFile:File = File.applicationStore.resolvePath("Example Application.air");
var version:String = "2.01";
updater.update(airFile, version);
</codeblock></example></apiOperationDetail><related-links><link href="air.update.xml#ApplicationUpdater"><linktext>air.update.ApplicationUpdater</linktext></link><link href="air.update.xml#ApplicationUpdaterUI"><linktext>air.update.ApplicationUpdaterUI</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.desktop:SystemTrayIcon"><apiName>SystemTrayIcon</apiName><shortdesc>
	 Класс SystemTrayIcon представляет значок в стиле области уведомлений Windows (панель задач&amp;#xAE;).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.desktop:InteractiveIcon</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс SystemTrayIcon представляет значок в стиле области уведомлений Windows (панель задач<sup>®</sup>).
	 
	 <p>Значки на панели задач поддерживаются не всеми операционными системами. Выполните проверку <codeph>NativeApplication.supportsSystemTrayIcon</codeph>, чтобы узнать, поддерживает ли текущая ОС значки на панели задач.</p>
	 
	 <p>Невозможно создать экземпляр класса SystemTrayIcon. Получите объект, представляющий значок на панели задач, из свойства <codeph>icon</codeph> «глобального» объекта NativeApplication.
	 </p>
	 
	 <p>Если поддержка значков на панели задач есть, то значок является типом <i>SystemTrayIcon</i>. В противном случае тип <codeph>icon</codeph> является другим подклассом класса InteractiveIcon (обычно DockIcon).</p>
	 
	 
	 <p><b>Важно!</b> Попытка применить метод класса SystemTrayIcon к объекту <codeph>NativeApplication.icon</codeph> в ОС, где AIR не поддерживает работу со значками на панелях задач, приводит к ошибке.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsSystemTrayIcon"><linktext>flash.desktop.NativeApplication.supportsSystemTrayIcon</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link></related-links><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
	 Отправляется данным объектом SystemTrayIcon по щелчку правой кнопкой мыши.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется данным объектом SystemTrayIcon по щелчку правой кнопкой мыши.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
	 Отправляется данным объектом SystemTrayIcon при отпускании правой кнопки мыши.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется данным объектом SystemTrayIcon при отпускании правой кнопки мыши.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
	 Отправляется данным объектом SystemTrayIcon при нажатии правой кнопки мыши.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется данным объектом SystemTrayIcon при нажатии правой кнопки мыши.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 	 Отправляется данным объектом SystemTrayIcon по щелчку левой кнопкой мыши.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 	 Отправляется данным объектом SystemTrayIcon по щелчку левой кнопкой мыши.
 	 
 	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 	 Отправляется данным объектом SystemTrayIcon при отпускании левой кнопки мыши.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 	 Отправляется данным объектом SystemTrayIcon при отпускании левой кнопки мыши.
 	 
 	 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.desktop:SystemTrayIcon_flash.events.ScreenMouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 	 Отправляется данным объектом SystemTrayIcon при нажатии левой кнопки мыши.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ScreenMouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.ScreenMouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 	 Отправляется данным объектом SystemTrayIcon при нажатии левой кнопки мыши.
 	 
 	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiValue id="flash.desktop:SystemTrayIcon:MAX_TIP_LENGTH"><apiName>MAX_TIP_LENGTH</apiName><shortdesc>
		 Допустимая длина всплывающей подсказки значка на панели задач.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>63</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Допустимая длина всплывающей подсказки значка на панели задач.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:bitmaps:get"><apiName>bitmaps</apiName><shortdesc> 
		
		  
	 Изображение значка в массиве объектов BitmapData различных размеров.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc> 
		
		  
	 Изображение значка в массиве объектов BitmapData различных размеров.
	   
	 <p>При отображении значка в контексте конкретной ОС из массива выбирается изображение, размер которого в максимальной степени подходит под текущий размер экрана (при необходимости масштабируется). Обычные размеры включают: 16x16, 32x32, 48x48 и 128x128. (В ближайшем будущем в некоторых ОС могут использоваться значки размером 512x512 пикселей.)</p>
	 
	 <p>В некоторых контекстах, если свойству <codeph>bitmaps</codeph> ничего присвоено не было, может использоваться значок ОС по умолчанию. В остальных контекстах значок не отображается.</p>
	 
	 <p>Чтобы изменить вид значка, присвойте свойству <codeph>bitmaps</codeph> массив объектов BitmapData.</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>Прямая модификация массива <codeph>bitmaps</codeph> ни к чему не приведет.</p>
	 
	 <p>Чтобы убрать изображение значка, присвойте свойству <codeph>bitmaps</codeph> пустой массив.</p>
	 
	 <p>
	 <b>Примечание.</b> Загружайте файлы изображений для значков в формате PNG, так как этот формат обеспечивает наилучшее альфа-смешивание. Формат GIF поддерживает только включение или отключение прозрачности, но не смешивание. Формат JPG не поддерживает прозрачность совсем.  
	 </p>
	  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:height:get"><apiName>height</apiName><shortdesc> 
		
		 Текущее значение высоты значка в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Текущее значение высоты значка в пикселях.
		 
		 <p>Некоторые контексты значков поддерживают динамические размеры. Свойство <codeph>height</codeph> обозначает высоту значка, выбранного из массива <codeph>bitmaps</codeph> для данного контекста. Если в ОС было использовано масштабирование, то текущее значение высоты может отличаться.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:menu:get"><apiName>menu</apiName><shortdesc>
		 Меню значка на панели задач.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Меню значка на панели задач.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:tooltip:get"><apiName>tooltip</apiName><shortdesc>
		 Всплывающая подсказка, которая появляется при выполнении определенного действия над значком на панели задач.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Всплывающая подсказка, которая появляется при выполнении определенного действия над значком на панели задач. Если длина строки превышает значение, указанное в <codeph>SystemTrayIcon.MAX_TIP_LENGTH</codeph>, подсказка усекается.
		 
	     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:SystemTrayIcon:width:get"><apiName>width</apiName><shortdesc> 
		
		 Текущее значение ширины значка в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Текущее значение ширины значка в пикселях. 
		 
		 <p>Некоторые контексты значков поддерживают динамические размеры. Свойство <codeph>width</codeph> обозначает ширину значка, выбранного из массива <codeph>bitmaps</codeph> для данного контекста. Если в ОС было использовано масштабирование, то текущее значение ширины может отличаться.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:Clipboard"><apiName>Clipboard</apiName><shortdesc>
 Класс Clipboard предоставляет контейнер для передачи данных и объектов через буфер обмена.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>NativeDragManager is AIR only and is not in FP10.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Clipboard предоставляет контейнер для передачи данных и объектов через буфер обмена. В AIR класс Clipboard также используется для операций перетаскивания. Получить доступ к буферу обмена ОС можно через статическое свойство <codeph>generalClipboard</codeph>.
 
 <p>В объекте Clipboard одна и та же хранимая информация может быть в различных форматах. Такая организация хранения данных предусмотрена для обеспечения максимальной совместимости с различными приложениями. Для добавления данных в объект Clipboard, используйте метод <codeph>setData()</codeph> или <codeph>setDataHandler()</codeph>.</p> 
 
 <p>Стандартными форматами являются следующие:</p>
 <ul>
 <li>BITMAP_FORMAT: объект BitmapData (только для AIR)</li>
 <li>FILE_LIST_FORMAT: массив объектов File (только для AIR)</li>
 <li>HTML_FORMAT: строковые данные в формате HTML</li>
 <li>TEXT_FORMAT: строковые данные</li>
 <li>RICH_TEXT_FORMAT: объект ByteArray, содержащий данные в формате RTF</li>
 <li>URL_FORMAT: строка URL (только для AIR)</li>
 </ul>
 <p>Эти константы имен стандартных форматов определены в классе ClipboardFormats.</p>
 
 <p>Если передача выполняется между Flash Player или приложением AIR и операционной системой, преобразование стандартных форматов между типами данных <ph platform="javascript">JavaScript</ph> <ph platform="actionscript">ActionScript</ph> и системным буфером обмена происходит автоматически.</p>
 
 <p>Для добавления объектов <ph platform="javascript">JavaScript</ph> <ph platform="actionscript">ActionScript</ph> в объект Clipboard можно использовать форматы, определенные приложением. Если объект сериализуемый, доступными могут быть и ссылка на объект, и клон объекта. Ссылки на объекты действуют только в пределах исходного приложения.</p>
 
 <p>Если для преобразования передаваемой информации в определенный формат требуется очень большой объем вычислений, можно указать имя функции для выполнения такого преобразования. Данную функцию можно вызвать только в том случае, если требуемый формат может быть распознан принимающим компонентом или приложением. Добавьте функцию отложенной визуализации в объект Clipboard, используя метод <codeph>setDataHandler()</codeph>.</p>
 
 <p><b>Примечание для приложений AIR.</b> Тип объектов Clipboard, на которые ссылаются объекты событий, отправляемые для событий перетаскивания и копирования-вставки HTML, отличается от типа объектов Clipboard AIR. Объекты буфера обмена JavaScript рассматриваются в руководстве для разработчика приложений AIR.</p>
 
 <p>В Linux при закрытии приложения AIR данные из буфера обмена не сохраняются.</p>
  
 </apiDesc><example conref="examples\ClipboardExample.as"> В следующем примере для Adobe AIR показано копирование строки из одной переменной в другую через буфер обмена операционной системы с использованием класса ClipboardExample. Это можно сделать, выполнив следующие действия.
 
 <ol>
     <li>Произведите запись данных (в данном случае строковых данных) в <codeph>Clipboard.generalClipboard</codeph>.</li>
    <li>Произведите считывание содержимого буфера обмена из <codeph>Clipboard.generalClipboard</codeph>.</li>
 </ol>
 <p><b>Примечание.</b> Ввиду ограничений безопасности на доступ к данным из буфера обмена этот пример не работает в Flash Player. В Flash Player можно только вызвать метод <codeph>getData()</codeph> объекта Clipboard в обработчике события <codeph>paste</codeph>.</p>
<codeblock>
package
{
    import flash.display.Sprite;
    import flash.desktop.Clipboard;
    import flash.desktop.ClipboardFormats;
    import flash.desktop.ClipboardTransferMode;

    public class ClipboardExample extends Sprite
    {
        public function ClipboardExample()
        {
            var sally:String = "Sally";
            var person:String;
            
            copy(sally);
            person = paste();
            trace(person); //traces: "Sally"
        }

        private function copy(text:String):void 
        {
            Clipboard.generalClipboard.clear();
            Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, text);
        }
        
        private function paste():String
        {
            if(Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT))
            {
                return String(Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT));
            } 
            else 
            {
                return null;
            }
        }
        
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeDragManager"><linktext>flash.desktop.NativeDragManager</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link><link href="flash.desktop.xml#ClipboardTransferMode"><linktext>flash.desktop.ClipboardTransferMode</linktext></link></related-links><apiConstructor id="flash.desktop:Clipboard:Clipboard"><apiName>Clipboard</apiName><shortdesc>
	Создает пустой объект Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>the example located at examples\Clipboard.clipboard.1.as should not be displayed with FP10 docs because FP10 will throw an error when new Clipboard() is called.
	</internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Flash Player не поддерживает метод <codeph>new Clipboard()</codeph>, так как здесь может использоваться только буфер обмена ОС. Для осуществления операций копирования/вставки с использованием буфера обмена ОС, используйте уже существующий объект Clipboard.generalClipboard. Это не приводит к ошибке в приложении AIR.
	
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiConstructorDef><apiDesc>
	Создает пустой объект Clipboard.
	
	</apiDesc><example conref="examples\Clipboard.clipboard.1.as"> В следующем примере создается новый буфер обмена для использования с классом NativeDragManager.
 
 <p><b>Примечание.</b> Для осуществления операций копирования/вставки с использованием буфера обмена ОС вместо создания нового буфера обмена используйте уже существующий объект <codeph>Clipboard.generalClipboard</codeph>.</p>
<codeblock>
 import flash.desktop.Clipboard;
 
 var clipboard:Clipboard = new Clipboard();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.desktop.xml#Clipboard/generalClipboard"><linktext>generalClipboard</linktext></link></related-links></apiConstructor><apiOperation id="flash.desktop:Clipboard:clear"><apiName>clear</apiName><shortdesc>
	Удаляет все представления данных из этого объекта Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	Удаляет все представления данных из этого объекта Clipboard.
	
 	</apiDesc><example conref="examples\Clipboard.clear.1.as"> В следующем примере производится очистка буфера обмена ОС:
<codeblock>
 Clipboard.generalClipboard.clear();
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:Clipboard:clearData"><apiName>clearData</apiName><shortdesc>
	Удаляет представления данных заданного формата.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Формат данных для удаления.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Удаляет представления данных заданного формата.
	
 	</apiDesc><example conref="examples\Clipboard.clearData.1.as"> В следующем примере из буфера обмена производится удаление всех данных в формате <codeph>ClipboardFormats.TEXT_FORMAT</codeph>.
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 Clipboard.generalClipboard.clearData(ClipboardFormats.TEXT_FORMAT);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:Clipboard:getData"><apiName>getData</apiName><shortdesc>
	Определяет данные из буфера обмена, если они существуют в указанном формате.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>transferMode</codeph> не является одним из имен, определенных в классе ClipboardTransferMode.
	</apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Запрошенный объект Clipboard больше не находится в области действия (только для AIR).
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>В данном контексте операции чтения и записи в буфер обмена запрещены. В приложении Flash Player этот метод можно вызывать только во время обработки события <codeph>paste</codeph>. В приложении AIR это ограничение применяется только к содержимому, находящемуся за пределами изолированной программной среды безопасности.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект данного типа, соответствующий формату данных.
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Возвращаемый формат данных. В строке формата может содержаться одно их стандартных имен, определенных в классе ClipboardFormats, или имя, задаваемое приложением.
	</apiDesc></apiParam><apiParam><apiItemName>transferMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>originalPreferred</apiData><apiDesc>Указывает, возвращать ли ссылку или сериализованную копию при доступе к формату данных, заданному приложением. Данное значение должно быть из списка заданных имен в классе ClipboardTransferMode. Это значение игнорируется для стандартных форматов данных; всегда возвращается копия.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Определяет данные из буфера обмена, если они существуют в указанном формате.
	
	<p>В приложении Flash Player метод <codeph>getData()</codeph> необходимо вызывать в обработчике события <codeph>paste</codeph>. В приложении AIR это ограничение применяется только к содержимому, находящемуся за пределами изолированной программной среды безопасности.</p>
	
	<p>При доступе к данным стандартного формата, данные возвращаются в качестве нового объекта соответствующего типа Flash Player или AIR.</p>
	
	<p>При доступе к данным в формате, указанном приложением, значение параметра <codeph>transferMode</codeph> определяет, возвращать ли ссылку на исходный объект или анонимный объект, содержащий сериализованную копию исходного объекта. Если при использовании режима <codeph>originalPreferred</codeph> или <codeph>clonePreferred</codeph> предпочтительная версия недоступна, Flash Player или AIR возвращает альтернативную версию. Если при использовании режима <codeph>originalOnly</codeph> или <codeph>cloneOnly</codeph> запрашиваемая версия недоступна, Flash Player или AIR возвращает значение <codeph>null</codeph>.</p>
	
	</apiDesc><example conref="examples\Clipboard.getData.1.as"> В следующем примере происходит считывание текста из буфера обмена ОС, если он существует:
<codeblock>
 import flash.desktop.ClipboardFormats;

 var pasteData:String = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard/setData()"><linktext>setData()</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link><link href="flash.desktop.xml#ClipboardTransferMode"><linktext>flash.desktop.ClipboardTransferMode</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:Clipboard:hasFormat"><apiName>hasFormat</apiName><shortdesc>
	Проверяет наличие данных указанного формата в данном объекте Clipboard.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Запрошенный объект Clipboard больше не находится в области действия (только для AIR).
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>В данном контексте операции чтения и записи в буфер обмена запрещены.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, если данные в указанном формате существуют.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Проверяемый тип формата.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Проверяет наличие данных указанного формата в данном объекте Clipboard.
	
	<p>С помощью констант класса ClipboardFormats можно ссылаться на имена стандартных форматов.</p>
	
	</apiDesc><example conref="examples\Clipboard.hasFormat.1.as"> В следующем примере производится проверка наличия в буфере обмена ОС данных в текстовом формате:
<codeblock>
if(Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT)){
    //do something 
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:Clipboard:setData"><apiName>setData</apiName><shortdesc>
	Добавляет представление информации для передачи данных в указанном формате данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Запрошенный объект Clipboard больше не находится в области действия (только для AIR).
	
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>В данном контексте операции чтения и записи в буфер обмена запрещены. В приложении Flash Player этот метод можно вызывать только во время обработки пользовательского события (в виде нажатия клавиши или щелчка мыши). В приложении AIR это ограничение применяется только к содержимому, находящемуся за пределами изолированной программной среды безопасности.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Свойство <codeph>format</codeph> или свойство <codeph>data</codeph> имеет значение <codeph>null</codeph>.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Если данные были записаны успешно – <codeph>true</codeph>. В противном случае – <codeph>false</codeph>. Flash Player возвращает значение <codeph>false</codeph>, если элемент <codeph>format</codeph> не поддерживается классом ClipboardFormats. (Flash Player не поддерживает следующие элементы: <codeph>ClipboardFormats.URL_FORMAT</codeph>, <codeph>ClipboardFormats.FILE_LIST_FORMAT</codeph> и <codeph>ClipboardFormats.BITMAP_FORMAT</codeph>.)
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Формат данных.
	</apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Добавляемая информация. 
	</apiDesc></apiParam><apiParam><apiItemName>serializable</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Укажите значение <codeph>true</codeph> для тех объектов, которые можно сериализовать (и десериализовать).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Добавляет представление информации для передачи данных в указанном формате данных. В приложении Flash Player перед использованием метода <codeph>setData()</codeph> требуется наличие пользовательского события (такого как нажатие клавиши или щелчок мыши). В приложении AIR это ограничение применяется только к содержимому, находящемуся за пределами изолированной программной среды безопасности.
	
	<p>Различные представления одной и той же информации могут храниться в буфере обмена в нескольких форматах. Это сделано для того, чтобы различные приложения или компоненты смогли воспользоваться доступными данными. Например, в приложении AIR изображение может быть добавлено: в растровом формате для использования в редакторах изображений, в качестве объекта Bitmap для использования в любом другом приложении AIR, в качестве закодированного PNG-файла для передачи в собственную файловую систему.</p>
	
	<p>Параметр data должен относиться к типу данных, соответствующему указанному формату.</p>
	<adobetable class="innertable">
	    
	    
	    
	    
	    
	    
	    
	    
	<tgroup cols="3"><thead><row><entry>Формат</entry><entry>Тип</entry><entry>Описание</entry></row></thead><tbody><row><entry><codeph>ClipboardFormats.TEXT_FORMAT</codeph></entry><entry><codeph>Строка</codeph></entry><entry>строковые данные</entry></row><row><entry><codeph>ClipboardFormats.HTML_FORMAT</codeph></entry><entry><codeph>Строка</codeph></entry><entry>строковые данные HTML</entry></row><row><entry><codeph>ClipboardFormats.URL_FORMAT</codeph></entry><entry><codeph>Строка</codeph></entry><entry>строка URL-адреса (только для AIR)</entry></row><row><entry><codeph>ClipboardFormats.RICH_TEXT_FORMAT</codeph></entry><entry><codeph>ByteArray</codeph></entry><entry>Данные в формате RTF</entry></row><row><entry><codeph>ClipboardFormats.BITMAP_FORMAT</codeph></entry><entry><codeph>BitmapData</codeph></entry><entry>данные растрового изображения (только для AIR)</entry></row><row><entry><codeph>ClipboardFormats.FILE_LIST_FORMAT</codeph></entry><entry>массив <codeph>File</codeph></entry><entry>массив файлов (только для AIR)</entry></row><row><entry>Имя пользовательского формата</entry><entry>любые</entry><entry>ссылка на объект и сериализованный клон</entry></row></tbody></tgroup></adobetable>
	
	<p>Имя пользовательского формата не может начинаться со слов air: или flash:. В приложении AIR, во избежание совпадения имен при использовании пользовательских форматов, в качестве префикса к формату можно добавить идентификатор вашего приложения или имя пакета, например com.example.applicationName.dataPacket.</p>
	
	<p>При передаче данных внутри или между приложениями Flash Player или AIR параметр <codeph>serializable</codeph> определяет, являются ли доступными и ссылка, и копия или только ссылка на объект. Задайте для параметра <codeph>serializable</codeph> значение <codeph>true</codeph>, чтобы сделать доступными и ссылку, и копию объекта данных. Задайте для параметра <codeph>serializable</codeph> значение <codeph>false</codeph>, чтобы сделать доступной только ссылку на объект. Ссылки на объекты действуют только в текущем приложении, поэтому установка параметра <codeph>serializable</codeph> на значение <codeph>false</codeph> также означает, что данные такого формата недоступны для других приложений Flash Player или AIR. Компонент может выбрать между получением ссылки на объект или копии объекта, установив соответствующий режим передачи данных для буфера обмена при доступе к данным формата.</p>
	
	<p><b>Примечание.</b> Стандартные форматы всегда преобразуются в собственные форматы системы при вставке или перетаскивании (только для AIR) данных вне поддерживаемого приложения, поэтому значение параметра <codeph>serializable</codeph> не влияет на доступность данных стандартного формата для приложений, отличных от приложений Flash Player или AIR.</p>
	
	<p>Для отложенной визуализации данных формата используйте метод <codeph>setDataHandler()</codeph>. Если оба метода – <codeph>setData()</codeph> и <codeph>setDataHandler()</codeph> – используются для добавления представления данных с одинаковым именем формата, то функция обработчика не будет вызвана.</p>
	
	<p><b>Примечание.</b> При установке параметра <codeph>format</codeph> равным <codeph>ClipboardFormats.URL_FORMAT</codeph> в системе Mac OS URL-адрес передается только в том случае, если этот URL-адрес действителен. В противном случае объект Clipboard очищается, а вызов <codeph>getData()</codeph> возвращает значение <codeph>null</codeph>).</p>
	
	</apiDesc><example conref="examples\Clipboard.setData.1.as"> В следующем примере происходит добавление в буфер обмена одного и того же содержимого в текстовом формате и формате HTML:
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 var htmlString:String = "&lt;html>&lt;body>Body content&lt;/body>&lt;/html>";
 Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, urlString);
 Clipboard.generalClipboard.setData(ClipboardFormats.HTML_FORMAT, urlString);
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard/setDataHandler()"><linktext>setDataHandler()</linktext></link><link href="flash.desktop.xml#Clipboard/getData()"><linktext>getData()</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link><link href="flash.desktop.xml#ClipboardTransferMode"><linktext>flash.desktop.ClipboardTransferMode</linktext></link></related-links></apiOperation><apiOperation id="flash.desktop:Clipboard:setDataHandler"><apiName>setDataHandler</apiName><shortdesc>
	Добавляет ссылку на функцию обработчика, который по требованию создает данные в указанном формате.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Свойство <codeph>format</codeph> или свойство <codeph>handler</codeph> имеет значение <codeph>null</codeph>.
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Запрошенный объект Clipboard больше не находится в области действия (только для AIR).
	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>В данном контексте операции чтения и записи в буфер обмена запрещены. В приложении Flash Player этот метод можно вызывать только во время обработки пользовательского события (такого как нажатие клавиши или щелчок мыши). В приложении AIR это ограничение применяется только к содержимому, находящемуся за пределами изолированной программной среды безопасности.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Если обработчик был настроен успешно – <codeph>true</codeph>. В противном случае – <codeph>false</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Функция, при вызове которой возвращаются передаваемые данные.
	</apiDesc></apiParam><apiParam><apiItemName>handler</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Формат данных. 
	</apiDesc></apiParam><apiParam><apiItemName>serializable</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Задайте значение <codeph>true</codeph>, если объект, возвращаемый <codeph>handler</codeph>, можно сериализовать (и десериализовать).
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Добавляет ссылку на функцию обработчика, который по требованию создает данные в указанном формате. Используйте данный метод для того, чтобы отложить создание или визуализацию данных до момента доступа к ним. В приложении Flash Player перед использованием метода <codeph>setDataHandler()</codeph> требуется наличие пользовательского события (такого как нажатие клавиши или щелчок мыши). В приложении AIR это ограничение применяется только к содержимому, находящемуся за пределами изолированной программной среды безопасности.
	
	<p>Функция обработчика должна возвращать соответствующий заданному формату тип данных.</p>
	<adobetable class="innertable">
	    
	    
	    
	    
	    
	    
	    
	      
	<tgroup cols="2"><thead><row><entry>Формат</entry><entry>Возвращаемый тип</entry></row></thead><tbody><row><entry><codeph>ClipboardFormats.TEXT_FORMAT</codeph></entry><entry><codeph>Строка</codeph></entry></row><row><entry><codeph>ClipboardFormats.HTML_FORMAT</codeph></entry><entry><codeph>Строка</codeph></entry></row><row><entry><codeph>ClipboardFormats.URL_FORMAT</codeph></entry><entry><codeph>String</codeph> (только для AIR)</entry></row><row><entry><codeph>ClipboardFormats.RICH_TEXT_FORMAT</codeph></entry><entry><codeph>ByteArray</codeph></entry></row><row><entry><codeph>ClipboardFormats.BITMAP_FORMAT</codeph></entry><entry><codeph>BitmapData</codeph> (только для AIR)</entry></row><row><entry><codeph>ClipboardFormats.FILE_LIST_FORMAT</codeph></entry><entry>Массив объектов <codeph>File</codeph> (только для AIR)</entry></row><row><entry>Имя пользовательского формата</entry><entry>Непустой</entry></row></tbody></tgroup></adobetable>
	
	<p>Функция обработчика вызывается только в том случае, если данные заданного формата распознаются. Обратите внимание на то, что данные могут измениться с момента добавления обработчика до момента их считывания, если только ваше приложение не обеспечивает защиту данных. Поведение при многократном считывании данных буфера обмена, представленных функцией обработчика, не гарантировано. Flash Player или AIR может возвратить данные, созданные при первом вызове функции, или выполнить повторный вызов функции. Не следует полагаться ни на одно из этих поведений.</p>
	
	<p>Для добавления данных непосредственно в этот объект Clipboard используйте метод <codeph>setData()</codeph>. Если вызываются оба метода – <codeph>setData()</codeph> и <codeph>setDataHandler()</codeph> – с одинаковым именем формата, то функция обработчика не будет вызвана.</p>
	
	<p><b>Примечание.</b> При установке параметра <codeph>format</codeph> равным <codeph>ClipboardFormats.URL_FORMAT</codeph> в системе Mac OS URL-адрес передается только в том случае, если функция обработчика возвращает действительный URL-адрес. В противном случае объект Clipboard очищается, а вызов <codeph>getData()</codeph> возвращает значение <codeph>null</codeph>).</p>
	
	</apiDesc><example conref="examples\Clipboard.setDataHandler.1.as"> В данном примере происходит добавление произвольного числа в буфер обмена ОС с использованием функции отложенных данных:
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 Clipboard.generalClipboard.setDataHandler(ClipboardFormats.TEXT_FORMAT, randomNumberGenerator);

 public function randomNumberGenerator():String{
     return Math.random().toString();
 }
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard/setData()"><linktext>setData()</linktext></link><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:Clipboard:formats:get"><apiName>formats</apiName><shortdesc>
	В этом объекте Clipboard находится массив строк, в котором содержатся имена поддерживаемых форматов данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	В этом объекте Clipboard находится массив строк, в котором содержатся имена поддерживаемых форматов данных.
	
	<p>Константы имен стандартных форматов содержатся в классе ClipboardFormats. Задаваемые приложением строки могут также использоваться в качестве имен форматов для передачи данных в виде объектов.</p>
	
	</apiDesc><example conref="examples\Clipboard.formats.1.as"> В следующем примере происходит считывание массива <codeph>formats</codeph> из буфера обмена ОС:
<codeblock>
 var availableFormats:Array = Clipboard.generalClipboard.formats;
</codeblock></example></apiValueDetail><related-links><link href="flash.desktop.xml#ClipboardFormats"><linktext>flash.desktop.ClipboardFormats</linktext></link></related-links></apiValue><apiValue id="flash.desktop:Clipboard:generalClipboard:get"><apiName>generalClipboard</apiName><shortdesc>
	 Буфер обмена ОС.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:Clipboard</apiValueClassifier></apiValueDef><apiDesc>
	 Буфер обмена ОС.
	 
	 <p>Любые данные, передаваемые в буфер обмена, доступны другим приложениям. По этой причине возможно удаленное выполнение вредоносного кода в web-браузере.</p>
	 
	 <p><b>Примечание.</b> В приложениях Flash Player 10 перед использованием операции вставки из буфера обмена требуется наличие пользовательского события (такого как нажатие комбинации клавиш для команды вставки или выбор команды вставки в контекстном меню щелчком мыши). Метод <codeph>Clipboard.getData()</codeph> возвратит содержимое буфера обмена только в том случае, если InteractiveObject получил и обрабатывает событие paste. При любых обстоятельствах вызов метода <codeph>Clipboard.getData()</codeph> ни к чему не приведет. В AIR то же ограничение применяется к содержимому за пределами изолированной программной среды приложения.</p>
	 
	 <p>Объект <codeph>generalClipboard</codeph> создается автоматически. Присвоить данному свойству другой экземпляр объекта Clipboard невозможно. Вместо этого для чтения и записи данных в уже существующий объект используйте методы <codeph>getData()</codeph> и <codeph>setData()</codeph>.</p>
	 
	 <p>Перед тем как записывать в буфер обмена новые данные, следует удалить из него предыдущие данные всех форматов.</p>
	 
	 </apiDesc><example conref="examples\Clipboard.generalClipboard.1.as"> Порядок записи в буфер обмена операционной системы:
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 var copy:String = "A string to copy to the system clipboard.";
 Clipboard.generalClipboard.clear();
 Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, copy);
</codeblock></example><example conref="examples\Clipboard.generalClipboard.2.as"> Порядок чтения из буфера обмена операционной системы:
<codeblock>
 import flash.desktop.ClipboardFormats;
 
 var pasteData:String  = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NotificationType"><apiName>NotificationType</apiName><shortdesc>
 Класс NotificationType определяет константы, используемые в параметре priority метода DockIcon bounce(), а также параметр type метода NativeWindow notifyUser().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс NotificationType определяет константы, используемые в параметре <codeph>priority</codeph> метода DockIcon <codeph>bounce()</codeph>, а также параметр <codeph>type</codeph> метода NativeWindow <codeph>notifyUser()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#DockIcon/bounce()"><linktext>flash.desktop.DockIcon.bounce()</linktext></link><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links><apiValue id="flash.desktop:NotificationType:CRITICAL"><apiName>CRITICAL</apiName><shortdesc>
	 Указывает на то, что уведомление носит важный характер, и пользователь должен уделить этому внимание.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>critical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает на то, что уведомление носит важный характер, и пользователь должен уделить этому внимание.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NotificationType:INFORMATIONAL"><apiName>INFORMATIONAL</apiName><shortdesc>
	 Указывает на то, что уведомление носит информационный характер, и пользователь может не обращать на него внимания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>informational</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает на то, что уведомление носит информационный характер, и пользователь может не обращать на него внимания.
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:ClipboardTransferMode"><apiName>ClipboardTransferMode</apiName><shortdesc>
 Класс ClipboardTransferMode задает константы для режимов, которые используются в качестве значений параметра transferMode метода Clipboard.getData().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Clipboard, ClipboardFormats and ClipboardTransferMode were all added to AIR 1.0. These are also being added, with some exceptions listed in this file, to FP10.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс ClipboardTransferMode задает константы для режимов, которые используются в качестве значений параметра <codeph>transferMode</codeph> метода <codeph>Clipboard.getData()</codeph>.
 
 <p>В режиме перехода предусмотрен выбор между возвратом ссылки или его копии при обращении объекту буфера обмена.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#Clipboard/getData()"><linktext>flash.desktop.Clipboard.getData()</linktext></link></related-links><apiValue id="flash.desktop:ClipboardTransferMode:CLONE_ONLY"><apiName>CLONE_ONLY</apiName><shortdesc>
    Объект буфера обмена всегда возвращает копию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>cloneOnly</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Объект буфера обмена всегда возвращает копию.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardTransferMode:CLONE_PREFERRED"><apiName>CLONE_PREFERRED</apiName><shortdesc>
    Объект буфера обмена возвращает копию, если она доступна, и ссылку, если нет.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clonePreferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Объект буфера обмена возвращает копию, если она доступна, и ссылку, если нет.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardTransferMode:ORIGINAL_ONLY"><apiName>ORIGINAL_ONLY</apiName><shortdesc>
    Объект буфера обмена всегда возвращает ссылку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>originalOnly</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Объект буфера обмена всегда возвращает ссылку.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:ClipboardTransferMode:ORIGINAL_PREFERRED"><apiName>ORIGINAL_PREFERRED</apiName><shortdesc>
    Объект буфера обмена возвращает ссылку, если она доступна, и копию, если нет.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>originalPreferred</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Объект буфера обмена возвращает ссылку, если она доступна, и копию, если нет.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeDragManager"><apiName>NativeDragManager</apiName><shortdesc>
 Класс NativeDragManager отвечает за управление операциями перетаскивания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс NativeDragManager отвечает за управление операциями перетаскивания. С помощью технологии перетаскивания пользователь может перемещать данные между приложением AIR и ОС, между двумя приложениями или компонентами одного приложения.
 
 <p>Можно перемещать следующие типы данных:</p>
 <ul>
 <li>Растровые изображения</li>
 <li>Файлы</li>
 <li>Текст</li>
 <li>Строки URL</li>
 <li>Последовательные объекты</li>
 <li>Ссылки на объекты (действует только в пределах исходного приложения)</li>
 </ul>
 
 <p><b>Примечание.</b> Все члены NativeDragManager являются статическими. Нужды в создании этого класса нет.</p>
 
 <p>Операция перетаскивания представляет собой действие пользователя, которое начинается с щелчка по видимому элементу и его дальнейшему перетаскиванию куда-либо. По мере передвижения в окне приложения AIR перетаскиваемые интерактивные объекты в списке отображения отправляют события собственного перетаскивания. Обработчики этих событий могут вызывать методы класса NativeDragManager для определения возможности перетащить данный элемент на какой-либо объект. В результате NativeDragManager реагирует на действия пользователя изменением курсора мыши.</p>
 
 <p><b>Операции перетаскивания</b></p>
 <p>Перетаскивание используется для трех типов действий, называемых <i>операциями</i>. Так как значение этих операций зависит от контекста приложения, никого определенной реакции на действия при выполнении программы не предусмотрено. Однако, правильная реализация операций повышает удобство использование данного приложения.
 </p> 
 
 <p>Возможные операции:</p>
 <ul>
 <li>Копирование – осуществляет копирование данных, оставляя оригинал без изменений. (При перетаскивании объектов внутри приложения необходимо следить за тем, чтобы копировался сам объект, а не ссылка на него.)</li>
 <li>Перемещение – переносит данные из исходного контекста в контекст, определяемый операцией перетаскивания, например, при перемещении объекта из одного списка в другой.</li>
 <li>Ссылка – создает ярлык или ссылку на исходные данные, оставляя их в исходном контексте.</li>
 </ul>
 
 <p>Возможные операции по перетаскиванию задаются параметром <codeph>allowedActions</codeph> при вызове <codeph>NativeDragManager.doDrag()</codeph> в момент начала операции перетаскивания. Если параметр <codeph>allowedActions</codeph> не задан, все операции считаются допустимыми. Потенциальные цели опускания, могут использовать свойство <codeph>allowedActions</codeph> объекта NativeDragEvent для запрещения определенных операций перетаскивания (несмотря на то, что в ходе выполнения программы эти ограничения отсутствуют).</p>
 
 <p>Если цель опускания реализует только одно действие, то объект может настроить в обработчиках свойство <codeph>dropAction</codeph> класса NativeDragManager на обработку событий <codeph>nativeDragEnter</codeph> и <codeph>nativeDragOver</codeph>. Настройка данного свойства до перетаскивания позволит обновлять курсор мыши для отображения поддерживаемого действия, а также исключит возможность совершения пользователем несовместимого действия с помощью клавиш-модификаторов. При совершении несовместимой операции перетаскивание не осуществляется, даже если цель вызывает метод <codeph>acceptDrop()</codeph>.</p>
 
 <p>Если потенциальная цель принимает опускание, она должна указать совершаемое действие путем задания свойства <codeph>NativeDragManager.dropAction</codeph> в ответ на событие <codeph>nativeDragDrop</codeph>. Эта операция возвращается инициирующему экранному объекту в виде события <codeph>nativeDragComplete</codeph>. Если цель опускания операцию не задает, то возвращается операция по умолчанию из списка доступных операций в следующем порядке: копирование, перемещение, ссылка. Инициирующий объект отвечает за обновление внутреннего состояния в ответ на выбранную операцию.</p> 
 
 <p>Константы строк для названий операций задаются в классе NativeDragActions.</p>
  
 <p><b>Порядок событий</b></p>
 <p>Процесс перетаскивание начинается с вызова метода <codeph>NativeDragManager.doDrag()</codeph> в рамках обработчика событий <codeph>mouseDown</codeph> или <codeph>mouseMove</codeph> и проходит через следующую последовательность событий в ответ на действия пользователя:</p>
 <ul>
 <li>Событие <codeph>nativeDragStart</codeph> – при вызове <codeph>NativeDragManager.doDrag()</codeph> интерактивный объект, переданный в качестве параметра, становится инициирующим объектом и отправляет событие <codeph>nativeDragStart</codeph>.</li> 
 
 <li>Событие <codeph>nativeDragUpdate</codeph> – в процессе перетаскивания инициирующий объект постоянно отправляет события <codeph>nativeDragUpdate</codeph>.</li>
 
 <li>События <codeph>nativeDragEnter</codeph>, <codeph>nativeDragOver</codeph> – при наведении перетаскиваемого объекта на интерактивный объект, последний отправляет событие <codeph>nativeDragEnter</codeph>. При задержке действия над интерактивным объектом он постоянно отправляет события <codeph>nativeDragOver</codeph>. В ответ на любое из этих двух событий объект, выступающий в роли потенциальной цели опускания, должен осуществить проверку свойств объекта события, чтобы принять или отклонить опускание. Если формат данных и совершаемая операция находятся в списке допустимых, то обработчик этих событий вызывает <codeph>NativeDragManager.acceptDrop()</codeph> и передает действие экранному объекту, который становится местом опускания (обычно это объект, который отправлял событие <codeph>nativeDragEnter</codeph> или <codeph>nativeDragOver</codeph>). Затем пользователь может опустить перетаскиваемый объект на цель.</li>
 
 <li>Событие <codeph>nativeDragExit</codeph> – при выходе жеста перетаскивания на границы интерактивного объекта объект отправляет событие <codeph>nativeDragExit</codeph>. Если данный объект был выбран в качестве целевого путем вызова метода <codeph>NativeDragManager.acceptDrop()</codeph>, этот выбор считается больше недействительным. При повторном входе жеста перетаскивания в пределы действия интерактивного объекта необходимо также вызвать <codeph>acceptDrop()</codeph> повторно.</li>
 
 <li>Событие <codeph>nativeDragDrop</codeph> – целевой экранный объект отправляет событие <codeph>nativeDragDrop</codeph>, когда пользователь отпускает кнопку мыши над объектом. Обработчик данного события получает доступ к свойству <codeph>transferable</codeph> объекта события и устанавливает свойство <codeph>NativeDragManager.dropAction</codeph> для оповещения инициирующего объекта об операции, которую необходимо выполнить.</li>
 
 <li><codeph>nativeDragComplete</codeph> – когда пользователь в конце жеста перетаскивания отпускает кнопку мыши, инициирующий объект отправляет событие <codeph>nativeDragComplete</codeph> (независимо от результата самого опускания). Обработчик этого события проверяет свойство <codeph>dropAction</codeph> объекта события и определяет вносимые изменения в его внутреннее состояние данных, если таковые требуется (например, удаление из списка перетащенного элемента). Если <codeph>dropAction</codeph> является <codeph>NativeDragActions.NONE</codeph>, тогда перетаскивание элемента на пригодный целевой объект не произошло.</li>
 </ul>
 
 <p><b>Жесты при работе с приложениями</b></p>
 <p>Когда жест перетаскивания входит в окно приложения AIR из приложения, не поддерживающего AIR, то событие <codeph>nativeDragStart</codeph> или <codeph>nativeDragComplete</codeph> объектом не отправляется. Отправляемые во время этого жеста события будут, напротив, следовать тому же принципу, что и жесты, начатые и законченные в пределах приложения AIR.</p>
 
 <p>Когда жест перетаскивания покидает окно приложения AIR, то целевой объект для отправки событий <codeph>nativeDragEnter</codeph>, <codeph>nativeDragOver</codeph> или <codeph>nativeDragDrop</codeph> отсутствует. Инициирующий объект по-прежнему отправляет событие <codeph>nativeDragComplete</codeph>, которое сообщает об операции перетаскивания, установленной операционной системой (или <codeph>none</codeph>, если опускание было отклонено).</p>
 
 <p>Когда жест перетаскивания перемещается между двумя приложениями AIR, то инициирующие и целевые экранные объекты этих приложений отправляют события как обычно.</p>
 
 <p><b>Информация о передаче</b></p>
 <p>Все передаваемые во время жеста перетаскивания данные содержатся в объекте Clipboard. Этот объект данных добавляется к операции перетаскивания с помощью метода <codeph>NativeDragManager.doDrag()</codeph>, с которого начинается жест перетаскивания. Потенциальные цели опускания могут получить доступ к объекту Clipboard через свойство <codeph>clipboard</codeph> самого объекта, инициирующего событие перетаскивания. После начала операции перетаскивания к объекту Clipboard можно получить доступ через обработчик события NativeDragEvent. Остальные попытки получить доступ к объекту приводят к ошибке выполнения.</p>
 
 <p><b>Соображения безопасности</b></p>
 <p>Способ доступа к перетаскиваемым данным задается изолированными средами инициирующих и потенциальных целевых объектов. Если оба объекта находятся в одной и той же изолированной среде, тогда доступ к данным можно получить через любой объект NativeDragEvent. Однако, если эти объекты расположены в разных изолированных средах, то доступ к данным можно получить только в целевой изолированной среде в пределах обработчика события <codeph>nativeDragDrop</codeph>. Прочие обработчики событий собственного перетаскивания также могут получать доступ к объекту Clipboard, на который ссылается свойство <codeph>clipboard</codeph> события, чтобы определить доступные форматы данных. При этом вызов метода <codeph>clipboard.getData()</codeph> приведет к ошибке системы безопасности.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#NativeDragEvent"><linktext>flash.events.NativeDragEvent</linktext></link><link href="flash.desktop.xml#NativeDragActions"><linktext>flash.desktop.NativeDragActions</linktext></link><link href="flash.desktop.xml#NativeDragOptions"><linktext>flash.desktop.NativeDragOptions</linktext></link><link href="flash.desktop.xml#Clipboard"><linktext>flash.desktop.Clipboard</linktext></link></related-links><apiOperation id="flash.desktop:NativeDragManager:acceptDragDrop"><apiName>acceptDragDrop</apiName><shortdesc>
	 Информирует объект NativeDragManager о том, что указанный целевой интерактивный объект может принять опускание, которое соответствует текущему событию перетаскивания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 Информирует объект NativeDragManager о том, что указанный целевой интерактивный объект может принять опускание, которое соответствует текущему событию перетаскивания.
	 
     <p>Данный метод может быть использован только при наличии на указанном целевом объекте обработчика <codeph>nativeDragDrop</codeph> для обработки, по крайней мере, одного формата данных в перетаскиваемом элементе и хотя бы одной допустимой операции.</p>
     
	 <p>Вызов данной функции возможет только в пределах следующих обработчиков событий: <codeph>nativeDragEnter</codeph> или <codeph>nativeDragOver</codeph>.</p>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.desktop:NativeDragManager:doDrag"><apiName>doDrag</apiName><shortdesc>
	 Начинает выполнять операцию перетаскивания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dragInitiator</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>Обычно это объект, с которого начинается жест перетаскивания. Получает события <codeph>nativeDragStart</codeph> и <codeph>nativeDragComplete</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipboard</apiItemName><apiOperationClassifier>flash.desktop:Clipboard</apiOperationClassifier><apiDesc>Контейнер объектов для перетаскиваемых данных.
	 
     </apiDesc></apiParam><apiParam><apiItemName>dragImage</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Во время жеста перетаскивания под курсором дополнительно отображается изображение приближения. При значении <codeph>null</codeph> изображение не отображается.
     
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Значение смещения верхнего левого угла изображения перетаскивания относительно активной точки курсора мыши. При отрицательных значениях изображение перемещается вверх и влево относительно активной точки курсора мыши. При значении <codeph>null</codeph> верхний левый угол изображения перетаскивания расположен в центре активной точки курсора мыши. 
     
     </apiDesc></apiParam><apiParam><apiItemName>allowedActions</apiItemName><apiOperationClassifier>flash.desktop:NativeDragOptions</apiOperationClassifier><apiData>null</apiData><apiDesc>Ограничивает набор операций перетаскивания, применимых для данного действия. При значении <codeph>null</codeph> ограничения отсутствуют.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Начинает выполнять операцию перетаскивания.
	 
	 <p>Для начала операции перетаскивания необходимо:</p>
	 <ol>
	 <li>Создать новый объект Clipboard.</li>
	 <li>Добавить данные для передачи, используя один или несколько форматов.</li>
	 <li>Дополнительно можно создать объект BitmapData, который будет выступать в роли изображения перетаскивания во время перетаскивания.</li>
	 <li>Дополнительно можно также создать объект NativeDragOptions для ограничения набора поддерживаемых операций при выполнении данного действия. (Если параметр <codeph>allowedActions</codeph> не задан, используется значение <codeph>null</codeph>, при котором ограничения отсутствуют.)</li>
     <li>Вызов <codeph>NativeDragManager.doDrag()</codeph>.</li>
	 </ol>
	 
     <p>При вызове этого метода инициирующий объект отправляет событие <codeph>nativeDragStart</codeph> в процессе перетаскивания события <codeph>nativeDragStart</codeph>, а когда пользователь отпускает кнопку мыши, завершая жест перетаскивания, событие <codeph>nativeDragComplete</codeph>. Обработчик события <codeph>nativeDragComplete</codeph> может осуществить проверку свойства <codeph>dropAction</codeph> данного события, чтобы определить, была ли начатая операция перетаскивания завершена успешно. Если <codeph>dropAction</codeph> является <codeph>NativeDragActions.NONE</codeph>, тогда перетаскивание элемента на пригодный целевой объект не произошло.</p>
	 
     <p>Вызов этого метода возможен только в пределах следующих обработчиков событий: <codeph>mouseDown</codeph> или <codeph>mouseMove</codeph>. (Если метод вызывает в ответ на событие <codeph>mouseMove</codeph>, то во время перемещения кнопка мыши все равно не должна быть зажата.)</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeDragActions"><linktext>flash.desktop.NativeDragActions</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:NativeDragManager:dragInitiator:get"><apiName>dragInitiator</apiName><shortdesc>
	Интерактивный объект, который инициировал операцию перетаскивания, передается вызванному методу NativeDragManager.doDrag().</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier></apiValueDef><apiDesc>
	Интерактивный объект, который инициировал операцию перетаскивания, передается вызванному методу <codeph>NativeDragManager.doDrag()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragManager:dropAction:get"><apiName>dropAction</apiName><shortdesc>
	Операция перетаскивания, определяемая целью опускания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Операция перетаскивания, определяемая целью опускания.
	 
     <p>Свойство <codeph>dropAction</codeph> настраивается в обработчике события <codeph>nativeDragDrop</codeph>. Если свойство <codeph>dropAction</codeph> не настроено до момента наступления события <codeph>nativeDragComplete</codeph>, тогда NativeDragManager выбирает для данного свойства первое значение из списка допустимых операций: копирование, перемещение, ссылка (именно в этой последовательности).</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.desktop.xml#NativeDragActions"><linktext>flash.desktop.NativeDragActions</linktext></link></related-links></apiValue><apiValue id="flash.desktop:NativeDragManager:isDragging:get"><apiName>isDragging</apiName><shortdesc>
	Сообщает, находится ли операция перетаскивания в процессе выполнения.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Сообщает, находится ли операция перетаскивания в процессе выполнения.
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:NativeDragOptions"><apiName>NativeDragOptions</apiName><shortdesc>
 Класс NativeDragOptions определяет константы для имен действий перетаскивания, разрешенных в операции перетаскивания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс NativeDragOptions определяет константы для имен действий перетаскивания, разрешенных в операции перетаскивания.
 
 <p>Операции перетаскивания являются частью механизма реагирования, который позволяет осуществлять обмен данными между целевыми объектами с помощью технологии перетаскивания. На уровне операционной системы данные операции являются всего лишь <i>указаниями</i>. Дальнейшая последовательность действий зависит от инициирующего и целевого объектов, участвующих в передачи данных.</p>
 
 <p>Инициирующий объект должен только разрешить выполнение поддерживаемых им операций. Например, инициирующий объект может разрешить выполнение операции <i>перемещения</i> только в том случае, если особенности внутренней архитектуры того объекта позволяют удалить исходные данные после завершения этой операции.</p>
 
 
 <p>Новый объект NativeDragOptions инициализируется с полным набором поддерживаемых операций (<codeph>true</codeph> – все операции разрешены).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeDragManager"><linktext>flash.desktop.NativeDragManager</linktext></link><link href="flash.events.xml#NativeDragEvent"><linktext>flash.events.NativeDragEvent</linktext></link></related-links><apiOperation id="flash.desktop:NativeDragOptions:toString"><apiName>toString</apiName><shortdesc>
	
	 Возвращает строковое представление заданного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строковое представление объекта.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Возвращает строковое представление заданного объекта.
	 
     <p platform="actionscript"><b>Примечание.</b> Методы класса Object динамически создаются в прототипе Object. Чтобы переопределить этот метод в подклассе Object, не используйте ключевое слово <codeph>override</codeph>. Например, в подклассе Object вместо переопределения базового класса применяется <codeph>function toString():String</codeph>.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.desktop:NativeDragOptions:allowCopy"><apiName>allowCopy</apiName><shortdesc>
	Цель опускания поддерживает копирование перетаскиваемых данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Цель опускания поддерживает копирование перетаскиваемых данных.
	
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragOptions:allowLink"><apiName>allowLink</apiName><shortdesc>
	 Цель опускания может создать ссылку на перетаскиваемые данные.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Цель опускания может создать ссылку на перетаскиваемые данные.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:NativeDragOptions:allowMove"><apiName>allowMove</apiName><shortdesc>
	Цель опускания поддерживает перемещение перетаскиваемых данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>true</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Цель опускания поддерживает перемещение перетаскиваемых данных.
	
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:DockIcon"><apiName>DockIcon</apiName><shortdesc>
	 Класс DockIcon отвечает за отображение значка панели в стиле MacOS X#xAE;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.desktop:InteractiveIcon</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс DockIcon отвечает за отображение значка панели в стиле MacOS X<sup>®</sup>.
	 
	 <p>Класс DockIcon можно использовать для изменения внешнего вида стандартных значков, например, для анимации значка или добавления информационных изображений. Вы также можете добавлять элементы в меню значка панели. Все добавленные элементы отображаются над стандартными элементами меню.</p>
	 
	 <p>Невозможно создать экземпляр класса DockIcon. Объект, отвечающий за значок панели операционной системы, находится в <codeph>NativeApplication.icon</codeph>.
	 </p>
	 
	 <p>Поддержка значков панелей присутствуют не во всех операционных системах. Выполните проверку <codeph>NativeApplication.supportsDockIcon</codeph>, чтобы узнать, поддерживает ли текущая ОС значки панелей. Есть такая поддержка существует, то свойство <codeph>NativeApplication.icon</codeph> является типом класса DockIcon. В противном случае тип <codeph>NativeApplication.icon</codeph> является другим подклассом класса InteractiveIcon (обычно SystemTrayIcon).</p>
	 
	 <p><b>Важно!</b> Попытка применить метод класса DockIcon к объекту <codeph>NativeApplication.icon</codeph> в ОС, где AIR не обеспечивает поддержку работы со значками панелей, приводит к ошибке.</p>
	 
	 </apiDesc><example conref="examples\DockIconExample.as"> Следующий пример загружает последовательность изображений и при запуске таймера с меню значка панели применяет анимацию к изображению этого значка. (Чтобы этот пример работал, необходимо предоставить набор изображений и изменить URL-адреса в массиве imageURLs.)
<codeblock>

 package {
    import flash.desktop.DockIcon;
    import flash.desktop.NativeApplication;
    import flash.display.Loader;
    import flash.display.NativeMenu;
    import flash.display.NativeMenuItem;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.TimerEvent;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class AnimatedDockIcon extends Sprite
    {
        private var imageURLs:Array =  ['gfx/frame01.png',
                                        'gfx/frame02.png',
                                        'gfx/frame03.png',
                                        'gfx/frame04.png'];
        
        private var images:Array = new Array();
        private var animTimer:Timer = new Timer(100);
                                        
        public function AnimatedDockIcon()
        {
            NativeApplication.nativeApplication.autoExit = false;
            
            addEventListener(Event.COMPLETE, loadImages);
            loadImages();
            
            animTimer.addEventListener(TimerEvent.TIMER,advanceFrame);
            addMenu();
            stage.nativeWindow.close();
        }
        
        private function addMenu():void{
            var menu:NativeMenu = new NativeMenu();
            var start:NativeMenuItem = menu.addItem(new NativeMenuItem("Start animation"));
            var stop:NativeMenuItem = menu.addItem(new NativeMenuItem("Stop animation"));
            start.addEventListener(Event.SELECT, startTimer);
            stop.addEventListener(Event.SELECT, stopTimer);
            
            var dockIcon:DockIcon =    NativeApplication.nativeApplication.icon as DockIcon;
            dockIcon.menu = menu;
        }
        
        private function startTimer(event:Event):void{
            animTimer.start();
        }

        private function stopTimer(event:Event):void{
            animTimer.stop();
        }

        private var currentFrame:int = 0;
        private function advanceFrame(event:Event):void{
            if(currentFrame &lt; images.length){
                currentFrame++;
            } else {
                currentFrame = 0;
            }
            NativeApplication.nativeApplication.icon.bitmaps = [images[currentFrame]];
        }
        

        private function loadImages(event:Event = null):void{
            if(event != null){
                images.push(event.target.content.bitmapData);
            }
            if(imageURLs.length > 0){
                var urlString:String = imageURLs.pop();
                var loader:Loader = new Loader();
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadImages, false, 0, true);
                loader.load(new URLRequest(urlString));
            } else {
                var complete:Event = new Event(Event.COMPLETE,false,false);
                dispatchEvent(complete);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsDockIcon"><linktext>flash.desktop.NativeApplication.supportsDockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link></related-links><apiOperation id="flash.desktop:DockIcon:bounce"><apiName>bounce</apiName><shortdesc>
		 Уведомляет пользователя о событии, требующем его внимания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiDefaultValue>NotificationType.Informational
		 
		 </apiDefaultValue><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>informational</apiData><apiDesc>Срочность колебания панели.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Уведомляет пользователя о событии, требующем его внимания.
		 
		 <p>Вызов этого метода приводит к колебанию значка панели только тогда, когда приложение работает в фоновом режиме. Если значением <codeph>priority</codeph> является <codeph>NotificationType.Informational</codeph>, то значок колеблется только один раз. Если значением <codeph>priority</codeph> является <codeph>NotificationType.Critical</codeph>, то значок колеблется до тех пор, пока приложение не станет активным.</p>
		 
		 </apiDesc><example conref="examples\DockIcon.bounce.1.as"> Следующий пример вызывает колебание значка панели до тех пор, пока пользователь не активирует приложение:
<codeblock>
 import flash.display.DockIcon;
 import flash.display.NotificationType;
 import flash.desktop.NativeApplication;

 if(NativeApplication.supportsDockIcon){
     var dockIcon:DockIcon = NativeApplication.nativeApplication.icon As DockIcon;
     dockIcon.bounce(NotificationType.CRITICAL);
 }
 
</codeblock></example></apiOperationDetail><related-links><link href="flash.desktop.xml#NotificationType"><linktext>flash.desktop.NotificationType</linktext></link><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiOperation><apiValue id="flash.desktop:DockIcon:bitmaps:set"><apiName>bitmaps</apiName><shortdesc> 
		
		  
	 Изображение значка в массиве объектов BitmapData различных размеров.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc> 
		
		  
	 Изображение значка в массиве объектов BitmapData различных размеров.
	   
	 <p>При отображении значка в контексте конкретной ОС из массива выбирается изображение, размер которого в максимальной степени подходит под текущий размер экрана (при необходимости масштабируется). Обычные размеры включают: 16x16, 32x32, 48x48 и 128x128. (В ближайшем будущем в некоторых ОС могут использоваться значки размером 512x512 пикселей.)</p>
	 
	 <p>В некоторых контекстах, если свойству <codeph>bitmaps</codeph> ничего присвоено не было, может использоваться значок ОС по умолчанию. В остальных контекстах значок не отображается.</p>
	 
	 <p>Чтобы изменить вид значка, присвойте свойству <codeph>bitmaps</codeph> массив объектов BitmapData.</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>Прямая модификация массива <codeph>bitmaps</codeph> ни к чему не приведет.</p>
	 
	 <p>Чтобы убрать изображение значка, присвойте свойству <codeph>bitmaps</codeph> пустой массив.</p>
	 
	 <p>
	 <b>Примечание.</b> Загружайте файлы изображений для значков в формате PNG, так как этот формат обеспечивает наилучшее альфа-смешивание. Формат GIF поддерживает только включение или отключение прозрачности, но не смешивание. Формат JPG не поддерживает прозрачность совсем.  
	 </p>
	  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:DockIcon:height:get"><apiName>height</apiName><shortdesc> 
		
		 Текущее значение высоты значка в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Текущее значение высоты значка в пикселях.
		 
		 <p>Некоторые контексты значков поддерживают динамические размеры. Свойство <codeph>height</codeph> обозначает высоту значка, выбранного из массива <codeph>bitmaps</codeph> для данного контекста. Если в ОС было использовано масштабирование, то текущее значение высоты может отличаться.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.desktop:DockIcon:menu:set"><apiName>menu</apiName><shortdesc>
		 Системное меню данного значка панели.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Системное меню данного значка панели.
		 
		 <p>Все элементы меню отображаются над стандартными элементами. Стандартные элементы невозможно изменить или удалить.</p>
		 
		 </apiDesc><example conref="examples\DockIcon.menu.1.as"> Следующий пример добавляет элемент в меню значка панели:
<codeblock>
 import flash.desktop.NativeApplication;
 import flash.events.Event;
 
private function createDockIconMenu():void{
    if(NativeApplication.supportsDockIcon){                
        var dockIcon:DockIcon = NativeApplication.nativeApplication.icon as DockIcon;
        
        var dockMenu:NativeMenu = new NativeMenu();
        var command:NativeMenuItem = dockMenu.addItem(new NativeMenuItem("Command"));
        command.addEventListener(Event.SELECT, onCommand);
        
        dockIcon.menu = dockMenu;
    }
}

 private function onCommand(event:Event):void{
     //do command...
 }
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.desktop:DockIcon:width:get"><apiName>width</apiName><shortdesc> 
		
		 Текущее значение ширины значка в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
		
		 Текущее значение ширины значка в пикселях. 
		 
		 <p>Некоторые контексты значков поддерживают динамические размеры. Свойство <codeph>width</codeph> обозначает ширину значка, выбранного из массива <codeph>bitmaps</codeph> для данного контекста. Если в ОС было использовано масштабирование, то текущее значение ширины может отличаться.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.desktop:Icon"><apiName>Icon</apiName><shortdesc> 
	 В классе Icon содержится значок операционной системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc> 
	 В классе Icon содержится значок операционной системы. 
	 
	 <p>У объекта Icon есть единственное свойство <codeph>bitmaps</codeph>, которое представляет собой массив объектов BitmapData. Одновременно может отображаться только один значок. ОС выбирает изображение, которое в наибольшей степени соответствует текущему размеру экрана, масштабируя его при необходимости.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#File/icon"><linktext>flash.filesystem.File.icon</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiValue id="flash.desktop:Icon:bitmaps:set"><apiName>bitmaps</apiName><shortdesc> 
	 Изображение значка в массиве объектов BitmapData различных размеров.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc> 
	 Изображение значка в массиве объектов BitmapData различных размеров.
	   
	 <p>При отображении значка в контексте конкретной ОС из массива выбирается изображение, размер которого в максимальной степени подходит под текущий размер экрана (при необходимости масштабируется). Обычные размеры включают: 16x16, 32x32, 48x48 и 128x128. (В ближайшем будущем в некоторых ОС могут использоваться значки размером 512x512 пикселей.)</p>
	 
	 <p>В некоторых контекстах, если свойству <codeph>bitmaps</codeph> ничего присвоено не было, может использоваться значок ОС по умолчанию. В остальных контекстах значок не отображается.</p>
	 
	 <p>Чтобы изменить вид значка, присвойте свойству <codeph>bitmaps</codeph> массив объектов BitmapData.</p>
	 
	 <codeblock>
	 icon.bitmaps = new Array(icon16x16.bitmapData, icon128x128.bitmapData);
	 </codeblock>
	  
	 <p>Прямая модификация массива <codeph>bitmaps</codeph> ни к чему не приведет.</p>
	 
	 <p>Чтобы убрать изображение значка, присвойте свойству <codeph>bitmaps</codeph> пустой массив.</p>
	 
	 <p>
	 <b>Примечание.</b> Загружайте файлы изображений для значков в формате PNG, так как этот формат обеспечивает наилучшее альфа-смешивание. Формат GIF поддерживает только включение или отключение прозрачности, но не смешивание. Формат JPG не поддерживает прозрачность совсем.  
	 </p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.filesystem.xml#File/icon"><linktext>flash.filesystem.File.icon</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue></apiClassifier></apiPackage>