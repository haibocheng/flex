<?xml version="1.0"?>
<apiPackage id="flash.display"><apiName>flash.display</apiName><apiDetail/><apiClassifier id="flash.display:FrameLabel"><apiName>FrameLabel</apiName><shortdesc>
	
	Объект FrameLabel содержит свойства, задающие номер рамки и соответствующее имя подписи.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	
	Объект FrameLabel содержит свойства, задающие номер рамки и соответствующее имя подписи. Класс Scene включает свойство <codeph>labels</codeph>, которое является массивом объектов FrameLabel монтажного кадра. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Scene/labels"><linktext>Scene.labels</linktext></link><link href="flash.display.xml#MovieClip/currentLabel"><linktext>MovieClip.currentLabel</linktext></link><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:FrameLabel:frame:get"><apiName>frame</apiName><shortdesc>
		Номер рамки, содержащей подпись.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		Номер рамки, содержащей подпись.
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FrameLabel:name:get"><apiName>name</apiName><shortdesc>
		Имя подписи.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Имя подписи.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
 Класс InteractiveObject является абстрактным базовым классом для всех экранных объектов, с которыми пользователь может взаимодействовать с помощью мыши и клавиатуры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс InteractiveObject является абстрактным базовым классом для всех экранных объектов, с которыми пользователь может взаимодействовать с помощью мыши и клавиатуры.
 
 <p>Нельзя создать экземпляры класса InteractiveObject напрямую. Вызов конструктора <codeph>new InteractiveObject()</codeph> выдает исключение <codeph>ArgumentError</codeph>.</p>
 
 <p>Сам класс InteractiveObject не содержит API-интерфейсов для визуализации содержимого на экране По этой причине, если требуется создать пользовательский подкласс класса InteractiveObject, нужно расширить один из его подклассов, в которых есть API-интерфейс для визуализации содержимого на экране, такие как классы Sprite, SimpleButton, TextField и MovieClip.</p>
 
 </apiDesc><example conref="examples\InteractiveObjectExample.as"> В следующем примере используется класс <codeph>InteractiveObjectExample</codeph>, который в свою очередь использует класс <codeph>ChildSprite</codeph> для рисования прямоугольника, а затем выполнения манипуляций с ним на базе различных событий мыши. Это можно сделать, выполнив следующие действия.
 <ol>
    <li>В конструкторе <codeph>InteractiveObjectExample</codeph> создается новый объект ChildSprite тип Sprite с именем <codeph>child</codeph>, который вызывает метод конструктора ChildSprite для рисования фигуры и добавляет для нее события мыши (как описывается далее). Объект <codeph>child</codeph> добавляется в начало списка отображения в точку с координатами <i>x = 0, y = 0</i>.  </li>
 
    <li>В классе <codeph>ChildSprite</codeph> объявите свойства <codeph>size</codeph> и <codeph>overSize</codeph>, которые будут использоваться позже в методе <codeph>draw()</codeph> и методах MouseEvent.</li>
 
     <li>Объявите свойства, задающие оранжевый цвет фона, темно-желтый цвет при наведении мыши и голубой при нажатии мыши.</li>
 
    <li>В конструкторе <codeph>ChildSprite</codeph> рисуется оранжевый квадрат с помощью методов класса Graphics и метода <codeph>draw()</codeph>.</li>
 
    <li>Конструктор добавляет четыре метода прослушивателя событий MouseEvent:
 
     <ul>
        <li><codeph>mouseOverHandler</codeph>: перерисовывает квадрат большего размера (60 на 60 пикселей) темно-желтого цвета в точке с исходными координатами.</li>
        <li><codeph>mouseOutHandler</codeph>: возвращает квадрату исходный размер и цвет.</li>
        <li><codeph>mouseDownHandler</codeph>: перерисовывает квадрат большего размера (60 на 60 пикселей) голубого цвета в точке с исходными координатами.</li>
        <li><codeph>mouseUpHandler</codeph>: то же, что <codeph>mouseOverHandler</codeph>.</li>
     </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class InteractiveObjectExample extends Sprite {

        public function InteractiveObjectExample() {
            var child:Sprite = new ChildSprite();
            addChild(child);
        }
    }
}

import flash.display.Sprite;
import flash.events.MouseEvent;

class ChildSprite extends Sprite {
    private var size:uint = 50;
    private var overSize:uint = 60;
    private var backgroundColor:uint = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;

    public function ChildSprite() {
        buttonMode = true;
        draw(size, size, backgroundColor);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
        addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
    }

    private function draw(w:uint, h:uint, bgColor:uint):void {
        graphics.clear();
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }

    public function mouseOverHandler(event:MouseEvent):void {
        trace("mouseOverHandler");
        draw(overSize, overSize, overColor);
    }

    public function mouseOutHandler(event:MouseEvent):void {
        trace("mouseOutHandler");
        draw(size, size, backgroundColor);
    }

    public function mouseDownHandler(event:MouseEvent):void {
        trace("mouseDownHandler");
        draw(overSize, overSize, downColor);
    }

    public function mouseUpHandler(event:MouseEvent):void {
        trace("mouseUpHandler");
        draw(overSize, overSize, overColor);
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.display:InteractiveObject_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Передается, если пользователь вводит один или несколько символов текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Передается, если пользователь вводит один или несколько символов текста. Это событие может генерироваться различными методами ввода текста, включая ввод со стандартной клавиатуры, редакторы ввода текста (IME), системы распознавания голоса и речи и просто вставкой обычного текста без информации о форматировании или стилях.
 </apiDesc><example conref="examples\TextField_textInput.as"/></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CONTEXT_MENU_contextMenu"><apiName>contextMenu</apiName><shortdesc>
 Отправляется, когда жест пользователя вызывает контекстное меню, связанное с данным интерактивным объектом в приложении AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CONTEXT_MENU</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда жест пользователя вызывает контекстное меню, связанное с данным интерактивным объектом в приложении AIR.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>contextMenu</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE_nativeDragComplete"><apiName>nativeDragComplete</apiName><shortdesc>
 Отправляется инициатором перетаскивания InteractiveObject, когда пользователь завершает жест перетаскивания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется инициатором перетаскивания InteractiveObject, когда пользователь завершает жест перетаскивания.
 
 <p>Свойство dropAction события указывает действие, заданное целевым объектом перетаскивания; значение none (<codeph>DragActions.NONE</codeph>) указывает на то, что «сброс» перетаскиваемых данных был отменен или не был принят.</p>
 
 <p>С помощью обработчика событий <codeph>nativeDragComplete</codeph> можно обновить состояние инициирующего объекта отображения, например, удалив элемент из списка (при операции перетаскивания move) или изменив визуальные свойства.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE_nativeDragUpdate"><apiName>nativeDragUpdate</apiName><shortdesc>
 Отправляется во время операции перетаскивания объектом InteractiveObject, заданным в качестве инициатора перетаскивания в вызове метода DragManager.doDrag().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется во время операции перетаскивания объектом InteractiveObject, заданным в качестве инициатора перетаскивания в вызове метода DragManager.doDrag().
 
 <p>События <codeph>nativeDragUpdate</codeph> не отправляются в Linux.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_START_nativeDragStart"><apiName>nativeDragStart</apiName><shortdesc>
 Отправляется в начале операции перетаскивания объектом InteractiveObject, заданным в качестве инициатора перетаскивания в вызове метода DragManager.doDrag().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_START</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется в начале операции перетаскивания объектом InteractiveObject, заданным в качестве инициатора перетаскивания в вызове метода DragManager.doDrag().
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_EXIT_nativeDragExit"><apiName>nativeDragExit</apiName><shortdesc>
 Отправляется объектом InteractiveObject, когда жест перетаскивания выходит за границы этого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_EXIT</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется объектом InteractiveObject, когда жест перетаскивания выходит за границы этого объекта.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_DROP_nativeDragDrop"><apiName>nativeDragDrop</apiName><shortdesc>
 Отправляется целевым объектом InteractiveObject при принятии перетаскиваемого объекта вызовом метода DragManager.acceptDragDrop().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_DROP</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется целевым объектом InteractiveObject при принятии перетаскиваемого объекта вызовом метода DragManager.acceptDragDrop().
 
 <p>Доступ к перенесенным данным можно получить с помощью свойства <codeph>clipboard</codeph> объекта события.</p>
 
 <p>Обработчик этого события должен установить свойство <codeph>DragManager.dropAction</codeph>, чтобы сообщить объекту-инициатору о том, какое действие перетаскивания было выполнено. Если значение не задано, DragManager выберет в списке допустимых действий значение по умолчанию.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_OVER_nativeDragOver"><apiName>nativeDragOver</apiName><shortdesc>
 Постоянно отправляется объектом InteractiveObject, пока жест перетаскивания остается в пределах его границ.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_OVER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Постоянно отправляется объектом InteractiveObject, пока жест перетаскивания остается в пределах его границ.
 
 <p>События <codeph>nativeDragOver</codeph> отправляются при каждом движении мыши. В Windows и Mac эти события также отправляются при коротком интервале таймера даже при отсутствии движения мыши.</p>
 
 <p>Чтобы экранный объект мог стать целевым объектом перетаскивания, необходимо обрабатывать либо события <codeph>nativeDragOver</codeph>, либо события <codeph>nativeDragEnter</codeph>.</p> 
 
 <p>Чтобы определить, может ли отправляющий объект принять перетаскиваемые данные, проверьте приемлемость данных в свойстве <codeph>clipboard</codeph> объекта события, и допустимые действия перетаскивания в свойстве <codeph>allowedActions</codeph>.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_ENTER_nativeDragEnter"><apiName>nativeDragEnter</apiName><shortdesc>
 Отправляется объектом InteractiveObject, когда жест перетаскивания входит в его границы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_ENTER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется объектом InteractiveObject, когда жест перетаскивания входит в его границы.
 
 <p>Чтобы экранный объект мог стать целевым объектом перетаскивания, необходимо обрабатывать либо события <codeph>nativeDragEnter</codeph>, либо события <codeph>nativeDragOver</codeph>.</p>
 
 <p>Чтобы определить, может ли отправляющий объект принять перетаскиваемые данные, проверьте приемлемость данных в свойстве <codeph>clipboard</codeph> объекта события, и допустимые действия перетаскивания в свойстве <codeph>allowedActions</codeph>.</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_INDEX_CHANGE_tabIndexChange"><apiName>tabIndexChange</apiName><shortdesc>
 Отправляется, когда изменяется значение свойства tabIndex объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_INDEX_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда изменяется значение свойства <codeph>tabIndex</codeph> объекта. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_ENABLED_CHANGE_tabEnabledChange"><apiName>tabEnabledChange</apiName><shortdesc>
 Отправляется при изменении флага tabEnabled объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_ENABLED_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при изменении флага <codeph>tabEnabled</codeph> объекта. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_CHILDREN_CHANGE_tabChildrenChange"><apiName>tabChildrenChange</apiName><shortdesc>
 Отправляется, когда изменяется значение свойства tabChildren объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_CHILDREN_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда изменяется значение свойства <codeph>tabChildren</codeph> объекта. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_UP_keyUp"><apiName>keyUp</apiName><shortdesc>
 Отправляется, когда пользователь отпускает клавишу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_UP</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь отпускает клавишу. Соответствие клавиш и конкретных символов варьируется в зависимости от устройства и операционной системы. Этот тип событий создается после возникновения такого соответствия, но перед его обработкой редактором метода ввода IME. Редакторы IME используются для ввода таких символов, как китайские идеограммы, для чего малопригодна стандартная клавиатура QWERTY. Это событие происходит после события <codeph>keyDown</codeph> и имеет следующие характеристики:
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_DOWN_keyDown"><apiName>keyDown</apiName><shortdesc>
 Отправляется, когда пользователь нажимает клавишу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_DOWN</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает клавишу. Соответствие клавиш и конкретных символов варьируется в зависимости от устройства и операционной системы. Этот тип событий создается после возникновения такого соответствия, но перед его обработкой редактором метода ввода IME. Редакторы IME используются для ввода таких символов, как китайские идеограммы, для чего малопригодна стандартная клавиатура QWERTY. Это событие происходит перед событием <codeph>keyUp</codeph>.
 
 <p>Отмена этого события в программе AIR предотвращает ввод этого символа в текстовое поле.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
 Отправляется, когда пользователь отпускает кнопку указывающего устройства над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь отпускает кнопку указывающего устройства над экземпляром InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
 Отправляется, когда пользователь нажимает кнопку указывающего устройства над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает кнопку указывающего устройства над экземпляром InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
 Отправляется, когда пользователь нажимает и отпускает правую кнопку указывающего устройства над одним и тем же объектом InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает и отпускает правую кнопку указывающего устройства над одним и тем же объектом InteractiveObject. Чтобы произошло событие <codeph>rightClick</codeph>, оно должно следовать за данной последовательностью событий, перечисленных в порядке появления: событие <codeph>rightMouseDown</codeph>, затем событие <codeph>rightMouseUp</codeph>. Оба эти события должны иметь ту же цель, иначе событие <codeph>rightClick</codeph> не произойдет. Между событиями <codeph>rightMouseDown</codeph> или <codeph>rightMouseUp</codeph> может произойти любое количество других событий мыши; событие <codeph>rightClick</codeph> все равно происходит. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_UP_middleMouseUp"><apiName>middleMouseUp</apiName><shortdesc>
 Отправляется, когда пользователь отпускает кнопку указывающего устройства над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь отпускает кнопку указывающего устройства над экземпляром InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_DOWN_middleMouseDown"><apiName>middleMouseDown</apiName><shortdesc>
 Отправляется, когда пользователь нажимает среднюю кнопку указывающего устройства над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает среднюю кнопку указывающего устройства над экземпляром InteractiveObject. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_CLICK_middleClick"><apiName>middleClick</apiName><shortdesc>
 Отправляется, когда пользователь нажимает и отпускает среднюю кнопку указывающего устройства над одним и тем же объектом InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает и отпускает среднюю кнопку указывающего устройства над одним и тем же объектом InteractiveObject. Чтобы произошло событие <codeph>middleClick</codeph>, оно должно следовать за данной последовательностью событий, перечисленных в порядке появления: событие <codeph>middleMouseDown</codeph>, затем событие <codeph>middleMouseUp</codeph>. Оба эти события должны иметь ту же цель, иначе событие <codeph>middleClick</codeph> не произойдет. Между событиями <codeph>middleMouseDown</codeph> или <codeph>middleMouseUp</codeph> может произойти любое количество других событий мыши; событие <codeph>middleClick</codeph> все равно происходит. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OVER_rollOver"><apiName>rollOver</apiName><shortdesc>
 Отправляется, когда пользователь наводит указывающее устройство на экземпляр InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь наводит указывающее устройство на экземпляр InteractiveObject. Цель этого события – объект, находящийся под указателем, или вышестоящий объект. <codeph>relatedObject</codeph> – это объект, который находился под указателем до этого. События <codeph>rollOver</codeph> отправляются последовательно вниз по нисходящей цепочке, начиная с вышестоящего элемента, не являющегося корнем или предшественником объекта <codeph>relatedObject</codeph>, и заканчивая самим объектом.
 <p>Цель события <codeph>rollOver</codeph> – упростить кодировку поведений отката для контейнеров экранных объектов с нижестоящими элементами. Когда мышь переходит в область экранного объекта или его нижестоящих элементов от объекта, не являющегося нижестоящим по отношению к данному объекту, экранный объект отправляет событие <codeph>rollOver</codeph>. Это поведение отличается от события <codeph>mouseOver</codeph>, которое отправляется каждый раз при переходе мыши в область нижестоящего объекта контейнера экранных объектов, даже если она переместилась туда с другого нижестоящего объекта контейнера. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OUT_rollOut"><apiName>rollOut</apiName><shortdesc>
 Отправляется, когда пользователь перемещает указатель от экземпляра InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь перемещает указатель от экземпляра InteractiveObject. Цель этого события – объект, который раньше находился под указателем, или его вышестоящий объект. <codeph>relatedObject</codeph> – это объект, на который перемещен указатель. События <codeph>rollOut</codeph> отправляются последовательно по восходящей от объекта, начиная с объекта и заканчивая самым вышестоящим элементом, не являющимся корнем или предшественником для объекта <codeph>relatedObject</codeph>. 
 <p>Цель события <codeph>rollOut</codeph> – упростить кодировку событий наведения для контейнеров отображаемых объектов с нижестоящими элементами. При выходе курсора мыши из области объекта отображения или области его нижестоящих элементов для перехода к объекту, не являющемуся одним из его нижестоящих элементов, объект отображения отправляет событие <codeph>rollOut</codeph>. Это поведение отличается от поведения события <codeph>mouseOut</codeph>, которое отправляется каждый раз при перемещении курсора мыши из области нижестоящего объекта контейнера объектов отображения, даже если он находится на другом нижестоящем объекте контейнера объектов отображения.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_WHEEL_mouseWheel"><apiName>mouseWheel</apiName><shortdesc>
 Отправляется при прокрутке колеса мыши над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_WHEEL</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при прокрутке колеса мыши над экземпляром InteractiveObject. Если цель – текстовое поле, то действие по умолчанию – прокрутка текста. Доступно только в операционных системах Microsoft Windows.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 Отправляется, когда пользователь отпускает кнопку указывающего устройства над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь отпускает кнопку указывающего устройства над экземпляром InteractiveObject. Если целью является экземпляр SimpleButton, объект отображает экранный объект <codeph>upState</codeph>. Если целью является выбираемое текстовое поле, то действие по умолчанию – завершение выбора текстового поля.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OVER_mouseOver"><apiName>mouseOver</apiName><shortdesc>
 Отправляется, когда пользователь наводит указывающее устройство на экземпляр InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь наводит указывающее устройство на экземпляр InteractiveObject. <codeph>relatedObject</codeph> – это объект, на который до этого был наведен указатель. Если цель – экземпляр SimpleButton, объект по умолчанию отображает объект отображения <codeph>overState</codeph> или <codeph>upState</codeph> в зависимости от того, нажата ли кнопка мыши.
 <p>Событие <codeph>mouseOver</codeph> отправляется каждый раз при перемещении курсора мыши в область нижестоящего объекта контейнера объектов отображения, даже при переходе с другого нижестоящего объекта контейнера объектов отображения. Это событие имеет иную цель, в отличие от события <codeph>rollOver</codeph>, которое служит для упрощения кодировки поведений отката для контейнеров объектов отображения с нижестоящими элементами. При перемещении курсора мыши в область объекта отображения или его нижестоящих элементов от объекта, не являющегося его нижестоящим объектом, объект отображения отправляет событие <codeph>rollOver</codeph>. События <codeph>rollOver</codeph> отправляются последовательно вниз по вышестоящей цепочке объекта, начиная с элемента самого высокого уровня, не являющегося корневым элементом или предшествующим элементом <codeph>relatedObject</codeph>, и заканчивая самим объектом.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OUT_mouseOut"><apiName>mouseOut</apiName><shortdesc>
 Отправляется, когда пользователь перемещает указатель с экземпляра InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь перемещает указатель с экземпляра InteractiveObject. Целью события является объект, на который до этого был наведен указатель. <codeph>relatedObject</codeph> – это объект, на который перемещен указатель. Если целью является экземпляр SimpleButton, кнопка по умолчанию отображает экранный объект <codeph>upState</codeph>.
 <p>Событие <codeph>mouseOut</codeph> отправляется каждый раз при перемещении курсора мыши из области нижестоящего объекта контейнера экранных объектов, даже если был выполнен переход к другому нижестоящему объекту. Это событие имеет иную цель, в отличие от события <codeph>rollOut</codeph>, которое служит для упрощения кодировки поведений ролловера для контейнеров экранных объектов с нижестоящими элементами. Когда мышь покидает область экранного объекта или его нижестоящих элементов и переходит к объекту, не являющемуся его нижестоящим элементом, экранный объект отправляет событие <codeph>rollOut</codeph>. События <codeph>rollOut</codeph> отправляются последовательно вверх по восходящей цепочке, начиная с объекта и заканчивая объектом верхнего уровня, который не является корнем или предшественником объекта <codeph>relatedObject</codeph>.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_MOVE_mouseMove"><apiName>mouseMove</apiName><shortdesc>
 Отправляется, когда пользователь перемещает указывающее устройство в момент, когда курсор находится над объектом InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_MOVE</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь перемещает указывающее устройство в момент, когда курсор находится над объектом InteractiveObject. Если цель – текстовое поле, которое выбирает пользователь, действие по умолчанию – обновление выбора.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 Отправляется, когда пользователь нажимает кнопку указывающего устройства над экземпляром InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает кнопку указывающего устройства над экземпляром InteractiveObject. Если цель – экземпляр SimpleButton, кнопка по умолчанию отображает экранный объект <codeph>downState</codeph>. Если цель – выбираемое текстовое поле, то действие по умолчанию – начало выбора текстового поля.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.DOUBLE_CLICK_doubleClick"><apiName>doubleClick</apiName><shortdesc>
 Отправляется, когда пользователь дважды нажимает и отпускает главную кнопку на указывающем устройстве над одним и тем же объектом InteractiveObject, а флаг doubleClickEnabled для этого объекта имеет значение true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.DOUBLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь дважды нажимает и отпускает главную кнопку на указывающем устройстве над одним и тем же объектом <codeph>InteractiveObject</codeph>, а флаг <codeph>doubleClickEnabled</codeph> для этого объекта имеет значение true. Чтобы произошло событие <codeph>doubleClick</codeph>, оно должно следовать непосредственно за этими последовательностями событий: <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>click</codeph>, <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>. У всех этих событий должна быть та же цель, что и у события <codeph>doubleClick</codeph>. Второй щелчок, представленный событиями <codeph>mouseDown</codeph> и <codeph>mouseUp</codeph>, должен произойти в пределах заданного периода времени после события <codeph>click</codeph>. Допустимая продолжительность этого периода варьируется в зависимости от операционной системы и может настраиваться пользователем. Если цель – выбираемое текстовое поле, действие по умолчанию – выделение слова, находящегося под указателем. Если у целевого объекта InteractiveObject флаг <codeph>doubleClickEnabled</codeph> имеет значение <codeph>true</codeph>, он получает два события <codeph>click</codeph>.  
 
 <p>По умолчанию свойство <codeph>doubleClickEnabled</codeph> имеет значение <codeph>false</codeph>.  </p>
 
 <p>Выделение текста двойным щелчком как поведение объекта TextField не связано с событием <codeph>doubleClick</codeph>. Используйте <codeph>TextField.doubleClickEnabled</codeph> для управления выделением TextField.</p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/doubleClickEnabled"><linktext>doubleClickEnabled</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 Отправляется, когда пользователь нажимает и отпускает главную кнопку на указывающем устройстве над одним и тем же объектом InteractiveObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь нажимает и отпускает главную кнопку на указывающем устройстве над одним и тем же объектом InteractiveObject. Чтобы произошло событие «click», оно должно следовать за данной последовательностью событий, перечисленных в порядке появления: событие mouseDown, а затем mouseUp. Оба эти события должны иметь ту же цель, иначе событие <codeph>click</codeph> не произойдет. Между событиями <codeph>mouseDown</codeph> или <codeph>mouseUp</codeph> может произойти любое количество других событий мыши; событие <codeph>click</codeph> все равно происходит. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.MOUSE_FOCUS_CHANGE_mouseFocusChange"><apiName>mouseFocusChange</apiName><shortdesc>
 Отправляется, когда пользователь пытается изменить фокус с помощью указывающего устройства.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.MOUSE_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь пытается изменить фокус с помощью указывающего устройства. По умолчанию это событие изменяет фокус и отправляет соответствующие события <codeph>focusIn</codeph> и <codeph>focusOut</codeph>. 
 
 <p>Это событие отправляется объекту, который в данный момент находится в фокусе. Связанным объектом этого события является экземпляр InteractiveObject, попадающий в фокус, если не изменить поведение по умолчанию. Чтобы предотвратить изменение фокуса, можно вызвать метод <codeph>preventDefault()</codeph> в прослушивателе событий, соответствующим образом зарегистрированном для целевого объекта. Свойство <codeph>shiftKey</codeph> не используется. Фокус меняется, и события <codeph>focusIn</codeph> и <codeph>focusOut</codeph> отправляются по умолчанию.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.KEY_FOCUS_CHANGE_keyFocusChange"><apiName>keyFocusChange</apiName><shortdesc>
 Отправляется, когда пользователь пытается изменить фокус с помощью клавиатуры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.KEY_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь пытается изменить фокус с помощью клавиатуры. По умолчанию это событие изменяет фокус и отправляет соответствующие события <codeph>focusIn</codeph> и <codeph>focusOut</codeph>.
 
 <p>Это событие отправляется объекту, который в данный момент находится в фокусе. Связанным объектом этого события является экземпляр InteractiveObject, попадающий в фокус, если не изменить поведение по умолчанию. Чтобы предотвратить изменение фокуса, можно вызвать метод <codeph>preventDefault()</codeph> в прослушивателе событий, соответствующим образом зарегистрированном для целевого объекта. Фокус меняется, и события <codeph>focusIn</codeph> и <codeph>focusOut</codeph> отправляются по умолчанию.</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_OUT_focusOut"><apiName>focusOut</apiName><shortdesc>
 Отправляется после того, как экранный объект теряет фокус.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_OUT</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется <i>после</i> того, как экранный объект теряет фокус. Это происходит, когда пользователь выделяет другой объект с помощью указателя или клавиатуры. Объект, теряющий фокус, называется целевым объектом события, а соответствующий экземпляр InteractiveObject, получающий фокус, называется связанным объектом. Ссылка на связанный объект сохраняется в свойстве <codeph>relatedObject</codeph> целевого объекта. Свойство <codeph>shiftKey</codeph> не используется. Это событие предшествует отправке события <codeph>focusIn</codeph> связанным объектом.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_IN_focusIn"><apiName>focusIn</apiName><shortdesc>
 Отправляется после того, как экранный объект перемещается в фокус.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_IN</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется <i>после</i> того, как экранный объект перемещается в фокус. Это происходит, когда пользователь выделяет объект с помощью указателя или клавиатуры. Получатель фокуса называется целевым объектом события, а соответствующий экземпляр InteractiveObject, потерявший фокус в результате данного изменения, называется связанным объектом. Ссылка на связанный объект сохраняется в свойстве <codeph>relatedObject</codeph> получающего объекта. Свойство <codeph>shiftKey</codeph> не используется. Это событие следует после отправки события <codeph>focusOut</codeph> предыдущего объекта.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.SELECT_ALL_selectAll"><apiName>selectAll</apiName><shortdesc>
 Отправляется, когда пользователь активирует комбинацию клавиш ускорения, используемую на данной платформе для операции «Выделить все», или выбирает команду «Выделить все» из контекстного меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT_ALL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь активирует комбинацию клавиш ускорения, используемую на данной платформе для операции «Выделить все», или выбирает команду «Выделить все» из контекстного меню. Это событие отправляется объекту, который в данный момент находится в фокусе. Если объект, находящийся в фокусе, является экземпляром TextField, действием по умолчанию этого события является выделение всего содержимого текстового поля. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.PASTE_paste"><apiName>paste</apiName><shortdesc>
 Отправляется, когда пользователь активирует комбинацию клавиш ускорения, используемую на данной платформе для операции «Вставить», или выбирает команду «Вставить» из контекстного меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.PASTE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь активирует комбинацию клавиш ускорения, используемую на данной платформе для операции «Вставить», или выбирает команду «Вставить» из контекстного меню. Это событие отправляется объекту, который в данный момент находится в фокусе. Если объект, находящийся в фокусе, является экземпляром TextField, по умолчанию содержимое буфера обмена вставляется в текстовое поле в текущей точке вставки, заменяя выделенный текст в поле. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CUT_cut"><apiName>cut</apiName><shortdesc>
 Отправляется, когда пользователь активирует комбинацию клавиш ускорения, используемую на данной платформе для операции «Вырезать», или выбирает команду «Вырезать» из контекстного меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CUT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь активирует комбинацию клавиш быстрого вызова, используемую на данной платформе для операции «Вырезать», или выбирает команду «Вырезать» из контекстного меню. Это событие отправляется объекту, который в данный момент находится в фокусе. Если объектом, находящимся в фокусе, является экземпляр TextField, событием по умолчанию является вырезание и сохранение в буфере обмена выделенного в данный момент текстового поля. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.COPY_copy"><apiName>copy</apiName><shortdesc>
 Отправляется, когда пользователь активирует комбинацию клавиш быстрого вызова, используемую на данной платформе для операции «Копировать», или выбирает команду «Копировать» из контекстного меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COPY</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь активирует комбинацию клавиш быстрого вызова, используемую на данной платформе для операции «Копировать», или выбирает команду «Копировать» из контекстного меню. Это событие отправляется объекту, который в данный момент находится в фокусе. Если объектом, находящимся в фокусе, является экземпляр TextField, событием по умолчанию является копирование в буфер обмена выделенного в данный момент текстового поля. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CLEAR_clear"><apiName>clear</apiName><shortdesc>
 Отправляется, когда пользователь выбирает команду «Удалить» из контекстного меню текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLEAR</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь выбирает команду «Удалить» из контекстного меню текста. Это событие отправляется объекту, который в данный момент находится в фокусе. Если объектом, находящимся в фокусе, является экземпляр TextField, событием по умолчанию является удаление выделенного в данный момент текстового поля. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:InteractiveObject:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
	При вызове конструктора new InteractiveObject() выдается исключение ArgumentError.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	При вызове конструктора <codeph>new InteractiveObject()</codeph> выдается исключение <codeph>ArgumentError</codeph>. Однако можно вызывать конструкторы для следующих подклассов InteractiveObject:
	
	<ul>
	
		<li><codeph>new SimpleButton()</codeph></li>
		<li><codeph>new TextField()</codeph></li>
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:InteractiveObject:contextMenu:get"><apiName>contextMenu</apiName><shortdesc> 
	 Определяет контекстное меню, связанное с данным объектом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier><apiTipTexts><apiTipText>Контекстное меню, связанное с этим объектом
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Определяет контекстное меню, связанное с данным объектом.
	 
	 <p>Для содержимого, запущенного в проигрывателе Flash Player, это свойство является объектом ContextMenu. В среде выполнения AIR класс ContextMenu расширяет класс NativeMenu, однако Flash Player поддерживает только класс ContextMenu, но не класс NativeMenu.
	 </p>
	 
	 <p><b>Примечание.</b> Объекты TextField всегда содержат меню буфера обмена в контекстном меню. Меню буфера обмена включает команды «Вырезать», «Копировать», «Вставить» и «Выбрать все». Удалить эти команды из контекстного меню для объектов TextField невозможно. Для объектов TextField выбор этих команд (или сочетаний клавиш, эквивалентных элементу меню) не приводит к генерации событий <codeph>clear</codeph>, <codeph>copy</codeph>, <codeph>cut</codeph>, <codeph>paste</codeph> или <codeph>selectAll</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:doubleClickEnabled:get"><apiName>doubleClickEnabled</apiName><shortdesc> 
	 Определяет, получает ли объект события doubleClick.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Определяет, получает ли этот объект сообщения о двойном щелчке.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Определяет, получает ли объект события <codeph>doubleClick</codeph>. Значение по умолчанию – <codeph>false</codeph>: по умолчанию экземпляр InteractiveObject не получает событий <codeph>doubleClick</codeph>. Если свойству <codeph>doubleClickEnabled</codeph> задано значение <codeph>true</codeph>, экземпляр получает события <codeph>doubleClick</codeph> в своих границах. Свойство <codeph>mouseEnabled</codeph> экземпляра InteractiveObject должно иметь значение <codeph>true</codeph>, чтобы объект мог получать события <codeph>doubleClick</codeph>.
	 
	 <p>При настройке данного свойства события не отправляются. Чтобы добавить прослушиватель события <codeph>doubleClick</codeph>, необходимо использовать метод <codeph>addEventListener()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InteractiveObject/event:doubleClick"><linktext>doubleClick</linktext></link><link href="flash.display.xml#InteractiveObject/mouseEnabled"><linktext>mouseEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:focusRect:get"><apiName>focusRect</apiName><shortdesc> 
	 Задает отображение прямоугольной рамки индикатора фокуса для данного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip._focusRect, Button._focusRect, and 
	 _focusRect (global property) topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc> 
	 Задает отображение прямоугольной рамки индикатора фокуса для данного объекта. Может принимать одно из трех значений <codeph>true</codeph>, <codeph>false</codeph> или <codeph>null</codeph>. Значения <codeph>true</codeph> и <codeph>false</codeph> дают ожидаемые результаты, определяя, будет ли появляться прямоугольник в фокусе. Значение <codeph>null</codeph> указывает, что данный объект подчиняется свойству <codeph>stageFocusRect</codeph> рабочей области.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:mouseEnabled:get"><apiName>mouseEnabled</apiName><shortdesc> 
	 Определяет, получает ли этот объект сообщения мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 Определяет, получает ли этот объект сообщения мыши. Значение по умолчанию – <codeph>true</codeph>, которое означает, что любой экземпляр InteractiveObject в списке отображения получает события мыши. Если <codeph>mouseEnabled</codeph> имеет значение <codeph>false</codeph>, экземпляр не получает событий мыши. Эта настройка не затрагивает нижестоящие элементы данного экземпляра в списке отображения. Чтобы изменить поведение <codeph>mouseEnabled</codeph> для всех нижестоящих элементов объекта в списке отображения, используйте <codeph>flash.display.DisplayObjectContainer.mouseChildren</codeph>.
	 <p> При настройке данного свойства события не отправляются. Чтобы создать интерактивные функции, необходимо использовать метод <codeph>addEventListener()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:tabEnabled:get"><apiName>tabEnabled</apiName><shortdesc> 
	 Определяет, включен ли переход к этому объекту с помощью клавиши Tab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip.tabEnabled, Button.tabEnabled, and 
	 TextField.tabEnabled topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Определяет, включен ли этот объект в последовательность перехода с помощью клавиши Tab.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 Определяет, включен ли переход к этому объекту с помощью клавиши Tab. Если объект включен в последовательность перехода с помощью клавиши Tab, значение – <codeph>true</codeph>; в противном случае – <codeph>false</codeph>. По умолчанию используется значение <codeph>false</codeph>, за исключением следующих случаев.
     <ul><li>Для объекта SimpleButton используется значение <codeph>true</codeph>.</li>
     <li>Для объекта TextField с <codeph>type = "input"</codeph> используется значение <codeph>true</codeph>.</li>
     <li>Для объекта Sprite или MovieClip с <codeph>buttonMode = true</codeph> используется значение <codeph>true</codeph>.</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:tabIndex:get"><apiName>tabIndex</apiName><shortdesc> 
   	 Задает последовательность перехода между объектами в SWF-файле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Индекс при переходе с помощью клавиши Tab для этого объекта.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
   	 Задает последовательность перехода между объектами в SWF-файле. Свойство <codeph>tabIndex</codeph> по умолчанию имеет значение -1, то есть для объекта не задан индекс при переходе с помощью клавиши Tab.
	 
   	 <p>Если какой-либо отображаемый в данный момент объект в SWF-файле имеет свойство <codeph>tabIndex</codeph>, автоматическая последовательность перехода с помощью клавиши Tab отключается, и последовательность перехода вычисляется по свойствам <codeph>tabIndex</codeph> объектов SWF-файла. Пользовательская последовательность перехода с помощью клавиши Tab включает только объекты, имеющие свойство <codeph>tabIndex</codeph>.</p>
	 
   	 <p>Свойство <codeph>tabIndex</codeph> может быть выражено неотрицательным числом. Последовательность перехода определяется в соответствии со свойствами <codeph>tabIndex</codeph> объектов в восходящем порядке. Объект со значением 1 свойства <codeph>tabIndex</codeph> предшествует объекту со значением 2 свойства <codeph>tabIndex</codeph>. Нельзя использовать одинаковое значение <codeph>tabIndex</codeph> для нескольких объектов.</p>
	 
	 <p>Пользовательская последовательность перехода с помощью клавиши Tab, определяемая свойством <codeph>tabIndex</codeph>, является <i>линейной</i>. Это значит, что иерархические отношения объектов в SWF-файле не учитываются. Все объекты в SWF-файле со свойствами <codeph>tabIndex</codeph> помещаются в последовательность перехода с помощью клавиши Tab, которая определяется последовательностью значений <codeph>tabIndex</codeph>. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
 Задает упорядоченный набор треугольников, которые будут визуализироваться с использованием координат заливки (u,v) или с помощью обычной заливки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Задает упорядоченный набор треугольников, которые будут визуализироваться с использованием координат заливки (u,v) или с помощью обычной заливки. Каждый треугольник в контуре представлен тремя наборами координат (x, y) для каждой вершины треугольника.
 
 <p>
 Векторы треугольников могут не содержать координату z и не представлять трехмерные поверхности. Однако, контур треугольника может быть использован для визуализации трехмерных геометрических объектов в двухмерном пространстве.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsTrianglePath:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
     Создает новый объект GraphicsTrianglePath.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Вектор чисел, где каждая пара чисел рассматривается как точка (пара координат x, y). Обязательное.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Вектор целых чисел или индексов, где каждые три индекса определяют треугольник. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Вектор нормализованных координат, используемый для наложения текстуры.
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Указывает, производить ли визуализацию треугольников, которые повернуты в указанном направлении. Используется для предотвращения визуализации треугольников, которые не видны с текущей точки обзора. Может быть настроено на использование любого значения класса TriangleCulling.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект GraphicsTrianglePath.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsTrianglePath/culling"><linktext>отбор</linktext></link><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsTrianglePath:indices"><apiName>indices</apiName><shortdesc>
     Вектор целых чисел или индексов, где каждые три индекса определяют треугольник.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     Вектор целых чисел или индексов, где каждые три индекса определяют треугольник. Если параметру индексов задано значение null, то треугольник определяют каждые три вершины (шесть пар х,у в векторе вершин). В противном случае каждый индекс относится к вершине, представленной парой чисел в векторе вершин. Например, <codeph>indexes[1]</codeph> определяет точку с координатами (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:uvtData"><apiName>uvtData</apiName><shortdesc>
     Вектор нормализованных координат, используемый для наложения текстуры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Вектор нормализованных координат, используемый для наложения текстуры. Каждая координата определяет точку на растровом изображении, используемом для заливки. Для каждой вершины должна быть указана одна координата UV или одна координата UVT.
     
     <p>
     В координатах UV точка (0,0) – это верхняя левая точка, а точка (1,1) – нижняя правая точка растрового изображения. 
     </p>
                    
     <p>
     Если длина этого вектора в два раза превышает длину вектора <codeph>vertices</codeph>, то нормализованные координаты используются без перспективной коррекции.
     </p>
     
     <p>
     Если длина этого вектора в три раза превышает длину вектора <codeph>vertices</codeph>, то третья координата интерпретируется как «t», расстояние от глаза до текстуры в поле зрения. Это помогает средству визуализации правильно применить перспективу при наложении текстур в трехмерной графике.
     </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:vertices"><apiName>vertices</apiName><shortdesc>
     Вектор чисел, где каждая пара чисел рассматривается как точка (пара координат x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Вектор чисел, где каждая пара чисел рассматривается как точка (пара координат x, y).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:culling:get"><apiName>culling</apiName><shortdesc>
     Указывает, производить ли визуализацию треугольников, которые повернуты в указанном направлении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, производить ли визуализацию треугольников, которые повернуты в указанном направлении. Используется для предотвращения визуализации треугольников, которые не видны с текущей точки обзора. 
     <p>
     Может быть настроено на использование любого значения класса TriangleCulling.
     </p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObject"><apiName>DisplayObject</apiName><shortdesc>
 Класс DisplayObject является базовым классом для всех объектов, которые можно поместить в список отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс DisplayObject является базовым классом для всех объектов, которые можно поместить в список отображения. Список отображения управляет всеми объектами, отображаемыми в проигрывателе Flash Player или в Adobe AIR. Используйте класс DisplayObjectContainer, чтобы упорядочить экранные объекты в списке отображения. Объекты DisplayObjectContainer могут иметь нижестоящие экранные объекты, а другие экранные объекты, такие как Shape и TextField, являются конечными узлами, у которых есть только вышестоящие элементы и элементы одного уровня, но нет нижестоящих. 
 
 <p>Класс DisplayObject поддерживает базовые функции, такие как положение объекта по осям <i>x</i> и <i>y</i>, а также некоторые расширенные свойства объекта, такие как матрица преобразования. 
 </p>
 
 <p>DisplayObject – это абстрактный базовый класс, поэтому DisplayObject нельзя вызывать непосредственно. При вызове <codeph>new DisplayObject()</codeph> выдается исключение <codeph>ArgumentError</codeph>. </p>
 
 <p>Все экранные объекты наследуют свойства и методы класса DisplayObject.</p>
 
 <p>Сам класс DisplayObject не содержит API-интерфейсов для визуализации содержимого на экране По этой причине, если требуется создать пользовательский подкласс класса DisplayObject, нужно расширить один из его подклассов, в которых есть API-интерфейс для визуализации содержимого на экране, такие как классы Shape, Sprite, Bitmap, SimpleButton, TextField и MovieClip.</p>
 
 <p>Класс DisplayObject содержит несколько многоадресных событий. Как правило, целью любого конкретного события является конкретный экземпляр DisplayObject. Например, целью события <codeph>added</codeph> является конкретный экземпляр DisplayObject, который был добавлен в список отображения. Единственный целевой объект предотвращает добавление прослушивателей событий для этого объекта, а иногда и его предков, в список отображения. Однако для многоадресных событий целью является не конкретный объект DisplayObject, а все экземпляры DisplayObject, в том числе и те, что не включены в список отображения. Это значит, что вы можете добавить прослушиватель к любому экземпляру DisplayObject для прослушивания многоадресных событий. В дополнение к многоадресным событиям, перечисленным в таблице событий класса DisplayObject, класс DisplayObject наследует также два многоадресных события от класса EventDispatcher: <codeph>activate</codeph> и <codeph>deactivate</codeph>.</p>
 
 <p>Некоторые свойства, которые ранее использовались в ActionScript 1.0 и 2.0 в классах MovieClip, TextField и Button (такие как <codeph>_alpha</codeph>, <codeph>_height</codeph>, <codeph>_name</codeph>, <codeph>_width</codeph>, <codeph>_x</codeph>, <codeph>_y</codeph> и другие) имеют эквиваленты в классе DisplayObject ActionScript 3.0, но они переименованы и больше не начинаются с символа подчеркивания (_).</p>
 
 <p>Дополнительные сведения см. в главе «Программирование экрана» книги <i>Программирование на ActionScript 3.0</i>.</p>
 
 </apiDesc><example conref="examples\DisplayObjectExample.as"> В следующем примере с помощью класса <codeph>DisplayObjectExample</codeph> рисуется оранжевый квадрат в углу рабочей области, который затем реагирует на события, для каждого из которых отображается текстовая информация. Это можно сделать, выполнив следующие действия.
 <ol>
    <li>Объявляются свойства класса для цвета и размера квадрата.</li>
     <li>Конструктор вызывает метод <codeph>draw()</codeph>, который рисует оранжевый квадрат на монтажном столе в точке с координатами по умолчанию <i>x = 0, y = 0</i>.</li>
    <li>Для квадрата добавляются следующие методы прослушивателей событий.
     <ul>
        <li><codeph>addedHandler()</codeph> прослушивает события <codeph>added</codeph>, отправляемые при добавлении квадрата в список отображения.</li>
        <li><codeph>enterFrameHandler()</codeph> прослушивает события <codeph>enterFrame</codeph>, которые в данном примере не несут реальной нагрузки.</li>
        <li><codeph>removedHandler()</codeph> прослушивает события <codeph>removed</codeph>, отправляемые при удалении квадрата из списка отображения, что происходит при щелчке по нему.</li>
        <li><codeph>clickHandler()</codeph> прослушивает события <codeph>click</codeph>, отправляемые при щелчке по оранжевому квадрату.</li>
        <li><codeph>renderHandler()</codeph> прослушивает события <codeph>render</codeph> после обновления списка отображения.</li>
  </ul></li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class DisplayObjectExample extends Sprite {
        public function DisplayObjectExample() {
            var child:CustomDisplayObject = new CustomDisplayObject();
            addChild(child);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.*;

class CustomDisplayObject extends Sprite {
    private var bgColor:uint = 0xFFCC00;
    private var size:uint    = 80;

    public function CustomDisplayObject() {
        draw();
        addEventListener(Event.ADDED, addedHandler);
        addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        addEventListener(Event.REMOVED, removedHandler);
        addEventListener(MouseEvent.CLICK, clickHandler);
        addEventListener(Event.RENDER, renderHandler);
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }

    private function clickHandler(event:MouseEvent):void {
        trace("clickHandler: " + event);
        parent.removeChild(this);
    }

    private function addedHandler(event:Event):void {
        trace("addedHandler: " + event);
        stage.scaleMode = StageScaleMode.NO_SCALE;
        stage.align = StageAlign.TOP_LEFT;
        stage.addEventListener("resize", resizeHandler);
    }

    private function enterFrameHandler(event:Event):void {
        trace("enterFrameHandler: " + event);
        removeEventListener("enterFrame", enterFrameHandler);
    }

    private function removedHandler(event:Event):void {
        trace("removedHandler: " + event);
        stage.removeEventListener("resize", resizeHandler);
    }

    private function renderHandler(event:Event):void {
        trace("renderHandler: " + event);
    }

    private function resizeHandler(event:Event):void {
        trace("resizeHandler: " + event);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.RENDER_render"><apiName>render</apiName><shortdesc>
 [многоадресное событие] Отправляется перед обновлением и визуализацией списка отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RENDER</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [многоадресное событие] Отправляется перед обновлением и визуализацией списка отображения. Это событие дает последнюю возможность объектам, прослушивающим данное событие, внести изменения перед визуализацией списка отображения. Метод <codeph>invalidate()</codeph> объекта Stage необходимо вызывать каждый раз, когда нужно отправить событие <codeph>render</codeph>. События <codeph>render</codeph> отправляются объекту только при условии отношений доверия между ним и объектом, вызвавшим метод <codeph>Stage.invalidate()</codeph>. Это многоадресное событие, которое отправляется всеми экранными объектами, для которых зарегистрированы прослушиватели данного события.
 
 <p><b>Примечание.</b> Это событие не отправляется, если дисплей не выполняет визуализацию. Это происходит, когда содержимое свернуто или скрыто. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_FROM_STAGE_removedFromStage"><apiName>removedFromStage</apiName><shortdesc>
 Отправляется перед удалением экранного объекта из списка отображения либо напрямую, либо путем удаления поддерева, содержащего экранный объект.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED_FROM_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется перед удалением экранного объекта из списка отображения либо непосредственно, либо путем удаления поддерева, содержащего экранный объект. Это событие генерируют два метода класса DisplayObjectContainer: <codeph>removeChild()</codeph> и <codeph>removeChildAt()</codeph>. 
 
 <p>Следующие методы объекта DisplayObjectContainer также генерируют это событие, если один объект должен быть удален с целью освобождения места для нового: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph> и <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_removed"><apiName>removed</apiName><shortdesc>
 Отправляется перед удалением экранного объекта из списка отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется перед удалением экранного объекта из списка отображения. Это событие генерируют два метода класса DisplayObjectContainer: <codeph>removeChild()</codeph> и <codeph>removeChildAt()</codeph>. 
 
 <p>Следующие методы объекта DisplayObjectContainer также генерируют это событие, если один объект должен быть удален с целью освобождения места для нового: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph> и <codeph>setChildIndex()</codeph>. </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.EXIT_FRAME_exitFrame"><apiName>exitFrame</apiName><shortdesc>
 [многоадресное событие] Отправляется, когда точка воспроизведения покидает текущий кадр.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXIT_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [многоадресное событие] Отправляется, когда точка воспроизведения покидает текущий кадр. Все сценарии кадров выполнены. Если точка воспроизведения не перемещается или если используется только один кадр, это событие отправляется непрерывно в соответствии с частотой кадров. Это многоадресное событие, которое отправляется всеми экранными объектами, для которых зарегистрированы прослушиватели данного события.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.FRAME_CONSTRUCTED_frameConstructed"><apiName>frameConstructed</apiName><shortdesc>
 [многоадресное событие] Отправляется после завершения работы конструкторов экранных объектов кадра до выполнения сценариев кадра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.FRAME_CONSTRUCTED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [многоадресное событие] Отправляется после завершения работы конструкторов экранных объектов кадра до выполнения сценариев кадра. Если точка воспроизведения не перемещается или если используется только один кадр, это событие отправляется непрерывно в соответствии с частотой кадров. Это многоадресное событие, которое отправляется всеми отображаемыми объектами, для которых зарегистрированы прослушиватели данного события.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ENTER_FRAME_enterFrame"><apiName>enterFrame</apiName><shortdesc>
 [многоадресное событие] Отправляется, когда точка воспроизведения переходит в новый кадр.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ENTER_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [многоадресное событие] Отправляется, когда точка воспроизведения переходит в новый кадр. Если точка воспроизведения не перемещается или если используется только один кадр, это событие отправляется непрерывно в соответствии с частотой кадров. Это многоадресное событие, которое отправляется всеми экранными объектами, для которых зарегистрированы прослушиватели данного события.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_TO_STAGE_addedToStage"><apiName>addedToStage</apiName><shortdesc>
 Отправляется, когда экранный объект добавляется к списку отображения на монтажном столе либо непосредственно, либо путем добавления поддерева, содержащего экранный объект.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED_TO_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда экранный объект добавляется к списку отображения на монтажном столе либо непосредственно, либо путем добавления поддерева, содержащего экранный объект. Это событие запускается следующими методами: <codeph>DisplayObjectContainer.addChild()</codeph>, <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_added"><apiName>added</apiName><shortdesc>
 Отправляется, когда экранный объект добавляется в список отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда экранный объект добавляется в список отображения. Это событие запускается следующими методами: <codeph>DisplayObjectContainer.addChild()</codeph>, <codeph>DisplayObjectContainer.addChildAt()</codeph>.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:DisplayObject:getBounds"><apiName>getBounds</apiName><shortdesc>
     Возвращает прямоугольник, определяющий область объекта отображения, которая относится к системе координат объекта targetCoordinateSpace.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Прямоугольник, определяющий область экранного объекта относительно системы координат объекта <codeph>targetCoordinateSpace</codeph>.
     
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экранный объект, определяющий используемую систему координат
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает прямоугольник, определяющий область экранного объекта, которая относится к системе координат объекта <codeph>targetCoordinateSpace</codeph>. На примере следующего кода рассмотрим, как возвращаемый прямоугольник может изменяться в зависимости от передаваемого методу параметра <codeph>targetCoordinateSpace</codeph>.
     
     <codeblock>
     var container:Sprite = new Sprite();
     container.x = 100;
     container.y = 100;
     this.addChild(container);
     var contents:Shape = new Shape();
     contents.graphics.drawCircle(0,0,100);
     container.addChild(contents);
     trace(contents.getBounds(container));
      // (x=-100, y=-100, w=200, h=200)
     trace(contents.getBounds(this));
      // (x=0, y=0, w=200, h=200)
     </codeblock>
     
     
     <p><b>Примечание.</b> Используйте методы <codeph>localToGlobal()</codeph> и <codeph>globalToLocal()</codeph> для преобразования локальных координат экранного объекта в координаты экрана и наоборот.</p>
     
     <p>Метод <codeph>getBounds()</codeph> похож на метод<codeph>getRect()</codeph>, однако прямоугольник, возвращаемый методом <codeph>getBounds()</codeph>, включает все штрихи на фигурах, а возвращаемый методом <codeph>getRect()</codeph> – нет. Пример см. в описании метода <codeph>getRect()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getRect()"><linktext>getRect()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:getRect"><apiName>getRect</apiName><shortdesc>
    Возвращает прямоугольник, определяющий границу объекта отображения по системе координат, определенной параметром targetCoordinateSpace за исключением линий фигур.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Прямоугольник, определяющий область экранного объекта относительно системы координат объекта <codeph>targetCoordinateSpace</codeph>.
    
    </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экранный объект, определяющий используемую систему координат
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Возвращает прямоугольник, определяющий границу объекта отображения по системе координат, определенной параметром <codeph>targetCoordinateSpace</codeph> за исключением линий фигур. Значения, возвращаемые методом <codeph>getRect()</codeph>, равны или меньше возвращаемых методом <codeph>getBounds()</codeph>.
    
    <p><b>Примечание.</b> Используйте методы <codeph>localToGlobal()</codeph> и <codeph>globalToLocal()</codeph> для преобразования локальных координат отображаемого объекта в координаты рабочей области и наоборот.</p>
    
    </apiDesc><example conref="examples\DisplayObject.getRect.1.as"> В следующем примере показано, как метод <codeph>getBounds()</codeph> возвращает прямоугольник большего размера, чем метод <codeph>getRect()</codeph>, потому что штрихи занимают дополнительное пространство. В данном случае спрайт <codeph>triangle</codeph> содержит дополнительные штрихи из-за параметров <codeph>width</codeph> и <codeph>jointStyle</codeph> метода <codeph>lineStyle()</codeph>. Вывод метода <codeph>trace()</codeph> (в двух последних строках) показывает различия между прямоугольниками <codeph>getRect()</codeph> и <codeph>getBounds()</codeph>.
<codeblock>

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.geom.Rectangle;

var triangle:Sprite = new Sprite();
var color:uint = 0xFF0044;
var width:Number = 20;
var alpha:Number = 1.0;
var pixelHinting:Boolean = true;
var scaleMode:String = LineScaleMode.NORMAL;
var caps:String = CapsStyle.SQUARE;
var joints:String = JointStyle.MITER;
triangle.graphics.lineStyle(width, color, alpha, pixelHinting, scaleMode, caps, joints);

var triangleSide:Number = 100;
triangle.graphics.moveTo(0, 0);
triangle.graphics.lineTo(0, triangleSide);
triangle.graphics.lineTo(triangleSide, triangleSide);
triangle.graphics.lineTo(0, 0);

addChild(triangle);

trace(triangle.getBounds(this)); // (x=-10, y=-24.1, w=134.10000000000002, h=134.1)
trace(triangle.getRect(this));     // (x=0, y=0, w=100, h=100)
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getBounds()"><linktext>getBounds()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal"><apiName>globalToLocal</apiName><shortdesc>
     Преобразует объект Point из координат рабочей области (глобальных) в координаты отображаемого объекта (локальные).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект Point с координатами относительно отображаемого объекта.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Объект, созданный с использованием класса Point. Объект Point задает координаты <i>x</i> и <i>y</i> в качестве свойств.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Преобразует объект <codeph>Point</codeph> из координат рабочей области (глобальных) в координаты отображаемого объекта (локальные).
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Преобразует объект <codeph>Point</codeph> из координат рабочей области (глобальных) в координаты экранного объекта (локальные).
     
     <p>Чтобы воспользоваться этим методом, сначала нужно создать экземпляр класса Point. Присвоенные вами значения <i>x</i> и <i>y</i> представляют глобальные координаты, так как они указаны относительно исходной точки (0,0) основной области отображения. Затем экземпляр Point следует передать в качестве параметра методу <codeph>globalToLocal()</codeph>. Этот метод возвращает новый объект Point со значениями <i>x</i> и <i>y</i>, указанными относительно исходной точки отображаемого объекта, а не рабочей области.</p>
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> Следующий код создает объект Shape и иллюстрирует результат вызова метода <codeph>hitTestPoint()</codeph>, в качестве параметров которого используются разные точки. Метод <codeph>globalToLocal()</codeph> переводит точку из координатной плоскости рабочей области в координатную плоскость фигуры.
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link><link href="flash.geom.xml#Point"><linktext>Класс flash.geom.Point</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal3D"><apiName>globalToLocal3D</apiName><shortdesc>
     Преобразует двумерный объект Point из координат рабочей области (глобальных) в координаты экранного трехмерного объекта (локальные).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект Vector3D с координатами относительно трехмерного экранного объекта. 
     
     </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Двухмерный объект Point, представляющий глобальные координаты x и y.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Преобразует двумерный объект Point из координат рабочей области (глобальных) в координаты экранного трехмерного объекта (локальные).
     
     <p>Чтобы воспользоваться этим методом, сначала нужно создать экземпляр класса Point. Присвоенные объекту Point значения x и y представляют глобальные координаты, так как они указаны относительно исходной точки (0, 0) основной области отображения. Затем передайте объект Point методу <codeph>globalToLocal3D()</codeph> в виде параметра <codeph>point</codeph>. Данный метод возвращает трехмерные координаты в виде объекта Vector3D, содержащего значения <codeph>x</codeph>, <codeph>y</codeph> и <codeph>z</codeph> относительно исходной точки трехмерного экранного объекта.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestObject"><apiName>hitTestObject</apiName><shortdesc>
     Вычисляет ограничительную рамку экранного объекта, чтобы определить, не перекрывает и не пересекает ли она ограничительную рамку экранного объекта obj.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если ограничительные рамки экранных объектов пересекаются; <codeph>false</codeph>, если нет.
     
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экранный объект для сравнения.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Вычисляет ограничительную рамку экранного объекта, чтобы определить, не перекрывает и не пересекает ли она ограничительную рамку экранного объекта, переданного в качестве параметра.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Вычисляет ограничительную рамку экранного объекта, чтобы определить, не перекрывает и не пересекает ли она ограничительную рамку экранного объекта <codeph>obj</codeph>.
     
     </apiDesc><example conref="examples\DisplayObject.hitTestObject.1.as"> Следующий код создает три объекта Shape и иллюстрирует результат вызова метода <codeph>hitTestObject()</codeph>. Обратите внимание на то, что хотя circle2 и circle3 не перекрывают друг друга, их ограничительные рамки пересекаются. Таким образом, проверка circle2 и circle3 на нажатие возвращает значение <codeph>true</codeph>.
<codeblock>

import flash.display.Shape;

var circle1:Shape = new Shape();
circle1.graphics.beginFill(0x0000FF);
circle1.graphics.drawCircle(40, 40, 40);
addChild(circle1);

var circle2:Shape = new Shape();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(40, 40, 40);
circle2.x = 50;
addChild(circle2);

var circle3:Shape = new Shape();
circle3.graphics.beginFill(0xFF0000);
circle3.graphics.drawCircle(40, 40, 40);
circle3.x = 100;
circle3.y = 67;
addChild(circle3);

trace(circle1.hitTestObject(circle2)); // true
trace(circle1.hitTestObject(circle3)); // false
trace(circle2.hitTestObject(circle3)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestPoint"><apiName>hitTestPoint</apiName><shortdesc>
     Вычисляет экранный объект, чтобы определить, перекрывает ли он точку, заданную координатами x и y, или пересекает ее.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Значение – <codeph>true</codeph>, если экранный объект перекрывает заданный объект или пересекается с ним; в противном случае – <codeph>false</codeph>.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>x</i>, сравниваемая с данным объектом.
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>у</i>, сравниваемая с данным объектом.
     
     </apiDesc></apiParam><apiParam><apiItemName>shapeFlag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, следует ли выполнять тестирование по фактическим пикселям объекта (<codeph>true</codeph>) или по рамке (<codeph>false</codeph>). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Вычисляет экранный объект, чтобы определить, перекрывает ли он точку, заданную координатами x и y, или пересекает ее.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Вычисляет экранный объект, чтобы определить, перекрывает ли он точку, заданную координатами <codeph>x</codeph> и <codeph>y</codeph>, или пересекает ее. Параметры <codeph>x</codeph> и <codeph>y</codeph> задают точку в координатной плоскости рабочей области, а не контейнера экранных объектов, содержащего объект (если контейнером не является сама рабочая область).
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> Следующий код создает объект Shape и иллюстрирует результат вызова метода <codeph>hitTestPoint()</codeph>, в качестве параметров которого используются разные точки. Метод <codeph>globalToLocal()</codeph> переводит точку из координатной плоскости рабочей области в координатную плоскость фигуры.
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:local3DToGlobal"><apiName>local3DToGlobal</apiName><shortdesc>
     Преобразует трехмерный объект point из координат трехмерного экранного объекта (локальных) в двухмерный объект point с координатами рабочей области (глобальными).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Двухмерный объект point, представляющий трехмерный объект point в двухмерном пространстве.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point3d</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>Объект Vector3D, содержащий либо трехмерный объект point, либо координаты трехмерного экранного объекта.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Преобразует трехмерный объект point из координат трехмерного экранного объекта (локальных) в двухмерный объект point с координатами рабочей области (глобальными).
     
     <p>Например, вы можете использовать только двухмерные координаты (x,y) для рисования при помощи методов <codeph>display.Graphics</codeph>. Чтобы нарисовать трехмерный объект, необходимо сопоставить трехмерные координаты экранного объекта двухмерным координатам. Сначала создайте экземпляр класса Vector3D с координатами x, y и z трехмерного экранного объекта. Затем передайте объект Vector3D методу <codeph>local3DToGlobal()</codeph> в виде параметра <codeph>point3d</codeph>. Метод возвращает двухмерный объект Point, который можно использовать с Graphics API для рисования трехмерного объекта.</p>
     
     
     </apiDesc><example conref="examples\Local3DToGlobalExample.as"> Данный пример иллюстрирует рисование простого трехмерного куба в двухмерном пространстве при помощи методов <codeph>display.Graphics</codeph>. Расположение экранного объекта <codeph>this</codeph> смещено, поэтому точка фиксации куба находится в центре. Вектор объектов Vector3D содержит трехмерные координаты куба. Сначала рисуется верхняя грань куба, затем нижняя, затем соединяются верхние и нижние углы. Перед рисованием куба его необходимо добавить в контейнер экранных объектов, чтобы использовать метод <codeph>local3DToGlobal()</codeph>. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.geom.*;

    public class Local3DToGlobalExample extends MovieClip {
        private var myCube:Sprite = new Sprite();
        private var v8:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(8);

        public function Local3DToGlobalExample():void {
            this.x = -(this.stage.stageWidth / 2);
            this.y = -(this.stage.stageWidth / 2);

            v8[0] = new Vector3D(-40,-40,-40);
            v8[1] = new Vector3D(40,-40,-40);
            v8[2] = new Vector3D(40,-40,40);
            v8[3] = new Vector3D(-40,-40,40);
            v8[4] = new Vector3D(-40,100,-40);
            v8[5] = new Vector3D(40,100,-40);
            v8[6] = new Vector3D(40,100,40);
            v8[7] = new Vector3D(-40,100,40);

            myCube.x = (this.stage.stageWidth / 2);
            myCube.y = (this.stage.stageWidth / 2);
            myCube.z = 1;
            addChild(myCube);

            Cube();         
        }

        private function Cube():void {
            var ps:Point = new Point(0,0);

            myCube.graphics.lineStyle(2,0xFF0000);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:localToGlobal"><apiName>localToGlobal</apiName><shortdesc>
     Преобразует объект Point из координат экранного объекта (локальных) в координаты рабочей области (глобальные).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект Point с координатами относительно рабочей области.
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Имя или идентификатор точки, созданной с использованием класса Point, в качестве свойств которой заданы координаты <i>x</i> и <i>y</i>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Преобразует объект <codeph>point</codeph> из координат экранного объекта (локальных) в координаты рабочей области (глобальные).
     
     <p>Этот метод позволяет преобразовать заданные координаты <i>x</i> и <i>y</i> из значений относительно исходной точки (0, 0) конкретного объекта (локальных координат) в значения относительно исходной точки рабочей области (глобальные координаты).</p>
     
     <p>Чтобы воспользоваться этим методом, сначала нужно создать экземпляр класса Point. Присвоенные вами значения <i>x</i> и <i>y</i> представляют локальные координаты, так как они указаны относительно исходной точки экранного объекта.</p>
     
     <p>Затем созданный экземпляр Point передается в качестве параметра методу <codeph>localToGlobal()</codeph>. Этот метод возвращает новый объект Point со значениями <i>x</i> и <i>y</i>, указанными относительно исходной точки рабочей области, а не объекта отображения.</p>
     
     </apiDesc><example conref="examples\DisplayObject.localToGlobal.1.as"> Следующий код создает объект Sprite. Свойства <codeph>mouseX</codeph> и <codeph>mouseY</codeph> спрайта представляют собой координатную плоскость экранного объекта. В этом коде используется метод <codeph>localToGlobal()</codeph> для преобразования этих свойств в глобальные координаты (координаты рабочей области).
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.Point;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
square.x = 100;
square.y = 200;

addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates)

function traceCoordinates(event:MouseEvent):void {
    var clickPoint:Point = new Point(square.mouseX, square.mouseY);
    trace("display object coordinates:", clickPoint);
    trace("stage coordinates:", square.localToGlobal(clickPoint));
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.geom.xml#Point"><linktext>Класс flash.geom.Point</linktext></link></related-links></apiOperation><apiValue id="flash.display:DisplayObject:accessibilityProperties:get"><apiName>accessibilityProperties</apiName><shortdesc>
     Текущие параметры специальных возможностей для данного экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.accessibility:AccessibilityProperties</apiValueClassifier></apiValueDef><apiDesc>
     Текущие параметры специальных возможностей для данного экранного объекта. Если модифицируется свойство <codeph>accessibilityProperties</codeph> или любые поля в <codeph>accessibilityProperties</codeph>, необходимо вызвать метод <codeph>Accessibility.updateProperties()</codeph>, чтобы изменения вступили в силу.
     
     <p class="flashonly"><b>Примечание.</b> Для объектов, созданных в среде разработки Flash, значение <codeph>accessibilityProperties</codeph> предварительно заполняется информацией, введенной на панели «Специальные возможности» данного объекта.</p>
     
     </apiDesc><example conref="examples\DisplayObject.accessibilityProperties.1.as"> На следующем примере показывается, как присоединить простой объект AccessibilityProperties к экземпляру TextField.
<codeblock>

import flash.text.TextField;
import flash.accessibility.AccessibilityProperties;
import flash.accessibility.Accessibility;
import flash.system.Capabilities;

var tf:TextField = new TextField();
tf.text = "hello";

var accessProps:AccessibilityProperties = new AccessibilityProperties();
accessProps.name = "Greeting";

tf.accessibilityProperties = accessProps;

if (Capabilities.hasAccessibility) {
    Accessibility.updateProperties();
}

trace(tf.accessibilityProperties.name); // Greeting
</codeblock></example></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link><link href="flash.accessibility.xml#AccessibilityProperties"><linktext>flash.accessibility.AccessibilityProperties</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:alpha:get"><apiName>alpha</apiName><shortdesc>
     Указывает значение альфа-прозрачности заданного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает значение альфа-прозрачности заданного объекта. Допустимые значения находятся в диапазоне от 0 (полностью прозрачный) до 1 (полностью непрозрачный). Значением по умолчанию является 1. Экранные объекты, для которых значение <codeph>alpha</codeph> равно 0, <i>являются</i> активными, несмотря на невидимость.
     
     </apiDesc><example conref="examples\DisplayObject.alpha.1.as"> Следующий код задает свойству спрайта <codeph>alpha</codeph> значение 50%, когда на него наводится мышь.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.alpha = 0.5;
}

function restoreObject(event:MouseEvent):void {
    event.target.alpha = 1.0;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:blendMode:get"><apiName>blendMode</apiName><shortdesc>
     Значение класса BlendMode, задающее режим наложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение класса BlendMode, задающее режим наложения. Растровое изображение может прорисовываться внутренними средствами двумя способами. Если включен режим наложения или внешняя маска обрезки, растровое изображение рисуется путем добавления квадрата, заполненного растровым изображением, к векторной визуализации. При попытке задать свойству недопустимое значение проигрыватель Flash Player или Adobe AIR использует значение <codeph>BlendMode.NORMAL</codeph>.
     
     <p>Свойство <codeph>blendMode</codeph> влияет на каждый пиксель экранного объекта. Каждый пиксель состоит из трех основных цветов (красного, зеленого и синего) со значениями в пределах 0x00 – 0xFF. Проигрыватель Flash Player или Adobe AIR сравнивает каждый цвет, составляющий один пиксель, во фрагменте ролика с соответствующим цветом пикселя фона. Например, если <codeph>blendMode</codeph> имеет значение <codeph>BlendMode.LIGHTEN</codeph>, Flash Player или Adobe AIR сравнивает значение красного для экранного объекта со значением красного для фона и использует более светлый из них в качестве красного компонента отображаемого цвета.</p>
     
     <p>В следующей таблице описываются параметры <codeph>blendMode</codeph>. Класс BlendMode определяет строковые значения для использования. На иллюстрациях в таблице показаны значения <codeph>blendMode</codeph>, примененные к круглому экранному объекту (2) с наложением на другой экранный объект (1).</p>
     
     
     <p>
      <adobeimage alt="Квадрат № 1" href="../../images/blendMode-0a.jpg"/> <adobeimage alt="Круг № 2" href="../../images/blendMode-0b.jpg"/>
     
     </p>
     
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Константа BlendMode</entry><entry>Рисунок</entry><entry>Описание</entry></row></thead><tbody><row valign="top">
     <entry><codeph>BlendMode.NORMAL</codeph></entry>
     <entry><adobeimage alt="режим наложения NORMAL (обычный)" href="../../images/blendMode-1.jpg"/></entry>
     <entry>Экранный объект отображается перед фоном. Значения пикселей экранного объекта переопределяют значения пикселей фона. В прозрачных областях экранного объекта виден фон.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LAYER</codeph></entry>
     <entry><adobeimage alt="режим наложения LAYER (слой)" href="../../images/blendMode-2.jpg"/></entry>
     
     <entry>Инициирует создание группы прозрачности для экранного объекта. Это означает, что перед дальнейшей обработкой экранный объект сначала составляется во временном буфере. Это выполняется автоматически, если экранный объект заранее сохраняется в кэше посредством кэширования растрового изображения или если экранный объект является контейнером экранных объектов, содержащим хотя бы один нижестоящий объект с параметром <codeph>blendMode</codeph> не в значении<codeph>BlendMode.NORMAL</codeph>.
     </entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.MULTIPLY</codeph></entry>
     <entry><adobeimage alt="режим наложения MULTIPLY (умножение)" href="../../images/blendMode-3.jpg"/></entry>
     
     <entry>Умножает значения составляющих цветов экранного объекта на значения цветов фона и затем нормализует их путем деления на 0xFF, в результате чего получаются более темные цвета. Этот параметр часто используется для затенения и создания эффекта глубины.
     
     <p>Например, если составляющий цвет (например, красный) одного пикселя в экранном объекте и соответствующий цвет пикселя в фоне имеют значение 0х88, то в результате умножения получается 0х4840. Деление на 0хFF дает значение 0х48 для данного составляющего цвета, принимающего более темный оттенок, чем в экранном объекте и фоне.</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SCREEN</codeph></entry>
     <entry><adobeimage alt="режим наложения SCREEN (экран)" href="../../images/blendMode-4.jpg"/></entry>
     
     <entry>Умножает обратный код цвета экранного объекта на обратный код цвета фона, в результате чего получается эффект осветления. Этот параметр часто используется для высветления или удаления черных областей экранного объекта.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LIGHTEN</codeph></entry>
     <entry><adobeimage alt="режим наложения LIGHTEN" href="../../images/blendMode-5.jpg"/></entry>
     
     <entry>Выбирает более светлые из составляющих цветов экранного объекта и цвета фона (цвета с большими значениями). Этот параметр часто используется как тип наложения.
     
     <p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xFFCC33, а RGB пикселя фона имеет значение 0xDDF800, то значением RGB отображаемого пикселя является 0xFFF833 (так как 0xFF > 0xDD, 0xCC &lt; 0xF8 и 0x33 > 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DARKEN</codeph></entry>
     <entry><adobeimage alt="режим наложения DARKEN" href="../../images/blendMode-6.jpg"/></entry>
     
     <entry>Выбирает более темные из составляющих цветов экранного объекта и цветов фона (цвета с меньшими значениями). Этот параметр часто используется как тип наложения.
     
     <p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xFFCC33, а RGB пикселя фона имеет значение 0xDDF800, то значением RGB отображаемого пикселя является 0xDDCC00 (так как 0xFF > 0xDD, 0xCC &lt; 0xF8 и 0x33 > 0x00 = 33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DIFFERENCE</codeph></entry>
     <entry><adobeimage alt="режим наложения DIFFERENCE" href="../../images/blendMode-7.jpg"/></entry>
     
     <entry>Сравнивает составляющие цвета экранного объекта с цветами его фона и вычитает более темное значение (из двух составляющих цветов) из более светлого значения. Этот параметр часто используется для получения более живых цветов.
     
     <p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xFFCC33, а RGB пикселя фона имеет значение 0xDDF800, то значением RGB отображаемого пикселя является 0x222C33 (так как 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C и 0x33 - 0x00 = 0x33).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ADD</codeph></entry>
     <entry><adobeimage alt="режим наложения ADD" href="../../images/blendMode-8.jpg"/></entry>
     
     <entry>Прибавляет значения составляющих цветов экранного объекта к значениям цветов его фона (с максимальным значением 0xFF). Этот параметр часто используется для анимации растворения света между двумя объектами.
     
     <p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xAAA633, а RGB пикселя фона имеет значение 0xDD2200, то значением RGB отображаемого пикселя является 0xFFC833 (так как 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8 и 0x33 + 0x00 = 0x33).</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.SUBTRACT</codeph></entry>
     <entry><adobeimage alt="режим наложения SUBTRACT" href="../../images/blendMode-9.jpg"/></entry>
     
     <entry>Вычитает значения составляющих цветов экранного объекта из значений цвета фона (с минимальным значением 0). Этот параметр часто используется для анимации растворения затемнения между двумя объектами.
     
     <p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xAA2233, а RGB пикселя фона имеет значение 0xDDA600, то значением RGB отображаемого пикселя является 0x338400 (так как 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84 и 0x00 - 0x33 &lt; 0x00).</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.INVERT</codeph></entry>
     <entry><adobeimage alt="режим наложения INVERT" href="../../images/blendMode-10.jpg"/></entry>
     
     <entry>Инвертирует фон.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ALPHA</codeph></entry>
     <entry><adobeimage alt="режим наложения ALPHA" href="../../images/blendMode-11.jpg"/></entry>
     
     <entry>Применяет альфа-значение каждого пикселя экранного объекта к фону. Для этого требуется, чтобы параметру <codeph>blendMode</codeph> вышестоящего экранного объекта было задано значение <codeph>BlendMode.LAYER</codeph>. Например, на иллюстрации для вышестоящего экранного объекта с белым фоном используется настройка <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ERASE</codeph></entry>
     <entry><adobeimage alt="режим наложения ERASE" href="../../images/blendMode-12.jpg"/></entry>
     
     <entry>Стирает фон на основе альфа-значения экранного объекта. Для этого требуется, чтобы настройке <codeph>blendMode</codeph> родительского экранного объекта было задано значение <codeph>BlendMode.LAYER</codeph>. Например, на иллюстрации для родительского экранного объекта с белым фоном используется настройка <codeph>blendMode = BlendMode.LAYER</codeph>.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.OVERLAY</codeph></entry>
     <entry><adobeimage alt="режим наложения OVERLAY" href="../../images/blendMode-13.jpg"/></entry>
     
     <entry>Изменяет цвет каждого пикселя в зависимости от того, насколько темный цвет используется для фона. Если фон светлее 50-процентного серого, цвета экранного объекта и фона отфильтровываются, в результате чего получается более светлый цвет. Если фон темнее 50-процентного серого, цвета умножаются, что дает более темный цвет. Этот параметр часто используется для эффектов затенения.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.HARDLIGHT</codeph></entry>
     <entry><adobeimage alt="режим наложения HARDLIGHT" href="../../images/blendMode-14.jpg"/></entry>
     
     <entry>Изменяет цвет каждого пикселя в зависимости от того, насколько темный цвет используется для экранного объекта. Если экранный объект светлее 50-процентного серого, цвета экранного объекта и фона отфильтровываются, в результате чего получается более светлый цвет. Если экранный объект темнее 50-процентного серого, цвета умножаются, что дает более темный цвет. Этот параметр часто используется для эффектов затенения.</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SHADER</codeph></entry>
     <entry align="center" valign="middle">нет</entry>
     
     <entry>Изменяет цвета с использованием пользовательской подпрограммы затенения. Используемое затенение задано в качестве экземпляра Shader, присвоенного свойству <codeph>blendShader</codeph>. Применение свойства <codeph>blendShader</codeph> к экземпляру Shader автоматически приведет к смене значения свойства <codeph>blendMode</codeph> на <codeph>BlendMode.SHADER</codeph>. Если для свойства <codeph>blendMode</codeph> задано <codeph>BlendMode.SHADER</codeph> без предварительного задания свойства <codeph>blendShader</codeph>, то свойство <codeph>blendMode</codeph> примет значение <codeph>BlendMode.NORMAL</codeph>.</entry>
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\DisplayObject.blendMode.1.as"> Следующий код создает два объекта sprite, квадрат и круг: для круга (в фоне) задается режим наложения<codeph>BlendMode.SUBTRACT</codeph>, когда на него наводится указатель.
<codeblock>
import flash.display.Sprite;
import flash.display.BlendMode;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF88CC);
square.graphics.drawRect(0, 0, 80, 80);
addChild(square);

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.SUBTRACT;
}

function restoreObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.NORMAL;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>blendShader</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:cacheAsBitmap:get"><apiName>cacheAsBitmap</apiName><shortdesc>
     При значении true проигрыватель Flash Player или Adobe AIR кэширует внутреннее растровое представление экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Задает необходимость кэширования этого объекта DisplayObject в виде растрового изображения.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     При значении <codeph>true</codeph> проигрыватель Flash Player или Adobe AIR кэширует внутреннее растровое представление экранного объекта. Такое кэширование может повысить производительность для экранных объектов со сложным векторным содержимым.
     
     <p>Все векторные данные для экранного объекта, имеющего кэшированный растр, вырисовываются в растровом изображении, а не в основной области отображения. Затем это растровое изображение копируется в основную область отображения в виде пикселей без растяжений и поворотов, которые привязываются к ближайшим пиксельным границам. Пиксели отображаются в точном соответствии с вышестоящим объектом. При изменении границ растрового изображения оно не растягивается, а создается повторно.</p>
     
     <p>Внутреннее растровое представление создается, только если свойство <codeph>cacheAsBitmap</codeph> имеет значение <codeph>true</codeph>.</p>
     
     <p>После задания свойству <codeph>cacheAsBitmap</codeph> значения <codeph>true</codeph> визуализация остается без изменений, однако экранный объект автоматически выполняет привязку к пикселям. Скорость анимации может значительно увеличиться в зависимости от сложности векторного содержимого.
     </p>
     
     <p>Свойство <codeph>cacheAsBitmap</codeph> автоматически получает значение <codeph>true</codeph> каждый раз, когда к экранному объекту применяется фильтр (при непустом массиве <codeph>filter</codeph>). Если к экранному объекту применяется фильтр, его свойство <codeph>cacheAsBitmap</codeph> отражается в значении <codeph>true</codeph>, даже если ему было задано значение <codeph>false</codeph>. Если удалить все фильтры экранного объекта, параметр <codeph>cacheAsBitmap</codeph> вернется к последнему заданному значению.</p>
     
     <p>В следующих случаях экранный объект не использует растровое изображение, даже если свойство <codeph>cacheAsBitmap</codeph> имеет значение <codeph>true</codeph>, а вместо этого визуализирует векторные данные:</p>
     
     <ul>
     
       <li>Растровое изображение слишком большое. В AIR 1.5 и Flash Player 10 максимальный размер растрового изображения составляет 8,191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16,777,215. (Т.е. если ширина растрового изображения составляет 8,191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину.</li>
     
       <li>Не удается выделить память для растрового изображения (с выдачей ошибки нехватки памяти). </li>
     
     </ul>
     
     <p>Свойство <codeph>cacheAsBitmap</codeph> лучше всего использовать для фрагментов роликов, в которых преобладает статичное содержимое и редко используется масштабирование и поворот. Использование в таких фрагментах роликов свойства <codeph>cacheAsBitmap</codeph> может повысить производительность при преобразовании фрагмента ролика (при изменении координат <i>x</i> и <i>y</i>).</p>
     
     </apiDesc><example conref="examples\DisplayObject.cacheAsBitmap.1.as"> В следующем примере к экземпляру Shape применяется тень. Затем отслеживается значение свойства <codeph>cacheAsBitmap</codeph>, которое получает значение <codeph>true</codeph> при применении фильтра.
<codeblock>
import flash.display.Sprite;
import flash.filters.DropShadowFilter

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);

addChild(circle);

trace(circle.cacheAsBitmap); // false

var filter:DropShadowFilter = new DropShadowFilter();
circle.filters = [filter];

trace(circle.cacheAsBitmap); // true
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:filters:get"><apiName>filters</apiName><shortdesc>
     Индексированный массив, который содержит все объекты filter, связанные в настоящий момент с экранным объектом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Если в <codeph>filters</codeph> входит ShaderFilter, и тип выхода затенения не совместим с данной операцией (затенение должно задать выход <codeph>pixel4</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если в <codeph>filters</codeph> входит ShaderFilter, и затенение не задает ни одного входного изображения, или если первичный вход не является входом <codeph>image4</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если в <codeph>filters</codeph> входит ShaderFilter, и затенение задает неподдерживаемое входное изображение.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если в <codeph>filters</codeph> входит ShaderFilter, ByteArray или Vector. В качестве ввода затенения используется экземпляр &lt;Number>, а свойства <codeph>width</codeph> и <codeph>height</codeph> для ShaderInput не указаны, или их значения не соответствуют входным данным. Дополнительные сведения см. в описании <codeph>ShaderInput.input</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Индексированный массив, который содержит все объекты filter, связанные в настоящий момент с экранным объектом. Пакет flash.filters содержит несколько классов, определяющих конкретные фильтры, доступные для использования.
     
     <p>Фильтры можно применять в ходе работы в инструменте разработки Flash или во время выполнения с использованием кода ActionScript. Чтобы применить фильтр с помощью ActionScript, необходимо создать временную копию всего массива <codeph>filters</codeph>, внести в нее необходимые изменения, а затем присвоить полученное значение исходному массиву <codeph>filters</codeph>. Нельзя добавлять новый объект filter напрямую в массив <codeph>filters</codeph>.</p>
     
     <p>Чтобы добавить фильтр с помощью ActionScript, выполните следующие действия (предположим, что целевой экранный объект называется <codeph>myDisplayObject</codeph>).</p>
     
     <ol>
     
       <li>Создайте новый объект filter с помощью метода конструктора выбранного класса фильтра.</li>
     
       <li>Присвойте значение массива <codeph>myDisplayObject.filters</codeph> временному массиву, например, массиву с именем <codeph>myFilters</codeph>.</li>
     
       <li>Добавьте новый объект filter во временный массив <codeph>myFilters</codeph>.</li>
     
       <li>Присвойте значение временного массива массиву<codeph>myDisplayObject.filters</codeph>.</li>
     
     </ol>
     
     <p>Если массив <codeph>filters</codeph> не определен, то временный массив использовать не требуется. Вместо этого можно напрямую присвоить литерал массива, содержащий один или несколько созданных вами объектов filter. В первом примере раздела «Примеры» добавляется фильтр «Тень» с помощью кода, обрабатывающего определенный и неопределенный массивы <codeph>filters</codeph>.</p>
     
     <p>Чтобы изменить существующий объект filter, необходимо использовать прием изменения копии массива <codeph>filters</codeph>.</p>
     
     <ol>
     
       <li>Присвойте значение массива <codeph>filters</codeph> временному массиву, например, массиву с именем <codeph>myFilters</codeph>.</li>
     
       <li>Модифицируйте свойство с помощью временного массива с именем <codeph>myFilters</codeph>. Например, чтобы настроить свойство quality первого фильтра массива, можно использовать следующий код: <codeph>myFilters[0].quality = 1;</codeph></li>
     
       <li>Присвойте значение временного массива массиву<codeph>filters</codeph>.</li>
     
     </ol>
     
     <p>Если экранный объект имеет соответствующий фильтр, то во время загрузки он помечается для кэширования в виде прозрачного растрового изображения. С этого момента проигрыватель кэширует экранный объект в виде растрового изображения, если этот объект имеет действительный список фильтров. Исходное растровое изображение используется в качестве источника для эффектов фильтра. Каждый экранный объект, как правило, имеет два растровых изображения: одно с исходным нефильтрованным экранным объектом, а другой для конечного изображения, полученного после фильтрации. Конечное изображение используется при визуализации. Если экранный объект не изменяется, конечное изображение не обновляется.</p>
     
     <p>Пакет flash.filters включает классы фильтров. Например, чтобы создать фильтр DropShadow, необходимо использовать код:</p>
     
     <codeblock>
     import flash.filters.DropShadowFilter
     var myFilter:DropShadowFilter = new DropShadowFilter (distance, angle, color, alpha, blurX, blurY, quality, inner, knockout)
     </codeblock>
     
     <p>Можно использовать оператор <codeph>is</codeph>, чтобы определить тип фильтра, присвоенного для каждой позиции индекса в массиве <codeph>filter</codeph>. На примере следующего кода показывается, как определить положение первого фильтра в массиве <codeph>filters</codeph> – DropShadowFilter.
     </p>
     
     <codeblock>
     import flash.text.TextField;
     import flash.filters.~~;
     var tf:TextField = new TextField();
     var filter1:DropShadowFilter = new DropShadowFilter();
     var filter2:GradientGlowFilter = new GradientGlowFilter();
     tf.filters = [filter1, filter2];
     
     tf.text = "DropShadow index: " + filterPosition(tf, DropShadowFilter).toString(); // 0
     addChild(tf)
     
     function filterPosition(displayObject:DisplayObject, filterClass:Class):int {
         for (var i:uint = 0; i &lt; displayObject.filters.length; i++) {
             if (displayObject.filters[i] is filterClass) {
                 return i;
             }
         }
         return -1;
     }
     </codeblock>
     <p><b>Примечание.</b> Так как нельзя добавить новый объект filter напрямую в массив <codeph>DisplayObject.filters</codeph>, следующий код не окажет действия на целевой экранный объект с именем<codeph>myDisplayObject</codeph>.</p>
     
     <codeblock>
     myDisplayObject.filters.push(myDropShadow);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="../../flash/filters/package-detail.html"><linktext>пакет flash.filters</linktext></link><link href="flash.display.xml#ShaderInput/input"><linktext>flash.display.ShaderInput.input</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:height:get"><apiName>height</apiName><shortdesc>
     Указывает высоту экранного объекта в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает высоту экранного объекта в пикселях. Высота вычисляется на основе границ содержимого экранного объекта. Когда задается свойство <codeph>height</codeph>, соответствующим образом изменяется и свойство <codeph>scaleY</codeph>, как показано в следующем коде.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>За исключением объектов TextField и Video, экранные объекты без содержимого (например, пустой спрайт), имеют высоту 0, даже если задать свойству <codeph>height</codeph> другое значение.</p>
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> Следующий код создает два объекта TextField и изменяет свойство <codeph>height</codeph> каждого из них на основе их свойства <codeph>textHeight</codeph>; также путем задания свойства <codeph>y</codeph> определяется положение второго текстового поля.
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
     Возвращает объект LoaderInfo, содержащий сведения о загрузке файла, к которому принадлежит этот экранный объект.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает объект LoaderInfo, содержащий сведения о загрузке файла, к которому принадлежит этот экранный объект. Свойство <codeph>loaderInfo</codeph> определяется только для корневого экранного объекта SWF-файла или для загруженного объекта Bitmap (а не нарисованного с помощью ActionScript). Чтобы найти объект <codeph>loaderInfo</codeph>, связанный с SWF-файлом, содержащим экранный объект с именем <codeph>myDisplayObject</codeph>, используйте <codeph>myDisplayObject.root.loaderInfo</codeph>.
     
     <p>Загрузку большого SWF-файла можно отслеживать с помощью метода <codeph>this.root.loaderInfo.addEventListener(Event.COMPLETE, func)</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.loaderInfo.1.as"> Следующий код предполагает, что <codeph>this</codeph> относится к экранному объекту. Код выдает URL корневого SWF-файла для экранного объекта.
<codeblock>
 trace (this.loaderInfo.url);
 
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>Класс LoaderInfo</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:mask:get"><apiName>mask</apiName><shortdesc>
     Вызывающий экранный объект маскируется заданным объектом mask.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Задает маску для экранного объекта.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Вызывающий экранный объект маскируется заданным объектом <codeph>mask</codeph>. Чтобы обеспечить маскирование при масштабировании рабочей области, экранный объект <codeph>mask</codeph> должен быть активным элементом списка отображения. Сам объект <codeph>mask</codeph> не отображается. Чтобы удалить маску, нужно задать для <codeph>mask</codeph> значение <codeph>null</codeph>.
     
     <p>Чтобы обеспечить масштабирование объекта mask, его необходимо добавить в список отображения. Чтобы обеспечить возможность перетаскивания маскирующего объекта Sprite (вызовом метода<codeph>startDrag()</codeph>), его необходимо добавить в список отображения. Чтобы вызвать метод <codeph>startDrag()</codeph> для маскирующего спрайта при отправке им события <codeph>mouseDown</codeph>, задайте свойству спрайта <codeph>buttonMode</codeph> свойство <codeph>true</codeph>.</p>
     
     <p><b>Примечание.</b> Один объект <codeph>mask</codeph> не может использоваться для маскирования нескольких вызывающих экранных объектов. Когда <codeph>mask</codeph> назначается второму экранному объекту, он перестает быть маской первого, для которого свойство <codeph>mask</codeph> получает значение <codeph>null</codeph>.</p>  
     
     </apiDesc><example conref="examples\DisplayObject.mask.1.as"> Следующий код создает объект TextField и объект Sprite, назначенный в качестве маски объекту TextField. Когда пользователь щелкает текстовое поле, прослушиватель событий <codeph>drag()</codeph> вызывает метод <codeph>startDrag()</codeph> маскирующего объекта Sprite.
<codeblock>
import flash.text.TextField;
import flash.display.Sprite;
import flash.events.MouseEvent;

var tf:TextField = new TextField();
tf.text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " 
            + "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
tf.selectable = false;
tf.wordWrap = true;
tf.width = 150;
addChild(tf);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 40, 40);
addChild(square);

tf.mask = square;

tf.addEventListener(MouseEvent.MOUSE_DOWN, drag);
tf.addEventListener(MouseEvent.MOUSE_UP, noDrag);

function drag(event:MouseEvent):void {
    square.startDrag();
}
function noDrag(event:MouseEvent):void {
    square.stopDrag();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseX:get"><apiName>mouseX</apiName><shortdesc>
     Указывает координату x положения курсора мыши (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает координату x положения курсора мыши (в пикселях).
     
     <p><b>Примечание</b>. Для повернутого объекта DisplayObject возвращенная координата x будет характеризовать объект, поворот которого не выполнен.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> Следующий код создает объект Sprite и отслеживает положения <codeph>mouseX</codeph> и <codeph>mouseY</codeph>, когда пользователь щелкает спрайт.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseY:get"><apiName>mouseY</apiName><shortdesc>
     Указывает координату y положения курсора мыши (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает координату y положения курсора мыши (в пикселях).
     
     <p><b>Примечание</b>. Для повернутого объекта DisplayObject возвращенная координата y будет характеризовать объект, поворот которого не выполнен.</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> Следующий код создает объект Sprite и отслеживает положения <codeph>mouseX</codeph> и <codeph>mouseY</codeph>, когда пользователь щелкает спрайт.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:name:get"><apiName>name</apiName><shortdesc>
     Указывает имя экземпляра DisplayObject.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>При попытке задать это свойство для объекта, помещенного на временную шкалу инструмента разработки Flash.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Имя этого объекта DisplayObject.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Указывает имя экземпляра DisplayObject. Объект можно найти в списке потомков родительского контейнера экранных объектов путем вызова метода <codeph>getChildByName()</codeph> контейнера.
     
     </apiDesc><example conref="examples\DisplayObject.name.1.as"> Следующий код создает два объекта Sprite и отслеживает соответствующее свойство <codeph>name</codeph>, когда пользователь щелкает один из них.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.name = "circle1";
addChild(circle1);
circle1.addEventListener(MouseEvent.CLICK, traceName);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x0000FF);
circle2.graphics.drawCircle(140, 40, 40);
circle2.name = "circle2";
addChild(circle2);
circle2.addEventListener(MouseEvent.CLICK, traceName);

function traceName(event:MouseEvent):void {
    trace(event.target.name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:opaqueBackground:get"><apiName>opaqueBackground</apiName><shortdesc>
     Определяет, является ли экранный объект непрозрачным с определенным цветом фона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, является ли экранный объект непрозрачным с определенным цветом фона. Прозрачное растровое изображение содержит данные альфа-канала и рисуется прозрачным. Непрозрачное растровое изображение не имеет альфа-канала (и визуализируется быстрее, чем прозрачное изображение). Если растровое изображение непрозрачное, требуется задать для него собственный цвет фона.
     
     <p>Если задать численное значение, поверхность будет непрозрачной, а RGB-цвет фона будет соответствовать заданному числу. Если оставить значение по умолчанию <codeph>null</codeph>, у экранного объекта будет прозрачный фон.</p>
     
     <p>Свойство <codeph>opaqueBackground</codeph> предназначено, главным образом, для использования вместе со свойством <codeph>cacheAsBitmap</codeph> с целью оптимизации визуализации. Для экранных объектов со свойством <codeph>cacheAsBitmap</codeph> в значении true настройка свойства <codeph>opaqueBackground</codeph> может повысить производительность.</p>
     
     <p>Непрозрачная область фона <i>не</i> сопоставляется при вызове метода <codeph>hitTestPoint()</codeph> с параметром <codeph>shapeFlag</codeph> в значении <codeph>true</codeph>.</p>
     
     <p>Непрозрачная область фона не реагирует на события мыши.</p>
     
     </apiDesc><example conref="examples\DisplayObject.opaqueBackground.1.as"> Следующий код создает объект Shape с синим кругом и задает свойству <codeph>opaqueBackground</codeph> значение 0xFF0000 (красный).
<codeblock>
import flash.display.Shape;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.opaqueBackground = 0xFF0000;
addChild(circle);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/hitTestPoint()"><linktext>hitTestPoint()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:parent:get"><apiName>parent</apiName><shortdesc>
     Указывает объект DisplayObjectContainer, содержащий данный экранный объект.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObjectContainer</apiValueClassifier><apiException><apiDesc>Данный вышестоящий экранный объект принадлежит изолированной программной среде, к которой нет доступа. Чтобы избежать такой ситуации, родительский ролик должен вызвать метод <codeph>Security.allowDomain()</codeph>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Указывает объект DisplayObjectContainer, содержащий данный экранный объект. Используйте свойство <codeph>parent</codeph>, чтобы задать относительный путь к экранным объектам, находящимся на более высоких уровнях иерархии списка отображения, чем текущий объект.
     
     <p>Свойство <codeph>parent</codeph> можно использовать для перемещения объекта вверх на несколько уровней в списке отображения, как показано ниже.</p>
     
     <codeblock>
     this.parent.parent.alpha = 20;
     </codeblock>
     
     </apiDesc><example conref="examples\DisplayObject.parent.1.as"> Следующий код создает три объекта Sprite; на его примере видно, как свойство <codeph>parent</codeph> отражает иерархию списка отображения.
<codeblock>

import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite2.parent.name); // sprite1
trace(sprite3.parent.name); // sprite2
trace(sprite3.parent.parent.name); // sprite1
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:root:get"><apiName>root</apiName><shortdesc>
     В случае с экранным объектом в загруженном SWF-файле свойством root является самый верхний экранный объект в части структуры дерева списка отображения, представленной этим SWF-файлом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Возвращает корневой экранный объект для данного объекта.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     В случае с экранным объектом в загруженном SWF-файле свойством <codeph>root</codeph> является самый верхний экранный объект в части структуры дерева списка отображения, представленной этим SWF-файлом. Для объекта Bitmap, представляющего файл загруженного изображения, свойством <codeph>root</codeph> является сам объект Bitmap. Для экземпляра основного класса первого загруженного SWF-файла свойством <codeph>root</codeph> является сам экранный объект. Свойством <codeph>root</codeph> объекта Stage является сам объект Stage. Свойство <codeph>root</codeph> имеет значение <codeph>null</codeph> для экранных объектов, не добавленных в список отображения, если они не добавлены в контейнер экранных объектов, не включенный в список отображения, но являющийся нижестоящим элементом экранного объекта верхнего уровня в загруженном SWF-файле.
     
     <p>Например, если создается новый объект Sprite путем вызова метода конструктора <codeph>Sprite()</codeph>, его свойство <codeph>root</codeph> имеет значение <codeph>null</codeph> до тех пор, пока он не будет добавлен в список отображения (или в контейнер экранных объектов, не включенный в список отображения, но являющийся потомком экранного объекта верхнего уровня в SWF-файле).</p>
     
     <p>Для загруженного SWF-файла, несмотря на то, что объект Loader, использованный для загрузки, может не входить в список отображения, свойством <codeph>root</codeph> экранного объекта верхнего уровня этого файла является сам объект. Свойство <codeph>root</codeph> объекта Loader не задается, пока он не будет добавлен в качестве потомка экранного объекта, для которого уже задано свойство <codeph>root</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.root.1.as"> На примере следующего кода показано различие между свойствами <codeph>root</codeph> объекта Stage, незагруженного экранного объекта (Loader) (до и после добавления в список отображения) и загруженного объекта (Bitmap).
<codeblock>
import flash.display.Loader;
import flash.net.URLRequest;
import flash.events.Event;

trace(stage.root); // [object Stage]

var ldr:Loader = new Loader();
trace (ldr.root); // null

addChild(ldr); 
trace (ldr.root); // [object ...]

var urlReq:URLRequest = new URLRequest("example.jpg");
ldr.load(urlReq);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void {
    trace(ldr.content.root); // [object Bitmap]
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotation:get"><apiName>rotation</apiName><shortdesc>
     Указывает поворот экземпляра DisplayObject относительно его исходной ориентации (в градусах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает поворот экземпляра DisplayObject относительно его исходной ориентации (в градусах). Значения от 0 до 180 представляют поворот по часовой стрелке. Значения от 0 до -180 представляют поворот против часовой стрелки. Значения за пределами этого диапазона, добавляются или вычитаются из 360 для получения допустимого значения. Например, инструкция <codeph>my_video.rotation = 450</codeph> равносильна <codeph> my_video.rotation = 90</codeph>.
     
     </apiDesc><example conref="examples\DisplayObject.rotation.1.as"> В следующем примере создается объект Sprite, который поворачивается при щелчке пользователя.
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(-50, -50, 100, 100);
square.x = 150;
square.y = 150;
addChild(square);

square.addEventListener(MouseEvent.CLICK, rotate);

function rotate(event:MouseEvent):void {
        square.rotation += 15;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationX:get"><apiName>rotationX</apiName><shortdesc>
     Обозначает поворот в градусах по оси x экземпляра DisplayObject относительно исходной ориентации по трехмерному вышестоящему контейнеру.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Обозначает поворот в градусах по оси x экземпляра DisplayObject относительно исходной ориентации по трехмерному вышестоящему контейнеру. Значения от 0 до 180 представляют поворот по часовой стрелке. Значения от 0 до -180 представляют поворот против часовой стрелки. Значения за пределами этого диапазона, добавляются или вычитаются из 360 для получения допустимого значения.
     
     </apiDesc><example conref="examples\RotationExample1.as"> В данном примере два эллипса вращаются в соответствии со значениями свойств <codeph>rotationX</codeph> и <codeph>rotationY</codeph>. Точка регистрации первого эллипса находится в центре. Он вращается вокруг своей оси. Второй эллипс вращается вокруг внешней точки. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationY:get"><apiName>rotationY</apiName><shortdesc>
     Обозначает поворот в градусах по оси у экземпляра DisplayObject от исходной ориентации относительно трехмерного вышестоящего контейнера.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Обозначает поворот в градусах по оси у экземпляра DisplayObject от исходной ориентации относительно трехмерного вышестоящего контейнера. Значения от 0 до 180 задают поворот по часовой стрелке. Значения от 0 до -180 задают поворот против часовой стрелки. Значения за пределами этого диапазона, добавляются или вычитаются из 360 для получения допустимого значения.
     
     
     </apiDesc><example conref="examples\RotationExample1.as"> В данном примере два эллипса вращаются в соответствии со значениями свойств <codeph>rotationX</codeph> и <codeph>rotationY</codeph>. Точка регистрации первого эллипса находится в центре. Он вращается вокруг своей оси. Второй эллипс вращается вокруг внешней точки. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationZ:get"><apiName>rotationZ</apiName><shortdesc>
     Обозначает поворот в градусах по оси z экземпляра DisplayObject от исходной ориентации относительно трехмерного вышестоящего контейнера.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Обозначает поворот в градусах по оси z экземпляра DisplayObject от исходной ориентации относительно трехмерного вышестоящего контейнера. Значения от 0 до 180 представляют поворот по часовой стрелке. Значения от 0 до -180 представляют поворот против часовой стрелки. Значения за пределами этого диапазона, добавляются или вычитаются из 360 для получения допустимого значения.
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scale9Grid:get"><apiName>scale9Grid</apiName><shortdesc>
     Текущая активная сетка масштабирования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following creates a movie clip that contains a 20-pixel line (which forms a border)
     and a gradient fill. The movie clip scales based on the mouse position, and because of the
     <code>scale9Grid</code> set for the movie clip, the thickness of the 20-pixel line does not
     vary when the clip scales (although the gradient in the movie clip <em>does</em> scale):
     
     <listing version="2.0">
     import flash.geom.Rectangle;
     import flash.geom.Matrix;
     
     this.createEmptyMovieClip("my_mc", this.getNextHighestDepth());
     
     var grid:Rectangle = new Rectangle(20, 20, 260, 260);
     my_mc.scale9Grid = grid ;
     
     my_mc._x = 50;
     my_mc._y = 50;
     
     function onMouseMove()
     {
      my_mc._width  = _xmouse;
      my_mc._height = _ymouse;
     }
     
     my_mc.lineStyle(20, 0xff3333, 100);
     var gradient_matrix:Matrix = new Matrix();
     gradient_matrix.createGradientBox(15, 15, Math.PI, 10, 10);
     my_mc.beginGradientFill("radial", [0xffff00, 0x0000ff],
              [100, 100], [0, 0xFF], gradient_matrix,
              "reflect", "RGB", 0.9);
     my_mc.moveTo(0, 0);
     my_mc.lineTo(0, 300);
     my_mc.lineTo(300, 300);
     my_mc.lineTo(300, 0);
     my_mc.lineTo(0, 0);
     my_mc.endFill();
     </listing>
     
     </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>Если методу передается недопустимый аргумент.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Текущая активная сетка масштабирования. Если установлено значение <codeph>null</codeph>, весь объект отображения масштабируется в обычном порядке при применении любых преобразований масштаба.
     
     <p>При определении свойства <codeph>scale9Grid</codeph> экранный объект разбивается на сетку с девятью областями на основе прямоугольника <codeph>scale9Grid</codeph>, определяющего центральную область сетки. Восемь остальных областей сетки: </p>
     
     <ul>
       <li>Верхний левый угол за пределами прямоугольника</li>
       <li>Область над прямоугольником </li>
       <li>Верхний правый угол за пределами прямоугольника</li>
       <li>Область слева от прямоугольника</li>
       <li>Область справа от прямоугольника</li>
       <li>Нижний левый угол за пределами прямоугольника</li>
       <li>Область под прямоугольником</li>
       <li>Нижний правый угол за пределами прямоугольника</li>
     </ul>
     
     <p>Восемь областей за пределами центра (ограниченного прямоугольником) можно рассматривать как рамку изображения, к которому при масштабировании применяются особые правила.</p>
     
     <p>При масштабировании объекта отображения с определенным свойством <codeph>scale9Grid</codeph> текст и градиенты масштабируются в обычном порядке, однако к остальным типам объектов применяются следующие правила.</p>
     
     <ul>
       <li>Содержимое центральной области масштабируется как обычно. </li>
       <li>Содержимое в углах не масштабируется. </li>
       <li>Содержимое в верхней и нижней областях масштабируется только по горизонтали. Содержимое в правой и левой областях масштабируется только по вертикали.</li>
      <li>Все заливки (включая растровые изображения, видео и градиенты) растягиваются в соответствии с новыми размерами.</li>
     </ul>
     
     <p>При повороте экранного объекта последующее масштабирование выполняется в обычном режиме (и свойство <codeph>scale9Grid</codeph> игнорируется).</p>
     
     <p>В качестве примера рассмотрим следующий экранный объект и прямоугольник, применяемый в качестве его свойства <codeph>scale9Grid</codeph></p>
     
     <adobetable>
     
       
     
     <tgroup cols="2"><tbody><row>
      <entry align="center"><adobeimage alt="изображение экранного объекта" href="../../images/scale9Grid-a.jpg"/>
     <p>Экранный объект.</p></entry>
     
      <entry align="center"><adobeimage alt="область scale 9 экранного объекта" href="../../images/scale9Grid-b.jpg"/>
      <p>Красный прямоугольник показывает <codeph>scale9Grid</codeph>.</p></entry>
       </row></tbody></tgroup></adobetable>
     
     <p>При масштабировании или растягивании экранного объекта объекты в пределах прямоугольника масштабируются в обычном порядке, а объекты за его пределами масштабируются согласно правилам <codeph>scale9Grid</codeph>.</p>
     
     <adobetable>
      
     
      
     
      
     
      
     
     <tgroup cols="2"><tbody><row>
      <entry>Масштабируется до 75%</entry>
      <entry><adobeimage alt="экранный объект на 75%" href="../../images/scale9Grid-c.jpg"/></entry>
      </row><row>
      <entry>Масштабируется до 50%</entry>
      <entry><adobeimage alt="экранный объект на 50%" href="../../images/scale9Grid-d.jpg"/></entry>
      </row><row>
      <entry>Масштабируется до 25%</entry>
      <entry><adobeimage alt="экранный объект на 25%" href="../../images/scale9Grid-e.jpg"/></entry>
      </row><row>
      <entry>Вытягивается по горизонтали до 150% </entry>
      <entry><adobeimage alt="экранный объект, растянутый до 150%" href="../../images/scale9Grid-f.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     
     <p>Как правило, параметр<codeph>scale9Grid</codeph> используется для установки экранного объекта в качестве компонента, области краев которого сохраняют ширину при масштабировании компонента.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scale9Grid.1.as"> Следующий код создает объект Shape, в свойстве <codeph>graphics</codeph> которого отображается прямоугольник. Прямоугольник имеет границу шириной 20 пикселей и заполнен градиентом. Событие timer вызывает функцию <codeph>scale()</codeph>, которая масштабирует объект Shape путем корректировки свойств <codeph>scaleX</codeph> и <codeph>scaleY</codeph>. Применение <codeph>scale9Grid</codeph> к объекту Shape предотвращает масштабирование линий границ прямоугольника; масштабируется только заливка градиентом.
<codeblock>

import flash.display.Shape;
import flash.display.GradientType;
import flash.display.SpreadMethod;
import flash.display.InterpolationMethod;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var square:Shape = new Shape();
square.graphics.lineStyle(20, 0xFFCC00);
var gradientMatrix:Matrix = new Matrix();
gradientMatrix.createGradientBox(15, 15, Math.PI, 10, 10);
square.graphics.beginGradientFill(GradientType.RADIAL, 
            [0xffff00, 0x0000ff], 
            [100, 100], 
            [0, 0xFF], 
            gradientMatrix, 
            SpreadMethod.REFLECT, 
            InterpolationMethod.RGB, 
            0.9);
square.graphics.drawRect(0, 0, 100, 100);

var grid:Rectangle = new Rectangle(20, 20, 60, 60);
square.scale9Grid = grid ;

addChild(square);

var tim:Timer = new Timer(100);
tim.start();
tim.addEventListener(TimerEvent.TIMER, scale);

var scaleFactor:Number = 1.01;

function scale(event:TimerEvent):void {
    square.scaleX *= scaleFactor;
    square.scaleY *= scaleFactor;
    
    if (square.scaleX > 2.0) {
        scaleFactor = 0.99;
    }
    if (square.scaleX &lt; 1.0) {
        scaleFactor = 1.01;
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scaleX:get"><apiName>scaleX</apiName><shortdesc>
     Указывает горизонтальное масштабирование объекта от точки регистрации (в процентах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает горизонтальное масштабирование объекта от точки регистрации (в процентах). Точка регистрации по умолчанию – (0,0). 1,0 соответствует масштабу 100%.
     
     <p>Масштабирование локальной системы координат изменяет значения свойств <codeph>x</codeph> и <codeph>y</codeph>, определяемые в целых пикселях. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> Следующий код создает объект Sprite, в свойстве <codeph>graphics</codeph> которого отображается прямоугольник. При щелчке пользователя спрайт масштабируется на 10%.
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleY:get"><apiName>scaleY</apiName><shortdesc>
     Указывает вертикальное масштабирование объекта от точки регистрации (в процентах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает вертикальное масштабирование объекта от точки регистрации (в процентах). Точка регистрации по умолчанию – (0,0). 1,0 соответствует масштабу 100%.
     
     <p>Масштабирование локальной системы координат изменяет значения свойств <codeph>x</codeph> и <codeph>y</codeph>, определяемые в целых пикселях. </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> Следующий код создает объект Sprite, в свойстве <codeph>graphics</codeph> которого отображается прямоугольник. При щелчке пользователя спрайт масштабируется на 10%.
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleZ:get"><apiName>scaleZ</apiName><shortdesc>
     Указывает глубину масштабирования объекта (в процентах) относительно точки регистрации этого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает глубину масштабирования объекта (в процентах) относительно точки регистрации этого объекта. Точка регистрации по умолчанию – (0,0). 1,0 равняется масштабу 100%.
     
     <p>Масштабирование локальной системы координат изменяет значения свойств <codeph>x</codeph>, <codeph>y</codeph> и <codeph>z</codeph>, определяемые в целых пикселях. </p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/z"><linktext>z</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scrollRect:get"><apiName>scrollRect</apiName><shortdesc>
     Прямоугольная область прокрутки экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     Прямоугольная область прокрутки экранного объекта. Экранный объект обрезается до размера, определенного прямоугольником, и прокручивается в его границах при изменении свойств <codeph>x</codeph> и <codeph>y</codeph> объекта <codeph>scrollRect</codeph>.
     
     <p>Свойства объекта <codeph>scrollRect</codeph> объекта Rectangle используют координатную плоскость экранного объекта и масштабируются просто как общий экранный объект. Углы обрезанного окна на экранном объекте прокрутки являются исходной точкой экранного объекта (0,0) и точкой, определенной шириной и высотой прямоугольника. Они не центрируются по исходной точке, а используют ее для определения верхнего левого угла области. Прокручиваемый экранный объект всегда прокручивается прибавлениями по целым пикселям. </p>
     
     <p>Можно прокручивать объект влево и вправо, настроив свойство <codeph>x</codeph> для <codeph>scrollRect</codeph> объекта Rectangle. Чтобы прокручивать объект вверх и вниз, нужно настроить свойство <codeph>y</codeph> для <codeph>scrollRect</codeph> объекта Rectangle. Если экранный объект, повернутый на 90°, прокручивается влево и вправо, на самом деле экранный объект прокручивается вверх и вниз.</p>
     
     </apiDesc><example conref="examples\DisplayObject.scrollRect.1.as"> Далее показан пример того, как свойство <codeph>scrollRect</codeph> задает область прокрутки экранного объекта <codeph>circle</codeph>. При щелчке по объекту <codeph>circle</codeph> метод обработчика событий <codeph>clicked()</codeph> корректирует свойство <codeph>y</codeph> свойства <codeph>scrollRect</codeph> объекта <codeph>circle</codeph>, в результате чего осуществляется прокрутка вниз.
<codeblock>

import flash.display.Sprite;
import flash.geom.Rectangle;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(200, 200, 200);
circle.scrollRect = new Rectangle(0, 0, 200, 200);
addChild(circle);

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    var rect:Rectangle = event.target.scrollRect;
    rect.y -= 5;
    event.target.scrollRect = rect;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:stage:get"><apiName>stage</apiName><shortdesc>
     Класс Stage экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
     Класс Stage экранного объекта. Приложение Flash имеет только один объект Stage. Например, можно создать и загрузить в список отображения несколько экранных объектов, и для каждого из них свойство <codeph>stage</codeph> будет ссылаться на один и тот же объект Stage (даже если экранный объект принадлежит загруженному SWF-файлу).
     
     <p>Если экранный объект не добавлен в список отображения, его свойство <codeph>stage</codeph> имеет значение <codeph>null</codeph>.</p>
     
     </apiDesc><example conref="examples\DisplayObject.stage.1.as"> Следующий код создает два объекта TextField и использует свойство <codeph>width</codeph> объекта Stage для размещения текстовых полей.
<codeblock>

import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.x = 10;
addChild(tf1);
tf1.width = tf1.stage.stageWidth / 2 - 10;

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.x = tf1.x + tf1.width + 5;
addChild(tf2);
tf2.width = tf2.stage.stageWidth / 2 - 10;

trace(stage.stageWidth);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:transform:get"><apiName>transform</apiName><shortdesc>
    Объект со свойствами, относящимися к матрице, преобразованию цвета и пиксельным границам экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Transform</apiValueClassifier></apiValueDef><apiDesc>
    Объект со свойствами, относящимися к матрице, преобразованию цвета и пиксельным границам экранного объекта. Конкретные свойства (matrix, colorTransform и три свойства только для чтения (<codeph>concatenatedMatrix</codeph>, <codeph>concatenatedColorTransform</codeph> и <codeph>pixelBounds</codeph>)) описываются в разделе, посвященном классу Transform.
    
    <p>Каждое из свойств объекта transform представляет собой объект. Это очень важно, так как единственным способом задать новые значения для объектов matrix или colorTransform является создание нового объекта и его копирование в свойство transform.matrix или transform.colorTransform.</p>
    
    <p>Например, чтобы увеличить значение <codeph>tx</codeph> матрицы экранного объекта, необходимо скопировать весь объект matrix, а затем копировать новый объект в свойство matrix объекта transform.</p>
    
    <pre><codeph>
    var myMatrix:Matrix = myDisplayObject.transform.matrix;  
    myMatrix.tx += 10; 
    myDisplayObject.transform.matrix = myMatrix;  
    </codeph></pre>
    
    <p>Свойство <codeph>tx</codeph> нельзя задавать напрямую. Следующий код не действует на <codeph>myDisplayObject</codeph>. </p>
    
    <pre><codeph>
    myDisplayObject.transform.matrix.tx += 10;
    </codeph></pre>
    
    <p>Также можно копировать весь объект transform и назначить его свойству transform другого экранного объекта. Например, следующий код копирует весь объект transform из <codeph>myOldDisplayObj</codeph> в <codeph>myNewDisplayObj</codeph>.</p>
    <codeph>myNewDisplayObj.transform = myOldDisplayObj.transform;</codeph>
    <p>Полученный экранный объект, <codeph>myNewDisplayObj</codeph>, теперь имеет те же значения для матрицы, преобразования цвета и пиксельных границ, что и старый экранный объект, <codeph>myOldDisplayObj</codeph>.</p>
     
    </apiDesc><example conref="examples\DisplayObject.transform.1.as"> Следующий код создает объект Sprite с именем <codeph>square</codeph>. Когда пользователь щелкает спрайт, метод <codeph>transformer()</codeph> корректирует свойства <codeph>colorTransform</codeph> и <codeph>matrix</codeph> свойства <codeph>transform</codeph> для спрайта.
<codeblock>

import flash.display.Sprite;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Transform;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.lineStyle(20, 0xFF2200);
square.graphics.beginFill(0x0000DD);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

var resultColorTransform:ColorTransform = new ColorTransform();
resultColorTransform.alphaMultiplier = 0.5;
resultColorTransform.redOffset = 155;
resultColorTransform.greenMultiplier = 0.5;

var skewMatrix:Matrix = new Matrix(1, 1, 0, 1);

square.addEventListener(MouseEvent.CLICK, transformer);

function transformer(event:MouseEvent):void {
    var transformation:Transform = square.transform;
    var tempMatrix:Matrix = square.transform.matrix;
    tempMatrix.concat(skewMatrix);
    square.transform.colorTransform = resultColorTransform;
    
    square.transform.matrix = tempMatrix;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Transform"><linktext>Класс Transform</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:visible:get"><apiName>visible</apiName><shortdesc>
     Определяет видимость экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Определяет видимость экранного объекта. Невидимые экранные объекты отключаются. Например, если <codeph>visible=false</codeph> для экземпляра InteractiveObject, то он не реагирует на щелчки мыши.
     
     </apiDesc><example conref="examples\DisplayObject.visible.1.as"> В следующем коде используется объект Timer для вызова функции <codeph>visible</codeph>, которая периодически изменяет свойство экранного объекта, в результате чего создается эффект мигания.
<codeblock>

import flash.text.TextField;
import flash.utils.Timer;
import flash.events.TimerEvent;

var tf:TextField = new TextField();
tf.text = "Hello.";
addChild(tf);

var tim:Timer = new Timer(250);
tim.start();
tim.addEventListener(TimerEvent.TIMER, blinker);

function blinker(event:TimerEvent):void {
    tf.visible = !tf.visible;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:width:get"><apiName>width</apiName><shortdesc>
     Указывает ширину экранного объекта в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает ширину экранного объекта в пикселях. Ширина вычисляется на основе границ содержимого экранного объекта. Когда задается свойство <codeph>width</codeph>, соответствующим образом изменяется и свойство <codeph>scaleX</codeph>, как показано в следующем коде.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>За исключением объектов TextField и Video, экранные объекты без содержимого (например, пустой спрайт), имеют ширину 0, даже если задать свойству <codeph>width</codeph> другое значение.</p>
     
     </apiDesc><example conref="examples\DisplayObject.width.1.as"> Следующий код создает объект Sprite с именем <codeph>square</codeph>. Когда пользователь щелкает спрайт, метод <codeph>widen()</codeph> увеличивает значение его свойства <codeph>width</codeph>.
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, widen);

function widen(event:MouseEvent):void {
    square.width += 10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:x:get"><apiName>x</apiName><shortdesc>
     Указывает координату x экземпляра DisplayObject, связанную с локальными координатами вышестоящего DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает координату <i>x</i> экземпляра DisplayObject, связанную с локальными координатами вышестоящего DisplayObjectContainer. Если объект включен в DisplayObjectContainer с преобразованиями, то он находится в локальной системе координат содержащего его DisplayObjectContainer. Таким образом, если объект DisplayObjectContainer повернут на 90° против часовой стрелки, нижестоящие элементы наследуют систему координат с поворотом на 90° против часовой стрелки. Координаты объекта определяются относительно положения точки регистрации.
     
     </apiDesc><example conref="examples\DisplayObject.x.1.as"> Следующий код создает объект Sprite с именем <codeph>circle</codeph>. Объект Timer используется для изменения свойства <codeph>x</codeph> спрайта через каждые 50 миллисекунд.
<codeblock>

import flash.display.Sprite;
import flash.utils.Timer;
import flash.events.TimerEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(100, 100, 100);
addChild(circle);

var tim:Timer = new Timer(50);
tim.start();
tim.addEventListener(TimerEvent.TIMER, bounce);

var xInc:Number = 2;

function bounce(event:TimerEvent):void {
    circle.x += xInc;
    if (circle.x > circle.width) {
        xInc = -2;
    }
    if (circle.x &lt; 0) {
        xInc = 2;
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:y:get"><apiName>y</apiName><shortdesc>
     Указывает координату y экземпляра DisplayObject, связанную с локальными координатами вышестоящего DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает координату <i>y</i> экземпляра DisplayObject, связанную с локальными координатами вышестоящего DisplayObjectContainer. Если объект включен в DisplayObjectContainer с преобразованиями, то он находится в локальной системе координат содержащего его DisplayObjectContainer. Таким образом, если объект DisplayObjectContainer повернут на 90° против часовой стрелки, нижестоящие элементы наследуют систему координат с поворотом на 90° против часовой стрелки. Координаты объекта определяются относительно положения точки регистрации.
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> Следующий код создает два объекта TextField и изменяет свойство <codeph>height</codeph> каждого из них на основе их свойства <codeph>textHeight</codeph>; также путем задания свойства <codeph>y</codeph> определяется положение второго текстового поля.
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:z:get"><apiName>z</apiName><shortdesc>
     Указывает положение по оси z экземпляра DisplayObject относительно трехмерного вышестоящего контейнера.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Указывает положение по оси z экземпляра DisplayObject относительно трехмерного вышестоящего контейнера. Свойство z предназначено для работы с трехмерными системами координат, а не с экранными или пиксельными координатами. 
     <p>При установке свойства <codeph>z</codeph> экранного объекта на значение, отличное от значения по умолчанию, равного <codeph>0</codeph>, автоматически создается соответствующий объект Matrix3D. для регулирования положения и ориентации экранного объекта в трехмерном пространстве. При работе с осью z существующее поведение свойств х и у изменяется с экранных или пиксельных координат на положения относительно трехмерного вышестоящего контейнера.</p>
     <p>Например, нижестоящий элемент объекта <codeph>_root</codeph> в положении x = 100, y = 100, z = 200 не отображается в пиксельном положении (100,100). Нижестоящий элемент отображается в месте, определенном путем вычисления трехмерной проекции. Вычисление производится следующим образом:</p>
     <p><codeph> (x~~cameraFocalLength/cameraRelativeZPosition, y~~cameraFocalLength/cameraRelativeZPosition)</codeph></p>
     
     
     </apiDesc><example conref="examples\ZAxisExample1.as"> Данный пример иллюстрирует рисование двух эллипсов, двигающихся туда и обратно (вниз и вверх по оси <codeph>z</codeph>) по направлению к точке схода. Один эллипс двигается быстрее другого. 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.geom.*;

    public class ZAxisExample1 extends MovieClip {
        private var ellipse1Back:int = 1;
        private var ellipse2Back:int = 1;
        private var depth:int = 1000;
        
        public function ZAxisExample1():void {
            
            var ellipse1 = drawEllipse((this.stage.stageWidth / 2) - 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 10);
            var ellipse2 = drawEllipse((this.stage.stageWidth / 2) + 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 300);

            this.addChild(ellipse1);
            this.addChild(ellipse2);
            
            ellipse1.addEventListener(Event.ENTER_FRAME, ellipse1FrameHandler);
            ellipse2.addEventListener(Event.ENTER_FRAME, ellipse2FrameHandler);
        }

        private function drawEllipse(x:Number, y:Number, w:Number, h:Number, z:Number):Shape {
            var s:Shape = new Shape();                            
            s.z = z;
            s.graphics.beginFill(0xFF0000);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(x, y, w, h);
            s.graphics.endFill();
            return s;
        }

        private function ellipse1FrameHandler(e:Event):void {
            ellipse1Back = setDepth(e, ellipse1Back);
            e.currentTarget.z += ellipse1Back * 10;
        }

        private function ellipse2FrameHandler(e:Event):void {
            ellipse2Back = setDepth(e, ellipse2Back);
            e.currentTarget.z += ellipse2Back * 20;
        }

        private function setDepth(e:Event, d:int):int {
            if(e.currentTarget.z > depth) {
                e.currentTarget.z = depth; 
                d = -1;
            }else if (e.currentTarget.z &lt;  0) {
                e.currentTarget.z = 0;
                d = 1;
            }
            return d;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>transform</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:blendShader:set"><apiName>blendShader</apiName><shortdesc>
     Задает затенение, используемое при наложении переднего плана на фон.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.display:Shader</apiValueClassifier><apiException><apiDesc>Если тип выхода затенения несовместим с данной операцией (затенение должно указать выход<codeph>pixel4</codeph>).
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если затенение задает меньше двух входных изображений, или если первые два входа не являются входами <codeph>image4</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если затенение задает неподдерживаемое входное изображение.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если объект ByteArray или Vector. В качестве ввода используется экземпляр &lt;Number>, а свойства <codeph>width</codeph> и <codeph>height</codeph> для ShaderInput не указаны либо указанные значения не соответствуют количеству данных во входном объекте. Дополнительные сведения см. в описании <codeph>ShaderInput.input</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Задает затенение, используемое при наложении переднего плана на фон. Если свойство <codeph>blendMode</codeph> настроено на <codeph>BlendMode.SHADER</codeph>, то в качестве выхода режима наложения для экранного объекта используется объект Shader.
     
     <p>Применение свойства <codeph>blendShader</codeph> к экземпляру Shader автоматически приведет к смене значения свойства <codeph>blendMode</codeph> на <codeph>BlendMode.SHADER</codeph>. Если же свойство <codeph>blendShader</codeph> установлено (устанавливает <codeph>blendMode</codeph> на значение <codeph>BlendMode.SHADER</codeph>), то значение свойства <codeph>blendMode</codeph> изменяется. Режим наложения можно настроить на использование затенения для наложения, установив свойство <codeph>blendMode</codeph> на значение <codeph>BlendMode.SHADER</codeph>. Необходимость в повторной установке свойства <codeph>blendShader</codeph> отсутствует, за исключением тех случаев, когда требуется сменить затенение, используемое для режима наложения.</p>
     
     <p>Присвоенный свойству <codeph>blendShader</codeph> объект Shader должен задавать как минимум пару входов <codeph>image4</codeph>. <b>Отсутствует</b> необходимость указания вводов в коде с помощью свойств <codeph>input</codeph> связанных объектов ShaderInput  В качестве первого входного изображения используется экранный объект на заднем плане (вход со значением <codeph>index</codeph> 0). В качестве второго входного изображения используется экранный объект на переднем плане (вход со значением <codeph>index</codeph> 1). Затенение, используемое в качестве затенения наложения, может задавать больше двух входов. В этом случае все дополнительные входы следует задавать в свойстве <codeph>input</codeph> объекта ShaderInput.</p>
     
     <p>При присвоении данному свойству экземпляра объекта Shader происходит копирование затенения на внутреннем уровне. При выполнении операции наложения используется эта копия, а не ссылка на исходное затенение. Изменения параметров затенения (изменение значения параметра, ввода или байт-кода) не влияют на используемую для наложения копию затенения.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Loader"><apiName>Loader</apiName><shortdesc>
 Класс Loader используется для загрузки SWF-файлов либо файлов изображений (JPG, PNG или GIF).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Loader используется для загрузки SWF-файлов либо файлов изображений (JPG, PNG или GIF). Используйте метод <codeph>load()</codeph> для инициации загрузки. Загруженный экранный объект добавляется в качестве потомка объекта Loader.
 
 <p>Используйте класс URLLoader для загрузки текстовых или двоичных данных.</p>
 
 <p>Класс Loader переопределяет следующие наследуемые методы, так как объект Loader может иметь только один нижестоящий объект отображения – объект, загруженный им. При вызове следующих методов создается исключение: <codeph>addChild()</codeph>, <codeph>addChildAt()</codeph>, <codeph>removeChild()</codeph>, <codeph>removeChildAt()</codeph> и <codeph>setChildIndex()</codeph>. Для удаления загруженного объекта отображения необходимо удалить объект <i>Loader</i> из нижестоящего массива вышестоящего объекта DisplayObjectContainer. </p>
 
 <p><b>Примечание.</b> Классы ActionScript 2.0 MovieClipLoader и LoadVars не используются в ActionScript 3.0. Они заменяются классами Loader и URLLoader.</p>
 
 <p>При использовании класса Loader необходимо продумать модель безопасности Flash Player и Adobe AIR. </p>
 
 <ul>
  <li>Можно загружать содержимое из любого доступного источника. </li>
 
  <li>Загрузка запрещена, если вызов SWF-файла осуществляется в изолированной программной среде сети, а файл для загрузки сохранен на локальном компьютере. </li>
 
  <li>Если загружаемое содержимое является SWF-файлом, созданным с использованием ActionScript 3.0, его нельзя использовать вместе с SWF-файлом из другой изолированной программной среды безопасности, если не было разрешено перекрестное выполнение сценариев путем вызова метода <codeph>System.allowDomain()</codeph> или <codeph>System.allowInsecureDomain()</codeph> в загруженном файле.</li>
  
  <li>Если загруженное содержимое является SWF-файлом версии AVM1 (написанным с использованием ActionScript 1.0 или 2.0), нельзя выполнять перекрестные сценарии совместно с SWF-файлом версии AVM2 (написанным на ActionScript 3.0). Однако можно передавать данные между двумя SWF-файлами с помощью класса LocalConnection.</li>
  
  <li>Если загруженное содержимое является изображением, его данные не будут доступны для SWF-файлов за пределами изолированной программной среды безопасности, если домен этого SWF-файла не включен в файл политики URL-адресов на исходном домене изображения.</li>
 
  <li>Фрагменты роликов в изолированной программной среде файловой системы не могут выполнять перекрестные сценарии вместе с фрагментами роликов в изолированной программной среде сети, и наоборот. </li>
 
  <li>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>«Программирование на ActionScript 3.0»</i>. </li>
 
 
 </ul>
 
 <p>Однако в AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
 
 <p>Дополнительные сведения см. в следующих источниках.</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 
 </ul>
 
 <p>Возможно, при загрузке SWF-файла из ненадежного источника (такого как домен, не являющийся доменом корневого SWF-файла объекта Loader) потребуется определить маску для объекта Loader, чтобы предотвратить отрисовку загруженного содержимого (например, потомка объекта Loader) в областях рабочей области, находящихся за пределами этой маски, как показано в следующем коде:</p>
 
 <codeblock>import flash.display.~~;
 import flash.net.URLRequest;
 var rect:Shape = new Shape();
 rect.graphics.beginFill(0xFFFFFF);
 rect.graphics.drawRect(0, 0, 100, 100);
 rect.graphics.endFill();
 addChild(rect);
 var ldr:Loader = new Loader();
 ldr.mask = rect;
 var url:String = "http://www.unknown.example.com/content.swf";
 var urlReq:URLRequest = new URLRequest(url);
 ldr.load(urlReq);
 addChild(ldr);
 </codeblock>
 
 </apiDesc><example conref="examples\LoaderExample.as"> В следующем примере класс LoaderExample служит для иллюстрации использования различных прослушивателей событий. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>Создается свойство <codeph>url</codeph>, описывающее местоположение и имя файла изображения.</li>
  <li>В конструкторе <codeph>LoaderExample</codeph> создается новый объект Loader с именем <codeph>loader</codeph> и затем передается методу <codeph>configureListeners()</codeph>, описанному в шаге 3.</li>
  <li>Конструктор создает новый экземпляр объекта URLRequest, <codeph>request</codeph>, и передает <codeph>url</codeph>, чтобы сообщить имя и местоположение файла.</li>
  <li>Объект <codeph>request</codeph> передается методу <codeph>load()</codeph> объекта <codeph>loader</codeph> для загрузки изображения в список отображения.</li>
  <li>Прослушиватель событий <codeph>clickHandler</codeph> зарегистрировал событие <codeph>click</codeph> для средства загрузки. После щелчка мыши загруженное изображение выгружается.</li>
  <li>Метод <codeph>configureListeners()</codeph> добавляет семь прослушивателей событий с помощью следующих методов:
  <ul>
      <li>Метод <codeph>completeHandler()</codeph> выполняется по завершении загрузки изображения.</li>
 
      <li>Метод <codeph>httpStatusHandler()</codeph> выполняется, если изображение загружено не локально и только если доступен сетевой запрос и проигрыватель Flash Player может его обнаружить.</li>
 
      <li>Метод <codeph>initHandler()</codeph> выполняется перед методом <codeph>completeHandler()</codeph> и после метода <codeph>progressHandler()</codeph>. Как правило, событие <codeph>init</codeph> более полезно при загрузке SWF-файлов.</li>
 
      <li>Метод <codeph>ioErrorHandler()</codeph> выполняется, если файла изображения нет или он недоступен.</li>
 
      <li>Метод <codeph>openHandler()</codeph> выполняется при первом открытии изображения.</li>
 
      <li>Метод <codeph>progressHandler()</codeph> выполняется, когда начинается и когда заканчивается загрузка файла изображения.</li>
 
      <li>Метод <codeph>unLoadHandler()</codeph> выполняется при выгрузке с использованием метода <codeph>unload()</codeph>, когда пользователь нажимает на изображение.</li>
 
  </ul>
  </li>
 </ol>
 <p> Необходимо учитывать следующие требования.</p>
 
 <ul>
  <li>В этом примере требуется поместить файл с именем Image.gif в тот же каталог, что и компилированный SWF-файл. Используйте изображение область которого соответствует размерам основного SWF-файла.</li>
 
  <li>Хотя в этом примере используются все события, доступные для объекта LoaderInfo, в большинстве случаев требуется только та или иная подгруппа. В частности, при загрузке только файла изображения можно использовать только событие <codeph>complete</codeph> (и, возможно, событие <codeph>ioError</codeph>), если загружается локальное изображение.</li>
 
 </ul>
 
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderExample() {
            var loader:Loader = new Loader();
            configureListeners(loader.contentLoaderInfo);
            loader.addEventListener(MouseEvent.CLICK, clickHandler);

            var request:URLRequest = new URLRequest(url);
            loader.load(request);

            addChild(loader);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(Event.INIT, initHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function initHandler(event:Event):void {
            trace("initHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function unLoadHandler(event:Event):void {
            trace("unLoadHandler: " + event);
        }

        private function clickHandler(event:MouseEvent):void {
            trace("clickHandler: " + event);
            var loader:Loader = Loader(event.target);
            loader.unload();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:Loader:Loader"><apiName>Loader</apiName><shortdesc>
     Создает объект Loader, с помощью которого можно загружать файлы, например: SWF, JPEG, GIF или PNG.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need wording on parent/child relationships, root DisplayObjects, and so on.
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Создает объект Loader, с помощью которого можно загружать файлы, например: SWF, JPEG, GIF или PNG. Вызовите метод <codeph>load()</codeph>, чтобы загрузить ресурс в качестве нижестоящего объекта экземпляра Loader. После этого можно добавить объект Loader в список отображения (например, с помощью метода <codeph>addChild()</codeph> экземпляра DisplayObjectContainer). Ресурс отображается в рабочей области по мере загрузки.
     
     <p>Экземпляр Loader можно также использовать автономно, то есть без добавления в контейнер объекта в списке отображения. В этом режиме экземпляр Loader может использоваться для загрузки SWF-файла, содержащего дополнительные модули приложения. </p>
     
     <p>О завершении загрузки SWF-файла можно узнать, используя события объекта LoaderInfo, связанные со свойством <codeph>contentLoaderInfo</codeph> объекта Loader. На этом этапе можно выполнить код в модуле SWF-файла, чтобы инициализировать и запустить модуль. В автономном режиме экземпляр Loader можно использовать для загрузки SWF-файла, содержащего компоненты и мультимедийные ресурсы. О завершении загрузки компонентов можно узнать с помощью оповещений о событиях объекта LoaderInfo. На этом этапе приложение может начать использовать компоненты и мультимедийные ресурсы в библиотеке SWF-файла, создав экземпляры классов ActionScript 3.0 для их представления.</p>
     
     <p>Чтобы узнать состояние объекта Loader, отслеживайте следующие события, которые объект LoaderInfo связал со свойством <codeph>contentLoaderInfo</codeph> объекта Loader.</p>
     
     <ul>
       
     <li>Событие <codeph>open</codeph> передается после начала загрузки.</li>
       
     <li>Событие <codeph>ioError</codeph> или <codeph>securityError</codeph> передается, если загрузка файла невозможна или если в процессе загрузки произошла ошибка. </li>
       
     <li>Событие <codeph>progress</codeph> отправляется постоянно по ходу загрузки файла.</li>
       
     <li>Событие <codeph>complete</codeph> передается после завершения загрузки файла, но до того, как станут доступны методы и свойства загруженного фрагмента ролика. </li>
       
     <li>Событие <codeph>init</codeph> передается после того, как станут доступны свойства и методы загруженного SWF-файла, чтобы можно было приступать к работе с ним. Это событие передается перед обработчиком <codeph>complete</codeph>. В потоковых SWF-файлах событие <codeph>init</codeph> может происходить намного раньше, чем событие <codeph>complete</codeph>. Для большинства целей следует использовать обработчик <codeph>init</codeph>.</li>
     
     </ul>
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:Loader:close"><apiName>close</apiName><shortdesc>
     Отменяет операцию выполняемого в данный момент метода load() для экземпляра класса Loader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Отменяет операцию выполняемого в данный момент метода <codeph>load()</codeph> для экземпляра класса Loader.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:load"><apiName>load</apiName><shortdesc>
     Загружает SWF-, JPEG-, прогрессивные JPEG-, неанимированные GIF- или PNG-файлы в объект, являющийся нижестоящим для объекта Loader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how to use the <code>MovieClipLoader.loadClip()</code> 
     method by creating a handler for the <code>onLoadInit</code> event and then making the request.
     <p>You should either place the following code directly into a frame action on a Timeline, or 
     paste it into a class that extends MovieClip. This code also expects an image named YourImage.jpg
     to exist in the same directory as the compiled SWF file.</p>
     
     <listing version="2.0">
     var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth());
     var mcLoader:MovieClipLoader = new MovieClipLoader();
     mcLoader.addListener(this);
     mcLoader.loadClip("YourImage.jpg", container);
     
     function onLoadInit(mc:MovieClip) {
         trace("onLoadInit: " + mc);
     }
     </listing>
     
     </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Значением свойства <codeph>digest</codeph> объекта <codeph>request</codeph> не является <codeph>null</codeph>. Свойство <codeph>digest</codeph> объекта URLRequest следует задавать только при вызове метода <codeph>URLLoader.load()</codeph> во время загрузки SWZ-файла (компонент платформы Adobe).
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Значение для <codeph>LoaderContext.securityDomain</codeph> должно быть <codeph>null</codeph> или <codeph>SecurityDomain.currentDomain</codeph>. Оно говорит о том, что загруженный мультимедийный файл можно поместить только в его натуральную изолированную программную среду безопасности или в вашу собственную (для этого требуется файл политики).
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Для локальных SWF-файлов нельзя задавать для LoaderContext.securityDomain других значений, кроме <codeph>null</codeph>. Не разрешается импортировать нелокальные мультимедийные файлы в локальную изолированную программную среду или помещать другие локальные мультимедийные файлы в не собственную изолированную программную среду.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойства <codeph>applicationDomain</codeph> или <codeph>securityDomain</codeph> параметра <codeph>context</codeph> передаются с запрещенного домена.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если локальный SWF-файл пытается использовать свойство<codeph>securityDomain</codeph> параметра <codeph>context</codeph>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> Абсолютный или относительный URL-адрес загружаемого SWF-, JPEG-, GIF- или PNG-файла. Относительный путь должен относиться к главному SWF-файлу. Абсолютные URL-адреса должны содержать название протокола, например http:// или file:///. Имена файлов не должны содержать имена жестких дисков.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект LoaderContext, имеющий свойства, которые определяют следующее:
     
     <ul>
     
	 <li>нужно ли проверять наличие файла политики при загрузке объекта;</li>
     
     <li>ApplicationDomain для загруженного объекта;</li>
     
     <li>SecurityDomain для загруженного объекта.</li>
     
     </ul>
     <p>Если параметр <codeph>context</codeph> не задан или ссылается на несуществующий объект, загружаемое содержимое остается в собственном домене защиты.</p>
     
     <p>Полные сведения см. в описании свойств класса <xref href="../system/LoaderContext.html">LoaderContext</xref>.</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Загружает SWF-файл или файл изображения в DisplayObject, являющийся дочерним объектом этого экземпляра Loader.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Загружает SWF-, JPEG-, прогрессивные JPEG-, неанимированные GIF- или PNG-файлы в объект, являющийся дочерним для объекта Loader. Если загружается анимированный GIF-файл, отображается только первый кадр. Так как объект Loader может содержать только один дочерний объект, отправка последующего запроса <codeph>load()</codeph> прекращает обработку предыдущего, если он еще ожидает выполнения, и начинается новая загрузка.
     
     <p><b>Примечание.</b> В AIR 1.5 и Flash Player 10 максимальный размер загруженного изображения составляет 8,191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16,777,215. (Т. е. если ширина загруженного изображения составляет 8,191 пикселей, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину.</p>
     
     <p>SWF-файл или изображение, загруженное в объект Loader наследует свойства положения, поворота и масштаба родительских экранных объектов объекта Loader. </p>
     
     <p>Используйте метод <codeph>unload()</codeph> для удаления роликов или изображений, загруженных с помощью этого метода, или для отмены выполняемой операции загрузки.</p>
     
     <p>Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</p>
     
     <p>При использовании данного метода необходимо учесть модель безопасности проигрывателя Flash Player, рассмотренную в описании класса Loader. </p>
     
     <p> В приложении Flash Player 10 и более поздней версии при использовании типа содержимого multipart (например, multipart/form-data), в котором содержится отправка (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для отправок:</p>
	 <ul>
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p>Кроме того, все объекты типа содержимого multipart должны иметь допустимый синтаксис (в соответствии со стандартом RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для отправок.</p>
     <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/contentLoaderInfo"><linktext>contentLoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>flash.display.Loader.unload()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><adobeApiEvent id="flash.display:Loader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Передается объектом <codeph>contentLoaderInfo</codeph> по завершении загрузки файла. Событие <codeph>complete</codeph> всегда отправляется после события <codeph>init</codeph>.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Передается объектом contentLoaderInfo по завершении загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Передается объектом <codeph>contentLoaderInfo</codeph>, когда совершается сетевой запрос по протоколу HTTP, а проигрыватель Flash Player может определить код состояния HTTP.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo, когда совершается сетевой запрос по протоколу HTTP, а проигрыватель Flash Player может определить код состояния HTTP.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_init"><apiName>init</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Передается объектом <codeph>contentLoaderInfo</codeph> когда становятся доступны свойства и методы загруженного SWF-файла. Событие <codeph>init</codeph> всегда предшествует событию <codeph>complete</codeph>.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo, когда становятся доступны свойства и методы загруженного SWF-файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется объектом <codeph>contentLoaderInfo</codeph>, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется объектом <codeph>contentLoaderInfo</codeph> после начала операции загрузки.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo после начала операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется объектом <codeph>contentLoaderInfo</codeph> по мере получения данных во время операции загрузки.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo по мере получения данных во время операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется объектом <codeph>contentLoaderInfo</codeph>, если SWF-файл в изолированной программной среде файловой системы пытается загрузить содержимое из изолированной программной среды сети и наоборот.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo, если SWF-файл в изолированной программной среде файловой системы пытается загрузить содержимое из изолированной программной среды сети и наоборот.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_unload"><apiName>unload</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется объектом <codeph>contentLoaderInfo</codeph> при удалении загруженного объекта.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется объектом contentLoaderInfo при удалении загруженного объекта.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:Loader:loadBytes"><apiName>loadBytes</apiName><shortdesc>
     Выполняет загрузку из двоичных данных, которые хранятся в объекте ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если свойство <codeph>length</codeph> объекта ByteArray меньше 0.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство <codeph>checkPolicyFile</codeph> или <codeph>securityDomain</codeph> параметра <codeph>context</codeph> имеет значение, отличное от 0.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если переданное свойство <codeph>applicationDomain</codeph> параметра<codeph>context</codeph> находится на запрещенном домене.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>«Программирование на ActionScript 3.0»</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray. Содержимое объекта ByteArray может иметь любой формат, поддерживаемый классом Loader: SWF, GIF, JPEG или PNG.
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект LoaderContext. Применяется только свойство <codeph>applicationDomain</codeph> объекта LoaderContext; свойства <codeph>checkPolicyFile</codeph> и <codeph>securityDomain</codeph> объекта LoaderContext не применяются. 
     
     <p>Если параметр <codeph>context</codeph> не задан или ссылается на несуществующий объект, содержимое загружается в текущий домен защиты – процесс, обозначенный как «загрузка-импорт» в документации о безопасности проигрывателя Flash Player. В частности, если загружаемый SWF-файл установил отношения доверия с удаленным SWF-файлом, встроив удаленный SWF-файл в свой код, то загружаемый SWF-файл может импортировать удаленный файл непосредственно в собственный домен защиты.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет загрузку из двоичных данных, которые хранятся в объекте ByteArray.
     
     <p>При использовании данного метода необходимо учесть модель безопасности проигрывателя Flash Player, рассмотренную в описании класса Loader. </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unload"><apiName>unload</apiName><shortdesc>
     Удаляет дочерний объект этого объекта Loader, загруженный с помощью метода load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The funky-looking code formatting above is intentional to work around a bug!
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет дочерний объект этого объекта Loader, загруженный с помощью метода <codeph>load()</codeph>. Параметр <codeph>property</codeph> связанного объекта LoaderInfo сброшен до значения <codeph>null</codeph>. Нижестоящий объект не обязательно удаляется, так как на него могут ссылаться другие объекты. Однако он больше не является дочерним для объекта Loader.
     
     <p>Перед загрузкой дочернего SWF-файла лучше всего явно закрыть все потоки объектов дочернего SWF-файла, таких как LocalConnection, NetConnection, NetStream и Sound. В противном случае в дочернем SWF-файле может продолжаться воспроизведение звука, несмотря на его загрузку. Чтобы закрыть потоки в дочернем SWF-файле, добавьте для него прослушиватель события <codeph>unload</codeph>. Когда родительский объект вызывает <codeph>Loader.unload()</codeph>, дочернему объекту отправляется событие <codeph>unload</codeph>. Следующий код показывает, как это делается.</p>
<pre>
function closeAllStreams(evt:Event) { 
    myNetStream.close();
    mySound.close();
    myNetConnection.close();
    myLocalConnection.close();
}

myMovieClip.loaderInfo.addEventListener(Event.UNLOAD, closeAllStreams);</pre>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.media.xml#Sound/close()"><linktext>flash.media.Sound.close()</linktext></link><link href="flash.net.xml#LocalConnection/close()"><linktext>flash.net.LocalConnection.close()</linktext></link><link href="flash.net.xml#NetConnection/close()"><linktext>flash.net.NetConnection.close()</linktext></link><link href="flash.net.xml#NetStream/close()"><linktext>flash.net.NetStream.close()</linktext></link><link href="../../operators.html#delete"><linktext>оператор delete</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unloadAndStop"><apiName>unloadAndStop</apiName><shortdesc>
     Пытается выгрузить содержимое дочернего SWF-файла и прекращает выполнение команд из загруженных SWF-файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>gc</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Предоставляет инструкции для сборщика мусора относительно того, требуется (<codeph>true</codeph>) или не требуется (<codeph>false</codeph>) выполнять действия в нижестоящих объектах SWF. При асинхронной выгрузке нескольких объектов производительность приложения можно повысить, задав для параметра <codeph>gc</codeph> значение <codeph>false</codeph>. Однако, если для этого параметра задано значение <codeph>false</codeph>, мультимедийные объекты и экранные объекты дочернего SWF-файла могут остаться в памяти после выполнения команды <codeph>unloadAndStop()</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Пытается выгрузить содержимое дочернего SWF-файла и прекращает выполнение команд из загруженных SWF-файлов. Данный метод пытается выгрузить SWF-файлы, загруженные при помощи метода <codeph>Loader.load()</codeph> или <codeph>Loader.loadBytes()</codeph>, удалив ссылки на объекты EventDispatcher, NetConnection, Timer, Sound или Video дочернего SWF-файла. В результате для нижестоящего файла SWF и его списка отображения выполняются следующие действия:
     <ul><li>Останавливается воспроизведение звука.</li>
     <li>Удаляются прослушиватели событий рабочей области.</li>
     <li>Удаляются прослушиватели событий <codeph>enterFrame</codeph>, <codeph>frameConstructed</codeph>, <codeph>exitFrame</codeph>, <codeph>activate</codeph> и <codeph>deactivate</codeph>.</li>
     <li>Останавливаются таймеры.</li>
     <li>Отсоединяются экземпляры Camera и Microphone.</li>
     <li>Прекращается воспроизведение видеороликов.</li></ul>
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Loader:content:get"><apiName>content</apiName><shortdesc>
     Содержит корневой экранный объект SWF-файла или изображения (JPG, PNG или GIF), загруженного с помощью методов load() или loadBytes().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>Загруженный SWF-файл или файл изображения принадлежит изолированной программной среде безопасности, к которой у вас нет доступа. Чтобы избежать такой ситуации, при вызове метода <codeph>load()</codeph> или <codeph>loadBytes()</codeph> загружаемый SWF-файл должен вызвать метод <codeph>Security.allowDomain()</codeph> либо загружающий файл должен указать параметр <codeph>loaderContext</codeph> со свойством <codeph>securityDomain</codeph> в значении <codeph>SecurityDomain.currentDomain</codeph>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Содержит корневой экранный объект SWF-файла или изображения (JPG, PNG или GIF), загруженного с помощью методов <codeph>load()</codeph> или <codeph>loadBytes()</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:Loader:contentLoaderInfo:get"><apiName>contentLoaderInfo</apiName><shortdesc>
     Возвращает объект LoaderInfo, соответствующий загружаемому объекту.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает объект LoaderInfo, соответствующий загружаемому объекту. Объекты LoaderInfo совместно используются объектом Loader и загруженным объектом содержимого. Объект LoaderInfo предоставляет сведения о процессе загрузки и статистику по загружаемому файлу. 
     
     <p>События, связанные с загрузкой, отправляются объектом LoaderInfo, на который ссылается свойство <codeph>contentLoaderInfo</codeph> объекта Loader. Свойство <codeph>contentLoaderInfo</codeph> задается для действительного объекта LoaderInfo, даже если содержимое еще не загружено, чтобы можно было добавить прослушиватели событий объекта перед загрузкой.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
     Класс NativeMenuItem представляет один элемент в меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     Класс NativeMenuItem представляет один элемент в меню.
     
     <p>Элементом меню может быть команда, подменю или разделительная линия.</p> 
     
     <ul>
     <li>Чтобы создать элемент команды, вызовите конструктор NativeMenuItem, передайте строку для ярлыка и значение <codeph>false</codeph> для параметра <codeph>isSeparator</codeph>.</li>
     
     <li>Чтобы создать подменю, создайте элемент команды для родительского меню и назначьте объект подменю NativeMenu свойству элемента <codeph>submenu</codeph>. Также можно создать метод <codeph>addSubmenu()</codeph> родительского объекта NativeMenu, чтобы создать элемент и одновременно задать свойство <codeph>submenu</codeph>.</li>
     
     <li>Чтобы создать разделитель, вызовите конструктор NativeMenuItem, передайте пустую строку для подписи и значение <codeph>true</codeph> для параметра <codeph>isSeparator</codeph>.</li>
     </ul>
     
     <p>Прослушивайте события <codeph>select</codeph> для элемента или родительского меню, чтобы узнать, когда будет выбрана команда меню. Ни подменю, ни разделители не передают события select Прослушивайте события <codeph>displaying</codeph>, чтобы определить, когда элемент меню готовится к показу.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Передается этим объектом NativeMenuItem непосредственно перед показом меню, содержащего элемент.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Передается этим объектом NativeMenuItem непосредственно перед показом меню, содержащего элемент. 
     
	 <p>Свойство <codeph>target</codeph> объекта события ссылается на объект NativeMenu, содержащий данный объект NativeMenuItem, а свойство <codeph>currentTarget</codeph> ссылается на этот NativeMenuItem.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Передается каждый раз, когда пользователь выбирает элемент меню.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Передается каждый раз, когда пользователь выбирает элемент меню. 
     
     <p>Событие <codeph>select</codeph> переходит по <i>восходящей цепочке</i> из данного элемента в содержащее его меню и дальше вверх к корневому объекту меню. Свойство <codeph>target</codeph> объекта события ссылается на данный объект NativeMenuItem, а свойство <codeph>currentTarget</codeph> ссылается на передающий объект (либо данный объект NativeMenuItem, либо предшествующий ему NativeMenu).</p>
	 
	 <p><b>Примечание.</b> Если окно, содержащее меню, показывается в полноэкранном режиме, то объект NativeMenuItem <i>не</i> передает событие <codeph>select</codeph>, когда пользователь вводит комбинацию клавиш, эквивалентную элементу меню. Однако можно отслеживать событие <codeph>keyDown</codeph>, передаваемое свойством <codeph>stage</codeph> объекта NativeWindow.</p>
       
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeMenuItem:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
         Создает новый объект NativeMenuItem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Экранная подпись для элемента или пустая строка для разделителей.
         </apiDesc></apiParam><apiParam><apiItemName>isSeparator</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Задайте <codeph>true</codeph>, чтобы создать разделитель; в противном случае задайте <codeph>false</codeph>.
         
         </apiDesc></apiParam></apiConstructorDef><apiDesc>
         Создает новый объект NativeMenuItem.
         
         <p>Чтобы создать команду меню, задайте параметр <codeph>label</codeph> строке, содержащей экранную подпись, а для <codeph>isSeparator</codeph> укажите значение <codeph>false</codeph>.</p>
	     
	     <p>Чтобы создать команду подменю, создайте элемент команды, а затем назначьте объект подменю NativeMenu свойству элемента <codeph>submenu</codeph>. Добавьте элемент в родительское меню.</p>
		  
	     <p>Чтобы создать разделитель, задайте параметр <codeph>label</codeph> пустой строке, а для <codeph>isSeparator</codeph> укажите значение <codeph>true</codeph>.</p>
         
         <p>Добавляйте и удаляйте элементы из меню с помощью методов NativeMenu <codeph>addItem()</codeph> и <codeph>removeItem()</codeph>.</p>
         
         </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeMenuItem:clone"><apiName>clone</apiName><shortdesc>
         Создает копию объекта NativeMenuItem.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Создает копию объекта NativeMenuItem.
         
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenuItem:toString"><apiName>toString</apiName><shortdesc>
         Возвращает строку, содержащую все свойства объекта NativeMenuItem.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Строка, содержащая все свойства объекта Event.
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         Возвращает строку, содержащую все свойства объекта NativeMenuItem.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenuItem:checked:get"><apiName>checked</apiName><shortdesc>
         Управляет отображением флажка для данного элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Управляет отображением флажка для данного элемента меню.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:data:get"><apiName>data</apiName><shortdesc>
         Объект произвольных данных, связанный с данным элементом меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
         Объект произвольных данных, связанный с данным элементом меню.
         
         <p>Этому свойству можно назначить любой объект. Назначенный объект не используется системой меню, но доступен для кода обработки события (через свойство target объекта событий). По умолчанию в качестве значения этого свойства выбрано<codeph>null</codeph></p>
           
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:enabled:get"><apiName>enabled</apiName><shortdesc>
         Управляет включением данного элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Управляет включением данного элемента меню.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:isSeparator:get"><apiName>isSeparator</apiName><shortdesc>
         Сообщает, является ли данный элемент разделительной линией меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         Сообщает, является ли данный элемент разделительной линией меню.
         
         <p>Создайте разделительную линию, задав для параметра <codeph>isSeparator</codeph> в конструкторе NativeMenuItem значение <codeph>true</codeph>.</p> 
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalent:get"><apiName>keyEquivalent</apiName><shortdesc>
         Эквивалентная комбинация клавиш для данного элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Эквивалентная комбинация клавиш для данного элемента меню.
		 
		 <p>Задайте <codeph>keyEquivalent</codeph>, используя строчную букву, чтобы назначить комбинацию клавиш без модификатора клавиши Shift. Задайте заглавную букву, чтобы назначить комбинацию клавиш с использованием модификатора клавиши Shift.</p>
		 
		 <p>По умолчанию в комбинацию клавиш включается модификатор эквивалентной комбинации клавиш (Ctrl для Windows или Linux и Command для Mac OS X). Если в эквивалентную комбинацию клавиш не должны входить модификаторы, установите свойство <codeph>keyEquivalentModifiers</codeph> на пустой массив.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalentModifiers:get"><apiName>keyEquivalentModifiers</apiName><shortdesc>
         Массив кодов клавиш для модификаторов эквивалентной комбинации клавиш.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         Массив кодов клавиш для модификаторов эквивалентной комбинации клавиш.
         
         <p>Используйте константы, определенные в классе Keyboard, чтобы указать коды клавиш для модификаторов. Допускаются следующие клавиши-модификаторы:</p>
         <ul>
         <li><codeph>Keyboard.ALTERNATE</codeph></li>
         <li><codeph>Keyboard.COMMAND</codeph></li>
         <li><codeph>Keyboard.CONTROL</codeph></li>
         </ul>
		 
		 <p>Если не назначено других модификаторов, по умолчанию в Windows или Linux указывается клавиша <codeph>Keyboard.CONTROL</codeph>, а в Mac OS X – <codeph>Keyboard.COMMAND</codeph>. Если эти модификаторы не должны входить в эквивалентную комбинацию клавиш, установите это свойство на пустой массив.</p>
		 
		 <p>Если свойству <codeph>keyEquivalent</codeph> назначается заглавная буква, то в качестве модификатора автоматически используется клавиша Shift. Назначение свойству <codeph>keyEquivalentModifier</codeph> пустого массива не приведет к отмене использования модификатора Shift.</p> 
         
         </apiDesc></apiValueDetail><related-links><link href="flash.ui.xml#Keyboard"><linktext>flash.ui.Keyboard</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeMenuItem:label:get"><apiName>label</apiName><shortdesc>
         Строка отображения данного элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Строка отображения данного элемента меню.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:menu:get"><apiName>menu</apiName><shortdesc>
         Меню, содержащее данный элемент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         Меню, содержащее данный элемент.  
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:mnemonicIndex:get"><apiName>mnemonicIndex</apiName><shortdesc>
         Положение мнемонического символа в ярлыке элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Положение мнемонического символа в ярлыке элемента меню.
         
         <p>Символ в указанном положении является мнемоническим для элемента меню. Индекс строится с нуля, поэтому первый символ имеет индекс 0.</p>
         
         <p>Данное свойство игнорируется в операционных системах, не использующих мнемосхемы меню.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:name:get"><apiName>name</apiName><shortdesc>
         Имя данного элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Имя данного элемента меню.  
         
         <p>Значение имени не отображается, его можно использовать в качестве идентификатора, независимого от региональных настроек. Имя не назначается автоматически.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:submenu:get"><apiName>submenu</apiName><shortdesc>
		 Подменю, связанное с данным элементом меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 Подменю, связанное с данным элементом меню.  
		 
		 <p>Назначение объекта NativeMenu данному свойству изменяет вид и поведение элемента меню. Элемент подменю отображает значок подменю и перестает передавать события select.</p>
         
        <p><b>Примечание.</b> Добавление меню в качестве подменю для самого себя (по циклической ссылке) может привести к зависанию приложения.</p>
        
         </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenu"><apiName>NativeMenu</apiName><shortdesc>
     Класс NativeMenu содержит методы и свойства для определения меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     Класс NativeMenu содержит методы и свойства для определения меню.
     
     <p>AIR поддерживает следующие типы меню:</p>
     <adobetable class="innertable">
     
     
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Меню</entry><entry>Экземпляр</entry><entry>Тест возможностей</entry><entry>Поддерживается на</entry><entry>Значения по умолчанию?</entry></row></thead><tbody><row><entry>Приложение</entry><entry><codeph>NativeApplication.nativeApplication.menu</codeph></entry><entry><codeph>NativeApplication.supportsMenu</codeph></entry><entry>Mac OS X</entry><entry>Да</entry></row><row><entry>Окно</entry><entry><codeph>NativeWindow.menu</codeph></entry><entry><codeph>NativeWindow.supportsMenu</codeph></entry><entry>Windows, Linux</entry><entry>Нет</entry></row><row><entry>Значок панели</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsDockIcon</codeph></entry><entry>Mac OS X</entry><entry>Да</entry></row><row><entry>Значок на панели задач</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry><entry>Windows, Linux</entry><entry>Нет</entry></row><row><entry>Контекст</entry><entry><codeph>InteractiveObject.contextMenu</codeph></entry><entry>Всегда поддерживается</entry><entry>Все</entry><entry>Нет</entry></row><row><entry>Раскрывающееся меню</entry><entry>Любой экземпляр NativeMenu</entry><entry>Всегда поддерживается</entry><entry>Все</entry><entry>Нет</entry></row></tbody></tgroup></adobetable>
     
     <p>Меню может содержать элементы для команд, подменю и разделительных линий. Элементы меню добавляются с помощью методов <codeph>addItem()</codeph>, <codeph>addItemAt()</codeph>, <codeph>addSubmenu()</codeph> и <codeph>addSubmenuAt()</codeph>. Порядок отображения элементов меню соответствует порядку элементов в массиве <codeph>items</codeph> меню.</p>
      
     <p>Подменю присоединяются к вышестоящему меню через свойство <codeph>submenu</codeph> соответствующего элемента в вышестоящем меню. Корневое меню окна и меню приложений должны содержать только элементы подменю. Элементы без подменю не показываются, так как они противоречат ожиданиям пользователей от меню такого типа.</p>
     
     <p>Меню отправляют события <codeph>select</codeph>, когда в меню или подменю выбирается элемент команды. (Подменю и разделители выбрать нельзя.) Свойство <codeph>target</codeph> объекта события ссылается на выбранный элемент.</p>
     
     <p>Меню отправляют события <codeph>displaying</codeph> непосредственно перед отображением меню. Это событие можно использовать для обновления содержимого меню на основе текущего состояния приложения.</p> 
     
     <p platform="actionscript"><b>Примечание.</b> Для настройки контекстного меню можно использовать как объект NativeMenu, так и объект ContextMenu. Проигрыватель Flash Player поддерживает только класс ContextMenu, а класс NativeMenu не поддерживает.
	 </p>
     
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>flash.display.InteractiveObject.contextMenu</linktext></link><link href="flash.display.xml#NativeMenuItem"><linktext>flash.display.NativeMenuItem</linktext></link><link href="flash.display.xml#NativeWindow/menu"><linktext>flash.display.NativeWindow.menu</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/menu"><linktext>flash.desktop.NativeApplication.menu</linktext></link><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     Отправляется этим объектом NativeMenu непосредственно перед показом меню.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Отправляется этим объектом NativeMenu непосредственно перед показом меню. 
     
     <p>Прослушивайте это событие для обновления меню перед показом. События Displaying также отправляются элементами в меню.</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     Отправляется этим объектом NativeMenu при выборе одного из элементов меню или элемента одного из подменю.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Отправляется этим объектом NativeMenu при выборе одного из элементов меню или элемента одного из подменю. 
     
     <p>Событие select переходит по <i>восходящей цепочке</i> из данного элемента в содержащее его меню и дальше вверх к корневому объекту меню. Свойство <codeph>target</codeph> объекта событий ссылается на выбранный объект NativeMenuItem. Свойство <codeph>currentTarget</codeph> ссылается на данный объект NativeMenu.</p>  
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:NativeMenu:addItem"><apiName>addItem</apiName><shortdesc>
         Добавляет элемент в конец меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если <codeph>item</codeph> имеет значение <codeph>null</codeph>.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если <codeph>item</codeph> является составным элементом другого меню.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Объект NativeMenuItem для добавления в конец меню.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Добавляет элемент в конец меню.
         
         <p platform="actionscript">При создании контекстного меню можно добавлять объекты NativeMenuItem или ContextMenuItem. Однако рекомендуется использовать только один тип объектов в контекстном меню, чтобы все элементы меню имели одинаковые свойства.</p>
         
         <p><b>Примечание.</b> Добавление элемента к меню может привести к зависанию приложения, если подменю элемента установлено на собственное меню (вызывает циклическую ссылку).</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addItemAt"><apiName>addItemAt</apiName><shortdesc>
         Вставляет элемент меню в указанное положение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если <codeph>item</codeph> имеет значение <codeph>null</codeph>.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если <codeph>item</codeph> является составным элементом другого меню.
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если индекс находится за пределами массива <codeph>items</codeph> меню.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Вставляемый объект NativeMenuItem.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение в меню (от нуля), выбранное для вставки элемента меню.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Вставляет элемент меню в указанное положение.
         
         <p><b>Примечание.</b> Добавление элемента к меню может привести к зависанию приложения, если подменю элемента установлено на собственное меню (вызывает циклическую ссылку).</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenu"><apiName>addSubmenu</apiName><shortdesc>
        Добавляет подменю в меню путем вставки нового элемента меню.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект NativeMenuItem, созданный для подменю. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>Объект NativeMenu, определяющий добавляемое подменю.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ярлык отображения для добавляемого элемента меню.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Добавляет подменю в меню путем вставки нового элемента меню.
        
        <p>Вызов метода <codeph>addSubMenu()</codeph> равносилен созданию нового элемента меню, его добавлению в меню и назначению объекта NativeMenu свойству <codeph>submenu</codeph> элемента.</p>
        
        <p><b>Примечание.</b> Добавление меню в качестве подменю для самого себя (по циклической ссылке) может привести к зависанию приложения.</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenuAt"><apiName>addSubmenuAt</apiName><shortdesc>
        Добавляет подменю в меню, вставляя новый элемент меню в заданное положение.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект NativeMenuItem, созданный для подменю. 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>Объект NativeMenu, определяющий добавляемое подменю.
        </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция массива <codeph>items</codeph> данного меню, в которую требуется вставить добавляемый элемент меню.
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Ярлык отображения для добавляемого элемента меню.
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        Добавляет подменю в меню, вставляя новый элемент меню в заданное положение.
        
        <p>Вызов метода <codeph>addSubMenuAt()</codeph> равносилен созданию нового элемента меню, вставке его в желаемое положение в меню и назначению объекта NativeMenu свойству <codeph>submenu</codeph> элемента.</p>
        
        <p><b>Примечание.</b> Добавление меню в качестве подменю для самого себя (по циклической ссылке) может привести к зависанию приложения.</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:clone"><apiName>clone</apiName><shortdesc>
        
        Создает копию меню и всех элементов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
        
        Создает копию меню и всех элементов.
        
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:containsItem"><apiName>containsItem</apiName><shortdesc>
         Сообщает, содержит ли меню указанный элемент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если <codeph>item</codeph> есть в этом меню.
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Объект NativeMenuItem, который требуется найти.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Сообщает, содержит ли меню указанный элемент.
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:display"><apiName>display</apiName><shortdesc>
        Добавляет раскрывающееся меню в заданном местоположении.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stage</apiItemName><apiOperationClassifier>flash.display:Stage</apiOperationClassifier><apiDesc>Объект Stage, на котором будет отображаться данное меню.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число пикселей по горизонтали относительно начала рабочей области, на котором будет отображаться данное меню.
		
        </apiDesc></apiParam><apiParam><apiItemName>stageY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число пикселей по вертикали относительно начала рабочей области, на котором будет отображаться данное меню.
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
        Добавляет раскрывающееся меню в заданном местоположении.
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemAt"><apiName>getItemAt</apiName><shortdesc>
         Определяет элемент меню, расположенный по заданному индексу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если <codeph>index</codeph> находится за пределами массива <codeph>items</codeph> меню.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект NativeMenuItem, расположенный в заданном положении в меню.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение (от нуля) возвращаемого элемента.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Определяет элемент меню, расположенный по заданному индексу.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemByName"><apiName>getItemByName</apiName><shortdesc>
         Определяет элемент меню с заданным именем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект NativeMenuItem с заданным именем или значение <codeph>null</codeph>, если такого элемента в меню не существует.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Искомая строка.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Определяет элемент меню с заданным именем.
         
         <p><b>Примечание.</b> Свойство <codeph>name</codeph> элементов меню не назначается по умолчанию.</p>
            
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemIndex"><apiName>getItemIndex</apiName><shortdesc>
         Определяет положение заданного элемента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Положение (от нуля) заданного элемента в данном меню или <codeph>null</codeph>, если элемент отсутствует в меню.
         
         </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Объект NativeMenuItem, который требуется найти.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Определяет положение заданного элемента. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeAllItems"><apiName>removeAllItems</apiName><shortdesc>
         Удаляет все элементы из меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
         Удаляет все элементы из меню.  
         
         
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItem"><apiName>removeItem</apiName><shortdesc>
         Удаляет заданный элемент меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если <codeph>item</codeph> нет в этом меню.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Объект NativeMenuItem для удаления из данного меню.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Удаляет заданный элемент меню. 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItemAt"><apiName>removeItemAt</apiName><shortdesc>
         Удаляет и возвращает элемент меню в заданный индекс.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если <codeph>index</codeph> находится за пределами массива <codeph>items</codeph> этого меню.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Удаленный объект NativeMenuItem.
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение (от нуля) удаляемого элемента.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Удаляет и возвращает элемент меню в заданный индекс.  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:setItemIndex"><apiName>setItemIndex</apiName><shortdesc>
         Перемещает элемент меню в заданное положение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если <codeph>index</codeph> находится за пределами массива <codeph>items</codeph> меню.
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>Перемещаемый объект NativeMenuItem.
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение (от нуля) в меню, в которое нужно переместить <codeph>элемент</codeph>.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         Перемещает элемент меню в заданное положение. Если элемент еще не находится в меню, вызов этого метода добавляет элемент к меню.
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenu:items:get"><apiName>items</apiName><shortdesc>
         Массив объектов NativeMenuItem в данном меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         Массив объектов NativeMenuItem в данном меню.
         
         <p>Массив сортируется в порядке отображения.</p>
         
         <p><i>Примечание.</i> Это свойство доступно только для чтения в AIR 1.0. Оно становится доступным для чтения или записи в AIR 1.1.</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:numItems:get"><apiName>numItems</apiName><shortdesc>
         Количество объектов NativeMenuItem в данном меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Количество объектов NativeMenuItem в данном меню.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:parent:get"><apiName>parent</apiName><shortdesc>
         Вышестоящее меню.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         Вышестоящее меню.  
         
         <p><codeph>Вышестоящим элементом</codeph> корневого объекта меню (верхнего уровня) является <codeph>null</codeph>.</p>
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
Класс DisplayObjectContainer является базовым классом для всех объектов, которые могут быть контейнерами для экранных объектов в списке отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Абстрактный базовый класс для всех экранных объектов, которые могут содержать дочерние объекты.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс DisplayObjectContainer является базовым классом для всех объектов, которые могут быть контейнерами для экранных объектов в списке отображения. Список отображения управляет всеми объектами, отображаемыми в проигрывателе Flash Player или в Adobe AIR. Используйте класс DisplayObjectContainer, чтобы упорядочить экранные объекты в списке отображения. Каждый объект DisplayObjectContainer имеет собственный список потомков для построения z-последовательности объектов. Z-последовательность – это порядок расположения с переднего на задний план, определяющий, какой объект будет нарисован на переднем плане, какой за ним и т.д. 
 
 <p>DisplayObject – это абстрактный базовый класс, поэтому нельзя выполнить прямой вызов DisplayObject. При вызове <codeph>new DisplayObject()</codeph> выдается исключение <codeph>ArgumentError</codeph>.</p>
 
 Класс DisplayObjectContainer – это абстрактный базовый класс для всех объектов, содержащих нижестоящие объекты. Он не поддерживает непосредственное создание экземпляров. При вызове конструктора <codeph>new DisplayObjectContainer()</codeph> выдается исключение <codeph>ArgumentError</codeph>.
 
 <p>Дополнительные сведения см. в главе «Программирование экрана» книги <i>Программирование на ActionScript 3.0</i>.</p>
 
 </apiDesc><example conref="examples\DisplayObjectContainerExample.as"> В следующем примере с помощью класса <codeph>DisplayObjectContainerExample</codeph> создается последовательность из пяти оранжевых квадратов. Это можно сделать, выполнив следующие действия.
 
 <ol>
     <li>Конструктор вызывает метод <codeph>configureAssets()</codeph>.</li>
 
  <li>Метод <codeph>configureAssets()</codeph> создает объекты Sprite с именами <codeph>child</codeph> и <codeph>lastChild</codeph>.</li>
 
    <li>Цикл <codeph>for</codeph> создает пять оранжевых квадратов и располагает их один за другим.</li>
 
     <li>Каждый раз при создании объекта <codeph>CustomSprite</codeph> конструктор вызывает его метод <codeph>draw()</codeph>, который рисует квадрат размером 50 х 50 пикселей путем вызова методов <codeph>beginFill()</codeph>, <codeph>drawRect()</codeph> и <codeph>endFill()</codeph> класса Graphics. Метод <codeph>addChild()</codeph> добавляет каждый квадрат в список отображения.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class DisplayObjectContainerExample extends Sprite {
        private var gutter:uint     = 5;
        private var childCount:uint = 5;

        public function DisplayObjectContainerExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var child:Sprite = new CustomSprite();
            var lastChild:Sprite = child;
            for (var i:uint = 1; i &lt;= childCount; i++) {
                child = new CustomSprite();
                child.x = lastChild.x + lastChild.width + gutter;
                addChild(child);
                lastChild = child;
            }
        }
    }
}

import flash.display.Sprite;

class CustomSprite extends Sprite {
    private var size:uint = 50;
    private var bgColor:uint = 0xFFCC00;

    public function CustomSprite() {
        draw(size, size);
    }

    private function draw(w:uint, h:uint):void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:DisplayObjectContainer:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
	При вызове нового DisplayObjectContainer() конструктор выдает исключение ArgumentError.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	При вызове нового <codeph>DisplayObjectContainer()</codeph> конструктор выдает исключение <codeph>ArgumentError</codeph>. Однако <i>можно</i> вызывать конструкторы для следующих подклассов DisplayObjectContainer:
	
	<ul>
	
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
 	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:DisplayObjectContainer:addChild"><apiName>addChild</apiName><shortdesc>
     Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Исключение выдается, если нижестоящий элемент тот же, что и вышестоящий. Также выдается исключение, если вызывающий объект является нижестоящим элементом первого уровня (или второго и так далее уровней) добавляемого нижестоящего элемента.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Экземпляр DisplayObject, передаваемый в параметр <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экземпляр DisplayObject для добавления в качестве нижестоящего элемента экземпляра DisplayObjectContainer.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Добавляет нижестоящий объект к данному экземпляру "DisplayObjectContainer".
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer. Нижестоящий элемент добавляется перед (сверху) всеми остальными нижестоящими элементами в данном экземпляре DisplayObjectContainer. (Чтобы добавить нижестоящий элемент в конкретную позицию в индексе, используйте метод <codeph>addChildAt()</codeph>.)
     
	 <p>При добавлении нижестоящего объекта, уже имеющего отличный от других контейнер объекта отображения в качестве вышестоящего элемента, объект удаляется из списка нижестоящих элементов другого контейнера объекта отображения. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> В следующем примере настраиваются два объекта Sprite с именами <codeph>container1</codeph> и <codeph>container2</codeph>. Спрайт – это тип контейнера экранных объектов. В примере вызывается метод <codeph>addChild()</codeph> для создания иерархии отображения: <codeph>container1</codeph> является нижестоящим элементом<codeph>container2</codeph>, а два других экранных объекта, <codeph>circle1</codeph> и <codeph>circle2</codeph>, являются нижестоящими элементами <codeph>container1</codeph>. При вызове метода <codeph>trace()</codeph> показывается число нижестоящих элементов каждого объекта. Обратите внимание, что нижестоящие элементы второго уровня не включены в счетчик <codeph>numChildren</codeph>.
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChild_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда экранный объект добавляется в список отображения.
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда экранный объект добавляется в список отображения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Исключение выдается, если позиция в индексе не существует в списке нижестоящих элементов.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Инициирует, если нижестоящий элемент тот же, что и вышестоящий. Также выдается исключение, если вызывающий объект является нижестоящим элементом первого уровня (или второго и так далее уровней) добавляемого нижестоящего элемента.
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Экземпляр DisplayObject, передаваемый в параметр <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экземпляр DisplayObject для добавления в качестве нижестоящего элемента экземпляра DisplayObjectContainer.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса для добавления нижестоящего элемента. При указании занятой в настоящее время позиции индекса существующий в данной позиции нижестоящий объект и все вышестоящие позиции перемещаются по списку на одну позицию вверх. 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Добавляет нижестоящий объект к данному экземпляру DisplayObjectContainer.
     
  	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer. Нижестоящий элемент добавляется к указанной позиции индекса. Индекс 0 представляет собой заднюю (нижнюю) часть списка отображения для объекта DisplayObjectContainer.
	 
	 <p>Так, в следующем примере представлено три объекта отображения с метками а, b и c в позициях индекса 0, 1 и 2 соответственно.</p>
	 
	 <p><adobeimage alt="b над c над a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>При добавлении нижестоящего объекта, уже имеющего отличный от других контейнер экранного объекта в качестве вышестоящего элемента, объект удаляется из списка нижестоящих элементов другого контейнера объекта отображения. </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.addChildAt.1.as"> В следующем примере создается контейнер экранных объектов <codeph>container</codeph>, и в его список отображения добавляется экранный объект <codeph>circle1</codeph>. Затем посредством вызова <codeph>container.addChildAt(circle2, 0)</codeph> добавляется объект <codeph>circle2</codeph> в позицию индекса 0 (задний план) и перемещает объект <codeph>circle1</codeph> в позицию индекса 1.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
var circle2:Sprite = new Sprite();

container.addChild(circle1);
container.addChildAt(circle2, 0);

trace(container.getChildAt(0) == circle2); // true
trace(container.getChildAt(1) == circle1); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>addChild()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChildAt_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда экранный объект добавляется в список отображения.
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда экранный объект добавляется в список отображения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:areInaccessibleObjectsUnderPoint"><apiName>areInaccessibleObjectsUnderPoint</apiName><shortdesc>
	 Показывает, могут ли ограничения безопасности привести к пропуску каких-либо экранных объектов в списке, возвращаемом в результате вызова метода DisplayObjectContainer.getObjectsUnderPoint() с заданной точкой point.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Значение <codeph>true</codeph>, если точка содержит нижестоящие экранные объекты с ограничениями по безопасности.
	 
 	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка, под которой следует осуществлять поиск.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Показывает, могут ли ограничения безопасности привести к пропуску каких-либо экранных объектов в списке, возвращаемом в результате вызова метода <codeph>DisplayObjectContainer.getObjectsUnderPoint()</codeph> с заданной точкой <codeph>point</codeph>. По умолчанию содержимое из одного домена не имеет доступ к объектам из другого домена, если это не разрешено посредством вызова метода <codeph>Security.allowDomain()</codeph>. 
	 
	 <p>Дополнительные сведения см. в следующих разделах: </p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>     
     
	 <p>Параметр <codeph>point</codeph> находится в координатной плоскости рабочей области, которая может отличаться от координатной плоскости контейнера объектов отображения (если это не рабочая область). Можно использовать методы <codeph>globalToLocal()</codeph> и <codeph>localToGlobal()</codeph> для преобразования точек между этими координатными плоскостями.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.areInaccessibleObjectsUnderPoint.as"> Следующий код создает контейнер экранных объектов <codeph>container</codeph>. В следующем блоке кода используется объект Loader для загрузки файла JPEG с именем "test.jpg" с удаленного файлового сервера. Обратите внимание, что свойство <codeph>checkPolicyFile</codeph> объекта LoaderContext, использованного в качестве параметра в методе <codeph>load()</codeph>, имеет значение <codeph>false</codeph>. По завершении загрузки файла код вызывает метод <codeph>loaded()</codeph>, который в свою очередь вызывает метод <codeph>container.areInaccessibleObjectsUnderPoint()</codeph>, возвращающий значение <codeph>true</codeph>, так как загруженное содержимое находится на недоступном домене.
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.system.LoaderContext;
import flash.net.URLRequest;
import flash.events.Event;
import flash.geom.Point;

var container:Sprite = new Sprite();

var urlReq:URLRequest = new URLRequest("http://localhost/RemoteFile.swf");
var ldr:Loader = new Loader();
var context:LoaderContext = new LoaderContext();
context.checkPolicyFile = false;
ldr.load(urlReq, context);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);

function loaded(event:Event):void {
    var pt:Point = new Point(1, 1);
    trace(container.areInaccessibleObjectsUnderPoint(pt)); // true
}

function urlNotFound(event:Event):void {
    trace("The URL was not found."); 
}
</codeblock> В данном примере предполагается, что SWF-файл, созданный этим кодом, загружается не с того домена, что файл JPEG, и что загруженный файл JPEG занимает точку с координатами (1, 1). 
</example></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getObjectsUnderPoint()"><linktext>getObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:contains"><apiName>contains</apiName><shortdesc>
	 Определяет, является ли указанный объект отображения нижестоящим объектом экземпляра DisplayObjectContainer или самим экземпляром.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Значение <codeph>true</codeph>, если объект <codeph>child</codeph> является нижестоящим элементом объекта DisplayObjectContainer или самого контейнера, в противном случае значение <codeph>false</codeph>.
	 
	  
	  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Тестируемый нижестоящий объект.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, является ли указанный объект отображения нижестоящим объектом экземпляра DisplayObjectContainer или самим экземпляром. Область поиска охватывает весь список отображения, включая данный экземпляр DisplayObjectContainer. Нижестоящие элементы второго, третьего и последующих уровней возвращают значение <codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.contains.1.as"> В следующем примере настраивается ряд объектов Sprite, одни из которых добавляются в списки нижестоящих элементов относительно других. (Объект Sprite – это тип контейнера объектов отображения.) Отношения между различными объектами можно проследить, вызвав метод <codeph>contains()</codeph>.
<codeblock>
import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();
var sprite4:Sprite = new Sprite();

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite1.contains(sprite1)); // true
trace(sprite1.contains(sprite2)); // true
trace(sprite1.contains(sprite3)); // true
trace(sprite1.contains(sprite4)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildAt"><apiName>getChildAt</apiName><shortdesc>
     Возвращает экземпляр нижестоящего экранного объекта, существующий в заданной позиции индекса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Исключение выдается, если индекс не существует в списке нижестоящих элементов.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Данный нижестоящий объект отображения принадлежит изолированной программной среде, к которой нет доступа. Чтобы избежать такой ситуации, нижестоящий ролик должен вызвать метод <codeph>Security.allowDomain()</codeph>.
     
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Дочерний экранный объект в заданной позиции индекса.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса дочернего объекта.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает экземпляр дочернего экранного объекта, существующий в заданной позиции индекса.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildAt.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, а затем добавляются три экранных объекта в список нижестоящих элементов объекта <codeph>container</codeph>. После вызова метода <codeph>getChildAt()</codeph> отображаются позиции нижестоящих объектов.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();

container.addChild(sprite1);
container.addChild(sprite2);
container.addChildAt(sprite3, 0);

trace(container.getChildAt(0) == sprite3); // true
trace(container.getChildAt(1) == sprite1); // true
trace(container.getChildAt(2) == sprite2); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildByName()"><linktext>getChildByName()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildByName"><apiName>getChildByName</apiName><shortdesc>
     Возвращает экземпляр нижестоящего экранного объекта с заданным именем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Данный нижестоящий экранный объект принадлежит изолированной программной среде, к которой нет доступа. Чтобы избежать такой ситуации, нижестоящий ролик должен вызвать метод <codeph>Security.allowDomain()</codeph>.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Нижестоящий экранный объект с заданным именем.
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя возвращаемого нижестоящего элемента.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает экземпляр нижестоящего экранного объекта с заданным именем. Если заданное имя соответствует нескольким нижестоящим экранным объектам, метод возвращает первый из списка.
     
	 <p>Метод <codeph>getChildAt()</codeph> работает быстрее метода <codeph>getChildByName()</codeph>. Метод <codeph>getChildAt()</codeph> обращается к нижестоящему элементу из кэшированного массива, а методу <codeph>getChildByName()</codeph> приходится искать нижестоящий элемент через связанный список.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, а затем в него добавляются два нижестоящих экранных объекта. Затем код вызывает методы <codeph>getChildByName()</codeph> и <codeph>getChildIndex()</codeph>, чтобы получить позицию индекса нижестоящего элемента объекта <codeph>container</codeph> с именем <codeph>"sprite1"</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildAt()"><linktext>getChildAt()</linktext></link><link href="flash.display.xml#DisplayObject/name"><linktext>flash.display.DisplayObject.name</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildIndex"><apiName>getChildIndex</apiName><shortdesc>
     Возвращает позицию индекса для экземпляра DisplayObject child.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Выдается исключение, если нижестоящий параметр не является нижестоящим по отношению к данному объекту.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Позиция индекса для искомого нижестоящего экранного объекта.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Искомый экземпляр DisplayObject.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает номер позиции индекса для экземпляра дочернего объекта DisplayObject.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Возвращает позицию индекса для экземпляра DisplayObject <codeph>child</codeph>.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, а затем в него добавляются два нижестоящих экранных объекта. Затем код вызывает методы <codeph>getChildByName()</codeph> и <codeph>getChildIndex()</codeph> для получения позиции индекса нижестоящего объекта <codeph>container</codeph> с именем <codeph>"sprite1"</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getObjectsUnderPoint"><apiName>getObjectsUnderPoint</apiName><shortdesc>
     Возвращает массив объектов, расположенных ниже указанной позиции и являющихся нижестоящими объектами любого уровня для данного экземпляра DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Массив объектов, расположенных ниже указанной позиции и являющихся нижестоящими объектами любого уровня для данного экземпляра DisplayObjectContainer.
     
 	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка, под которой следует искать.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает массив объектов, расположенных ниже указанной позиции и являющихся нижестоящими объектами любого уровня для данного экземпляра DisplayObjectContainer. Нижестоящие объекты, недоступные по соображениям безопасности, опускаются из возвращенного массива. Чтобы определить, затрагивается ли возвращенный массив ограничением с целью обеспечения безопасности, вызовите метод <codeph>areInaccessibleObjectsUnderPoint()</codeph>.
	 
	 <p>Параметр <codeph>point</codeph> находится в координатной плоскости рабочей области, которая может отличаться от координатной плоскости контейнера объектов отображения (если это не рабочая область). Можно использовать методы <codeph>globalToLocal()</codeph> и <codeph>localToGlobal()</codeph> для преобразования точек между этими координатными плоскостями.</p>
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getObjectsUnderPoint.1.as"> В следующем примере создается контейнер объектов отображения с именем <codeph>container</codeph>, а затем в него добавляется два пересекающихся нижестоящих объекта отображения. Затем код дважды вызывает метод <codeph>getObjectsUnderPoint()</codeph>: один раз с использованием точки, касающейся только одного объекта, а затем с использованием точки, в которой объекты пересекаются. Свойство <codeph>length</codeph> возвращаемого массива показывает количество объектов контейнера в каждой точке.
<codeblock>
import flash.display.Sprite;
import flash.geom.Point;

var container:Sprite = new Sprite();

var square1:Sprite = new Sprite();
square1.graphics.beginFill(0xFFCC00);
square1.graphics.drawRect(0, 0, 40, 40);

var square2:Sprite = new Sprite();
square2.graphics.beginFill(0x00CCFF);
square2.graphics.drawRect(20, 0, 30, 40);

container.addChild(square1);
container.addChild(square2);

var pt:Point = new Point(10, 20);
var objects:Array = container.getObjectsUnderPoint(pt); 
trace(objects.length); // 1

pt = new Point(35, 20);
objects = container.getObjectsUnderPoint(pt);
trace(objects.length);  // 2
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/areInaccessibleObjectsUnderPoint()"><linktext>areInaccessibleObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChild"><apiName>removeChild</apiName><shortdesc>
	 Удаляет заданный объект child DisplayObject из списка нижестоящих элементов экземпляра DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Инициируется, если нижестоящий параметр не является нижестоящим элементом данного объекта.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Экземпляр DisplayObject, передаваемый в параметр <codeph>child</codeph>.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Удаляемый экземпляр DisplayObject.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Удаляет нижестоящий экранный объект из экземпляра DisplayObjectContainer.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Удаляет заданный объект <codeph>child</codeph> DisplayObject из списка нижестоящих элементов экземпляра DisplayObjectContainer. Свойство <codeph>parent</codeph> удаленного нижестоящего элемента получает значение <codeph>null</codeph>, а сам объект утилизуется в ходе «сборки мусора», если отсутствуют другие ссылки на нижестоящий элемент. Позиции индексов объектов отображения, расположенных над нижестоящим элементом в DisplayObjectContainer уменьшаются на 1.
	 
	 <p>Сборщик мусора перераспределяет неиспользуемый объем памяти. Когда на переменную или объект больше нет ссылок или он хранится в другом месте, сборщик мусора очищает и утилизирует память, которую он занимал, при условии отсутствия ссылок</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChild.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, а затем в него добавляются два нижестоящих экранных объекта. Для объекта <codeph>container</codeph> добавляется прослушиватель событий, чтобы при нажатии пользователем на нижестоящий объект контейнера, метод <codeph>removeChild()</codeph> удалял его из списка потомков контейнера.
<codeblock>
 
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);

container.addChild(circle1);
container.addChild(circle2);

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    container.removeChild(DisplayObject(event.target)); 
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 Удаляет нижестоящий DisplayObject из заданной позиции индекса в списке потомков DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Данный нижестоящий экранный объект принадлежит изолированной программной среде, к которой нет доступа у вызывающего объекта. Чтобы избежать такой ситуации, нижестоящий ролик должен вызвать метод <codeph>Security.allowDomain()</codeph>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Исключение выдается, если индекс не существует в списке нижестоящих элементов.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Удаленный экземпляр DisplayObject.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Удаляемый индекс нижестоящего элемента DisplayObject.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Удаляет нижестоящий экранный объект в заданной позиции <codeph>index</codeph> из экземпляра DisplayObjectContainer.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Удаляет нижестоящий DisplayObject из заданной позиции <codeph>индекса</codeph> в списке потомков DisplayObjectContainer. Свойство <codeph>parent</codeph> удаленного нижестоящего элемента получает значение <codeph>null</codeph>, а сам объект очищается, если нет других ссылок на нижестоящие элементы. Позиции индекса экранных объектов, расположенных над нижестоящим элементом в DisplayObjectContainer уменьшаются на 1.
	 
	 <p>Сборщик мусора перераспределяет неиспользуемый объем памяти. Когда на переменную или объект больше нет ссылок или он хранится в другом месте, сборщик мусора очищает и утилизирует память, которую он занимал, при условии отсутствия ссылок</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChildAt.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, а затем в него добавляется два дочерних экранных объекта. Затем код показывает, что при вызове метода <codeph>removeChildAt()</codeph> для удаления элемента на самой нижней позиции индекса (0) все остальные нижестоящие объекты в списке перемещаются на одну позицию вниз.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.numChildren) // 2
container.removeChildAt(0); 
trace(container.numChildren) // 1
trace(container.getChildAt(0).name); // sprite2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	Изменяет положение существующего потомка в DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Исключение выдается, если индекс не существует в списке нижестоящих элементов.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>Выдается исключение, если нижестоящий параметр не является нижестоящим по отношению к данному объекту.
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Нижестоящий экземпляр DisplayObject, для которого нужно изменить номер индекса.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Полученный в результате номер индекса для нижестоящего экранного объекта <codeph>child</codeph>.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Изменяет номер позиции индекса для существующего нижестоящего элемента.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	Изменяет положение существующего нижестоящего элемента в DisplayObjectContainer. Это отражается на иерархическом представлении нижестоящих объектов. Так, в следующем примере показано три разных объекта с именами a, b и c в позициях индекса 0, 1 и 2 соответственно.
	
	<p><adobeimage alt="c над b над a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>Когда используется метод <codeph>setChildIndex()</codeph> и указывается уже занятая позиция индекса, меняются только позиции между прежней и новой позицией экранного объекта. Все остальные остаются без изменения. Если потомок перемещается на более НИЗКУЮ позицию, позиции всех потомков между этими позициями станут на 1 ВЫШЕ. Если потомок перемещается на более ВЫСОКУЮ позицию, позиции всех потомков между этими позициями станут на 1 НИЖЕ. Например, если контейнер экранных объектов из предыдущего примера имеет имя <codeph>container</codeph>, можно поменять позициями экранные объекты с именами a и b, вызвав следующий код:</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>В результате этого объекты выстраиваются следующим образом:</p>
	
    <p><adobeimage alt="c над a над b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc><example conref="examples\DisplayObjectContainer.setChildIndex.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, а затем в него добавляется три немного пересекающихся нижестоящих экранных объекта. Когда пользователь нажимает на один из этих объектов, метод <codeph>clicked()</codeph> вызывает метод <codeph>setChildIndex()</codeph>, чтобы переместить нажатый объект на верхнюю позицию в списке отображения объекта <codeph>container</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.addEventListener(MouseEvent.CLICK, clicked);
 
var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(100, 40, 40);
circle2.addEventListener(MouseEvent.CLICK, clicked);
 
var circle3:Sprite = new Sprite();
circle3.graphics.beginFill(0x0000FF);
circle3.graphics.drawCircle(70, 80, 40);
circle3.addEventListener(MouseEvent.CLICK, clicked);
 
container.addChild(circle1);
container.addChild(circle2);
container.addChild(circle3);
addChild(container);
 
function clicked(event:MouseEvent):void {
    var circle:Sprite = Sprite(event.target);
    var topPosition:uint = container.numChildren - 1;
    container.setChildIndex(circle, topPosition);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getChildIndex()"><linktext>getChildIndex()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildren"><apiName>swapChildren</apiName><shortdesc>
	 Меняет местами (в порядке «от начала к концу») два заданных нижестоящих объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Выдается исключение, если любой из нижестоящих параметров не является нижестоящим для данного объекта.
	 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Первый нижестоящий объект.
	 
     </apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Второй нижестоящий объект.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Меняет местами (в порядке «от начала к концу») два заданных нижестоящих объекта. Все остальные нижестоящие объекты в контейнере экранных объектов остаются на прежних позициях.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildren.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, затем в него добавляются два нижестоящих экранных объекта, после чего иллюстрируется результат вызова метода <codeph>swapChildren()</codeph>.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2

container.swapChildren(sprite1, sprite2);

trace(container.getChildAt(0).name); // sprite2
trace(container.getChildAt(1).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 Меняет местами (в порядке «от начала к концу») нижестоящие объекты, расположенные в двух заданных позициях индекса в списке нижестоящих элементов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если ни один индекс не существует в списке нижестоящих элементов.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса первого нижестоящего объекта.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса второго нижестоящего объекта.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Меняет местами (в порядке «от начала к концу») нижестоящие объекты, расположенные в двух заданных позициях индекса в списке потомков. Все остальные нижестоящие объекты в контейнере экранных объектов остаются на прежних позициях.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildrenAt.1.as"> В следующем примере создается контейнер экранных объектов с именем <codeph>container</codeph>, затем в него добавляются три нижестоящих экранных объекта, после чего показывается, как вызов метода<codeph>swapChildrenAt()</codeph> изменяет список отображения контейнера.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

container.addChild(sprite1);
container.addChild(sprite2);
container.addChild(sprite3);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite3

container.swapChildrenAt(0, 2);

trace(container.getChildAt(0).name); // sprite3
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:DisplayObjectContainer:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью мыши. Если объект реагирует на мышь, пользователь может осуществлять действия с ним с помощью мыши. Значение по умолчанию – <codeph>true</codeph>.
	 
	 <p>Это свойство удобно использовать, когда кнопка создается с помощью экземпляра класса Sprite (а не класса SimpleButton). Когда для создания кнопки используется экземпляр Sprite, при желании можно украсить кнопку с помощью метода <codeph>addChild()</codeph>, добавив дополнительные экземпляры Sprite. Этот процесс может вызывать непредвиденное поведение событий мыши, так как целевым объектом события мыши вместо вышестоящего экземпляра могут стать экземпляры Sprite, добавленные в качестве нижестоящих. Чтобы родительский экземпляр гарантированно был целевым объектом событий мыши, можно задать его свойству <codeph>mouseChildren</codeph> значение <codeph>false</codeph>.</p>
	 <p> При настройке данного свойства события не отправляются. Чтобы создать интерактивные функции, необходимо использовать метод <codeph>addEventListener()</codeph>.</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.mouseChildren.1.as"> В следующем примере настраивается объект Sprite (тип контейнера экранных объектов) с именем <codeph>container</codeph> и показывается, что когда свойству <codeph>mouseChildren</codeph> задается значение <codeph>false</codeph>, целью события <codeph>mouseClick</codeph> является объект <codeph>container</codeph>, а не его нижестоящие элементы.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
container.name = "container";
addChild(container);

var circle:Sprite = new Sprite();
circle.name = "circle";
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);

container.addChild(circle);

container.mouseChildren = false;

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace(event.target.name); // container
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>flash.display.Sprite.buttonMode</linktext></link><link href="flash.events.xml#EventDispatcher/addEventListener()"><linktext>flash.events.EventDispatcher.addEventListener()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObjectContainer:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 Возвращает число нижестоящих элементов данного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Возвращает число нижестоящих элементов данного объекта.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> В следующем примере настраиваются два объекта Sprite с именами <codeph>container1</codeph> и <codeph>container2</codeph>. Спрайт – это тип контейнера экранных объектов. В примере вызывается метод <codeph>addChild()</codeph> для создания иерархии отображения: <codeph>container1</codeph> является нижестоящим элементом<codeph>container2</codeph>, а два других экранных объекта, <codeph>circle1</codeph> и <codeph>circle2</codeph>, являются нижестоящими элементами <codeph>container1</codeph>. При вызове метода <codeph>trace()</codeph> показывается число нижестоящих элементов каждого объекта. Обратите внимание, что нижестоящие элементы второго уровня не включены в счетчик <codeph>numChildren</codeph>.
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью клавиши Tab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>При вызове данного свойства объекта Stage выдается исключение. Объект Stage не реализует это свойство.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью клавиши Tab. Включает или отключает переход между потомками объекта с помощью клавиши Tab. Значение по умолчанию –<codeph>true</codeph>.
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.tabChildren.1.as"> В следующем примере создается контейнер экранных объектов <codeph>container1</codeph> и в его список отображения добавляется два экранных объекта: <codeph>circle1</codeph> и <codeph>circle2</codeph>. В этом примере для tabChildren потомков задается значение <codeph>false</codeph>, чтобы последовательностью перехода посредством клавиши Tab можно было управлять с помощью <codeph>tabIndex</codeph>.
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();
container.tabChildren = false;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.tabIndex = 1;

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);
circle2.tabIndex = 0;

container.addChild(circle1);
container.addChild(circle2);
</codeblock> Чтобы просмотреть результаты данного примера, файл нужно скомпилировать и запустить. Щелкнув один из кругов, можно нажать клавишу TAB, чтобы перевести фокус на другой экранный объект (выделенный желтым прямоугольником).
</example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
     Возвращает объект TextSnapshot для данного экземпляра DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает объект TextSnapshot для данного экземпляра DisplayObjectContainer.
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.textSnapshot.1.as"> Следующий пример поддерживается только в среде разработки Flash. Flex не имеет возможностей добавления статического текста в файл. Чтобы соответствующим образом подготовить файл Flash, нужно добавить одно или несколько текстовых полей в первый кадр ролика. Затем вставьте следующий сценарий в первый кадр и запустите файл. Будет выведен добавленный вами статический текст.
<codeblock>
trace(this.textSnapshot.getText(0, this.textSnapshot.charCount));
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot"><linktext>flash.text.TextSnapshot</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
 Определяет заливку градиентом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Определяет заливку градиентом. 
 
 <p>
 Используйте объект GraphicsGradientFill совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>. Рисование объекта GraphicsGradientFill эквивалентно вызову метода <codeph>Graphics.beginGradientFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsGradientFill:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
     Создает новый объект GraphicsGradientFill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>linear</apiData><apiDesc>Значение из класса GradientType, определяющее, какой тип градиента должен использоваться: <codeph>GradientType.LINEAR</codeph> или <codeph>GradientType.RADIAL</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив шестнадцатеричных значений цвета RGB, который должен использоваться в градиенте; например, красный – 0xFF0000, синий – 0x0000FF и т.д. Можно указать до 15 цветов. Для каждого цвета необходимо указать соответствующее значение в параметрах альфа-канала и пропорций.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений альфа-канала для соответствующих цветов в массиве цветов. Действительные значения – от 0 до 1. Если значение меньше 0, то используется 0. Если значение больше 1, то используется 1.
     
     </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений распределения цветов; действительными являются значения от 0 до 255. Это значение определяет процент ширины, на которой цвет представлен на 100% Значение 0 обозначает левую позицию окна градиента, а 255 – правую. 
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Матрица преобразования, определенная классом flash.geom.Matrix. Класс flash.geom.Matrix включает метод <codeph>createGradientBox()</codeph>, позволяющий удобно настроить матрицу для использования с методом <codeph>beginGradientFill()</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>pad</apiData><apiDesc>Значение из класса SpreadMethod, определяющее метод нанесения, который должен использоваться: <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> или <codeph>SpreadMethod.REPEAT</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiType value=""/><apiData>rgb</apiData><apiDesc>Значение из класса InterpolationMethod, указывающее, какое значение должно использоваться: <codeph>InterpolationMethod.LINEAR_RGB</codeph> или <codeph>InterpolationMethod.RGB</codeph>
     
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiType value=""/><apiData>0.0</apiData><apiDesc>Число, управляющее местоположением фокуса градиента. Значение 0 устанавливает фокус в центр. Значение 1 означает, что фокус находится у одного края окружности градиента. Значение -1 устанавливает фокус у другого края окружности градиента. Значение меньше -1 или больше 1 округляется до -1 или 1 соответственно.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект GraphicsGradientFill.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsGradientFill:alphas"><apiName>alphas</apiName><shortdesc>
     Массив значений альфа-канала для соответствующих цветов в массиве цветов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив значений альфа-канала для соответствующих цветов в массиве цветов. Действительны значения от 0 до 1. Если значение меньше 0, то используется 0. Если значение больше 1, то используется 1.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:colors"><apiName>colors</apiName><shortdesc>
     Массив шестнадцатеричных значений цвета RGB для применения в градиенте.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив шестнадцатеричных значений цвета RGB для применения в градиенте. Например, красный задается значением 0xFF0000, синий – значением 0x0000FF и т.д. Можно указать до 15 цветов. Для каждого цвета необходимо указать соответствующее значение в свойствах альфа-канала и пропорций.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:focalPointRatio"><apiName>focalPointRatio</apiName><shortdesc>
     Число, управляющее местоположением фокуса градиента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Число, управляющее местоположением фокуса градиента. Значение 0 устанавливает фокус в центр. Значение 1 устанавливает фокус у одного края окружности градиента. Значение -1 устанавливает фокус у другого края окружности градиента. Значение меньше -1 или больше 1 округляется до -1 или 1 соответственно. Следующий пример иллюстрирует случай, когда для <codeph>focalPointRatio</codeph> задано значение 0,75:
     
     <p><adobeimage alt="радиальный градиент при значении focalPointRatio, равном 0,75" href="../../images/radial_sketch.jpg"/> </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:matrix"><apiName>matrix</apiName><shortdesc>
     Матрица преобразования, определенная классом Matrix.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Матрица преобразования, определенная классом Matrix. Класс flash.geom.Matrix включает метод <codeph>createGradientBox()</codeph>, позволяющий настроить матрицу для использования с методом <codeph>beginGradientFill()</codeph>.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:ratios"><apiName>ratios</apiName><shortdesc>
     Массив значений распределения цветов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив значений распределения цветов. Действительны значения от 0 до 255. Это значение определяет процент ширины, на которой цвет представлен на 100% Значение 0 обозначает левую позицию окна градиента, а 255 – правую. 
     
     <p><b>Примечание.</b> Это значение показывает позиции в окне градиента, а не в координатной плоскости конечного градиента, которая может быть шире или уже окна градиента. Укажите величину каждого значения в свойстве <codeph>colors</codeph>. </p>
     
     <p>Например, для линейного градиента, состоящего из двух цветов (синего и зеленого) приводится пример, в котором представлено размещение цветов в градиенте, созданном с использованием разных значений массива <codeph>ratios</codeph>:</p>
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Градиент</entry></row></thead><tbody><row>
     
      <entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего к зеленому со значениями распределения 0 и 127" href="../../images/gradient-ratios-1.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего к зеленому с значениями распределения 0 и 255" href="../../images/gradient-ratios-2.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего цвета к зеленому с коэффициентами127 и 255" href="../../images/gradient-ratios-3.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     <p>Значения в массиве должны увеличиваться последовательно, например <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:interpolationMethod:get"><apiName>interpolationMethod</apiName><shortdesc>
     Значение класса InterpolationMethod, определяющее, какое должно использоваться значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение класса InterpolationMethod, определяющее, какое должно использоваться значение. Допустимыми значениями являются: <codeph>InterpolationMethod.LINEAR_RGB</codeph> или <codeph>InterpolationMethod.RGB</codeph>
     
     <p>Например, рассмотрим простой линейный градиент между двумя цветами (когда параметру <codeph>spreadMethod</codeph> задано значение <codeph>SpreadMethod.REFLECT</codeph>). Разные методы интерполяции влияют на внешний вид следующим образом: </p>
     
      <adobetable>
      
      
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="линейный градиент с методом InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="линейный градиент с методом InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
      </row><row>
      <entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
      <entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
      </row></tbody></tgroup></adobetable>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:spreadMethod:get"><apiName>spreadMethod</apiName><shortdesc>
     Значение класса SpreadMethod, указывающее метод нанесения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение класса SpreadMethod, указывающее метод нанесения. Допустимыми значениями являются: <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> или <codeph>SpreadMethod.REPEAT</codeph>. 
     
     <p>Ниже приведен пример простого линейного градиента между двумя цветами:</p>
     
     <codeblock>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       
     this.graphics.drawRect(0,0,100,100);
     </codeblock>
     
      <p>В этом примере используется метод нанесения <codeph>SpreadMethod.PAD</codeph>, и заливка градиентом выглядит следующим образом:</p>
     
      <p><adobeimage alt="Линейный градиент с методом SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
     
      <p>При использовании метода нанесения <codeph>SpreadMethod.REFLECT</codeph> заливка градиентом выглядит следующим образом:</p>
     
      <p><adobeimage alt="линейный градиент с методом SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
     
      <p>При использовании метода нанесения <codeph>SpreadMethod.REPEAT</codeph> заливка градиентом выглядит следующим образом:</p>
     
      <p><adobeimage alt="линейный градиент с методом SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:type:get"><apiName>type</apiName><shortdesc>
     Значение из класса GradientType, определяющее, какой тип градиента должен использоваться.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение из класса GradientType, определяющее, какой тип градиента должен использоваться. Допустимыми значениями являются <codeph>GradientType.LINEAR</codeph> или <codeph>GradientType.RADIAL</codeph>. 
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Sprite"><apiName>Sprite</apiName><shortdesc>
 Класс Sprite является базовым стандартным блоком списка отображения: это узел списка отображения, который способен отображать графику, а также может содержать нижестоящие элементы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Базовые экранный объект для объектов, создаваемых ActionScript.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Sprite является базовым стандартным блоком списка отображения: это узел списка отображения, который способен отображать графику, а также может содержать нижестоящие элементы.
 
 <p>Объект Sprite напоминает фрагмент ролика, но не имеет временной шкалы. Sprite – это подходящий базовый класс для объектов, не требующих временной шкалы. Например, будет логично использовать класс Sprite в качестве базы для компонентов пользовательского интерфейса, для которых обычно не используется временная шкала.</p>
 
 <p>Класс Sprite является новым в ActionScript 3.0. Это альтернатива для функций класса MovieClip, сохраняющая все возможности предыдущих версий ActionScript с целью обеспечения совместимости.</p>
 
 </apiDesc><example conref="examples\SpriteExample.as"> В следующем примере класс SpriteExample используется для отображения оранжевого квадрата в рабочей области, и при каждом щелчке или перетаскивании квадрата пользователем отправляется событие. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>Объявите свойство <codeph>size</codeph> (100 x 100 пикселей) и цвет фона (оранжевый) для дальнейшего использования при рисовании квадрата.</li>
 
  <li>После этого конструктор создает новый объект Sprite <codeph>child</codeph> и использует его для добавления двух прослушивателей событий и связанных с ними методов: <codeph>mouseDownHandler()</codeph> и <codeph>mouseUpHandler()</codeph>.</li>
 
  <li>Затем объект Sprite <codeph>child</codeph> передается методу <codeph>draw()</codeph>, который рисует оранжевый квадрат.</li>
 
  <li>После этого нижестоящий объект помещается в список отображения через вызов метода <codeph>addChild()</codeph>. </li>
 
  <li>Прослушиватели событий работают следующим образом.
 
  <ul>
      <li><codeph>mouseDownHandler()</codeph>: когда пользователь щелкает объект Sprite, этот метод добавляет прослушиватель события mouseMove, метод <codeph>mouseMoveHandler()</codeph>, обрабатывающий перемещение мыши. Затем вызывается метод <codeph>startDrag()</codeph>, позволяющий перетаскивать объект Sprite.</li>
 
      <li><codeph>mouseUpHandler()</codeph>: когда кнопка мыши отпускается, прослушиватель события mouseMove удаляется и вызывается метод <codeph>stopDrag()</codeph>, фиксирующий оранжевый квадрат на месте.</li>
 
      <li><codeph>mouseMoveHandler</codeph>: пока удерживается левая кнопка мыши, этот метод предписывает проигрывателю непрерывное перерисовывание оранжевого квадрата.</li>
 
  </ul>
  </li>
 
 </ol>
 
 <p><b>Примечание. </b>Каждый метод прослушивателя событий объявляет локальную переменную <codeph>sprite</codeph>, которая назначается свойству <codeph>target</codeph> события.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;

    public class SpriteExample extends Sprite {
        private var size:uint    = 100;
        private var bgColor:uint = 0xFFCC00;

        public function SpriteExample() {
            var child:Sprite = new Sprite();
            child.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
            child.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
            draw(child);
            addChild(child);
        }

        private function mouseDownHandler(event:MouseEvent):void {
            trace("mouseDownHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.startDrag();
        }

        private function mouseUpHandler(event:MouseEvent):void {
            trace("mouseUpHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.stopDrag();
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            trace("mouseMoveHandler");
            event.updateAfterEvent();
        }

        private function draw(sprite:Sprite):void {
            sprite.graphics.beginFill(bgColor);
            sprite.graphics.drawRect(0, 0, size, size);
            sprite.graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:Sprite:Sprite"><apiName>Sprite</apiName><shortdesc>
	Создает новый экземпляр Sprite.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Создает новый экземпляр Sprite. Создав экземпляр Sprite вызовите метод <codeph>DisplayObjectContainer.addChild()</codeph> или <codeph>DisplayObjectContainer.addChildAt()</codeph>, чтобы добавить Sprite в родительский объект DisplayObjectContainer.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:Sprite:startDrag"><apiName>startDrag</apiName><shortdesc>
	 Позволяет пользователю перетаскивать заданный спрайт (растровый графический объект, легко перемещаемый по экрану).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.startDrag, startDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lockCenter</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, блокируется ли перетаскиваемый спрайт по центру положения мыши (<codeph>true</codeph>) или по точке, на которой впервые щелкнул мышью пользователь (<codeph>false</codeph>). 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>bounds</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Значение относительно координат родительского объекта Sprite, задающее для него закрепленный прямоугольник. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Позволяет пользователю перетаскивать заданный спрайт (растровый графический объект, легко перемещаемый по экрану). Спрайт можно перетаскивать до явной остановки через вызов метода <codeph>Sprite.stopDrag()</codeph> или до того, как можно будет перетаскивать другой спрайт. Одновременно можно перетаскивать только один спрайт.
	 <p>Трехмерные объекты отображения управляются мышью, а метод <codeph>Sprite.startDrag()</codeph> позволяет перемещать объект в трехмерной плоскости, определенной объектом отображения. Или, если экранный объект является двумерным объектом и нижестоящим элементом трехмерного объекта, двумерный объект перемещается в трехмерной плоскости, определенной трехмерным вышестоящим объектом.</p>
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> В следующем примере создается спрайт <codeph>circle</codeph> и два спрайта <codeph>target</codeph>. Метод <codeph>startDrag()</codeph> вызывается для спрайта <codeph>circle</codeph>, когда пользователь помещает курсор на спрайт и нажимает кнопку мыши, а метод <codeph>stopDrag()</codeph> вызывается, когда пользователь отпускает кнопку мыши. Это позволяет пользователю перетащить спрайт. При отпускании кнопки мыши вызывается метод <codeph>mouseRelease()</codeph>, отслеживающий <codeph>name</codeph> объекта <codeph>dropTarget</codeph> – того, к которому пользователь перетащил спрайт <codeph>circle</codeph>:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Sprite:stopDrag"><apiName>stopDrag</apiName><shortdesc>
	 Завершает метод startDrag().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sprite, movieclip.stopDrag, stopDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Завершает метод <codeph>startDrag()</codeph>. Спрайт, созданный перетаскиваемым с помощью метода <codeph>startDrag()</codeph>, остается таковым до добавления метода <codeph>stopDrag()</codeph> или до того, как другой спрайт станет перетаскиваемым. Одновременно можно перетаскивать только один спрайт.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> В следующем примере создается спрайт <codeph>circle</codeph> и два спрайта <codeph>target</codeph>. Метод <codeph>startDrag()</codeph> вызывается для спрайта <codeph>circle</codeph>, когда пользователь помещает курсор на спрайт и нажимает кнопку мыши, а метод <codeph>stopDrag()</codeph> вызывается, когда пользователь отпускает кнопку мыши. Это позволяет пользователю перетащить спрайт. При отпускании кнопки мыши вызывается метод <codeph>mouseRelease()</codeph>, отслеживающий <codeph>name</codeph> объекта <codeph>dropTarget</codeph> – того, к которому пользователь перетащил спрайт <codeph>circle</codeph>:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Sprite:buttonMode:get"><apiName>buttonMode</apiName><shortdesc>
     Задает режим кнопки данного спрайта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Задает режим кнопки данного спрайта.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Задает режим кнопки данного спрайта. При значении <codeph>true</codeph> этот спрайт ведет себя как кнопка, то есть, вызывает отображение курсора в виде руки, когда над ним проходит мышь, и может получать событие <codeph>click</codeph> при нажатии клавиш Enter и «Пробел», когда спрайт в фокусе. Можно отменить отображение курсора в виде руки, задав свойству <codeph>useHandCursor</codeph> значение <codeph>false</codeph>, в этом случае будет отображаться указатель.
     
     <p>В целом, для создания кнопок лучше использовать класс SimpleButton, однако свойство <codeph>buttonMode</codeph> можно использовать для придания спрайту некоторых функций кнопок. Чтобы включить спрайт в последовательность перехода посредством клавиши Tab, задайте свойству <codeph>tabEnabled</codeph> (унаследованному от класса InteractiveObject и имеющему по умолчанию значение <codeph>false</codeph>) значение <codeph>true</codeph>. Кроме того, подумайте, должны ли нижестоящие элементы спрайта реагировать на наведение мыши. Большинство кнопок блокируют воздействие мыши на нижестоящие объекты, так как это запутывает поток событий. Чтобы отключить воздействие мыши на нижестоящие объекты, необходимо задать свойству <codeph>mouseChildren</codeph> (унаследованному от класса DisplayObjectContainer) значение <codeph>false</codeph>.</p>
     
     <p>Если свойство <codeph>buttonMode</codeph> используется с классом MovieClip (подклассом класса Sprite), кнопка может получить дополнительные функции. Если включить кадры с подписями _up, _over и _down, проигрыватель Flash Player передает автоматические изменения состояния (функция, подобная возможностям фрагментов роликов, используемых в качестве кнопок, в предыдущих версиях ActionScript). Эти автоматические изменения состояния недоступны для спрайтов, так как у них нет временной шкалы и, следовательно, кадров для добавления подписей. </p>
	 
	 </apiDesc><example conref="examples\Sprite.buttonMode.1.as"> В следующем примере создается два спрайта, для одного из которых свойству <codeph>buttonMode</codeph> задается значение <codeph>true</codeph>, а для другого – <codeph>false</codeph>. Когда приложение компилируется и запускается, оба спрайта реагируют на события мыши, но только тот, для которого <codeph>buttonMode</codeph> имеет значение <codeph>true</codeph>, использует курсор в виде руки и включается в последовательность перехода посредством клавиши Tab.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton"><linktext>SimpleButton</linktext></link><link href="flash.display.xml#Sprite/useHandCursor"><linktext>Sprite.useHandCursor</linktext></link><link href="flash.display.xml#InteractiveObject/tabEnabled"><linktext>InteractiveObject.tabEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:dropTarget:get"><apiName>dropTarget</apiName><shortdesc>
	 Определяет экранный объект, над которым перетаскивается спрайт либо на котором спрайт был отпущен.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Sprite, Sprite.dropTarget, dropTarget
	 
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Определяет объект DisplayObject, над которым или на который перетаскивается спрайт.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет экранный объект, над которым перетаскивается спрайт либо на котором спрайт был отпущен.
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> В следующем примере создается спрайт <codeph>circle</codeph> и два спрайта <codeph>target</codeph>. Метод <codeph>startDrag()</codeph> вызывается для спрайта <codeph>circle</codeph>, когда пользователь помещает курсор на спрайт и нажимает кнопку мыши, а метод <codeph>stopDrag()</codeph> вызывается, когда пользователь отпускает кнопку мыши. Это позволяет пользователю перетащить спрайт. При отпускании кнопки мыши вызывается метод <codeph>mouseRelease()</codeph>, который в свою очередь отслеживает <codeph>name</codeph> объекта, <codeph>dropTarget</codeph>, к которому пользователь перетащил спрайт <codeph>circle</codeph>:
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:graphics:get"><apiName>graphics</apiName><shortdesc>
     Задает объект Graphics, принадлежащий данному спрайту, в котором могут выполняться команды векторного рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Задает объект Graphics.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Задает объект Graphics, принадлежащий данному спрайту, в котором могут выполняться команды векторного рисования.
     
	 </apiDesc><example conref="examples\Sprite.graphics.1.as"> В следующем примере создается спрайт <codeph>circle</codeph> и используется его свойство <codeph>graphics</codeph> для отрисовки круга с желтой заливкой (0xFFCC00).
<codeblock>
import flash.display.Sprite;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:hitArea:get"><apiName>hitArea</apiName><shortdesc>
	 Определяет другой спрайт в качестве области щелчка для спрайта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Sprite</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет другой спрайт в качестве области щелчка для спрайта. Если свойство <codeph>hitArea</codeph> не существует или ему задано значение <codeph>null</codeph> или <codeph>undefined</codeph>, то в качестве области щелчка используется сам спрайт. Значение свойства <codeph>hitArea</codeph> может быть ссылкой на объект Sprite.
	 
	 <p>Свойство <codeph>hitArea</codeph> можно изменить в любой момент; модифицированный спрайт немедленно начинает использовать новое поведение области щелчка. Спрайт, настроенный в качестве области щелчка не обязательно должен быть видимым; его графическая форма, оставаясь невидимой, все равно обнаруживается в качестве области щелчка.</p>
	 
	 <p><b>Примечание.</b> Необходимо задать значение <codeph>false</codeph> свойству <codeph>mouseEnabled</codeph> спрайта, настроенного в качестве области щелчка. В противном случае кнопка спрайта может не работать, так как спрайт, настроенный в качестве области щелчка, получает события мыши вместо кнопки спрайта.</p>
	 
	 </apiDesc><example conref="examples\Sprite.hitArea.1.as"> В следующем примере создается спрайт <codeph>circle</codeph> и спрайт <codeph>square</codeph>. Спрайт <codeph>square</codeph> является областью щелчка <codeph>hitArea</codeph> для спрайта<codeph>circle</codeph>. Поэтому когда пользователь нажимает на спрайт <codeph>square</codeph>, спрайт <codeph>circle</codeph> отправляет событие <codeph>click</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xCCFF00);
square.graphics.drawRect(200, 0, 100, 100);

circle.hitArea = square;
square.mouseEnabled = false;

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void{
    trace(event.target == circle); // true
    trace(event.target == square); // false
}

addChild(circle);
addChild(square);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Управляет звуком в данном спрайте.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Управляет звуком в данном спрайте.
	 
	 </apiDesc><example conref="examples\Sprite.soundTransform.1.as"> В следующем примере создается спрайт с именем <codeph>container</codeph>, и в его список потомков добавляется объект Loader. Объект Loader загружает SWF-файл. Когда пользователь щелкает ссылку в текстовом поле <codeph>tf</codeph> со значением <codeph>true</codeph>, метод <codeph>mute()</codeph> задает свойство <codeph>volume</codeph> свойства <codeph>soundTransform</codeph> спрайта <codeph>container</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.events.IOErrorEvent;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.text.TextField;
import flash.media.SoundTransform;

var container:Sprite = new Sprite();
addChild(container);

var ldr:Loader = new Loader;
var urlReq:URLRequest = new URLRequest("SoundPlayer.swf");
ldr.load(urlReq);

container.addChild(ldr);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);
            
var tf:TextField = new TextField();
tf.htmlText = "&lt;a href = 'event:Mute'>Mute / Unmute&lt;/a>";
addChild(tf);

var mySoundTransform:SoundTransform = new SoundTransform();
mySoundTransform.volume = 1;

tf.addEventListener(MouseEvent.CLICK, mute);

function mute(event:MouseEvent):void {    
    if (mySoundTransform.volume == 0) {
        mySoundTransform.volume = 1;
    } else {
        mySoundTransform.volume = 0;        
    }
    container.soundTransform = mySoundTransform;
}

function urlNotFound(event:IOErrorEvent):void {
    trace("The URL was not found."); 
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
	 Логическое значение, определяющее, должен ли отображаться курсор в виде руки при наведении мыши на спрайт, в котором свойство buttonMode имеет значение true.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Логическое значение, определяющее, должен ли отображаться курсор в виде руки при наведении мыши на спрайт, в котором свойство buttonMode имеет значение true. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Логическое значение, определяющее, должен ли отображаться курсор в виде руки при наведении мыши на спрайт, в котором свойство <codeph>buttonMode</codeph> имеет значение <codeph>true</codeph>. Свойство <codeph>useHandCursor</codeph> по умолчанию имеет значение <codeph>true</codeph>. При <codeph>useHandCursor</codeph>, установленном в значение <codeph>true</codeph>, курсор в виде руки, используемый для кнопок, появляется при наведении мыши на спрайт-кнопку. Если же <codeph>useHandCursor</codeph> имеет значение <codeph>false</codeph>, используется указатель «стрелка».
	 
	 <p>Свойство <codeph>useHandCursor</codeph> можно изменить в любое время; модифицированный спрайт немедленно принимает новый вид курсора. </p>
     
     <p product="flex"><b>Примечание.</b> Если спрайт имеет нижестоящие спрайты, может потребоваться задание для свойства <codeph>mouseChildren</codeph> значения <codeph>false</codeph>. Например, если необходимо, чтобы курсор в виде руки отображался над элементом управления Flex &lt;mx:Label>, задайте для свойств <codeph>useHandCursor</codeph> и <codeph>buttonMode</codeph> значение <codeph>true</codeph>, а для свойства <codeph>mouseChildren</codeph> значение <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\Sprite.useHandCursor.1.as"> В следующем примере создается два спрайта, и свойству <codeph>buttonMode</codeph> обоих задается значение <codeph>true</codeph>, однако для одного из них свойство <codeph>useHandCursor</codeph> имеет значение <codeph>true</codeph>, а для другого – <codeph>false</codeph>. При компиляции и запуске приложения оба спрайта ведут себя как кнопки (включенные в последовательность перехода с помощью клавиши Tab), но только курсор в виде руки использует спрайт со свойством <codeph>useHandCursor</codeph> в значении <codeph>true</codeph>.
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.useHandCursor = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = true;
circle2.useHandCursor = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>buttonMode</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
 Определяет заливку растровым изображением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Определяет заливку растровым изображением. Растровое изображение может смягчаться, повторяться или располагаться в виде мозаики для заполнения области. Его также можно изменять с помощью матрицы преобразования.
 <p>
 Используйте объект GraphicsBitmapFill совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>. Рисование объекта GraphicsBitmapFill эквивалентно вызову метода <codeph>Graphics.beginBitmapFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsBitmapFill:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
     Создает новый объект GraphicsBitmapFill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Прозрачное или матовое растровое изображение, содержащее отображаемые биты.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект матрицы (из класса flash.geom.Matrix), который можно использовать для определения преобразований в растровом изображении.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>При значении <codeph>true</codeph> растровое изображение повторяется по шаблону мозаики. При значении <codeph>false</codeph> растровое изображение не повторяется, а его края используются для заливки всей области, выходящей за его пределы. 
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При выборе значения <codeph>false</codeph> визуализируются растровые изображения, увеличенные при помощи алгоритма ближайшего соседнего пикселя, которые могут выглядеть нечетко. При выборе значения <codeph>true</codeph> увеличенное растровое изображение визуализируется с помощью билинейного алгоритма. Обычно процедура визуализации с помощью алгоритма ближайшего соседа требует меньше времени.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект GraphicsBitmapFill.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsBitmapFill:bitmapData"><apiName>bitmapData</apiName><shortdesc>
     Прозрачное или матовое растровое изображение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
     Прозрачное или матовое растровое изображение.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:matrix"><apiName>matrix</apiName><shortdesc>
     Объект матрицы (из класса flash.geom.Matrix), определяющий преобразования в растровом изображении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Объект матрицы (из класса flash.geom.Matrix), определяющий преобразования в растровом изображении. Например, следующая матрица поворачивает растровое изображение на 45 градусов (пи/4 радиан):
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:repeat"><apiName>repeat</apiName><shortdesc>
     Указывает, будет ли растровое изображение повторяться по шаблону мозаики.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, будет ли растровое изображение повторяться по шаблону мозаики.
     
     <p>
     При значении <codeph>true</codeph> растровое изображение повторяется по шаблону мозаики. При значении <codeph>false</codeph> растровое изображение не повторяется, а его края используются для заливки всей области, выходящей за его пределы.</p>
     
     <p>Например, рассмотрим следующее растровое изображение (рисунок «шахматная доска» 20 х 20 пикселей):</p>
     
     <p><adobeimage alt="«шахматная доска» 20 х 20 пикселей" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
     
     <p>Когда для <codeph>repeat</codeph> задано значение <codeph>true</codeph> (как в следующем примере), в заливке повторяется растровое изображение:</p>
     
     <p><adobeimage alt="«шахматная доска» 60 х 60 пикселей" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
     
     <p>Когда для <codeph>repeat</codeph> задано значение <codeph>false</codeph>, в заливке растровым изображением используются краевые пиксели, чтобы залить область, выходящую за пределы изображения:</p>
     
     <p><adobeimage alt="изображение 60 х 60 без повторения" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsBitmapFill:smooth"><apiName>smooth</apiName><shortdesc>
     Указывает, применять ли алгоритм смягчения к растровому изображению.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, применять ли алгоритм смягчения к растровому изображению.
     <p>
     При выборе значения <codeph>false</codeph> визуализируются растровые изображения, увеличенные при помощи алгоритма ближайшего соседнего пикселя, которые могут выглядеть нечетко. При выборе значения <codeph>true</codeph>увеличенное растровое изображение визуализируется с помощью билинейного алгоритма. Обычно процедура визуализации с помощью алгоритма ближайшего соседнего пикселя требует меньше времени.
     </p>
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Задает стиль линии или штриха.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsStroke</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Задает стиль линии или штриха. 
 
 <p>
 Используйте объект GraphicsStroke совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>. Рисование объекта GraphicsStroke эквивалентно вызову одного из методов класса Graphics, задающего стиль линии, таких как <codeph>Graphics.lineStyle()</codeph>, <codeph>Graphics.lineBitmapStyle()</codeph> или <codeph>Graphics.lineGradientStyle()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>flash.display.Graphics.lineBitmapStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsStroke:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 Создает новый объект GraphicsStroke.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Целое число, определяющее толщину линии в точках; допустимыми являются значения от 0 до 255. Если число не указано или параметр не определен, то линия не будет проведена. Если передается значение меньше 0, по умолчанию задается 0. Значение 0 обозначает толщину одного волоса, максимальная толщина составляет 255. Если передается значение больше 255, по умолчанию задается 255. 
 
 </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Логическое значение, определяющее, следует ли выполнять хинтинг штрихов до полных пикселей. Оно влияет на позицию привязок кривой и на размер штриха линии как таковой. Если для <codeph>pixelHinting</codeph> задано значение <codeph>true</codeph>, проигрыватель Flash Player доводит ширину линии до полного пикселя. Если для <codeph>pixelHinting</codeph> задано значение <codeph>false</codeph>, в кривых и прямых линиях могут возникать разрывы. Например, на следующих рисунках показано, как проигрыватель Flash Player визуализирует два одинаковых округленных прямоугольника, которые отличаются только настройкой параметра <codeph>pixelHinting</codeph> в методе <codeph>lineStyle()</codeph> (с целью наглядности изображения увеличены на 200%):
 
 <p><adobeimage alt="pixelHinting false и pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 <p>Если значение не задано, для линии не используется хинтинг пикселей.</p>
  
 </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>Значение класса LineScaleMode, задающее режим масштабирования:
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> – Всегда масштабировать толщину линии при масштабировании объекта (по умолчанию).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> – Никогда не масштабировать толщину линии.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> – Не масштабировать толщину линии, если объект масштабируется <i>только</i> по вертикали. Например, рассмотрим следующие окружности, нарисованные линией толщиной в 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.VERTICAL</codeph>. Масштаб окружности слева изменен только по вертикали, а окружности справа – и по вертикали и по горизонтали.
 
 <p><adobeimage alt="Окружность, масштабированная по вертикали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> – Не масштабировать толщину линии, если объект масштабируется <i>только</i> по горизонтали. Например, рассмотрим следующие окружности, нарисованные линией толщиной 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.HORIZONTAL</codeph>. Масштаб окружности слева изменен только по горизонтали, а окружности справа – и по вертикали и по горизонтали.
 
 <p><adobeimage alt="Окружность, масштабированная по горизонтали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 
 </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Значение класса CapsStyle, задающее тип концов линии. Допустимые значения: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> и <codeph>CapsStyle.SQUARE</codeph>. Если значение не указано, Flash Player использует круглые концы. 
 <p>Следующий пример иллюстрирует разные параметры класса <codeph>capsStyle</codeph>. На рисунке представлено три синих линии толщиной 30 (к которым применяется <codeph>capsStyle</codeph>), а поверх них нанесена черная линия толщиной 1 (к которой <codeph>capsStyle</codeph> не применяется):
 </p>
 <p><adobeimage alt="NONE (нет), ROUND (круглый) и SQUARE (квадратный)" href="../../images/linecap.jpg"/></p>
 
 </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>round</apiData><apiDesc>Значение класса JointStyle, задающее тип стыка на углах. Допустимые значения: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> и <codeph>JointStyle.ROUND</codeph>. Если значение не указано, Flash Player использует круглые стыки. 
 
 <p>Следующий пример иллюстрирует разные параметры <codeph>joints</codeph>. На рисунке представлено три синих линии толщиной 30 (к которым применяется <codeph>jointStyle</codeph>), а поверх них нанесена черная линия толщиной 1 (к которой <codeph>jointStyle</codeph> не применяется):
 </p>
 
 <p><adobeimage alt="MITER (уголок), ROUND (круглый) и BEVEL (скос)" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Примечание.</b> Для <codeph>стыков</codeph> типа <codeph>JointStyle.MITER</codeph> можно использовать параметр <codeph>miterLimit</codeph>, чтобы ограничить длину уголка.</p>
 
 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3.0</apiData><apiDesc>Число, указывающее предел усечения уголка. Допустимыми являются значения в диапазоне 1-255 (остальные значения округляются до 1 или 255). Это значение используется, только если для <codeph>jointStyle</codeph> выбран тип <codeph>"miter"</codeph>. Значение <codeph>miterLimit</codeph> – это длина, до которой может продлеваться уголок после точки стыка. Значение выражает фактор <codeph>толщины</codeph> линии. Например, при факторе <codeph>miterLimit</codeph>, равном 2,5, и <codeph>толщине</codeph> в 10 пикселей, длина уголка достигает 25 пикселей. 
 
 <p>Рассмотрим следующие углы, все составленные из линий с <codeph>thickness</codeph> 20, но с разными значениями <codeph>miterLimit</codeph>: 1, 2 и 4. Поверх углов для наглядности нанесены черные линии, показывающие точки стыка:</p>
 
 <p><adobeimage alt="углы с miterLimit, равным 1, 2 и 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Обратите внимание, что данное значение <codeph>miterLimit</codeph> имеет специфический максимальный угол для усечения «уголка». В следующей таблице приводится несколько примеров.</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Значение <codeph>miterLimit</codeph>:</entry><entry>Углы, меньше этого, усекаются:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 градусов</entry></row><row><entry>2</entry>      <entry>60 градусов</entry></row><row><entry>4</entry>      <entry>30 градусов</entry></row><row><entry>8</entry>      <entry>15 градусов</entry></row></tbody></tgroup></adobetable>
 </apiDesc></apiParam><apiParam><apiItemName>fill</apiItemName><apiOperationClassifier>flash.display:IGraphicsFill</apiOperationClassifier><apiData>null</apiData><apiDesc>Экземпляр IGraphicsFill содержащий данные для заливки штриха. Экземпляр IGraphicsFill может представлять собой последовательность команд для заливки.
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Создает новый объект GraphicsStroke.
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsStroke:fill"><apiName>fill</apiName><shortdesc>
 Указывает экземпляр, содержащий данные для заливки штриха.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:IGraphicsFill</apiValueClassifier></apiValueDef><apiDesc>
 Указывает экземпляр, содержащий данные для заливки штриха. Экземпляр IGraphicsFill может представлять собой последовательность команд для заливки.
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:miterLimit"><apiName>miterLimit</apiName><shortdesc>
 Указывает предел усечения уголка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Указывает предел усечения уголка. Допустимыми являются значения в диапазоне 1-255 (остальные значения округляются до 1 или 255). Это значение используется, только если для <codeph>jointStyle</codeph> выбран тип <codeph>"miter"</codeph>. Значение <codeph>miterLimit</codeph> – это длина, до которой может продлеваться уголок после точки стыка. Значение выражает фактор <codeph>толщины</codeph> линии. Например, при факторе <codeph>miterLimit</codeph>, равном 2,5, и <codeph>толщине</codeph> в 10 пикселей, длина уголка достигает 25 пикселей. 
 
 <p>Рассмотрим следующие углы, все составленные из линий с <codeph>thickness</codeph> 20, но с разными значениями <codeph>miterLimit</codeph>: 1, 2 и 4. Поверх углов для наглядности нанесены черные линии, показывающие точки стыка:</p>
 
 <p><adobeimage alt="углы с miterLimit, равным 1, 2 и 4" href="../../images/miterLimit.jpg"/></p>
 
 <p>Обратите внимание, что данное значение <codeph>miterLimit</codeph> имеет специфический максимальный угол для усечения «уголка». В следующей таблице приводится несколько примеров.</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Значение <codeph>miterLimit</codeph>:</entry><entry>Углы, меньше этого, усекаются:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 градусов</entry></row><row><entry>2</entry>      <entry>60 градусов</entry></row><row><entry>4</entry>      <entry>30 градусов</entry></row><row><entry>8</entry>      <entry>15 градусов</entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:pixelHinting"><apiName>pixelHinting</apiName><shortdesc>
 Указывает, следует ли выполнять хинтинг до полных пикселей.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
 Указывает, следует ли выполнять хинтинг до полных пикселей. Оно влияет на позицию привязок кривой и на размер штриха линии как таковой. Если для <codeph>pixelHinting</codeph> задано значение <codeph>true</codeph>, проигрыватель Flash Player доводит ширину линии до полного пикселя. Если для <codeph>pixelHinting</codeph> задано значение <codeph>false</codeph>, в кривых и прямых линиях могут возникать разрывы. Например, на следующих рисунках показано, как проигрыватель Flash Player визуализирует два одинаковых округленных прямоугольника, которые отличаются только настройкой параметра <codeph>pixelHinting</codeph> в методе <codeph>lineStyle()</codeph> (с целью наглядности изображения увеличены на 200%):
 
 <p><adobeimage alt="pixelHinting false и pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:thickness"><apiName>thickness</apiName><shortdesc>
 Указывает толщину линии в точках; допустимыми являются значения от 0 до 255.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Указывает толщину линии в точках; допустимыми являются значения от 0 до 255. Если число не указано или параметр не определен, то линия не будет проведена. Если передается значение меньше 0, по умолчанию задается 0. Значение 0 обозначает толщину одного волоса, максимальная толщина составляет 255. Если передается значение больше 255, по умолчанию задается 255.
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:caps:get"><apiName>caps</apiName><shortdesc>
 Указывает тип концов линии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Указывает тип концов линии. Допустимые значения: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> и <codeph>CapsStyle.SQUARE</codeph>. Если значение не указано, Flash Player использует круглые концы. 
 <p>Следующий пример иллюстрирует разные параметры класса <codeph>capsStyle</codeph>. На рисунке представлено три синих линии толщиной 30 (к которым применяется <codeph>capsStyle</codeph>), а поверх них нанесена черная линия толщиной 1 (к которой <codeph>capsStyle</codeph> не применяется):
 </p>
 <p><adobeimage alt="NONE (нет), ROUND (круглый) и SQUARE (квадратный)" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:joints:get"><apiName>joints</apiName><shortdesc>
 Задает тип стыка на углах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Задает тип стыка на углах. Допустимые значения: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> и <codeph>JointStyle.ROUND</codeph>. Если значение не указано, Flash Player использует круглые стыки. 
 
 <p>Следующий пример иллюстрирует разные параметры <codeph>joints</codeph>. На рисунке представлено три синих линии толщиной 30 (к которым применяется <codeph>jointStyle</codeph>), а поверх них нанесена черная линия толщиной 1 (к которой <codeph>jointStyle</codeph> не применяется):
 </p>
 
 <p><adobeimage alt="MITER (уголок), ROUND (круглый) и BEVEL (скос)" href="../../images/linejoin.jpg"/></p>
 
 <p><b>Примечание.</b> Для <codeph>стыков</codeph> типа <codeph>JointStyle.MITER</codeph> можно использовать параметр <codeph>miterLimit</codeph>, чтобы ограничить длину уголка.</p>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
 Задает масштаб толщины штриха.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Задает масштаб толщины штриха. Допустимые значения:
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> – Всегда масштабировать толщину линии при масштабировании объекта (по умолчанию).
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> – Никогда не масштабировать толщину линии.
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> – Не масштабировать толщину линии, если объект масштабируется <i>только</i> по вертикали. Например, рассмотрим следующие окружности, нарисованные линией толщиной в 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.VERTICAL</codeph>. Масштаб окружности слева изменен только по вертикали, а окружности справа – и по вертикали и по горизонтали.
 
 <p><adobeimage alt="Окружность, масштабированная по вертикали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> – Не масштабировать толщину линии, если объект масштабируется <i>только</i> по горизонтали. Например, рассмотрим следующие окружности, нарисованные линией толщиной 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.HORIZONTAL</codeph>. Масштаб окружности слева изменен только по горизонтали, а окружности справа – и по вертикали и по горизонтали.
 
 <p><adobeimage alt="Окружность, масштабированная по горизонтали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Указывает на завершение графической заливки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Указывает на завершение графической заливки. Используйте объект GraphicsEndFill совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>.
 
 <p>
 Рисование объекта GraphicsEndFill эквивалентно вызову метода <codeph>Graphics.endFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsEndFill:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 Создает объект для использования с методом Graphics.drawGraphicsData(), чтобы явным образом завершить загрузку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 Создает объект для использования с методом <codeph>Graphics.drawGraphicsData()</codeph>, чтобы явным образом завершить загрузку.
 
 
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderPrecision"><apiName>ShaderPrecision</apiName><shortdesc>
	 Этот класс содержит константы, представляющие возможные значения для свойства precisionHint класса Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Этот класс содержит константы, представляющие возможные значения для свойства <codeph>precisionHint</codeph> класса Shader. Каждая константа представляет один из режимов точности для выполнения операций затенения.
	 
	 <p>Выбор режима точности затенения влияет на следующие операции затенения. При использовании процессора Intel с набором инструкций SSE данные операции выполняются быстрее:</p>
	 
	 <ul>
	   <li><codeph>sin(x)</codeph></li>
	   <li><codeph>cos(x)</codeph></li>
	   <li><codeph>tan(x)</codeph></li>
	   <li><codeph>asin(x)</codeph></li>
	   <li><codeph>acos(x)</codeph></li>
	   <li><codeph>atan(x)</codeph></li>
	   <li><codeph>atan(x, y)</codeph></li>
	   <li><codeph>exp(x)</codeph></li>
	   <li><codeph>exp2(x)</codeph></li>
	   <li><codeph>log(x)</codeph></li>
	   <li><codeph>log2(x)</codeph></li>
	   <li><codeph>pow(x, y)</codeph></li>
	   <li><codeph>reciprocal(x)</codeph></li>
	   <li><codeph>sqrt(x)</codeph></li>
	 </ul>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links><apiValue id="flash.display:ShaderPrecision:FAST"><apiName>FAST</apiName><shortdesc>
		 Представляет быстрый режим точности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fast</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Представляет быстрый режим точности.
		 
		 <p>Быстрый режим точности предусмотрен для максимального повышения производительности, но он дает несогласованные результаты для разных платформ и индивидуальных конфигураций ЦП. Во многих случаях этого уровня точности достаточно для создания графических эффектов без видимых искажений.</p>
		 
		 <p>Часто быстрый режим точности дает больше производительности, чем при использовании справочных таблиц.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderPrecision:FULL"><apiName>FULL</apiName><shortdesc>
		 Представляет режим максимальной точности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Представляет режим максимальной точности.
		 
		 <p>При выполнении операции затенения в режиме максимальной точности вычисления производятся по 32-разрядному стандарту IEEE с плавающей запятой. Работа в данном режиме поддерживается всеми платформами. Вычисление некоторых математических функций в этом режиме, например тригонометрических и экспонентных, может выполняться очень медленно.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:BlendMode"><apiName>BlendMode</apiName><shortdesc>
Класс, который передает значения констант для визуальных эффектов режима наложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс, который передает значения констант для визуальных эффектов режима наложения. Эти константы используются в следующих элементах:

<ul>

	<li> свойство <codeph>blendMode</codeph> класса flash.display.DisplayObject;</li>

	<li> Параметр <codeph>blendMode</codeph> метода <codeph>draw()</codeph> класса flash.display.BitmapData</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiValue id="flash.display:BlendMode:ADD"><apiName>ADD</apiName><shortdesc>
Прибавляет значения составляющих цветов экранного объекта к значениям цветов его фона (с максимальным значением 0xFF).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>add</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Прибавляет значения составляющих цветов экранного объекта к значениям цветов его фона (с максимальным значением 0xFF). Этот параметр часто используется для анимации растворения света между двумя объектами.

<p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xAAA633, а RGB пикселя фона имеет значение 0xDD2200, то значением RGB отображаемого пикселя является 0xFFC833 (так как 0xAA + 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8 и 0x33 + 0x00 = 0x33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ALPHA"><apiName>ALPHA</apiName><shortdesc>
Применяет альфа-значение каждого пикселя экранного объекта к фону.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alpha</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Применяет альфа-значение каждого пикселя экранного объекта к фону. Для этого требуется, чтобы свойству <codeph>blendMode</codeph> родительского экранного объекта было задано значение <codeph>flash.display.BlendMode.LAYER</codeph>. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DARKEN"><apiName>DARKEN</apiName><shortdesc>
Выбирает более темные из составляющих цветов экранного объекта и цветов фона (цвета с меньшими значениями).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>darken</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Выбирает более темные из составляющих цветов экранного объекта и цветов фона (цвета с меньшими значениями). Этот параметр часто используется как тип наложения. 

<p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xFFCC33, а RGB пикселя фона имеет значение 0xDDF800, то значением RGB отображаемого пикселя является 0xDDCC00 (так как 0xFF > 0xDD, 0xCC &lt; 0xF8 и 0x33 > 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DIFFERENCE"><apiName>DIFFERENCE</apiName><shortdesc>
Сравнивает составляющие цвета экранного объекта с цветами его фона и вычитает более темное значение (из двух составляющих цветов) из более светлого значения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>difference</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Сравнивает составляющие цвета экранного объекта с цветами его фона и вычитает более темное значение (из двух составляющих цветов) из более светлого значения. Этот параметр часто используется для получения более живых цветов. 

<p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xFFCC33, а RGB пикселя фона имеет значение 0xDDF800, то значением RGB отображаемого пикселя является 0x222C33 (так как 0xFF - 0xDD = 0x22, 0xF8 - 0xCC = 0x2C и 0x33 - 0x00 = 0x33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ERASE"><apiName>ERASE</apiName><shortdesc>
Стирает фон на основе альфа-значения экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>erase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Стирает фон на основе альфа-значения экранного объекта. Для этого процесса требуется, чтобы свойству <codeph>blendMode</codeph> родительского экранного объекта было задано значение <codeph>flash.display.BlendMode.LAYER</codeph>. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:HARDLIGHT"><apiName>HARDLIGHT</apiName><shortdesc>
Изменяет цвет каждого пикселя в зависимости от того, насколько темный цвет используется для экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>hardlight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Изменяет цвет каждого пикселя на основе того, насколько темный цвет используется для экранного объекта. Если экранный объект светлее 50-процентного серого, цвета экранного объекта и фона отфильтровываются, в результате чего получается более светлый цвет. Если экранный объект темнее 50-процентного серого, цвета умножаются, что дает более темный цвет. Этот параметр часто используется для эффектов затенения. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:INVERT"><apiName>INVERT</apiName><shortdesc>
Инвертирует фон.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invert</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Инвертирует фон.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LAYER"><apiName>LAYER</apiName><shortdesc>
Инициирует создание группы прозрачности для экранного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>layer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Инициирует создание группы прозрачности для экранного объекта. Это означает, что перед дальнейшей обработкой экранный объект сначала составляется во временном буфере. Предварительное составление выполняется автоматически, если экранный объект заранее сохраняется в кэше посредством кэширования растрового изображения или если экранный объект является контейнером экранных объектов, содержащим хотя бы один нижестоящий объект с параметром <codeph>blendMode</codeph> не в значении <codeph>normal</codeph>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LIGHTEN"><apiName>LIGHTEN</apiName><shortdesc>
Выбирает более светлые из составляющих цветов экранного объекта и цветов фона (цвета с большими значениями).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lighten</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Выбирает более светлые из составляющих цветов экранного объекта и цветов фона (цвета с большими значениями). Этот параметр часто используется как тип наложения. 

<p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xFFCC33, а RGB пикселя фона имеет значение 0xDDF800, то значением RGB отображаемого пикселя является 0xFFF833 (так как 0xFF > 0xDD, 0xCC &lt; 0xF8 и 0x33 > 0x00 = 33).</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:MULTIPLY"><apiName>MULTIPLY</apiName><shortdesc>
Умножает значения составляющих цветов экранного объекта на значения составляющих цветов фона и нормализует их путем деления на 0xFF, в результате чего получаются более темные цвета.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>multiply</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Умножает значения составляющих цветов экранного объекта на значения составляющих цветов фона и нормализует их путем деления на 0xFF, в результате чего получаются более темные цвета. Этот параметр часто используется для затенения и создания эффекта глубины.

<p>Например, если составляющий цвет (например, красный) одного пикселя в экранном объекте и соответствующий цвет пикселя в фоне имеют значение 0х88, то в результате умножения получается 0х4840. Деление на 0хFF дает значение 0х48 для данного составляющего цвета, принимающего более темный оттенок, чем в экранном объекте и фоне.</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
Экранный объект отображается перед фоном.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Экранный объект отображается перед фоном. Значения пикселей экранного объекта переопределяют значения пикселей фона. В прозрачных областях экранного объекта виден фон.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:OVERLAY"><apiName>OVERLAY</apiName><shortdesc>
Изменяет цвет каждого пикселя на основе того, насколько темный цвет используется для фона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>overlay</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Изменяет цвет каждого пикселя на основе того, насколько темный цвет используется для фона. Если фон светлее 50-процентного серого, цвета экранного объекта и фона отфильтровываются, в результате чего получается более светлый цвет. Если фон темнее 50-процентного серого, цвета умножаются, что дает более темный цвет. Этот параметр часто используется для эффектов затенения. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SCREEN"><apiName>SCREEN</apiName><shortdesc>
Умножает обратный код цвета экранного объекта на обратный код цвета фона, в результате чего получается эффект осветления.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>screen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Умножает обратный код цвета экранного объекта на обратный код цвета фона, в результате чего получается эффект осветления. Этот параметр часто используется для высветления или удаления черных областей экранного объекта. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SHADER"><apiName>SHADER</apiName><shortdesc>
Использует затенение для наложения между объектами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>shader</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Использует затенение для наложения между объектами.

<p>Применение свойства <codeph>blendShader</codeph> к экземпляру Shader автоматически приведет к смене значения свойства <codeph>blendMode</codeph> экранного объекта на <codeph>BlendMode.SHADER</codeph>. Если для свойства <codeph>blendMode</codeph> задано <codeph>BlendMode.SHADER</codeph> без предварительного задания свойства <codeph>blendShader</codeph>, то свойство <codeph>blendMode</codeph> примет значение <codeph>BlendMode.NORMAL</codeph>. Если же свойство <codeph>blendShader</codeph> настроено (свойство <codeph>blendMode</codeph> принимает значение <codeph>BlendMode.SHADER</codeph>), то в дальнейшем значение свойства <codeph>blendMode</codeph> изменяется. Режим наложения можно быстро перенастроить на использование затенения для наложения, задав свойству <codeph>blendMode</codeph> значение <codeph>BlendMode.SHADER</codeph>. Необходимость в повторной настройке свойства <codeph>blendShader</codeph> отсутствует, кроме тех случаев, когда требуется сменить затенение, используемое для определения режима наложения.</p>

</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue><apiValue id="flash.display:BlendMode:SUBTRACT"><apiName>SUBTRACT</apiName><shortdesc>
Вычитает значения составляющих цветов экранного объекта из значений цвета фона (с минимальным значением 0).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subtract</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Вычитает значения составляющих цветов экранного объекта из значений цвета фона (с минимальным значением 0). Этот параметр часто используется для анимации растворения затемнения между двумя объектами.

<p>Например, если в экранном объекте есть пиксель со значением RGB, равным 0xAA2233, а RGB пикселя фона имеет значение 0xDDA600, то значением RGB отображаемого пикселя является 0x338400 (так как 0xDD - 0xAA = 0x33, 0xA6 - 0x22 = 0x84 и 0x00 - 0x33 &lt; 0x00).</p>
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Graphics"><apiName>Graphics</apiName><shortdesc>
 Класс Graphics содержит набор методов, с помощью которых можно создавать векторные фигуры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Graphics содержит набор методов, с помощью которых можно создавать векторные фигуры. К числу объектов отображения, поддерживающих возможности рисования, относятся объекты Sprite и Shape. Каждый из этих классов включает свойство <codeph>graphics</codeph>, являющееся объектом Graphics. Далее перечислены вспомогательные функции, обеспечивающие простоту использования: <codeph>drawRect()</codeph>, <codeph>drawRoundRect()</codeph>, <codeph>drawCircle()</codeph> и <codeph>drawEllipse()</codeph>.
 
 <p>Нельзя создать объект Graphics непосредственно из кода ActionScript. Можно вызвать функцию <codeph>new Graphics()</codeph> для создания исключения.</p>
 
 <p>Класс Graphics является конечным, его нельзя разбить на подклассы.</p>
 
 
 </apiDesc><example conref="examples\GraphicsExample.as"> В следующем примере рассматривается использование класса GraphicsExample для рисования круга, прямоугольного примитива со скругленными углами и квадрата. Это можно сделать, выполнив следующие действия:
 <ol>
    <li>Объявите свойство <codeph>size</codeph> для последующего использования при определении размера каждой фигуры.</li>
     <li>Объявите свойства, определяющие оранжевый цвет фона, темно-серый цвет рамки, размер рамки в пикселях, равный 0, радиус угла, равный 9 пикселям; также задайте расстояние между краем рабочей области и другими объектами, равное 5 пикселям.</li>
    <li>Используйте свойства, объявленные в предыдущих шагах, вместе со встроенными методами класса Graphics, чтобы нарисовать круг, прямоугольный примитив со скругленными углами и квадрат с координатами x = 0, y = 0.</li>
    <li>Повторно нарисуйте все эти фигуры у верхнего края рабочей области, начиная с точки x = 5, y = 5 с расстоянием 5 пикселей между ними.</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Graphics:beginBitmapFill"><apiName>beginBitmapFill</apiName><shortdesc>
	 Заполняет область рисунка растровым изображением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Прозрачное или матовое растровое изображение, содержащее отображаемые биты.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект матрицы (из класса flash.geom.Matrix), который можно использовать для определения преобразований в растровом изображении. Например, можно использовать следующую матрицу для поворота растрового изображения на 45 градусов (пи/4 радиан):
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>При значении <codeph>true</codeph> растровое изображение повторяется по шаблону мозаики. При значении <codeph>false</codeph> растровое изображение не повторяется, а его края используются для заливки всей области, выходящей за его пределы. 
	 
	 <p>Например, рассмотрим следующее растровое изображение (рисунок «шахматная доска»20 х 20 пикселей):</p>
	 
     <p><adobeimage alt="«шахматная доска» 20 х 20 пикселей" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
	 
	 <p>Когда для <codeph>repeat</codeph> задано значение <codeph>true</codeph> (как в следующем примере), в заливке повторяется растровое изображение:</p>
	 
     <p><adobeimage alt="«шахматная доска» 60 х 60 пикселей" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
	 
	 <p>Когда для <codeph>repeat</codeph> задано значение <codeph>false</codeph>, в заливке растровым изображением используются краевые пиксели, чтобы залить область, выходящую за пределы изображения:</p>
	 
     <p><adobeimage alt="изображение 60 х 60 без повторения" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 
   	 
	 </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При выборе значения <codeph>false</codeph> визуализируются растровые изображения, увеличенные при помощи алгоритма ближайшего соседнего пикселя, которые могут выглядеть нечетко. При выборе значения <codeph>true</codeph>увеличенное растровое изображение визуализируется с помощью билинейного алгоритма. Процедура визуализации с помощью алгоритма ближайшего соседнего пикселя требует меньше времени.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Начинает отрисовку фигуры с заливкой растровым изображением.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Заполняет область рисунка растровым изображением. Растровое изображение может повторяться или располагаться в виде мозаики для заполнения области. Заливка остается действительной вплоть до вызова метода <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginShaderFill()</codeph>. При вызове метода <codeph>clear()</codeph> заливка удаляется.
	 
	 <p>В приложении заливка отображается при рисовании трех и более точек или вызове метода <codeph>endFill()</codeph>. </p>
	 
	 </apiDesc><example conref="examples\Graphics_beginBitmapFillExample.as"> В следующем примере рассматривается изображение (<codeph>image1.jpg</codeph>), которое поворачивается и повторяется для заполнения прямоугольника.
 
 <ol>
    <li>Файл изображения (<codeph>image1.jpg</codeph>) загружается с помощью объектов <codeph>Loader</codeph> и <codeph>URLRequest</codeph>. В данном примере файл находится в том же каталоге, что и SWF-файл. SWF-файл должен быть откомпилирован с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к локальным файлам».</li>
     <li>При загрузке изображения (завершении <codeph>Event</codeph>) вызывается метод <codeph>drawImage()</codeph>. Метод <codeph>ioErrorHandler()</codeph> записывает комментарий отслеживания, если изображение загружено неправильно.</li>  
  <li>При методе <codeph>drawImage()</codeph> создаются экземпляры объекта <codeph>BitmapData</codeph>, а в качестве ширины и высоты задаются размеры изображения (<codeph>image1.jpg</codeph>). Затем исходное изображение отрисовывается в объекте BitmapData. После этого рисуется прямоугольник в объекте Sprite <codeph>mySprite</codeph>, а для заливки используется объект BitmapData. С использованием метода <codeph>Matrix</codeph> метод <codeph>beginBitmapFill()</codeph> поворачивает изображение на 45 градусов, а затем начинает заполнять прямоугольник изображением, пока не будет покрыта вся область.</li> 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginFill"><apiName>beginFill</apiName><shortdesc>
 	 Задает простую заливку сплошным цветом для использования при последующих вызовах других методов объекта Graphics (например, lineTo() или drawCircle()) при рисовании.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Цвет заполнения (0xRRGGBB).
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Значение альфа-канала заливки (0,0 – 1,0). 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Задает заливку сплошным цветом.
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Задает простую заливку сплошным цветом для использования при последующих вызовах других методов объекта Graphics (например, <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>) при рисовании. Заливка остается действительной вплоть до вызова метода <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginShaderFill()</codeph>. При вызове метода <codeph>clear()</codeph> заливка удаляется.
	 
	 <p>В приложении заливка отображается при рисовании трех и более точек или вызове метода <codeph>endFill()</codeph>.</p>
	 
	 </apiDesc><example>См. <xref href="Graphics.html#includeExamplesSummary">пример использования этого метода</xref> в конце описания класса. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginGradientFill"><apiName>beginGradientFill</apiName><shortdesc>
	 Задает заливку градиентом для использования при последующих вызовах других методов Graphics (например, lineTo() или drawCircle()) объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметр <codeph>type</codeph> недействителен.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Значение из класса GradientType, определяющее, какой тип градиента должен использоваться: <codeph>GradientType.LINEAR</codeph> или <codeph>GradientType.RADIAL</codeph>. 
	 
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив шестнадцатеричных значений цвета RGB, который должен использоваться в градиенте; например, красный – 0xFF0000, синий – 0x0000FF и т.д. Можно указать до 15 цветов. Для каждого цвета необходимо указать соответствующее значение в параметрах альфа-канала и пропорций.
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив значений альфа-канала для соответствующих цветов в массиве цветов. Действительные значения – от 0 до 1. Если значение меньше 0, по умолчанию задается 0. Если значение больше 1, по умолчанию задается 1.
     
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив значений распределения цветов; действительными являются значения от 0 до 255. Это значение определяет процент ширины, на которой цвет представлен на 100% Значение 0 обозначает левую позицию окна градиента, а 255 – правую. 
	 
	 <p><b>Примечание.</b> Это значение показывает позиции в окне градиента, а не в координатной плоскости конечного градиента, которая может быть шире или уже окна градиента. Укажите величину каждого значения в параметре <codeph>colors</codeph>. </p>
	 
	 <p>Например, линейный градиент включает два цвета: синий и зеленый. Ниже иллюстрируется размещение цветов в градиенте, созданном с использованием разных значений массива <codeph>ratios</codeph>:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Градиент</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
	 	<entry><adobeimage alt="линейный градиент от синего к зеленому со значениями распределения 0 и 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего к зеленому с значениями распределения 0 и 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего цвета к зеленому с коэффициентами127 и 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Значения в массиве должны увеличиваться последовательно, например <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Матрица преобразования, определенная классом flash.geom.Matrix. Класс flash.geom.Matrix включает метод <codeph>createGradientBox()</codeph>, позволяющий удобно настроить матрицу для использования с методом <codeph>beginGradientFill()</codeph>.
	 
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>Значение из класса SpreadMethod, определяющее метод нанесения, который должен использоваться: <codeph>SpreadMethod.PAD</codeph>, <codeph>SpreadMethod.REFLECT</codeph> или <codeph>SpreadMethod.REPEAT</codeph>. 
	 
	 <p>Например, рассмотрим простой линейный градиент между двумя цветами.</p>
	 
	 <codeblock>
	 import flash.geom.*
	 import flash.display.*
	 var fillType:String = GradientType.LINEAR;
	 var colors:Array = [0xFF0000, 0x0000FF];
	 var alphas:Array = [1, 1];
	 var ratios:Array = [0x00, 0xFF];
	 var matr:Matrix = new Matrix();
	 matr.createGradientBox(20, 20, 0, 0, 0);
	 var spreadMethod:String = SpreadMethod.PAD;
	 this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);		
	 this.graphics.drawRect(0,0,100,100);
	 </codeblock>
	 
	 	<p>В этом примере используется метод нанесения <codeph>SpreadMethod.PAD</codeph>, и заливка градиентом выглядит следующим образом:</p>
	 
      <p><adobeimage alt="Линейный градиент с методом SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
 	 
	 	<p>При использовании метода нанесения <codeph>SpreadMethod.REFLECT</codeph> заливка градиентом выглядит следующим образом:</p>
 	 
      <p><adobeimage alt="линейный градиент с методом SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
 	 
	 	<p>При использовании метода нанесения <codeph>SpreadMethod.REPEAT</codeph> заливка градиентом выглядит следующим образом:</p>
 	 
      <p><adobeimage alt="линейный градиент с методом SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>Значение из класса InterpolationMethod, указывающее, какое значение должно использоваться: <codeph>InterpolationMethod.LINEAR_RGB</codeph> или <codeph>InterpolationMethod.RGB</codeph>
	 
	 <p>Например, рассмотрим простой линейный градиент между двумя цветами (параметру <codeph>spreadMethod</codeph> задано значение <codeph>SpreadMethod.REFLECT</codeph>). Разные методы интерполяции влияют на внешний вид следующим образом: </p>
	 
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="линейный градиент с методом InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="линейный градиент с методом InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Число, управляющее местоположением фокуса градиента. 0 означает, что фокус находится в центре. 1 означает, что фокус находится у одного края круга градиента. -1 означает, что фокус находится у другого края окружности градиента. Значение меньше -1 или больше 1 округляется до -1 или 1. Например, для <codeph>focalPointRatio</codeph> задано значение 0,75:
	 
     <p><adobeimage alt="Радиальный градиент при значении focalPointRatio, равном 0,75" href="../../images/radial_sketch.jpg"/> </p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Задает заливку градиентом.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Задает заливку градиентом для использования при последующих вызовах других методов Graphics (например, <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>) объекта. Заливка остается действительной вплоть до вызова метода <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginShaderFill()</codeph>. При вызове метода <codeph>clear()</codeph> заливка удаляется.
	 
	 <p>В приложении заливка отображается при рисовании трех и более точек или вызове метода <codeph>endFill()</codeph>. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginShaderFill"><apiName>beginShaderFill</apiName><shortdesc>
 	 Задает затенение для использования при последующих вызовах других методов объекта Graphics (например, lineTo() или drawCircle()).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если и тип выхода затенения не совместим с данной операцией (затенение должно задать выход <codeph>pixel3</codeph> или <codeph>pixel4</codeph>).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если затенение задает неподдерживаемое входное изображение.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если объект ByteArray или Vector. В качестве ввода используется экземпляр &lt;Number>, а свойства <codeph>width</codeph> и <codeph>height</codeph> для ShaderInput не указаны либо указанные значения не соответствуют количеству данных во входном объекте. Дополнительные сведения см. в описании <codeph>ShaderInput.input</codeph>.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>Затенение, которое должно использоваться для заливки. Для указания входного изображения данный экземпляр Shader не требуется. Однако если в затенении входное изображение указано, его необходимо настроить вручную. Чтобы указать ввод, настройте свойство <codeph>input</codeph> соответствующего свойства ShaderInput свойства <codeph>Shader.data</codeph>.
	 
	 <p>При передаче экземпляра объекта Shader в качестве аргумента происходит копирование затенения на внутреннем уровне. При выполнении операции рисования заливки используется эта копия, а не ссылка на исходное затенение. Изменения параметров затенения (изменение значения параметра, ввода или байт-кода) не влияют на используемую для заливки копию затенения.</p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект матрицы (из класса flash.geom.Matrix), который можно использовать для определения преобразований в затенении. Например, можно использовать следующую матрицу для поворота затенения на 45 градусов (пи/4 радиан):
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 <p>В основе полученных в затенении координат лежит матрица, указанная для параметра <codeph>matrix</codeph>. В матрице по умолчанию (<codeph>null</codeph>) этими координатами в затенении являются локальные координаты пикселей, которые могут быть использованы для пробы ввода.</p>
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Определяет заливку затенением.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 Задает затенение для использования при последующих вызовах других методов объекта Graphics (например, <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>). Заливка остается действительной вплоть до вызова метода <codeph>beginFill()</codeph>, <codeph>beginBitmapFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginShaderFill()</codeph>. При вызове метода <codeph>clear()</codeph> заливка удаляется.
	 
	 <p>В приложении заливка отображается при рисовании трех и более точек или вызове метода <codeph>endFill()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:clear"><apiName>clear</apiName><shortdesc>
     Удаляет графику, отрисованную в данном объекте «Graphics», и сбрасывает параметры заливки и стиля линии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет графику, отрисованную в данном объекте «Graphics», и сбрасывает параметры заливки и стиля линии.
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:copyFrom"><apiName>copyFrom</apiName><shortdesc>
	 Копирует все команды рисования исходного объекта Graphics в вызывающий объект Graphics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceGraphics</apiItemName><apiOperationClassifier>flash.display:Graphics</apiOperationClassifier><apiDesc>Объект Graphics, из которого будут браться команды рисования для копирования.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Копирует все команды рисования исходного объекта Graphics в вызывающий объект Graphics.
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:curveTo"><apiName>curveTo</apiName><shortdesc>
	 Рисует кривую с использованием текущего стиля линии от текущего положения до (anchorX, anchorY) и с применением контрольной точки, указанной в координатах (controlX, controlY).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение контрольной точки относительно точки регистрации вышестоящего экранного объекта.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение опорной точки относительно точки регистрации вышестоящего экранного объекта.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение следующей точки привязки относительно точки регистрации вышестоящего экранного объекта.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение следующей точки привязки относительно точки регистрации вышестоящего экранного объекта.  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Рисует кривую от текущего положения инструмента рисования до точки привязки (anchorX, anchorY) с применением опорной точки, заданной координатами (controlX, controlY).
     
	 
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Рисует кривую с использованием текущего стиля линии от текущего положения инструмента рисования до точки с координатами (anchorX, anchorY) с применением опорной точки, заданной координатами (<codeph>controlX</codeph>, <codeph>controlY</codeph>). Затем текущим положением становится точка (<codeph>anchorX</codeph>, <codeph>anchorY</codeph>). Если в фрагменте ролика, в котором выполняется отрисовка, есть содержимое, созданное с помощью инструментов рисования Flash, то вызовы метода <codeph>curveTo()</codeph> осуществляются под содержимым. Если вызвать метод <codeph>curveTo()</codeph> перед вызовом метода <codeph>moveTo()</codeph>, то текущим положением инструмента рисования по умолчанию становится точка с координатами (0,0). Если отсутствует один из параметров, этот метод использовать не удастся, и текущее положение инструмента рисования остается без изменений.
	 
	 <p>Нарисованная кривая является квадратичной кривой Безье. Квадратичные кривые Безье состоят из двух точек привязки и одной опорной точки. Кривая соединяет две точки привязки с искривлением в направлении опорной точки. </p>
	 
	 <p><adobeimage alt="Квадратичная кривая Безье и кубическая кривая Безье" href="../../images/quad_bezier.jpg"/></p>
	 
  	 </apiDesc><example conref="examples\Graphics_curveToExample1.as"> В следующем примере рисуется зеленый округлый объект с шириной и высотой, равными 100 пикселям, в 250 пикселях справа от точки регистрации (0, 0) экранного объекта Sprite. 
 <p>Нарисуйте четыре кривых, образующих круг, и заполните фигуру зеленым цветом.</p>
   
 <p>Обратите внимание на то, что вследствие характера квадратичного уравнения Безье этот круг не является идеальным. Лучше всего рисовать круг с использованием метода <codeph>drawCircle()</codeph> класса Graphics.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</codeblock></example><example conref="examples\Graphics_curveToExample2.as"> В следующем примере рассматривается рисование растущего месяца с использованием метода <codeph>curveTo()</codeph>.
 
 <p>Рисуются две кривые линии толщиной 1 пиксель, фигура заливается белым цветом. Метод <codeph>moveTo()</codeph> используется для указания текущего положения инструмента рисования в точке с координатами (100, 100). Первая кривая перемещает положение инструмента рисования до своей точки назначения с координатами (100, 200). Вторая кривая возвращает инструмент в исходное положение (100, 100), которое является ее точкой назначения. Горизонтальные опорные точки определяют разные размеры кривых.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:drawCircle"><apiName>drawCircle</apiName><shortdesc>
	 Рисует круг.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Положение <i>x</i> центра круга относительно точки регистрации вышестоящего объекта отображения (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Местоположение <i>y</i> центра круга относительно точки регистрации родительского экранного объекта (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>radius</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Радиус окружности (в пикселях).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Рисует круг.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Рисует круг. Прежде чем вызывать метод <codeph>drawCircle()</codeph>, необходимо задать стиль линии, заливку или и то, и другое. Для этого нужно вызвать метод <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example>См. <xref href="Graphics.html#includeExamplesSummary">пример использования этого метода</xref> в конце описания класса. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawEllipse()"><linktext>drawEllipse()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawEllipse"><apiName>drawEllipse</apiName><shortdesc>
	 Рисует эллипс.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Положение <i>x</i> верхней левой точки ограничительной рамки эллипса относительно точки регистрации вышестоящего объекта отображения (в пикселях).
	
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Положение <i>y</i> верхнего левого угла ограничительной рамки для эллипса относительно точки регистрации вышестоящего экранного объекта (в пикселях).
	
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ширина эллипса (в пикселях).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Высота эллипса (в пикселях).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Рисует эллипс.
         
         </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Рисует эллипс. Прежде чем вызывать метод <codeph>drawEllipse()</codeph>, необходимо задать стиль линии, заливку или и то, и другое. Для этого нужно вызвать метод <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example conref="examples\Graphics_drawEllipseExample.as"> В следующем примере используется функция <codeph>drawEgg()</codeph>, чтобы нарисовать три яйца разного размера (три размера эллипса) с применением параметра <codeph>eggSize</codeph>.  
 <ol>
 <li>Конструктор вызывает функцию <codeph>drawEgg()</codeph> и передает горизонтальные и вертикальные параметры для места отрисовки яйца и его типа (<codeph>eggSize</codeph>). (Высота и ширина яиц (эллипсов) может использоваться для определения места их отображения.)</li> 
 <li>Функция <codeph>drawEgg()</codeph> рисует эллипсы разного размера и заполняет их белым цветом с помощью метода <codeph>beginFill()</codeph>. Для этой функции не предусмотрена процедура предварительной обработки ошибок.</li>
 </ol>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawCircle()"><linktext>drawCircle()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawGraphicsData"><apiName>drawGraphicsData</apiName><shortdesc>
	 Отправляет последовательность экземпляров IGraphicsData для рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>graphicsData</apiItemName><apiType value="Vector$flash.display:IGraphicsData"/><apiDesc>Объект Vector, содержащий графические объекты, которые должны реализовывать интерфейс IGraphicsData.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отправляет последовательность экземпляров IGraphicsData для рисования. Данный метод поддерживает объект Vector, в который входят объекты, включая контуры, заливки и штрихи, реализующие интерфейс IGraphicsData. Вектор, состоящий из экземпляров IGraphicsData, может относиться к части фигуры или к сложному, полностью определенному набору данных для визуализации полной фигуры.
     
     
     <p>
     Графические контуры могут содержать другие графические контуры. Если вектор <codeph>graphicsData</codeph> содержит контур, то во время визуализации будет обработан не только данный контур, но и все вложенные контуры.
     </p>
     
     </apiDesc><example conref="examples\Graphics_DrawGraphicsDataExample.as"> С помощью следующего экземпляра создается объект GraphicsGradientFill для установки свойства fill для квадрата. Далее с помощью экземпляра создается класс объектов GraphicsStroke и объект GraphicsSolidFill (для цвета линий), чтобы установить свойства для линии границ квадрата. Далее с помощью экземпляра создается объект GraphicsPath для значений, требуемых для отображения фигуры. Все эти объекты сохраняются в объекте IGraphicsData и передаются в команду <codeph>drawGraphicsData()</codeph> для визуализации фигуры.
<codeblock>
package{
    import flash.display.*;
    import flash.geom.*;
    
    public class DrawGraphicsDataExample extends Sprite {

    public function DrawGraphicsDataExample(){    

    // establish the fill properties
    var myFill:GraphicsGradientFill = new GraphicsGradientFill();
    myFill.colors = [0xEEFFEE, 0x0000FF];
    myFill.matrix = new Matrix();
    myFill.matrix.createGradientBox(100, 100, 0);
 
    // establish the stroke properties
    var myStroke:GraphicsStroke = new GraphicsStroke(2);
    myStroke.fill = new GraphicsSolidFill(0x000000);
 
    // establish the path properties
    var myPath:GraphicsPath = new GraphicsPath(new Vector.&lt;int>(), new Vector.&lt;Number>());
    myPath.commands.push(1,2,2,2,2);
    myPath.data.push(10,10, 10,100, 100,100, 100,10, 10,10);
 
    // populate the IGraphicsData Vector array
    var myDrawing:Vector.&lt;IGraphicsData> = new Vector.&lt;IGraphicsData>();
    myDrawing.push(myFill, myStroke, myPath);
 
    // render the drawing 
    graphics.drawGraphicsData(myDrawing);
    }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#IGraphicsData"><linktext>flash.display.IGraphicsData</linktext></link><link href="flash.display.xml#GraphicsBitmapFill"><linktext>flash.display.GraphicsBitmapFill</linktext></link><link href="flash.display.xml#GraphicsEndFill"><linktext>flash.display.GraphicsEndFill</linktext></link><link href="flash.display.xml#GraphicsGradientFill"><linktext>flash.display.GraphicsGradientFill</linktext></link><link href="flash.display.xml#GraphicsPath"><linktext>flash.display.GraphicsPath</linktext></link><link href="flash.display.xml#GraphicsShaderFill"><linktext>flash.display.GraphicsShaderFill</linktext></link><link href="flash.display.xml#GraphicsSolidFill"><linktext>flash.display.GraphicsSolidFill</linktext></link><link href="flash.display.xml#GraphicsStroke"><linktext>flash.display.GraphicsStroke</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawPath"><apiName>drawPath</apiName><shortdesc>
	 Отправляет последовательность команд для рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiDesc>Вектор целых чисел, представляющий команды, определенные классом GraphicsPathCommand. Класс GraphicsPathCommand устанавливает соответствие между командами и их числовыми идентификаторами для данного векторного массива.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiDesc>Вектор чисел, где каждая пара чисел рассматривается как точка в системе координат (пара координат x, y). Пары значений координат x и y не являются объектами Point; вектор <codeph>data</codeph> представляет собой последовательность чисел, в которой каждая пара чисел представляет собой местоположение в системе координат. 
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Указывает правило изгиба с использованием значения, определенного в классе GraphicsPathWinding.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отправляет последовательность команд для рисования. Метод <codeph>drawPath()</codeph> использует векторные массивы для единого вызова отдельных команд рисования, таких как <codeph>moveTo()</codeph>, <codeph>lineTo()</codeph> и <codeph>curveTo()</codeph>. Параметры метода <codeph>drawPath()</codeph> объединяют команды рисования с парами значений координат x и y и направлением рисования. Команды рисования являются значениями из класса GraphicsPathCommand. Пары значений координат x и y являются числами в составе массива, в котором каждая пара задает местоположение в системе координат. Направление рисования является значением из класса GraphicsPathWinding.
     
	 <p>
	 Как правило, рисунки визуализируются быстрее при помощи метода <codeph>drawPath()</codeph>, чем в результате вызова серии отдельных методов <codeph>lineTo()</codeph> и <codeph>curveTo()</codeph>. 
	 </p>
     
	 <p>
     При вычислениях методом <codeph>drawPath()</codeph> используются числа с плавающей запятой, поэтому вращение и масштабирование фигур является более точным. Однако кривые, отправленные с помощью метода <codeph>drawPath()</codeph>, могут содержать незначительные ошибки выравнивания (до 1 пикселя) при использовании вместе с методами <codeph>lineTo()</codeph> и <codeph>curveTo()</codeph>.
     </p>
     
	 <p>
	 Метод <codeph>drawPath()</codeph> также использует немного другие правила для заполнения и рисования линий. Они перечислены ниже.
     </p>
     
	 <ul>
     <li>При применении заливки к визуализации контура:
	  <ul>
          <li>вложенный контур менее 3 точек не визуализируется. (однако визуализация штриха все равно выполняется в соответствии с приведенными ниже правилами для штрихов);</li>
	      <li>незамкнутый вложенный контур (конечная точка не совпадает с начальной) неявно замыкается.</li>
	   </ul>
     </li>
     <li>Когда штрих применяется к визуализации контура:
       <ul>
	     <li>вложенные контуры могут состоять из любого количества точек;</li>
	     <li>вложенные контуры никогда не замыкаются неявно.</li>
        </ul>
     </li>
     </ul>
     
     </apiDesc><example conref="examples\Graphics_DrawPathExample.as"> Следующий пример заполняет два векторных объекта, затем передает их методу <codeph>drawPath()</codeph> для визуализации голубой звезды. Первый векторный объект, <codeph>star_commands</codeph>, содержит последовательность целых чисел, представляющих команды рисования из класса flash.display.GraphicsPathCommand, где значение 1 является командой <codeph>MoveTo()</codeph>, а значение 2 – командой <codeph>LineTo()</codeph>. Второй объект Vector, <codeph>star_coord</codeph>, содержит 5 наборов пар координат x и y. Метод <codeph>drawPath()</codeph> сопоставляет команды с позициями для рисования звезды.
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {

    public function DrawPathExample(){

    var star_commands:Vector.&lt;int> = new Vector.&lt;int>(5, true);
    
    star_commands[0] = 1;
    star_commands[1] = 2;
    star_commands[2] = 2;
    star_commands[3] = 2;
    star_commands[4] = 2;

    var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>(10, true);
    star_coord[0] = 66; //x
    star_coord[1] = 10; //y 
    star_coord[2] = 23; 
    star_coord[3] = 127; 
    star_coord[4] = 122; 
    star_coord[5] = 50; 
    star_coord[6] = 10; 
    star_coord[7] = 49; 
    star_coord[8] = 109; 
    star_coord[9] = 127;


    graphics.beginFill(0x003366);
    graphics.drawPath(star_commands, star_coord);

    }

    }
}

</codeblock></example><example conref="examples\Graphics_DrawPathExample2.as"> В вышеупомянутом примере каждая команда и пара координат назначена индивидуально для отображения их позиции в массиве, однако они могут быть назначены в отдельном операторе. В следующем примере выполняется рисование той же самой звезды посредством назначения значений для каждого массива в отдельном операторе <codeph>push()</codeph>:
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {
    public function DrawPathExample(){
        var star_commands:Vector.&lt;int> = new Vector.&lt;int>();
        star_commands.push(1, 2, 2, 2, 2);

           var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>();
           star_coord.push(66,10, 23,127, 122,50, 10,49, 109,127);

        graphics.beginFill(0x003366);
        graphics.drawPath(star_commands, star_coord);
    }
    }
}


</codeblock> <b>Примечание.</b> По умолчанию метод <codeph>drawPath()</codeph> использует заливку по правилу четности-нечетности. Поэтому центр звезды не закрашен. Укажите заливку по правилу ненулевого направления для третьего параметра, и центр звезды будет закрашен:
 <codeblock>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </codeblock>
 
</example></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRect"><apiName>drawRect</apiName><shortdesc>
	 Рисует прямоугольник.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметры <codeph>width</codeph> или <codeph>height</codeph> не являются числом (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение относительно точки регистрации вышестоящего объекта отображения (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение относительно точки регистрации родительского объекта отображения (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ширина прямоугольника (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Высота прямоугольника (в пикселях).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Рисует прямоугольник со скругленными углами.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Рисует прямоугольник. Прежде чем вызывать метод <codeph>drawRect()</codeph>, необходимо задать стиль линии, заливку или и то, и другое. Для этого нужно вызвать метод <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example>См. <xref href="Graphics.html#includeExamplesSummary">пример использования этого метода</xref> в конце описания класса. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRoundRect()"><linktext>drawRoundRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRoundRect"><apiName>drawRoundRect</apiName><shortdesc>
	 Рисует прямоугольный примитив со скругленными углами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если параметры <codeph>width</codeph>, <codeph>height</codeph>, <codeph>ellipseWidth</codeph> или <codeph>ellipseHeight</codeph> не являются числом (<codeph>Number.NaN</codeph>).
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение относительно точки регистрации вышестоящего объекта отображения (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение относительно точки регистрации родительского объекта отображения (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ширина прямоугольника со скругленными углами (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Высота прямоугольника со скругленными углами (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ширина эллипса, используемая для отрисовки скругленных углов (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Высота эллипса, используемая для отрисовки скругленных углов (в пикселях). Необязательно. Если значение не задано, то по умолчанию используется то же, что и для параметра <codeph>ellipseWidth</codeph>.
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Рисует прямоугольник со скругленными углами.
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Рисует прямоугольный примитив со скругленными углами. Прежде чем вызывать метод <codeph>drawRoundRect()</codeph>, необходимо задать стиль линии, заливку или и то, и другое. Для этого нужно вызвать метод <codeph>linestyle()</codeph>, <codeph>lineGradientStyle()</codeph>, <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginBitmapFill()</codeph>.
	 
	 </apiDesc><example>См. <xref href="Graphics.html#includeExamplesSummary">пример использования этого метода</xref> в конце описания класса. 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRect()"><linktext>drawRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawTriangles"><apiName>drawTriangles</apiName><shortdesc>
	 Визуализирует набор треугольников, чтобы придать растровому изображению трехмерный вид.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiDesc>Вектор чисел, где каждая пара чисел рассматривается как точка в системе координат (пара координат x, y). Параметр <codeph>vertices</codeph> обязателен.
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Вектор целых чисел или индексов, где каждые три индекса определяют треугольник. Если параметру <codeph>indexes</codeph> задано значение null, то треугольник определяют каждые три вершины (шесть пар х,у в векторе <codeph>vertices</codeph>). В противном случае каждый индекс относится к вершине, представленной парой чисел в векторе <codeph>vertices</codeph>. Например, <codeph>indexes[1]</codeph> определяет точку с координатами (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>). Параметр <codeph>indexes</codeph> является дополнительным, но индексы, как правило, сокращают объем отправляемых и вычисляемых данных. 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Вектор нормализованных координат, используемый для наложения текстуры. Каждая координата определяет точку на растровом изображении, используемом для заливки. Для каждой вершины должна быть указана одна координата UV или одна координата UVT. В координатах UV точка (0,0) – это верхняя левая точка, а точка (1,1) – нижняя правая точка растрового изображения. 
     <p>Если длина этого вектора в два раза превышает длину вектора <codeph>vertices</codeph>, то нормализованные координаты используются без перспективной коррекции. </p>
     <p>Если длина этого вектора в три раза превышает длину вектора <codeph>vertices</codeph>, то третья координата интерпретируется как «t», (расстояние от глаз до текстуры в поле зрения). Это помогает средству визуализации правильно применить перспективу при наложении текстур в трехмерной графике.</p>
     <p>Если параметру <codeph>uvtData</codeph> задано значение null, будут применяться обычные правила для заливки любого типа.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>Указывает, производить ли визуализацию треугольников, которые смотрят в указанном направлении. Данный параметр используется для предотвращения визуализации треугольников, которые не видны с текущей точки обзора. Для данного параметра может быть задано любое значение, определенное классом TriangleCulling. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Визуализирует набор треугольников, чтобы придать растровому изображению трехмерный вид. Метод <codeph>drawTriangles()</codeph> накладывает текущую или растровую заливку на грани треугольника, используя набор координат (u,v). 
     <p>
     Можно использовать любую заливку. Однако все встроенные в заливках матрицы преобразования игнорируются.
     </p>
     
     <p>
     При использовании растровой заливки параметр <codeph>uvtData</codeph> улучшает наложение текстуры. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:endFill"><apiName>endFill</apiName><shortdesc>
	 Применяет заливку к линиям и кривым, добавленным с момента последнего вызова метода beginFill(), beginGradientFill() или beginBitmapFill().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a square with red fill on the Stage:
	 
	 <listing>
	 this.createEmptyMovieClip("square_mc", this.getNextHighestDepth());
	 square_mc.beginFill(0xFF0000);
	 square_mc.moveTo(10, 10);
	 square_mc.lineTo(100, 10);
	 square_mc.lineTo(100, 100);
	 square_mc.lineTo(10, 100);
	 square_mc.lineTo(10, 10);
	 square_mc.endFill();
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Применяет заливку к линиям и кривым.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Применяет заливку к линиям и кривым, добавленным с момента последнего вызова метода <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginBitmapFill()</codeph>. Flash использует заливку, указанную в предыдущем вызове метода <codeph>beginFill()</codeph>, <codeph>beginGradientFill()</codeph> или <codeph>beginBitmapFill()</codeph>. Если текущее положение инструмента рисования не совпадает с предыдущим положением, указанным в методе <codeph>moveTo()</codeph>, и определяется заливка, то путь замыкается линией, а затем заполняется цветом.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineBitmapStyle"><apiName>lineBitmapStyle</apiName><shortdesc>
	 Указывает растровое изображения штриха линии для использования при рисовании линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Растровое изображение, которое должно использоваться для штриха линии.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Дополнительная матрица преобразования, определенная классом flash.geom.Matrix. Матрица может быть использована для масштабирования или манипуляции растрового изображения до того, как применить его к стилю линии.
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Указывает, будет ли растровое изображение повторяться по шаблону мозаики.
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, будет ли к растровому изображению применяться смягчение.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Указывает растровое изображения штриха линии для использования при рисовании линий. 
     
     <p>Стиль линии растрового изображения используется при последующих вызовах таких методов Graphics, как <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>. Стиль линии остается действительным вплоть до вызова метода <codeph>lineStyle()</codeph>, <codeph>lineGradientStyle()</codeph> или <codeph>lineBitmapStyle()</codeph> с другими параметрами. </p>
     
     <p>Метод <codeph>lineBitmapStyle()</codeph> можно вызвать в процессе отрисовки контура, чтобы указать новые стили для других сегментов линии. </p>
     
     <p>Вызовите метод <codeph>lineStyle()</codeph> перед вызовом метода <codeph>lineBitmapStyle()</codeph>, чтобы активировать штрих, в противном случае значение стиля линии останется <codeph>undefined</codeph>.</p>
     
     <p>Вызовы функции <codeph>clear()</codeph> возвращают стиль линии к значению <codeph>undefined</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineGradientStyle"><apiName>lineGradientStyle</apiName><shortdesc>
	 Указывает градиент для использования при рисовании линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Значение из класса GradientType, определяющее, какой тип градиента должен использоваться: GradientType.LINEAR или GradientType.RADIAL.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив шестнадцатеричных значений цвета RGB, который должен использоваться в градиенте (например, красный – 0xFF0000, синий – 0x0000FFи т.д.).
	 
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив значений альфа-канала для соответствующих цветов в массиве цветов. Действительные значения – от 0 до 1. Если значение меньше 0, по умолчанию задается 0. Если значение больше 1, по умолчанию задается 1.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив значений распределения цветов; действительными являются значения от 0 до 255. Это значение определяет процент ширины, на которой цвет представлен на 100%. Значение 0 обозначает левую позицию окна градиента, а 255 – правую. Это значение показывает позиции в окне градиента, а не в координатной плоскости конечного градиента, которая может быть шире или уже окна градиента. Укажите величину каждого значения в параметре <codeph>colors</codeph>. 
	 
	 <p>Например, линейный градиент включает два цвета: синий и зеленый. Ниже иллюстрируется размещение цветов в градиенте, созданном с использованием разных значений массива <codeph>ratios</codeph>:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>Градиент</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего к зеленому со значениями распределения 0 и 127" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего к зеленому с значениями распределения 0 и 255" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="линейный градиент от синего к зеленому с значениями распределения 127 и 255" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Значения в массиве должны увеличиваться последовательно, например <codeph>[0, 63, 127, 190, 255]</codeph>. </p>
   	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Матрица преобразования, определенная классом flash.geom.Matrix. Класс flash.geom.Matrix включает метод <codeph>createGradientBox()</codeph>, позволяющий удобно настроить матрицу для использования с методом <codeph>lineGradientStyle()</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>Значение класса SpreadMethod, задающее метод нанесения: 
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="3"><tbody><row><entry align="center"><adobeimage alt="линейный градиент с методом SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>
      <entry align="center"><adobeimage alt="линейный градиент с методом SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>
      <entry align="center"><adobeimage alt="линейный градиент с методом SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>Значение класса InterpolationMethod, определяющее, какое значение должно использоваться. Например, рассмотрим простой линейный градиент между двумя цветами (параметру <codeph>spreadMethod</codeph> задано значение <codeph>SpreadMethod.REFLECT</codeph>). Разные методы интерполяции влияют на внешний вид следующим образом:
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="линейный градиент с методом InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="линейный градиент с методом InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Число, управляющее местоположением фокуса градиента. Значение 0 означает, что фокус находится в центре. Значение 1 означает, что фокус находится у одного края круга градиента. Значение -1 означает, что фокус находится у другого края окружности градиента. Значения меньше -1 или больше 1 округляются до -1 и 1 соответственно. Следующий пример иллюстрирует градиент с значением <codeph>focalPointRatio</codeph>, равным -0.75:
   	 
     <p><adobeimage alt="радиальный градиент при значении focalPointRatio, равном 0,75" href="../../images/radial_sketch.jpg"/> </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Указывает градиент для использования при рисовании линий.
     
     <p>Стиль линии градиента используется при последующих вызовах следующих методов Graphics: <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>. Стиль линии остается действительным вплоть до вызова метода <codeph>lineStyle()</codeph>, <codeph>lineBitmapStyle()</codeph> или <codeph>lineGradientStyle()</codeph> с другими параметрами. </p>
     
     <p>Метод <codeph>lineGradientStyle()</codeph> можно вызвать в процессе отрисовки контура, чтобы указать новые стили для других сегментов линии. </p>
     
     <p>Вызовите метод <codeph>lineStyle()</codeph> перед вызовом метода <codeph>lineGradientStyle()</codeph>, чтобы активировать штрих, в противном случае значение стиля линии останется <codeph>undefined</codeph>.</p>
     
     <p>Вызовы функции <codeph>clear()</codeph> возвращают стиль линии к значению <codeph>undefined</codeph>.
     </p>
	 
	 </apiDesc><example conref="examples\Graphics_lineGradientStyleExample.as"> В следующем примере рассматривается рисование прямоугольника и круга с использованием штриха градиента от красного к зеленому и синему.
 
 <p>Метод <codeph>createGradientBox()</codeph> класса <codeph>Matrix</codeph> используется для определения окна градиента с шириной 200 и высотой 40. Толщина линии составляет 5 пикселей. Для метода <codeph>lineGradientStyle()</codeph> необходимо определить толщину штриха. Задается линейный градиент. Для градиента выбираются красный, зеленый и синий цвета. Прозрачность (значение альфа-канала) цветов составляет 1 (матовые). Распределение градиента – равномерное, 100-процентная выборка цветов в позициях 0 (левый край окна градиента), 128 (середина окна) и 255 (правый край окна). Ширина прямоугольника охватывает весь спектр градиента, а круг –только 50% в центре спектра.</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineShaderStyle"><apiName>lineShaderStyle</apiName><shortdesc>
	 Указывает затенение штриха линии для использования при рисовании линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>Затенение, которое должно использоваться для штриха линии.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Дополнительная матрица преобразования, определенная классом flash.geom.Matrix. Матрица может быть использована для масштабирования или манипуляции растрового изображения до того, как применить его к стилю линии.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Указывает затенение штриха линии для использования при рисовании линий. 
     
     <p>Стиль затенения линии используется при последующих вызовах таких методов Graphics, как <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>. Стиль линии остается действительным вплоть до вызова метода <codeph>lineStyle()</codeph>, <codeph>lineGradientStyle()</codeph> или <codeph>lineBitmapStyle()</codeph> с другими параметрами. </p>
     
     <p>Метод <codeph>lineShaderStyle()</codeph> можно вызвать в процессе отрисовки контура, чтобы указать новые стили для других его сегментов линии. </p>
     
     <p>Вызовите метод <codeph>lineStyle()</codeph> перед вызовом метода <codeph>lineShaderStyle()</codeph>, чтобы активировать штрих, в противном случае значение стиля линии останется <codeph>undefined</codeph>.</p>
     
     <p>Вызовы функции <codeph>clear()</codeph> возвращают стиль линии к значению <codeph>undefined</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineStyle"><apiName>lineStyle</apiName><shortdesc>
     Указывает стиль линии, который будет использоваться при последующих вызовах таких методов Graphics, как lineTo() или drawCircle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following code draws a triangle with a 5-pixel, solid magenta line with 
	 no fill, with pixel hinting, no stroke scaling, no caps, and miter joints with 
	 <code>miterLimit</code> set to 1:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", this.getNextHighestDepth());
	 triangle_mc.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 </listing>
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Целое число, определяющее толщину линии в точках; допустимыми являются значения от 0 до 255. Если число не указано или параметр не определен, то линия не будет проведена. Если передается значение меньше 0, по умолчанию задается 0. Значение 0 обозначает толщину одного волоса, максимальная толщина составляет 255. Если передается значение больше 255, по умолчанию задается 255. 
     
     </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Шестнадцатеричное значение цвета линии; например красный – 0xFF0000, синий – 0x0000FF и т.д. Если значение на задано, по умолчанию используется 0x000000 (черный). Дополнительно.
	 
 	 
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Число, указывающее значение альфа-канала цвета линии, допустимые значения находятся в диапазоне 0-1. Если значение на задано, по умолчанию используется 1(сплошной). Если значение меньше 0, по умолчанию задается 0. Если значение больше 1, по умолчанию задается 1. 
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Логическое значение, определяющее, следует ли выполнять хинтинг штрихов до полных пикселей. Оно влияет на позицию привязок кривой и на размер штриха линии как таковой. Если для <codeph>pixelHinting</codeph> задано значение <codeph>true</codeph>, выполняется хинтинг ширины линии до полного пикселя. Если для <codeph>pixelHinting</codeph> задано значение <codeph>false</codeph>, в кривых и прямых линиях могут возникать разрывы. Например, на следующих рисунках показано, как проигрыватель Flash Player или Adobe AIR визуализирует два одинаковых округленных прямоугольника, которые отличаются только настройкой параметра <codeph>pixelHinting</codeph> в методе <codeph>lineStyle()</codeph> (с целью наглядности изображения увеличены на 200%):
	 
	 <p><adobeimage alt="pixelHinting false и pixelHinting true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
	 
	 <p>Если значение не задано, для линии не используется хинтинг пикселей.</p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>Значение класса LineScaleMode, задающее режим масштабирования:
	 
	 <ul>
	 
	 <li>
	 <codeph>LineScaleMode.NORMAL</codeph> – Всегда масштабировать толщину линии при масштабировании объекта (по умолчанию).
	 </li>
	 
	 <li>
	 <codeph>LineScaleMode.NONE</codeph> – Никогда не масштабировать толщину линии.
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.VERTICAL</codeph> – Не масштабировать толщину линии, если объект масштабируется <i>только</i> по вертикали. Например, рассмотрим следующие окружности, нарисованные линией толщиной в 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.VERTICAL</codeph>. Масштаб окружности слева изменен только по вертикали, а окружности справа – и по вертикали и по горизонтали.
	 
     <p><adobeimage alt="Окружность, масштабированная по вертикали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	 
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.HORIZONTAL</codeph> – Не масштабировать толщину линии, если объект масштабируется <i>только</i> по горизонтали. Например, рассмотрим следующие окружности, нарисованные линией толщиной 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.HORIZONTAL</codeph>. Масштаб окружности слева изменен только по горизонтали, а окружности справа – и по вертикали и по горизонтали.
	 
     <p><adobeimage alt="Окружность, масштабированная по горизонтали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	 
	 </li>
	 
	 
	 </ul>
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Значение класса CapsStyle, задающее тип концов линии. Допустимые значения: <codeph>CapsStyle.NONE</codeph>, <codeph>CapsStyle.ROUND</codeph> и <codeph>CapsStyle.SQUARE</codeph>. Если значение не указано, Flash Player использует круглые концы. 
	 <p>Следующий пример иллюстрирует разные параметры класса <codeph>capsStyle</codeph>. На рисунке представлено три синих линии толщиной 30 (к которым применяется <codeph>capsStyle</codeph>), а поверх них нанесена черная линия толщиной 1 (к которой <codeph>capsStyle</codeph> не применяется):
	 </p>
	 <p><adobeimage alt="NONE (нет), ROUND (круглый) и SQUARE (квадратный)" href="../../images/linecap.jpg"/></p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Значение класса JointStyle, задающее тип стыка на углах. Допустимые значения: <codeph>JointStyle.BEVEL</codeph>, <codeph>JointStyle.MITER</codeph> и <codeph>JointStyle.ROUND</codeph>. Если значение не указано, Flash Player использует круглые стыки. 
	 
	 <p>Следующий пример иллюстрирует разные параметры <codeph>joints</codeph>. На рисунке представлено три синих линии толщиной 30 (к которым применяется <codeph>jointStyle</codeph>), а поверх них нанесена черная линия толщиной 1 (к которой <codeph>jointStyle</codeph> не применяется):
	 </p>
	 
     <p><adobeimage alt="MITER (уголок), ROUND (круглый) и BEVEL (скос)" href="../../images/linejoin.jpg"/></p>
	 
	 <p><b>Примечание.</b> Для <codeph>стыков</codeph> типа <codeph>JointStyle.MITER</codeph> можно использовать параметр <codeph>miterLimit</codeph>, чтобы ограничить длину уголка.</p>
 	 
	 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3</apiData><apiDesc>Число, указывающее предел усечения уголка. Допустимыми являются значения в диапазоне 1-255 (остальные значения округляются до 1 или 255). Это значение используется, только если для <codeph>jointStyle</codeph> выбран тип <codeph>"miter"</codeph>. Значение <codeph>miterLimit</codeph> – это длина, до которой может продлеваться уголок после точки стыка. Значение выражает фактор <codeph>толщины</codeph> линии. Например, при факторе <codeph>miterLimit</codeph>, равном 2,5, и <codeph>толщине</codeph> в 10 пикселей, длина уголка достигает 25 пикселей. 
	 
	 <p>Рассмотрим следующие углы, все составленные из линий с <codeph>thickness</codeph> 20, но с разными значениями <codeph>miterLimit</codeph>: 1, 2 и 4. Поверх углов для наглядности нанесены черные линии, показывающие точки стыка:</p>
	 
     <p><adobeimage alt="углы с miterLimit, равным 1, 2 и 4" href="../../images/miterLimit.jpg"/></p>
	 
	 <p>Обратите внимание, что данное значение <codeph>miterLimit</codeph> имеет специфический максимальный угол для усечения «уголка». В следующей таблице приводится несколько примеров.</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>Значение <codeph>miterLimit</codeph>:</entry><entry>Углы, меньше этого, усекаются:</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 градусов</entry></row><row><entry>2</entry>      <entry>60 градусов</entry></row><row><entry>4</entry>      <entry>30 градусов</entry></row><row><entry>8</entry>      <entry>15 градусов</entry></row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Задает стиль линии, который Flash использует для отрисовки линий.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Указывает стиль линии, который будет использоваться при последующих вызовах таких методов Graphics, как <codeph>lineTo()</codeph> или <codeph>drawCircle()</codeph>. Стиль линии остается действительным вплоть до вызова метода <codeph>lineGradientStyle()</codeph>, <codeph>lineBitmapStyle()</codeph> или <codeph>lineStyle()</codeph> с другими параметрами. 
     
     <p>Метод <codeph>lineStyle()</codeph> можно вызвать в процессе отрисовки пути, чтобы указать новые стили для других сегментов линии.</p> 
	 
	 <p><b>Примечание.</b> Вызовы функции <codeph>clear()</codeph> возвращает стиль линии к <codeph>неопределенному</codeph>.</p>
     
	 </apiDesc><example>См. примеры метода <xref href="Graphics.html#lineTo()">lineTo()</xref> или <xref href="Graphics.html#moveTo()">moveTo()</xref>, иллюстрирующие использование <codeph>getStyle()</codeph>. 
     
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineBitmapStyle"><linktext>lineBitmapStyle</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle"><linktext>lineGradientStyle</linktext></link><link href="flash.display.xml#LineScaleMode"><linktext>LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>JointStyle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineTo"><apiName>lineTo</apiName><shortdesc>
	 Рисует линию с использованием текущего стиля линии от текущего положения инструмента рисования до точки с координатами (x, y); затем текущим положением становится точка (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill.
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение относительно точки регистрации вышестоящего экранного объекта (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение относительно точки регистрации вышестоящего экранного объекта (в пикселях).
     
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Рисует линию от текущего положения инструмента рисования до точки с координатами (x, y).
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Рисует линию с использованием текущего стиля линии от текущего положения инструмента рисования до точки с координатами (<codeph>x</codeph>, <codeph>y</codeph>); затем текущим положением становится точка (<codeph>x</codeph>, <codeph>y</codeph>). Если в экранном объекте, в котором выполняется отрисовка, есть содержимое, созданное с помощью инструментов рисования Flash, то вызовы метода <codeph>lineTo()</codeph> осуществляются под содержимым. Если вызвать <codeph>lineTo()</codeph> перед вызовом метода <codeph>moveTo()</codeph>, то текущим положением инструмента рисования по умолчанию становится точка с координатами (<i>0, 0</i>). Если отсутствует один из параметров, этот метод использовать не удастся, и текущее положение инструмента рисования остается без изменений.
	 
	 </apiDesc><example conref="examples\Graphics_lineToExample.as"> В следующем примере рисуется трапеция с использованием метода <codeph>lineTo()</codeph>, начиная с точки с координатами (100, 100). 
 <p>Толщина линии равна 10 пикселям, цвет – золотой, непрозрачный, концы линий не определены (так как все они заканчиваются на стыках), для стыков линий выбран тип <codeph>MITER</codeph> («уголок») с пределом 10, чтобы получились острые концы.</p>     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:moveTo"><apiName>moveTo</apiName><shortdesc>
     Перемещает текущее положение инструмента рисования в точку с координатами (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
	 
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение относительно точки регистрации вышестоящего экранного объекта (в пикселях).
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение относительно точки регистрации вышестоящего экранного объекта (в пикселях).
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Перемещает текущее положение инструмента рисования в точку с координатами (x, y).
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Перемещает текущее положение инструмента рисования в точку с координатами (<codeph>x</codeph>, <codeph>y</codeph>). Если отсутствует один из параметров, этот метод использовать не удается, и текущее положение инструмента рисования остается без изменений.
     
	 </apiDesc><example conref="examples\Graphics_moveToExample.as"> В следующем примере рисуется пунктирная линия толщиной 3 пикселя с использованием методов <codeph>moveTo()</codeph> и <codeph>lineTo()</codeph>.
 
 <p>С помощью метода <codeph>lineStyle()</codeph> задается толщина линии, равная 3 пикселям. Также настраивается запрет масштабирования. Задается красный цвет с 25-процентной прозрачностью. Для свойства <codeph>CapsStyle</codeph> выбраны квадратные концы (по умолчанию используются круглые).</p>
 
 <p>Поскольку <codeph>Graphics_moveToExample</codeph> является экземпляром класса <codeph>Sprite</codeph>, он имеет доступ ко всем методам класса Graphics. Методы класса Graphics можно использовать для отрисовки непосредственно в объекте Sprite <codeph>Graphic_moveToExample</codeph>. Однако если не поместить векторный графический объект в <codeph>Shape</codeph> ограничиваются возможности управления им, его перемещения и изменения.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.display:NativeWindowType"><apiName>NativeWindowType</apiName><shortdesc>
	 Класс NativeWindowType определяет константы для свойства type объекта NativeWindowInitOptions, используемого для создания собственного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс NativeWindowType определяет константы для свойства <codeph>type</codeph> объекта NativeWindowInitOptions, используемого для создания собственного окна.
	 
	 <p><b>Примечание.</b> Значение type задается при создании окна и не может изменяться впоследствии.</p>
	 	  
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowType:LIGHTWEIGHT"><apiName>LIGHTWEIGHT</apiName><shortdesc>
		 Минимальное окно</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lightweight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Минимальное окно
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
		 Обычное окно.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Обычное окно.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:UTILITY"><apiName>UTILITY</apiName><shortdesc>
		 Окно служебной программы.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>utility</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Окно служебной программы.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowDisplayState"><apiName>NativeWindowDisplayState</apiName><shortdesc>
     Класс NativeWindowDisplayState определяет константы для имен состояний отображения окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     Класс NativeWindowDisplayState определяет константы для имен состояний отображения окна.
     
     <p><b>Примечание.</b> Полноэкранные режимы настраиваются с использованием свойства <codeph>displayState</codeph> объекта Stage, а не свойства <codeph>displaySate</codeph> окна.</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link></related-links><apiValue id="flash.display:NativeWindowDisplayState:MAXIMIZED"><apiName>MAXIMIZED</apiName><shortdesc>
         Развернутое состояние отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>maximized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Развернутое состояние отображения.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:MINIMIZED"><apiName>MINIMIZED</apiName><shortdesc>
         Свернутое состояние отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>minimized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Свернутое состояние отображения.
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
         Обычное состояние отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         Обычное состояние отображения.
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Screen"><apiName>Screen</apiName><shortdesc>
	 Класс Screen передает информацию об экранах дисплея, доступных для данного приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс Screen передает информацию об экранах дисплея, доступных для данного приложения.
	 
	 <p>Экраны – это независимые области рабочего стола внутри одного, возможно, большего по размеру «виртуального рабочего стола». Исходная точка виртуального рабочего стола находится в верхнем левом углу главного экрана операционной системы. Таким образом, координаты границ отдельного экрана дисплея могут быть отрицательными. Также могут быть области виртуального рабочего стола, не входящие ни в один экран отображения.</p>
	 
	 <p>Класс Screen, содержит статические элементы класса для обращения к доступным экранным объектам и элементы экземпляров для обращения к свойствам отдельных экранов. Информацию об экранах не следует сохранять в кэше, так как пользователь может в любой момент ее изменить.</p>
	  
	 <p>Обратите внимание, что между экранами и физическими мониторами, подключенными к компьютеру, не обязательно должно быть соотношение один к одному. Например, два монитора могут показывать один и тот же экран.</p>
	 
	 <p>Нельзя создать экземпляры класса Screen напрямую. Вызовы конструктора <codeph>new Screen()</codeph> выдают исключение <codeph>ArgumentError</codeph>.</p>
	 
	 </apiDesc><example conref="examples\ScreenExample.as"> Следующий пример определяет класс DockingWindow для создания окна, закрепляемого по краям экрана. Это можно сделать, выполнив следующие действия.
 
 <ol>
     <li>Ответить на события клавиатуры, чтобы определить край экрана, к которому прикрепить окно.</li>
 
    <li>Обратиться к методу <codeph>getScreensForRectangle()</codeph> статического класса Screen, чтобы получить объект Screen для экрана, на котором в данный момент отображается окно.</li>
 
    <li>Изменить настройки границ окна в соответствии с размерами экрана.</li>
 
    <li>Обновить содержимое окна в соответствии с его новыми размерами.</li>
 
 </ol>
 
 <p>Обратите внимание на то, что этот класс следует использовать как корневой класс приложения AIR с настройками <codeph>SystemChrome="none"</codeph> и <codeph>transparent="true"</codeph>. Для использования этого класса в окне с системным хромом необходимо учитывать толщину хрома и минимальную ширину окна при вычислении расположения и размера окна.</p>
<codeblock>

package
{
    import flash.display.Screen;
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.KeyboardEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;

    public class DockingWindow extends Sprite
    {
        private const dockedWidth:uint = 80;
        private const dockedHeight:uint = 80;
        
        public function DockingWindow():void{
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onKey);
            dockLeft();
        }
        
        private function onKey(event:KeyboardEvent):void{
            switch(event.keyCode){
                case Keyboard.LEFT :
                    dockLeft();
                    break;
                case Keyboard.RIGHT :
                    dockRight();
                    break;
                case Keyboard.UP :
                    dockTop();
                    break;
                case Keyboard.DOWN :
                    dockBottom();
                    break;
                case Keyboard.SPACE :
                    stage.nativeWindow.close();
            }    
        }
        
        public function dockLeft():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.height = screen.visibleBounds.height;
            stage.stageWidth = dockedWidth;
            drawContent();
        }
        
        public function dockRight():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.width - dockedWidth;            
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.stageWidth = dockedWidth;
            stage.nativeWindow.height = screen.visibleBounds.height;
            drawContent();
        }
        
        public function dockTop():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;
            drawContent();
        }
        
        public function dockBottom():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.height - dockedHeight;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;    
            drawContent();        
        }
        
        private function getCurrentScreen():Screen{
            return Screen.getScreensForRectangle(stage.nativeWindow.bounds)[0];
        }
        
        private function drawContent():void{
            const size:int = 60;
            const pad:int = 10;
            var numHSquares:int = Math.floor(stage.stageWidth/(size + pad));
            var numVSquares:int = Math.floor(stage.stageHeight/(size + pad));
            with (graphics){
                clear();
                lineStyle(1);
                beginFill(0x3462d5,.7);
                for(var i:int = 0; i &lt; numHSquares; i++){
                    for(var j:int = 0; j &lt; numVSquares; j++){                
                            drawRect((i * (size + pad)) + pad, (j * (size + pad)) + pad, size, size);
                    }
                }
                endFill();
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Screen:getScreensForRectangle"><apiName>getScreensForRectangle</apiName><shortdesc>
		 Возвращает набор экранов (возможно, пустой), пересекающих данный прямоугольник.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Массив объектов Screen с экранами, содержащими любую часть области, определенной параметром <codeph>rect</codeph>.
		 
		 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник с координатами относительно исходной точки виртуального рабочего стола, которая находится в верхнем левом углу главного экрана.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Возвращает набор экранов (возможно, пустой), пересекающих данный прямоугольник.
		  
		 </apiDesc><example conref="examples\Screen.getScreensForRectangle.1.as"> Следующий пример показывает, как получить массив экранов, содержащих хотя бы часть данного прямоугольника.
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var rect:Rectangle = new Rectangle(-200, 100, 1000, 600);
var intersectedScreens:Array = Screen.getScreensForRectangle(rect);
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:Screen:bounds:get"><apiName>bounds</apiName><shortdesc>
		 Границы данного экрана.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 Границы данного экрана.
		 
		 <p>Местоположение экрана определяется относительно виртуального рабочего стола</p>
		 
		 </apiDesc><example conref="examples\Screen.bounds.1.as"> В следующем примере показано, как получить границы экрана (в данном случае экрана главного дисплея):
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.bounds;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:colorDepth:get"><apiName>colorDepth</apiName><shortdesc>
		 Глубина цвета (выраженная количеством битов).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Глубина цвета (выраженная количеством битов).
		 
		 </apiDesc><example conref="examples\Screen.colorDepth.1.as"> Следующий пример показывает, как получить глубину цвета экрана (в данном случае экрана главного дисплея):
<codeblock>

var mainScreen:Screen = Screen.mainScreen;
var colors:uint = mainScreen.colorDepth;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:mainScreen:get"><apiName>mainScreen</apiName><shortdesc>
		 Главный дисплей.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Screen</apiValueClassifier></apiValueDef><apiDesc>
		 Главный дисплей.
		 
		 </apiDesc><example conref="examples\Screen.mainScreen.1.as"> Следующий пример показывает, как получить объект Screen, представляющий основной экран компьютера:
<codeblock>

var primaryScreen:Screen = Screen.mainScreen;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:screens:get"><apiName>screens</apiName><shortdesc>
		 Массив доступных на данный момент экранов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3."/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 Массив доступных на данный момент экранов. 
		 
		 <p>Модификация возвращенного массива не будет оказывать влияния на доступные экраны.</p>
		 
		 </apiDesc><example conref="examples\Screen.screens.1.as"> Следующий пример показывает, как получить массив, содержащий доступные экраны:
<codeblock>

var screenArray:Array = Screen.screens;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:visibleBounds:get"><apiName>visibleBounds</apiName><shortdesc>
		 Границы области на данном экране, в которой будут отображаться окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 Границы области экрана, в которой окна будут видимыми.
		 
		 <p>В границы <codeph>visibleBounds</codeph> не входит панель задач (и другие панели рабочего стола) Windows, строка меню и, в зависимости от системных настроек, док в Mac OS X. В некоторых конфигурациях Linux видимые границы определить невозможно. В таких случаях свойство <codeph>visibleBounds</codeph> возвращает то же самое значение, что и свойство <codeph>screenBounds</codeph>.</p>
		 
		 </apiDesc><example conref="examples\Screen.usableBounds.1.as"> В следующем примере показано, как получить используемые границы экрана (в данном случае экрана главного дисплея):
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.visibleBounds;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Bitmap"><apiName>Bitmap</apiName><shortdesc>
 Класс Bitmap представляет экранные объекты, представляющие растровые изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Представляет экранные объекты, производные от изображений.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Bitmap представляет экранные объекты, представляющие растровые изображения. Это могут быть изображения, загружаемые с помощью класса flash.display.Loader или созданные с помощью конструктора <codeph>Bitmap()</codeph>. 
 
 <p>Конструктор <codeph>Bitmap()</codeph> позволяет создать объект Bitmap, содержащий ссылку на объект BitmapData. Создав объект Bitmap, используйте метод <codeph>addChild()</codeph> или <codeph>addChildAt()</codeph> родительского экземпляра DisplayObjectContainer, чтобы добавить растровое изображение в список отображения.</p>
 
 <p>Объект Bitmap может использовать свою ссылку BitmapData совместно с несколькими объектами Bitmap, независимо от свойств сдвига или поворота. Поскольку можно создать несколько объектов Bitmap, ссылающихся на один объект BitmapData, несколько экранных объектов могут использовать один сложный объект BitmapData, что предотвращает чрезмерную загрузку памяти в случае использования индивидуальных объектов BitmapData для каждого экземпляра экранного объекта.</p>
 
 <p>Объект BitmapData можно вызвать на экран объектом Bitmap одним из двух способов: с помощью векторного средства визуализации, такого как фигура, заполненная растровым изображением, или с использованием более быстрой подпрограммы копирования пикселей. Подпрограмма копирования пикселей работает намного быстрее, чем векторное средство визуализации, но объект Bitmap должен соответствовать определенным условиям для его использования.</p>
 
 <ul>
 
 <li> К объекту Bitmap не должно применяться растягивание, поворот и наклон.</li>
 <li> К объекту Bitmap не должно применяться преобразование цвета. </li>
 <li> К объекту Bitmap не должен применяться режим наложения. </li>
 <li> Нельзя выполнять обрезку через уровни маски или методы <codeph>setMask()</codeph>. </li>
 <li> Само изображение не должно быть маской. </li>
 <li> Координаты назначения должны находиться на целой пиксельной границе. </li>
 
 </ul>
 
 <p>Если объект Bitmap загружается не с того домена, на котором находится объект Loader, используемый для загрузки изображения, и не предусмотрено файла политики URL-адресов, предоставляющего доступ к домену объекта Loader, тогда сценарий в этом домене не может получить доступ к объекту Bitmap, его свойствам и методам. Дополнительные сведения см. в следующих источниках.</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 </ul>
 
 
 <p><b>Примечание.</b> Класс Bitmap не является подклассом класса InteractiveObject, поэтому он не может отправлять события мыши. Однако можно использовать метод <codeph>addEventListener()</codeph> контейнера экранного объекта, содержащего объект Bitmap.</p>
 
 </apiDesc><example conref="examples\BitmapExample.as"> В следующем примере класс BitmapExample используется для загрузки изображения "Image.gif" в объект DisplayObject в месте по умолчанию (<i>x = 0, y = 0</i>). Затем копия Image.gif помещается справа от оригинала, в котором применяются новые цвета к пикселям, подвергающимся тестированию с помощью метода <codeph>threshold()</codeph>. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>Создается свойство <codeph>url</codeph>, описывающее местоположение и имя файла изображения.</li>
  <li>Конструктор класса вызывает метод <codeph>configureAssets()</codeph>, который в свою очередь вызывает метод <codeph>completeHandler()</codeph>.</li>
  <li><codeph>configureAssets()</codeph> создает объект Loader, который затем создает экземпляр прослушивателя событий, отправляемых по завершении обработки изображения методом <codeph>completeHandler()</codeph>.</li>
  <li>Затем метод <codeph>buildChild()</codeph> создает новый экземпляр объекта URLRequest, <codeph>request</codeph>, и передает <codeph>url</codeph>, чтобы сообщить имя и местоположение файла.</li>
  <li>Объект <codeph>request</codeph> передается методу <codeph>loader.load()</codeph>, который загружает изображение в память через экранный объект.</li>
  <li>После этого изображение добавляется в список отображения, который почти сразу показывает изображение на экране в положении с координатами <i>x = 0, y = 0</i>.</li>
  <li>Затем метод <codeph>completeHandler()</codeph> выполняет следующие задачи:
  <ol outputclass="A">
      <li>Создает второй объект Loader и инициализированный вместе с ним объект Bitmap.</li>
      <li>Создает второй объект Bitmap, <codeph>duplicate</codeph>, который в свою очередь вызывает метод <codeph>duplicateImage()</codeph>, создающий дубликат исходного изображения. </li>
      <li>Создает объект BitmapData, который назначается объекту BitmapData объекта <codeph>duplicate</codeph>.</li>
      <li>Создает новый объект Rectangle, инициализированный с теми же координатами, шириной и высотой, что и исходное изображение.</li>
      <li>Создает новый объект Point с координатами по умолчанию: <i>x = 0, y = 0</i>.</li>
      <li>Создает следующие переменные:
      <ul>
          <li><codeph>operation</codeph>: применяет новый цвет, когда пороговое значение больше исходного или равно ему.</li>
          <li><codeph>threshold</codeph>: значение, с которым сравнивается каждый пиксель, – светло-серый цвет с альфа-значением 0xCC. </li>
          <li><codeph>color</codeph>: цвет, который будет задан пикселям, проходящим пороговый тест, – в данном случае это сплошной желтый цвет.</li>
          <li><codeph>mask</codeph>: задается диаметрально противоположный цвет (прозрачный синий).</li>
          <li><codeph>copySource</codeph>: получает значение false, указывающее на то, что значения пикселей не копируются в том случае, если пороговое значение не проходит. Это значение не имеет смысла, потому что изображение продублировано и изменяются только пиксели, прошедшие пороговый тест.</li>
      </ul></li>
      <li>Вызывает метод <codeph>threshold()</codeph> с использованием предшествующих переменных. В результате мы получаем уравнение порога: <codeph>если (текущее значение пикселя &amp; 0x000000FF) больше или равно (0xCCCCCCCC &amp; 0x000000FF), то ему задается 0xFFFFFF00</codeph>. </li>
  </ol></li>
 </ol>
 <p> <b>Примечания.</b>
 <ul>
  <li>SWF-файл потребуется откомпилировать с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к локальным файлам».
 </li>
  <li>Данный пример требует, чтобы файл с именем Image.gif находился в том же каталоге, что и SWF-файл.
 </li>
  <li>Рекомендуем использовать изображение с шириной до 80 пикселей. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiConstructor id="flash.display:Bitmap:Bitmap"><apiName>Bitmap</apiName><shortdesc>
     Инициализирует объект Bitmap для ссылки на заданный объект BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект BitmapData, указанный в ссылке. 
     
     </apiDesc></apiParam><apiParam><apiItemName>pixelSnapping</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>auto</apiData><apiDesc>Определяет, должен ли объект Bitmap быть привязанным к ближайшему пикселю.
     
     </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, следует ли сглаживать растровое изображение при масштабировании. В следующих примерах показано то же растровое изображение, отмасштабированное с фактором 3, при <codeph>smoothing</codeph> в значении <codeph>false</codeph> (слева) и <codeph>true</codeph> (справа).
     
     <p>
      <adobetable>
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="Растровое изображение без смягчения" href="../../images/bitmap_smoothing_off.jpg"/></entry>
      <entry align="center"><adobeimage alt="Растровое изображение со смягчением" href="../../images/bitmap_smoothing_on.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     </p>
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Инициализирует объект Bitmap для ссылки на заданный объект BitmapData.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Bitmap:bitmapData:get"><apiName>bitmapData</apiName><shortdesc>
    Объект BitmapData, указанный в ссылке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
    Объект BitmapData, указанный в ссылке.
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:pixelSnapping:get"><apiName>pixelSnapping</apiName><shortdesc>
    Определяет, должен ли объект Bitmap быть привязанным к ближайшему пикселю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Определяет, должен ли объект Bitmap быть привязанным к ближайшему пикселю. Класс PixelSnapping включает возможные значения:
    
    <ul>
    
      <li><codeph>PixelSnapping.NEVER</codeph> – Привязка к пикселям не выполняется.</li>
    
      <li><codeph>PixelSnapping.ALWAYS</codeph> – Изображение всегда привязывается к ближайшему пикселю, независимо от преобразования.</li>
    
      <li><codeph>PixelSnapping.AUTO</codeph> – Изображение привязывается к ближайшему пикселю, если не выполнялось вращение или наклон, а также если оно отображено в масштабе от 99,9% до 100,1%. Если эти условия удовлетворяются, растровое изображение отображается в масштабе 100% с привязкой к ближайшему пикселю. На внутреннем уровне это значение позволяет показывать изображение с максимальной быстротой с помощью векторного средства визуализации.</li>
    
    </ul>
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:smoothing:get"><apiName>smoothing</apiName><shortdesc>
    Определяет, следует ли сглаживать растровое изображение при масштабировании.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Определяет, следует ли сглаживать растровое изображение при масштабировании. При значении <codeph>true</codeph> растровое изображение смягчается при масштабировании. При значении <codeph>false</codeph> растровое изображение не смягчается при масштабировании.
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Scene"><apiName>Scene</apiName><shortdesc>
	В классе Scene предусмотрены свойства для определения имени, подписей и числа кадров в монтажном кадре.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	В классе Scene предусмотрены свойства для определения имени, подписей и числа кадров в монтажном кадре. Класс MovieClip включает свойство <codeph>currentScene</codeph>, которое является объектом Scene, определяющим монтажный кадр, в котором находится точка воспроизведения на временной шкале экземпляра MovieClip. Свойство <codeph>scenes</codeph> класса MovieClip представляет собой массив объектов Scene. Также методы <codeph>gotoAndPlay()</codeph> и <codeph>gotoAndStop()</codeph> класса MovieClip используют объекты Scene в качестве параметров.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:Scene:labels:get"><apiName>labels</apiName><shortdesc>
		Массив объектов FrameLabel для монтажного кадра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		Массив объектов FrameLabel для монтажного кадра. Каждый объект FrameLabel содержит свойство <codeph>frame</codeph>, задающее номер кадра, соответствующий подписи, и свойство <codeph>name</codeph>.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:Scene:name:get"><apiName>name</apiName><shortdesc>
		Имя монтажного кадра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Имя монтажного кадра.
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Scene:numFrames:get"><apiName>numFrames</apiName><shortdesc>
		Число кадров в монтажном кадре.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		Число кадров в монтажном кадре.
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageDisplayState"><apiName>StageDisplayState</apiName><shortdesc>
Класс StageDisplayState передает значения для свойства Stage.displayState.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс StageDisplayState передает значения для свойства <codeph>Stage.displayState</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link></related-links><apiValue id="flash.display:StageDisplayState:FULL_SCREEN"><apiName>FULL_SCREEN</apiName><shortdesc>
Задает полноэкранный режим рабочей области.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает полноэкранный режим рабочей области. В этом режиме взаимодействие с клавиатурой отключено.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:FULL_SCREEN_INTERACTIVE"><apiName>FULL_SCREEN_INTERACTIVE</apiName><shortdesc>
Задает полноэкранный режим рабочей области с активной клавиатурой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreenInteractive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает полноэкранный режим рабочей области с активной клавиатурой. <ph platform="actionscript">Данная функциональная возможность поддерживается только приложениями AIR.</ph>

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
Задает обычный режим рабочей области.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает обычный режим рабочей области. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderData"><apiName>ShaderData</apiName><shortdesc>
	 В объекте ShaderData содержатся свойства, отвечающие за все параметры и входы ядра затенения, а также свойства, содержащие все метаданные, указанные для затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 В объекте ShaderData содержатся свойства, отвечающие за все параметры и входы ядра затенения, а также свойства, содержащие все метаданные, указанные для затенения.
	 
	 <p>Эти свойства применяются к объекту ShaderData при его создании. Имена свойств совпадают с именами, указанными в исходном коде затенения. Типы данных каждого свойства различаются в зависимости от представляемого свойством аспекта затенения. Например, свойства, представляющие параметры затенения, являются экземплярами ShaderParameter, свойства, представляющие изображения ввода, являются экземплярами ShaderInput, а свойства, представляющие метаданные затенения, относятся к классу ActionScript в зависимости от их типа данных (экземпляр String для метаданных в формате текста и uint для метаданных типа uint).</p>
	 
	 <p>Рассмотрим пример затенения, который характеризуется одним изображением ввода (<codeph>src</codeph>), двумя параметрами (<codeph>size</codeph> и <codeph>radius</codeph>) и тремя значениями метаданных (<codeph>nameSpace</codeph>, <codeph>version</codeph> и <codeph>description</codeph>):</p>
	 
	 <codeblock>
	 &lt;languageVersion : 1.0;>
	 
	 kernel DoNothing
	 &lt;
	     namespace: "Adobe::Example";
	     vendor: "Adobe examples";
	     version: 1;
	     description: "A shader that does nothing, but does it well.";
	 >
	 {
	     input image4 src;
	 
	     output pixel4 dst;
	     
	     parameter float2 size
	     &lt;
	         description: "The size of the image to which the kernel is applied";
	         minValue: float2(0.0, 0.0);
	         maxValue: float2(100.0, 100.0);
	         defaultValue: float2(50.0, 50.0);
	     >;
	     
	     parameter float radius
	     &lt;
	         description: "The radius of the effect";
	         minValue: 0.0;
	         maxValue: 50.0;
	         defaultValue: 25.0;
	     >;
	 
	     void evaluatePixel()
	     {
	         float2 one = (radius / radius) ∗ (size / size);
	         dst = sampleNearest(src, outCoord());
	     }
	 }
	 </codeblock>
	 
	 <p>Если при создании экземпляра Shader использовался байт-код данного затенения, то в свойстве <codeph>data</codeph> экземпляра ShaderData будут содержаться следующие свойства:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Свойство</entry><entry>Тип данных</entry><entry>Значение</entry></row></thead><tbody><row>
	   <entry>Имя</entry>
	   <entry>Строка</entry>
	   <entry>DoNothing</entry>
	 </row><row>
	   <entry>nameSpace</entry>
	   <entry>Строка</entry>
	   <entry>Adobe::Example</entry>
	 </row><row>
	   <entry>version</entry>
	   <entry>Строка</entry>
	   <entry>"1"</entry>
	 </row><row>
	   <entry>description</entry>
	   <entry>Строка</entry>
	   <entry>«Затенение, которое не оказывает никакого эффекта»</entry>
	 </row><row>
	   <entry>src</entry>
	   <entry>ShaderInput</entry>
	   <entry><i>[Экземпляр ShaderInput]</i></entry>
	 </row><row>
	   <entry>size</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[Экземпляр ShaderParameter, содержащий свойства метаданных параметра]</i></entry>
	 </row><row>
	   <entry>radius</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[Экземпляр ShaderParameter, содержащий свойства метаданных параметра]</i></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Обратите внимание на то, что каждое изображение ввода или параметр, определенные в исходном коде затенения, но не используемые в функции <codeph>evaluatePixel()</codeph> затенения, удаляются при компиляции затенения в байт-код. В этом случае соответствующие экземпляры ShaderInput или ShaderParameter к экземпляру ShaderData в качестве свойства не прибавляются.</p> 
	 
	 <p>Обычно, в коде разработчика создание экземпляра ShaderData не заложено. Экземпляр ShaderData, содержащий данные, параметры и вводы для затенения, доступен в качестве свойства <codeph>data</codeph> экземпляра Shader.</p>
	 
	 </apiDesc><example conref="examples\ShaderDataExample.1.as"> В следующем примере происходит загрузка затенения и перечисление экземпляра ShaderData в его свойстве <codeph>data</codeph> для отображения свойств ввода, параметров и метаданных данного затенения.
 
 <p>Обратите внимание, что в этом примере мы исходим из того, что существует файл байт-кодов с именем donothing.pbj, хранящийся в каталоге, который является выходным для приложения.</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel DoNothing
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "A shader that does nothing, but does it well.";
>
{
    input image4 src;
    
    output pixel4 dst;
    
    parameter float2 size
    &lt;
        description: "The size of the image to which the shader is applied";
        minValue: float2(0.0, 0.0);
        maxValue: float2(100.0, 100.0);
        defaultValue: float2(50.0, 50.0);
    >;
    
    parameter float radius
    &lt;
        description: "The radius of the effect";
        minValue: float(0.0);
        maxValue: float(50.0);
        defaultValue: float(25.0);
    >;

    void evaluatePixel()
    {
        float2 one = (radius / radius) * (size / size);
        dst = sampleNearest(src, outCoord());
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderDataExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function ShaderDataExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            for (var p:String in shader.data) {
                trace(p, ":", shader.data[p]);
                for (var d:String in shader.data[p]) {
                    trace("\t", d, ":", shader.data[p][d]);
                }
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links><apiConstructor id="flash.display:ShaderData:ShaderData"><apiName>ShaderData</apiName><shortdesc>
		 Создает экземпляр ShaderData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>byteCode</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Байт-код затенения.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Создает экземпляр ShaderData. Обычно в коде разработчика прямой вызов конструктора ShaderData не производится. Доступ к экземпляру ShaderData, содержащему данные, параметры и вводы для затенения, осуществляется через его свойство <codeph>data</codeph>.
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
	 Экземпляр ShaderJob используется для выполнения операций затенения в автономном режиме.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Экземпляр ShaderJob используется для выполнения операций затенения в автономном режиме. Выполняется операция затенения, и возвращаются результирующие данные. Задачей разработчика является определение способа использования результата.
	 
	 <p>Существует две основные причины использования затенения в автономном режиме.</p>
	 
	 <ul>
	   <li>Обработка данных, отличных от изображений: при использовании экземпляра ShaderJob можно управлять входными значениями и способами использования результатов затенения. Операция затенения может возвращать результаты в виде двоичных данных или числовых данных вместо данных изображений.</li>
	   <li>Фоновая обработка: некоторые операции затенения являются достаточно сложными, и на их выполнение требуется много времени. Выполнение сложной операции затенения в основном потоке выполнения приложения может замедлить другие части приложения, например, реакцию на действия пользователя или обновление экрана. С помощью экземпляра ShaderJob можно выполнить операцию затенения в фоновом режиме. Таким способом операция затенения выполняется отдельно от основного потока приложения.</li>
	 </ul>
	 
	 <p>Свойство <codeph>shader</codeph> (или параметр конструктора) определяет экземпляр Shader, представляющий используемое в данной операции затенение. Параметры и входы, используемые затенением, настраиваются с помощью связанных экземпляров ShaderParameter или ShaderInput.</p>
	 
	 <p>Перед выполнением операции ShaderJob необходимо указать объект, в который записывается результат, путем его настройки в качестве значения свойства <codeph>target</codeph>. По завершении операции затенения результат записывается в объект <codeph>target</codeph>.</p>
	 
	 <p>Чтобы начать операцию фонового затенения, вызовите метод <codeph>start()</codeph>. По завершении операции затенения результат записывается в объект <codeph>target</codeph>. В этот момент экземпляр ShaderJob отправляет событие <codeph>complete</codeph>, уведомляя прослушивателей о наличии готового результата.</p>
	 
	 <p>Для синхронного выполнения затенения (то есть не в фоновом режиме) вызовите метод <codeph>start()</codeph> и передайте значение <codeph>true</codeph> в качестве аргумента. Затенение выполняется в основном потоке выполнения, и выполнение кода приостанавливается до завершения операции. После выполнения операции результаты сохраняются в объекте <codeph>target</codeph>. В этой точке приложение продолжает выполнение следующей строки кода.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader"><linktext>Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>ShaderParameter</linktext></link><link href="flash.events.xml#ShaderEvent"><linktext>ShaderEvent</linktext></link></related-links><adobeApiEvent id="flash.display:ShaderJob_flash.events.ShaderEvent.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 Отправка по завершении обработки данных с использованием затенения заданием ShaderJob, которое выполняется асинхронно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ShaderEvent.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправка по завершении обработки данных с использованием затенения заданием ShaderJob, которое выполняется асинхронно. Экземпляр ShaderJob выполняется асинхронно при вызове метода <codeph>start()</codeph> со значением <codeph>false</codeph> для параметра <codeph>waitForCompletion</codeph>.
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:ShaderJob:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
		 
		 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Используемое в операции затенение.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект, в который сохраняется результат вычисления операции затенения. Аргументом может быть объект BitmapData, ByteArray или Vector. Экземпляр &lt;Number>.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Ширина результирующих данных в <codeph>target</codeph>, если аргументом является ByteArray или Vector. Экземпляр &lt;Number>. Размер ByteArray или Vector. При необходимости происходит расширение экземпляра &lt;Number>, а существующие данные перезаписываются.
		 
		 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Высота результирующих данных в <codeph>target</codeph>, если аргументом является ByteArray или Vector. Экземпляр &lt;Number>. Размер ByteArray или Vector. При необходимости происходит расширение экземпляра &lt;Number>, а существующие данные перезаписываются.
         
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:ShaderJob:cancel"><apiName>cancel</apiName><shortdesc>
		 Отменяет текущую запущенную операцию затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Отменяет текущую запущенную операцию затенения. Все полученные в результате вычислений данные игнорируются. Событие <codeph>complete</codeph> не отправляется.
		 
		 <p>Многократный вызов метода <codeph>cancel()</codeph> не действует.</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:ShaderJob:start"><apiName>start</apiName><shortdesc>
		 Запуск операции затенения в синхронном или асинхронном режиме в соответствии со значением параметра waitForCompletion.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если свойство <codeph>target</codeph> принимает значение <codeph>null</codeph> или не является BitmapData, ByteArray или Vector. Экземпляр &lt;Number>.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если затенение задает неподдерживаемое входное изображение.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если объект ByteArray или Vector. В качестве ввода используется экземпляр &lt;Number>, а свойства <codeph>width</codeph> и <codeph>height</codeph> для ShaderInput не указаны либо указанные значения не соответствуют количеству данных во входном объекте. Дополнительные сведения см. в описании <codeph>ShaderInput.input</codeph>.
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>waitForCompletion</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определение необходимости выполнения затенения в фоновом режиме (по умолчанию <codeph>false</codeph>) или в основном потоке выполнения программы (<codeph>true</codeph>).
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Запуск операции затенения в синхронном или асинхронном режиме в соответствии со значением параметра <codeph>waitForCompletion</codeph>.
		 
		 <p>В асинхронном режиме (если для параметра <codeph>waitForCompletion</codeph> задано значение <codeph>false</codeph>), который является режимом по умолчанию, выполнение ShaderJob осуществляется в фоновом режиме. Операция затенения не влияет на быстроту реакции отображения или других операций. В асинхронном режиме вызов метода <codeph>start()</codeph> происходит немедленно и в программе продолжается выполнение следующей строки кода. По завершении выполнения операции затенения в фоновом режиме доступен результат и выполняется отправка события <codeph>complete</codeph>.</p>
		 
		 <p>Одновременно может выполняться только одна фоновая операция ShaderJob. Все операции затенения помещаются в очередь и выполняются последовательно. При вызове метода <codeph>start()</codeph> во время выполнения операции затенения еще одна операция добавляется в конец очереди. Впоследствии, когда наступает очередь, она выполняется.</p>
		 
		 <p>Чтобы выполнить операцию затенения в синхронном режиме, вызовите метод <codeph>start()</codeph> со значением <codeph>true</codeph> для параметра <codeph>waitForCompletion</codeph> (единственный параметр). Выполнение кода приостанавливается в точке вызова метода <codeph>start()</codeph> до завершения операции затенения. В этой точке доступен результат, и продолжается выполнение следующей строки кода.</p>
		 
		 <p>При вызове метода <codeph>start()</codeph> происходит копирование на внутреннем уровне экземпляра Shader в свойстве <codeph>shader</codeph>. При выполнении операции затенения используется эта копия, а не ссылка на исходное затенение. Изменения параметров затенения (изменение значения параметра, ввода или байт-кода) не влияют на используемую для обработки затенения копию затенения. Для внедрения изменений в операцию затенения произведите вызов метода <codeph>cancel()</codeph> (при необходимости) и повторно вызовите метод <codeph>start()</codeph>, чтобы запустить операцию обработки затенения.</p>
		 
		 <p>На время выполнения операции затенения значение объекта <codeph>target</codeph> остается неизменным. По завершении операции (и выполнения отправки события <codeph>complete</codeph> в асинхронном режиме) все результаты одновременно записываются в объект <codeph>target</codeph>. Если объект <codeph>target</codeph> является экземпляром BitmapData и его метод <codeph>dispose()</codeph> вызывается до завершения операции, отправка события <codeph>complete</codeph> выполняется в асинхронном режиме. В таком случае, данные в объект BitmapData не сохраняются, так как его не существует.</p>
         
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.display:ShaderJob:start_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Передается по завершении операции, если метод <codeph>start()</codeph> вызывается со значением <codeph>true</codeph> аргумента <codeph>waitForCompletion</codeph>.
		 
		 </apiDesc></adobeApiEventDetail><shortdesc>Передается по завершении операции, если метод start() вызывается со значением true аргумента waitForCompletion.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.display:ShaderJob:height:get"><apiName>height</apiName><shortdesc>
		 Высота данных результата в target, если он является ByteArray или Vector. Экземпляр &amp;lt;Number&amp;gt;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Высота результирующих данных в <codeph>target</codeph>, если он является ByteArray или Vector. Экземпляр &lt;Number>. Размер ByteArray или Vector. При необходимости происходит расширение экземпляра &lt;Number>, а существующие данные перезаписываются.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:progress:get"><apiName>progress</apiName><shortdesc>
		 Прогресс выполнения запущенной операции затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Прогресс выполнения запущенной операции затенения. Значение находится в диапазоне от 0 до 1. В значении 0 прогресс выполнения находится на отметке 0%. Значение 1 указывает на завершение операции.
		 
		 <p>При вызове метода <codeph>cancel()</codeph> значение этого свойства становится <codeph>undefined</codeph> и уже не отображает реального значения прогресса при повторном запуске операции.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:shader:get"><apiName>shader</apiName><shortdesc>
		 Используемое в операции затенение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 Используемое в операции затенение. Все параметры и вводы для операции затенения задаются в свойствах <codeph>data</codeph> экземпляра Shader, а именно ShaderInput или ShaderParameter. Ввод задается соответствующим свойством ShaderInput, даже если он совпадает с объектом <codeph>target</codeph>.
		 
		 <p>Для обработки массива ByteArray, данные в котором расположены линейно (в отличие от данных изображения), задайте параметры соответствующего экземпляра ShaderInput следующим образом: для <codeph>height</codeph> установите значение 1, для <codeph>width</codeph> – число 32-разрядных значений с плавающей запятой в массиве ByteArray. В этом случае значение ввода затенения должно принадлежать типу данных <codeph>image1</codeph>.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderJob:target:get"><apiName>target</apiName><shortdesc>
		 Объект, в который сохраняется результат вычисления операции затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 Объект, в который сохраняется результат вычисления операции затенения. Этот объект может быть объектом BitmapData, ByteArray или Vector. Экземпляр &lt;Number>.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:width:get"><apiName>width</apiName><shortdesc>
		 Ширина данных результата в target, если он является ByteArray или Vector. Экземпляр &amp;lt;Number&amp;gt;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Ширина данных результата в <codeph>target</codeph>, если он является ByteArray или Vector. Экземпляр &lt;Number>. Размер ByteArray или Vector. При необходимости происходит расширение экземпляра &lt;Number>, а существующие данные перезаписываются.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowSystemChrome"><apiName>NativeWindowSystemChrome</apiName><shortdesc>
	 Класс NativeWindowSystemChrome определяет константы для свойства systemChrome объекта NativeWindowInitOptions, используемого для создания собственного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс NativeWindowSystemChrome определяет константы для свойства <codeph>systemChrome</codeph> объекта NativeWindowInitOptions, используемого для создания собственного окна.  
	 
	 <p>Системным хромом называются элементы окна, определяемые операционной системой, такие как строка заголовка, кнопки «Свернуть», «Развернуть» и «Закрыть».</p>
  	 
	 <p><b>Примечание.</b> Тип системного хрома задается при создании окна и не может изменяться впоследствии.</p>
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowSystemChrome:NONE"><apiName>NONE</apiName><shortdesc>
	 Нет системного хрома.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Нет системного хрома. 
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowSystemChrome:STANDARD"><apiName>STANDARD</apiName><shortdesc>
	 Стандартный хром для операционной системы компьютера.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Стандартный хром для операционной системы компьютера.
	 
	 <p>Используйте этот параметр, чтобы имитировать внешний вид собственной операционной системы.</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsStroke"><apiName>IGraphicsStroke</apiName><shortdesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров stroke в методах flash.display.Graphics и классах рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров stroke в методах flash.display.Graphics и классах рисования. Используйте классы средства реализации данного интерфейса для создания данных свойства stroke и управления ими, а также для повторного использования этих данных для других экземпляров.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
 Класс SimpleButton позволяет управлять всеми экземплярами символов-кнопок в SWF-файле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Класс SimpleButton позволяет управлять всеми экземплярами символов-кнопок в SWF-файле.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SimpleButton позволяет управлять всеми экземплярами символов-кнопок в SWF-файле. Создав экземпляр кнопки в инструменте разработки, можно использовать методы и свойства класса SimpleButton для манипуляции с кнопками с помощью ActionScript.
 
 <p product="flash">Кнопке можно присвоить имя экземпляра в инспекторе свойств. Имена экземпляров SimpleButton отображаются в обозревателе ролика Movie Explorer и в диалоговом окне «Целевой путь» на панели «Действия».</p>
 
 <p>В ActionScript 3.0 для создания экземпляра SimpleButton используется конструктор <codeph>new SimpleButton()</codeph>.</p>
 
 <p>Класс SimpleButton наследует методы и свойства класса InteractiveObject.</p>
 
 </apiDesc><example conref="examples\SimpleButtonExample.as"> В следующем примере используется класс SimpleButtonExample, который в свою очередь использует класс CustomSimpleButton, и затем он создает экземпляры четырех объектов ButtonDisplayState. В результате создается квадратная кнопка, цвет фона которой изменяется в зависимости от состояния мыши путем переопределения свойств экземпляра класса SimpleButton. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>В конструкторе <codeph>SimpleButtonExample()</codeph> создается новый объект CustomSimpleButton типа SimpleButton с именем <codeph>button</codeph> при помощи конструктора <codeph>CustomSimpleButton</codeph>. Объект <codeph>button</codeph> добавляется в список отображения. Цвет и размер кнопки определяются в следующих шагах.</li>
 
  <li>В классе CustomSimpleButton объявляются свойства экземпляра, которые в дальнейшем будут использоваться для управления размером и фоновым цветом объекта <codeph>button</codeph> в зависимости от его состояния (оранжевый в обычном состоянии, темно-желтый при наведении мыши и голубой при нажатии мыши). Во всех состояниях объекта <codeph>button</codeph> размер квадрата равен 80 пикселям, что определено свойством <codeph>size</codeph>.</li>
 
  <li>Функция конструктора класса CustomSimpleButton задает свойства <codeph>downState</codeph>, <codeph>overState</codeph>, <codeph>upState</codeph>, <codeph>hitTestState</codeph> и <codeph>useHandCursor</codeph> для всех четырех экземпляров класса ButtonDisplayState.</li>
 
  <li>В классе ButtonDisplayState конструктор задает значение размера и фонового цвета квадрата и вызывает метод <codeph>draw()</codeph>.</li>
 
  <li>Метод <codeph>draw()</codeph> перерисовывает квадрат, используя размер и цвет фона, заданный в конструкторе, в зависимости от состояния кнопки.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class SimpleButtonExample extends Sprite {
        public function SimpleButtonExample() {
            var button:CustomSimpleButton = new CustomSimpleButton();
            addChild(button);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.SimpleButton;

class CustomSimpleButton extends SimpleButton {
    private var upColor:uint   = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;
    private var size:uint      = 80;

    public function CustomSimpleButton() {
        downState      = new ButtonDisplayState(downColor, size);
        overState      = new ButtonDisplayState(overColor, size);
        upState        = new ButtonDisplayState(upColor, size);
        hitTestState   = new ButtonDisplayState(upColor, size * 2);
        hitTestState.x = -(size / 4);
        hitTestState.y = hitTestState.x;
        useHandCursor  = true;
    }
}

class ButtonDisplayState extends Shape {
    private var bgColor:uint;
    private var size:uint;

    public function ButtonDisplayState(bgColor:uint, size:uint) {
        this.bgColor = bgColor;
        this.size    = size;
        draw();
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject"><linktext>Класс InteractiveObject</linktext></link></related-links><apiConstructor id="flash.display:SimpleButton:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
	Создает новый экземпляр SimpleButton.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>upState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Начальное значение для ненажатого состояния SimpleButton.
	</apiDesc></apiParam><apiParam><apiItemName>overState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Начальное значение для состояния over SimpleButton.
	</apiDesc></apiParam><apiParam><apiItemName>downState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Начальное значение для состояния down SimpleButton.
	</apiDesc></apiParam><apiParam><apiItemName>hitTestState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>Начальное значение для состояния hitTest SimpleButton.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Создает новый экземпляр SimpleButton.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Создает новый экземпляр SimpleButton. Все и каждый из экранных объектов, представляющих разные состояния кнопки, можно задать в качестве параметров в конструкторе.  
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:SimpleButton:downState:get"><apiName>downState</apiName><shortdesc>
	 Задает объект отображения, применяемый в качестве визуального объекта для отображения кнопки в нажатом состоянии – кнопка устанавливается в это положение при выборе объекта hitTestState.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Задает значение DisplayObject, используемое для состояния Down кнопки.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Задает объект отображения, применяемый в качестве визуального объекта для отображения кнопки в нажатом состоянии – кнопка устанавливается в это положение при выборе объекта <codeph>hitTestState</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Логическое значение, которое определяет, включена ли кнопка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button.enabled, enabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Показывает, включена ли кнопка. Принимает значения true и false.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Логическое значение, которое определяет, включена ли кнопка. Когда кнопка отключена (свойство enabled имеет значение <codeph>false</codeph>), кнопка является видимой, но не может быть выбрана. По умолчанию используется значение <codeph>true</codeph>. Это свойство удобно использовать, когда требуется отключить часть элементов навигации. Например, может потребоваться отключить кнопку на отображаемой в данный момент странице, чтобы на нее нельзя было нажать и чтобы предотвратить перезагрузку страницы.
	 
	 <p><b>Примечание.</b> Для предотвращения событий mouseClicks для кнопки установите оба свойства – <codeph>enabled</codeph> и <codeph>mouseEnabled</codeph> – на значение <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:hitTestState:get"><apiName>hitTestState</apiName><shortdesc>
	 Задает экранный объект, который служит кнопке в качестве объекта для тестирования нажатия.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier></apiValueDef><apiDesc>
	 Задает экранный объект, который служит кнопке в качестве объекта для тестирования нажатия. Для базовой кнопки нужно задать свойству <codeph>hitTestState</codeph> тот же экранный объект, что и свойству<codeph>overState</codeph>. Если не указать свойство <codeph>hitTestState</codeph>, объект SimpleButton будет неактивным: он не будет отвечать на события мыши и клавиатуры.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:overState:get"><apiName>overState</apiName><shortdesc>
	 Задает объект отображения, применяемый в качестве визуального объекта для отображения кнопки в положении &amp;#8212; когда на нее наведен курсор мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Задает значение DisplayObject, используемое для состояния Over кнопки.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Задает экранный объект, применяемый в качестве визуального объекта для отображения кнопки в состоянии Over (в котором находится кнопка, когда указатель мыши располагается над ней).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 Объект SoundTransform, связанный с этой кнопкой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should information from AS2 setTransform be here? e.g. percentage values indicating
	 how much of the left input to play in the left speaker or right speaker; it is generally
	 best to use 22-KHZ 6-bit mono sounds?
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 Объект SoundTransform, связанный с этой кнопкой. Объект SoundTransform включает свойства для настройки громкости, панорамы, назначения левого и правого динамиков. Данный объект SoundTransform применяется ко всем состояниям кнопки. Данный объект SoundTransform воздействует только на встроенные звуки.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Определяет, могут ли другие экранные объекты, являющиеся объектами SimpleButton или MovieClip, получать события отпускания кнопки мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, могут ли другие экранные объекты, являющиеся объектами SimpleButton или MovieClip, получать события отпускания кнопки мыши. Свойство <codeph>trackAsMenu</codeph> позволяет создавать меню. Свойство <codeph>trackAsMenu</codeph> можно задать для любого объекта SimpleButton или MovieClip. Если свойство <codeph>trackAsMenu</codeph> не существует, по умолчанию используется значение <codeph>false</codeph>. 
	 
	 <p>Свойство <codeph>trackAsMenu</codeph> можно изменить в любой момент; обновленный фрагмент ролика немедленно начинает использовать новое поведение курсора. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:upState:get"><apiName>upState</apiName><shortdesc>
	 Задает объект отображения, применяемый в качестве визуального объекта для отображения кнопки в отжатом положении (кнопка находится в положении, когда указатель мыши не наведен на нее).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>Задает значение DisplayObject, используемое для состояния Up кнопки.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Задает экранный объект, применяемый в качестве визуального объекта для отображения кнопки в состоянии вверх (в котором находится кнопка, когда указатель мыши не расположен над ней).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
     Логическое значение. При значении true определяет, отображается ли курсор в виде руки при наведении курсора мыши на кнопку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create two buttons on the Stage with the instance names <code>myBtn1_btn</code> and <code>myBtn2_btn</code>. Enter the following ActionScript in Frame 1 of the Timeline:
	 <listing>
	 myBtn1_btn.useHandCursor = false;
	 myBtn1_btn.onRelease = buttonClick;
	 myBtn2_btn.onRelease = buttonClick;
	 function buttonClick() {
	   trace(this._name);
	 }
	 </listing>
	 <p>When the mouse is over and clicks <code>myBtn1_btn</code>, there is no pointing hand. However, you see the pointing hand when the button is over and clicks <code>myBtn2_btn</code>.</p>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Если установлено значение true, отображает курсор в виде руки.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Логическое значение. При значении <codeph>true</codeph> определяет, отображается ли курсор в виде руки при наведении указателя мыши на кнопку. Если этому свойству задано значение <codeph>false</codeph>, используется курсор «стрелка». По умолчанию используется значение <codeph>true</codeph>.
	 
	 <p>Свойство <codeph>useHandCursor</codeph> можно изменить в любой момент; обновленный фрагмент ролика немедленно начинает использовать новое поведение курсора. </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:TriangleCulling"><apiName>TriangleCulling</apiName><shortdesc>
 Определяет коды для отбора алгоритмов, используемых для определения треугольников, которые не будут визуализироваться при прорисовке контуров треугольников.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Определяет коды для отбора алгоритмов, используемых для определения треугольников, которые не будут визуализироваться при прорисовке контуров треугольников.
 
 <p>
 Термины <codeph>POSITIVE</codeph> и <codeph>NEGATIVE</codeph> влияют на нормаль треугольника относительно оси z. Под нормалью подразумевается трехмерный вектор, направленный перпендикулярно поверхности треугольника.
 </p>
 
 <p>
 Считается, что если векторы 0, 1 и 2 треугольника расположены по часовой стрелке, значение его нормали положительное. Иными словами, его нормаль указывает на положительное направление оси z от текущей точки обзора. При использовании алгоритма <codeph>TriangleCulling.POSITIVE</codeph> треугольники с положительными нормалями не визуализируются. Для этого используется другое название – «отбор невидимых поверхностей».
 </p>
 
 <p>
 Если векторы треугольника расположены против часовой стрелки, значение его нормали отрицательное. Иными словами, его нормаль указывает на отрицательное направление оси z по отношению к текущей точке обзора. При использовании алгоритма <codeph>TriangleCulling.NEGATIVE</codeph> треугольники с отрицательными нормалями не визуализируются.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTrianglePath()"><linktext>flash.display.Graphics.drawTrianglePath()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="http://www.gamedev.net/reference/articles/article1089.asp"><linktext>Введение в трехмерные векторы.</linktext></link><link href="http://www.gamedev.net/reference/articles/article1088.asp"><linktext>Трехмерный отбор невидимых поверхностей.</linktext></link></related-links><apiValue id="flash.display:TriangleCulling:NEGATIVE"><apiName>NEGATIVE</apiName><shortdesc>
     Задает отбор всех треугольников, которые направлены в сторону текущей точки обзора.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>negative</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Задает отбор всех треугольников, которые направлены в сторону текущей точки обзора.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:NONE"><apiName>NONE</apiName><shortdesc>
     Задает отсутствие отбора.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Задает отсутствие отбора. Визуализируются все треугольники в контуре.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:POSITIVE"><apiName>POSITIVE</apiName><shortdesc>
     Задает отбор всех треугольников, которые направлены в обратную сторону по отношению к текущей точке обзора.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>positive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Задает отбор всех треугольников, которые направлены в обратную сторону по отношению к текущей точке обзора. Это также называют отбором невидимых поверхностей.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
 Класс NativeWindow обеспечивает интерфейс для создания собственных окон рабочего стола и управления ими.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс NativeWindow обеспечивает интерфейс для создания собственных окон рабочего стола и управления ими.
  
 <p platform="actionscript">Ссылка на экземпляр NativeWindow возвращается конструктором окон. Ссылка на экземпляр NativeWindow также доступна через свойство <codeph>stage.nativeWindow</codeph> любого экранного объекта в рабочей области окна:
 </p>
 
 <pre platform="actionscript">var window:NativeWindow = displayObject.stage.nativeWindow;</pre>
 
 <p platform="javascript">Ссылка на экземпляр NativeWindow возвращается конструктором окон. Код JavaScript на странице HTML может ссылаться на экземпляр NativeWindow с использованием свойства <codeph>window.nativeWindow</codeph>.
 </p>
 
 <p>Свойства экземпляра NativeWindow может получать только содержимое приложения. Если содержимое не из приложения попытается обратиться к объекту NativeWindow, будет отправлена ошибка системы безопасности.</p>
 
 <p>Содержимое можно добавить в окно с помощью методов DisplayObjectContainer объекта Stage, таких как <codeph>addChild()</codeph>.</p>
 
 <p platform="actionscript">Невозможно добавить компоненты Flex непосредственно в список отображения экземпляра NativeWindow. Вместо этого используйте компоненты Flex mx:WindowedApplication и mx:Window для создания окон и добавления других компонентов Flex в качестве дочерних объектов. Можно добавить SWF-содержимое на основе Flex непосредственно в окно NativeWindow, если SWF-файл загружен в собственный домен приложений и является содержимым приложения.
 </p>
 
 <p>Чтобы создать корневое HTML-окно для отображения HTML-содержимого, обычно достаточно создать окно с помощью метода <codeph>HTMLLoader.createRootWindow()</codeph>. В окна, созданные таким способом, автоматически добавляется объект HTMLLoader. (Из кода JavaScript также можно использовать функцию <codeph>window.open()</codeph>. Однако этот метод дает меньше возможностей управления внешним видом и поведением окон.)</p>
 
 <p>
 Далее перечислены асинхронные операции над объектами NativeWindow: <codeph>close()</codeph>, <codeph>maximize()</codeph>, <codeph>minimize()</codeph>, <codeph>restore()</codeph> и изменение <codeph>границ</codeph>. Приложение может выявить выполнение этих операций, прослушивая соответствующие события.
 </p>
 
 <p>
 Если свойство <codeph>NativeApplication.autoExit</codeph> имеет значение <codeph>true</codeph>, используемое по умолчанию, приложение закроется при закрытии последнего окна (и возврате всех обработчиков события <codeph>close</codeph>). Если <codeph>autoExit</codeph> имеет значение <codeph>false</codeph>, тогда для завершения работы приложения необходимо вызвать метод <codeph>NativeApplication.nativeApplication.exit()</codeph>.
 </p>
 <p>
 Объекты NativeWindow не очищаются после вызова конструктора окон и перед вызовом <codeph>close()</codeph>. Приложение должно самостоятельно закрывать свои окна.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/nativeWindow"><linktext>flash.display.Stage.nativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="flash.desktop.xml#NativeApplication"><linktext>flash.desktop.NativeApplication</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
 Отправляется данным объектом NativeWindow после деактивации окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow после деактивации окна.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
 Отправляется данным объектом NativeWindow после активации окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow после активации окна.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Отправляется данным объектом NativeWindow после закрытия окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow после закрытия окна.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSING_closing"><apiName>closing</apiName><shortdesc>
 Отправляется этим объектом NativeMenu непосредственно перед закрытием окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется этим объектом NativeMenu непосредственно перед закрытием окна. Это событие можно отменить, чтобы предотвратить закрытие окна.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE_displayStateChange"><apiName>displayStateChange</apiName><shortdesc>
 Отправляется данным объектом NativeWindow после изменения свойства displayState окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow после изменения свойства <codeph>displayState</codeph> окна.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING_displayStateChanging"><apiName>displayStateChanging</apiName><shortdesc>
 Отправляется данным объектом NativeWindow непосредственно перед изменением состояния отображения окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow непосредственно перед изменением состояния отображения окна. Это событие можно отменить, чтобы предотвратить изменение.
 
 </apiDesc><example conref="examples\NativeWindow.displayStateChanging.1.as"> Следующий пример иллюстрирует отмену события <codeph>displayStateChanging</codeph>.
<codeblock>
function displayStateChanging_handler(displayStateEvent:NativeWindowDisplayStateEvent):void
{
  //shouldStopStateChange is an application-defined Boolean indicating 
  //that display state changes should be canceled
  if (displayStateEvent.type == NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING 
                                  &amp;&amp;    shouldStopStateChange)
  {
    displayStateEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Отправляется данным объектом NativeWindow после изменения размеров окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow после изменения размеров окна. Событие <codeph>resize</codeph> отправляется при каждом изменении размеров (свойств <codeph>width</codeph> или <codeph>height</codeph>) окна, что может происходить вследствие изменения размеров окна под управлением системы; свертывания, развертывания или восстановления окна; или изменения размеров окна путем задания свойств <codeph>width</codeph>, <codeph>height</codeph> или <codeph>bounds</codeph>. События <codeph>resize</codeph> объекта NativeWindow отправляются во время циклов изменения размеров под управлением системы. Напротив, события <codeph>resize</codeph> объекта Stage отправляются, когда рабочая область готова для рисования.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Stage/resize"><linktext>flash.display.Stage.resize</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZING_resizing"><apiName>resizing</apiName><shortdesc>
 Отправляется этим объектом NativeMenu непосредственно перед изменением размеров окна на рабочем столе.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется этим объектом NativeMenu непосредственно перед изменением размеров окна на рабочем столе. Это событие можно отменить, чтобы предотвратить изменение размеров или изменить его свойства.
 
 </apiDesc><example conref="examples\NativeWindow.resizing.1.as"> Следующий пример иллюстрирует отмену события <codeph>resizing</codeph>.
<codeblock>
function boundsChanging_handler(boundsEvent:NativeWindowBoundsEvent):void
{
  //shouldStopResize is an application-defined Boolean indicating 
  //that resize operations should be canceled
  if (boundsEvent.type == NativeWindowBoundsEvent.RESIZING &amp;&amp; shouldStopResize)
  {
    boundsEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVE_move"><apiName>move</apiName><shortdesc>
 Отправляется данным объектом NativeWindow после перемещения окна на рабочем столе.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется данным объектом NativeWindow после перемещения окна на рабочем столе.
 <p>
 Событие <codeph>move</codeph> отправляется при каждом изменении размеров (свойств <codeph>х</codeph> или <codeph>у</codeph>) окна, что может происходить вследствие перемещения окна под управлением системы; свертывания, развертывания или восстановления окна; или изменения местоположения окна путем задания свойств <codeph>х</codeph>, <codeph>у</codeph> или <codeph>bounds</codeph>.
 </p>
 <p><b>Примечание.</b> Избегайте действий, которые могут открыть одновременные диалоговые окна операционной системы в функциях обработчиков для событий <codeph>moving</codeph> и <codeph>move</codeph> объекта NativeWindow. К примеру, такое может произойти, если обе функции обработчиков выдают ошибки. Если это произойдет, второе открытое диалоговое окно не будет отвечать на щелчки мыши, его придется закрыть с клавиатуры.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVING_moving"><apiName>moving</apiName><shortdesc>
 Отправляется этим объектом NativeMenu непосредственно перед перемещением окна на рабочем столе.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется этим объектом NativeMenu непосредственно перед перемещением окна на рабочем столе. Это событие можно отменить, чтобы предотвратить перемещение или модифицировать его свойства.
 
 <p><b>Примечание.</b> Избегайте действий, которые могут открыть одновременно диалоговые окна операционной системы в функциях обработчиков для событий <codeph>moving</codeph> и <codeph>move</codeph> объекта NativeWindow. К примеру, такое может произойти, если обе функции обработчиков выдают ошибки. Если это произойдет, второе открытое диалоговое окно не будет отвечать на щелчки мыши, его придется закрыть с клавиатуры.</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeWindow:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
    Создает новый экземпляр NativeWindow и соответствующее окно операционной системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Если параметр <codeph>initOptions</codeph> не действителен.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiParam><apiItemName>initOptions</apiItemName><apiOperationClassifier>flash.display:NativeWindowInitOptions</apiOperationClassifier><apiDesc>Объект, содержащий свойства инициализации для данного окна.
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Создает новый экземпляр NativeWindow и соответствующее окно операционной системы.
    <p>
    Настройки, определенные параметром <codeph>initOptions</codeph>, нельзя изменять после создания окна. Недействительные параметры <codeph>initOptions</codeph> приведут к появлению ошибки о недопустимой операции. Действительные настройки, которые недоступны в текущей системе, вызовут создание исключения. При необходимости возможности, специфичные для текущей операционной системы, можно определить с помощью статических членов NativeWindow, таких как <codeph>systemMaxSize</codeph>.
    </p>
    
    <p>Размеры окна по умолчанию определяются операционной системой, но их можно изменить путем настройки границ окна. Это изменение не будет видимым, если свойство окна <codeph>visible</codeph> имеет значение <codeph>false</codeph>.</p>
    
    </apiDesc><example conref="examples\NativeWindow.constructor.1.as"> В следующем примере создается и активируется новый экземпляр NativeWindow:
<codeblock>
import flash.display.NativeWindowInitOptions;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowType;
import flash.display.NativeWindow;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.geom.Rectangle;

var windowOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
windowOptions.systemChrome = NativeWindowSystemChrome.STANDARD;
windowOptions.type = NativeWindowType.NORMAL;

var newWindow:NativeWindow = new NativeWindow(windowOptions);
newWindow.stage.scaleMode = StageScaleMode.NO_SCALE;
newWindow.stage.align = StageAlign.TOP_LEFT;
newWindow.bounds = new Rectangle(100, 100, 800, 800);

newWindow.activate();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeWindow:activate"><apiName>activate</apiName><shortdesc>
	 Активирует данное окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Активирует данное окно. 
	 
	 <p>Активация окна:</p>
	 <ul> 
	 <li>делает окно видимым;</li>
	 <li>выводит его поверх остальных окон;</li> 
	 <li>помещает его в фокус клавиатуры или мыши.</li>
	 </ul>
	 
	 <p>В Linux <codeph>activate()</codeph> является асинхронной операцией.</p>
	 
	 <p>Объект NativeWindow отправляет событие <codeph>activate</codeph> во всех платформах.</p>
	 
	 </apiDesc><example conref="examples\NativeWindow.activate.1.as"> Следующий пример показывает, как сделать окно активным:
  
 <p>С помощью ссылки на экранный объект в рабочей области окна:</p>
<codeblock>
displayObject.stage.nativeWindow.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.2.as"> С помощью ссылки на экземпляр класса NativeWindow:
<codeblock>
windowObj.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.3.as"> Из JavaScript на странице HTML, отображаемой в окне (где <codeph>window</codeph> является глобальным объектом окна JavaScript):
<codeblock>
window.nativeWindow.activate();
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/visible"><linktext>visible</linktext></link><link href="flash.display.xml#NativeWindow/orderToFront"><linktext>orderToFront</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:close"><apiName>close</apiName><shortdesc>
      Закрывает окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Закрывает окно. 
      
      <p>Событие <codeph>close</codeph> отправляется сразу после завершения операции закрытия. Событие <codeph>closing</codeph> не отправляется. Если необходимо разрешить отмену операции закрытия, отправьте событие <codeph>closing</codeph> и проверьте, отменят ли зарегистрированные прослушиватели поведение по умолчанию перед вызовом метода <codeph>close()</codeph>.
      </p>
      <p>
      Если на отображаемые в окне экземпляры экранных объектов нет других ссылок, они будут очищены и уничтожены, за исключением начального окна приложения, созданного в AIR. Чтобы разрешить очистку экранных объектов на начальном окне, удалите их из рабочей области окна.
      </p>
      <p>
      После закрытия объект NativeWindow все еще доступен для ссылок, но обращение к большинству свойств и методов приведет к появлению ошибки о недопустимой операции.
      </p>
      <p>
      Закрытые окна нельзя открыть повторно. Если окно уже закрыто, никакие действия не предпринимаются и события не отправляются.
      </p>
      
      <p>Примечание. Чтобы скрыть окно, не закрывая его, задайте свойству <codeph>visible</codeph> окна значение <codeph>false</codeph>.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.close.1.as"> Следующий пример показывает, как закрыть окно:
  
 <p>С помощью ссылки на экземпляр NativeWindow (<codeph>windowObj</codeph>):</p>
<codeblock>
windowObj.close();

</codeblock></example><example conref="examples\NativeWindow.close.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObj.stage.nativeWindow.close();
</codeblock></example><example conref="examples\NativeWindow.close.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader (или корневом окне HTML):
<codeblock>
window.close(); //overriddable in HTMLHost
</codeblock></example><example conref="examples\NativeWindow.close.4.as"> Или:
<codeblock>
window.nativeWindow.close(); //not overriddable
</codeblock></example><example conref="examples\NativeWindow.close.5.as">  
 Следующий пример показывает, как можно разрешить отмену операции закрытия (где <codeph>windowObj</codeph> является экземпляром NativeWindow, который нужно закрыть):
<codeblock>
public function closeCommand():Boolean{
    var closeEvent:Event = new Event(Event.CLOSING,true,true);
    windowObj.dispatchEvent(closeEvent);
    if(!closeEvent.isDefaultPrevented()){
        windowObj.close();
        return true;
    } else {
      return false;
    }
}
</codeblock></example><example conref="examples\NativeWindow.close.6.as"> Следующий пример показывает, как закрыть окно из процедуры JavaScript, выполняющейся в объекте HTMLLoader (или корневом окне HTML) с разрешением отмены этой операции:
<codeblock>
&lt;script src="AIRAliases.js" type="text/javascript">&lt;/script>
&lt;script type="text/javascript">
    var dirtyData = false;
    function closeWindow(){
            var closingEvent = new air.Event(air.Event.CLOSING,true,true);
            window.nativeWindow.dispatchEvent(closingEvent);
               if(!closingEvent.isDefaultPrevented()){
                   window.nativeWindow.close();
                //or use: window.close(); 
               return true;
           } else {
               return false;
        }
    }
        
    function onClosing(event){
        if(dirtyData){
            event.preventDefault();
            //Save data...
        }
    }    

    window.nativeWindow.addEventListener(air.Event.CLOSING,onClosing);        
&lt;/script>
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/closed"><linktext>flash.display.NativeWindow.closed</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>flash.html.HTMLLoader</linktext></link><link href="../../flash/html/HTMLHost.html"><linktext>flash.html.HTMLHost</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:globalToScreen"><apiName>globalToScreen</apiName><shortdesc>
      Преобразует точку в координатах пикселей относительно исходной точки в рабочей области окна (глобальной точки списка отображения) в точку на виртуальном рабочем столе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Заданная глобальная точка относительно рабочего стола.
      
      </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>globalPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка в рабочей области, преобразуемая в точку на экране.
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Преобразует точку в координатах пикселей относительно исходной точки в рабочей области окна (глобальной точки списка отображения) в точку на виртуальном рабочем столе.
      
      <p>Координаты виртуального рабочего стола строятся относительно верхнего левого угла главного монитора.</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:maximize"><apiName>maximize</apiName><shortdesc>
      Разворачивает данное окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если свойство <codeph>maximizable</codeph> этого окна имеет значение <codeph>false</codeph> или если метод вызывается после закрытия данного окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Разворачивает данное окно.  
      <p>
      Вызов метода <codeph>maximize()</codeph> отправляет событие <codeph>displayStateChange</codeph> и, когда применимо, события <codeph>move</codeph> и <codeph>resize</codeph>. Системный хром отправляет событие <codeph>displayStateChanging</codeph>, которое можно отменить, когда пользователь инициирует команду «развернуть». При желании можно внедрить такое поведение логики разворачивания.
      </p>
      <p>
      Метод <codeph>maximize()</codeph> выполняется асинхронно. Чтобы узнать о завершении изменения состояния, прослушивайте событие <codeph>displayStateChange</codeph>.
      </p>
      <p>Если окно уже развернуто, никакие действия не предпринимаются и события не отправляются.</p>
      
      <p><b>Примечания.</b></p> 
      <ul>
      <li>В операционных системах, таких как Mac OS X, где разворачивание окна не предотвращает изменения размеров, вызов метода <codeph>maximize()</codeph> приведет к увеличению окна на весь экран, но не предотвратит последующего изменения его размеров. Изменение размеров развернутого окна также приведет к восстановлению состояния отображения.</li>
      
      <li>В некоторых операционных системах, таких как Mac OS X, а также в некоторых диспетчерах окон Linux, при разворачивании окна его ширина и высота не превышают значения, заданные свойством <codeph>maxSize</codeph>. В других операционных системах окно будет развернуто на весь экран, даже если размеры экрана превышают значения свойства <codeph>maxSize</codeph>.</li>
      
      <li>Некоторые диспетчеры окон Linux запрещают разворачивание служебных окон.</li>
      
      </ul>
      
      </apiDesc><example conref="examples\NativeWindow.maximize.1.as">  
 Следующий пример показывает, как можно разрешить отмену операции разворачивания:  
<codeblock>
public function maximizeWindow(nativeWin:NativeWindow):Boolean{
  if(nativeWin.displayState != NativeWindowDisplayState.MAXIMIZED){
    var beforeState:String = nativeWin.displayState;
    var afterState:String = NativeWindowDisplayState.MAXIMIZED;
    var displayStateEvent:NativeWindowDisplayStateEvent = 
        new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
    nativeWin.dispatchEvent(displayStateEvent);
    if(!displayStateEvent.isDefaultPrevented()){
        nativeWin.maximize();
        return true;
    } else {
      return false;
    }
  }
  return false;
}
</codeblock></example><example conref="examples\NativeWindow.maximize.2.as">  
 Следующий пример показывает, как можно разрешить отмену операции разворачивания окна из процедуры JavaScript, выполняющейся в объекте HTMLLoader (или окне HTML):  
<codeblock>
function maximizeWindow(nativeWin){
    if(nativeWin.displayState != air.NativeWindowDisplayState.MAXIMIZED){
        var beforeState = nativeWin.displayState;
        var afterState = air.NativeWindowDisplayState.MAXIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.maximize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:minimize"><apiName>minimize</apiName><shortdesc>
      Сворачивает данное окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если свойство <codeph>minimizable</codeph> этого окна имеет значение <codeph>false</codeph> или если метод вызывается после закрытия данного окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Сворачивает данное окно. 
      <p>
      Вызов метода <codeph>minimize()</codeph> отправляет событие <codeph>displayStateChange</codeph> и, когда применимо, события <codeph>move</codeph> и <codeph>resize</codeph>. Тогда как системный хром отправляет событие <codeph>displayStateChanging</codeph>, которое можно отменить, когда пользователь инициирует команду «свернуть», этого не происходит при вызове <codeph>minimize()</codeph> напрямую. При желании для логики сворачивания можно внедрить такое поведение.
      </p>
      
      <p>Метод <codeph>minimize()</codeph> выполняется асинхронно. Чтобы узнать о завершении изменения состояния, прослушивайте событие <codeph>displayStateChange</codeph>. Если окно уже свернуто, никакие действия не предпринимаются и события не отправляются.</p>
      
      <p>Некоторые диспетчеры окон Linux запрещают сворачивание служебных окон.</p>
      
	  </apiDesc><example conref="examples\NativeWindow.minimize.1.as"> Следующий пример показывает, как разрешить отмену вызова метода <codeph>minimize()</codeph> путем отправки события <codeph>displayStateChanging</codeph>: 
<codeblock>
public function minimizeWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.MINIMIZED){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.minimize.2.as"> Следующий пример показывает, как разрешить отмену вызова метода <codeph>minimize()</codeph> в сценарии JavaScript, выполняющемся в объекте HTMLLoader (или окне HTML): 
<codeblock> 
function minimizeWindow(){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.MINIMIZED){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:notifyUser"><apiName>notifyUser</apiName><shortdesc>
      Запускает через операционную систему визуальный сигнал о том, что произошло событие, представляющее интерес.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, описывающая срочность оповещения.   
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      Запускает через операционную систему визуальный сигнал о том, что произошло событие, представляющее интерес.
      
      <p>Когда <codeph>NativeWindow.supportsNotification</codeph> имеет значение <codeph>true</codeph>, визуальный сигнал соответствует правилам собственной операционной системы. Например, в Windows мигает значок на панели задач.</p>
      
      <p>Параметр <codeph>type</codeph> определяет интенсивность сигнала. Константы для разрешенных значений определены в классе NotificationType и могут быть следующими:</p>
      <ul>
      <li><codeph>NotificationType.INFORMATIONAL</codeph></li>
      <li><codeph>NotificationType.CRITICAL</codeph></li>
      </ul>
      <p>Сигналы для оповещений информативного характера могут быть кратковременными, а сигналы для критических оповещений продолжаются, пока пользователь не активирует данное окно. Не все диспетчеры окон Linux поддерживают два уровня оповещений. Для таких диспетчеров результат вызова метода <codeph>notifyUser()</codeph> будет одинаковым независимо от заданного параметра.</p>
      
      <p><b>Примечание.</b> Вызов метода <codeph>notifyUser()</codeph>, когда <codeph>NativeWindow.supportsNotification</codeph> имеет значение <codeph>false</codeph> разрешен, но не выполняет никаких действий.</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInBackOf"><apiName>orderInBackOf</apiName><shortdesc>
      Отправляет это окно непосредственно под заданное окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если это окно успешно выведено под остальные; <codeph>false</codeph>, если окно невидимо или свернуто.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>Окно приложения.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Отправляет это окно непосредственно под заданное окно.
      
      <p>Не активирует это окно или приложение и не переводит его в фокус. Порядок свернутых или скрытых окон (<codeph>visible</codeph> имеет значение <codeph>false</codeph>) изменить нельзя.</p>
      
      <p>Некоторые диспетчеры окон Linux запрещают размещение служебных окон под обычными окнами.</p>
      
      </apiDesc><example conref="NativeWindow.orderInBackOf.1.as"> Следующие примеры показывают, как поместить окно позади другого окна с помощью ссылок на экземпляры NativeWindow:
<codeblock>
windowBehind.orderInBackOf(windowFront);
</codeblock></example><example conref="NativeWindow.orderInBackOf.2.as"> С помощью ссылок на экранные объекты в рабочих областях окна:
<codeblock>
displayObjBehind.stage.nativeWindow.orderInBackOf(displayObjectFront.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInBackOf.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader (или корневом окне HTML), со ссылками на два объекта окна JavaScript:
<codeblock>
jsWindowObjBehind.nativeWindow.orderInBackOf(jsWindowObjFront.nativeWindow);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInFrontOf"><apiName>orderInFrontOf</apiName><shortdesc>
      Помещает данное окно непосредственно над заданным окном.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если это окно успешно выведено поверх остальных; <codeph>false</codeph>, если окно невидимо или свернуто.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>Окно приложения.
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Помещает данное окно непосредственно над заданным окном.
      
      <p>Не активирует это окно или приложение и не переводит его в фокус. Порядок свернутых или скрытых окон (<codeph>visible</codeph> имеет значение <codeph>false</codeph>) изменить нельзя.</p>
      
      <p>Некоторые диспетчеры окон Linux не позволяют обычным окнам располагаться поверх служебных окон.</p>
      
      </apiDesc><example conref="NativeWindow.orderInFrontOf.1.as"> Следующие примеры показывают, как поместить окно поверх другого окна с помощью ссылок на экземпляры NativeWindow:
<codeblock>
windowFront.orderInFrontOf(windowBehind);
</codeblock></example><example conref="NativeWindow.orderInFrontOf.2.as"> С помощью ссылок на экранные объекты в рабочих областях окна:
<codeblock>
displayObjFront.stage.nativeWindow.orderInFrontOf(displayObjectBehind.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInFrontOf.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader (или корневом окне HTML), со ссылками на два объекта окна JavaScript:
<codeblock>
jsWindowObjFront.nativeWindow.orderInFrontOf(jsWindowObjBehind.nativeWindow);

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToBack"><apiName>orderToBack</apiName><shortdesc>
      Отправляет это окно под все остальные видимые окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если это окно успешно выведено под остальные; <codeph>false</codeph>, если окно невидимо или свернуто.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Отправляет это окно под все остальные видимые окна.
      
      <p>Не активирует это окно или приложение и не переводит его в фокус. Порядок свернутых или скрытых окон (<codeph>visible</codeph> имеет значение <codeph>false</codeph>) изменить нельзя.</p>
      
      <p>Если <codeph>alwaysInFront</codeph> имеет значение <codeph>true</codeph>, то вызов этого метода не переместит это окно поверх тех окон, для которых<codeph>alwaysInFront</codeph> имеет значение <codeph>false</codeph>.</p>
      
      <p>Некоторые диспетчеры окон Linux запрещают размещение служебных окон под обычными окнами.</p>
      
      </apiDesc><example conref="NativeWindow.orderToBack.1.as"> Следующие примеры показывают, как поместить окно позади всех других окон приложения (с той же настройкой <codeph>alwaysInFront</codeph>):
<codeblock>
windowObj.orderToBack();

</codeblock></example><example conref="NativeWindow.orderToBack.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObj.stage.nativeWindow.orderToBack();
</codeblock></example><example conref="NativeWindow.orderToBack.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.orderToBack();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToFront"><apiName>orderToFront</apiName><shortdesc>
      Помещает это окно поверх всех остальных видимых окон.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если это окно успешно помещено поверх остальных; <codeph>false</codeph>, если окно невидимо или свернуто.
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Выводит это окно поверх всех остальных видимых окон. 
      
      <p>Не активирует это окно или приложение и не переводит его в фокус. Порядок свернутых или скрытых окон (<codeph>visible</codeph> имеет значение <codeph>false</codeph>) изменить нельзя.</p>
       
      <p>Если <codeph>alwaysInFront</codeph> имеет значение <codeph>false</codeph>, то вызов этого метода не переместит это окно поверх тех окон, для которых<codeph>alwaysInFront</codeph> имеет значение <codeph>true</codeph>.</p>
      
      <p>Некоторые диспетчеры окон Linux не позволяют обычным окнам располагаться поверх служебных окон.</p> 
      
      </apiDesc><example conref="NativeWindow.orderToFront.1.as"> В следующих примерах показано, как поместить окно поверх всех других окон приложения (с той же настройкой <codeph>alwaysInFront</codeph>):
<codeblock>
windowObj.orderToFront();

</codeblock></example><example conref="NativeWindow.orderToFront.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObj.stage.nativeWindow.orderToFront();
</codeblock></example><example conref="NativeWindow.orderToFront.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.orderToFront();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:restore"><apiName>restore</apiName><shortdesc>
      Восстанавливает окно из свернутого или развернутого состояния.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если метод вызван после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      Восстанавливает окно из свернутого или развернутого состояния.
      
      <p>Вызов метода <codeph>restore()</codeph> отправляет событие <codeph>displayStateChange</codeph> и, когда применимо, события <codeph>move</codeph> и <codeph>resize</codeph>. Системный хром отправляет событие <codeph>displayStateChanging</codeph>, которое можно отменить, когда пользователь инициирует команду «восстановить». При необходимости можно внедрить такое поведение логики разворачивания.
      </p>
      
      <p>Если окно уже находится в состоянии <codeph>NativeWindowDisplayState.NORMAL</codeph>, никакие действия не выполняются и события не отправляются.</p>
      
      <p>
      Чтобы узнать о завершении изменения состояния, прослушивайте событие <codeph>displayStateChange</codeph>, которое отправляется на всех платформах.
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.restore.1.as">  
 Следующий пример показывает, как можно разрешить отмену операции восстановления: 
<codeblock>
public function restoreWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.NORMAL){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.NORMAL;
        var displayStateChangingEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateChangingEvent);
        if(!displayStateChangingEvent.isDefaultPrevented()){
            nativeWin.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.restore.2.as"> Следующий пример показывает, как можно разрешить отмену операции восстановления окна из процедуры JavaScript, выполняющейся в объекте HTMLLoader (или окне HTML): 
<codeblock>
function restoreWindow(nativeWin){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.NORMAL){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.NORMAL;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:startMove"><apiName>startMove</apiName><shortdesc>
      Запускает перемещение данного окна системой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если метод вызван после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, если перемещение инициировано успешно, и <codeph>false</codeph>, если окно развернуто.
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      Запускает перемещение данного окна системой.
      <p>
      При вызове из события <codeph>mouseDown</codeph> этот метод начинает последовательность перемещения мышью, которая продолжается до получения события <codeph>mouseUp</codeph>. 
      </p>
      <p>
      При вызове из другого кода этот метод начинает последовательность перемещения с помощью клавиатуры или мыши в соответствии с последовательностью, используемой по умолчанию в операционной системе.
      </p>
      
      <p>Во время выполнения последовательности будет отправляться серия событий по ходу перемещения окна. Для каждого добавочного перемещения отправляется событие <codeph>moving</codeph>, а затем, если <codeph>moving</codeph> не отменяется, обновляется местоположение окна и отправляется событие <codeph>move</codeph>. Если событие <codeph>moving</codeph> отменено, последовательность перемещения немедленно прекращается.</p>
      
      </apiDesc><example conref="NativeWindow.startMove.1.as"> Следующий пример показывает, как переместить окно в ответ на событие <codeph>mouseDown</codeph>:
<codeblock>
var initOpts:NativeWindowInitOptions = new NativeWindowInitOptions();
var win:NativeWindow = new NativeWindow(initOpts);
win.activate();
win.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);

function mouseDownHandler(event:MouseEvent):void
{
    win.startMove();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:startResize"><apiName>startResize</apiName><shortdesc>
      Запускает изменение размеров данного окна под управлением системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если метод вызван после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc><codeph>true</codeph>, если изменение размеров инициировано успешно, и <codeph>false</codeph>, если окно развернуто.

      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>edgeOrCorner</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Константа класса NativeWindowResize, задающая край или угол окна для изменения размеров. Ниже приводятся допустимые значения.
      
      <p>
      <adobetable class="innertable">
          
           
           
           
           
            
            
            
            
            
           
      <tgroup cols="3"><thead><row><entry>Значение</entry><entry>Выравнивание по вертикали</entry><entry>Выравнивание по горизонтали</entry></row></thead><tbody><row><entry><codeph>NativeWindowResize.TOP</codeph></entry>
           <entry>Верхний край</entry>
           <entry>Центр</entry>
           </row><row><entry><codeph>NativeWindowResize.BOTTOM</codeph></entry>
           <entry>Нижний край</entry>
           <entry>Центр</entry>
           </row><row><entry><codeph>NativeWindowResize.LEFT</codeph></entry>
           <entry>Центр</entry>
           <entry>Слева</entry>
           </row><row><entry><codeph>NativeWindowResize.RIGHT</codeph></entry>
           <entry>Центр</entry>
           <entry>Справа</entry>
           </row><row><entry><codeph>NativeWindowResize.TOP_LEFT</codeph></entry>
            <entry>Верхний край</entry>
            <entry>Слева</entry>
            </row><row><entry><codeph>NativeWindowResize.TOP_RIGHT</codeph></entry>
            <entry>Верхний край</entry>
            <entry>Справа</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_LEFT</codeph></entry>
            <entry>Нижний край</entry>
            <entry>Слева</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_RIGHT</codeph></entry>
            <entry>Нижний край</entry>
            <entry>Справа</entry>
            </row><row><entry><codeph>NativeWindowResize.NONE</codeph></entry>
            <entry>Нижний край</entry>
            <entry>Справа</entry>
            </row></tbody></tgroup></adobetable>
      </p>
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      Запускает изменение размеров данного окна под управлением системы.
      <p>
      При вызове из обработчика события <codeph>mouseDown</codeph> этот метод начинает последовательность изменения размеров мышью, которая продолжается до получения события <codeph>mouseUp</codeph>.  
      </p>
      <p>
      При вызове из другого кода этот метод начинает последовательность изменения размеров с помощью клавиатуры или мыши в соответствии с последовательностью, используемой по умолчанию в операционной системе.
      </p>
      <p>Во время выполнения последовательности будет отправляться серия событий по ходу изменения размеров окна. Для каждого добавочного изменения отправляется событие <codeph>resizing</codeph>, а затем, если <codeph>resizing</codeph> не отменяется, обновляется местоположение окна и отправляется событие <codeph>resize</codeph>. Если событие <codeph>resizing</codeph> отменено, последовательность перемещения немедленно прекращается.</p>
      
      </apiDesc><example conref="NativeWindow.startResize.1.as"> Следующий пример показывает, как изменить размер окна в ответ на событие <codeph>mouseDown</codeph>:
<codeblock>
stage.addEventListener(MouseEvent.MOUSE_DOWN, onResizeCommand);

function onResizeCommand(event:MouseEvent):void
{
    var win:NativeWindow = event.target.nativeWindow;
    var resizeFrom:String = "";
    if (event.stageY &lt; win.height * .33)
    {
        resizeFrom = NativeWindowResize.TOP;
    }
    else if (event.stageY > win.height * .66)
    {
        resizeFrom = NativeWindowResize.BOTTOM;
    }
    if (event.stageX &lt; win.width * .33)
    {
        resizeFrom += NativeWindowResize.LEFT;
    }
    else if (event.stageX > win.width * .66)
    {
        resizeFrom += NativeWindowResize.RIGHT;
    }
    win.startResize(resizeFrom);    
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeWindow:active:get"><apiName>active</apiName><shortdesc>
      Указывает, принадлежит ли окно активному приложению.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Указывает, принадлежит ли окно активному приложению.
      
      <p>Используйте метод <codeph>activate()</codeph> для активации окна.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate"><linktext>flash.display.NativeWindow.activate</linktext></link><link href="flash.desktop.xml#NativeApplication/activate"><linktext>flash.desktop.NativeApplication.activate</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:alwaysInFront:get"><apiName>alwaysInFront</apiName><shortdesc>
      Определяет, будет ли это окно всегда отображаться поверх всех остальных окон (включая окна других приложений).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Определяет, будет ли это окно всегда отображаться поверх всех остальных окон (включая окна других приложений).
      
      <p>В системном порядке отображения есть две группы окон. Окна группы <codeph>alwaysInFront</codeph> всегда отображаются поверх всех остальных окон. Порядок глубины окон одной группы определяется в обычном порядке. Другими словами, активация окна будет выводить его поверх остальных окон в той же группе.</p>
      
      <p>Изменение значения <codeph>alwaysInFront</codeph> с <codeph>false</codeph> на <codeph>true</codeph> выведет окно поверх всех остальных окон. При изменении значения с <codeph>true</codeph> на <codeph>false</codeph> отправит окно под окна, всегда отображаемые поверх остальных, но над окнами другой группы. При настройке текущего значения свойства, порядок глубины окон не изменится.</p>
      
      <p>Свойству <codeph>alwaysInFront</codeph> следует задавать значение <codeph>true</codeph> лишь в редких случаях, так как окна с таким параметром будут отображаться над окнами других приложений, даже если такое приложение активно.</p>
      
      <p>Некоторые диспетчеры окон Linux всегда отображают служебные окна поверх обычных окон.</p>
      
      <p><b>Примечание.</b> В ОС Mac<sup>®</sup> OS X задание для <codeph>alwaysInFront</codeph> значения <codeph>true</codeph> не будет иметь силы, если свойству <codeph>displayState</codeph> рабочей области окна задано значение <codeph>fullScreen</codeph> или <codeph>fullScreenInteractive</codeph>. В Linux полноэкранные окна, свойство <codeph>alwaysInFront</codeph> которых имеет значение <codeph>true</codeph>, всегда отображаются поверх других окон, свойство <codeph>alwaysInFront</codeph> которых имеет значение <codeph>true</codeph>.</p> 
      
      </apiDesc><example conref="NativeWindow.alwaysInFront.1.as"> В следующих примерах окно принудительно отображается поверх всех других окон (которые не отображаются поверх других окон в принудительном порядке):
<codeblock>
windowObj.alwaysInFront = true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObject.stage.nativeWindow.alwaysInFront=true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.alwaysInFront = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:bounds:set"><apiName>bounds</apiName><shortdesc>
      Размер и местоположение окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>Если прямоугольник имеет значение null или содержит недопустимые значения.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство bounds получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Размер и местоположение окна.  
      <p>
      Размеры окна включают системный хром. Размеры рабочей области окна равны размерам окна минус размер системного хрома. Изменение ширины и высоты окна приведет к изменению свойств <codeph>stageWidth</codeph> и <codeph>stageHeight</codeph> рабочей области. И наоборот, изменение размеров рабочей области приведет к изменению размеров окна.
      </p>
      <p>В корневом HTML-окне свойства <codeph>outerWidth</codeph> и <codeph>outerHeigth</codeph> эквиваленты свойствам <codeph>height</codeph> и <codeph>width</codeph> окна. Свойства <codeph>innerWidth</codeph> и <codeph>innerHeight</codeph> равны свойствам <codeph>stage.stageWidth</codeph> и <codeph>stage.stageHeight</codeph> минус толщина автоматических полос прокрутки, отображаемых в окне.</p>
      <p>
      Событие <codeph>resize</codeph> отправляется при каждом изменении ширины или высоты окна. Подобным образом, событие <codeph>move</codeph> отправляется при каждом изменении исходной точки (х, у) окна. В Mac OS и Windows при задании свойства <codeph>bounds</codeph> напрямую событие <codeph>moving</codeph> или <codeph>resizing</codeph> не отправляется. Однако на Linux NativeWindow <i>передает</i> события <codeph>moving</codeph> и <codeph>resizing</codeph>, если установлено свойство <codeph>bounds</codeph>. 
      </p>
      <p>
      Задание свойства <codeph>bounds</codeph> окна эквивалентно заданию его свойств <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> и <codeph>height</codeph>. Подобным образом, задание индивидуальных размеров равносильно заданию свойства <codeph>bounds</codeph>. При установке всех измерений одновременно с помощью свойства <codeph>bounds</codeph>, отправляется меньшее число событий. 
      </p>
      <p>Соблюдение порядка, в котором были заданы отдельные размеры, не гарантируется. В диспетчерах окон Linux, запрещающих выход границ окна за пределы области рабочего стола, изменение отдельных свойств может быть заблокировано, даже если результатом применения всех изменений свойств будет окно допустимого размера.</p>
      
      <p>Если указанные ширина или высота не достигают минимальных значений или превышают максимальные значения, то для окна устанавливаются значения, наиболее близкие к разрешенным. Минимальные и максимальные ширина и высота определяются следующими факторами:</p>
      
      <ul>
      
      	<li>Свойства <codeph>minSize</codeph> и <codeph>maxSize</codeph> объекта NativeWindow</li>
      	<li>Максимально допустимое и минимально допустимые значения для операционной системы, являющиеся значениями <codeph>NativeWindow.systemMinSize</codeph> и <codeph>NativeWindow.systemMaxSize</codeph>.</li>
      	<li>Максимальное значение ширины и высоты окна в Adobe AIR, равное 2880 пикселям.</li>
      	<li>Минимальные ширина и высота, требуемые для отображаемого системного хрома.</li>
      
      </ul>
      
	  </apiDesc><example conref="examples\NativeWindow.bounds.1.as"> Следующие примеры задают границы окна с помощью ссылки на объект NativeWindow:
<codeblock>
windowObj.bounds = new Rectangle(200, 200, 1000, 800);
</codeblock></example><example conref="examples\NativeWindow.bounds.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObject.stage.nativeWindow.bounds = new Rectangle(20, 20, 800, 600);
</codeblock></example><example conref="examples\NativeWindow.bounds.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.bounds = new air.Rectangle(20, 20, 800, 600);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:closed:get"><apiName>closed</apiName><shortdesc>
      Указывает, закрыто ли окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      Указывает, закрыто ли окно.  
      
      <p>Попытка получить следующие свойства закрытого окна приведет к появлению ошибки о недопустимой операции:</p>
      <ul> 
      <li><codeph>title</codeph></li>
      <li><codeph>bounds</codeph></li>
      <li><codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph>, <codeph>height</codeph></li>
      <li><codeph>displayState</codeph></li>
      <li><codeph>visible</codeph></li>
      </ul>
      <p>Подобным образом, попытка вызвать следующие методы для закрытого окна приведет к появлению ошибки о недопустимой операции:</p>
      <ul>
      <li><codeph>minimize()</codeph></li>
      <li><codeph>maximize()</codeph></li>
      <li><codeph>restore()</codeph></li>
      <li><codeph>startResize()</codeph></li>
      <li><codeph>startMove()</codeph></li>
      </ul>
      
      </apiDesc><example conref="NativeWindow.closed.1.as"> В следующем примере показано, как получить свойство <codeph>closed</codeph> окна:
<codeblock>
var isWindowClosed:Boolean = windowObj.closed;
</codeblock></example><example conref="NativeWindow.closed.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
var isWindowClosed:Boolean = displayObject.stage.nativeWindow.closed;
</codeblock></example><example conref="NativeWindow.closed.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
var isWindowClosed = window.nativeWindow.closed;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:displayState:get"><apiName>displayState</apiName><shortdesc>
     Состояние отображения окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Если свойство <codeph>displayState</codeph> получено после закрытия окна.
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Состояние отображения окна.
     <p>
     Константы для возможных значений определяются классом NativeWindowDisplayState: 
     </p>
     <ul>
     <li><codeph>NativeWindowDisplayState.NORMAL</codeph></li>
     <li><codeph>NativeWindowDisplayState.MINIMIZED</codeph></li>
     <li><codeph>NativeWindowDisplayState.MAXIMIZED</codeph></li>
     </ul> 
     
     </apiDesc><example conref="examples\NativeWindow.displayState.1.as"> Следующий пример показывает, как получить текущее состояние отображения окна с помощью ссылки на объект окна:
<codeblock>
var state:String = windowObj.displayState;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:height:get"><apiName>height</apiName><shortdesc>
      Высота окна в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Если задано недопустимое значение или <codeph>null</codeph>.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Высота окна в пикселях.
      
      <p>Размеры окна включают примененный к нему системный хром. Высота доступной для использования области экрана внутри окна указывается в свойстве <codeph>Stage.stageHeight</codeph>.</p>
      
      <p>Изменение свойства окна <codeph>height</codeph> равносильно изменению высоты через свойство <codeph>bounds</codeph>.</p>
      
      <p>Если указанная высота не достигает минимально допустимого значения или превышает максимально допустимое значение, то значение высоты окна устанавливается на ближайшее разрешенное значение. Минимальная и максимальная высота определяется следующими факторами:</p>
      
      <ul>
      
      	<li>Свойства <codeph>minSize.x</codeph> и <codeph>maxSize.x</codeph> объекта NativeWindow</li>
      	<li>Минимально допустимое и максимально допустимое значения для операционный системы, являющиеся значениями <codeph>NativeWindow.systemMinSize.x</codeph> и <codeph>NativeWindow.systemMaxSize.x</codeph>.</li>
      	<li>Максимальная высота окна в Adobe AIR, составляющая 2880 пикселей.</li>
      
      </ul>
      
      <p>В Linux установка свойства <codeph>height</codeph> является асинхронной операцией.</p>
     
      <p>
      Чтобы узнать о завершении изменения высоты, прослушивайте событие <codeph>resize</codeph>, отправляемое на всех платформах.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageHeight"><linktext>flash.display.Stage.stageHeight</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maxSize:get"><apiName>maxSize</apiName><shortdesc>
      Максимальный размер окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Если назначенный размер находится за рамками минимального и максимального размеров окна. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если размер запрещен для текущих полномочий содержимого.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если размер имеет значение <codeph>null</codeph> или содержит недопустимые значения.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство <codeph>maxSize</codeph> получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Максимальный размер окна.  
      
      <p>Предельный размер определяется как координаты объекта Point. Свойство точки <codeph>x</codeph> соответствует ширине окна, а свойство <codeph>y</codeph> – высоте окна.</p>
      
      <p>
      Ограничение <codeph>maxSize</codeph> применяется для операций изменения размера окна, вызываемых как посредством кода <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph>, так и посредством операционной системы.
      </p>
      <p>
      При задании <codeph>maxSize</codeph> границы окна изменятся, если текущие границы больше нового максимального размера.
      </p>
      
      <p>Если указанные ширина и высота превышают максимально допустимые значения, устанавливается ближайшее разрешенное значение. Максимальные ширина и высота определяются следующими факторами:</p>
      
      <ul>
      
      	<li>Максимально допустимое значение для операционной системы, являющееся значением <codeph>NativeWindow.systemMaxSize</codeph>.</li>
      	<li>Максимальное значение ширины и высоты окна в Adobe AIR, равное 2880 пикселям.</li>
      
      </ul>
      
      <p>
      <b>Примечание.</b> В некоторых операционных системах, таких как Mac OS X, окно разворачивается до значения, заданного свойством <codeph>maxSize</codeph>, даже если оно будет меньше экрана операционной системы. Несмотря на это окно будет находиться в состоянии развернутого отображения.
      </p>
      
      </apiDesc><example conref="NativeWindow.maxSize.1.as"> Следующие примеры показывают, как задать максимальный допустимый размер окна.
<codeblock>
windowObj.maxSize = new Point(1040,920);
</codeblock></example><example conref="NativeWindow.maxSize.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObject.stage.nativeWindow.maxSize = new Point(800,600);
</codeblock></example><example conref="NativeWindow.maxSize.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.maxSize = new air.Point(960,960);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maximizable:get"><apiName>maximizable</apiName><shortdesc>
	 Сообщает параметр maximizable, использованный для создания данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Сообщает параметр <codeph>maximizable</codeph>, использованный для создания данного окна.
	  
	 <p>Параметр <codeph>maximizable</codeph> нельзя изменить после создания окна.</p>
	 
	 <p>Не все диспетчеры окон Linux воспринимают настройку свойства <codeph>maximizable</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/maximizable"><linktext>flash.display.NativeWindowInitOptions.maximizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:menu:get"><apiName>menu</apiName><shortdesc>
      Собственное меню для данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
      Собственное меню для данного окна. 
      
      <p>Когда объект NativeMenu назначается свойству окна <codeph>menu</codeph>, для этого окна будет отображаться собственное меню, если <codeph>NativeWindow.supportsMenu</codeph> имеет значение <codeph>true</codeph> и если свойство <codeph>systemChrome</codeph> не имеет значение <codeph>NativeWindowSystemChrome.NONE</codeph>.</p>
      
      <p><b>Примечание.</b> Назначить меню для окна, когда <codeph>NativeWindow.supportsMenu</codeph> имеет значение <codeph>false</codeph> или когда свойство окна <codeph>systemChrome</codeph> имеет значение <codeph>NativeWindowSystemChrome.NONE</codeph> можно, но эта настройка не будет иметь силы. Свойство <codeph>NativeWindow.supportsMenu</codeph> позволяет определить, поддерживает ли операционная система оконные меню. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minSize:get"><apiName>minSize</apiName><shortdesc>
      Минимальный размер окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Если назначенный размер находится за рамками минимального и максимального размеров окна. 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если размер запрещен для текущих полномочий содержимого.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если размер имеет значение <codeph>null</codeph> или содержит недопустимые значения.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство <codeph>minSize</codeph> получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Минимальный размер окна. 
       
      <p>Предельный размер определяется как координаты объекта Point. Свойство точки <codeph>x</codeph> соответствует ширине окна, а свойство <codeph>y</codeph> – высоте окна.</p>
      <p>
      При задании <codeph>minSize</codeph> границы окна изменятся, если текущие границы меньше нового минимального размера.
      </p>
      <p>
      Ограничение <codeph>minSize</codeph> применяется для операций изменения размера окна, вызываемых как посредством кода <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph>, так и посредством операционной системы.
      </p>
      <p>
      <b>Примечание.</b> Ширина и высота любого отображаемого системного хрома может препятствовать уменьшению окна до заданного минимального размера. 
      </p>
      
      </apiDesc><example conref="NativeWindow.minSize.1.as"> Следующие примеры показывают, как задать минимальный допустимый размер окна:
<codeblock>
windowObj.minSize = new Point(200,80);
</codeblock></example><example conref="NativeWindow.minSize.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObject.stage.nativeWindow.minSize = new Point(120,60);
</codeblock></example><example conref="NativeWindow.minSize.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.minSize = new air.Point(80,60);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minimizable:get"><apiName>minimizable</apiName><shortdesc>
	 Сообщает параметр minimizable, использованный для создания данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Сообщает параметр <codeph>minimizable</codeph>, использованный для создания данного окна.
	 
	 <p>Параметр <codeph>minimizable</codeph> нельзя изменить после создания окна.</p>
	 
	 <p>Не все диспетчеры окон Linux воспринимают настройку свойства <codeph>minimizable</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/minimizable"><linktext>flash.display.NativeWindowInitOptions.minimizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:resizable:get"><apiName>resizable</apiName><shortdesc>
	 Сообщает параметр resizable для изменения размера, использованный для создания данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Сообщает параметр <codeph>resizable</codeph> для изменения размера, использованный для создания данного окна.
	 
	 <p>Параметр <codeph>resizable</codeph> нельзя изменить после создания окна.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:stage:get"><apiName>stage</apiName><shortdesc>
      Объект Stage для данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
      Объект Stage для данного окна. <ph platform="actionscript">Объект Stage является корневым объектом в архитектуре экранных объектов, используемой в SWF-содержимом на базе ActionScript 3.0.</ph>
      
      <p>
      Рабочая область находится в корне списка отображения для данного окна. Добавьте визуальные экранные объекты в окно путем добавления в рабочую область или в другой объект, уже находящийся в списке отображения данного рабочей области. Размеры рабочей области соответствуют размеру области клиента окна, когда оно использует системный хром. Если же системный хром не используется, размеры рабочей области равны размерам окна.
      </p>
      
      <p platform="javascript">Класс HTMLLoader, который позволяет отобразить содержимое HTML, является единственным листом в дереве списка отображения. Экранные объекты ActionScript могут находится выше или ниже HTMLLoader в порядке рисования, но не между визуальными элементами, отображаемыми классом HTMLLoader.</p>
      
      </apiDesc><example conref="NativeWindow.stage.1.as"> В следующем примере показано, как задать свойства рабочей области для экземпляра NativeWindow:
<codeblock>
import flash.display.StageAlign;

windowObj.stage.align = StageAlign.TOP_LEFT;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage"><linktext>flash.display.Stage</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
      Указывает, поддерживает ли AIR меню собственного окна в текущей операционной системе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Указывает, поддерживает ли AIR меню собственного окна в текущей операционной системе.
      
      <p>Когда <codeph>NativeWindow.supportsMenu</codeph> имеет значение <codeph>true</codeph>, для окна будет отображаться собственное меню, когда свойству окна <codeph>menu</codeph> назначается объект NativeMenu (если свойство окна <codeph>systemChrome</codeph> имеет значение <codeph>NativeWindowSystemChrome.NONE</codeph>). Свойство <codeph>NativeWindow.supportsMenu</codeph> позволяет определить, поддерживает ли операционная система оконные меню. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
      
      <p><b>Примечание.</b> Назначить меню для окна, когда <codeph>NativeWindow.supportsMenu</codeph> имеет значение <codeph>false</codeph> или когда свойство окна <codeph>systemChrome</codeph> имеет значение <codeph>NativeWindowSystemChrome.NONE</codeph> можно, но эта настройка не будет иметь силы.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsMenu"><linktext>flash.desktop.NativeApplication.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsNotification:get"><apiName>supportsNotification</apiName><shortdesc> 
      Указывает, поддерживает ли AIR сигналы оповещения окна в текущей операционной системе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Указывает, поддерживает ли AIR сигналы оповещения окна в текущей операционной системе.
      
      <p>Когда <codeph>NativeWindow.supportsNotification</codeph> имеет значение <codeph>true</codeph>, вызов метода окна <codeph>notifyUser()</codeph> приведет к отображению визуального сигнала о том, что произошло интересующее пользователя событие. Визуальный сигнал будет соответствовать правилам установленной операционной системы. Например, в Windows<sup>®</sup> мигает значок на панели задач.</p>
      
      <p><b>Примечание.</b> Вызов метода <codeph>notifyUser()</codeph>, когда <codeph>NativeWindow.supportsNotification</codeph> имеет значение <codeph>false</codeph> разрешен, но не выполняет никаких действий.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsTransparency:get"><apiName>supportsTransparency</apiName><shortdesc> 
      Указывает, поддерживает ли AIR собственные окна с прозрачными пикселями.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      Указывает, поддерживает ли AIR собственные окна с прозрачными пикселями.
      
      <p>Если <codeph>NativeWindow.supportsTransparency</codeph> имеет значение <codeph>true</codeph>, прозрачность пикселей собственного окна будет поддерживаться при условии, что свойство окна <codeph>transparent</codeph> имеет значение <codeph>true</codeph>. Непрозрачность всех пикселей будет установлена на значение 1, если <codeph>NativeWindow.supportsTransparency</codeph> имеет значение <codeph>false</codeph>, независимо от значения свойства окна <codeph>transparent</codeph>. Полностью прозрачные пиксели будут отображаться черным, если <codeph>NativeWindow.supportsTransparency</codeph> имеет значение <codeph>false</codeph>. Свойство <codeph>NativeWindow.supportsTransparency</codeph> позволяет определить, поддерживает ли операционная система прозрачность. Использование других средств (например, <codeph>Capabilities.os</codeph>) для определения поддержки может привести к ошибкам программирования (если некоторые целевые операционные системы не рассматриваются).</p>
      
      <p><b>Примечание.</b> Значение данного свойства может измениться во время работы приложения в зависимости от предпочтений пользователя, заданных для операционной системы.</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/transparent"><linktext>flash.display.NativeWindow.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
	 Сообщает параметр системного хрома, использованный для создания данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Сообщает параметр системного хрома, использованный для создания данного окна.
	 
	 <p>Значения, возвращенные <codeph>NativeWindow.systemChrome</codeph>, будут входить в число констант, определенных в классе NativeWindowSystemChrome.</p>
	 
	 <p>Параметр системного хрома нельзя изменить после создания окна.</p>
	 
	 </apiDesc><example conref="NativeWindow.systemChrome.1.as"> В следующем примере показано, как получить тип системного хрома для окна:
<codeblock>
var sysChromeType:String = windowObj.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
var sysChromeType:String = displayObject.stage.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
var sysChromeType = window.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.4.as"> Следующий пример показывает, как изменить видимый системный хром и параметры отображения прозрачных областей путем создания нового окна и перемещения всех нижестоящих экранных объектов в это новое окно:
<codeblock>
import flash.display.NativeWindow;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowInitOptions;

public function deChromeWindow(oldWindow:NativeWindow):NativeWindow{
    if(oldWindow.systemChrome != NativeWindowSystemChrome.NONE){
        var newOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
        newOptions.systemChrome = NativeWindowSystemChrome.NONE;
        newOptions.transparent = true;
        
        var newWindow:NativeWindow = new NativeWindow(newOptions);
        newWindow.stage.stageWidth = oldWindow.stage.stageWidth;
        newWindow.stage.stageHeight = oldWindow.stage.stageHeight;
        newWindow.stage.align = oldWindow.stage.align;
        newWindow.stage.scaleMode = oldWindow.stage.scaleMode;
        
        for(var i:int = 0; i &lt; oldWindow.stage.numChildren; i++){
            newWindow.stage.addChild(oldWindow.stage.getChildAt(i));
        }
        newWindow.activate();
        oldWindow.close();
        
        return newWindow;
    }
    return oldWindow;
}

</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/systemChrome"><linktext>flash.display.NativeWindowInitOptions.systemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemMaxSize:get"><apiName>systemMaxSize</apiName><shortdesc>
	 Наибольший размер окна, разрешенный операционной системой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 Наибольший размер окна, разрешенный операционной системой.
	 
      <p>Предельный размер определяется как координаты объекта Point. Свойство точки <codeph>x</codeph> соответствует ширине окна, а свойство <codeph>y</codeph> – высоте окна.</p>
      
      <p>В дополнение к границе размера, определяемой операционной системой, AIR имеет предельное значение размера окна, составляющее 2880 на 2880 пикселей. И для приложения может быть задано предельное значение с помощью свойства <codeph>maxSize</codeph> объекта NativeWindow.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:systemMinSize:get"><apiName>systemMinSize</apiName><shortdesc>
	 Наименьший размер окна, разрешенный операционной системой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 Наименьший размер окна, разрешенный операционной системой.
	 
      <p>Предельный размер определяется как координаты объекта Point. Свойство точки <codeph>x</codeph> соответствует ширине окна, а свойство <codeph>y</codeph> – высоте окна.</p>
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:title:set"><apiName>title</apiName><shortdesc>
      Заголовок окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Low-privilege apps will probably have a string appended to all of their title strings
      
      </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Если свойство получено после закрытия окна.
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Заголовок окна.  
      <p>
      Если заголовок отображается, он появится в системном хроме для окна, а также в других системных местоположениях (например, на панели задач).
      </p>
      
      </apiDesc><example conref="NativeWindow.title.1.as"> Следующий пример задает заголовок для объекта окна:
<codeblock>
windowObj.title = "Window Title";
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Сообщает параметр прозрачности, использованный для создания данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Сообщает параметр прозрачности, использованный для создания данного окна.
	 
     <p>Свойство <codeph>transparent</codeph> нельзя изменить после создания окна. Прозрачность влияет на внешний вид окна и на поведение мыши в его границах. В Windows и Mac OS X окно не может выполнить захват событий мыши, если альфа-значение пикселя ниже определенного порогового значения, которое в зависимости от операционной системы варьируется между 0,06 и 0,01. В Linux окно будет захватывать события мыши в абсолютно прозрачных областях, тем самым предотвращая доступ пользователей к другим окнам и элементам рабочего стола.</p>
     
     <p><b>Примечание.</b> Прозрачность окон поддерживается не всегда. Если конфигурация операционной системы пользователя не поддерживает прозрачность, окно будет создано непрозрачным. Окна, которые должны были быть прозрачными, отображаются с черным фоном. С помощью свойства <codeph>NativeWindow.supportsTransparency</codeph> можно определить, поддерживается ли прозрачность окна.</p>
	 
	 </apiDesc><example conref="NativeWindow.transparent.1.as"/><example conref="NativeWindow.transparent.2.as"/><example conref="NativeWindow.transparent.3.as"/></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/transparent"><linktext>flash.display.NativeWindowInitOptions.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:type:get"><apiName>type</apiName><shortdesc>
	 Сообщает параметр type окна, использованный для создания данного окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Сообщает параметр <codeph>type</codeph> окна, использованный для создания данного окна.
	 
	 <p>Значения, возвращенные <codeph>NativeWindow.type</codeph>, будут входить в число констант, определенных в классе NativeWindowType.</p>
	 
	 <p>Параметр <codeph>type</codeph> нельзя изменить после создания окна.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/type"><linktext>flash.display.NativeWindowInitOptions.type</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:visible:get"><apiName>visible</apiName><shortdesc> 
      Указывает, видимо ли окно.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>При попытке задать значение <codeph>false</codeph> без необходимых полномочий.
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
      Указывает, видимо ли окно.  
      
      <p>
      Невидимое окно не отображается на рабочем столе, но все его свойства и методы остаются действительными.
      </p> 
      <p>
      По умолчанию <codeph>visible</codeph> имеет значение <codeph>false</codeph>. Чтобы отобразить окно, нужно задать <codeph>visible</codeph> значение <codeph>true</codeph> или вызвать метод<codeph>NativeWindow.activate()</codeph>.
      </p>
      <p>
      <b>Примечание.</b> В Mac OS X параметр <codeph>visible=false</codeph> для свернутого окна не приведет к удалению значка окна с панели рабочего стола. Если потом пользователь щелкнет значок на панели, окно снова станет видимым и отобразится на рабочем столе.
      </p>
      
      </apiDesc><example conref="NativeWindow.visible.1.as"> В следующем примере показано, как получить свойство <codeph>visible</codeph> окна:
<codeblock>
windowObj.visible = true;
</codeblock></example><example conref="NativeWindow.visible.2.as"> С помощью ссылки на экранный объект в рабочей области окна:
<codeblock>
displayObj.stage.nativeWindow.visible = true;
</codeblock></example><example conref="NativeWindow.visible.3.as"> Из процедуры JavaScript, выполняющейся в объекте HTMLLoader окна (или корневом окне HTML):
<codeblock>
window.nativeWindow.visible = true;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate()"><linktext>activate()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:width:get"><apiName>width</apiName><shortdesc>
      Ширина окна в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Если задано недопустимое значение или <codeph>null</codeph>.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Ширина окна в пикселях.
      
      <p>Отображаемые размеры собственного окна включают примененный к нему системный хром. Ширина доступной для использования области экрана внутри окна указывается в свойстве <codeph>Stage.stageWidth</codeph>.</p>
      
      <p>Изменение свойства окна <codeph>width</codeph> равносильно изменению ширины через свойство <codeph>bounds</codeph>.</p>
      
      <p>Если указанная ширина не достигает минимально допустимого значения или превышает максимально допустимое значение, то устанавливается ближайший разрешенный размер окна. Максимальная и минимальная ширина определяются следующими факторами:</p>
      
      <ul>
      
      	<li>Свойства <codeph>minSize.y</codeph> и <codeph>maxSize.y</codeph> объекта NativeWindow</li>
      	<li>Минимально допустимое и максимально допустимое значения для операционный системы, являющиеся значениями <codeph>NativeWindow.systemMinSize.y</codeph> и <codeph>NativeWindow.systemMaxSize.y</codeph>.</li>
      	<li>Максимальная ширина окна в Adobe AIR, составляющая 2880 пикселей.</li>
      
      </ul>
      
      <p>В Linux установка свойства <codeph>width</codeph> является асинхронной операцией.</p>
      
      <p>
      Чтобы узнать о завершении изменения ширины, прослушивайте событие <codeph>resize</codeph>, отправляемое на всех платформах.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageWidth"><linktext>flash.display.Stage.stageWidth</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:x:get"><apiName>x</apiName><shortdesc>
      Координата горизонтальной оси верхнего левого угла этого окна относительно исходной точки рабочего стола операционной системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Если задано недопустимое значение или <codeph>null</codeph>.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Координата горизонтальной оси верхнего левого угла этого окна относительно исходной точки рабочего стола операционной системы.
      
      <p>В системах с несколькими мониторами <codeph>x</codeph> может иметь отрицательное значение. Если вы сохраняете значение, допустим для возвращения окна в предыдущее местоположение, необходимо всегда следить, чтобы во время восстановления окно находилось в пригодном для использования местоположении. Изменение разрешения экрана или организации мониторов может привести к тому, что окно попадет за пределы области экрана. Используйте класс Screen для получения информации о геометрии рабочего стола.</p> 
      
      <p>Изменение свойства окна <codeph>x</codeph> равносильно изменению местоположения через свойство <codeph>bounds</codeph>.</p>
      
      <p>В Linux установка свойства <codeph>x</codeph> является асинхронной операцией.</p>
      
      <p>
      Чтобы узнать о завершении изменения позиции, прослушивайте событие <codeph>displayStateChange</codeph>.
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:y:get"><apiName>y</apiName><shortdesc>
      Координата вертикальной оси верхнего левого угла этого окна относительно верхнего левого угла рабочего стола операционной системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Если задано недопустимое значение или <codeph>null</codeph>.
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если свойство получено после закрытия окна.
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      Координата вертикальной оси верхнего левого угла этого окна относительно верхнего левого угла рабочего стола операционной системы.
      
      <p>В системах с несколькими мониторами <codeph>y</codeph> может иметь отрицательное значение. Если вы сохраняете значение, допустим для возвращения окна в предыдущее местоположение, необходимо всегда следить, чтобы во время восстановления окно находилось в пригодном для использования местоположении. Изменение разрешения экрана или организации мониторов может привести к тому, что окно попадет за пределы области экрана. Используйте класс Screen для получения информации о геометрии рабочего стола.</p> 
      
      <p>Изменение свойства окна <codeph>y</codeph> равносильно изменению местоположения через свойство <codeph>bounds</codeph>.</p>
      
      <p>В Linux установка свойства <codeph>y</codeph> является асинхронной операцией.</p>
       
      <p>
      Чтобы узнать о завершении изменения позиции, прослушивайте событие <codeph>move</codeph>, отправляемое на всех платформах.
      </p>
     
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Stage"><apiName>Stage</apiName><shortdesc>
 Класс Stage представляет основную область рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Stage представляет основную область рисования. 
 
 <p platform="actionscript">Для SWF-содержимого, выполняемого в обозревателе (в Flash<sup>®</sup> Player), Stage представляет собой всю область отображения содержимого Flash. Для содержимого, выполняемого в приложении AIR, каждый объект NativeWindow имеет соответствующий объект Stage.</p>
 
 <p platform="actionscript">К объекту Stage нет глобального доступа. Доступ к нему осуществляется через свойство <codeph>stage</codeph> экземпляра DisplayObject.</p> 
 
 <p platform="actionscript">Класс Stage имеет несколько классов предшественников – DisplayObjectContainer, InteractiveObject, DisplayObject и EventDispatcher –от которых он наследует свойства и методы. Многие из этих свойств и методов либо неприменимы к объектам Stage, либо требуют проверки безопасности, когда используются для объекта Stage. Свойства и методы, требующие проверки безопасности, записаны как часть класса Stage.</p>
 
 <p platform="actionscript">Следующие наследуемые свойства также неприменимы к объектам Stage. При попытке задать для них значения выдается ошибка IllegalOperationError. Эти свойства можно считывать, но, так как для них невозможно задать значение, они всегда имеют значения по умолчанию.</p>
 
 <ul platform="actionscript">
 <li><codeph>accessibilityProperties</codeph></li>
 <li><codeph>alpha</codeph></li>
 <li><codeph>blendMode</codeph></li>
 <li><codeph>cacheAsBitmap</codeph></li>
 <li><codeph>contextMenu</codeph></li>
 <li><codeph>filters</codeph></li>
 <li><codeph>focusRect</codeph></li>
 <li><codeph>loaderInfo</codeph></li>
 <li><codeph>mask</codeph></li>
 <li><codeph>mouseEnabled</codeph></li>
 <li><codeph>name</codeph></li>
 <li><codeph>opaqueBackground</codeph></li>
 <li><codeph>вращение</codeph></li>
 <li><codeph>scale9Grid</codeph></li>
 <li><codeph>scaleX</codeph></li>
 <li><codeph>scaleY</codeph></li>
 <li><codeph>scrollRect</codeph></li>
 <li><codeph>tabEnabled</codeph></li>
 <li><codeph>tabIndex</codeph></li>
 <li><codeph>transform</codeph></li>
 <li><codeph>visible</codeph></li>
 <li><codeph>x</codeph></li>
 <li><codeph>y</codeph></li>
 </ul>
 
 <p>Некоторые события, которые, казалось бы, являются частью класса Stage, например <codeph>enterFrame</codeph>, <codeph>exitFrame</codeph>, <codeph>frameConstructed</codeph> и <codeph>render</codeph>, не могут быть событиями класса Stage, так как существование ссылки на объект Stage не гарантируется в каждой ситуации, в которой используются данные события. Так как эти события не могут быть отправлены объектом Stage, они отправляются каждым экземпляром DisplayObject, что означает, что вы можете добавить прослушиватель событий к любому экземпляру DisplayObject для прослушивания этих событий. Такие события, являющиеся частью класса DisplayObject, называются многоадресными и отличаются от событий, нацеленных на конкретный экземпляр DisplayObject. Два других многоадресных события, <codeph>activate</codeph> и <codeph>deactivate</codeph>, принадлежат к суперклассу DisplayObject, EventDispatcher. Поведение событий <codeph>activate</codeph> и <codeph>deactivate</codeph> схоже с поведением многоадресных событий DisplayObject, за исключением того, что эти два события отправляются не только всеми экземплярами DisplayObject, но также всеми экземплярами EventDispatcher и экземплярами других подклассов EventDispatcher. Дополнительную информацию о многоадресных событиях см. в описании класса DisplayObject.</p>
 
 </apiDesc><example conref="examples\StageExample.as"> В следующем примере используется класс <codeph>StageExample</codeph> для отправки событий при активации или изменении размера рабочей области. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>Сначала конструктор класса настраивает приложение Flash для фиксации, независимо от размера окна проигрывателя Flash Player, а затем добавляет два прослушивателя событий с методами <codeph>activateHandler()</codeph> и <codeph>resizeHandler()</codeph>.</li>
 
  <li>Метод <codeph>activateHandler()</codeph> запускается при щелчке левой кнопкой мыши.</li>
 
  <li>Метод <codeph>resizeHandler()</codeph> запускается при изменении размеров рабочего стола.</li>
 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.Event;

    public class StageExample extends Sprite {

        public function StageExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.addEventListener(Event.ACTIVATE, activateHandler);
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function activateHandler(event:Event):void {
            trace("activateHandler: " + event);
        }

        private function resizeHandler(event:Event):void {
            trace("resizeHandler: " + event);
            trace("stageWidth: " + stage.stageWidth + " stageHeight: " + stage.stageHeight);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><adobeApiEvent id="flash.display:Stage_flash.events.FullScreenEvent.FULL_SCREEN_fullScreen"><apiName>fullScreen</apiName><shortdesc>
 Отправляется, когда объект Stage переходит в полноэкранный режим или выходит из этого режима.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FullScreenEvent.FULL_SCREEN</apiEventType><adobeApiEventClassifier>flash.events.FullScreenEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда объект Stage переходит в полноэкранный режим или выходит из этого режима. Изменение в полноэкранном режиме можно инициировать через ActionScript, либо при нажатии комбинации клавиш пользователем, либо если текущий фокус покидает окно, находящееся в полноэкранном режиме.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 Отправляется, когда свойство scaleMode объекта Stage установлено в значение StageScaleMode.NO_SCALE и изменяется размер SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда свойство <codeph>scaleMode</codeph> объекта Stage установлено в значение <codeph>StageScaleMode.NO_SCALE</codeph> и изменяется размер SWF-файла. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.MOUSE_LEAVE_mouseLeave"><apiName>mouseLeave</apiName><shortdesc>
 Отправляется объектом Stage, когда курсор мыши покидает рабочую область.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.MOUSE_LEAVE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется объектом Stage, когда курсор мыши покидает рабочую область. Если кнопка мыши нажата, событие не отправляется.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:Stage:addChild"><apiName>addChild</apiName><shortdesc>
	 
     Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>addChild()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Экземпляр DisplayObject, передаваемый в параметр <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экземпляр DisplayObject для добавления в качестве нижестоящего элемента экземпляра DisplayObjectContainer.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
     Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer. Нижестоящий элемент добавляется перед (сверху) всеми остальными нижестоящими элементами в данном экземпляре DisplayObjectContainer. (Чтобы добавить нижестоящий элемент в конкретную позицию в индексе, используйте метод <codeph>addChildAt()</codeph>.)
     
	 <p>При добавлении нижестоящего объекта, уже имеющего отличный от других контейнер объекта отображения в качестве вышестоящего элемента, объект удаляется из списка нижестоящих элементов другого контейнера объекта отображения. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 
	 Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>addChildAt()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Экземпляр DisplayObject, передаваемый в параметр <codeph>child</codeph>.
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Экземпляр DisplayObject для добавления в качестве нижестоящего элемента экземпляра DisplayObjectContainer.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса для добавления нижестоящего элемента. При указании занятой в настоящее время позиции индекса существующий в данной позиции нижестоящий объект и все вышестоящие позиции перемещаются по списку на одну позицию вверх. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Добавляет экземпляр нижестоящего элемента DisplayObject к экземпляру DisplayObjectContainer. Нижестоящий элемент добавляется к указанной позиции индекса. Индекс 0 представляет собой заднюю (нижнюю) часть списка отображения для объекта DisplayObjectContainer.
	 
	 <p>Так, в следующем примере представлено три объекта отображения с метками а, b и c в позициях индекса 0, 1 и 2 соответственно.</p>
	 
	 <p><adobeimage alt="b над c над a" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>При добавлении нижестоящего объекта, уже имеющего отличный от других контейнер объекта отображения в качестве вышестоящего элемента, объект удаляется из списка нижестоящих элементов другого контейнера объекта отображения. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	 
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>addEventListener</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этой ситуации владелец объекта Stage должен предоставить разрешение домену вызывающего файла путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция прослушивателя, обрабатывающая событие. Эта функция должна принимать объект Event в качестве единственного параметра и не должна что-либо возвращать <ph platform="actionscript">, как показано в примере:</ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Эта функция может иметь любое имя.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Этот параметр применяется для отображения объектов в архитектуре списка отображения ActionScript 3.0, используемой в SWF-содержимом. </ph> <ph platform="actionscript">Определяет, работает ли прослушиватель в фазе захвата или в целевой фазе и в фазе восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>true</codeph>, прослушиватель обрабатывает событие только во время фазы захвата, но не во время целевой фазы или фазы восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>false</codeph>, то прослушиватель обрабатывает событие только в целевой фазе или фазе восходящей цепочки. Чтобы прослушивать событие во всех трех фазах, необходимо вызвать <codeph>addEventListener()</codeph> дважды: один раз с <codeph>useCapture</codeph> в значении <codeph>true</codeph>, а другой – с <codeph>useCapture</codeph> в значении <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Уровень приоритета прослушивателя событий. Приоритет определяется 32-разрядным целым числом со знаком. Чем больше число, тем выше приоритет. Все прослушиватели событий с приоритетом <i>n</i> обрабатываются перед прослушивателями с приоритетом <i>n</i>-1. Прослушиватели с одинаковым приоритетом обрабатываются в порядке их добавления. Значение приоритета по умолчанию равно 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли ссылка на прослушивателя «сильной» или «слабой». «Сильная» ссылка (по умолчанию) предотвращает удаление прослушивателя сборщиком мусора. «Слабая» ссылка позволяет удалить прослушиватель. <p>Функции элементов уровня класса не подлежат удалению в качестве мусора, вследствие чего можно установить <codeph>useWeakReference</codeph> равным <codeph>true</codeph> для функций элементов уровня класса, не подвергая их возможности подобного удаления. Если свойству <codeph>useWeakReference</codeph> присвоить значение <codeph>true</codeph> для прослушивателя, который является вложенной внутренней функцией, то функция будет очищена и перестанет быть постоянной. При создании ссылок на внутреннюю функцию (возможно сохранение в другой переменной) она не будет собираться в качестве мусора и останется устойчивой.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии. <ph platform="actionscript">Можно регистрировать прослушиватели событий в любом узле из списка отображения для каждого типа события, фазы и приоритета.</ph>
	
	<p platform="javascript">В коде JavaScript в среде выполнения AIR этот метод используется в целях регистрации прослушивателей событий, определенных интерфейсами AIR API. Для других событий JavaScript (таких как событие <codeph>onload</codeph> объекта <codeph>body</codeph> в модели DOM) можно использовать те же стандартные способы обработки событий, что и для содержимого в обозревателе.</p>
	
	<p>После успешной регистрации прослушивателя событий невозможно изменить его приоритет путем дополнительных вызовов <codeph>addEventListener()</codeph>. Чтобы изменить приоритет прослушивателя, необходимо сначала вызвать метод <codeph>removeListener()</codeph>. Затем можно снова зарегистрировать прослушиватель с новым приоритетом. </p>
	
	<p>Следует учесть, что после регистрации прослушивателя последующие вызовы метода <codeph>addEventListener()</codeph> с другим значением свойства <codeph>type</codeph> или <codeph>useCapture</codeph> приводят к регистрации другого прослушивателя. <ph platform="actionscript">Например, прослушиватель, изначально зарегистрированный со значением <codeph>useCapture</codeph>, равным <codeph>true</codeph>, прослушивает только во время фазы захвата. Если вызвать метод <codeph>addEventListener()</codeph> еще раз с тем же объектом прослушивателя, но со свойством <codeph>useCapture</codeph> в значении <codeph>false</codeph>, то будет два прослушивателя: один – прослушивающий в фазе захвата, а другой – в целевой фазе и фазе восходящей цепочки. </ph>
	</p>
	
	<p platform="actionscript">Невозможно зарегистрировать прослушиватель события только для целевой фазы или для фазы восходящей цепочки. Эти фазы соединены при регистрации, поскольку восходящая цепочка применяется только к предшественникам целевого узла.</p>
	
	<p>Если прослушиватель событий больше не нужен, его можно удалить, вызвав метод <codeph>removeEventListener()</codeph>, иначе могут возникнуть проблемы с памятью. Прослушиватели событий не удаляются из памяти автоматически, так как сборщик мусора не удаляет прослушиватель, пока существует объект, отправляющий соответствующее событие (если параметру <codeph>useWeakReference</codeph> не задано значение <codeph>true</codeph>).</p>
		
	<p>Копирование экземпляра EventDispatcher не приводит к копированию прослушивателей событий, присоединенных к нему. (Если для вновь создаваемого узла требуется прослушиватель событий, его необходимо присоединить после создания узла.) При этом при перемещении экземпляра EventDispatcher присоединенные к нему прослушиватели событий перемещаются вместе с ним.</p>
	
	
	<p platform="actionscript">Если прослушиватель регистрируется для узла в тот момент, когда на нем обрабатывается событие, то в текущей фазе он не запускается, однако может запуститься в следующей фазе потока события, например в фазе восходящей цепочки.</p>
	
	<p platform="actionscript">Прослушиватель событий, удаленный из узла во время обработки события на этом узле, будет запускаться текущими операциями. После удаления прослушиватель событий больше не вызывается (если не будет снова зарегистрирован для дальнейшей обработки). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	 Устанавливает фокус клавиатуры на интерактивном объекте, указанном в objectToFocus. Направление фокуса устанавливается параметром direction.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если фокус не может быть установлен на цели, или тип направления неверный.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>objectToFocus</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>Объект, на который следует переместить фокус или <codeph>null</codeph>, чтобы убрать фокус с любого элемента в рабочей области.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>direction</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Направление, по которому фокусируется <codeph>objectToFocus</codeph>. Подходящие значения перечислены в виде констант в классе FocusDirection.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Присваивает фокус клавиатуры интерактивному объекту и указывает направление, откуда этот фокус поступает.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Устанавливает фокус клавиатуры на интерактивном объекте, указанном в <codeph>objectToFocus</codeph>. Направление фокуса устанавливается параметром <codeph>direction</codeph>. 
	 
	 <p>Направление фокуса должно задаваться приложением (или средой приложения). Как такового встроенного принципа расположения интерактивных объектов не существует, однако, для их упорядочения можно использовать ряд доступных свойств. Например, можно сортировать интерактивные объекты в рабочей области по их положению в списке отображения. Вызов метода <codeph>assignFocus()</codeph> идентичен параметру свойства <codeph>Stage.focus</codeph> с дополнительной возможностью указывать направление, откуда этот фокус поступает.</p>
	 
	 <p>После получения фокуса <codeph>objectToFocus</codeph> отправляет событие <codeph>focusIn</codeph>. Свойство <codeph>direction</codeph> объекта FocusEvent сообщает о настройке параметра <codeph>direction</codeph>.</p>
	 
	 <p>При назначении объекта HTMLLoader параметру <codeph>objectToFocus</codeph> объект HTMLLoader выбирает подходящий объект для передачи фокуса в HTML DOM, принимая во внимание значение параметра <codeph>direction</codeph>. При использовании <codeph>FocusDirection.BOTTOM</codeph> фокус передается объекту в HTML DOM, который находится в конце списка отображения. При использовании <codeph>FocusDirection.TOP</codeph> фокус передается объекту в HTML DOM, который находится в начале списка отображения. При использовании <codeph>NONE</codeph> объект HTMLLoader получает фокус, а его текущий элемент с фокусом не меняется.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link><link href="flash.display.xml#FocusDirection"><linktext>flash.display.FocusDirection</linktext></link><link href="flash.events.xml#FocusEvent"><linktext>flash.events.FocusEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
	 
	Посылает событие в поток событий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>dispatchEvent()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение <codeph>true</codeph> в случае успешной передачи события. Значение <codeph>false</codeph> указывает на ошибку или на то, что для события был вызван метод <codeph>preventDefault()</codeph>.
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>Объект события, передаваемый в поток событий. Если осуществляется повторная отправка события, автоматически создается его клон. После отправки события нельзя изменить его свойство <codeph>target</codeph>, поэтому необходимо создать новую копию события, чтобы обеспечить правильное выполнение повторной отправки.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Посылает событие в поток событий. Целью события является объект EventDispatcher, для которого вызывается метод <codeph>dispatchEvent()</codeph>.
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
	 
	Проверяет, имеет ли объект EventDispatcher прослушиватели, зарегистрированные для определенного типа события.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>hasEventListener()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение <codeph>true</codeph>, если прослушиватель указанного типа зарегистрирован; в противном случае – <codeph>false</codeph>.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Проверяет, имеет ли объект EventDispatcher прослушиватели, зарегистрированные для определенного типа события. Это позволяет определить, где объект EventDispatcher изменил обработку типа события в иерархии потока событий. Чтобы определить, запускает ли на самом деле определенный тип событий прослушиватель, используйте метод <codeph>willTrigger()</codeph>.
	
	<p>Различие между <codeph>hasEventListener()</codeph> и <codeph>willTrigger()</codeph> заключается в том, что <codeph>hasEventListener()</codeph> анализирует только объект, к которому он принадлежит, тогда как <codeph>willTrigger()</codeph> – весь поток событий для события, указанного параметром <codeph>type</codeph>. <ph platform="javascript">Поток событий применяется к списку отображения ActionScript 3.0, используемому в содержимом SWF.</ph>
	</p>
	
	<p>Когда метод <codeph>hasEventListener()</codeph> вызывается из объекта LoaderInfo, учитываются только те прослушиватели, к которым есть доступ у вызывающего объекта.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:invalidate"><apiName>invalidate</apiName><shortdesc>
     Вызов метода invalidate() предписывает проигрывателю Flash Player оповестить экранные объекты о следующей возможности визуализации списка отображения (например, когда точка воспроизведения приближается к новому кадру).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Предписывает проигрывателю Flash Player обновить свойства экранных объектов при следующей возможности обновить Stage.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Вызов метода <codeph>invalidate()</codeph> предписывает проигрывателю Flash Player оповестить экранные объекты о следующей возможности визуализации списка отображения (например, когда точка воспроизведения приближается к новому кадру). После вызова метода<codeph>invalidate()</codeph> при дальнейшей визуализации списка отображения проигрыватель Flash Player отправляет событие <codeph>render</codeph> каждому экранному объекту, зарегистрированному для прослушивания события <codeph>render</codeph>. Метод <codeph>invalidate()</codeph> необходимо вызвать каждый раз, когда нужно, чтобы проигрыватель Flash Player отправлял события <codeph>render</codeph>. 
     
     <p>Событие <codeph>render</codeph> дает возможность вносить изменения в список отображения непосредственно перед его визуализацией. Это позволяет откладывать обновления списка отображения до самой последней возможности. Это может увеличить производительность путем предотвращения ненужных обновлений экрана.</p>
     
     <p>Событие <codeph>render</codeph> отправляется только тем экранным объектам, которые находятся в том же защищенном домене, что и код, вызывающий метод <codeph>stage.invalidate()</codeph>, или экранным объектам из защищенного домена, которому предоставлено разрешение через метод <codeph>Security.allowDomain()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/RENDER"><linktext>flash.events.Event.RENDER</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:isFocusInaccessible"><apiName>isFocusInaccessible</apiName><shortdesc>
	 Определяет, должно ли свойство Stage.focus возвращать значение null по соображениям безопасности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>, если объект в фокусе принадлежит к изолированной программной среде безопасности, к которой у SWF-файла нет доступа.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Определяет, должно ли свойство <codeph>Stage.focus</codeph> возвращать значение <codeph>null</codeph> по соображениям безопасности.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Определяет, должно ли свойство <codeph>Stage.focus</codeph> возвращать значение <codeph>null</codeph> по соображениям безопасности. Другими словами, <codeph>isFocusInaccessible</codeph> имеет значение <codeph>true</codeph>, если объект в фокусе принадлежит к изолированной программной среде безопасности, к которой у SWF-файла нет доступа.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 
	 Удаляет нижестоящий DisplayObject из заданной позиции индекса в списке нижестоящих элементов DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>removeChildAt()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец данного объекта может предоставить разрешение домену вызывающего файла путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Удаленный экземпляр DisplayObject.
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Удаляемый индекс нижестоящего элемента DisplayObject.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Удаляет нижестоящий элемент DisplayObject из заданной позиции <codeph>индекса</codeph> в списке нижестоящих элементов DisplayObjectContainer. Свойство <codeph>parent</codeph> удаленного нижестоящего элемента получает значение <codeph>null</codeph>, а сам объект очищается, если нет других ссылок на нижестоящие элементы. Позиции индекса экранных объектов, расположенных над нижестоящим элементом в DisplayObjectContainer уменьшаются на 1.
	 
	 <p>Сборщик мусора перераспределяет неиспользуемый объем памяти. Когда на переменную или объект больше нет ссылок или он хранится в другом месте, сборщик мусора очищает и утилизирует память, которую он занимал, при условии отсутствия ссылок</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	 
	Изменяет положение существующего нижестоящего элемента в DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>addChildIndex()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>Нижестоящий экземпляр DisplayObject, для которого необходимо изменить номер индекса.
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Полученный в результате номер индекса для нижестоящего экранного объекта <codeph>child</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Изменяет положение существующего нижестоящего элемента в DisplayObjectContainer. Это отражается на иерархическом представлении нижестоящих объектов. Так, в следующем примере показано три разных объекта с именами a, b и c в позициях индекса 0, 1 и 2 соответственно.
	
	<p><adobeimage alt="c над b над a" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>Когда используется метод <codeph>setChildIndex()</codeph> и указывается уже занятая позиция индекса, меняются только позиции между прежней и новой позицией экранного объекта. Все остальные остаются без изменения. Если потомок перемещается на более НИЗКУЮ позицию, позиции всех потомков между этими позициями станут на 1 ВЫШЕ. Если потомок перемещается на более ВЫСОКУЮ позицию, позиции всех потомков между этими позициями станут на 1 НИЖЕ. Например, если контейнер экранных объектов из предыдущего примера имеет имя <codeph>container</codeph>, можно поменять позициями экранные объекты с именами a и b, вызвав следующий код:</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>В результате этого объекты выстраиваются следующим образом:</p>
	
    <p><adobeimage alt="c над a над b" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 
	 Меняет местами (в порядке «от начала к концу») дочерние объекты, расположенные в двух заданных позициях индекса в списке потомков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>swapChildrenAt()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владельцы объекта могут предоставить разрешение домену вызывающего файла путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса первого нижестоящего объекта.
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Позиция индекса второго нижестоящего объекта.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Меняет местами (в порядке «от начала к концу») нижестоящие объекты, расположенные в двух заданных позициях индекса в списке потомков. Все остальные нижестоящие объекты в контейнере экранных объектов остаются на прежних позициях.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:willTrigger"><apiName>willTrigger</apiName><shortdesc>
	 
	Проверяет, зарегистрирован ли прослушиватель события для указанного типа события с данным объектом EventDispatcher или любым его предшественником.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>Вызов метода <codeph>willTrigger()</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение равно <codeph>true</codeph> при запуске прослушивателя указанного типа; в противном случае значение равно <codeph>false</codeph>.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	Проверяет, зарегистрирован ли прослушиватель события для указанного типа события с данным объектом EventDispatcher или любым его предшественником. Этот метод возвращает значение <codeph>true</codeph>, если прослушиватель события запускается в течение любой фазы потока событий, когда событие указанного типа передается объекту EventDispatcher или любому из его нижестоящих элементов.
	
	<p>Разница между методами <codeph>hasEventListener()</codeph> и <codeph>willTrigger()</codeph> заключается в том, что <codeph>hasEventListener()</codeph> просматривает только тот объект, которому принадлежит, а <codeph>willTrigger()</codeph> просматривает весь поток событий для события, указанного в параметре <codeph>type</codeph>. <ph platform="javascript">Поток событий применяется к списку отображения ActionScript 3.0, используемому в содержимом SWF.</ph></p>
	
	<p>Когда метод <codeph>willTrigger()</codeph> вызывается из объекта LoaderInfo, учитываются только те прослушиватели, к которым есть доступ у вызывающего объекта.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:Stage:align:get"><apiName>align</apiName><shortdesc>
	 Значение класса StageAlign, задающее выравнивание рабочей области в проигрывателе Flash Player или обозревателе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Значение класса StageAlign, задающее выравнивание рабочей области в проигрывателе Flash Player или обозревателе. Ниже приводятся допустимые значения.
	 
	 <p>
	 <adobetable class="innertable">
	 	
	 	 
	 	 
	 	 
	 	 
	 	  
	 	  
	 	  
	 	  
	 	 
	 <tgroup cols="3"><thead><row><entry>Значение</entry><entry>Выравнивание по вертикали</entry><entry>По горизонтали</entry></row></thead><tbody><row><entry><codeph>StageAlign.TOP</codeph></entry>
	 	 <entry>Верхний край</entry>
	 	 <entry>Центр</entry>
	 	 </row><row><entry><codeph>StageAlign.BOTTOM</codeph></entry>
	 	 <entry>Нижний край</entry>
	 	 <entry>Центр</entry>
	 	 </row><row><entry><codeph>StageAlign.LEFT</codeph></entry>
	 	 <entry>Центр</entry>
	 	 <entry>Слева</entry>
	 	 </row><row><entry><codeph>StageAlign.RIGHT</codeph></entry>
	 	 <entry>Центр</entry>
	 	 <entry>Справа</entry>
	 	 </row><row><entry><codeph>StageAlign.TOP_LEFT</codeph></entry>
	 	  <entry>Верхний край</entry>
	 	  <entry>Слева</entry>
	 	  </row><row><entry><codeph>StageAlign.TOP_RIGHT</codeph></entry>
	 	  <entry>Верхний край</entry>
	 	  <entry>Справа</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_LEFT</codeph></entry>
	 	  <entry>Нижний край</entry>
	 	  <entry>Слева</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_RIGHT</codeph></entry>
	 	  <entry>Нижний край</entry>
	 	  <entry>Справа</entry>
	 	  </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>Свойство <codeph>align</codeph> доступно только для объекта, находящегося в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageAlign"><linktext>flash.display.StageAlign</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrection:get"><apiName>colorCorrection</apiName><shortdesc>
 	 Управление цветокоррекцией Flash Player для отображений.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Попытка использования цветокоррекции монитора
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
 	 Управление цветокоррекцией Flash Player для отображений. Коррекция цвета срабатывает, только если главному монитору назначен действительный профиль ICC, задающий конкретные цветовые атрибуты устройства. По умолчанию в приложении Flash Player предпринимается попытка сопоставления цветокоррекции хоста (обычно обозревателя).
     
     <p>Используйте свойство <codeph>Stage.colorCorrectionSupport</codeph> для определения доступности коррекции цвета в текущей системе и состоянии по умолчанию. . Если коррекция цвета доступна, все цвета в рабочей области должны находиться в пространстве цветов sRGB, которое на данный момент является наиболее распространенным. Во время цветовой коррекции исходные профили устройств ввода игнорируются. Коррекция цветов на вводе не применяется. На цветовой профиль IIC главного монитора накладывается только вывод рабочей области.</p>
      
     <p>Обычно, активация управления цветом делает передачу цвета более точной, улучшает преобразование, позволяет точнее осуществлять цветопробу и эффективно отображать цвета независимо от программного материала. Имейте в виду, что управление цветом не делает преобразование идеальным, так как цветовые гаммы различных устройств расходятся между собой и отличаются от палитр исходных изображений. Подобным образом, при использовании управления цветом не исключается необходимость использовать пользовательские или измененные профили. Профили цветов зависят от обозревателей, операционных систем (ОС), расширений ОС, устройств вывода и поддержки со стороны приложения.</p>
     
     <p>При применении коррекции цвета производительность Flash Player снижается. В Flash Player коррекция цвета реализована в качестве документа стиля коррекции цвета, так как все ролики SWF являются документами со встроенными профилями sRGB. Используйте свойство <codeph>Stage.colorCorrectionSupport</codeph>, чтобы во время отображения документа SWF в цветовом пространстве проигрыватель Flash Player осуществлял процесс коррекции цвета наиболее подходящим образом. Flash Player может компенсировать различия между мониторами, но не устройствами ввода (видеотехникой/сканнером и так далее).
     </p>
     
 	 <p>Тремя возможными значениями являются строки с соответствующими константами в классе flash.display.ColorCorrection:</p>
 	  <ul><li><codeph>default</codeph>: использование такой же цветокоррекции, как в хост-системе.</li> 
 	 <li><codeph>on</codeph>: постоянное выполнение цветокоррекции.</li>
 	 <li><codeph>off</codeph>: запрет выполнения цветокоррекции.</li>
 	 </ul>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrection"><linktext>flash.display.ColorCorrection</linktext></link><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>colorCorrectionSupport</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrectionSupport:get"><apiName>colorCorrectionSupport</apiName><shortdesc>
      Определяет выполнение приложения Flash Player в операционной системе, поддерживающей цветокоррекцию, и возможность чтения и распознавания цветового профиля главного (основного) монитора в приложении Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>ColorCorrection
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
      Определяет выполнение приложения Flash Player в операционной системе, поддерживающей цветокоррекцию, и возможность чтения и распознавания цветового профиля главного (основного) монитора в приложении Flash Player. Это свойство также возвращает состояние цветокоррекции по умолчанию в хост-системе (обычно обозревателе). Текущими возвращаемыми значениями могут быть следующие:
 	  <p>Тремя возможными значениями являются строки с соответствующими константами в классе flash.display.ColorCorrectionSupport:</p>
 	   <ul><li><codeph>unsupported</codeph>: цветокоррекция недоступна.</li> 
 	  <li><codeph>defaultOn</codeph>: постоянное выполнение цветокоррекции.</li>
 	  <li><codeph>defaultOff</codeph>: запрет выполнения цветокоррекции.</li>
 	  </ul>      
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrectionSupport"><linktext>flash.display.ColorCorrectionSupport</linktext></link><link href="flash.display.xml#Stage/colorCorrection"><linktext>colorCorrection</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:displayState:get"><apiName>displayState</apiName><shortdesc>
	 Значение класса StageDisplayState, задающее состояние отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Вызов свойства <codeph>displayState</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>. При попытке настроить свойство <codeph>displayState</codeph>, когда отображается диалоговое окно параметров без отклика пользователя или если атрибуту <codeph>allowFullScreen</codeph> HTML-тегов <codeph>param</codeph> или <codeph>embed</codeph> не назначено значение <codeph>true</codeph>, появляется ошибка безопасности.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Значение класса StageDisplayState, задающее состояние отображения. Ниже приводятся допустимые значения. 
	 
	 <ul>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN</codeph> предписывает приложению AIR развернуть рабочую область на весь экран пользователя, отключив ввод с клавиатуры.</li>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> предписывает приложению AIR развернуть рабочую область на весь экран пользователя, не отключая ввод с клавиатуры. <ph platform="actionscript">(Недоступно для содержимого, выполняемого в Flash Player.)</ph></li>
	 
     <li><codeph>StageDisplayState.NORMAL</codeph> возвращает проигрыватель в стандартный режим отображения рабочей области.</li>
	 
	 </ul> 
	 
     <p platform="actionscript">Масштабирование видео в полноэкранном режиме определяется значением <codeph>scaleMode</codeph> (которое задается при помощи свойства <codeph>Stage.scaleMode</codeph> параметрами тегов <codeph>embed</codeph> SWF-файла в файле HTML). Если для свойства <codeph>scaleMode</codeph> задано значение <codeph>noScale</codeph> при переходе приложения в полноэкранный режим, свойства объекта Stage <codeph>width</codeph> и <codeph>height</codeph> обновляются, и объект Stage получает событие <codeph>resize</codeph>.</p>
     
     <p platform="actionscript">Следующие ограничения действуют для SWF-файлов, проигрываемых на странице HTML (не для тех, что выполняются в автономном проигрывателе Flash Player и не выполняются в среде AIR):</p>
     
     <ul platform="actionscript">
	 
	 <li>Для включения полноэкранного режима добавьте параметр <codeph>allowFullScreen</codeph> в теги <codeph>object</codeph> и <codeph>embed</codeph> страницы HTML, содержащей SWF-файл, задав для свойства <codeph>allowFullScreen</codeph> значение <codeph>"true"</codeph>, как показано в следующем примере:
	 
	 <codeblock>&lt;param name="allowFullScreen" value="true" />
	        ...
	 &lt;embed src="example.swf" allowFullScreen="true" ... ></codeblock>
	 
	 <p>Страница HTML может также выполнить сценарий для создания тегов внедрения SWF. Такой сценарий нужно изменить, задав нужные значения для свойства <codeph>allowFullScreen</codeph>. Страницы HTML, созданные при помощи Flash и Flex Builder, используют функцию <codeph>AC_FL_RunContent()</codeph> для вставки ссылок на SWF-файлы, поэтому необходимо добавить значения параметра <codeph>allowFullScreen</codeph>, как в следующем примере:</p>
	 
	 <codeblock>AC_FL_RunContent( ... "allowFullScreen", "true", ... )</codeblock></li>
	 
     <li>Полноэкранный режим запускается в ответ на щелчок мышью или нажатие кнопки пользователем; значение свойства <codeph>Stage.displayState</codeph> не может измениться без ввода пользователя. В приложении Flash Player ввод с клавиатуры в полноэкранном режиме ограничен. Допустимыми клавишами являются комбинации клавиш для отключения полноэкранного режима и клавиши, отличные от клавиш печати, такие как стрелки, пробел Shift и Tab. Для выключения полноэкранного режима используются следующие сочетания клавиш: Escape (Windows, Linux и Mac), Control+W (Windows), Command+W (Mac) и Alt+F4.
     <p>При переходе в полноэкранный режим поверх видео отображается диалоговое окно Flash Player, уведомляющее пользователей о том, что включен полноэкранный режим и можно нажать клавишу Escape для выхода из этого режима.</p></li>
     <li>Начиная с Flash Player 9.0.115.0, полноэкранный режим работает одинаково в безоконном и оконном режиме. Если вы установите «Режим окон» (<codeph>wmode</codeph> в HTML) на «Непрозрачный, без окна» (<codeph>opaque</codeph>) или «Прозрачный, без окна» (<codeph>transparent</codeph>), полноэкранный режим может быть включен, но окно всегда будет непрозрачным.</li> 
	 
     </ul>
     
 	 <p platform="actionscript">Данные ограничения <i>не</i> действуют для содержимого SWF, выполняемого в автономном Flash Player или в приложении AIR. AIR поддерживает интерактивный полноэкранный режим, который допускает ввод с клавиатуры.</p>  
	 
	 <p>На время воспроизведения ролика <ph platform="actionscript">AIR</ph> в полноэкранном режиме экранная заставка ОС и управление питанием отключаются и становятся активными только при выходе из полноэкранного режима или завершении воспроизведения ролика.</p>
 	 
	 <p>В Linux установка <codeph>displayState</codeph> на <codeph>StageDisplayState.FULL_SCREEN</codeph> или <codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> является асинхронной операцией.</p>
    
	 </apiDesc><example conref="examples\StageExample2.as"> В следующем примере создается интерактивная демонстрация того, как создавать полноэкранное представление путем модификации свойства <codeph>displayState</codeph>. <p><b>Примечание.</b> Вследствие ограничений, установленных из соображений безопасности, полноэкранный режим можно запускать только в определенных ситуациях, например, если пользователь щелкнул кнопку или нажал клавишу. При запуске в обозревателе свойство allowFullScreen должно иметь значение true.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Stage;
    import flash.events.*;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.media.Video;
    
    public class FullScreenExample extends Sprite
    {
        private var videoURL:String = "testVideo.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var video:Video;        
        
        public function FullScreenExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
            
            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK,toggleFullScreen);
        }        
        
        private function toggleFullScreen(event:MouseEvent):void {
            switch(stage.displayState) {
                case "normal":
                    stage.displayState = "fullScreen";    
                    break;
                case "fullScreen":
                default:
                    stage.displayState = "normal";    
                    break;
            }
        }    
        
        // Video related:
        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }
        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);

            video = new Video(stage.stageWidth,stage.stageHeight);
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:focus:get"><apiName>focus</apiName><shortdesc>
	 Интерактивный объект с фокусом клавиатуры, либо null, если фокус не установлен, а также если объект с фокусом принадлежит к изолированной программной среде безопасности, доступ к которой отсутствует у вызывающего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier><apiException><apiDesc>Выдает ошибку, если фокус нельзя перевести на цель.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Объект с фокусом, заданным с клавиатуры.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Интерактивный объект с фокусом клавиатуры, либо <codeph>null</codeph>, если фокус не установлен, а также если объект с фокусом принадлежит к изолированной программной среде безопасности, доступ к которой отсутствует у вызывающего объекта.
	 
	 </apiDesc><example conref="Stage.focus.as"> <codeph/>  
<codeblock>
var myTF:TextField = new TextField();
myTF.border =true;
myTF.type = TextFieldType.INPUT;

addChild(myTF);
stage.focus= myTF;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Stage:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Получает и задает частоту кадров монтажного стола.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Вызов метода <codeph>frameRate</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Получает и задает частоту кадров монтажного стола. Частота кадров определяется как число кадров в секунду. По умолчанию используется значение частоты кадров первого загруженного SWF-файла. Допустимые значения частоты кадров находятся в диапазоне 0,01 – 1000 кадров в секунду. 
	 
	 <p><codeph> Примечание.</codeph> Приложение может не воспринимать параметры высокой частоты, если целевая платформа недостаточно быстрая или если проигрыватель синхронизируется с интервалами пробела по вертикали дисплея (обычно это 60 Гц на ЖК-мониторах). В некоторых случаях целевая платформа также может выбирать более низкую максимальную частоту кадров, если ожидает высокий процент использования ЦП.</p>
	 
	 <p>При работе с содержимым в Adobe AIR настройка свойства <codeph>frameRate</codeph> одного объекта Stage приводит к изменению частоты кадров всех объектов Stage (используемых разными объектами NativeWindow).
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:fullScreenHeight:get"><apiName>fullScreenHeight</apiName><shortdesc>
  Возвращает ту высоту монитора, которая будет использована при мгновенном переходе в полноэкранный режим.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Возвращает ту высоту монитора, которая будет использована при мгновенном переходе в полноэкранный режим. Если в системе установлено несколько мониторов, то используется тот из них, на котором в данный момент отображается большая часть рабочей области.
  
  <p><b>Примечание.</b> Если у пользователя есть возможность перемещать обозреватель с одного монитора на другой между получением значения и переходом в полноэкранный режим, то это значение будет неправильным. Если значение получено в обработчике событий, задающем для <codeph>Stage.displayState</codeph> значение <codeph>StageDisplayState.FULL_SCREEN</codeph>, то значение будет правильным.</p>
  
  <p>Это высота монитора в пикселях, она равна высоте рабочей области, если для <codeph>Stage.align</codeph> задано значение <codeph>StageAlign.TOP_LEFT</codeph>, а для <codeph>Stage.scaleMode</codeph> –  <codeph>StageScaleMode.NO_SCALE</codeph>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> В данном примере создается зеленый прямоугольник размером с рабочую область, а поверх него накладывается красный квадрат, активируемый в качестве кнопки. Щелчок по красному квадрату запускает обработчик событий <codeph>enterFullScreen()</codeph>, который задает свойство <codeph>fullScreenSourceRect</codeph> и входит в полноэкранный режим. Чтобы задать свойство <codeph>fullScreenSourceRect</codeph>, обработчик событий начинает с местоположения и размеров красного квадрата. Затем он сравнивает соотношение сторон (ширина, разделенная на высоту) красного квадрата с соотношением сторон рабочей области, имеющего ширину и высоту полного экрана, чтобы развернуть прямоугольник (<codeph>fullScreenSourceRect</codeph>) в соответствии с соотношением сторон экрана. В результате, красный квадрат занимает всю высоту монитора, а по бокам виден зеленый фон. Если бы не соблюдалось соотношение сторон, то вместо зеленого фона по бокам был бы виден фон рабочей области (по умолчанию белый).
 
 <p><b>Примечание.</b> Протестируйте этот пример в обозревателе. В диалоговом окне «Параметры публикации Flash», на вкладке «HTML» выберите шаблон «Только Flash – Разрешить полноэкранный режим». Укажите Flash Player версии 9.0.115.0 и не забудьте выбрать форматы Flash и HTML на вкладке «Форматы». Затем опубликуйте и откройте полученный HTML-файл в обозревателе.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/fullScreenWidth"><linktext>fullScreenWidth</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenSourceRect:get"><apiName>fullScreenSourceRect</apiName><shortdesc>
  Flash Player масштабирует конкретный участок рабочей области в полноэкранный режим.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
  Flash Player масштабирует конкретный участок рабочей области в полноэкранный режим. Если есть возможность, проигрыватель Flash Player выполняет масштабирование с использованием аппаратных средств, включая графическую карту и видеокарту на компьютере пользователя. В этом случае отображение содержания, как правило, начинается намного быстрее, чем при масштабирование с помощью программных средств.
  
  <p>Когда этому свойству задано значение допустимого прямоугольника, а свойство <codeph>displayState</codeph> настроено на полноэкранный режим, проигрыватель Flash Player масштабирует заданную область. Фактический размер рабочей области в пикселях в ActionScript не изменяется. Проигрыватель Flash Player использует ограничение минимального размера прямоугольника, чтобы показать сообщение «Нажмите «Esc» для выхода из полноэкранного режима». Обычно минимальный размер бывает около 260 на 30 пикселей, но он может варьироваться в зависимости от платформы и версии Flash Player.</p>
  
  <p>Это свойство можно настраивать, только когда проигрыватель не находится в полноэкранном режиме. Для правильного использования этого свойства его необходимо настроить первым, и только потом выбирать для свойства <codeph>displayState</codeph> полноэкранный режим, как показано в примерах кода.</p>
  <p>Чтобы включить масштабирование, задайте свойство <codeph>fullScreenSourceRect</codeph> объекту прямоугольника.</p>
  <codeblock>  
  // valid, will enable hardware scaling
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240); 
  </codeblock>
  
  <p>Чтобы отключить масштабирование, задайте <codeph>fullScreenSourceRect=null</codeph> в ActionScript 3.0 и <codeph>undefined</codeph> в ActionScript 2.0.</p>
  <codeblock>
  stage.fullScreenSourceRect = null;
  </codeblock>
  
  <p>Конечный пользователь может отключить в параметрах отображения проигрывателя Flash Player аппаратное масштабирование, включенное по умолчанию. Дополнительные сведения см. на странице <xref href="http://www.adobe.com/go/display_settings_ru" scope="external">www.adobe.com/go/display_settings_ru</xref>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenSourceRect.1.as"> Чтобы использовать аппаратное масштабирование, необходимо задать полноэкранный режим для всего рабочей области или его части. Следующий код ActionScript 3.0 задает полноэкранный режим для всего рабочей области.
<codeblock>
 
import flash.geom.*; 
{
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
  stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example><example conref="examples\Stage_fullScreenSourceRectExample2.as"> В следующем примере пользователь может переключать воспроизведение видео с полноэкранного режима в нормальный и обратно щелчком по рабочей области. Если SWF-файл, рассматриваемый в данном примере, воспроизводится в проигрывателе Flash Player версии 9.0.115.0 или более поздней, то для улучшения полноэкранного масштабирования при отображении будет использоваться аппаратное ускорение.
  
 <p>Прежде чем использовать полноэкранный режим с аппаратным масштабированием, необходимо выполнить следующие условия:</p>
 
 <ol>
 <li>Требуется проигрыватель Flash Player версии 9.0.115.0 или более поздней, а также поддерживающий его инструмент разработки.</li>
 <li>необходимо изменить HTML-шаблоны с целью поддержки полноэкранного режима; атрибуту <codeph>allowFullScreen</codeph> необходимо задать значение <codeph>true</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph>. (Сценарии, создающие теги для внедрения SWF, также должны разрешать переход в полноэкранный режим.) Примеры файлов, которые можно использовать для Flex Builder, см. в статье <xref href="http://www.adobe.com/devnet/flashplayer/articles/full_screen_mode.html" scope="external">Exploring full-screen mode in Flash Player 9</xref> (Полноэкранный режим в проигрывателе Flash Player 9).</li>
 <li>У приложения должны быть разрешение и доступ к видеофайлу FLV. В данном примере предполагается, что файл Flash Video (FLV) находится в том же каталоге, что и SWF-файл.</li>
 <li>Пользователь должен разрешить доступ для полноэкранного режима.</li>
 <li>Дополнительные сведения об аппаратном масштабировании см. в статье <xref href="http://www.adobe.com/go/hardware_scaling_ru" scope="external">Поддержка видео с высоким разрешением H.264 и аудио формата AAC в проигрывателе Flash Player</xref>.</li>
 </ol>
 
 <p>FLV-файл загружается с использованием объектов NetConnection и NetStream. Так как FLV-файл находится в том же каталоге, что и SWF-файл и будет подключаться через HTTP, то параметру метода <codeph>NetConnection.connect()</codeph> задается значение <codeph>null</codeph>. Объект <codeph>connect</codeph> NetConnection сообщает свое состояние, отправляя событие <codeph>netStatus</codeph>, вызывающее метод <codeph>netStatusHandler()</codeph>. Метод <codeph>netStatusHandler()</codeph> проверяет, успешно ли установлено подключение и вызывает метод <codeph>connectStream()</codeph>, который создает объект NetStream, принимающий в качестве параметра объект NetConnection. Он также создает видеообъект и прилагаемый к нему объект NetStream. Затем видеообъект добавляется в список отображения и поток включается на воспроизведение. Так как видеофайл FLV не содержит метаданных или информации о ключевых точках, отправляется событие <codeph>AsyncError</codeph>. Необходимо настроить прослушиватель для обработки этого события. В данном примере прослушиватель настроен, он игнорирует событие. Также для объекта NetStream настраивается другой прослушиватель для события <codeph>netStatus</codeph>. Он будет отображать сообщение об ошибке, если поток не найден. (Обратите внимание, что метод <codeph>netStatusHandler()</codeph> можно использовать для обработки любого объема информации о состоянии потока или подключения.)</p>
 
 <p>Когда становятся доступны свойства и методы загруженного SWF-файла, вызывается метод <codeph>createMouseListener()</codeph>. Он настраивает прослушивателя событий щелчка мыши по рабочей области. Метод <codeph>toggleFullScreen()</codeph> проверяет, находится ли состояние отображения в полноэкранном или нормальном режиме. Если режим нормальный, размер видеообъекта равен размеру видеопотока. Для свойства <codeph>fullScreenSourceRect</codeph> выбирается прямоугольник, соответствующий размерам видеообъекта. Затем для свойства <codeph>Stage.displayMode</codeph> задается полный экран, в результате чего видео в исходном прямоугольнике развернется на весь экран. Если выполняются системные требования, графические аппаратные средства компьютера будут использоваться для оптимизации производительности полноэкранной визуализации видеоролика, и состояние отображения переходит в полноэкранный режим. Чтобы улавливать любые ошибки безопасности, которые могут возникнуть при переходе в полноэкранный режим, используется <codeph>try...catch</codeph>. (Обратите внимание, что состояние отображения должно переводиться на полноэкранный режим после того, как задано свойство <codeph>fullScreenSourceRect</codeph>.) Перед переключением в нормальный режим ширина и высота видеообъекта возвращаются к сохраненным исходным значениям. Если этого не сделать, ширина и высота будут определяться изменениями, внесенными в видеообъект для полноэкранного режима.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageDisplayState;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.NetStatusEvent;
    import flash.events.AsyncErrorEvent;
    import flash.events.SecurityErrorEvent;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.geom.Rectangle;
    
    public class Stage_fullScreenSourceRectExample2 extends Sprite {
        private var videoURL:String = "testVideo1.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var myVideo:Video;        
        private    var savedWidth:uint;
        private    var savedHeight:uint;
 
        public function Stage_fullScreenSourceRectExample2() {
    
            connection = new NetConnection();
             connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);    
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);

            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK, toggleFullScreen);
        }        

        private function toggleFullScreen(event:MouseEvent):void {

            if(stage.displayState == StageDisplayState.NORMAL) {
                myVideo.width = myVideo.videoWidth;
                  myVideo.height = myVideo.videoHeight;

                try {
                    stage.fullScreenSourceRect = new Rectangle(myVideo.x, myVideo.y, 
                                                           myVideo.width, myVideo.height);
                     stage.displayState = StageDisplayState.FULL_SCREEN;

                 } catch (e:SecurityError) {
                     trace ("A security error occurred while switching to full screen: " + event);
                    myVideo.width = savedWidth;
                    myVideo.height = savedHeight;
                 }

            }else {
                myVideo.width = savedWidth;
                myVideo.height = savedHeight;
                stage.displayState = StageDisplayState.NORMAL;
            }
        }    

       private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace ("Unable to locate video: " + videoURL);
                    break;
            }
        }

       private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);     

             myVideo = new Video();
            myVideo.attachNetStream(stream);
            stream.play(videoURL);

            savedWidth = myVideo.width;
            savedHeight = myVideo.height;

            addChild(myVideo);
        }
       
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);    
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/displayState"><linktext>Stage.displayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenWidth:get"><apiName>fullScreenWidth</apiName><shortdesc>
  Возвращает ту ширину монитора, которая будет использована при мгновенном переходе в полноэкранный режим.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  Возвращает ту ширину монитора, которая будет использована при мгновенном переходе в полноэкранный режим. Если в системе установлено несколько мониторов, то используется тот из них, на котором в данный момент отображается большая часть рабочей области. 
  
  <p><b>Примечание.</b> Если у пользователя есть возможность перемещать обозреватель с одного монитора на другой между получением значения и переходом в полноэкранный режим, то это значение будет неправильным. Если значение получено в обработчике событий, задающем для <codeph>Stage.displayState</codeph> значение <codeph>StageDisplayState.FULL_SCREEN</codeph>, то значение будет правильным.</p>
  
  <p>Это ширина монитора в пикселях, она равна ширине рабочей области, если для <codeph>Stage.align</codeph> задано значение <codeph>StageAlign.TOP_LEFT</codeph>, а для <codeph>Stage.scaleMode</codeph> – <codeph>StageScaleMode.NO_SCALE</codeph>.</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> В данном примере создается зеленый прямоугольник размером с рабочую область, а поверх него накладывается красный квадрат, активируемый в качестве кнопки. Щелчок по красному квадрату запускает обработчик событий <codeph>enterFullScreen()</codeph>, который задает свойство <codeph>fullScreenSourceRect</codeph> и входит в полноэкранный режим. Чтобы задать свойство <codeph>fullScreenSourceRect</codeph>, обработчик событий начинает с местоположения и размеров красного квадрата. Затем он сравнивает соотношение сторон (ширина, разделенная на высоту) красного квадрата с соотношением сторон рабочей области, имеющего ширину и высоту полного экрана, чтобы развернуть прямоугольник (<codeph>fullScreenSourceRect</codeph>) в соответствии с соотношением сторон экрана. В результате, красный квадрат занимает всю высоту монитора, а по бокам виден зеленый фон. Если бы не соблюдалось соотношение сторон, то вместо зеленого фона по бокам был бы виден фон рабочей области (по умолчанию белый).
 
 <p><b>Примечание.</b> Протестируйте этот пример в обозревателе. В диалоговом окне «Параметры публикации Flash», на вкладке «HTML» выберите шаблон «Только Flash – Разрешить полноэкранный режим». Укажите Flash Player версии 9.0.115.0 и не забудьте выбрать форматы Flash и HTML на вкладке «Форматы». Затем опубликуйте и откройте полученный HTML-файл в обозревателе.</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenHeight"><linktext>fullScreenHeight</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:height:get"><apiName>height</apiName><shortdesc>
	 
     Указывает высоту экранного объекта в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Ссылка на свойство <codeph>height</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Абсолютно недопустимо настраивать свойство <codeph>height</codeph> объекта Stage, даже если вызывающий объект является его владельцем (главный SWF-файл).
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Указывает высоту экранного объекта в пикселях. Высота вычисляется на основе границ содержимого экранного объекта. Когда задается свойство <codeph>height</codeph>, соответствующим образом изменяется и свойство <codeph>scaleY</codeph>, как показано в следующем коде.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>За исключением объектов TextField и Video, экранные объекты без содержимого (например, пустой спрайт), имеют высоту 0, даже если задать свойству <codeph>height</codeph> другое значение.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Ссылка на свойство <codeph>mouseChildren</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью мыши. Если объект реагирует на мышь, пользователь может осуществлять действия с ним с помощью мыши. Значение по умолчанию – <codeph>true</codeph>.
	 
	 <p>Это свойство удобно использовать, когда кнопка создается с помощью экземпляра класса Sprite (а не класса SimpleButton). Когда для создания кнопки используется экземпляр Sprite, при желании можно украсить кнопку с помощью метода <codeph>addChild()</codeph>, добавив дополнительные экземпляры Sprite. Этот процесс может вызывать непредвиденное поведение событий мыши, так как целевым объектом события мыши вместо вышестоящего экземпляра могут стать экземпляры Sprite, добавленные в качестве нижестоящих. Чтобы родительский экземпляр гарантированно был целевым объектом событий мыши, можно задать его свойству <codeph>mouseChildren</codeph> значение <codeph>false</codeph>.</p>
	 <p> При настройке данного свойства события не отправляются. Чтобы создать интерактивные функции, необходимо использовать метод <codeph>addEventListener()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:nativeWindow:get"><apiName>nativeWindow</apiName><shortdesc>
	 Ссылка на объект NativeWindow, содержащий данную рабочую область.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
	 Ссылка на объект NativeWindow, содержащий данную рабочую область. 
	 
	 <p>Данное окно представляет собственное окно операционной системы, а рабочая область – его содержимое. Данное свойство может быть использовано только при работе в среде AIR. В проигрывателе Flash Player (при просмотре содержимого в обозревателе) значением данного свойства является <codeph>null</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 
	 Возвращает число нижестоящих элементов данного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Ссылка на свойство <codeph>numChildren</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Возвращает число нижестоящих элементов данного объекта.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:quality:get"><apiName>quality</apiName><shortdesc>
	 Значение класса StageQuality, определяющее, какое качество визуализации следует применять.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Вызов свойства <codeph>quality</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Значение класса StageQuality, определяющее, какое качество визуализации следует применять. Ниже приводятся допустимые значения.
	 
	 <ul>
	 
	 <li><codeph>StageQuality.LOW</codeph> – низкое качество визуализации. Графические объекты и растровые изображения не сглаживаются, а среда выполнения продолжает использовать множественное отображение. Этот параметр не поддерживается в Adobe AIR.</li>
	 
	 <li><codeph>StageQuality.MEDIUM</codeph> – среднее качество визуализации. Графические объекты сглаживаются с помощью решетки пикселей 2 на 2, сглаживание растровых изображений зависит от значения параметра <codeph>Bitmap.smoothing</codeph>. Среда выполнения использует множественное отображение. Эта установка подходит для роликов, не содержащих текст. Этот параметр не поддерживается в Adobe AIR.</li>
	 
	 <li><codeph>StageQuality.HIGH</codeph> – высокое качество визуализации. Графические объекты сглаживаются с помощью решетки пикселей 4 на 4, сглаживание растровых изображений зависит от значения параметра <codeph>Bitmap.smoothing</codeph>. Среда выполнения использует множественные отображения. Этот параметр качества визуализации используется проигрывателем Flash Player по умолчанию.</li>
	 
	 <li><codeph>StageQuality.BEST</codeph> – Очень высокое качество визуализации. Графические объекты сглаживаются с помощью решетки пикселей 4 на 4. Если параметр <codeph>Bitmap.smoothing</codeph> имеет значение <codeph>true</codeph>, то среда выполнения использует высококачественный алгоритм уменьшения размера, который дает меньше помех (в то же время использование <codeph>StageQuality.BEST</codeph> с параметром <codeph>Bitmap.smoothing</codeph>, равным <codeph>true</codeph>, существенно замедляет работу и не рекомендуется).</li>
	 
	 </ul>
	 
	 <p>Более высокие параметры качества обеспечивают более качественную визуализацию масштабированных растровых изображений. Однако это происходит за счет увеличения нагрузки на ресурсы системы. В частности, параметр высокого качества при визуализации масштабированного видео может привести к уменьшению частоты кадров.
	 </p>
	 
	 <p>При воспроизведении содержимого в Adobe AIR можно установить параметр <codeph>quality</codeph> в значение <codeph>StageQuality.BEST</codeph> или <codeph>StageQuality.HIGH</codeph> (значением по умолчанию является <codeph>StageQuality.HIGH</codeph>). Изменение значения параметра на другое ни к чему не приводит (значение свойства остается неизменным).
	 </p>
	 
	 <p>При работе с содержимым в Adobe AIR настройка свойства <codeph>quality</codeph> одного объекта Stage приводит к изменению качества визуализации всех объектов Stage (используемых разными объектами NativeWindow).
	 </p>
	 
	 <b><i>Примечание.</i></b> Операционная система использует шрифты устройства, вследствие чего на них не влияет свойство <codeph>quality</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageQuality"><linktext>flash.display.StageQuality</linktext></link><link href="flash.display.xml#Bitmap/smoothing"><linktext>flash.display.Bitmap.smoothing</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
	 Значение класса StageScaleMode, задающее режим масштабирования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Вызов метода <codeph>scaleMode</codeph> объекта Stage приводит к созданию исключения для всех вызывающих файлов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Значение класса StageScaleMode, задающее режим масштабирования.
 	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Значение класса StageScaleMode, задающее режим масштабирования. Ниже приводятся допустимые значения.
	 
     <ul>
     
     <li><codeph>StageScaleMode.EXACT_FIT</codeph> – Задает видимость всего приложения в указанной области. При этом исходное соотношение сторон не поддерживается. Может возникнуть искажение изображения, в результате чего приложение может выглядеть растянутым или сжатым.
     </li>
     
     <li><codeph>StageScaleMode.SHOW_ALL</codeph> – Задает видимость всего приложения в указанной области без искажений при поддержании исходного соотношения сторон приложения. С двух сторон от приложения могут появиться поля.   
     </li>
     
	 <li><codeph>StageScaleMode.NO_BORDER</codeph> – Задает заполнение указанной области приложением без искажений, но с возможным усечением. При этом поддерживается исходное соотношение сторон приложения.
	 </li>
	 
	 <li><codeph>StageScaleMode.NO_SCALE</codeph> – Фиксируется размер всего приложения, так что он сохраняется даже при изменении размеров окна проигрывателя. Если окно проигрывателя меньше размеров содержимого, может возникнуть усечение.
	 </li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:showDefaultContextMenu:get"><apiName>showDefaultContextMenu</apiName><shortdesc>
     Задает отображение или скрытие элементов по умолчанию в контекстном меню Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызов свойства <codeph>showDefaultContextMenu</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Задает отображение или скрытие элементов по умолчанию в контекстном меню Flash Player.
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Задает отображение или скрытие элементов по умолчанию в контекстном меню Flash Player.
     
     <p>Если свойство <codeph>showDefaultContextMenu</codeph> имеет значение <codeph>true</codeph> (по умолчанию), то появляются все элементы контекстного меню. Если свойство <codeph>showDefaultContextMenu</codeph> имеет значение <codeph>false</codeph>, отображаются только элементы меню «Параметры» и «О проигрывателе Adobe Flash Player».</p>
     
 	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageFocusRect:get"><apiName>stageFocusRect</apiName><shortdesc>
	 Определяет, должна ли отображаться светящаяся рамка вокруг объектов в фокусе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызов свойства <codeph>stageFocusRect</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Определяет, должна ли отображаться светящаяся рамка вокруг объектов в фокусе.
	 
 	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет, должна ли отображаться светящаяся рамка вокруг объектов в фокусе.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageHeight:get"><apiName>stageHeight</apiName><shortdesc>
     Текущая высота объекта Stage в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Вызов свойства <codeph>stageHeight</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Текущая высота объекта Stage в пикселях.
     
     <p>Если задать для свойства <codeph>Stage.scaleMode</codeph> значение <codeph>StageScaleMode.NO_SCALE</codeph>, когда пользователь изменяет размеры окна, содержимое рабочей области сохраняет заданный размер, а свойство <codeph>stageHeight</codeph> изменяется, отражая новую высоту области экрана, занимаемой SWF-файлом. (В остальных режимах масштабирования свойство <codeph>stageHeight</codeph> всегда отражает исходную высоту SWF-файла.) Можно добавить прослушиватель для события <codeph>resize</codeph>, а затем использовать свойство <codeph>stageHeight</codeph> класса Stage, чтобы определять фактические размеры в пикселях измененного окна проигрывателя Flash Player. Прослушиватель событий позволяет контролировать, как содержимое экрана корректируется, когда пользователь изменяет размер окна.</p>
	 
	 <p><b>Примечание.</b> На HTML-странице, содержащей SWF-файл, атрибуты <codeph>height</codeph> тегов <codeph>object</codeph> и <codeph>embed</codeph> должны быть выражены в процентах (например, <codeph>100%</codeph>), а не в пикселях. Если параметры определяются кодом JavaScript, то параметр <codeph>height</codeph> метода <codeph>AC_FL_RunContent() </codeph> также необходимо настроить на представление в процентах. Эти проценты применяются к значению <codeph>stageHeight</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:stageWidth:get"><apiName>stageWidth</apiName><shortdesc>
     Задает текущую ширину объекта Stage в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Вызов свойства <codeph>stageWidth</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Задает текущую ширину объекта Stage в пикселях.
     
     
     <p>Если задать для свойства <codeph>Stage.scaleMode</codeph> значение <codeph>StageScaleMode.NO_SCALE</codeph>, когда пользователь изменяет размеры окна, содержимое рабочей области сохраняет заданный размер, а свойство <codeph>stageWidth</codeph> изменяется, отражая новую ширину области экрана, занимаемой SWF-файлом. (В остальных режимах масштабирования свойство <codeph>stageWidth</codeph> всегда отражает исходную ширину SWF-файла.) Можно добавить прослушиватель для события <codeph>resize</codeph>, а затем использовать свойство <codeph>stageWidth</codeph> класса Stage, чтобы определять фактические размеры в пикселях измененного окна проигрывателя Flash Player. Прослушиватель событий позволяет контролировать, как содержимое экрана корректируется, когда пользователь изменяет размер окна.</p>
	 
     <p><b>Примечание.</b> На HTML-странице, содержащей SWF-файл атрибуты <codeph>width</codeph> тегов <codeph>object</codeph> и <codeph>embed</codeph> должны быть выражены в процентах (например, <codeph>100%</codeph>), а не в пикселях. Если параметры определяются кодом JavaScript, то параметр <codeph>width</codeph> метода <codeph>AC_FL_RunContent() </codeph> также необходимо настроить на представление в процентах. Эти проценты применяются к значению <codeph>stageWidth</codeph>.</p>
     
 	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью клавиши Tab.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Ссылка на свойство <codeph>tabChildren</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 Определяет, включен ли переход между нижестоящими элементами объекта с помощью клавиши Tab. Включает или отключает переход между потомками объекта с помощью клавиши Tab. Значение по умолчанию – <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
	 
     Возвращает объект TextSnapshot для данного экземпляра DisplayObjectContainer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier><apiException><apiDesc>Ссылка на свойство <codeph>textSnapshot</codeph> объекта Stage приводит к созданию исключения, так как класс Stage не реализует это свойство. Во избежание этого нужно вызвать свойство <codeph>textSnapshot</codeph> контейнера экранного объекта, не содержащего объект Stage.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Возвращает объект TextSnapshot для данного экземпляра DisplayObjectContainer.
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:width:get"><apiName>width</apiName><shortdesc>
	 
     Указывает ширину экранного объекта в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Ссылка на свойство <codeph>width</codeph> объекта Stage приводит к созданию исключения для всех вызывающих объектов, находящихся не в той же изолированной программной среде безопасности, что и владелец объекта Stage (главный SWF-файл). Во избежание этого владелец объекта Stage может предоставить разрешение домену вызывающего объекта путем вызова метода <codeph>Security.allowDomain()</codeph> или метода <codeph>Security.allowInsecureDomain()</codeph>. Дополнительные сведения см. в главе «Безопасность» в книге <i>Программирование на ActionScript 3.0</i>.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Абсолютно недопустимо настраивать свойство <codeph>width</codeph> объекта Stage, даже если вы являетесь его владельцем.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     Указывает ширину экранного объекта в пикселях. Ширина вычисляется на основе границ содержимого экранного объекта. Когда задается свойство <codeph>width</codeph>, соответствующим образом изменяется и свойство <codeph>scaleX</codeph>, как показано в следующем коде.
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>За исключением объектов TextField и Video, экранные объекты без содержимого (например, пустой спрайт), имеют ширину 0, даже если задать свойству <codeph>width</codeph> другое значение.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:wmodeGPU:get"><apiName>wmodeGPU</apiName><shortdesc>
	 Указывает, доступен ли композитинг GPU и используется ли он в данный момент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, доступен ли композитинг GPU и используется ли он в данный момент. Свойство <codeph>wmodeGPU</codeph> имеет значение <codeph>true</codeph>, <i>только</i> когда верны все три перечисленные ниже условия.
	 <p><ul><li>Получен запрос на композитинг GPU.</li>
	 <li>Композитинг GPU доступен.</li>
	 <li>Композитинг GPU используется в данный момент.</li></ul></p>
	 <p>В частности, свойство <codeph>wmodeGPU</codeph> указывает на одно из следующих состояний.</p>
	 <p><ol><li>Композитинг GPU не востребован или недоступен. В этом случае свойство <codeph>wmodeGPU</codeph> имеет значение <codeph>false</codeph>.</li>
	 <li>Композитинг GPU востребован (если он применим и доступен), но среда работает в резервном режиме из-за ограничений содержимого (не может обеспечить оптимальный рендеринг). В этом случае свойство <codeph>wmodeGPU</codeph> имеет значение <codeph>true</codeph>.</li>
	 <li>Композитинг GPU востребован (если он применим и доступен), и среда работает в оптимальном режиме. В этом случае свойство <codeph>wmodeGPU</codeph> также имеет значение <codeph>true</codeph>.</li></ol></p>
	 <p>Другими словами, свойство <codeph>wmodeGPU</codeph> обозначает возможности и состояние среды рендеринга. Если среда выполнения не поддерживает композитинг GPU, например AIR 1.5.2, это свойство всегда имеет значение <codeph>false</codeph>, поскольку (как сказано выше) оно имеет значение <codeph>true</codeph>, только когда композитинг GPU востребован, доступен и используется.</p>
	 <p>С помощью свойства <codeph>wmodeGPU</codeph> во время выполнения можно определить, используется ли композитинг GPU. Значение <codeph>wmodeGPU</codeph> указывает, будет ли содержимое масштабироваться аппаратными средствами, чтобы выбрать для графики правильный размер. Также можно определить, быстро или медленно выполняется рендеринг, чтобы соответствующим образом скорректировать сложность содержимого.</p>
	 <p>Если Flash Player встроен в браузер, композитинг GPU может быть востребован с помощью значения <codeph>gpu</codeph>, присвоенного параметру HTML <codeph>wmode</codeph> на странице, содержащей SWF-файл. Для других конфигураций запрос на композитинг GPU можно добавить в заголовок SWF-файла (с помощью инструментов разработки SWF).</p>	 
	 <p>Однако свойство <codeph>wmodeGPU</codeph> не позволяет определить текущее быстродействие рендеринга. Даже если композитинг GPU используется, процесс рендеринга может выполняться не в оптимальном режиме. Чтобы скорректировать содержимое для оптимального рендеринга, следует использовать отладочную версию среды выполнения Flash и задать свойство <codeph>DisplayGPUBlendsetting</codeph> в файле mm.cfg.</p>
	 
	 <p><b>Примечание.</b> Это свойство всегда имеет значение <codeph>false</codeph>, когда на него ссылается код ActionScript, исполняемый до того, как среда выполнения осуществляет первый прогон рендеринга. Например, если выполняется анализ <codeph>wmodeGPU</codeph> из сценария кадра 1 в Adobe Flash Professional и ваш SWF-файл является первым SWF-файлом, загруженным в новый экземпляр среды выполнения, тогда <codeph>wmodeGPU</codeph> будет иметь значение <codeph>false</codeph>. Чтобы получить точное значение, дождитесь, когда будет выполнен хотя бы один прогон рендеринга. Если создан прослушиватель для события <codeph>exitFrame</codeph> любого объекта <codeph>DisplayObject</codeph>, то свойство <codeph>wmodeGPU</codeph> возвращает правильное значение.</p>
	 
	 </apiDesc><example conref="examples\Stage.wmodeGPU.as"> В следующем примере свойство <codeph>wmodeGPU</codeph> анализируется после рендеринга экранного объекта mySprite с целью получения точного значения.
<codeblock>
mySprite.addEventListener(EXIT_FRAME, exithandler):

function exithandler(exiteventobject:Event):void {
                trace(stage.wmodeGPU);
}
</codeblock></example></apiValueDetail><related-links><link href="DisplayObject.html#event:exitFrame"><linktext>Событие exitFrame объекта DisplayObject</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	 Класс NativeWindowInitOptions определяет параметры инициализации, используемые при создании нового экземпляра NativeWindow.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс NativeWindowInitOptions определяет параметры инициализации, используемые при создании нового экземпляра NativeWindow. 
	 <p>Свойства, определенные в параметрах, инициализации нельзя изменить после создания окна.</p>
	 
	 <p><b>Примечание.</b> Для начального окна приложения, автоматически создаваемого в AIR, все эти свойства, кроме <codeph>типа</codeph>, задаются в дескрипторе приложения. Начальное окно всегда имеет обычный тип.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links><apiConstructor id="flash.display:NativeWindowInitOptions:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	    Создает новый объект NativeWindowInitOptions.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	    Создает новый объект NativeWindowInitOptions.
	    
        <p>По умолчанию вновь созданный объект имеет следующие значения:</p>
	    <ul>
        <li><codeph>systemChrome = NativeWindowSystemChrome.STANDARD</codeph></li>
        <li><codeph>type = NativeWindowType.NORMAL</codeph></li>
	    <li><codeph>transparent = false</codeph></li>
	    <li><codeph>resizable = true</codeph></li>
	    <li><codeph>maximizable = true</codeph></li>
	    <li><codeph>minimizable = true</codeph></li>
	    </ul>
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:NativeWindowInitOptions:maximizable:get"><apiName>maximizable</apiName><shortdesc>
		 Определяет возможность разворачивания окна пользователем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MAXIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Определяет возможность разворачивания окна пользователем  
		 
		 <p>
		 Для окон с системным хромом этот параметр влияет на внешний вид кнопки для разворачивания. Также она влияет и на другие элементы пользовательского интерфейса, управляемого системой, такие как меню окна в Microsoft Windows.
		 </p>
		 
		 <p>
		 При значении <codeph>false</codeph> окно не может быть развернуто пользователем. При вызове метода NativeWindow <codeph>maximize()</codeph> напрямую окно полностью разворачивается.
		 </p>
		 
		 <p><b>Примечание</b> В операционных системах, таких как Mac OS X, в которых разворачивание окна не предотвращает изменения размеров, значение <codeph>false</codeph> необходимо задать как для <codeph>maximizable</codeph>, так и для <codeph>resizable</codeph>, чтобы предотвратить масштабирование или изменение размеров окна.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:minimizable:get"><apiName>minimizable</apiName><shortdesc>
		 Определяет возможность сворачивания окна пользователем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MINIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Определяет возможность сворачивания окна пользователем.
		 
		 <p>
		 Для окон с системным хромом этот параметр влияет на внешний вид кнопки для сворачивания. Также она влияет и на другие элементы пользовательского интерфейса, управляемого системой, такие как меню окна в Microsoft Windows.
		 </p>
		 
		 <p>
		 При значении <codeph>false</codeph> окно не может быть свернуто пользователем. При вызове метода NativeWindow <codeph>minimize()</codeph> напрямую окно сворачивается.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:resizable:get"><apiName>resizable</apiName><shortdesc>
		 Определяет возможность изменения размеров окна пользователем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_SIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Определяет возможность изменения размеров окна пользователем.
		 
		 <p>
		 При установке <codeph>false</codeph> размеры окна не могут быть изменены пользователем с помощью системного хрома. Вызов метода <codeph>startResize()</codeph> NativeWindow в ответ на событие мыши разрешает пользователям изменять размеры окна. При задании границ окна напрямую размер окна также изменится.
		 </p>
		 
		 <p><b>Примечание.</b> В операционных системах, таких как Mac OS X, в которых разворачивание окна является операцией изменения размеров, значение <codeph>false</codeph> необходимо задать как для <codeph>maximizable</codeph>, так и для <codeph>resizable</codeph>, чтобы предотвратить масштабирование или изменение размеров окна.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
		 Указывает, предусмотрен ли для окна системный хром.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowSystemChrome.STANDARD
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Указывает, предусмотрен ли для окна системный хром. 
		  
		 <p> Хромом называются элементы управления окном, позволяющие управлять свойствами окна на рабочем столе. Системный хром использует стандартные элементы управления для окружения рабочего стола, в котором работает приложение AIR, и согласует его со стандартным внешним видом, используемым в данной операционной системе.</p>
		 <p>
		 Чтобы использовать хром, предусмотренный в среде (такой как Flex), или указать собственный хром окна, задайте для <codeph>systemChrome</codeph> значение <codeph>NativeWindowSystemChrome.NONE</codeph>.
		 </p>
		 <p>Константы для допустимых значений данного свойства определяются в классе NativeWindowSystemChrome:
         </p>
		 <ul>
         <li><codeph>NativeWindowSystemChrome.NONE</codeph></li>
		 <li><codeph>NativeWindowSystemChrome.STANDARD</codeph></li>
		 </ul>
		 
		 <p>Если не задано иное, по умолчанию для <codeph>systemChrome</codeph> используется значение <codeph>NativeWindowSystemChrome.STANDARD</codeph>.
		 </p>
		 
		 <p>Для свойства <codeph>transparent</codeph> окна с системным хромом не поддерживается значение <codeph>true</codeph>.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:transparent:get"><apiName>transparent</apiName><shortdesc>
		 Указывает, поддерживает ли окно прозрачность и альфа-смешивание с рабочим столом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
		 
	     </apiDefaultValue></apiValueDef><apiDesc>
		 Указывает, поддерживает ли окно прозрачность и альфа-смешивание с рабочим столом.
		 
		 <p>
		 Если задано значение <codeph>true</codeph>, отображение окна согласуется с рабочим столом. Области окна, не закрытые экранным объектом или закрытые объектами отображения с значениями альфа-канала, близкими нулю, становятся невидимы и не реагируют на мышь (при нажатии на объект рабочего стола, находящийся под окном). Значение альфа-канала, при котором объект перестает улавливать события мыши, варьируется от 0,01 до 0,06 в зависимости от операционной системы.
		 </p>  
		 
		 <p>Для свойства <codeph>transparent</codeph> окна с системным хромом не поддерживается значение <codeph>true</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowInitOptions:type:get"><apiName>type</apiName><shortdesc>
		 Задает тип создаваемого окна.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowType.NORMAL
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Задает тип создаваемого окна.  
		 
		 <p>Константы для допустимых значений данного свойства определяются в классе NativeWindowType:
         </p>
         
		 <ul>
		 <li><codeph>NativeWindowType.NORMAL</codeph> – Обычное окно. Обычные окна используют полноразмерный хром и появляются на панели задач Windows или Linux и в меню окна Mac OS X.</li>
		 
		 <li><codeph>NativeWindowType.UTILITY</codeph> – Палитра инструмента. Окна служебной программы используют более тонкую версию системного хрома и не отображаются на панели задач Windows и в меню окна Mac OS X.</li>
		 
		 <li><codeph>NativeWindowType.LIGHTWEIGHT</codeph> – облегченные окна не могут использовать системный хром и не отображаются на панели задач Windows или Linux и в меню окна Mac OS X. Кроме того, у облегченных окон нет системного меню (Alt-Space) в Windows. Облегченные окна подходят для уведомлений и элементов управления, таких как комбинированное поле, открывающие кратковременную область отображения. При использовании облегченного типа для <codeph>systemChrome</codeph> необходимо задать значение <codeph>none</codeph>.</li>
		 </ul>
		 
		 <p>
		 Если не задано иное, по умолчанию для <codeph>типа</codeph> используется значение <codeph>NativeWindowType.NORMAL</codeph>.
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
	 Экземпляр ShaderParameter представляет единственный параметр ввода ядра затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Экземпляр ShaderParameter представляет единственный параметр ввода ядра затенения. При выполнении ядра можно заставить его работать с нулем, одним или несколькими параметрами, используемыми при выполнении ядра. ShaderParameter предоставляет сведения о параметре, например, ожидаемый тип данных. В нем также заложен механизм, позволяющий указывать значение параметра для использования при выполнении операции затенения. Чтобы задать одно или несколько значений параметра затенения, создайте массив с одним или несколькими значениями и назначьте его свойству <codeph>value</codeph>.
	 
	 <p>Доступ к экземпляру ShaderParameter, представляющему параметр экземпляра Shader, осуществляется в качестве свойства <codeph>data</codeph> экземпляра Shader. В коде затенения имя свойства ShaderParameter совпадает с именем параметра. Например, если затенение задает параметр с именем <codeph>radius</codeph>, то экземпляр ShaderParameter, представляющий параметр <codeph>radius</codeph>, будет доступен в качестве свойства <codeph>radius</codeph>. Пример:</p>
	 
	 <codeblock>var radiusParam:ShaderParameter = myShader.data.radius;</codeblock>
	 
	 <p>В дополнение к заданным свойствам класса ShaderParameter каждый экземпляр ShaderParameter обладает дополнительными свойствами, соответствующими любым метаданным, определенным для параметра. Эти свойства применяются к объекту ShaderParameter при его создании. Имена свойств совпадают с именами метаданных, указанными в исходном коде затенения. Типы данных каждого свойства различаются в зависимости от типов данных соответствующих метаданных. Значение метаданных текста «описание» является экземпляром String. Свойство метаданных, содержащее не строковое значение (например, <codeph>minValue</codeph> или <codeph>defaultValue</codeph>), является экземпляром Array. Количество элементов и типов данных элементов совпадает со значениями метаданных.</p>
	 
	 <p>Предположим, в затенение входит два следующих объявления параметров:</p>
	 
	 <codeblock>
	 parameter float2 size
	 &lt;
	     description: "The size of the image to which the kernel is applied";
	     minValue: float2(0.0, 0.0);
	     maxValue: float2(100.0, 100.0);
	     defaultValue: float2(50.0, 50.0);
	 >;
	 
	 parameter float radius
	 &lt;
	     description: "The radius of the effect";
	     minValue: 0.0;
	     maxValue: 50.0;
	     defaultValue: 25.0;
	 >;
	 </codeblock>
	 
	 <p>В дополнение к встроенным свойствам в экземпляре ShaderParameter, который соответствует параметру <codeph>size</codeph>, присутствуют следующие свойства метаданных:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Имя свойства</entry><entry>Тип данных</entry><entry>Значение</entry></row></thead><tbody><row>
	   <entry><codeph>Имя</codeph></entry>
	   <entry>Строка</entry>
	   <entry><codeph>"size"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>Строка</entry>
	   <entry><codeph>"The size of the image to which the kernel is applied"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0, 0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[100, 100]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50, 50]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>ShaderParameter, соответствующий параметру <codeph>radius</codeph>, обладает следующими дополнительными свойствами:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Имя свойства</entry><entry>Тип данных</entry><entry>Значение</entry></row></thead><tbody><row>
	   <entry><codeph>Имя</codeph></entry>
	   <entry>Строка</entry>
	   <entry><codeph>"radius"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>Строка</entry>
	   <entry><codeph>"The radius of the effect"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[25]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Обычно в коде разработчика прямое создание экземпляра ShaderParameter не заложено. При создании экземпляра Shader экземпляр ShaderParameter создается автоматически для каждого параметра затенения.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links><apiConstructor id="flash.display:ShaderParameter:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
		 Создает экземпляр ShaderParameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Создает экземпляр ShaderParameter. В коде разработчика прямой вызов конструктора ShaderParameter не производится. При создании экземпляра Shader экземпляр ShaderParameter создается автоматически для каждого параметра затенения.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderParameter:index:get"><apiName>index</apiName><shortdesc>
         Отсчитываемое от нуля значение индекса для параметра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Отсчитываемое от нуля значение индекса для параметра.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameter:type:get"><apiName>type</apiName><shortdesc>
		Тип данных параметра согласно заданному типу в затенении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Тип данных параметра согласно заданному типу в затенении. Набор возможных значений свойства <codeph>type</codeph> определяется константами класса ShaderParameterType.
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameterType"><linktext>flash.display.ShaderParameterType</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameter:value:get"><apiName>value</apiName><shortdesc>
		Значение или значения, передаваемые в качестве значений параметра затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		Значение или значения, передаваемые в качестве значений параметра затенения. Свойство <codeph>value</codeph> является индексированным массивом. Число и тип элементов массива соответствует типу данных параметра и задается с помощью свойства <codeph>type</codeph>.
		
		<p>В следующей таблице указан тип параметра и соответствующие значение числа и типа данных <codeph>value</codeph> элементов массива:</p>
		
		<adobetable class="innertable">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		<tgroup cols="3"><thead><row><entry>Тип параметра</entry><entry>Число элементов</entry><entry>Тип данных элементов</entry></row></thead><tbody><row>
		  <entry>float (<codeph>ShaderParameterType.FLOAT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float2 (<codeph>ShaderParameterType.FLOAT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3 (<codeph>ShaderParameterType.FLOAT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4 (<codeph>ShaderParameterType.FLOAT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>int (<codeph>ShaderParameterType.INT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>int или uint</entry>
		</row><row>
		  <entry>int2 (<codeph>ShaderParameterType.INT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>int или uint</entry>
		</row><row>
		  <entry>int3 (<codeph>ShaderParameterType.INT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>int или uint</entry>
		</row><row>
		  <entry>int4 (<codeph>ShaderParameterType.INT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>int или uint</entry>
		</row><row>
		  <entry>bool (<codeph>ShaderParameterType.BOOL</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Логическое значение</entry>
		</row><row>
		  <entry>bool2 (<codeph>ShaderParameterType.BOOL2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Логическое значение</entry>
		</row><row>
		  <entry>bool3 (<codeph>ShaderParameterType.BOOL3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Логическое значение</entry>
		</row><row>
		  <entry>bool4 (<codeph>ShaderParameterType.BOOL4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Логическое значение</entry>
		</row><row>
		  <entry>float2x2 (<codeph>ShaderParameterType.MATRIX2X2</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3x3 (<codeph>ShaderParameterType.MATRIX3X3</codeph>)</entry>
		  <entry>9</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4x4 (<codeph>ShaderParameterType.MATRIX4X4</codeph>)</entry>
		  <entry>16</entry>
		  <entry>Number</entry>
		</row></tbody></tgroup></adobetable>
		
		<p>Если используются параметры типа «матрица», то массив заполняется сначала по горизонтали, затем по вертикали. Предположим, что следующая строка ActionScript используется для заполнения параметра <codeph>float2x2</codeph> с именем <codeph>myMatrix</codeph>:</p>
		
		<codeblock>myShader.data.myMatrix.value = [.1, .2, .3, .4];</codeblock>
		
		<p>Значения элементов матрица в заголовке затенения:</p>
		
		<ul>
		  <li><codeph>myMatrix[0][0]</codeph>: .1</li>
		  <li><codeph>myMatrix[0][1]</codeph>: .2</li>
		  <li><codeph>myMatrix[1][0]</codeph>: .3</li>
		  <li><codeph>myMatrix[1][1]</codeph>: .4</li>
		</ul>
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GradientType"><apiName>GradientType</apiName><shortdesc>
Класс GradientType передает значения для параметра type в методах beginGradientFill() и lineGradientStyle() класса flash.display.Graphics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс GradientType передает значения для параметра <codeph>type</codeph> в методах <codeph>beginGradientFill()</codeph> и <codeph>lineGradientStyle()</codeph> класса flash.display.Graphics.

</apiDesc></apiClassifierDetail><apiValue id="flash.display:GradientType:LINEAR"><apiName>LINEAR</apiName><shortdesc>
	Значение, с помощью которого задается заливка линейным градиентом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linear</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Значение, с помощью которого задается заливка линейным градиентом.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GradientType:RADIAL"><apiName>RADIAL</apiName><shortdesc>
	Значение, с помощью которого задается заливка радиальным градиентом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>radial</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Значение, с помощью которого задается заливка радиальным градиентом.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InterpolationMethod"><apiName>InterpolationMethod</apiName><shortdesc>
Класс InterpolationMethod передает значения для параметра interpolationMethod в методах Graphics.beginGradientFill() и Graphics.lineGradientStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс InterpolationMethod передает значения для параметра <codeph>interpolationMethod</codeph> в методах <codeph>Graphics.beginGradientFill()</codeph> и <codeph>Graphics.lineGradientStyle()</codeph>. Этот параметр определяет пространство RGB, используемое при визуализации градиента. 

 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:InterpolationMethod:LINEAR_RGB"><apiName>LINEAR_RGB</apiName><shortdesc>
	Задает применение метода линейной RGB-интерполяции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linearRGB</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает применение метода линейной RGB-интерполяции. Это значит, что используется цветовое пространство RGB, основанное на линейной цветовой модели RGB.
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/RGB"><linktext>RGB</linktext></link></related-links></apiValue><apiValue id="flash.display:InterpolationMethod:RGB"><apiName>RGB</apiName><shortdesc>
	Задает применение метода RGB-интерполяции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>rgb</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает применение метода RGB-интерполяции. Это значит, что визуализация градиента выполняется с использованием экспоненциального пространства sRGB (стандартное RGB). Пространство sRGB представляет собой стандарт W3C, определяющий нелинейное преобразование между значениями красного, зеленого и синего компонентов и фактическую интенсивность видимого составляющего цвета.
	
	<p>Например, рассмотрим простой линейный градиент между двумя цветами (параметру <codeph>spreadMethod</codeph> задано значение <codeph>SpreadMethod.REFLECT</codeph>). Разные методы интерполяции влияют на внешний вид следующим образом: </p>
	
		<adobetable>
		
      
		
		
		
		<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="линейный градиент с методом InterpolationMethod.LINEAR_RGB" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="линейный градиент с методом InterpolationMethod.RGB" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
		</row><row>
		<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
		<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
		</row></tbody></tgroup></adobetable>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/LINEAR_RGB"><linktext>LINEAR_RGB</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsPath"><apiName>IGraphicsPath</apiName><shortdesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров path в методах flash.display.Graphics и классах рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров path в методах flash.display.Graphics и классах рисования. Используйте классы средства реализации данного интерфейса для создания данных свойства path и управления ими, а также для повторного использования этих данных для других экземпляров.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:IGraphicsFill"><apiName>IGraphicsFill</apiName><shortdesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров fill в методах flash.display.Graphics и классах рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров fill в методах flash.display.Graphics и классах рисования. Используйте классы средства реализации данного интерфейса для создания данных свойства fill и управления ими, а также для повторного использования этих данных для других экземпляров.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#GraphicsStroke/fill"><linktext>flash.display.GraphicsStroke.fill</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:LoaderInfo"><apiName>LoaderInfo</apiName><shortdesc>
 Класс LoaderInfo обеспечивает сведения о загружаемом SWF-файле или файле изображения (JPEG, GIF или PNG).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion><Exclude kind="method" name="dispatchEvent"/></asMetadata><asCustoms><internal>Update the places LoaderInfo can be obtained from (playerglobal.as) and double-check loader vs. loadee.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс LoaderInfo обеспечивает сведения о загружаемом SWF-файле или файле изображения (JPEG, GIF или PNG). Объекты LoaderInfo доступны для любых экранных объектов. Предоставляемая информация включает процесс загрузки, URL-адреса загружающего объекта и загружаемого содержимого, общее количество байт и номинальная высота и ширина содержимого.
 
 <p>Обратиться к объектам LoaderInfo можно двумя способами: </p>
 
 <ul>
 
 	<li>Свойство <codeph>contentLoaderInfo</codeph> объекта flash.display.Loader – Свойство <codeph>contentLoaderInfo</codeph> всегда доступно для объекта Loader. Если объект Loader не вызывал метод <codeph>load()</codeph> или <codeph>loadBytes()</codeph> или не загрузил достаточный объем содержимого, попытка обратиться ко многим свойствам <codeph>contentLoaderInfo</codeph> приведет к появлению ошибки.</li>
 
 	<li>Свойство <codeph>loaderInfo</codeph> экранного объекта. </li>
 
 </ul>
 
 <p>Свойство <codeph>contentLoaderInfo</codeph> объекта Loader передает информацию о содержимом, загружаемом объектом Loader, а свойство <codeph>loaderInfo</codeph> объекта DisplayObject передает информацию о его корневом SWF-файле. </p>
 
 <p>При использовании объекта Loader для загрузки экранного объекта (SWF-файла или растрового изображения), значение свойства <codeph>loaderInfo</codeph> экранного объекта совпадает со значением свойства <codeph>contentLoaderInfo</codeph> объекта Loader (<codeph>DisplayObject.loaderInfo = Loader.contentLoaderInfo</codeph>). Так как экземпляр основного класса SWF-файла не имеет объекта Loader, свойство <codeph>loaderInfo</codeph> является единственным способом обращения к LoaderInfo для экземпляра основного класса SWF-файла.</p>
 
 <p>На следующей схеме показаны разные возможности применения объекта LoaderInfo: для экземпляра основного SWF-файла, для свойства <codeph>contentLoaderInfo</codeph> объекта Loader и для свойства <codeph>loaderInfo</codeph> загруженного объекта.</p>
 
 <p>
 <adobeimage alt="Изображение с примерами использования LoaderInfo" href="../../images/loaderInfo_object.jpg"/>
 </p>
 
 <p>Некоторые свойства <codeph>contentLoaderInfo</codeph> объекта Loader остаются недоступными вплоть до завершения загрузки. Но можно получить такие свойства, как <codeph>bytesLoaded</codeph>, <codeph>bytesTotal</codeph>, <codeph>url</codeph>, <codeph>loaderURL</codeph> и <codeph>applicationDomain</codeph>. Когда объект <codeph>loaderInfo</codeph> отправляет событие <codeph>init</codeph>, можно обратиться ко всем свойствам объекта <codeph>loaderInfo</codeph> и загруженного изображения или SWF-файла.</p>
 
 <p><b>Примечание.</b> Все свойства объектов LoaderInfo доступны только для чтения.</p>
 
 <p>Метод <codeph>EventDispatcher.dispatchEvent()</codeph> не применим к объектам LoaderInfo. Если вызвать метод <codeph>dispatchEvent()</codeph> для объекта LoaderInfo, появится ошибка IllegalOperationError.</p>
 
 
 
 </apiDesc><example conref="examples\LoaderInfoExample.as"> В следующем примере класс LoaderInfoExample используется для вывода изображения в рабочую область. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>Создается свойство <codeph>url</codeph>, описывающее местоположение и имя изображения.</li>
 
  <li>Конструктор класса создает объект Loader с именем <codeph>loader</codeph>.</li>
 
  <li>Объект <codeph>loader</codeph> создает экземпляр прослушивателя событий, чтобы обеспечить правильную загрузку изображения.</li>
 
  <li>Конструктор создает новый экземпляр объекта URLRequest, <codeph>request</codeph>, и передает <codeph>url</codeph>, чтобы сообщить имя и местоположение файла.</li>
 
  <li>Затем объект <codeph>request</codeph> передается методу <codeph>load()</codeph> объекта <codeph>loader</codeph>, который загружает изображение в список отображения.</li>
 
 </ol>
 <p><b>Важно!</b> В этом примере требуется добавить файл с именем Image.gif в тот же каталог, что и компилированный SWF-файл. Используйте изображение, область которого соответствует размерам основного SWF-файла.</p>
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.LoaderInfo;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderInfoExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderInfoExample() {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function initHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);
            trace("initHandler: loaderURL=" + info.loaderURL + " url=" + info.url);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObject/loaderInfo"><linktext>flash.display.DisplayObject.loaderInfo</linktext></link></related-links><adobeApiEvent id="flash.display:LoaderInfo_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Передается, когда сетевой запрос отправляется через HTTP и возможно определить код состояния HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Передается, когда сетевой запрос отправляется через HTTP и возможно определить код состояния HTTP.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.UNLOAD_unload"><apiName>unload</apiName><shortdesc>
 Передается объектом LoaderInfo каждый раз, когда загруженный объект удаляется с помощью метода unload() объекта Loader, а также когда выполняется повторная загрузка тем же объектом Loader, и перед началом загрузки удаляется исходное содержимое.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.UNLOAD</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Передается объектом LoaderInfo каждый раз, когда загруженный объект удаляется с помощью метода <codeph>unload()</codeph> объекта Loader, а также когда выполняется повторная загрузка тем же объектом Loader, и перед началом загрузки удаляется исходное содержимое.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>Loader.unload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Отправляется в случае получения данных в ходе операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется в случае получения данных в ходе операции загрузки.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Отправляется при запуске операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при запуске операции загрузки.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.INIT_init"><apiName>init</apiName><shortdesc>
 Отправляется, когда свойства и методы загруженного SWF-файла становятся доступны и готовы к использованию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.INIT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда свойства и методы загруженного SWF-файла становятся доступны и готовы к использованию. Содержимое, однако, может продолжать загружаться. Объект LoaderInfo отправляет событие <codeph>init</codeph>, когда выполняются два следующих условия:
 <ul>
     <li>Доступны все свойства и методы, связанные с загруженным объектом и с объектом LoaderInfo.</li>
     <li>Завершена работа конструкторов для всех нижестоящих объектов.</li>
     <li>Код ActionScript в первом кадре основной временной шкалы загруженного SWF-файла был полностью выполнен.</li>
 </ul>
 
 <p>Например, событие <codeph>Event.INIT</codeph> отправляется после загрузки первого кадра ролика или анимации. Тогда ролик становится доступным и может быть добавлен в список отображения. Загрузка ролика полностью, однако, может занять больше времени. Событие <codeph>Event.COMPLETE</codeph> отправляется только при полной загрузке ролика.</p>
 
 <p>Событие <codeph>init</codeph> всегда предшествует событию <codeph>complete</codeph>.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Отправляется после успешной загрузки данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после успешной загрузки данных. Другими словами, это событие отправляется при завершении загрузки всего содержимого. Событие <codeph>complete</codeph> всегда отправляется после события <codeph>init</codeph>. Событие <codeph>init</codeph> отправляется, когда объект становится доступным, хотя загрузка содержимого может продолжаться.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:LoaderInfo:getLoaderInfoByDefinition"><apiName>getLoaderInfoByDefinition</apiName><shortdesc>
     Возвращает объект LoaderInfo, связанный с SWF-файлом, определенным в качестве объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Вызывающий объект выполняется не в доверенной изолированной программной среде.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Связанный объект LoaderInfo. Возвращает значение <codeph>null</codeph> при вызове в неотладочных сборках (или когда функция отладки выключена) или если указанный <codeph>object</codeph> не имеет связанного объекта LoaderInfo (например, некоторые объекты, используемые средой выполнения AIR).
	 
	 </apiDesc><apiOperationClassifier>flash.display:LoaderInfo</apiOperationClassifier></apiReturn><apiParam><apiItemName>object</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект, для которого нужно получить связанный объект LoaderInfo.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает объект LoaderInfo, связанный с SWF-файлом, определенным в качестве объекта.
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:LoaderInfo:actionScriptVersion:get"><apiName>actionScriptVersion</apiName><shortdesc>
	 Версия ActionScript загруженного SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Если файл загружен недостаточно для получения запрашиваемой информации.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Если файл не является SWF-файлом.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Версия ActionScript загруженного SWF-файла. Версия языка задается с помощью перечислений в классе ActionScriptVersion, таких как <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> и <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>.
	 
	 <p><b>Примечание.</b> Это свойство всегда имеет значение <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> или <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>. ActionScript 1.0 и 2.0 указываются как <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> (версия 2.0). Это свойство служит только для того, чтобы отличать ActionScript 1.0 и 2.0 от ActionScript 3.0.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ActionScriptVersion"><linktext>flash.display.ActionScriptVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:applicationDomain:get"><apiName>applicationDomain</apiName><shortdesc>
	 При загрузке внешнего SWF-файла все определения ActionScript 3.0 в загруженном классе сохраняются в свойстве applicationDomain.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need better description and example.  
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier><apiException><apiDesc>Изолированная программная среда безопасности данного вызывающего объекта не имеет доступа к данному домену приложений.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 При загрузке внешнего SWF-файла все определения ActionScript 3.0 в загруженном классе сохраняются в свойстве <codeph>applicationDomain</codeph>.
	 
	 <p>Все программные коды в SWF-файле определены для существования в домене приложения. Текущим доменом приложения является домен, где выполняется основное приложение. Системный домен содержит все домены приложений, включая текущий домен и все классы проигрывателя Flash Player или Adobe AIR.</p>
	 
	 <p>Все домены приложений, кроме системного, имеют связанный родительский домен. Родительским доменом свойства <codeph>applicationDomain</codeph> основного приложения является системный домен. Загруженные классы определяются только в том случае, если они уже не определены в своих родительских классах. Нельзя перезаписать определение загруженного класса новым определением.</p>
	 
	 <p>Примеры использования доменов приложений см. в главе «Среда клиентской системы» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:bytes:get"><apiName>bytes</apiName><shortdesc>
	 Байты, связанные с объектом LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>Если объект, обращающийся к данному API-интерфейсу, не может получить доступ к загруженному объекту из-за ограничений по безопасности. Это может происходить, например, когда объект Loader пытается обратиться к свойству <codeph>contentLoaderInfo.content</codeph> и не получает права на доступ к загруженному содержимому по соображениям безопасности.
	 
	 <p>Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Байты, связанные с объектом LoaderInfo. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 Число загруженных байт мультимедиа-содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Число загруженных байт мультимедиа-содержимого. Когда это число равно значению <codeph>bytesTotal</codeph>, загружено все содержимое.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 Число упакованных байт во всем мультимедийном файле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Число упакованных байт во всем мультимедийном файле.
	 
	 <p>До отправки первого события <codeph>progress</codeph> соответствующим объектом Loader данного объекта LoaderInfo, <codeph>bytesTotal</codeph> имеет значение 0. После отправки события <codeph>progress</codeph> объектом Loader <codeph>bytesTotal</codeph> отражает фактическое количество байт для загрузки.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
	 Означает доверительные отношения со стороны содержимого (дочернего элемента) к загрузчику (родителю).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Выдается исключение, если файл загружен недостаточно для получения запрашиваемой информации.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Означает доверительные отношения со стороны содержимого (нижестоящего элемента) к загрузчику (вышестоящему элементу). Если нижестоящий элемент имеет право доступа к вышестоящему, значение – <codeph>true</codeph>; в противном случае значение – <codeph>false</codeph>. Это свойство имеет значение <codeph>true</codeph>, если нижестоящий объект вызвал метод <codeph>allowDomain()</codeph> для предоставления права доступа вышестоящему домену или если в нижестоящем домене загружена политика URL-адресов, предоставляющая доступ вышестоящему домену. Если потомок и предок находятся в том же домене, это свойство имеет значение <codeph>true</codeph>.
	 
	 <p>Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:childSandboxBridge:get"><apiName>childSandboxBridge</apiName><shortdesc>
	 Объект, который может быть задан кодом загруженного содержимого, чтобы сделать свойства и методы доступными для кода в изолированной программной среде объекта Loader.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Только содержимое в изолированной программной среде загруженного содержимого может задать это свойство.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Объект, который может быть задан кодом загруженного содержимого, чтобы сделать свойства и методы доступными для кода в изолированной программной среде объекта Loader. <i>Мост изолированной программной среды</i> позволяет содержимому не из домена приложения получить управляемый доступ к сценариям в изолированной программной среде приложения AIR, и наоборот. Этот мост служит своеобразным шлюзом между изолированными программными средами, обеспечивая открытое взаимодействие между изолированной программной средой приложения и другими изолированными средами. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/parentSandboxBridge"><linktext>parentSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:content:get"><apiName>content</apiName><shortdesc>
	 Загруженный объект, связанный с данным объектом LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>Если объект, обращающийся к данному API-интерфейсу, не может получить доступ к загруженному объекту из-за ограничений по безопасности. Это может происходить, например, когда объект Loader пытается обратиться к свойству <codeph>contentLoaderInfo.content</codeph> и не получает права на доступ к загруженному содержимому по соображениям безопасности.
	 
	 <p>Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Загруженный объект, связанный с данным объектом LoaderInfo. 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:contentType:get"><apiName>contentType</apiName><shortdesc>
	 Тип MIME загруженного файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Тип MIME загруженного файла. Имеет значение <codeph>null</codeph>, если файл загружен недостаточно для определения его типа. В следующем списке перечислены возможные значения.
	 
	 <ul>
	 	
	 	<li><codeph>"application/x-shockwave-flash"</codeph></li>
	 
	 	<li><codeph>"image/jpeg"</codeph></li>
	 
	 	<li><codeph>"image/gif"</codeph></li>
	 
	 	<li><codeph>"image/png"</codeph></li>
	 
	 </ul>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 Номинальная частота кадров загруженного SWF-файла (в кадрах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Если файл загружен недостаточно для получения запрашиваемой информации.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Если файл не является SWF-файлом. 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Номинальная частота кадров загруженного SWF-файла (в кадрах в секунду). Значение часто бывает целым числом, хотя это не обязательно.
	 
	 <p>Это значение может отличаться от фактически используемой частоты кадров. Проигрыватель Flash Player или Adobe AIR одновременно использует одну частоту кадров для всех загруженных SWF-файлов. Она определяется номинальной частотой кадров основного SWF-файла. Иногда невозможно достичь основной частоты кадров в зависимости от аппаратного обеспечения, звуковой синхронизации и других факторов.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:height:get"><apiName>height</apiName><shortdesc>
	 Номинальная высота загруженного файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Если файл загружен недостаточно для получения запрашиваемой информации.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Номинальная высота загруженного файла. Это значение может отличаться от фактической высоты области отображения содержимого, так как масштаб загруженного содержимого или его родительских экранных объектов может изменяться.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loader:get"><apiName>loader</apiName><shortdesc>
	 Объект Loader, связанный с данным объектом LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Loader</apiValueClassifier><apiException><apiDesc>Если объект, обращающийся к данному API-интерфейсу, не может получить доступ к объекту Loader из-за ограничений по безопасности. Это может происходить, например, когда загруженный SWF-файл пытается обратиться к свойству <codeph>loaderInfo.loader</codeph> и не получает права доступа к загружающему SWF-файлу по соображениям безопасности.
	 
	 <p>Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Объект Loader, связанный с данным объектом LoaderInfo. Если этот объект LoaderInfo является свойством <codeph>loaderInfo</codeph> экземпляра основного класса SWF-файла, с ним не связывается объект Loader.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loaderURL:get"><apiName>loaderURL</apiName><shortdesc>
	 URL-адрес SWF-файла, который запустил загрузку мультимедийного содержимого описанного в данном объекте LoaderInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 URL-адрес SWF-файла, который запустил загрузку мультимедийного содержимого описанного в данном объекте LoaderInfo. Для экземпляра основного класса SWF-файла этот URL-адрес совпадает с собственным URL-адресом этого файла.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parameters:get"><apiName>parameters</apiName><shortdesc>
	 Объект, содержащий пары имен и значений, представляющих параметры для загруженного SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Объект, содержащий пары имен и значений, представляющих параметры для загруженного SWF-файла.
	 
	 <p>Можно использовать цикл <codeph>for-in</codeph> для извлечения всех имен и значений из объекта <codeph>parameters</codeph>.</p>
	 
	 <p>Существует два источника параметров: строка запроса в URL основного SWF-файла и значения HTML-параметра <codeph>FlashVars</codeph> (оно затрагивает только основной SWF-файл).</p>
	 
	 <p>Свойство <codeph>parameters</codeph> заменяет технологию ActionScript 1.0 и 2.0, используемую для передачи параметров SWF-файлов в виде свойств основной временной шкалы.</p>
	 
	 <p>Значение свойства <codeph>parameters</codeph> имеет значение null для объектов Loader, содержащих SWF-файлы, использующие ActionScript 1.0 или 2.0.. Это могут быть только SWF-файлы, использующие ActionScript 3.0, содержатся только в объектах Loader с ненулевым значением.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc>
	 Означает доверительные отношения со стороны загрузчика (вышестоящего элемента) к содержимому (нижестоящему элементу).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Выдается исключение, если файл загружен недостаточно для получения запрашиваемой информации.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Означает доверительные отношения со стороны загрузчика (вышестоящего элемента) к содержимому (нижестоящему элементу). Если предшественник имеет право доступа к нижестоящему элементу, то <codeph>true</codeph>; иначе <codeph>false</codeph>. Это свойство имеет значение <codeph>true</codeph>, если вышестоящий объект вызвал метод <codeph>allowDomain()</codeph> для предоставления права доступа нижестоящему домену или если в вышестоящем домене загружена политика URL-адресов, предоставляющая доступ нижестоящему домену. Если нижестоящий и вышестоящий элементы находятся в том же домене, это свойство имеет значение <codeph>true</codeph>.
	 
	 <p>Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentSandboxBridge:get"><apiName>parentSandboxBridge</apiName><shortdesc>
	 Объект, который может быть задан с помощью кода в изолированной программной среде объекта Loader, чтобы сделать свойства и методы доступными для кода загруженного содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>Только содержимое в изолированной программной среде объекта Loader может задать это свойство.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Объект, который может быть задан с помощью кода в изолированной программной среде объекта Loader, чтобы сделать свойства и методы доступными для кода загруженного содержимого. <i>Мост изолированной программной среды</i> позволяет содержимому не из домена приложения получить управляемый доступ к сценариям в изолированной программной среде приложения AIR, и наоборот. Этот мост служит своеобразным шлюзом между изолированными программными средами, обеспечивая открытое взаимодействие между изолированной программной средой приложения и другими изолированными средами. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/childSandboxBridge"><linktext>childSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:sameDomain:get"><apiName>sameDomain</apiName><shortdesc>
	 Показывает доменную связь между загрузчиком и содержимым: true (если у них общий исходный домен) или false (в противном случае).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> Выдается исключение, если файл загружен недостаточно для получения запрашиваемой информации.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Показывает доменную связь между загрузчиком и содержимым: <codeph>true</codeph> (если у них общий исходный домен) или <codeph>false</codeph> (в противном случае).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:sharedEvents:get"><apiName>sharedEvents</apiName><shortdesc>
	 Экземпляр EventDispatcher, с помощью которого возможен обмен событиями через зоны с разным уровнем безопасности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.events:EventDispatcher</apiValueClassifier></apiValueDef><apiDesc>
	 Экземпляр EventDispatcher, с помощью которого возможен обмен событиями через зоны с разным уровнем безопасности. Даже если объект Loader и загруженное содержимое находятся в доменах защиты, между которыми отсутствуют отношения доверия, они все равно могут получить свойство <codeph>sharedEvents</codeph> и использовать этот объект для отправки и получения событий.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:swfVersion:get"><apiName>swfVersion</apiName><shortdesc>
	 Версия формата загруженного SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Если файл загружен недостаточно для получения запрашиваемой информации.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Если файл не является SWF-файлом.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Версия формата загруженного SWF-файла. Формат файла задается с помощью перечислений в классе SWFVersion, например <codeph>SWFVersion.FLASH7</codeph> и <codeph>SWFVersion.FLASH9</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SWFVersion"><linktext>flash.display.SWFVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:url:get"><apiName>url</apiName><shortdesc>
	 URL-адрес загружаемого мультимедийного содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 URL-адрес загружаемого мультимедийного содержимого.
	 
	 <p>Перед отправкой первого события <codeph>progress</codeph> соответствующим объектом Loader данного объекта LoaderInfo значение свойства <codeph>url</codeph> может отображать только исходный URL-адрес, заданный в вызове метода <codeph>load()</codeph> объекта Loader. После первого события <codeph>progress</codeph> свойство <codeph>url</codeph> отображает окончательный URL-адрес мультимедийного содержимого после того, как выполнено разрешение всех перенаправлений и относительных URL.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:width:get"><apiName>width</apiName><shortdesc>
	 Номинальная ширина загруженного содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>Если файл загружен недостаточно для получения запрашиваемой информации.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Номинальная ширина загруженного содержимого. Это значение может отличаться от фактической ширины области отображения содержимого, так как масштаб загруженного содержимого или его вышестоящих экранных объектов может изменяться.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageQuality"><apiName>StageQuality</apiName><shortdesc>
Класс StageQuality передает значения для свойства Stage.quality.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс StageQuality передает значения для свойства <codeph>Stage.quality</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/quality"><linktext>flash.display.Stage.quality</linktext></link></related-links><apiValue id="flash.display:StageQuality:BEST"><apiName>BEST</apiName><shortdesc>
Задает очень высокое качество визуализации: графика сглаживается по сетке 4 x 4 пикселя, растровые изображения всегда сглаживаются.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>best</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает очень высокое качество визуализации: графика сглаживается по сетке 4 x 4 пикселя, растровые изображения всегда сглаживаются.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
Задает высокое качество визуализации: графика сглаживается по сетке 4 x 4 пикселя, растровые изображения сглаживаются, если ролик статичен.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>high</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает высокое качество визуализации: графика сглаживается по сетке 4 x 4 пикселя, растровые изображения сглаживаются, если ролик статичен. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:LOW"><apiName>LOW</apiName><shortdesc>
Задает низкое качество визуализации: графика не сглаживается, растровые изображения также не сглаживаются.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>low</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает низкое качество визуализации: графика не сглаживается, растровые изображения также не сглаживаются. Этот параметр не поддерживается в Adobe AIR.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
Задает среднее качество визуализации: графика сглаживается по сетке 2 x 2 пикселя, растровые изображения не сглаживаются.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>medium</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает среднее качество визуализации: графика сглаживается по сетке 2 x 2 пикселя, растровые изображения не сглаживаются. Этот параметр подходит для роликов, не содержащих текст. Этот параметр не поддерживается в Adobe AIR.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 Класс BitmapData позволяет работать с данными (пикселями) растрового изображения объекта Bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Позволяет работать с растровыми данными объекта Bitmap.
 
 </apiTipText></apiTipTexts><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс BitmapData позволяет работать с данными (пикселями) <ph platform="actionscript">Bitmap object</ph> <ph platform="javascript">bitmap image</ph>. Методы класса BitmapData можно использовать для создания прозрачных или непрозрачных растровых изображений произвольного размера и выполнять с ними различные операции. <ph platform="actionscript"> Также можно обращаться к BitmapData для получения растрового изображения, загружаемого с помощью класса <codeph>flash.display.Loader</codeph>. </ph> 
 
 <p platform="actionscript">Этот класс позволяет отделить операции по визуализации растрового изображения от внутренних подпрограмм обновления отображения проигрывателя Flash Player. Путем манипуляции с объектом BitmapData напрямую можно создавать сложные изображения без необходимости постоянно перерисовывать содержимое из векторных данных в каждом кадре.</p>
 
 <p platform="actionscript">Методы класса BitmapData поддерживают эффекты, не доступные через фильтры, предусмотренные для нерастровых экранных объектов.</p>
 
 <p>Объект BitmapData содержит массив пиксельных данных. Эти данные могут представлять собой либо полностью непрозрачное растровое изображение, либо прозрачное растровое изображение с данными альфа-канала. Объекты BitmapData любого типа сохраняются в виде буфера 32-разрядных целых чисел. Каждое 32-разрядное целое число определяет свойства одного пикселя в растровом изображении.</p>
 
 <p>Каждое 32-разрядное целое число представляет собой комбинацию 8-разрядных значений каналов (от 0 до 255), описывающих альфа-прозрачность и значения красного, зеленого и синего (ARGB) пикселя. (Для значений ARGB наиболее значимый байт представляет значение альфа-канала, а за ним следуют красный, зеленый и синий.)</p>
 
 <p>Четыре канала (альфа-канал, красный, зеленый и синий) представлены числами при использовании в методе <codeph>BitmapData.copyChannel()</codeph> или свойствами <codeph>DisplacementMapFilter.componentX</codeph> и <codeph>DisplacementMapFilter.componentY</codeph>, и эти числа представлены следующими константами класса BitmapDataChannel:</p>
 
 <ul>
 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
  <li><codeph>BitmapDataChannel.RED</codeph></li>
 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
</ul>
 
 <p platform="actionscript">Объекты BitmapData можно присоединить к объекту Bitmap с помощью свойства <codeph>bitmapData</codeph> объекта Bitmap.</p>
 
 <p platform="actionscript">Объект BitmapData можно использовать для заполнения объекта Graphics с помощью метода<codeph>Graphics.beginBitmapFill()</codeph>.</p>
 
 <p>Во время выполнения AIR классы DockIcon, Icon, InteractiveIcon и SystemTrayIcon имеют свойство <codeph>bitmaps</codeph>, которое является массивом объектов BitmapData, определяющих растровые изображения значка.</p>
 
 <p>В AIR 1.5 и Flash Player 10 максимальный размер объекта BitmapData составляет 8,191 пикселя в ширину или высоту, а общее количество пикселей не может превышать 16,777,215. (Т. е. если ширина объекта BitmapData составляет 8,191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину.</p>
 
 <p>Вызовы любого метода или свойства объекта BitmapData выдают ошибку ArgumentError, если объект BitmapData недействителен (например, если <codeph>height == 0</codeph> и <codeph>width == 0</codeph>) или если он был удален с помощью метода dispose(). </p>
 
 </apiDesc><example conref="examples\BitmapDataExample.as"> В следующем примере класс BitmapDataExample используется для загрузки изображения Image.gif в объект DisplayObject в месте по умолчанию (0, 0). Затем копия Image.gif помещается справа от оригинала, в котором применяются новые цвета к пикселям, тестируемым с помощью метода <codeph>threshold()</codeph>. Это можно сделать, выполнив следующие действия.
 <ol>
     <li>Создается свойство <codeph>url</codeph>, описывающее местоположение и имя файла изображения.</li>
     <li>Конструктор класса создает объект Loader, который затем создает экземпляр прослушивателя событий, отправляемых по завершении обработки изображения методом <codeph>completeHandler()</codeph>.</li>
        <li>Затем объект URLRequest с именем <codeph>request</codeph> передается методу <codeph>loader.load()</codeph>, который загружает изображение в память с помощью экранного объекта.</li>
     <li>После этого изображение добавляется в список отображения, который отображает изображение на экране в положении с координатами <i>x = 0, y = 0</i>.</li>
     <li>Затем метод <codeph>completeHandler()</codeph> выполняет следующие действия. 
     <ul>
         <li>Создает второй объект Loader и инициализированный вместе с ним объект Bitmap.</li>
         <li>Создает второй объект Bitmap, <codeph>duplicate</codeph>, который в свою очередь вызывает метод <codeph>duplicateImage()</codeph>, создающий дубликат исходного изображения. </li>
         <li>Создает объект BitmapData, который назначается объекту BitmapData объекта <codeph>duplicate</codeph>.</li>
         <li>Создает новый объект Rectangle, инициализированный с теми же координатами, шириной и высотой, что и исходное изображение.</li>
         <li>Создает новый объект Point с координатами по умолчанию: <i>x = 0, y = 0</i>.</li>
         <li>Создает следующие переменные:
         <ul>
             <li><codeph>operation</codeph> ? Использует новый цвет при пороговом значении, которое больше или равно исходному значению.</li>
             <li><codeph>threshold</codeph> ? Значение, с которым сравнивается каждый пиксель (в данном примере это светло-серый цвет со значением альфа-канала 0xCC). </li>
             <li><codeph>color</codeph> ? Цвет, указанный для пикселей, проходящих пороговый тест; в данном случае это желтый цвет.</li>
             <li><codeph>mask</codeph> ? Диаметрально противоположный цвет (прозрачный синий).</li>
             <li><codeph>copySource</codeph> ? Установлено на значение <codeph>false</codeph>, указывающее на то, что значения пикселей не копируются в том случае, если они не проходят пороговое значение. Это значение не имеет смысла, потому что изображение продублировано и изменяются только пиксели, прошедшие пороговый тест.</li>
      </ul></li>
         <li>Вызывает метод <codeph>threshold()</codeph> с использованием предшествующих переменных. В результате мы получаем уравнение порога: <codeph>если (текущее значение пикселя &amp; 0x000000FF) больше или равно (0xCCCCCCCC &amp; 0x000000FF), то для него устанавливается значение 0xFFFFFF00</codeph>. </li>
  </ul></li>
 </ol>
 <p> <b>Примечания.</b>
 <ul>
     <li>SWF-файл потребуется откомпилировать с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к локальным файлам».
 </li>
     <li>Данный пример требует, чтобы файл с именем Image.gif находился в том же каталоге, что и SWF-файл.
 </li>
  <li>Рекомендуется использовать изображение с шириной не больше 80 пикселей. </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example><example conref="examples\BitmapDataExample2.as"/></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/bitmapData"><linktext>flash.display.Bitmap.bitmapData</linktext></link><link href="flash.desktop.xml#DockIcon/bitmaps"><linktext>flash.desktop.DockIcon.bitmaps</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.desktop.xml#Icon/bitmaps"><linktext>flash.desktop.Icon.bitmaps</linktext></link><link href="flash.desktop.xml#InteractiveIcon/bitmaps"><linktext>flash.desktop.InteractiveIcon.bitmaps</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.desktop.xml#SystemTrayIcon/bitmaps"><linktext>flash.desktop.SystemTrayIcon.bitmaps</linktext></link></related-links><apiConstructor id="flash.display:BitmapData:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 	 Создает объект BitmapData заданной ширины и высоты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>ширина и/или высота превышает максимальное значение.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Ширина растрового изображения в пикселях.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Высота растрового изображения в пикселях.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>transparent</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Определяет, поддерживает ли растровое изображение попиксельную прозрачность. Значение по умолчанию — <codeph>true</codeph> (прозрачное). Чтобы создать полностью прозрачное растровое изображение, параметру <codeph>transparent</codeph> нужно присвоить значение <codeph>true</codeph>, а параметру <codeph>fillColor</codeph> — 0x00000000 (или 0). Если задать свойству <codeph>transparent</codeph> значение <codeph>false</codeph>, то можно незначительно улучшить производительность визуализации. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>32-разрядное ARGB-значение цвета, используемое для заливки области растрового изображения. Значение по умолчанию — 0xFFFFFFFF (сплошной белый).
	 
 	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Создает объект BitmapData заданной ширины и высоты. Если задать значение для параметра <codeph>fillColor</codeph>, каждый пиксель растрового изображения будет окрашен в этот цвет.
	 
	 <p>По умолчанию растровое изображение создается прозрачным, если не передано значение <codeph>false</codeph> для параметра <codeph>transparent</codeph>. Создав непрозрачное растровое изображение, его нельзя сделать прозрачным. Каждый пиксель непрозрачного растрового изображения использует только 24 бита информации о цветовых каналах. Если растровое изображение определено как прозрачное, каждый пиксель использует 32 бита информации о цветовых каналах, включая канал альфа-прозрачности.</p>
	 
	 <p>В AIR 1.5 и Flash Player 10 максимальный размер объекта BitmapData составляет 8,191 пикселя в ширину или высоту, а общее количество пикселей не может превышать 16,777,215. (Т. е. если ширина объекта BitmapData составляет 8,191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Если задать значение ширины или высоты, превышающее 2880, новый экземпляр не будет создан.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:BitmapData:applyFilter"><apiName>applyFilter</apiName><shortdesc>
	 Создает фильтрованное изображение по исходному изображению и объекту filter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect, destPoint или filter имеют значение null.
 	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Прозрачность объектов BitmapData несовместима с операцией фильтрации.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число, указывающее на успешность применения фильтра. Если возвращено значение 0, фильтр был применен успешно. Если возвращено отрицательное число, в процессе применения фильтра произошла ошибка.
	 
	 </apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.

	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>Объект фильтра, который будет использоваться для выполнения фильтрации. Каждый тип фильтра имеет определенные требования, приведенные ниже.
	 
	 <ul><li><b>BlurFilter</b> — этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения. Если форматы изображений не совпадают, то при сопоставлении формата конечного изображения в ходе фильтрации создается копия исходного изображения.</li>
	 
	 <li><b>BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter</b> — конечное изображение этих фильтров должно быть прозрачным. При вызове фильтра DropShadowFilter или GlowFilter создается изображение, содержащее данные альфа-канала для тени или бликов. Он не создает тень на конечном изображении. Если использовать эти фильтры для непрозрачного конечного изображения, создается исключение.</li>
	 
	 <li><b>ConvolutionFilter</b> — этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения.</li>
	 
	 <li><b>ColorMatrixFilter</b> — этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения.</li>
	 
	 <li><b>DisplacementMapFilter</b> — этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения, но форматы исходного и конечного изображений должны совпадать.</li></ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Создает фильтрованное изображение по исходному изображению и объекту filter.
	 
	 <p>Этот метод базируется на поведении встроенных объектов фильтра, которые определяют целевой прямоугольник, затрагиваемый вводным исходным прямоугольником.</p>
	 
	 <p>Полученное после применения фильтра изображение может быть больше вводного. Например, если класс BlurFilter используется, чтобы размыть очертания исходного прямоугольника с координатами (50,50,100,100) и точку назначения с координатами (10,10), то область конечного изображения будет больше (10,10,60,60) в результате размытости. Это происходит на внутреннем уровне при вызове метода <codeph>applyFilter()</codeph>.</p>
	 
	 <p>Если параметр <codeph>sourceRect</codeph> параметра <codeph>sourceBitmapData</codeph> является внутренней областью, например (50,50,100,100) в изображении 200 x 200, фильтр использует исходные пиксели за пределами параметра <codeph>sourceRect</codeph>, чтобы создать целевой прямоугольник.</p>
	 
	 <p>Если объект BitmapData является объектом, указанным в качестве параметра <codeph>sourceBitmapData</codeph>, приложение использует временную копию объекта для выполнения фильтрации. Если требуется обеспечить максимальную производительность, такую ситуацию лучше избегать.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.applyFilter.1.as"> В следующем примере показано применение размывающего фильтра к экземпляру BitmapData.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>flash.filters.BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>flash.filters.BlurFilter</linktext></link><link href="flash.filters.xml#ColorMatrixFilter"><linktext>flash.filters.ColorMatrixFilter</linktext></link><link href="flash.filters.xml#ConvolutionFilter"><linktext>flash.filters.ConvolutionFilter</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>flash.filters.DropShadowFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>flash.filters.GlowFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:clone"><apiName>clone</apiName><shortdesc>
	 Возвращает новый объект BitmapData, являющийся клоном исходного экземпляра с точной копией содержащегося в нем растрового изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Новый объект BitmapData, идентичный исходному.
	 
	 </apiDesc><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Создает новый объект BitmapData, являющийся точной копией исходного растрового изображения.

	  

	  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает новый объект BitmapData, являющийся клоном исходного экземпляра с точной копией содержащегося в нем растрового изображения.
	 
	 </apiDesc><example conref="examples\BitmapData.clone.1.as"> В следующем примере клонируется экземпляр BitmapData и показывается, что изменение клонированного экземпляра BitmapData не затрагивает оригинал.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:colorTransform"><apiName>colorTransform</apiName><shortdesc>
	 Изменяет значения цветов в заданной области растрового изображения с помощью объекта ColorTransform.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты rect и colorTransform имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Объект Rectangle, определяющий область изображения, в которой применяется объект ColorTransform.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>Объект ColorTransform, описывающий применяемые значения преобразования цвета.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Изменяет значения цветов в заданной области растрового изображения с помощью объекта <codeph>ColorTransform</codeph>. Если прямоугольник соответствует границам растрового изображения, этот метод преобразует значения цветов для всего изображения.
	 
	 </apiDesc><example conref="examples\BitmapData.colorTransform.1.as"> В следующем примере показано применение преобразования цвета к левой половине объекта BitmapData (прямоугольнику).
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:compare"><apiName>compare</apiName><shortdesc>
	 
	 Сравнивает два объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объект otherBitmapData имеет значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Если два объекта BitmapData имеют одинаковые размеры (ширину и высоту), метод возвращает новый объект BitmapData с различиями между двумя объектами (см. главное обсуждение темы). Если объекты BitmapData идентичны, метод возвращает значение 0. Если объекты BitmapData имеют разную ширину, метод возвращает значение -3. Если объекты BitmapData имеют разную высоту, метод возвращает значение -4. 
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>otherBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Объект BitmapData, сравниваемый с исходным объектом BitmapData.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Сравнивает два объекта BitmapData. Если два объекта BitmapData имеют одинаковые размеры (ширину и высоту), метод возвращает новый объект BitmapData, в котором каждый пиксель представляет «разницу» между пикселями двух исходных объектов.
	 
	 <ul>
	 
	 	<li>Если пиксели равны, то пиксель разницы будет иметь значение 0x00000000. </li>
	 
	 	<li>Если у двух пикселей разные RGB-значения (игнорирующие значение альфа-канала), то пиксель разницы будет иметь значение 0xRRGGBB, где RR/GG/BB — это индивидуальные значения разницы между красными, зелеными и синими каналами (значение пикселя в исходном объекте минус значение пикселя в объекте <codeph>otherBitmapData</codeph>). В данном случае различия значений альфа-канала игнорируются. </li> 
	 
	 	<li>Если же альфа-канал имеет другое значение, то значением пикселя будет 0x<i>ZZ</i>FFFFFF, где <i>ZZ</i> - это разница между альфа-значениями (альфа-значение исходного объекта минус альфа-значение объекта <codeph>otherBitmapData</codeph>).</li>
	 
	 </ul>
	 
	 <p>В качестве примера рассмотрим два следующих объекта BitmapData.</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
     </codeblock>
	 
	 <p><b>Примечание.</b> Цвета, использованные для заливки двух объектов BitmapData, имеют немного разные RGB-значения (0xFF0000 и 0xFFAA00). В результате использования метода <codeph>compare()</codeph> создается новый объект BitmapData, каждый пиксель которого показывает разницу RGB-значений между двумя растровыми изображениями.</p>
	 
	 <p>Рассмотрим следующие два объекта BitmapData, у которых одинаковые RGB-цвета, но разные значения альфа-канала.</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
	 </codeblock>
	 
	 <p>В результате использования метода <codeph>compare()</codeph> создается новый объект BitmapData, каждый пиксель которого показывает разницу значений альфа-канала между двумя растровыми изображениями.</p>
	 
	 <p>Если объекты BitmapData идентичны (имеют одинаковую высоту, ширину и значения пикселей), метод возвращает значение 0.</p>
	 
	 <p>Если объекты BitmapData имеют разную ширину, метод возвращает значение -3. </p>
	 
	 <p>Если объекты BitmapData имеют разную высоту, но одинаковую ширину, метод возвращает значение -4.</p>
	 
	 <p>В следующем примере сравниваются два объекта Bitmap с разной шириной (50 и 60).</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 </apiDesc><example conref="examples\BitmapData.compare.1.as"> В следующем примере показывается значение пикселя объекта BitmapData, полученное в результате сравнения двух объектов BitmapData с одинаковыми размерами.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:copyChannel"><apiName>copyChannel</apiName><shortdesc>
	 Переносит данные из одного канала отдельного объекта BitmapData или текущего объекта BitmapData в канал текущего объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий объект BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Исходный объект Rectangle. Чтобы скопировать только данные каналов из меньшей по размеру области растрового изображения, задайте исходный прямоугольник, размер которого меньше общего размера объекта BitmapData. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Целевой объект Point, представляющий верхний левый угол прямоугольной области, в которую помещаются новые данные канала. Чтобы скопировать только данные канала из одной области в другую в конечном изображении, укажите другую точку вместо исходной (0,0).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Исходный канал. Используйте значение класса BitmapDataChannel (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Целевой канал. Используйте значение класса BitmapDataChannel (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph>, <codeph>BitmapDataChannel.ALPHA</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переносит данные из одного канала отдельного объекта BitmapData или текущего объекта BitmapData в канал текущего объекта BitmapData. Все данные в других каналах конечного объекта BitmapData сохраняются.
	 
	 <p>Исходным или конечным значением канала может быть одно из следующих: </p>
	 <ul>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 </ul>

	 
	 </apiDesc><example conref="examples\BitmapData.copyChannel.1.as"> В следующем примере копируется красный канал объекта BitmapData в его собственный синий канал в области с размером 20 x 20 пикселей.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:copyPixels"><apiName>copyPixels</apiName><shortdesc>
	 Представляет собой процедуру быстрой обработки точек изображений без растяжения, поворота и цветовых эффектов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Вводное растровое изображение, из которого копируются пиксели. Исходным изображением может быть другой экземпляр BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка назначения, представляющая верхний левый угол прямоугольной области, в которую помещаются новые пиксели канала.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Вторичный источник альфа-канала объекта BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Точка в альфа-источнике объекта BitmapData, соответствующая верхнему левому углу параметра <codeph>sourceRect</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mergeAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Чтобы использовать альфа-канал, нужно задать значение <codeph>true</codeph>. Чтобы копировать пиксели без альфа-канала, нужно задать значение <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Представляет собой процедуру быстрой обработки точек изображений без растяжения, поворота и цветовых эффектов. Этот метод копирует прямоугольную область исходного изображения в прямоугольную область того же размера в точке назначения конченого объекта BitmapData.
	 
	 <p>Если включены параметры <codeph>alphaBitmap</codeph> и <codeph>alphaPoint</codeph>, можно использовать вторичное изображение в качестве источника альфа-канала для исходного изображения. Если исходное изображение имеет данные альфа-канала, то для переноса пикселей из исходного изображения в конечное используются оба набора данных альфа-канала. Параметр <codeph>alphaPoint</codeph> — это точка на альфа-изображении, соответствующая верхнему левому углу исходного прямоугольника. Все пиксели, не находящиеся в области пересечения исходного изображения и альфа-изображения, не копируются в конечное изображение.</p>
	 
	 <p>Свойство <codeph>mergeAlpha</codeph> контролирует, используется или нет альфа-канал при копировании одного прозрачного изображение в другое прозрачное изображение. Чтобы копировать пиксели с данными альфа-канала, задайте свойству <codeph>mergeAlpha</codeph> значение <codeph>true</codeph>. По умолчанию свойство <codeph>mergeAlpha</codeph> имеет значение <codeph>false</codeph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.copyPixels.1.as"> В следующем примере копируются пиксели из области 20 х 20 пикселей одного объекта BitmapData в другой объект BitmapData.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:dispose"><apiName>dispose</apiName><shortdesc>
	 Очищает память, задействованную для хранения объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Очищает память, задействованную для хранения объекта BitmapData. 
	 
	 <p>Когда для изображения вызывается метод <codeph>dispose()</codeph>, его ширина и высота получают значение 0. Все последующие вызовы методов и свойств данного экземпляра BitmapData заканчиваются неудачно и приводят к появлению исключения. </p>
	 <p>Метод <codeph>BitmapData.dispose()</codeph> мгновенно освобождает память, занятую фактическими данными растрового изображения (растровое изображение может потреблять до 64 МБ памяти). После вызова <codeph>BitmapData.dispose()</codeph> объект BitmapData больше не может использоваться, и среда выполнения Flash выдает исключение в случае последующего вызова функции для объекта BitmapData. Однако метод <codeph>BitmapData.dispose()</codeph> не утилизирует объект BitmapData (около 128 байт); память, занимаемая фактическим объектом BitmapData, освобождается при его утилизации сборщиком мусора.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.dispose.1.as"> В следующем примере показан результат вызова метода объекта BitmapData после вызова метода <codeph>dispose()</codeph> (выдается исключение).
<codeblock>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.system.xml#System/gc()"><linktext>flash.system.System.gc()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:draw"><apiName>draw</apiName><shortdesc>
	 Отображает экранный объект source поверх растрового изображения с помощью векторного средства визуализации проигрывателя Flash Player или AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Параметр <codeph>source</codeph> не является объектом BitmapData или DisplayObject.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Объект <codeph>source</codeph> и (в случае с объектами Sprite и MovieClip) все его нижестоящие объекты находятся не в том же домене, что и вызывающий объект, или не находятся в содержимом, доступном вызывающему объекту посредством вызова метода <codeph>Security.allowDomain()</codeph>. Это ограничение не применимо к содержимому AIR в изолированной программной среде безопасности приложения.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Источник имеет значение null или не является действительным объектом IBitmapDrawable.
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>flash.display:IBitmapDrawable</apiOperationClassifier><apiDesc>Экранный объект или объект BitmapData для рисования объекта BitmapData. Классы DisplayObject и BitmapData реализуют интерфейс IBitmapDrawable.
	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект Matrix, используемый для масштабирования, поворота и перемещения координат растрового изображения. Если не требуется применять преобразование матрицы в изображение, задайте для этого параметра идентификационную матрицу, созданную с помощью конструктора <codeph>new Matrix()</codeph> по умолчанию, или передайте значение <codeph>null</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект ColorTransform, используемый для настройки значений цвета растрового изображения. Если объект не указан, цвета растрового изображения не преобразуются. Если вам необходимо передать этот параметр, но преобразовывать изображение не нужно, задайте для него объект ColorTransform, созданный с помощью конструктора <codeph>new ColorTransform()</codeph> по умолчанию.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>blendMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Строковое значение класса flash.display.BlendMode, задающее режим наложения, которые будет применен к полученному растровому изображению. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект Rectangle, определяющий для рисования область исходного объекта. Если это значение не задано, то обрезка не производится и исходный объект рисуется полностью.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Логическое значение, которое определяет, будет ли объект BitmapData сглаживаться при масштабировании или повороте вследствие масштабирования или поворота в параметре <codeph>matrix</codeph>. Параметр <codeph>smoothing</codeph> применяется, только если параметром <codeph>source</codeph> является объект BitmapData. Если <codeph>smoothing</codeph> имеет значение <codeph>false</codeph>, повернутое или масштабированное изображение BitmapData может получиться нечетким или с зазубренными очертаниями. Например в следующих двух изображениях в качестве параметра <codeph>source</codeph> используется один и тот же объект BitmapData, но для левого параметр <codeph>smoothing</codeph> имеет значение <codeph>true</codeph>, а для правого - <codeph>false</codeph>.
	 
	 <p><adobeimage alt="Два изображения: левое со сглаживанием и правое без сглаживание." href="../../images/bitmapData_draw_smoothing.jpg"/></p>
	 
	 <p>Рисование с параметром <codeph>smoothing</codeph> в значении <codeph>true</codeph> требует больше времени, чем со <codeph>smoothing</codeph> в значении <codeph>false</codeph>.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает экранный объект <codeph>source</codeph> поверх растрового изображения с помощью векторного средства визуализации проигрывателя <ph platform="actionscript">Flash Player или</ph> AIR. Можно задать параметры <codeph>matrix</codeph>, <codeph>colorTransform</codeph>, <codeph>blendMode</codeph> и <codeph>clipRect</codeph> назначения, чтобы управлять процессом визуализации. Также можно указать, должно ли сглаживать растровое изображение при масштабировании (это применимо только если источником является объект BitmapData).
	  
	 <p>Этот метод напрямую соответствует тому, как рисуются объекты с помощью стандартного векторного средства визуализации в интерфейсе инструмента разработки.</p>
	 
	 <p>Исходный экранный объект не использует свои примененные преобразования для этого вызова. Он обрабатывается в том виде, в котором представлен в библиотеке или файле: без преобразования матрицы, цвета и без режима наложения. Чтобы нарисовать экранный объект (например, фрагмент ролика) с помощью его собственных свойств преобразования, можно скопировать его объект свойства <codeph>transform</codeph> в свойство <codeph>transform</codeph> объекта Bitmap, использующего объект BitmapData.</p>
	 
     <p>Этот метод поддерживается через протокол RTMP в <ph platform="actionscript">Flash Player 9.0.115.0 и более поздних версиях и в</ph> Adobe AIR. Можно контролировать потоки на сервере Flash Media Server в сценарии, выполняемом на стороне сервера. Дополнительные сведения см. в разделах о свойствах <codeph>Client.audioSampleAccess</codeph> и <codeph>Client.videoSampleAccess</codeph> в документе <xref href="http://www.adobe.com/go/documentation_ru" scope="external"> <i>Справочник по языку ActionScript на стороне сервера для Adobe Flash Media Server</i></xref>.</p>
	 
	 <p platform="actionscript">Если объект source и (в случае с объектами Sprite и MovieClip) все его нижестоящие объекты не находятся в том же домене, что и вызывающий объект, или не находятся в содержимом, доступном вызывающему объекту посредством вызова метода <codeph>Security.allowDomain()</codeph>, вызов метода <codeph>draw()</codeph> выдает исключение SecurityError. Это ограничение не применимо к содержимому AIR в изолированной программной среде безопасности приложения.</p>
	 
	 <p platform="actionscript">Существуют также ограничения по использованию загруженного растрового изображения в качестве объекта <codeph>source</codeph>. Вызов метода <codeph>draw()</codeph> будет успешным, если загруженное изображение принадлежит тому же домену, что и вызывающий объект. Более того, файл междоменной политики на сервере изображения может предоставить право доступа домену содержимого SWF, вызывающего метод <codeph>draw()</codeph>. В таком случае необходимо задать свойство <codeph>checkPolicyFile</codeph> объекта LoaderContext и использовать этот объект в качестве параметра <codeph>context</codeph> при вызове метода <codeph>load()</codeph> объекта Loader, используемого для загрузки изображения. Эти ограничения не применимы к содержимому AIR в изолированной программной среде безопасности приложения.</p>
	 
	 <p>В Windows метод <codeph>draw()</codeph> не может выполнить захват содержимого SWF, встроенного в страницу HTML <ph platform="actionscript">в объекте HTMLLoader в Adobe AIR</ph>.</p>
	 
	 <p>Метод <codeph>draw()</codeph> не может выполнить захват содержимого PDF <ph platform="actionscript">в Adobe AIR</ph>. Он также не может выполнить захват содержимого SWF, встроенного в HTML-файл, в котором атрибут <codeph>wmode</codeph> имеет значение <codeph>window</codeph> <ph platform="actionscript">в Adobe AIR</ph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.draw.1.as"> В следующем примере рисуется объект TextField в объекте BitmapData.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:fillRect"><apiName>fillRect</apiName><shortdesc>
	 Заполняет прямоугольную область пикселей заданным цветом ARGB.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объект rect имеет значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольная область для заливки.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Цвет ARGB для заливки области. Цвета ARGB часто указываются в шестнадцатеричном формате, например 0xFF336699.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Заполняет прямоугольную область пикселей заданным цветом ARGB.
	 
	 </apiDesc><example conref="examples\BitmapData.fillRect.1.as"> В следующем примере прямоугольная область объекта BitmapData заливается синим цветом:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:floodFill"><apiName>floodFill</apiName><shortdesc>
	 Выполняет операцию заливки изображения, начиная с точки с координатами (x, y) и заполняя область определенным цветом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Координата <i>x</i> изображения.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Координата <i>y</i> изображения.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Цвет ARGB для заливки.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Применяет операцию заливки к изображению, начиная с точки с координатами (x, y).
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Выполняет операцию заливки изображения, начиная с точки с координатами (<i>x</i>, <i>y</i>) и заполняя область определенным цветом. Метод <codeph>floodFill()</codeph> напоминает инструмент заливки в различных программах для рисования. Цвет представляет собой цвет ARGB, содержащий информацию альфа-канала и данные цвета.
	 
	 </apiDesc><example conref="examples\BitmapData.floodFill.1.as"> В следующем примере выполняется заливка области объекта BitmapData, то есть области вокруг пикселя в точке с координатами <codeph>(10, 10)</codeph>, в которой все цвета граничат с цветом в данной точке – с красным.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:generateFilterRect"><apiName>generateFilterRect</apiName><shortdesc>
	 Определяет целевой прямоугольник, на который оказывает влияние вызов метода applyFilter() при наличии объекта BitmapData, исходного прямоугольника и объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceRect и filter имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Целевой прямоугольник, вычисленный с использованием изображения, параметра <codeph>sourceRect</codeph> и фильтра.
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>Объект фильтра, используемый для вычисления конечного прямоугольника.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Определяет целевой прямоугольник, на который повлияет вызов метода applyFilter().
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Определяет целевой прямоугольник, на который оказывает влияние вызов метода <codeph>applyFilter()</codeph> при наличии объекта BitmapData, исходного прямоугольника и объекта фильтра.
	 
	 <p>Например, размывающий фильтр обычно воздействует на область, размер которой превышает размер исходного изображения. Изображение размером 100 x 200 пикселей, отфильтрованное с использованием экземпляра BlurFilter по умолчанию, где <codeph>blurX = blurY = 4</codeph> создает целевой прямоугольник с координатами <codeph>(-2,-2,104,204)</codeph>. Метод <codeph>generateFilterRect()</codeph> позволяет заранее определять размер целевого прямоугольника, чтобы соответствующим образом изменить его размеры перед применением фильтра.</p>
	 
	 <p>Некоторые фильтры обрезают целевой прямоугольник по размеру исходного изображения. Например, внутренний фильтр <codeph>DropShadow</codeph> не увеличивает размер по сравнению с исходным изображением. В данном API-интерфейсе объект BitmapData используется в качестве исходных границ, а не исходного параметра <codeph>rect</codeph>.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.generateFilterRect.1.as"> В следующем примере метод <codeph>generateFilterRect()</codeph> используется для определения прямоугольной области, которую будет занимать изображение после применения фильтра размытия. Результаты метода <codeph>generateFilterRect()</codeph> выводятся с помощью функции <codeph>trace()</codeph>.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock> Обратите внимание, что метод <codeph>generateFilterRect()</codeph> не применяет фильтр. Вызовите метод <codeph>applyFilter()</codeph>, чтобы применить фильтр. 
</example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getColorBoundsRect"><apiName>getColorBoundsRect</apiName><shortdesc>
	 Определяет прямоугольный участок, полностью охватывающий все пиксели заданного цвета в пределах растрового изображения (если параметру findColor присвоено значение true), либо полностью охватывает все пиксели, не содержащие заданный цвет (если параметру findColor присвоено значение false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Область изображения, заполненная заданным цветом. 
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Шестнадцатеричное значение, указывающее рассматриваемые биты цвета ARGB. Значение цвета объединяется с данным шестнадцатеричным значением с использованием оператора <codeph>&amp;</codeph> (побитовое И).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Шестнадцатеричное значение, задающее цвет ARGB для соответствия (если <codeph>findColor</codeph> имеет значение <codeph>true</codeph>) или <i>не</i> соответствия (если <codeph>findColor</codeph> имеет значение <codeph>false</codeph>).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>findColor</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Если задано значение <codeph>true</codeph>, то возвращаются границы значения цвета в изображения. Если задано значение <codeph>false</codeph>, возвращаются границы области изображения, в которой этого цвета нет. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет прямоугольный участок, полностью охватывающий все пиксели заданного цвета в пределах растрового изображения (если параметру <codeph>findColor</codeph> присвоено значение <codeph>true</codeph>), либо полностью охватывает все пиксели, не содержащие заданный цвет (если параметру <codeph>findColor</codeph> присвоено значение <codeph>false</codeph>). 
	 
	 <p>Например, если имеется исходное изображение и требуется определить прямоугольник изображения, содержащий ненулевой альфа-канал, передайте в качестве параметров <codeph>{mask: 0xFF000000, color: 0x00000000}</codeph>. Если параметру <codeph>findColor</codeph> задано значение <codeph>true</codeph>, в пределах всего изображения ведется поиск границ с пикселями, для которых <codeph>(value &amp; mask) == color</codeph> (где <codeph>value</codeph> - это значение цвета пикселя). Если параметру <codeph>findColor</codeph> задано значение <codeph>false</codeph>, в пределах всего изображения ведется поиск границ пикселей, для которых <codeph>(value &amp; mask)! = color</codeph> (где <codeph>value</codeph> - это значение цвета пиксела). Чтобы определить белое пространство вокруг изображения, передайте <codeph>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</codeph>, чтобы найти границы не белых пикселей.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getColorBoundsRect.1.as"> В следующем примере создается объект BitmapData с красным цветом в верхней половине пикселей. Затем вызывается метод <codeph>getColorBoundsRect()</codeph> для определения прямоугольника, содержащего красные пиксели (0xFF0000), после чего тот же метод вызывается для определения прямоугольника, пиксели которого не красные (параметру <codeph>findColor</codeph> задается значение <codeph>false</codeph>.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getPixel"><apiName>getPixel</apiName><shortdesc>
	 Возвращает целое число, представляющее RGB-значение пикселя из объекта BitmapData в конкретной точке (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Число, представляющее RGB-значение пикселя. Если координаты (<i>x</i>, <i>y</i>) находятся за пределами изображения, метод возвращает 0. 
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение пикселя по оси <i>x</i>.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение пикселя по оси <i>y</i>.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает целое число, представляющее RGB-значение указанной точки объекта BitmapData.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает целое число, представляющее RGB-значение пикселя из объекта BitmapData в конкретной точке (<i>x</i>, <i>y</i>). Метод <codeph>getPixel()</codeph> возвращает неумноженное значение пикселя. Информация альфа-канала не возвращается.
	 
	 <p>Все пиксели в объекте BitmapData сохраняются как предварительно умноженные значения цвета. В предварительно умноженном пикселе изображения значения красного, зеленого и синего канала уже умножены на данные альфа-канала. Например, если значение альфа-канала равно нулю, то значения RGB-каналов также равны нулю независимо от их значений до умножения. Потеря данных может вызвать проблемы при выполнении операций. Все методы BitmapData принимают и возвращают неумноженные значения. Перед тем как возвращать значение, внутреннее представление пикселя преобразуется из предварительно умноженного в неумноженное. Во время операции настройки, значение пикселя предварительно умножается, и только после этого настраивается необработанный пиксель изображения.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel.1.as"> В следующем примере объект BitmapData заливается красным, а с помощью метода <codeph>getPixel()</codeph> определяется значение цвета для верхнего левого пикселя.
<codeblock>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(1, 1);
trace(pixelValue.toString(16)); // ff0000;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixel32"><apiName>getPixel32</apiName><shortdesc>
	 Возвращает значение цвета ARGB, содержащее данные альфа-канала и данные RGB.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Число, представляющее значение пикселя ARGB. Если координаты (<i>x</i>, <i>y</i>) находятся за пределами изображения, возвращается значение 0.
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение пикселя по оси <i>x</i>.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение пикселя по оси <i>y</i>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает значение цвета ARGB, содержащее данные альфа-канала и данные RGB. Этот метод подобен методу <codeph>getPixel()</codeph>, который возвращает RGB-цвет без данных альфа-канала.
	 
	 <p>Все пиксели в объекте BitmapData сохраняются как предварительно умноженные значения цвета. В предварительно умноженном пикселе изображения значения красного, зеленого и синего канала уже умножены на данные альфа-канала. Например, если значение альфа-канала равно нулю, то значения RGB-каналов также равны нулю независимо от их значений до умножения. Потеря данных может вызвать проблемы при выполнении операций. Все методы BitmapData принимают и возвращают неумноженные значения. Перед тем как возвращать значение, внутреннее представление пикселя преобразуется из предварительно умноженного в неумноженное. Во время операции настройки, значение пикселя предварительно умножается, и только после этого настраивается необработанный пиксель изображения.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel32.1.as"> В следующем примере создается объект BitmapData, залитый цветом, а затем с помощью метода <codeph>getPixel32()</codeph> определяется значение цвета в верхнем левом пикселе, после чего определяются шестнадцатеричные значения для каждого компонента цвета (альфа-канал, красный, зеленый и синий).
<codeblock>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(1, 1);
var alphaValue:uint = pixelValue >> 24 &amp; 0xFF;
var red:uint = pixelValue >> 16 &amp; 0xFF;
var green:uint = pixelValue >> 8 &amp; 0xFF;
var blue:uint = pixelValue &amp; 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixels"><apiName>getPixels</apiName><shortdesc>
	 Формирует байтовый массив из прямоугольного участка пиксельных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объект rect имеет значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект ByteArray, представляющий пиксели в данном объекте Rectangle.
	 
	 </apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольная область в текущем объекте BitmapData.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Формирует байтовый массив из прямоугольного участка пиксельных данных. Записывает неподписанное целое число (32-разрядное неумноженное значение пикселя) для каждого пикселя в байтовом массиве.
	 
	 </apiDesc><example conref="examples\BitmapData.getPixels.1.as"> В следующем примере создается объект BitmapData, заполненный пикселями, образующими белый шум, а затем с помощью метода <codeph>getPixels()</codeph> объект ByteArray заполняется пиксельными значениями объекта BitmapData.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getVector"><apiName>getVector</apiName><shortdesc>
	 Формирует векторный массив из прямоугольного участка пиксельных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объект rect имеет значение null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект Vector, представляющий указанный объект Rectangle.
	 </apiDesc><apiType value="Vector$uint"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольная область в текущем объекте BitmapData.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Формирует векторный массив из прямоугольного участка пиксельных данных. Возвращает объект Vector беззнаковых целых чисел (32-разрядное неумноженное пиксельное значение) для заданного прямоугольника.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:histogram"><apiName>histogram</apiName><shortdesc>
	 Вычисление гистограммы двоичных чисел с 256 значениями для объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Vector$Vector$Number"/></apiReturn><apiParam><apiItemName>hRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Используемая область объекта BitmapData.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Вычисление гистограммы двоичных чисел с 256 значениями для объекта BitmapData. Этот метод возвращает объект Vector, содержащий четыре вектора. Экземпляры &lt;Number> (четыре объекта Vector, содержащие объекты Number). Четыре экземпляра Vector представляют красный, зеленый, синий и альфа компоненты по порядку. Каждый экземпляр Vector содержит 256 значений, которые представляют распространение отдельного значения компонента: от 0 до 255.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:hitTest"><apiName>hitTest</apiName><shortdesc>
	 Выполняет распознавание на уровне пикселей между одним растровым изображением и точкой, прямоугольником или другим растровым изображением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Параметр <codeph>secondObject</codeph> не является объектом Point, Rectangle, Bitmap или BitmapData.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Объект firstPoint имеет значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Имеет значение <codeph>true</codeph> при наличии совпадений; в противном случае - <codeph>false</codeph>.
	    
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>firstPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc> Положение верхнего левого угла изображения BitmapData в произвольном координатном пространстве. То же координатное пространство используется при определении параметра <codeph>secondBitmapPoint</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>firstAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Самое низкое значение альфа-канала, рассматриваемое как непрозрачное, для данной проверки попадания.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект Rectangle, Point, Bitmap или BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondBitmapDataPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Точка, определяющая местоположение пикселя во втором объекте BitmapData. Используйте этот параметр, только когда значением <codeph>secondObject</codeph> является объект BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>1</apiData><apiDesc>Самое низкое значение альфа-канала, рассматриваемое как непрозрачное во втором объекте BitmapData. Используйте этот параметр, только когда значением <codeph>secondObject</codeph> является BitmapData и оба объекта BitmapData прозрачные.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет распознавание на уровне пикселей между одним растровым изображением и точкой, прямоугольником или другим растровым изображением. Попаданием считается наложение точки или прямоугольника на непрозрачный пиксель или два накладывающихся непрозрачных пикселя. При тестировании нажатия растягивание, поворот и другие преобразования обоих объектов не учитываются. 
	 
	 <p>Если изображение непрозрачное, то при использовании данного метода оно считается полностью непрозрачным прямоугольником. Для тестирования нажатия, при котором учитывается прозрачность, оба изображения должны быть прозрачными. Когда тестируются два прозрачных изображения, параметры порога альфа-значений контролируют, какие значения альфа-канала (от 0 до 255) считаются непрозрачными.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.hitTest.1.as"> В следующем примере создается объект BitmapData, являющийся непрозрачным только в прямоугольной области с координатами (20, 20, 40, 40), и вызывается метод <codeph>hitTest()</codeph> с объектом Point в качестве <codeph>secondObject</codeph>. При первом вызове объект Point определяет верхний левый угол объекта BitmapData, который является прозрачным, а при втором вызове объект Point определяет центр объекта BitmapData, который является непрозрачным.
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:lock"><apiName>lock</apiName><shortdesc>
	 Блокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, не обновлялись при изменении данного объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Блокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, не обновлялись при изменении данного объекта BitmapData. Чтобы повысить производительность, используйте этот метод вместе с методом <codeph>unlock()</codeph> до или после многочисленных вызовов метода <codeph>setPixel()</codeph> или <codeph>setPixel32()</codeph>.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> В следующем примере создается объект BitmapData на базе свойства <codeph>bitmapData</codeph> объекта Bitmap с именем <codeph>picture</codeph>. Затем вызывается метод <codeph>lock()</codeph> перед вызовом сложной пользовательской функции, <codeph>complexTransformation()</codeph>, изменяющей объект BitmapData. (Объект <codeph>picture</codeph> и функция <codeph>complexTransformation()</codeph> в этом примере не определяются.) Даже если функция <codeph>complexTransformation()</codeph> обновляет свойство <codeph>bitmapData</codeph> объекта <codeph>picture</codeph>, изменения не отображаются, пока код не вызовет метод <codeph>unlock()</codeph> объекта <codeph>bitmapData</codeph>.
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:merge"><apiName>merge</apiName><shortdesc>
     Проводит наложение каналов исходного изображения на целевое изображение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий объект BitmapData.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
     </apiDesc></apiParam><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Шестнадцатеричное значение, на которое будет умножаться значение красного канала. 
     </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Шестнадцатеричное значение, на которое будет умножаться значение зеленого канала. 
     </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Шестнадцатеричное значение, на которое будет умножаться значение синего канала.
     </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Шестнадцатеричное значение, на которое будет умножаться значение альфа-канала.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Проводит наложение каналов исходного изображения на целевое изображение. Для каждого канала и каждого пикселя вычисляется новое значение на основе значений каналов исходных и целевых пикселей. Например, в красном канале новое значение вычисляется следующим образом (где <codeph>redSrc</codeph> - это значение красного канала для пикселя в исходном изображении, а <codeph>redDest</codeph> - это значение красного канала в соответствующем пикселе целевого изображения): 
	 <p>
	 <codeph> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </codeph>
	 </p>
	 
	 <p>Значения <codeph>redMultiplier</codeph>, <codeph>greenMultiplier</codeph>, <codeph>blueMultiplier</codeph> и <codeph>alphaMultiplier</codeph> являются множителями, используемыми для канала каждого цвета. Используйте шестнадцатеричное значение от <codeph>0</codeph> до <codeph>0x100</codeph> (256), где <codeph>0</codeph> обозначает, что в результате используется полное значение целевого изображения, а <codeph>0x100</codeph> - что используется полное значение исходного изображения, а промежуточные числа означают, что используется наложение (так <codeph>0x80</codeph> указывает на 50-процентное наложение).</p>
	 
	 </apiDesc><example conref="examples\BitmapData.merge.1.as"> В следующем примере создаются два объекта BitmapData. Размер обоих составляет 100 х 80 пикселей. Первый объект заливается зеленым цветом, а второй — красным. Код вызывает метод <codeph>merge()</codeph>, накладывающий пиксели второго объекта BitmapData на первый объект BitmapData, но только в заданной прямоугольной области:
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:noise"><apiName>noise</apiName><shortdesc>
	 Заполняет изображение пикселями, представляющими собой белый шум.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Начальное значение, используемое для создания случайных чисел. Если не изменять остальных параметров, можно создавать различные псевдослучайные результаты, изменяя начальное значение случайной последовательности. Функция шума является функцией наложения, а не настоящей функцией создания случайных чисел, поэтому при использовании одного и того же начального числа она каждый раз дает одинаковые результаты.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>low</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Самое низкое значение для создания случайных чисел для каждого канала (от 0 до 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>high</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>255</apiData><apiDesc>Самое высокое значение для создания случайных чисел для каждого канала (от 0 до 255). 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc>Число, которое может представлять собой любую комбинацию значений четырех каналов цвета (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph> и <codeph>BitmapDataChannel.ALPHA</codeph>). Можно использовать логический оператор ИЛИ (<codeph>|</codeph>) для комбинирования значений каналов. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Логическое значение. Если имеет значение <codeph>true</codeph>, создается изображение с использованием серой шкалы путем присвоения всем цветовым каналам одного и того же значения. На значение альфа-канала не воздействует задание значения <codeph>true</codeph> для этого параметра. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Заполняет изображение пикселями, представляющими собой белый шум.
	 
	 </apiDesc><example conref="examples\BitmapData.noise.1.as"> В следующем примере создается два объекта BitmapData и для каждого из них вызывается метод <codeph>noise()</codeph>. Однако параметру <codeph>grayscale</codeph> задано значение <codeph>false</codeph> для вызова метода <codeph>noise()</codeph> первого объекта и <codeph>true</codeph> для вызова метода <codeph>noise()</codeph> второго объекта.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapDataChannel/RED"><linktext>flash.display.BitmapDataChannel.RED</linktext></link><link href="flash.display.xml#BitmapDataChannel/BLUE"><linktext>flash.display.BitmapDataChannel.BLUE</linktext></link><link href="flash.display.xml#BitmapDataChannel/GREEN"><linktext>flash.display.BitmapDataChannel.GREEN</linktext></link><link href="flash.display.xml#BitmapDataChannel/ALPHA"><linktext>flash.display.BitmapDataChannel.ALPHA</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:paletteMap"><apiName>paletteMap</apiName><shortdesc>
	 Переназначает значения цветовых каналов в изображении, содержащем до четырех массивов данных цветовой палитры, по одному для каждого канала.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка в целевом изображении (текущем объекте BitmapData), соответствующая правому левому углу исходного прямоугольника.
	 </apiDesc></apiParam><apiParam><apiItemName>redArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Если <codeph>redArray</codeph> не имеет значение <codeph>null</codeph>, <codeph>красный = redArray[исходное значение красного], в противном случае красный = исходное значение красного</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>greenArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Если <codeph>greenArray</codeph> не имеет значение <codeph>null</codeph>, <codeph>зеленый = greenArray[исходное значение зеленого], в противном случае зеленый = исходное значение зеленого.</codeph>
	 </apiDesc></apiParam><apiParam><apiItemName>blueArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Если <codeph>blueArray</codeph> не имеет значение <codeph>null</codeph>, <codeph>синий = blueArray[исходное значение синего], в противном случае синий = исходное значение синего</codeph>.
	 </apiDesc></apiParam><apiParam><apiItemName>alphaArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Если <codeph>alphaArray</codeph> не имеет значение <codeph>null</codeph>, <codeph>альфа = alphaArray[исходное альфа-значение], в противном случае альфа = исходное альфа-значение</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переназначает значения цветовых каналов в изображении, содержащем до четырех массивов данных цветовой палитры, по одному для каждого канала. 
	 
	 <p><ph platform="actionscript">Проигрыватель Flash Player или</ph> AIR выполняет следующие шаги для создания конечного изображения:</p>
	 
	 <ol>
	 
	 <li>После вычисления значения красного, зеленого, синего и альфа-каналов складываются, образуя стандартное 32-разрядное целое число. </li>
	 
	 <li>Значения красного, зеленого, синего и альфа-каналов каждого пикселя извлекаются в отдельные значения от 0 до 255. Эти значения используются для поиска новых значений цвета в соответствующем массиве: <codeph>redArray</codeph>, <codeph>greenArray</codeph>, <codeph>blueArray</codeph> и <codeph>alphaArray</codeph>. Каждый из этих четырех массивов должен содержать 256 значений. </li>
	 
	 <li>После получения новых значений для всех четырех каналов, они образуют стандартное значение ARGB, которое применяется к пикселю.</li>
	 
	 </ol>
	 
	 <p>Этот метод может поддерживать эффекты, создаваемые с использованием разных каналов. Каждый вводный массив содержит полные 32-разрядные значения, поэтому при складывании значений не происходит смещения. Эта подпрограмма не поддерживает фиксацию по каналам. </p>
	 
	 <p>Если для канала не задан массив, то канал цвета копируется из исходного изображения в целевое.</p>
	 
	 <p>Этот метод можно использовать для самых разнообразных эффектов, таких как общее наложение палитры (преобразование одного канала для создания псевдо-цветного изображения). Этот метод можно использовать для различных расширенных алгоритмов манипуляций с цветом, таких как использование гаммы, кривых, уровней и квантизации.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.paletteMap.1.as"> В следующем примере создается зеленый объект BitmapData с красным квадратом по центру, а затем вызывается метод <codeph>paletteMap()</codeph>, чтобы поменять местами красный и зеленый в нижней прямоугольной области объекта BitmapData.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:perlinNoise"><apiName>perlinNoise</apiName><shortdesc>
	 Создает изображение с шумом Перлина.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>baseX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Частота, используемая по оси <i>x</i>. Например, чтобы создать объект с шумом для изображения размером 64 x 128, передайте 64 для значения <codeph>baseX</codeph>. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>baseY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Частота для использования в направлении <i>y</i>. Например, чтобы создать объект с шумом для изображения размером 64 x 128, передайте 128 для значения <codeph>baseY</codeph>. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numOctaves</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Количество октав или индивидуальных функций шума, которые необходимо объединить с целью создания шума. Чем больше октав, тем более детальное изображение создается. Также чем больше октав, тем больше времени требуется на обработку.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Начальное значение, используемое для создания случайных чисел. Если не изменять остальных параметров, можно создавать различные псевдослучайные результаты, изменяя начальное значение случайной последовательности. Функция шума Перлина является функцией наложения, а не настоящей функцией создания случайных чисел, поэтому при использовании одного и того же начального числа она каждый раз дает одинаковые результаты.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>stitch</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение. При значении <codeph>true</codeph> метод пытается сгладить края перехода изображения, чтобы создать бесшовную текстуру для мозаичной заливки растровым изображением.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fractalNoise</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение. При значении <codeph>true</codeph> метод создает фрактальный шум, в противном случае создается турбулентность. Изображение с турбулентностью имеет видимые прерывания градиента, благодаря чему оно больше подходит для более резких визуальных эффектов, например для создания языков пламени или морских волн.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc> Число, которое может представлять собой любую комбинацию значений четырех каналов цвета (<codeph>BitmapDataChannel.RED</codeph>, <codeph>BitmapDataChannel.BLUE</codeph>, <codeph>BitmapDataChannel.GREEN</codeph> и <codeph>BitmapDataChannel.ALPHA</codeph>). Можно использовать логический оператор ИЛИ (<codeph>|</codeph>) для комбинирования значений каналов.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Логическое значение. При значении <codeph>true</codeph> создается изображение с использованием серой шкалы путем присвоения каналам красного, зеленого и синего цветов идентичных значений. Значение альфа-канала остается без изменений, если данному параметру задано значение <codeph>true</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>offsets</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив точек, соответствующий смещениям в направлениях <i>x</i> и <i>y</i> для каждой октавы. Изменяя значения смещения, можно плавно прокручивать слои изображения с шумом Перлина. Каждая точка в массиве смещения применяется к функции шума конкретной октавы.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Создает изображение с шумом Перлина.
	 
	 <p>Алгоритм создания шума Перлина интерполирует и объединяет отдельные функции случайного шума (называемые октавами) в одну функцию, создающую более естественный случайный шум. Как и в музыкальных октавах, каждая функция октавы удваивает частоту предыдущей. Шум Перлина описывается как «фрактальная сумма шума», так как он объединяет несколько наборов шумовых данных с разным уровнем детализации.</p>
	 
	 <p>Функции шума Перлина можно использовать для симуляции естественных явлений и ландшафтов, таких как текстура древесины, облака и горные хребты. В большинстве случаев результат функции шума Перлина не отображается непосредственно: он используется для доработки других изображений, придавая им псевдослучайные вариации.</p>
	 
	 <p>Простые функции цифрового белого шума часто дают изображения с резко контрастирующими точками. Такое явление редко встречается в естественных условиях. Алгоритм шума Перлина объединяет несколько функций шума с разным уровнем детализации. В результате чего разница между значениями соседних пикселей становится не столь большой.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.perlinNoise.1.as"> В следующем примере создается объект BitmapData 200 х 200 пикселей, который вызывает метод <codeph>perlinNoise()</codeph> для создания эффекта красной и синей акварели.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:pixelDissolve"><apiName>pixelDissolve</apiName><shortdesc>
	 Выполняет растворение точек от исходного изображения до целевого или для одного изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>numPixels имеет отрицательное значение.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Новое начальное значение случайного числа для последующих вызовов.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Начальное значение случайного числа, используемое для начала растворения точек. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numPixels</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>По умолчанию составляет 1/30 исходной области (ширина x высота).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Значение цвета ARGB, используемое для заливки пикселей, для которых исходное значение равно целевому. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет растворение точек от исходного изображения до целевого или для одного изображения. <ph platform="actionscript">Проигрыватель Flash Player или</ph> AIR использует значение <codeph>randomSeed</codeph> для выполнения случайного растворения точек. Возвращаемое значение функции должно передаваться при последующих вызовах для продолжения растворения точек вплоть до завершения операции.
	 
	 <p>Если исходное изображение отличается от целевого, пиксели копируются из первого во второе с использованием всех свойств. Этот процесс позволяет выполнить растворение от пустого изображения до заполненного.</p>
	 
	 <p>Если исходное и целевое изображения одинаковы, пиксели заполняются с помощью параметра <codeph>color</codeph>. Этот процесс позволяет выполнить растворение из заполненного изображения. В данном режиме целевой параметр <codeph>point</codeph> игнорируется.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.pixelDissolve.1.as"> В следующем примере метод <codeph>pixelDissolve()</codeph> используется для преобразования серого объекта BitmapData в красный: одновременно растворяется по 40 пикселей до тех пор, пока не будет изменен цвет всех пикселей.
<codeblock>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 &amp;&amp; grayRegion.height == 0 ) {
        tim.stop();
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:scroll"><apiName>scroll</apiName><shortdesc>
	 Прокручивает изображение на заданное число точек (x, y).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Число точек для прокрутки по горизонтали.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Число точек для прокрутки по вертикали.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Прокручивает изображение на заданное число точек (<i>x</i>, <i>y</i>). Края за пределами области прокрутки остаются без изменений.
	 
	 </apiDesc><example conref="examples\BitmapData.scroll.1.as"> В следующем примере показывается эффект прокрутки объекта BitmapData на 40 пикселей вправо.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:setPixel"><apiName>setPixel</apiName><shortdesc>
	 Задает одиночный пиксель объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение по оси <i>x</i> пикселя, значение которого меняется.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение по оси <i>y</i> пикселя, значение которого меняется.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Полученный RGB-цвет пикселя. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает одиночный пиксель объекта BitmapData. При выполнении этой операции сохраняется текущее значение альфа-канала пикселя изображения. Значение параметра RGB-цвета обрабатывается как неумноженное значение цвета.
	 
	 <p><b>Примечание.</b> Для повышения производительности при многократном использовании метода <codeph>setPixel()</codeph> или <codeph>setPixel32()</codeph> вызовите метод <codeph>lock()</codeph> перед тем, как вызывать <codeph>setPixel()</codeph> или <codeph>setPixel32()</codeph>, а по завершении внесения изменений в пиксели, вызовите метод <codeph>unlock()</codeph>. Эта процедура не позволяет объектам, ссылающимся на данный экземпляр BitmapData, обновляться, пока не будет завершено изменение пикселей.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel.1.as"> В следующем примере с помощью метода <codeph>setPixel()</codeph> рисуется красная линия в объекте BitmapData.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixel32"><apiName>setPixel32</apiName><shortdesc>
	 Задает значения цвета и альфа-прозрачности отдельно взятой точки объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение по оси <i>x</i> пикселей, значение которого меняется.
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Положение по оси <i>y</i> пикселя, значение которого меняется.
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Полученный ARGB-цвет пикселя. Если растровое изображение непрозрачное, то альфа-составляющая значения цвета игнорируется.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает значения цвета и альфа-прозрачности отдельно взятой точки объекта BitmapData. Этот метод поход на метод <codeph>setPixel()</codeph>. Основное различие заключается в том, что метод <codeph>setPixel32()</codeph> принимает ARGB-значение цвета, содержащее информацию об альфа-канале.
	 
	 <p>Все пиксели в объекте BitmapData сохраняются как предварительно умноженные значения цвета. В предварительно умноженном пикселе изображения значения красного, зеленого и синего канала уже умножены на данные альфа-канала. Например, если значение альфа-канала равно нулю, то значения RGB-каналов также равны нулю независимо от их значений до умножения. Потеря данных может вызвать проблемы при выполнении операций. Все методы BitmapData принимают и возвращают неумноженные значения. Перед тем как возвращать значение, внутреннее представление пикселя преобразуется из предварительно умноженного в неумноженное. Во время операции настройки, значение пикселя предварительно умножается, и только после этого настраивается необработанный пиксель изображения.</p>
	 
	 <p><b>Примечание.</b> Для повышения производительности при многократном использовании метода <codeph>setPixel()</codeph> или <codeph>setPixel32()</codeph> вызовите метод <codeph>lock()</codeph> перед тем, как вызывать <codeph>setPixel()</codeph> или <codeph>setPixel32()</codeph>, а по завершении внесения изменений в пиксели, вызовите метод <codeph>unlock()</codeph>. Эта процедура не позволяет объектам, ссылающимся на данный экземпляр BitmapData, обновляться, пока не будет завершено изменение пикселей.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel32.1.as"> В следующем примере с помощью метода <codeph>setPixel32()</codeph> рисуется прозрачная красная линия в объекте BitmapData (значение альфа-канала = 0х60).
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixels"><apiName>setPixels</apiName><shortdesc>
	 Преобразует массив байтов в прямоугольный участок пиксельных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объект <codeph>inputByteArray</codeph> не содержит достаточно данных для заполнения области прямоугольника <codeph>rect</codeph>. Метод заполняет максимально возможное количество пикселей, а затем выдает исключение.
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>Объекты rect и inputByteArray имеют значение null.
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Задает прямоугольную область объекта BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputByteArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray состоит из 32-разрядных неумноженных пиксельных значений, которые должны использоваться в прямоугольной области.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует массив байтов в прямоугольный участок пиксельных данных. Для каждого пикселя вызывается метод <codeph>ByteArray.readUnsignedInt()</codeph> и записывается возвращаемое значение. Если массив байтов заканчивается, прежде чем будет заполнен весь прямоугольник, функция возвращает исключение. Массив байтов должен содержать 32-разрядные ARGB-значения пикселей. Перед считыванием пикселей и после него поиск по массиву байтов не выполняется.  
	 
	 </apiDesc><example conref="examples\BitmapData.setPixels.1.as"> В следующем примере методы <codeph>getPixels()</codeph> и <codeph>setPixels()</codeph> используются для копирования пикселей из одного объекта BitmapData в другой.
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/readUnsignedInt()"><linktext>flash.utils.ByteArray.readUnsignedInt()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setVector"><apiName>setVector</apiName><shortdesc>
	 Преобразует вектор в прямоугольную область пиксельных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Векторный массив недостаточно большой для чтения всех пиксельных данных.
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Задает прямоугольную область объекта BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputVector</apiItemName><apiType value="Vector$uint"/><apiDesc>Векторный объект состоит из 32-разрядных неумноженных пиксельных значений, используемых в прямоугольной области  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует вектор в прямоугольную область пиксельных данных. Для каждого пикселя элемент вектора считывается и записывается в пиксель BitmapData. Ожидается, что данные в векторе являются 32-разрядными ARGB-значениями пикселей. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:threshold"><apiName>threshold</apiName><shortdesc>
	 Сопоставляет пиксельные значения в изображении с заданным пороговым значением и присваивает пикселям, прошедшим проверку, новые цветовые значения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты sourceBitmapData, sourceRect, destPoint или operation имеют значение null.
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Строка operation не является допустимой операцией. 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число измененных пикселей.
 	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>Входное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>В качестве строки String передается один из следующих операторов сравнения: "&lt;", "&lt;=", ">", ">=", "==", "! ="
	 
	 </apiDesc></apiParam><apiParam><apiItemName>threshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Значение, с которым сопоставляется каждый пиксель, чтобы узнать, больше он или равен порогу.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Значение цвета, которое получает пиксель при успешном прохождении пороговой проверки. Значение по умолчанию – 0x00000000.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>Маска используется с целью изоляции компонента цвета. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>copySource</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При значении <codeph>true</codeph> пиксельные значения из исходного изображения копируются в целевое, если пиксель не проходит пороговый тест. При значении <codeph>false</codeph> исходное изображение не копируется, если пиксель не проходит пороговую проверку. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Сопоставляет пиксельные значения в изображении с заданным пороговым значением и присваивает пикселям, прошедшим проверку, новые цветовые значения. С помощью метода <codeph>threshold()</codeph> можно изолировать и заменить диапазоны в изображении и выполнить другие логические операции над пикселями изображения. 
	 
	 <p>Проверка метода <codeph>threshold()</codeph> имеет следующую логику:</p> 
	 
	 <ol> 
	 
	 	<li>если <codeph>((pixelValue &amp; mask) operation (threshold &amp; mask))</codeph>, то установите <codeph>color</codeph> для пикселя;</li>
	 
	 	<li>В противном случае, если <codeph>copySource == true</codeph>, то пиксель получает соответствующее значение из <codeph>sourceBitmap</codeph>.</li>
	 </ol>
	 
	 <p>Параметр <codeph>operation</codeph> задает оператор сравнения, используемый при пороговой проверке. Например, используя «==» в качестве параметра <codeph>operation</codeph> можно изолировать конкретное цветовое значение в изображении. Или с помощью операции <codeph>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</codeph> можно сделать все целевые пиксели полностью прозрачными, если альфа-значение пикселя исходного изображения меньше 0x7F. Этот прием можно использовать для анимированных переходов и других эффектов.</p>
	 
	 </apiDesc><example conref="examples\BitmapData.threshold.1.as"> В следующем примере используется метод <codeph>perlinNoise()</codeph> для добавления сине-красного рисунка в объект BitmapData, а затем вызывается метод <codeph>threshold()</codeph>, чтобы скопировать эти пиксели из первого объекта BitmapData во второй, заменяя пиксели, в которых значение красного больше 0x80 (50%), пикселями с прозрачным красным цветом(0x20FF0000).
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, ">", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:unlock"><apiName>unlock</apiName><shortdesc>
	 Разблокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, обновлялись при изменении данного объекта BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>changeRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>Измененная область объекта BitmapData. Если не задать значения для данного параметра, измененной считается вся область объекта BitmapData. Для использования этого параметра требуется проигрыватель Flash Player версии 9.0.115.0 или более поздней.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Разблокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, обновлялись при изменении данного объекта BitmapData. Чтобы повысить производительность, используйте этот метод вместе с методом <codeph>lock()</codeph> до или после многочисленных вызовов метода <codeph>setPixel()</codeph> или <codeph>setPixel32()</codeph>.
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> В следующем примере создается объект BitmapData на базе свойства <codeph>bitmapData</codeph> объекта Bitmap с именем <codeph>picture</codeph>. Затем вызывается метод <codeph>lock()</codeph> перед вызовом сложной пользовательской функции, <codeph>complexTransformation()</codeph>, изменяющей объект BitmapData. (Объект <codeph>picture</codeph> и функция <codeph>complexTransformation()</codeph> в этом примере не определяются.) Даже если функция <codeph>complexTransformation()</codeph> обновляет свойство <codeph>bitmapData</codeph> объекта <codeph>picture</codeph>, изменения не отображаются, пока код не вызовет метод <codeph>unlock()</codeph> объекта <codeph>bitmapData</codeph>.
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiValue id="flash.display:BitmapData:height:get"><apiName>height</apiName><shortdesc>
	 Высота растрового изображения в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Высота растрового изображения в пикселях.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:rect:get"><apiName>rect</apiName><shortdesc>
	 Прямоугольник, определяющий размер и расположение растрового изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
	 Прямоугольник, определяющий размер и расположение растрового изображения. Верхняя левая точка прямоугольника имеет значение 0; ширина и высота в пикселях равны размерам объекта BitmapData.
   	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:transparent:get"><apiName>transparent</apiName><shortdesc>
	 Определяет, поддерживает ли растровое изображение попиксельную прозрачность.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, поддерживает ли растровое изображение попиксельную прозрачность. Это значение можно задавать, только когда при создании объекта BitmapData в конструкторе передается значение<codeph>true</codeph> для параметра <codeph>transparent</codeph>. Затем, когда объект BitmapData создан, можно узнать, поддерживает ли он попиксельную прозрачность: для этого нужно проверить, имеет ли свойство <codeph>transparent</codeph> значение <codeph>true</codeph>.
   	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:width:get"><apiName>width</apiName><shortdesc>
	 Ширина растрового изображения в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Ширина растрового изображения в пикселях.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:JointStyle"><apiName>JointStyle</apiName><shortdesc>
Класс JointStyle — это перечисление значений констант, задающих стили соединений при рисовании линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс JointStyle — это перечисление значений констант, задающих стили соединений при рисовании линий. Эти константы предназначены для использования в качестве значений параметра <codeph>joints</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph>. Этот метод использует три типа стыков: уголок, круглый и фаска, как показано в следующем примере. 

<p><adobeimage alt="MITER (уголок), ROUND (круглый) и BEVEL (скос)" href="../../images/linejoin.jpg"/></p> 

 
</apiDesc><example conref="examples\JointStyleExample.as"> В следующем примере используется класс JointStyleExample для иллюстрации применения разных стилей стыков к трем группам соединенных линий. Это можно сделать, выполнив следующие действия.
 <ol>
  <li>Для каждой линии заданы следующие свойства.
  <ul>
      <li>Длина линии — 80 пикселей.</li>
      <li>Цвет рамки — оранжевый.</li>
      <li>Размер рамки — 30 пикселей.</li>
      <li>Цвет подсветки — серый.</li>
      <li>Размер подсветки — ноль пикселей.</li>
      <li>Значение альфа-канала — 1 для получения сплошного цвета.</li>
      <li>Хинтинг пикселей имеет значение false (не выполняется хинтинг до полных пикселей).</li>
      <li>Режим масштабирования линий - обычный: масштабирование по ширине.</li>
      <li>Концы рамки и длина уголков объявлены, но не заданы, поэтому используются значения по умолчанию.</li>
  </ul></li>
  <li>Конструктор класса создает три группы по два соединенных сегмента линии. Сегменты начинаются в точке с координатами x = 0, y = 0 и рисуются путем троекратного вызова метода <codeph>doDrawCorner()</codeph> с использованием трех стилей стыков (уголок, круглый и фаска). В каждом из трех вызовов <codeph>doDrawCorner()</codeph> используются описанные выше свойства и стили стыков для отрисовки двух соединенных сегментов линии и соответствующих подсветок.. С этой целью сначала создается новый объект Shape с именем <codeph>child</codeph>, затем используются методы класса Graphics для указания стиля линий и отрисовки линий и подсветок. Каждый экземпляр <codeph>child</codeph> добавляется в список отображения и тут же отрисовывается в рабочей области.</li>
  <li>Затем соединенные сегменты линии перерисовываются с использованием метода <codeph>refreshLayout()</codeph> на пикселях y = 80, начиная с пикселей x = 80, где сегменты линии разделены 25 пикселями.</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class JointStyleExample extends Sprite {
        private var size:uint                  = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderCaps:String;
        private var borderMiterLimit:uint;

        public function JointStyleExample() {
            doDrawCorner(JointStyle.MITER);
            doDrawCorner(JointStyle.ROUND);
            doDrawCorner(JointStyle.BEVEL);
            refreshLayout();
        }

        private function doDrawCorner(jointStyle:String):void {
            var halfSize:uint = Math.round(size / 2);
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     borderCaps,
                                     jointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = size;
            lastChild.y = size;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = size;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:JointStyle:BEVEL"><apiName>BEVEL</apiName><shortdesc>
	
	Задает использование скошенных стыков сегментов параметром joints метода flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bevel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Определяет использование скошенных стыков сегментов в параметре <codeph>joints</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:MITER"><apiName>MITER</apiName><shortdesc>
	
	Задает использование параметром joints метода flash.display.Graphics.lineStyle() угловых стыков сегментов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>miter</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Определяет использование угловых стыков сегментов в параметре <codeph>joints</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	
	Задает использование круглых стыков сегментов параметром joints метода flash.display.Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	Определяет использование круглых стыков сегментов в параметре <codeph>joints</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph>.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:AVM1Movie"><apiName>AVM1Movie</apiName><shortdesc>
	AVM1Movie – это простой класс, представляющий фрагменты роликов AVM1, которые используют ActionScript 1.0 или 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
	AVM1Movie – это простой класс, представляющий фрагменты роликов AVM1, которые используют ActionScript 1.0 или 2.0. (AVM1 представляет собой виртуальную машину ActionScript, используемую для выполнения ActionScript 1.0 и 2.0. AVM2 представляет собой виртуальную машину ActionScript, используемую для выполнения ActionScript 3.0 При использовании Flash Player 8 или более ранней версии SWF-файл загружается объектом Loader, и создается объект AVM1Movie. Объект AVM1Movie может использовать методы и свойства, унаследованные от класса DisplayObject (например, <codeph>x</codeph>, <codeph>y</codeph>, <codeph>width</codeph> и т.д.). Однако наследование между объектами AVM1Movie и AVM2 (например, вызов методов или использование параметров) не поддерживается.
	
	<p>Существует ряд ограничений для SWF-файлов AVM1, загруженных SWF-файлами AVM2.</p>
	
	<ul>
	
	<li>Загруженный объект AVM1Movie выступает в роли псевдокорневого объекта для SWF-файла AVM1 и всех загруженных им SWF-файлов AVM1 SWF (как если бы свойство <codeph>lockroot</codeph> в ActionScript 1.0 имело значение <codeph>true</codeph>). Ролик AVM1 всегда находится на верхнем уровне выполнения кода ActionScript 1.0 или 2.0 в его потомках. Свойством <codeph>_root</codeph> для загруженных нижестоящих элементов всегда является SWF-файл AVM1, если в загруженном SWF-файле AVM1 не задано свойство <codeph>lockroot</codeph>.</li>
	
	<li>Содержимое AVM1 не может выполнять поуровневую загрузку файлов. Например, с его помощью невозможна загрузка файлов вызовом метода <codeph>loadMovieNum("url", levelNum)</codeph>.</li>
	
	<li>SWF-файл AVM1, загруженный SWF-файлом AVM2, не может загружать <codeph>в него</codeph> другой SWF-файл. Он не может загружать через себя другой SWF-файл. Однако можно загрузить <codeph>в него</codeph> нижестоящие объекты Sprite, MovieClip или другие SWF-файлы AVM1, загруженные данным SWF-файлом.</li>
	
	</ul>
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>DisplayObject</linktext></link><link href="flash.display.xml#Loader"><linktext>Загрузчик</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
	 Экземпляр ShaderInput представляет единственное изображение ввода для ядра затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Экземпляр ShaderInput представляет единственное изображение ввода для ядра затенения. При выполнении ядра можно заставить его работать с нулем, одним или несколькими исходными изображениями, используемыми при выполнении ядра. В экземпляре ShaderInput заложен механизм, позволяющий указывать изображение ввода для использования при выполнении операции затенения. Чтобы задать значение ввода, создайте объект BitmapData, ByteArray или Vector. Экземпляр &lt;Number>, содержащий данные изображения, и назначьте его свойству <codeph>input</codeph>.
	 
	 <p>Доступ к экземпляру ShaderInput, представляющему изображение ввода экземпляра Shader, осуществляется в качестве свойства <codeph>data</codeph> экземпляра Shader. В коде затенения имя свойства ShaderInput совпадает с именем ввода. Например, если затенение задает ввод с именем <codeph>src</codeph>, то экземпляр ShaderInput, представляющий ввод <codeph>src</codeph>, будет доступен в качестве свойства <codeph>src</codeph>. Пример:</p>
	 
	 <codeblock>myShader.data.src.image = new BitmapData(50, 50, true, 0xFF990000);</codeblock>
	 
	 <p>В некоторых случаях с использованием экземпляра Shader указывать изображение ввода не требуется, так как оно назначается операцией автоматически. Указывать ввод требуется только тогда, когда затенение используется для следующего:</p>
	 
	 <ul>
	   <li>Заливка затенением</li>
	   <li>ShaderFilter используется только для вторых или дополнительных вводов, при условии что затенение настроено на использование нескольких вводов. (Объект, к которому применяется фильтр, автоматически используется в качестве первичного ввода.)</li>
	   <li>Режим наложения затенения используется только для третьих или дополнительных вводов, при условии что затенение настроено на использование более двух вводов. (Накладываемые объекты автоматически используются в качестве первого и второго ввода.)</li>
	   <li>Выполнение ShaderJob в фоне</li>
	 </ul>
	 
	 <p>Если операция затенения запускается с использованием экземпляра ShaderJob для обработки массива ByteArray, данные в котором расположены линейно, настройте параметры экземпляра ShaderInput следующим образом: установите для <codeph>height</codeph> значение 1, для <codeph>width</codeph> — значение числа 32-разрядных значений с плавающей запятой в массиве ByteArray. В этом случае значение ввода затенения должно принадлежать типу данных <codeph>image1</codeph>.</p>
	 
	 <p>Обычно, в коде разработчика создание экземпляра ShaderInput не заложено. При создании экземпляра Shader экземпляр ShaderInput создается автоматически для каждого ввода затенения.</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link></related-links><apiConstructor id="flash.display:ShaderInput:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
		 Создает экземпляр ShaderInput.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 Создает экземпляр ShaderInput. Обычно, в коде разработчика прямой вызов конструктора ShaderInput не производится. При создании экземпляра Shader экземпляр ShaderInput создается автоматически для каждого ввода затенения.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderInput:channels:get"><apiName>channels</apiName><shortdesc>
         Число каналов во вводе затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Число каналов во вводе затенения. Данное свойство принимается во внимание только если данными ввода являются ByteArray или Vector. Экземпляр &lt;Number>.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:height:get"><apiName>height</apiName><shortdesc>
		 Высота ввода затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Высота ввода затенения. Данное свойство используется только если данными ввода являются ByteArray или Vector. Экземпляр &lt;Number>. Если вводом является экземпляр BitmapData, высота определяется автоматически.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:index:get"><apiName>index</apiName><shortdesc>
         Отсчитываемое от нуля значение индекса для ввода затенения отражает порядок определений вводов в затенении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         Отсчитываемое от нуля значение индекса для ввода затенения отражает порядок определений вводов в затенении.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:input:get"><apiName>input</apiName><shortdesc>
		 
		 Данные ввода, используемые при выполнении операции затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 
		 Данные ввода, используемые при выполнении операции затенения. Это свойство может быть экземпляром BitmapData, ByteArray или Vector. Экземпляр &lt;Number>.
		 
		 <p>При присвоении значения ByteArray свойству <codeph>input</codeph> необходимо выполнить следующие условия:</p>
		 
		 <ul>
		   <li>Необходимо настроить свойства <codeph>height</codeph> и <codeph>width</codeph>.</li>
		   <li>Массив байтов должен состоять только из 32-разрядных значений с плавающей запятой. Эти значения должны быть записаны с помощью метода <codeph>ByteArray.writeFloat()</codeph>.</li>
		   <li>Общая длина ByteArray в байтах должна равняться произведению <codeph>width</codeph> х <codeph>height</codeph> х <codeph>channels</codeph> х 4.</li>
		   <li>Свойство <codeph>endian</codeph> байтов массива должно быть <codeph>Endian.LITTLE_ENDIAN</codeph>.</li>
		 </ul>
		 
		 <p>При использовании VectorЭкземпляр &lt;Number> присваивается свойству <codeph>input</codeph>, длина Vector должна равняться произведению <codeph>width</codeph> х <codeph>height</codeph> х <codeph>channels</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:width:get"><apiName>width</apiName><shortdesc>
		 Ширина ввода затенения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 Ширина ввода затенения. Данное свойство используется только если данными ввода являются ByteArray или Vector. Экземпляр &lt;Number>. Если вводом является экземпляр BitmapData, ширина определяется автоматически.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrection"><apiName>ColorCorrection</apiName><shortdesc>
Класс ColorCorrection передает значения для свойства flash.display.Stage.colorCorrection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс ColorCorrection передает значения для свойства <codeph>flash.display.Stage.colorCorrection</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrection"><linktext>flash.display.Stage.colorCorrection</linktext></link></related-links><apiValue id="flash.display:ColorCorrection:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
Использование цветокоррекции хоста по умолчанию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Использование цветокоррекции хоста по умолчанию. Для веб-проигрывателя хостом обычно является обозреватель, и в приложении Flash Player предпринимается попытка использования цветокоррекции, соответствующей цветокоррекции веб-страницы, на которой содержится SWF-файл. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:OFF"><apiName>OFF</apiName><shortdesc>
Отключение цветокоррекции вне зависимости от среды хоста проигрывателя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>off</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Отключение цветокоррекции вне зависимости от среды хоста проигрывателя. Этот параметр позволяет повысить производительность. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:ON"><apiName>ON</apiName><shortdesc>
По возможности включение цветокоррекции вне зависимости от среды хоста проигрывателя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>on</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
По возможности включение цветокоррекции вне зависимости от среды хоста проигрывателя. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:LineScaleMode"><apiName>LineScaleMode</apiName><shortdesc>
Класс LineScaleMode передает значения для параметра scaleMode метода Graphics.lineStyle().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс LineScaleMode передает значения для параметра <codeph>scaleMode</codeph> метода <codeph>Graphics.lineStyle()</codeph>.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:LineScaleMode:HORIZONTAL"><apiName>HORIZONTAL</apiName><shortdesc>
	При использовании этого параметра в качестве параметра scaleMode метода lineStyle() толщина линии масштабируется только по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>horizontal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	При использовании этого параметра в качестве параметра <codeph>scaleMode</codeph> метода <codeph>lineStyle()</codeph> толщина линии масштабируется <i>только</i> по вертикали. Например, рассмотрим следующие окружности, нарисованные линией с толщиной 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.VERTICAL</codeph>. Масштаб окружности слева изменен только по вертикали, а окружности справа — и по вертикали и по горизонтали.
	
    <p><adobeimage alt="Окружность, масштабированная по вертикали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NONE"><apiName>NONE</apiName><shortdesc>
	При использовании этого параметра в качестве параметра scaleMode метода lineStyle() толщина линии не масштабируется.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	При использовании этого параметра в качестве параметра <codeph>scaleMode</codeph> метода <codeph>lineStyle()</codeph> толщина линии не масштабируется.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	При использовании этого параметра в качестве параметра scaleMode в методе lineStyle() толщина линии всегда будет масштабироваться при масштабировании объекта (по умолчанию).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	При использовании этого параметра в качестве параметра <codeph>scaleMode</codeph> в методе <codeph>lineStyle()</codeph> толщина линии всегда будет масштабироваться при масштабировании объекта (по умолчанию).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:VERTICAL"><apiName>VERTICAL</apiName><shortdesc>
	При использовании этого параметра в качестве параметра scaleMode метода lineStyle() толщина линии масштабируется только по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>vertical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	При использовании этого параметра в качестве параметра <codeph>scaleMode</codeph> метода <codeph>lineStyle()</codeph> толщина линии масштабируется <i>только</i> по горизонтали. Например, рассмотрим следующие окружности, нарисованные линией с толщиной 1 пиксель, для каждой из которых параметру <codeph>scaleMode</codeph> задано значение <codeph>LineScaleMode.HORIZONTAL</codeph>. Масштаб окружности слева изменен только по горизонтали, а окружности справа — и по вертикали и по горизонтали.
	
    <p><adobeimage alt="Окружность, масштабированная по горизонтали, и окружность, масштабированная по вертикали и горизонтали." href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Shader"><apiName>Shader</apiName><shortdesc>
	 Экземпляр Shader представляет ядро затенения Pixel Bender в ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Экземпляр Shader представляет ядро затенения Pixel Bender в ActionScript. Чтобы использовать затенение в приложении, необходимо создать экземпляр Shader. Затем можно использовать этот экземпляр Shader соответствующим образом в зависимости от желаемого эффекта. Например, чтобы использовать затенение в качестве фильтра, необходимо назначить экземпляр Shader свойству <codeph>shader</codeph> объекта ShaderFilter.
	 
	 <p>Затенение задает функцию, которая по очереди обрабатывает каждый пиксель изображения. В результате каждого вызова функции цвет пикселя в конкретном месте изображения меняется. В затенении может быть указано более одного изображения ввода, содержимое которого или которых может быть использовано для определения вывода функции. В затенении также может быть указан один или несколько параметров, представляющих значения ввода, которые могут быть использованы в расчетах вывода функции. При однократном выполнении операции затенения значения ввода и параметра остаются неизменными. Изменяются только координаты пикселя, цвет которого является результатом вычисления функции. Повышение производительности достигается параллельной работой нескольких функций затенения.</p>
	 
	 <p>Байт-код затенения можно загрузить в среду выполнения с помощью экземпляра URLLoader. В следующем примере демонстрируется загрузка файла байт-кода затенения в среду выполнения и его привязка к экземпляру Shader.</p>
	 
	 <codeblock>
	 var loader:URLLoader = new URLLoader();
	 loader.dataFormat = URLLoaderDataFormat.BINARY;
	 loader.addEventListener(Event.COMPLETE, onLoadComplete);
	 loader.load(new URLRequest("myShader.pbj"));
	  
	 var shader:Shader;
	  
	 function onLoadComplete(event:Event):void {
	     // Create a new shader and set the loaded data as its bytecode
	     shader = new Shader();
	     shader.byteCode = loader.data;
	     
	     // You can also pass the bytecode to the Shader() constructor like this:
	     // shader = new Shader(loader.data);
	     
	     // do something with the shader
	 }
	 </codeblock>
	 
	 <p>Вы можете непосредственно встроить затенение в ролик SWF на этапе компиляции. Для этого используйте тег метаданных <codeph>[Embed]</codeph>. Тег метаданных <codeph>[Embed]</codeph> доступен только в том случае, если при компиляции SWF используется Flex SDK. В теге <codeph>[Embed]</codeph> параметр <codeph>source</codeph> указывает на файл затенения, а параметр <codeph>mimeType</codeph> является <codeph>"application/octet-stream"</codeph>. Пример:</p>
	 
	 <codeblock>
	 [Embed(source="myShader.pbj", mimeType="application/octet-stream)]
	 var MyShaderClass:Class;
	  
	 // ...
	 
	 // create a new shader and set the embedded shader as its bytecode
	 var shaderShader = new Shader();
	 shader.byteCode = new MyShaderClass();
	  
	 // You can also pass the bytecode to the Shader() constructor like this:
	 // var shader:Shader = new Shader(new MyShaderClass());
	  
	 // do something with the shader
	 </codeblock>
	 
	 <p>В любом из двух случаев происходит привязка необработанного затенения (свойства <codeph>URLLoader.data</codeph> или экземпляра класса данных <codeph>[Embed]</codeph>) к экземпляру Shader. По аналогии с предыдущим примером это можно проделать двумя способами. Можно передать байт-код затенения в качестве аргумента конструктору <codeph>Shader()</codeph>. Либо можно задать его в качестве свойства <codeph>byteCode</codeph> экземпляра Shader.</p>
	 
	 <p>После создания экземпляра Shader его можно использовать по-разному:</p>
	 
	 <ul>
	   <li>Заливка затенением: вывод затенения используется в качестве заливки при рисовании содержимого с помощью соответствующего API. Следует передать экземпляр Shader в качестве аргумента метода <codeph>Graphics.beginShaderFill()</codeph>.</li>
	   <li>Фильтр затенением: вывод затенения используется в качестве графического фильтра, применяемого к экранному объекту. Следует назначить экземпляр Shader свойству <codeph>shader</codeph> экземпляра ShaderFilter.</li>
	   <li>Режим наложения: вывод затенения используется визуализируется в качестве наложения двух пересекающихся экранных объектов. Следует назначить экземпляр Shader свойству <codeph>blendShader</codeph> верхнего из двух пересекающихся экранных объектов.</li>
	   <li>Фоновая обработка затенения: выполнение операции затенения происходит в фоновом режиме, исключая зависания программного окна. По окончании операции отправляется соответствующее событие. Следует назначить экземпляр Shader свойству <codeph>shader</codeph> экземпляра ShaderJob.</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\ShaderExample.1.as"> В следующем примере происходит загрузка файла байт-кода затенения в среду выполнения и создание экземпляра Shader, связанного с ним.
 
 <p>Обратите внимание, что в этом примере мы исходим из того, что существует файл байт-кодов с именем donothing.pbj, хранящийся в каталоге, который является выходным для приложения. Исходный код Pixel Bender для затенения DoNothing доступен в <xref href="ShaderData.html#includeExamplesSummary">примере класса ShaderData</xref>.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class LoadedShaderExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function LoadedShaderExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example><example conref="examples\ShaderExample.2.as"> В следующем примере происходит внедрение файла байт-кода в SWF при компиляции и его привязка к экземпляру Shader.
 
 <p>Примечание. В данном примере подразумевается наличие файла байт-кода затенения с именем donothing.pbj в каталоге исходного кода, а также использование Flex SDK при компиляции SWF-файла. Исходный код Pixel Bender для затенения DoNothing доступен в <xref href="ShaderData.html#includeExamplesSummary">примере класса ShaderData</xref>.</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;

    public class EmbeddedShaderExample extends Sprite {
        
        [Embed(source="donothing.pbj", mimeType="application/octet-stream")]
        private static var DoNothingShader:Class;
        
        public function EmbeddedShaderExample() {
            var shader:Shader = new Shader();
            shader.byteCode = new DoNothingShader();
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link><link href="flash.filters.xml#ShaderFilter"><linktext>flash.filters.ShaderFilter</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><apiConstructor id="flash.display:Shader:flash.display:Shader"><apiName>Shader</apiName><shortdesc>
		 Создает новый экземпляр Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>Необработанный байт-код затенения, привязываемый к экземпляру Shader.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Создает новый экземпляр Shader.
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shader:data:set"><apiName>data</apiName><shortdesc>
		 Предоставляет доступ к параметрам, изображениям ввода и метаданным данного экземпляра Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:ShaderData</apiValueClassifier></apiValueDef><apiDesc>
		 Предоставляет доступ к параметрам, изображениям ввода и метаданным данного экземпляра Shader. При создании экземпляра Shader все объекты ShaderParameter, представляющие параметры затенения, объекты ShaderInput, представляющие изображения ввода и прочие значения, представляющие метаданные затенения, динамически добавляются в качестве свойств объекта <codeph>data</codeph>. Эти свойства можно использовать для анализа затенения, а также для настройки параметров и значений ввода.
		 
		 <p>Дополнительные сведения по получению доступа к динамическим свойствам объекта <codeph>data</codeph> и их изменению находятся в описании класса ShaderData.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:precisionHint:set"><apiName>precisionHint</apiName><shortdesc>
		 Точность вычисления математических операций, выполняемых затенением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Точность вычисления математических операций, выполняемых затенением.
		 
		 <p>Набор возможных значений свойства <codeph>precisionHint</codeph> определяется константами класса ShaderPrecision.</p>
		 
		 <p>Значение по умолчанию — <codeph>ShaderPrecision.FULL</codeph>. Если установить для точности значение <codeph>ShaderPrecision.FAST</codeph>, то выполнение математических вычислений ускорится в ущерб точности.</p>
		 
		 <p>В полном режиме точности (<codeph>ShaderPrecision.FULL</codeph>) все математические операции выполняются с использованием полного 32-разрядного стандарта IEEE, что обеспечивает согласованное поведение на всех платформах. Вычисление некоторых математических функций в этом режиме, например тригонометрических и экспонентных, может выполняться очень медленно.</p>
		 
		 <p>Быстрый режим точности (<codeph>ShaderPrecision.FAST</codeph>) предусмотрен для максимального повышения производительности, но он дает несогласованные результаты для разных платформ и индивидуальных конфигураций ЦП. Во многих случаях этого уровня точности достаточно для создания графических эффектов без видимых искажений.</p>
		 
		 <p>Выбор режима точности затенения влияет на следующие операции затенения. При использовании процессора Intel с набором инструкций SSE данные операции выполняются быстрее:</p>
		 
		 <ul>
		   <li><codeph>sin(x)</codeph></li>
		   <li><codeph>cos(x)</codeph></li>
		   <li><codeph>tan(x)</codeph></li>
		   <li><codeph>asin(x)</codeph></li>
		   <li><codeph>acos(x)</codeph></li>
		   <li><codeph>atan(x)</codeph></li>
		   <li><codeph>atan(x, y)</codeph></li>
		   <li><codeph>exp(x)</codeph></li>
		   <li><codeph>exp2(x)</codeph></li>
		   <li><codeph>log(x)</codeph></li>
		   <li><codeph>log2(x)</codeph></li>
		   <li><codeph>pow(x, y)</codeph></li>
		   <li><codeph>reciprocal(x)</codeph></li>
		   <li><codeph>sqrt(x)</codeph></li>
		 </ul>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderPrecision"><linktext>flash.display.ShaderPrecision</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:byteCode:set"><apiName>byteCode</apiName><shortdesc>
		 Необработанный байт-код затенения для данного экземпляра Shader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier></apiValueDef><apiDesc>
		 Необработанный байт-код затенения для данного экземпляра Shader.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsData"><apiName>IGraphicsData</apiName><shortdesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров в методах flash.display.Graphics, включая заливки, линии и контуры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Данный интерфейс используется для определения объектов, которые можно использовать в виде параметров в методах flash.display.Graphics, включая заливки, линии и контуры. Используйте классы implementor данного интерфейса для создания данных свойства drawing и управления ими, а также для повторного использования этих данных для других экземпляров. Затем используйте методы класса Graphics для визуализации графических объектов.
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:MovieClip"><apiName>MovieClip</apiName><shortdesc>
 Классы, которым наследует класс MovieClip: Sprite, DisplayObjectContainer, InteractiveObject, DisplayObject и EventDispatcher.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Базовые экранный объект для объектов, создаваемых ActionScript.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:Sprite</apiBaseClassifier></apiClassifierDef><apiDesc>
 Классы, которым наследует класс MovieClip: Sprite, DisplayObjectContainer, InteractiveObject, DisplayObject и EventDispatcher.
 
 <p>В отличие от объекта Sprite, объект MovieClip имеет временную шкалу.</p>
 
 <p product="flash">Методы для класса MovieClip обеспечивают те же функции, что и действия, нацеленные на фрагменты роликов. Некоторые дополнительные методы не имеют эквивалентных действий в наборе инструментов «Действия» на панели «Действия» в инструменте разработки Flash. </p>
 
 <p>Нижестоящие экземпляры, помещенные в рабочую область в инструменте разработки Flash, нельзя вызвать с помощью кода из конструктора вышестоящего экземпляра, так как они еще не созданы на момент выполнения кода. Перед обращением к нижестоящему элементу вышестоящий должен либо создать нижестоящий экземпляр с помощью кода, либо отложить вызов, пока функция обратного вызова, прослушивающая события нижестоящего элемента, не отправит его события <codeph>Event.ADDED_TO_STAGE</codeph>.</p>
 
 <p>Если изменить следующие свойства объекта MovieClip, содержащего анимацию движения, точка воспроизведения в этом объекте MovieClip останавливается: <codeph>alpha</codeph>, <codeph>blendMode</codeph>, <codeph>filters</codeph>, <codeph>height</codeph>, <codeph>opaqueBackground</codeph>, <codeph>rotation</codeph>, <codeph>scaleX</codeph>, <codeph>scaleY</codeph>, <codeph>scale9Grid</codeph>, <codeph>scrollRect</codeph>, <codeph>transform</codeph>, <codeph>visible</codeph>, <codeph>width</codeph>, <codeph>x</codeph> или <codeph>y</codeph>. Однако он не останавливает точку воспроизведения в нижестоящих элементах объектов MovieClip данного объекта MovieClip.</p>
 
 </apiDesc><example conref="examples\MovieClipExample.as"> Ниже на примере класса MovieClipExample иллюстрируется отслеживание различных свойств объекта MovieClip. Это можно сделать, выполнив следующие действия.
 
 <ol>
 
  <li>Функция конструктора определяет текстовое поле, используемое для отображения значений свойств объекта MovieClipExample (расширяющего MovieClip).</li>
 
  <li>Возвращаемое значение метода <codeph>getPropertiesString()</codeph> используется в качестве текстового поля <codeph>outputText</codeph>. Метод <codeph>getPropertiesString()</codeph> возвращает строку, заполненную значениями следующих свойств фрагмента ролика: <codeph>currentFrame</codeph>, <codeph>currentLabel</codeph>, <codeph>currentScene</codeph>, <codeph>framesLoaded</codeph>, <codeph>totalFrames</codeph> и <codeph>trackAsMenu</codeph>.</li>
 
  <li>Две строки кода в функции конструктора настраивают свойства <codeph>width</codeph> и <codeph>height</codeph> текстового поля <codeph>outputText</codeph>.</li>
 
  <li>Последняя строка функции конструктора добавляет текстовое поле <codeph>outputText</codeph> в список отображения.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.MovieClip;
    import flash.text.TextField;

    public class MovieClipExample extends MovieClip {

        public function MovieClipExample() {
            var outputText:TextField = new TextField();
            outputText.text = getPropertiesString();
            outputText.width = stage.stageWidth;
            outputText.height = outputText.textHeight;
            addChild(outputText);
        }

        private function getPropertiesString():String {
            var str:String = ""
                + "currentFrame: " + currentFrame + "\n"
                + "currentLabel: " + currentLabel + "\n"
                + "currentScene: " + currentScene + "\n"
                + "framesLoaded: " + framesLoaded + "\n"
                + "totalFrames: " + totalFrames + "\n"
                + "trackAsMenu: " + trackAsMenu + "\n";
            return str;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:MovieClip:MovieClip"><apiName>MovieClip</apiName><shortdesc>
	Создает новый экземпляр MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Создает новый экземпляр MovieClip. Создав MovieClip, вызовите метод <codeph>addChild()</codeph> или <codeph>addChildAt()</codeph> контейнера экранных объектов, находящегося в рабочей области.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:MovieClip:gotoAndPlay"><apiName>gotoAndPlay</apiName><shortdesc>
	 Запускает воспроизведение SWF-файла с заданного кадра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandplay, gotoandplay
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Число, указывающее номер кадра, или строка, представляющая ярлык кадра, на который отправлена точка воспроизведения. Если указать номер, он будет определяться относительно заданного монтажного кадра. Если не указать монтажный кадр, для определения глобального номера воспроизводимого кадра используется текущая сцена. Если указать монтажный кадр, точка воспроизведения перескакивает к нужному кадру заданного монтажного кадра.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Имя воспроизводимого монтажного кадра. Этот параметр является необязательным.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Запускает воспроизведение SWF-файла с заданного кадра. Это происходит после того, как завершается выполнения всех оставшихся действий. Чтобы указать монтажный кадр и кадр, задайте значение для параметра <codeph>scene</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.gotoAndPlay.1.as"> В следующем коде используется метод <codeph>gotoAndPlay()</codeph>, чтобы переместить точку воспроизведения фрагмента ролика <codeph>mc1</codeph> на пять кадров вперед от текущего местоположения.
<codeblock>
mc1.gotoAndPlay(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndPlay.2.as"> В следующем коде метод <codeph>gotoAndPlay()</codeph> используется для перемещения точки воспроизведения фрагмента ролика <codeph>mc1</codeph> к кадру с подписью <codeph>"intro"</codeph> в сцене <codeph>"Scene 12"</codeph>.
<codeblock>
mc1.gotoAndPlay("intro", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:gotoAndStop"><apiName>gotoAndStop</apiName><shortdesc>
	  Переводит точку воспроизведения в заданный кадр фрагмента ролика и останавливает ее в этом кадре.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandstop, gotoandstop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если заданные <codeph>scene</codeph> или <codeph>frame</codeph> отсутствуют в данном фрагменте ролика.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Число, указывающее номер кадра, или строка, представляющая ярлык кадра, на который отправлена точка воспроизведения. Если указать номер, он будет определяться относительно заданного монтажного кадра. Если не указать монтажный кадр, для определения глобального номера кадра, с которого нужно начать и на котором нужно остановить воспроизведение, используется текущий монтажный кадр. Если указать монтажный кадр, точка воспроизведения переходит к нужному кадру заданного монтажного кадра и останавливается.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Имя монтажного кадра. Этот параметр является необязательным.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Переводит точку воспроизведения в заданный кадр фрагмента ролика и останавливает ее в этом кадре. Это происходит после того, как завершается выполнения всех оставшихся действий. Если требуется указать монтажный кадр вместе с кадром, задайте параметр <codeph>scene</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> В следующем коде используется метод <codeph>gotoAndStop()</codeph> и свойство <codeph>currentFrame</codeph>, чтобы переместить точку воспроизведения фрагмента ролика <codeph>mc1</codeph> на пять кадров вперед от текущего местоположения и остановить ее.
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndStop.1.as"> В следующем коде метод <codeph>gotoAndStop()</codeph> используется для перемещения точки воспроизведения фрагмента ролика <codeph>mc1</codeph> к кадру с меткой <codeph>finale</codeph> в монтажном кадре <codeph>Scene 12</codeph> и ее остановки.
<codeblock>
mc1.gotoAndStop("finale", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:nextFrame"><apiName>nextFrame</apiName><shortdesc>
	 Переводит точку воспроизведения в следующий кадр и останавливает ее.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.nextframe, nextframe
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Переводит точку воспроизведения в следующий кадр и останавливает ее. Это происходит после того, как завершается выполнения всех оставшихся действий.
	 
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> В следующем примере временную шкалу контролируют два объекта SimpleButton. Кнопка <codeph>prev</codeph> перемещает точку воспроизведения к предыдущему кадру, а кнопка<codeph>nextBtn</codeph> перемещает точку воспроизведения к следующему кадру.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/prevFrame()"><linktext>prevFrame()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:nextScene"><apiName>nextScene</apiName><shortdesc>
	 Перемещает точку воспроизведения в следующий монтажный кадр экземпляра MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Перемещает точку воспроизведения в следующий монтажный кадр экземпляра MovieClip. Это происходит после того, как завершается выполнения всех оставшихся действий.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> В следующем примере временную шкалу контролируют два объекта SimpleButton. Кнопка <codeph>prevBtn</codeph> перемещает точку воспроизведения к предыдущему монтажному кадру, а кнопка<codeph>nextBtn</codeph> перемещает точку воспроизведения к следующему монтажному кадру.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:play"><apiName>play</apiName><shortdesc>
	 Перемещает точку воспроизведения по временной шкале фрагмента ролика.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.play, play
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Перемещает точку воспроизведения по временной шкале фрагмента ролика.
	 
	 </apiDesc><example conref="examples\MovieClip.play.1.as"> В следующем примере метод <codeph>stop()</codeph> для остановки фрагмента ролика с именем <codeph>mc1</codeph> и возобновления воспроизведения, когда пользователь щелкает текстовое поле с именем <codeph>continueText</codeph>.
<codeblock>

import flash.text.TextField;
import flash.events.MouseEvent;

var continueText:TextField = new TextField();
continueText.text = "Play movie...";
addChild(continueText);

mc1.stop();
continueText.addEventListener(MouseEvent.CLICK, resumeMovie);

function resumeMovie(event:MouseEvent):void {
    mc1.play();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>gotoAndPlay()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:prevFrame"><apiName>prevFrame</apiName><shortdesc>
	 Переводит точку воспроизведения в предыдущий кадр и останавливает ее.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.prevframe, prevframe, previous frame
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Переводит точку воспроизведения в предыдущий кадр и останавливает ее. Это происходит после того, как завершается выполнения всех оставшихся действий.
	  
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> В следующем примере временную шкалу контролируют два объекта SimpleButton. Кнопка <codeph>prev</codeph> перемещает точку воспроизведения к предыдущему кадру, а кнопка<codeph>nextBtn</codeph> перемещает точку воспроизведения к следующему кадру.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:prevScene"><apiName>prevScene</apiName><shortdesc>
	 Перемещает точку воспроизведения в предыдущий монтажный кадр экземпляра MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Перемещает точку воспроизведения в предыдущий монтажный кадр экземпляра MovieClip. Это происходит после того, как завершается выполнения всех оставшихся действий.
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> В следующем примере временную шкалу контролируют два объекта SimpleButton. Кнопка <codeph>prevBtn</codeph> перемещает точку воспроизведения к предыдущему монтажному кадру, а кнопка<codeph>nextBtn</codeph> перемещает точку воспроизведения к следующему монтажному кадру.
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:stop"><apiName>stop</apiName><shortdesc>
	 Останавливает точку воспроизведения во фрагменте ролика.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.stop, stop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Останавливает точку воспроизведения во фрагменте ролика.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:MovieClip:currentFrame:get"><apiName>currentFrame</apiName><shortdesc>
	 Определяет номер кадра, в котором точка воспроизведения находится на временной шкале экземпляра MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.currentFrame, currentFrame, currentFrame
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет номер кадра, в котором точка воспроизведения находится на временной шкале экземпляра MovieClip. Если фрагмент ролика содержит несколько монтажных кадров, это значение является номером кадра в текущем монтажном кадре.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> В следующем коде используется метод <codeph>gotoAndStop()</codeph> и свойство <codeph>currentFrame</codeph>, чтобы переместить точку воспроизведения фрагмента ролика <codeph>mc1</codeph> на пять кадров вперед от текущего местоположения и остановить ее.
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentFrameLabel:get"><apiName>currentFrameLabel</apiName><shortdesc>
	 Подпись текущего кадра на временной шкале экземпляра MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Подпись текущего кадра на временной шкале экземпляра MovieClip. Если текущий кадр не имеет подписи, значение свойства <codeph>currentLabel</codeph> равно <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrameLabel.1.as"/></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabel:get"><apiName>currentLabel</apiName><shortdesc>
	 Текущая подпись, в которой точка воспроизведения расположена на временной шкале экземпляра MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Текущая подпись, в которой точка воспроизведения расположена на временной шкале экземпляра MovieClip. Если у текущего кадра нет подписи, для <codeph>currentLabel</codeph> используется имя предыдущего кадра с подписью. Если текущий и предыдущий кадры не имеют подписи, <codeph>currentLabel</codeph> возвращает значение <codeph>null</codeph>.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabel.1.as"> На примере следующего кода показано использование свойства <codeph>currentLabel</codeph> объекта MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
trace(mc1.currentLabel);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabels:get"><apiName>currentLabels</apiName><shortdesc>
	 Возвращает массив объектов FrameLabel для текущего монтажного кадра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Возвращает массив объектов FrameLabel для текущего монтажного кадра. Если экземпляр MovieClip не использует монтажных кадров, массив включает все метки кадров из всего экземпляра MovieClip.
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabels.1.as"> На примере следующего кода показано использование свойства <codeph>currentLabel</codeph> объекта MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
import flash.display.FrameLabel;
 
var labels:Array = mc1.currentLabels;

for (var i:uint = 0; i &lt; labels.length; i++) {
    var label:FrameLabel = labels[i];
    trace("frame " + label.frame + ": " + label.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>flash.display.FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:currentScene:get"><apiName>currentScene</apiName><shortdesc>
	 Текущий монтажный кадр, в котором точка воспроизведения расположена на временной шкале экземпляра MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Scene</apiValueClassifier></apiValueDef><apiDesc>
	 Текущий монтажный кадр, в котором точка воспроизведения расположена на временной шкале экземпляра MovieClip.
	 
	 </apiDesc><example conref="examples\MovieClip.currentScene.1.as"> На примере следующего кода показано использование свойства <codeph>currentScene</codeph> объекта MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
import flash.display.Scene;
 
var scene:Scene = mc1.currentScene;
trace(scene.name + ": " + scene.numFrames + " frames");
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Сцена</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Логическое значение, определяющее включение фрагмента ролика.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Логическое значение, определяющее включение фрагмента ролика. По умолчанию свойство <codeph>enabled</codeph> имеет значение <codeph>true</codeph>. Если для <codeph>enabled</codeph> задано значение <codeph>false</codeph>, отключаются карды фрагмента ролика с подписями Over, Down и Up. Фрагмент ролика продолжает получать события (например, <codeph>mouseDown</codeph>, <codeph>mouseUp</codeph>, <codeph>keyDown</codeph> и <codeph>keyUp</codeph>).
	 
	 <p>Свойство <codeph>enabled</codeph> управляет только кнопочными свойствами фрагмента ролика. Свойство <codeph>enabled</codeph> можно изменить в любое время; обновленный фрагмент ролика немедленно включается или выключается. Если <codeph>enabled</codeph> имеет значение <codeph>false</codeph>, объект не включается в автоматическую последовательность перехода с помощью клавиши Tab.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.enabled.1.as"> На примере следующего кода показано использование свойства <codeph>enabled</codeph> для отключения кнопочных свойств объекта MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
mc1.enabled = false;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:framesLoaded:get"><apiName>framesLoaded</apiName><shortdesc>
	 Число кадров, загружаемых из потокового SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.framesLoaded, framesLoaded, framesloaded
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Число кадров, загружаемых из потокового SWF-файла. Можно использовать свойство <codeph>framesLoaded</codeph>, чтобы определить, будет ли содержимое конкретного кадра и всех предшествующих загружаться и открываться локально в обозревателе. Также его можно использовать для отслеживания загрузки больших SWF-файлов. Например, можно показывать пользователям сообщение о том, что SWF-файл загружается, до того момента, пока не закончит загружаться заданный кадр файла.
	 
	 <p>Если фрагмент ролика содержит несколько монтажных кадров, свойство <codeph>framesLoaded</codeph> возвращает количество кадров, загруженных для <i>всех</i> монтажных кадров фрагмента ролика.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.framesLoaded.1.as"> На примере следующего кода показано, как использовать свойства <codeph>framesLoaded</codeph> и <codeph>totalFrames</codeph>, чтобы определить, полностью ли загружен объект MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
if (mc1.framesLoaded == mc1.totalFrames) {
    trace("OK.");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>Класс Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:scenes:get"><apiName>scenes</apiName><shortdesc>
	 Массив объектов Scene, каждый из которых содержит имя, число кадров и подписи кадров для одного из монтажных кадров в экземпляре MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Массив объектов Scene, каждый из которых содержит имя, число кадров и подписи кадров для одного из монтажных кадров в экземпляре MovieClip.
	 
	 </apiDesc><example conref="examples\MovieClip.scenes.1.as"> На примере следующего кода показано использование свойства <codeph>scenes</codeph> объекта MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
import flash.display.Scene;
 
for (var i:uint = 0; i &lt; mc1.scenes.length; i++) {
    var scene:Scene = mc1.scenes[i];
    trace("scene " + scene.name + ": " + scene.numFrames + " frames");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Сцена</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:totalFrames:get"><apiName>totalFrames</apiName><shortdesc>
	 Общее число кадров в экземпляре MovieClip.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.totalFrames, totalFrames, totalFrames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Общее число кадров в экземпляре MovieClip.
	 
	 <p>Если фрагмент ролика содержит несколько кадров, свойство <codeph>totalFrames</codeph> возвращает общее количество кадров во <i>всех</i> монтажных кадрах фрагмента ролика.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.totalFrames.1.as"> На примере следующего кода показано использование свойства <codeph>totalFrames</codeph> объекта MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
 trace(mc1.totalFrames);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 Определяет, могут ли другие экранные объекты, являющиеся объектами SimpleButton или MovieClip, получать события отпускания кнопки мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, могут ли другие экранные объекты, являющиеся объектами SimpleButton или MovieClip, получать события отпускания кнопки мыши. Свойство <codeph>trackAsMenu</codeph> позволяет создавать меню. Свойство <codeph>trackAsMenu</codeph> можно задать для любого объекта SimpleButton или MovieClip. По умолчанию свойство <codeph>trackAsMenu</codeph> имеет значение <codeph>false</codeph>. 
	 
	 <p>Свойство <codeph>trackAsMenu</codeph> можно изменить в любой момент; модифицированный фрагмент ролика немедленно начинает использовать новое поведение.</p>
	 
	 </apiDesc><example conref="examples\MovieClip.trackAsMenu.1.as"> На примере следующего кода показано, как использовать свойство <codeph>trackAsMenu</codeph>, чтобы включить события отпускания кнопки мыши для MovieClip с именем <codeph>mc1</codeph>.
<codeblock>
 mc1.trackAsMenu = true;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SWFVersion"><apiName>SWFVersion</apiName><shortdesc>
	Класс SWFVersion — это перечисление значений констант, соответствующих версии формата загруженного SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Класс SWFVersion — это перечисление значений констант, соответствующих версии формата загруженного SWF-файла. Константы класса SWFVersion предоставляются для использования при проверке свойства <codeph>swfVersion</codeph> объекта flash.display.LoaderInfo.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/swfVersion"><linktext>flash.display.LoaderInfo.swfVersion</linktext></link></related-links><apiValue id="flash.display:SWFVersion:FLASH1"><apiName>FLASH1</apiName><shortdesc>
		Формат SWF-файла версии 1.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 1.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH10"><apiName>FLASH10</apiName><shortdesc>
		Формат SWF-файла версии 10.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>10</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 10.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH2"><apiName>FLASH2</apiName><shortdesc>
		Формат SWF-файла версии 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 2.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH3"><apiName>FLASH3</apiName><shortdesc>
		Формат SWF-файла версии 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 3.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH4"><apiName>FLASH4</apiName><shortdesc>
		Формат SWF-файла версии 4.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 4.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH5"><apiName>FLASH5</apiName><shortdesc>
		Формат SWF-файла версии 5.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 5.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH6"><apiName>FLASH6</apiName><shortdesc>
		Формат SWF-файла версии 6.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>6</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 6.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH7"><apiName>FLASH7</apiName><shortdesc>
		Формат SWF-файла версии 7.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>7</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 7.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH8"><apiName>FLASH8</apiName><shortdesc>
		Формат SWF-файла версии 8.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 8.0. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH9"><apiName>FLASH9</apiName><shortdesc>
		Формат SWF-файла версии 9.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>9</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Формат SWF-файла версии 9.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowResize"><apiName>NativeWindowResize</apiName><shortdesc>
Класс NativeWindowResize определяет константы для различных значений параметра edgeOrCorner метода NativeWindow startResize().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс NativeWindowResize определяет константы для различных значений параметра <codeph>edgeOrCorner</codeph> метода NativeWindow <codeph>startResize()</codeph>. 
<p>Определяется константа для присвоения имени каждой стороне и углу окна.</p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow/startResize()"><linktext>flash.display.NativeWindow.startResize()</linktext></link></related-links><apiValue id="flash.display:NativeWindowResize:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Нижняя сторона окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Нижняя сторона окна. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
Нижний левый угол окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Нижний левый угол окна. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
Нижний правый угол окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Нижний правый угол окна. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:LEFT"><apiName>LEFT</apiName><shortdesc>
Левая сторона окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Левая сторона окна.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:NONE"><apiName>NONE</apiName><shortdesc>
Не подсказывает системе, с какой стороны или угла начинать изменение размера, используя поведение по умолчанию.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Не подсказывает системе, с какой стороны или угла начинать изменение размера, используя поведение по умолчанию.

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Правая сторона окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Правая сторона окна. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP"><apiName>TOP</apiName><shortdesc>
Верхняя сторона окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Верхняя сторона окна. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
Верхний левый угол окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Верхний левый угол окна. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
Верхний правый угол окна.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Верхний правый угол окна. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapDataChannel"><apiName>BitmapDataChannel</apiName><shortdesc>
Класс BitmapDataChannel – это перечисление значений констант, обозначающих применяемый канал: красный, синий, зеленый или альфа-прозрачность.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс BitmapDataChannel – это перечисление значений констант, обозначающих применяемый канал: красный, синий, зеленый или альфа-прозрачность. 

<p>При вызове некоторых методов можно использовать побитовый оператор ИЛИ (<codeph>|</codeph>), чтобы комбинировать константы BitmapDataChannel для индикации многоцветных каналов.</p>

<p>Константы BitmapDataChannel передаются для использования в качестве значений в:</p>

<ul>

	<li>параметрах <codeph>sourceChannel</codeph> и <codeph>destChannel</codeph> метода <codeph>flash.display.BitmapData.copyChannel()</codeph>;</li>

	<li>параметре <codeph>channelOptions</codeph> метода <codeph>flash.display.BitmapData.noise()</codeph>;</li>

	<li>в свойствах <codeph>flash.filters.DisplacementMapFilter.componentX</codeph> и <codeph>flash.filters.DisplacementMapFilter.componentY</codeph>.</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/copyChannel()"><linktext>flash.display.BitmapData.copyChannel()</linktext></link><link href="flash.display.xml#BitmapData/noise()"><linktext>flash.display.BitmapData.noise()</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentX"><linktext>flash.filters.DisplacementMapFilter.componentX</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentY"><linktext>flash.filters.DisplacementMapFilter.componentY</linktext></link></related-links><apiValue id="flash.display:BitmapDataChannel:ALPHA"><apiName>ALPHA</apiName><shortdesc>
		Альфа-канал.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Альфа-канал. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:BLUE"><apiName>BLUE</apiName><shortdesc> 
		Синий канал.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		Синий канал. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:GREEN"><apiName>GREEN</apiName><shortdesc>
		Зеленый канал.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Зеленый канал.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:RED"><apiName>RED</apiName><shortdesc>
		Красный канал.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Красный канал. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Определяет сплошную заливку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Определяет сплошную заливку. 
 
 <p>
 Используйте объект GraphicsSolidFill совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>. Рисование объекта GraphicsSolidFill эквивалентно вызову метода <codeph>Graphics.beginFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>flash.display.Graphics.beginFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsSolidFill:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 Создает новый объект GraphicsSolidFill.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Значение цвета. Действительны значения в шестнадцатеричном формате 0xRRGGBB.  
 </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Значение альфа-прозрачности. Допустимые значения находятся в диапазоне 0 (полностью прозрачный) — 1 (полностью непрозрачный).
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 Создает новый объект GraphicsSolidFill. 
 
 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:GraphicsSolidFill:alpha"><apiName>alpha</apiName><shortdesc>
 Указывает значение альфа-прозрачности заливки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Указывает значение альфа-прозрачности заливки. Допустимые значения находятся в диапазоне 0 (полностью прозрачный) — 1 (полностью непрозрачный). Значением по умолчанию является 1. Экранные объекты, для которых значение alpha равно 0, являются активными, несмотря на невидимость. 
 
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsSolidFill:color"><apiName>color</apiName><shortdesc>
 Цвет заполнения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
 Цвет заполнения. Действительны значения в шестнадцатеричном формате 0xRRGGBB. Значение по умолчанию — 0xFF0000 (или uint 0). 
 
 
 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IBitmapDrawable"><apiName>IBitmapDrawable</apiName><shortdesc>
	Интерфейс IBitmapDrawable реализуется объектами, которые могут передаваться в качестве параметра source метода draw() класса BitmapData.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	Интерфейс IBitmapDrawable реализуется объектами, которые могут передаваться в качестве параметра <codeph>source</codeph> метода <codeph>draw()</codeph> класса BitmapData. Эти объекты относятся к типу BitmapData или DisplayObject. 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:CapsStyle"><apiName>CapsStyle</apiName><shortdesc>
 Класс CapsStyle — это перечисление значений констант, задающих стили концов линий при рисовании линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс CapsStyle — это перечисление значений констант, задающих стили концов линий при рисовании линий. Константы предназначены для использования в качестве значений параметра <codeph>caps</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph>. Можно задать концы линий трех типов:
 
 <p><adobeimage alt="Три типа концов линий: NONE (нет), ROUND (круглые) и SQUARE (квадратные)." href="../../images/linecap.jpg"/></p> 
 
 </apiDesc><example conref="examples\CapsStyleExample.as"> В следующем примере класс <codeph>CapsStyleExample</codeph> используется для рисования трех параллельных линий с разными типами концов.
 <ol>
     <li>Для каждой линии заданы следующие свойства.
     <ul>
         <li>Длина линии — 80 пикселей.</li>
         <li>Цвет рамки — оранжевый.</li>
         <li>Размер рамки — 30 пикселей. </li>
         <li>Цвет подсветки — серый. </li>
         <li>Размер подсветки — 0 пикселей.</li>
         <li>Значение альфа-канала — 1 для получения сплошного цвета.</li>
         <li>Хинтинг пикселей имеет значение false (не выполняется хинтинг до полных пикселей).</li>
         <li>Режим масштабирования линий - обычный: масштабирование по ширине. </li>
         <li>Стиль стыка концов рамки - <codeph>MITER</codeph> (уголок).</li>
         <li>Длина уголка - 1, то есть, уголок обрезается близко к линии.</li>
     </ul></li>
    <li>Конструктор класса создает три вертикальные линии, начиная с координат <i>x = 0, y = 0</i>, путем троекратного вызова метода <codeph>drawLine()</codeph> с использованием разных стилей концов линий (нет, круглые, квадратные). В каждом из трех вызовов метода <codeph>drawLine()</codeph> используются перечисленные выше стиль концов и свойства для рисования вертикальной линии и соответствующей подсветки. Первый вызов создает новый объект Shape <codeph>child</codeph>, а затем с помощью методов класса Graphics задается стиль линии и рисуются линии с подсветкой. Каждый экземпляр <codeph>child</codeph> добавляется в список отображения и отрисовывается в рабочей области.</li>
     <li>Соединенные сегменты линии перерисовываются с использованием метода <codeph>refreshLayout()</codeph> на пикселях <i>y = 80</i>, начиная с пикселей <i>x = 80</i>, где сегменты линии разделены 25 пикселями.</li>
 </ol>
<codeblock>
package {
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class CapsStyleExample extends Sprite {
        private var lineLength:uint            = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderJointStyle:String    = JointStyle.MITER;
        private var borderMiterLimit:uint      = 1;

        public function CapsStyleExample() {
            drawLine(CapsStyle.NONE);
            drawLine(CapsStyle.ROUND);
            drawLine(CapsStyle.SQUARE);
            refreshLayout();
        }

        private function drawLine(capsStyle:String):void {
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     capsStyle,
                                     borderJointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = lineLength;
            lastChild.y = lineLength;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = lineLength;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:CapsStyle:NONE"><apiName>NONE</apiName><shortdesc>
	 
	 С его помощью в параметре caps метода flash.display.Graphics.lineStyle() задается отсутствие концов линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 С его помощью в параметре <codeph>caps</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph> задается отсутствие концов линий.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	 
	 С его помощью в параметре caps метода flash.display.Graphics.lineStyle() задаются круглые концы линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 С его помощью в параметре <codeph>caps</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph> задаются круглые концы линий.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:SQUARE"><apiName>SQUARE</apiName><shortdesc>
	 
	 С его помощью в параметре caps метода flash.display.Graphics.lineStyle() задаются квадратные концы линий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>square</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 С его помощью в параметре <codeph>caps</codeph> метода <codeph>flash.display.Graphics.lineStyle()</codeph> задаются квадратные концы линий.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageScaleMode"><apiName>StageScaleMode</apiName><shortdesc>
Класс StageScaleMode передает значения для свойства Stage.scaleMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс StageScaleMode передает значения для свойства <codeph>Stage.scaleMode</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/scaleMode"><linktext>flash.display.Stage.scaleMode</linktext></link></related-links><apiValue id="flash.display:StageScaleMode:EXACT_FIT"><apiName>EXACT_FIT</apiName><shortdesc>
Задает видимость всего приложения в указанной области. При этом исходное соотношение сторон не сохраняется.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exactFit</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает видимость всего приложения в указанной области. При этом исходное соотношение сторон не сохраняется. Может возникнуть искажение изображения.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_BORDER"><apiName>NO_BORDER</apiName><shortdesc>
Задает заполнение указанной области приложением без искажений, но с возможным усечением. При этом поддерживается исходное соотношение сторон приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noBorder</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает заполнение указанной области приложением без искажений, но с возможным усечением. При этом поддерживается исходное соотношение сторон приложения.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_SCALE"><apiName>NO_SCALE</apiName><shortdesc>
Задает фиксированный размер приложения, который сохраняется даже при изменении размеров окна проигрывателя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noScale</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает фиксированный размер приложения, который сохраняется даже при изменении размеров окна проигрывателя. Если окно проигрывателя меньше размеров содержимого, может возникнуть усечение.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:SHOW_ALL"><apiName>SHOW_ALL</apiName><shortdesc>
Задает видимость всего приложения в указанной области без искажений при поддержании исходного соотношения сторон приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>showAll</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает видимость всего приложения в указанной области без искажений при поддержании исходного соотношения сторон приложения. С двух сторон от приложения могут появиться поля.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SpreadMethod"><apiName>SpreadMethod</apiName><shortdesc>
Класс SpreadMethod содержит значения параметра spreadMethod методов beginGradientFill() и lineGradientStyle() класса Graphics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс SpreadMethod содержит значения параметра <codeph>spreadMethod</codeph> методов <codeph>beginGradientFill()</codeph> и <codeph>lineGradientStyle()</codeph> класса Graphics.

<p>В следующем примере показана та же заливка градиентом с использованием разных методов нанесения.</p>

<adobetable>





<tgroup cols="3"><tbody><row>

	<entry align="center"><adobeimage alt="линейный градиент с методом SpreadMethod.PAD" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>

  <entry align="center"><adobeimage alt="линейный градиент с методом SpreadMethod.REFLECT" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>

  <entry align="center"><adobeimage alt="линейный градиент с методом SpreadMethod.REPEAT" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>

</row><row>

	 <entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>


</row></tbody></tgroup></adobetable>


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:SpreadMethod:PAD"><apiName>PAD</apiName><shortdesc>
Показывает, что градиент применяет нанесение заполнением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pad</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Показывает, что градиент применяет нанесение <i>заполнением</i>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REFLECT"><apiName>REFLECT</apiName><shortdesc>
Показывает, что градиент применяет нанесение отражением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reflect</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Показывает, что градиент применяет нанесение <i>отражением</i>.
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REPEAT"><apiName>REPEAT</apiName><shortdesc>
Показывает, что градиент применяет нанесение повторением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>repeat</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Показывает, что градиент применяет нанесение <i>повторением</i>.
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:FocusDirection"><apiName>FocusDirection</apiName><shortdesc>
 В классе FocusDirection перечислены значения, используемые параметром direction метода assignFocus() объекта Stage, а также в качестве свойства direction объекта FocusEvent.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 В классе FocusDirection перечислены значения, используемые параметром <codeph>direction</codeph> метода <codeph>assignFocus()</codeph> объекта Stage, а также в качестве свойства <codeph>direction</codeph> объекта FocusEvent.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#FocusEvent/direction"><linktext>flash.events.FocusEvent.direction</linktext></link><link href="flash.display.xml#Stage/assignFocus()"><linktext>flash.display.Stage.assignFocus()</linktext></link></related-links><apiValue id="flash.display:FocusDirection:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
		Указывает на то, что фокус будет передан объекту в конце последовательности считывания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bottom</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Указывает на то, что фокус будет передан объекту в конце последовательности считывания.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:NONE"><apiName>NONE</apiName><shortdesc>
		Указывает на то, что объект с фокусом в пределах интерактивного объекта изменяться не должен.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Указывает на то, что объект с фокусом в пределах интерактивного объекта изменяться не должен.
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:TOP"><apiName>TOP</apiName><shortdesc>
		Указывает на то, что фокус будет передан объекту в начале последовательности считывания.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>top</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		Указывает на то, что фокус будет передан объекту в начале последовательности считывания.
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageAlign"><apiName>StageAlign</apiName><shortdesc>
Класс StageAlign передает значения констант для свойства Stage.align.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс StageAlign передает значения констант для свойства <codeph>Stage.align</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/align"><linktext>flash.display.Stage.align</linktext></link></related-links><apiValue id="flash.display:StageAlign:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
Задает выравнивание рабочей области по нижнему краю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по нижнему краю. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
Задает выравнивание рабочей области по левому нижнему углу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по левому нижнему углу. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
Задает выравнивание рабочей области по правому нижнему углу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по правому нижнему углу. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
Задает выравнивание рабочей области по левому краю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по левому краю. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
Задает выравнивание рабочей области по правому краю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по правому краю. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP"><apiName>TOP</apiName><shortdesc>
Задает выравнивание рабочей области по верхнему краю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по верхнему краю. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
Задает выравнивание рабочей области по левому верхнему углу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по левому верхнему углу. 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
Задает выравнивание рабочей области по правому верхнему углу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает выравнивание рабочей области по правому верхнему углу. 
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrectionSupport"><apiName>ColorCorrectionSupport</apiName><shortdesc>
Класс ColorCorrectionSupport передает значения для свойства flash.display.Stage.colorCorrectionSupport.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс ColorCorrectionSupport передает значения для свойства <codeph>flash.display.Stage.colorCorrectionSupport</codeph>. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>flash.display.Stage.colorCorrectionSupport</linktext></link></related-links><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_OFF"><apiName>DEFAULT_OFF</apiName><shortdesc>
Цветокоррекция поддерживается, но отключена по умолчанию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOff</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Цветокоррекция поддерживается, но отключена по умолчанию. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_ON"><apiName>DEFAULT_ON</apiName><shortdesc>
Цветокоррекция поддерживается и включена по умолчанию.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOn</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Цветокоррекция поддерживается и включена по умолчанию. 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:UNSUPPORTED"><apiName>UNSUPPORTED</apiName><shortdesc>
Цветокоррекция не поддерживается средой хоста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unsupported</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Цветокоррекция не поддерживается средой хоста. 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
 Определяет заливку затенением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Определяет заливку затенением. 
 
 <p>
 Используйте объект GraphicsShaderFill совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>. Рисование объекта GraphicsShaderFill эквивалентно вызову метода <codeph>Graphics.beginShaderFill()</codeph>.
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsShaderFill:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
     Создает новый объект GraphicsShaderFill.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Затенение, которое должно использоваться для заливки. Для указания входного изображения данный экземпляр Shader не требуется. Однако, если в затенении входное изображение указано, его необходимо настроить вручную в свойстве <codeph>input</codeph> соответствующего свойства ShaderInput свойства <codeph>Shader.data</codeph>.
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект матрицы (из класса flash.geom.Matrix), который можно использовать для определения преобразований в затенении. 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект GraphicsShaderFill.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsShaderFill:matrix"><apiName>matrix</apiName><shortdesc>
     Объект матрицы (из класса flash.geom.Matrix), который можно использовать для определения преобразований в затенении.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     Объект матрицы (из класса flash.geom.Matrix), который можно использовать для определения преобразований в затенении. Например, можно использовать следующую матрицу для поворота затенения на 45 градусов (пи/4 радиан):
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     <p>В основе полученных в затенении координат лежит матрица, указанная для параметра <codeph>matrix</codeph>. В матрице по умолчанию (<codeph>null</codeph>) этими координатами в затенении являются локальные координаты пикселей, которые могут быть использованы для пробы ввода.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsShaderFill:shader"><apiName>shader</apiName><shortdesc>
     Затенение, которое должно использоваться для заливки.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
     Затенение, которое должно использоваться для заливки. Для указания входного изображения данный экземпляр Shader не требуется. Однако, если в затенении входное изображение указано, его необходимо настроить вручную в свойстве <codeph>input</codeph> соответствующего свойства ShaderInput свойства <codeph>Shader.data</codeph>.
     
     <p>При передачи экземпляра Shader в качестве аргумента происходит его копирование на внутреннем уровне. При выполнении операции заливки используется эта копия, а не ссылка за исходное затенение. Изменения параметров затенения (изменение значения параметра, ввода или байт-кода) не влияют на используемую для заливки копию затенения.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Shape"><apiName>Shape</apiName><shortdesc>
 Этот класс позволяет создавать облегченные фигуры с помощью API-интерфейса для рисования ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Экранный объект, используемый для фигур.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс позволяет создавать облегченные фигуры с помощью API-интерфейса для рисования ActionScript. Класс Shape включает свойство <codeph>graphics</codeph>, обеспечивающее доступ к методам класса Graphics.
 
 <p>Класс Sprite также включает свойство <codeph>graphics</codeph> и другие функции, недоступные в классе Shape. Например, объект Sprite является контейнером экранных объектов, а объект Shape не является (и не может содержать нижестоящих элементов экранных объектов). По этой причине объекты Shape используют меньше памяти, чем объекты Sprite, содержащие те же графические элементы. Однако объект Sprite поддерживает события нажатия мыши, а объект Shape — нет.</p>
 
 </apiDesc><example conref="examples\ShapeExample.as"> В следующем примере рассматривается использование класса <codeph>ShapeExample</codeph> для рисования круга, прямоугольного примитива со скругленными углами и квадрата. Это можно сделать, выполнив следующие действия.
 
 <ol>
    <li>Объявите свойство <codeph>size</codeph> для последующего использования при определении размера каждой фигуры.</li>
 
     <li>Объявите свойства, определяющие оранжевый цвет фона, темно-серый цвет рамки, размер рамки в пикселях, равный 0, радиус угла, равный 9 пикселям; также задайте расстояние между краем рабочей области и другими объектами, равное 5 пикселям.</li>
 
    <li>Используйте свойства, объявленные в предыдущих шагах, вместе со встроенными методами класса Graphics, чтобы нарисовать круг, прямоугольный примитив со скругленными углами и квадрат с координатами x = 0, y = 0.</li>
 
    <li>Повторно нарисуйте все эти фигуры у верхнего края рабочей области, начиная с точки x = 5, y = 5 с расстоянием 5 пикселей между ними с использованием метода <codeph>refreshLayout()</codeph>.</li>
 
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class ShapeExample extends Sprite {
        private var size:uint           = 80;
        private var bgColor:uint       = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function ShapeExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size/2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#Sprite"><linktext>flash.display.Sprite</linktext></link></related-links><apiConstructor id="flash.display:Shape:Shape"><apiName>Shape</apiName><shortdesc>
     Создает новый объект Shape.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Создает новый объект Shape.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shape:graphics:get"><apiName>graphics</apiName><shortdesc>
     Указывает объект Graphics, принадлежащий этому объекту Shape, где можно выполнять команды векторного рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>Задает объект Graphics для объекта Shape.
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     Указывает объект Graphics, принадлежащий этому объекту Shape, где можно выполнять команды векторного рисования.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameterType"><apiName>ShaderParameterType</apiName><shortdesc>
	 Этот класс содержит константы, представляющие возможные значения для свойства type класса ShaderParameter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Этот класс содержит константы, представляющие возможные значения для свойства <codeph>type</codeph> класса ShaderParameter. Каждая константа представляет один из типов данных параметров, доступных для использования в Flash Player на языке Pixel Bender для затенений.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links><apiValue id="flash.display:ShaderParameterType:BOOL"><apiName>BOOL</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип bool и в ActionScript совпадает с единственным экземпляром Boolean.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>bool</codeph> и в ActionScript совпадает с единственным экземпляром Boolean.
		 
		 <p>Имейте ввиду, что несмотря на то, что данный параметр ожидает единственное значение, свойство <codeph>ShaderParameter.value</codeph> является массивом. Поэтому, данное значение должно являться единственным значением массива, присвоенное свойству <codeph>value</codeph>. Например:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is bool
		 myShader.data.param.value = [true];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL2"><apiName>BOOL2</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип bool2 и в ActionScript совпадает с массивом с двумя экземплярами Boolean.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>bool2</codeph> и в ActionScript совпадает с массивом с двумя экземплярами Boolean.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL3"><apiName>BOOL3</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип bool3 и в ActionScript совпадает с массивом с тремя экземплярами Boolean.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>bool3</codeph> и в ActionScript совпадает с массивом с тремя экземплярами Boolean.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL4"><apiName>BOOL4</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип bool4 и в ActionScript совпадает с массивом с четырьмя экземплярами Boolean.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>bool4</codeph> и в ActionScript совпадает с массивом с четырьмя экземплярами Boolean.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT"><apiName>FLOAT</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float и в ActionScript совпадает с единственным экземпляром Number.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float</codeph> и в ActionScript совпадает с единственным экземпляром Number.
		 
		 <p>Имейте ввиду, что несмотря на то, что данный параметр ожидает единственное значение, свойство <codeph>ShaderParameter.value</codeph> является массивом. Поэтому, данное значение должно являться единственным значением массива, присвоенное свойству <codeph>value</codeph>. Например:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is float
		 myShader.data.param.value = [22.5];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT2"><apiName>FLOAT2</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float2 и совпадает с массивом с двумя экземплярами Number в ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float2</codeph> и совпадает с массивом с двумя экземплярами Number в ActionScript.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT3"><apiName>FLOAT3</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float3 и в ActionScript совпадает с массивом с тремя экземплярами Number.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float3</codeph> и в ActionScript совпадает с массивом с тремя экземплярами Number.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT4"><apiName>FLOAT4</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float4 и в ActionScript совпадает с массивом с четырьмя экземплярами Number.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float4</codeph> и в ActionScript совпадает с массивом с четырьмя экземплярами Number.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT"><apiName>INT</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип int и в ActionScript совпадает с единственным экземпляром int или uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>int</codeph> и в ActionScript совпадает с единственным экземпляром int или uint.
		 
		 <p>Имейте ввиду, что несмотря на то, что данный параметр ожидает единственное значение, свойство <codeph>ShaderParameter.value</codeph> является массивом. Поэтому, данное значение должно являться единственным значением массива, присвоенное свойству <codeph>value</codeph>. Например:</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is int
		 myShader.data.param.value = [275];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT2"><apiName>INT2</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип int2 и в ActionScript совпадает с массивом с двумя экземплярами int или uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>int2</codeph> и в ActionScript совпадает с массивом с двумя экземплярами int или uint.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT3"><apiName>INT3</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип int3  и в ActionScript совпадает с массивом с тремя экземплярами int или uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>int3 </codeph> и в ActionScript совпадает с массивом с тремя экземплярами int или uint.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT4"><apiName>INT4</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип int4 и в ActionScript совпадает с массивом с четырьмя экземплярами int или uint.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>int4 </codeph> и в ActionScript совпадает с массивом с четырьмя экземплярами int или uint.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX2X2"><apiName>MATRIX2X2</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float2x2 и совпадает с матрицей 2 на 2.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix2x2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float2x2</codeph> и совпадает с матрицей 2 на 2. В ActionScript данная матрица представляет массив из четырех экземпляров Number.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX3X3"><apiName>MATRIX3X3</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float3x3 и совпадает с матрицей 3 на 3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix3x3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float3x3</codeph> и совпадает с матрицей 3 на 3. В ActionScript данная матрица представляет массив из девяти экземпляров Number.
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX4X4"><apiName>MATRIX4X4</apiName><shortdesc>
		 Указывает на то, что значение параметра затенения имеет тип float4x4 и совпадает с матрицей 4 на 4.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix4x4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Указывает на то, что значение параметра затенения имеет тип <codeph>float4x4</codeph> и совпадает с матрицей 4 на 4. В ActionScript данная матрица представляет массив из шестнадцати экземпляров Number.
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathWinding"><apiName>GraphicsPathWinding</apiName><shortdesc>
Класс GraphicsPathWinding содержит значения для свойства flash.display.GraphicsPath.winding и метода flash.display.Graphics.drawPath() для определения направления отрисовки контура.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс GraphicsPathWinding содержит значения для свойства <codeph>flash.display.GraphicsPath.winding</codeph> и метода <codeph>flash.display.Graphics.drawPath()</codeph> для определения направления отрисовки контура. Направление контура по часовой стрелке считается положительным, а против часовой стрелки — отрицательным:
<p><adobeimage alt="положительные и отрицательные направления для заливки" href="../../images/winding_positive_negative.gif"/></p>
<p> При пересечении или наложении контуров их направление определяет правило заливки областей, созданных пересечением или наложением:</p>
<p><adobeimage alt="сравнение заливки по правилу четности-нечетности и ненулевого направления" href="../../images/winding_rules_evenodd_nonzero.gif"/></p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#GraphicsPath/winding"><linktext>flash.display.GraphicsPath.winding</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiValue id="flash.display:GraphicsPathWinding:EVEN_ODD"><apiName>EVEN_ODD</apiName><shortdesc>
Задает заливку по правилу четности-нечетности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>evenOdd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает заливку по правилу четности-нечетности. Заливка по правилу четности-нечетности используется всеми API для рисования и является типом заливки по умолчанию для метода <codeph>flash.display.Graphics.drawPath()</codeph>. Для накладывающихся контуров заливка будет перемежаться пустыми областями. При пересечении двух квадратов с одинаковой заливкой область пересечения останется без заливки. Смежные области всегда разные (одна с заливкой, другая — без). 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathWinding:NON_ZERO"><apiName>NON_ZERO</apiName><shortdesc>
Задает заливку по правилу ненулевого направления.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>nonZero</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
Задает заливку по правилу ненулевого направления. При заливке по правилу ненулевого направления в случае пересечения разнонаправленных контуров область пересечения останется без заливки (как при заливке по правилу четности-нечетности). При пересечении однонаправленных контуров область пересечения будет закрашена.

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ActionScriptVersion"><apiName>ActionScriptVersion</apiName><shortdesc>
	Класс ActionScriptVersion является перечислением значений констант, указывающих на версию языка загруженного SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Класс ActionScriptVersion является перечислением значений констант, указывающих на версию языка загруженного SWF-файла. Константы версии языка предоставляются для использования при проверке свойства <codeph>actionScriptVersion</codeph> объекта flash.display.LoaderInfo.
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/actionScriptVersion"><linktext>flash.display.LoaderInfo.actionScriptVersion</linktext></link></related-links><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT2"><apiName>ACTIONSCRIPT2</apiName><shortdesc>
		Язык ActionScript версии 2.0 и более ранних версий.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Язык ActionScript версии 2.0 и более ранних версий. 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT3"><apiName>ACTIONSCRIPT3</apiName><shortdesc>
		Язык ActionScript версии 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Язык ActionScript версии 3.0. 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
 Набор команд рисования и параметры координат для этих команд.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Набор команд рисования и параметры координат для этих команд.
 <p>
 Используйте объект GraphicsPath совместно с методом <codeph>Graphics.drawGraphicsData()</codeph>. Рисование объекта GraphicsPath эквивалентно вызову метода <codeph>Graphics.drawPath()</codeph>.
 </p>
 <p>Для класса GraphicsPath также предусмотрен собственный набор методов (<codeph>curveTo()</codeph>, <codeph>lineTo()</codeph>, <codeph>moveTo()</codeph> <codeph>wideLineTo()</codeph> и <codeph>wideMoveTo()</codeph>), которые аналогичны методам в классе Graphics для корректировки векторных массивов <codeph>GraphicsPath.commands</codeph> и <codeph>GraphicsPath.data</codeph>.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsPath:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
     Создает новый объект GraphicsPath.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>Вектор целых чисел, представляющий команды, определенные классом GraphicsPathCommand.
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>Вектор чисел, где каждая пара чисел рассматривается как точка (пара координат x, y).
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>Указывает правило изгиба с использованием значения, определенного в классе GraphicsPathWinding.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект GraphicsPath.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:GraphicsPath:curveTo"><apiName>curveTo</apiName><shortdesc>
     Добавляет новую команду curveTo к вектору commands и новые координаты к вектору data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение опорной точки относительно точки регистрации вышестоящего экранного объекта.  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение опорной точки относительно точки регистрации вышестоящего экранного объекта.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее горизонтальное положение следующей точки привязки относительно точки регистрации вышестоящего экранного объекта.  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, указывающее вертикальное положение следующей точки привязки относительно точки регистрации вышестоящего экранного объекта.
     
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет новую команду curveTo к вектору <codeph>commands </codeph> и новые координаты к вектору <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/CURVE_TO"><linktext>flash.display.GraphicsPathCommand.CURVE_TO</linktext></link><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:lineTo"><apiName>lineTo</apiName><shortdesc>
     Добавляет новую команду lineTo к вектору commands и новые координаты к вектору data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата x точки назначения прямой.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата y точки назначения прямой.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет новую команду lineTo к вектору <codeph>commands</codeph> и новые координаты к вектору <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>flash.display.GraphicsPathCommand.LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:moveTo"><apiName>moveTo</apiName><shortdesc>
     Добавляет новую команду moveTo к вектору commands и новые координаты к вектору data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата x точки назначения.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата y точки назначения.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет новую команду moveTo к вектору <codeph>commands</codeph> и новые координаты к вектору <codeph>data</codeph>.
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>flash.display.GraphicsPathCommand.MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideLineTo"><apiName>wideLineTo</apiName><shortdesc>
     Добавляет новую команду wideLineTo к вектору commands и новые координаты к вектору data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата x точки назначения прямой.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата y точки назначения прямой.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет новую команду wideLineTo к вектору <codeph>commands</codeph> и новые координаты к вектору <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_LINE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_LINE_TO</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideMoveTo"><apiName>wideMoveTo</apiName><shortdesc>
     Добавляет новую команду wideMoveTo к вектору commands и новые координаты к вектору data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата x точки назначения.
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата y точки назначения.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет новую команду wideMoveTo к вектору <codeph>commands</codeph> и новые координаты к вектору <codeph>data</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_MOVE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_MOVE_TO</linktext></link></related-links></apiOperation><apiValue id="flash.display:GraphicsPath:commands"><apiName>commands</apiName><shortdesc>
     Вектор команд рисования в виде целых чисел, представляющий контур.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     Вектор команд рисования в виде целых чисел, представляющий контур. Каждая команда может представлять одно из значений, заданных в классе GraphicsPathCommand.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPath:data"><apiName>data</apiName><shortdesc>
     Вектор чисел, содержащий параметры, используемые для команд рисования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     Вектор чисел, содержащий параметры, используемые для команд рисования.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPath:winding:get"><apiName>winding</apiName><shortdesc>
     Указывает правило изгиба с использованием значения, определенного в классе GraphicsPathWinding.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает правило изгиба с использованием значения, определенного в классе GraphicsPathWinding.
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:MorphShape"><apiName>MorphShape</apiName><shortdesc>
 Класс MorphShape представляет объекты MorphShape в списке отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс MorphShape представляет объекты MorphShape в списке отображения. Объекты MorphShape нельзя создавать непосредственно в ActionScript; они создаются при создании анимации формы в инструменте разработки Flash.
 
 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="flash.display:PixelSnapping"><apiName>PixelSnapping</apiName><shortdesc>

Класс PixelSnapping — это перечисление значений констант для задания параметров привязки к пикселям с помощью свойства pixelSnapping объекта Bitmap.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Класс PixelSnapping — это перечисление значений констант для задания параметров привязки к пикселям с помощью свойства <codeph>pixelSnapping</codeph> объекта Bitmap.


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/pixelSnapping"><linktext>flash.display.Bitmap.pixelSnapping</linktext></link></related-links><apiValue id="flash.display:PixelSnapping:ALWAYS"><apiName>ALWAYS</apiName><shortdesc>
	Значение константы, применяемое свойством pixelSnapping объекта Bitmap: растровое изображение всегда привязывается к ближайшему пикселю независимо от преобразований.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>always</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Значение константы, применяемое свойством <codeph>pixelSnapping</codeph> объекта Bitmap: растровое изображение всегда привязывается к ближайшему пикселю независимо от преобразований.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:AUTO"><apiName>AUTO</apiName><shortdesc>
	Значение константы, применяемое свойством pixelSnapping объекта Bitmap: растровое изображение привязывается к ближайшему пикселю, если не выполнялось вращение или наклон, а также если оно отображено в масштабе от 99,9% до 100,1%.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>auto</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Значение константы, применяемое свойством <codeph>pixelSnapping</codeph> объекта Bitmap: растровое изображение привязывается к ближайшему пикселю, если не выполнялось вращение или наклон, а также если оно отображено в масштабе от 99,9% до 100,1%. Если эти условия удовлетворяются, изображение отображается в масштабе 100% с привязкой к ближайшему пикселю. На внутреннем уровне этот параметр позволяет показывать изображение с максимальной быстротой с помощью векторного средства визуализации.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:NEVER"><apiName>NEVER</apiName><shortdesc>
	Значение константы, применяемое свойством pixelSnapping объекта Bitmap: привязка к пикселям не применяется.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Значение константы, применяемое свойством <codeph>pixelSnapping</codeph> объекта Bitmap: привязка к пикселям не применяется.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathCommand"><apiName>GraphicsPathCommand</apiName><shortdesc>
 Задает значения, которые используются для указания команд рисования контуров.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Задает значения, которые используются для указания команд рисования контуров. 
 
 <p>Значения данного класса используются методом <codeph>Graphics.drawPath()</codeph> или хранятся в векторе <codeph>commands</codeph> объекта GraphicsPath.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link><link href="flash.display.xml#GraphicsPath/commands"><linktext>flash.display.GraphicsPath.commands</linktext></link></related-links><apiValue id="flash.display:GraphicsPathCommand:CURVE_TO"><apiName>CURVE_TO</apiName><shortdesc>
     Указывает команду рисования, которая рисует кривую от текущего положения инструмента рисования до точки с координатами х и у, заданными вектором данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Указывает команду рисования, которая рисует кривую от текущего положения инструмента рисования до точки с координатами х и у, заданными вектором данных. Данная команда приводит к тому же результату, что и метод <codeph>Graphics.lineTo()</codeph>, и использует две точки в векторе данных — контрольную и точку привязки: (cx, cy, ax, ay).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:LINE_TO"><apiName>LINE_TO</apiName><shortdesc>
     Указывает команду рисования, которая рисует линию от текущего положения инструмента рисования до точки с координатами х и у, заданными вектором данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Указывает команду рисования, которая рисует линию от текущего положения инструмента рисования до точки с координатами х и у, заданными вектором данных. Данная команда приводит к тому же результату, что и метод <codeph>Graphics.lineTo()</codeph>, и использует одну точку в векторе данных: (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:MOVE_TO"><apiName>MOVE_TO</apiName><shortdesc>
     Указывает команду рисования, которая перемещает текущее положение инструмента рисования в точку с координатами х и у, заданными вектором данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Указывает команду рисования, которая перемещает текущее положение инструмента рисования в точку с координатами х и у, заданными вектором данных. Данная команда приводит к тому же результату, что и метод <codeph>Graphics.moveTo()</codeph>, и использует одну точку в векторе данных: (x,y).
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:NO_OP"><apiName>NO_OP</apiName><shortdesc>
     Представляет команду по умолчанию «do nothing».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Представляет команду по умолчанию «do nothing».
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_LINE_TO"><apiName>WIDE_LINE_TO</apiName><shortdesc>
     Задает команду рисования «line to», но использует две пары координат (четыре значения) вместо одной.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Задает команду рисования line to, но использует две пары координат (четыре значения) вместо одной. Данная команда позволяет переключаться между командами line to и curve to, не изменяя количества значений данных, используемых командой. Данная команда использует два набора значений вектора данных: один набор фиктивных координат и один набор координат положения (x,y).
     
     <p>Варианты команды <codeph>WIDE_LINE_TO</codeph> и <codeph>WIDE_MOVE_TO</codeph> используют такое же количество параметров, что и команда <codeph>CURVE_TO</codeph>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_MOVE_TO"><apiName>WIDE_MOVE_TO</apiName><shortdesc>
     Задает команду рисования move to, но использует две пары координат (четыре значения) вместо одной.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Задает команду рисования «move to», но использует две пары координат (четыре значения) вместо одной. Данная команда позволяет переключаться между командами «move to» и «curve to», не изменяя количества значений данных, используемых командой. Данная команда использует два набора значений вектора данных: один набор фиктивных координат и один набор координат положения (x,y).
     
     <p>Варианты команды <codeph>WIDE_LINE_TO</codeph> и <codeph>WIDE_MOVE_TO</codeph> используют такое же количество параметров, что и команда <codeph>CURVE_TO</codeph>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>