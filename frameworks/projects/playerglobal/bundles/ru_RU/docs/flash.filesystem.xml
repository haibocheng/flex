<?xml version="1.0"?>
<apiPackage id="flash.filesystem"><apiName>flash.filesystem</apiName><apiDetail/><apiClassifier id="flash.filesystem:FileStream"><apiName>FileStream</apiName><shortdesc>
 Объект FileStream используется для чтения и записи файлов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Объект FileStream используется для чтения и записи файлов. Файлы можно открывать в синхронном режиме с помощью метода <codeph>open()</codeph> или в асинхронном с помощью метода <codeph>openAsync()</codeph>.
 
 <p>Преимущество открытия файлов в асинхронном режиме состоит в том, что пока Adobe AIR выполняет чтение и запись в фоновом режиме, может исполняться и другой код. При открытии в асинхронном режиме события <codeph>progress</codeph> вызываются по мере выполнения операций.</p>
 
 <p>Поведение объекта File, открываемого в асинхронном режиме, похоже на поведение объекта ByteArray, а поведение файла, открываемого в асинхронном режиме, похоже на поведение объекта Socket или URLStream. Когда объект File открывается в синхронном режиме, вызывающий оператор приостанавливает работу, пока запрошенные данные считываются или записываются в файл. Когда же он открывается в асинхронном режиме, все записываемые данные немедленно помещаются в буфер и записываются в файл позднее.</p>
 
 <p>Независимо от того, в синхронном или асинхронном режиме выполняется чтение, в действительности методы чтения являются синхронными. В обоих случаях считывание производится из данных, которые «доступны» в текущий момент времени. Разница в том, что при синхронном чтении все данные доступны постоянно, а при асинхронном данные становятся доступны по мере того, как они передаются в буфер считывания. В любом случае, данные, которые в настоящий момент можно считать синхронным способом, представлены свойством <codeph>bytesAvailable</codeph>.</p>
 
 <p>Приложение, обрабатывающее вводимые данные в асинхронном режиме, обычно ожидает событий <codeph>progress</codeph> и использует данные по мере того, как они становятся доступны, через вызов методов чтения. С другой стороны, приложение может просто дождаться, когда станут доступны все данные (событие <codeph>complete</codeph>), и как только событие <codeph>complete</codeph> будет выполнено, обработать все данные сразу. </p>
 
 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Сообщает о достижении конца потока.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Сообщает о достижении конца потока.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#FileStream/position"><linktext>position</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.OutputProgressEvent.OUTPUT_PROGRESS_outputProgress"><apiName>outputProgress</apiName><shortdesc>
 Сообщает, что запись данных из буфера в файл завершена.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.OutputProgressEvent.OUTPUT_PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.OutputProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Сообщает, что запись данных из буфера в файл завершена.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Сообщает, что в потоке появились новые доступные данные.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Сообщает, что в потоке появились новые доступные данные.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Указывает, что во время выполнения асинхронной операции ввода-вывода произошла ошибка.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Указывает, что во время выполнения асинхронной операции ввода-вывода произошла ошибка.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Указывает, что поток был закрыт формальным вызовом метода close().</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Указывает, что поток был закрыт формальным вызовом метода <codeph>close()</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.filesystem:FileStream:FileStream"><apiName>FileStream</apiName><shortdesc>
	 Создает объект FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Создает объект FileStream. Для открытия файла используйте методы <codeph>open()</codeph> или <codeph>openAsync()</codeph>.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:FileStream:close"><apiName>close</apiName><shortdesc>
	 Закрывает объект FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Закрывает объект FileStream. 
	 
	 <p>После вызова метода <codeph>close()</codeph> данные невозможно считывать или записывать. Если файл был открыт в асинхронном режиме (объект FileStream использует для открытия файла метод <codeph>openAsync()</codeph>), вызов метода <codeph>close()</codeph> заставляет объект вызвать событие <codeph>close</codeph>. </p>
	 
	 <p>Автоматическое закрытие приложения закрывает все файлы, связанные с объектами FileStream в приложении. Тем не менее, рекомендуется ставить все асинхронно открытые объекты FileStream, у которых есть данные, ожидающие записи, в очередь на событие <codeph>closed</codeph>, прежде чем закрывать приложение (чтобы данные точно были записаны).</p>
	 
	 <p>Можно повторно использовать объект FileStream, вызвав метод <codeph>open()</codeph> или <codeph>openAsync()</codeph>. Все файлы, связанные с объектом FileStream, при этом закрываются, но объект не вызывает событие <codeph>close</codeph>.</p>
	 
	 <p>Что касается объекта FileStream, открытого в асинхронном режиме (с использованием метода <codeph>openAsync()</codeph>), то даже если вызвать событие <codeph>close()</codeph> для этого объекта и удалить свойства и переменные, ссылающиеся на него, объект FileStream не будет удален из памяти до тех пор, пока в остаются невыполненные операции и обработчики событий, ждущие их выполнения. В частности, объект FileStream, на который нет других ссылок, будет существовать, пока выполняется хотя бы одно из следующих условий: </p>
	 
	 <ul>
	 
	 	<li>При выполнении считывания из файла не был достигнут конец файла (и не было вызвано событие <codeph>complete</codeph>). </li>
	 
	 	<li>Выходные данные будут по-прежнему доступны для записи, а у связанных с ними событий (таких как <codeph>outputProgress</codeph> или <codeph>ioError</codeph>) будут прослушиватели событий. </li>
	 
	 </ul>
	 
	 </apiDesc><example conref="examples\FileStream.close.1.as">     Следующий код открывает объект FileStream <i>асинхронно</i> и записывает текстовый файл с именем test.txt во вложенный каталог Apollo Test каталога документов пользователя. Вызов метода <codeph>close()</codeph> объекта FileStream закрывает файл после записи данных. 
<codeblock>
import flash.filesystem.*;
import flash.events.Event;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.WRITE);
fileStream.writeUTFBytes("Hello");
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();

function fileClosed(event:Event):void {
    trace("closed");
}            
</codeblock></example><example conref="examples\FileStream.close.2.as">     Следующий код открывает объект FileStream <i>синхронно</i> и записывает текстовый файл с именем test.txt во вложенный каталог Apollo Test каталога документов пользователя. Вызов метода <codeph>close()</codeph> объекта FileStream закрывает файл после записи данных.
<codeblock>
import flash.filesystem.*;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF("Hello");
fileStream.close();
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>open()</linktext></link><link href="flash.filesystem.xml#FileStream/event:close"><linktext>событие close</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Открытый в асинхронном режиме файл будет закрыт.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Открытый в асинхронном режиме файл будет закрыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:open"><apiName>open</apiName><shortdesc>
	 Открывает объект FileStream в синхронном режиме, указывая на файл, заданный параметром file.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файла не существует; у вас нет прав для открытия файла; вы открываете файл для чтения, но у вас нет прав на чтение; вы открываете файл для записи, но у вас нет прав для записи. 
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Файл находится в каталоге приложения, и для параметра <codeph>fileMode</codeph> задан режим append, update или write. 
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>Объект File, указывающий на файл, который необходимо открыть.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fileMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка класса FileMode, определяющая доступные действия объекта FileStream, например чтение или запись в файл.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Открывает объект FileStream в синхронном режиме, указывая на файл, заданный параметром <codeph>file</codeph>. 
	 
	 <p>Если объект FileStream уже открыт, вызов метода закрывает файл перед открытием, и последующие события (включая <codeph>close</codeph>) не передаются ранее открытому файлу.</p>
	 
	 <p>В системах, поддерживающих блокирование файлов, файлы, открытые только для записи или только для обновления (<codeph>FileMode.WRITE</codeph> или <codeph>FileMode.UPDATE</codeph>), недоступны для чтения, пока они не будут закрыты.</p>
	 
	 <p>После завершения выполнения операций с файлом необходимо вызвать метод <codeph>close()</codeph> объекта FileStream. В некоторых системах число одновременно открытых файлов ограничено.</p>
	 
	 </apiDesc><example conref="examples\FileStream.open.1.as"> Следующий код показывает, как синхронно открыть файл test.txt во вложенном каталоге Apollo Test каталога документов пользователя, а затем считать этот файл в строку, используя для кодировки текста системный набор символов.
<codeblock>
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);
fileStream.close();
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link><link href="flash.filesystem.xml#File"><linktext>Файл</linktext></link><link href="flash.filesystem.xml#FileMode"><linktext>FileMode</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:openAsync"><apiName>openAsync</apiName><shortdesc>
	 Открывает объект FileStream в синхронном режиме, указывая на файл, заданный параметром file.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл находится в каталоге приложения, и для параметра <codeph>fileMode</codeph> задан режим append, update или write. 
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>Объект File, указывающий на файл, который необходимо открыть.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fileMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка класса FileMode, определяющая доступные действия объекта FileStream, например чтение или запись в файл.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Открывает объект FileStream в синхронном режиме, указывая на файл, заданный параметром <codeph>file</codeph>. 
	 
	 <p>Если объект FileStream уже открыт, вызов метода закрывает файл перед открытием, и последующие события (включая <codeph>close</codeph>) не передаются ранее открытому файлу.</p>
	 
	 <p>Если параметру <codeph>fileMode</codeph> присвоена константа <codeph>FileMode.READ</codeph> или <codeph>FileMode.UPDATE</codeph>, AIR считывает данные во входной буфер при открытии файла, а события <codeph>progress</codeph> и <codeph>open</codeph> отправляются по мере считывания данных во входной буфер.</p>
	 
	 <p>В системах, поддерживающих блокирование файлов, файлы, открытые только для записи или только для обновления (<codeph>FileMode.WRITE</codeph> или <codeph>FileMode.UPDATE</codeph>), недоступны для чтения, пока они не будут закрыты.</p>
	 
	 <p>После завершения выполнения операций с файлом необходимо вызвать метод <codeph>close()</codeph> объекта FileStream. В некоторых системах число одновременно открытых файлов ограничено.</p>
	 
`	 </apiDesc><example conref="examples\FileStream.openAsync.1.as"> Следующий код показывает, как синхронно открыть файл test.txt во вложенном каталоге Apollo Test каталога документов пользователя, а затем считать этот файл в строку, используя для кодировки текста системный набор символов.
<codeblock>
import flash.filesystem.*;
import flash.events.Event;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.addEventListener(Event.COMPLETE, fileCompleteHandler)
fileStream.openAsync(file, FileMode.READ);

function fileCompleteHandler(event:Event):void {
    var str:String = fileStream.readMultiByte(fileStream.bytesAvailable, File.systemCharset);
    trace(str);
    fileStream.close();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link><link href="flash.filesystem.xml#FileStream/event:complete"><linktext>Событие complete</linktext></link><link href="flash.filesystem.xml#FileStream/event:ioError"><linktext>Событие ioError</linktext></link><link href="flash.filesystem.xml#FileStream/event:progress"><linktext>Событие progress</linktext></link><link href="flash.filesystem.xml#FileMode"><linktext>FileMode</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:openAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Файла не существует; у вас нет прав для открытия файла; вы открываете файл для чтения, но у вас нет прав на чтение; вы открываете файл для записи, но у вас нет прав для записи. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Файла не существует; у вас нет прав для открытия файла; вы открываете файл для чтения, но у вас нет прав на чтение; вы открываете файл для записи, но у вас нет прав для записи.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при считывании данных во входной буфер. (При открытии файла для параметра <codeph>fileMode</codeph> должно быть установлено значение <codeph>FileMode.READ</codeph> или <codeph>FileMode.UPDATE</codeph>.)
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при считывании данных во входной буфер.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Данные файла считаны во входной буфер. (При открытии файла для параметра <codeph>fileMode</codeph> должно быть установлено значение <codeph>FileMode.READ</codeph> или <codeph>FileMode.UPDATE</codeph>.)
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Данные файла считаны во входной буфер.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	
	 Считывает логическое значение из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Логическое значение будет <codeph>true</codeph>, если количество байтов не равно нулю, в остальных случаях оно будет <codeph>false</codeph>.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает логическое значение из потока файлов, байтов или массива байтов. Считывается один байт. Если этот байт ненулевой, то возвращается значение <codeph>true</codeph>. В противном случае возвращается значение <codeph>false</codeph>.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBoolean_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readByte"><apiName>readByte</apiName><shortdesc>
	
	 Считывает байт со знаком из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от -128 до 127.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает байт со знаком из потока файлов, байтов или массива байтов.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBytes"><apiName>readBytes</apiName><shortdesc>
	
	 Считывает число байтов данных, заданное параметром length, из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект <codeph>ByteArray</codeph>, в который считываются данные.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Смещение в параметре <codeph>bytes</codeph>, с которого должно начинаться считывание данных.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Число байтов для считывания. Если значение по умолчанию равно 0, считываются все доступные данные.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Считывает число байтов данных, заданное параметром <codeph>length</codeph>, из потока файлов, байтов или массива байтов. Байты считываются в объект ByteArray, определяемый параметром <codeph>bytes</codeph>, при этом начальная позиция определяется параметром <codeph>offset</codeph>.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readDouble"><apiName>readDouble</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с двойной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число IEEE 754 с двойной точностью и плавающей запятой.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с двойной точностью и плавающей запятой.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readDouble_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readFloat"><apiName>readFloat</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с одинарной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число IEEE 754 с одинарной точностью и плавающей запятой.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с одинарной точностью и плавающей запятой.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readFloat_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readInt"><apiName>readInt</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от -2147483648 до 2147483647.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число со знаком.
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов многобайтовую строку заданной длины с использованием заданного набора символов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число считываемых из потока байтов.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, обозначающая набор символов, которые используются для интерпретации байтов. Возможные строки наборов символов: <codeph>"shift_jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
	 
     <p><b>Примечание.</b> Если в текущей системе не распознается значение параметра <codeph>charSet</codeph>, то в качестве набора символов <ph platform="actionscript"> Adobe<sup>®</sup> Flash<sup>®</sup> Player или </ph> Adobe<sup>®</sup> AIR<sup>®</sup> будет использована кодовая страница по умолчанию. Например, значение параметра <codeph>charSet</codeph>, как в <codeph>myTest.readMultiByte(22, iso-8859-01)</codeph>, использующее <codeph>01</codeph>вместо <codeph>1</codeph>, может работать на компьютере данного пользователя, но привести к сбою на другой рабочей станции. На другом компьютере приложение <ph platform="actionscript">Flash Player или </ph> AIR будет использовать кодовую страницу, заданную по умолчанию в системе.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов многобайтовую строку заданной длины с использованием заданного набора символов.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/systemCharset"><linktext>File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readMultiByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readObject"><apiName>readObject</apiName><shortdesc>
	
	 Считывает объект из потока файлов, байтов или массива байтов, зашифрованный в сериализованном формате AMF.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Десериализованный объект
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает объект из потока файлов, байтов или массива байтов, зашифрованный в сериализованном формате AMF.
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readObject_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readShort"><apiName>readShort</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от -32768 до 32767.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число со знаком.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTF"><apiName>readUTF</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8, являющаяся байтовым представлением символов.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов строку UTF-8. Предполагается, что в строку вставляется префикс с неподписанным значением, указывающим длину в байтах.
	 
	 <p>Этот метод похож на метод <codeph>readUTF()</codeph> интерфейса Java<sup>®</sup> IDataInput.</p>
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTF_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	
	 Считывает из потока байтов или массива байтов последовательность байт UTF-8 длиной и возвращает строку.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8, являющаяся байтовым представлением символов указанной длины.	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число байт для считывания.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Считывает из потока байтов или массива байтов последовательность байт UTF-8 длиной и возвращает строку.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTFBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	
	 Считывает байт без знака из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от 0 до 255. 	   
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает байт без знака из потока файлов, байтов или массива байтов.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от 0 до 4294967295.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число без знака.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на чтение; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), файл не может быть считан (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Положение, определенное для считывания данных, превышает количество доступных байтов (задается свойством <codeph>bytesAvailable</codeph>).
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от 0 до 65535. 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число без знака.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Чтение файла невозможно или файл не открыт. Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Чтение файла невозможно или файл не открыт.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:truncate"><apiName>truncate</apiName><shortdesc>
	 Сокращает файл до положения, заданного свойством position объекта FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не открыт для записи.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Сокращает файл до положения, заданного свойством <codeph>position</codeph> объекта FileStream. 
	 
	 <p>Все байты от положения, заданного свойством <codeph>position</codeph>, до конца файла, удаляются. Файл должен быть открыт для записи.</p>
	 
	 </apiDesc><example conref="examples\FileStream.truncate.1.as"> Следующий код синхронно открывает файл test.txt во вложенном каталоге Apollo Test каталога документов пользователя, а затем обрезает этот файл до 100 символов, если его длина превышает 100 символов.
<codeblock>
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.UPDATE);
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.close();
</codeblock></example><example conref="examples\FileStream.truncate.2.as"> Следующий код <i>асинхронно</i> открывает файл test.txt во вложенном каталоге Apollo Test каталога документов пользователя, а затем обрезает этот файл до 100 символов, если его длина превышает 100 символов.
<codeblock>
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.UPDATE);
trace("start", file.size)
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();
function fileClosed(event:Event):void {
    trace("closed", file.size); 
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	
	 Записывает логическое значение.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение, показывающее, какой байт записывается. Если параметр имеет значение <codeph>true</codeph>, записывается 1; если <codeph>false</codeph>, записывается 0.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает логическое значение. Записывается один байт, соответствующий параметру <codeph>value</codeph>, 1 в случае значения <codeph>true</codeph> и 0 в случае значения <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBoolean_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeByte"><apiName>writeByte</apiName><shortdesc>
	
	 Записывает байт.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение байта в виде целого числа.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает байт. Используются 8 младших битов параметра, а 24 старших битов игнорируются.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	
	 Записывает последовательность байтов из заданного массива байт bytes, начиная с байта, заданного параметром offset (используя индекс с нулевой базой), длиной, заданной параметром length, в поток файлов, байтов или массив байтов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Массив байтов для записи.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Индекс с нулевой базой, определяющий положение в массиве для начала записи.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число без знака, определяющее глубину буфера для записи.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает последовательность байтов из заданного массива байтов <codeph>bytes</codeph>, начиная с байта, заданного параметром <codeph>offset</codeph> (используя индекс с нулевой базой), длиной, заданной параметром <codeph>length</codeph>, в поток файлов, байтов или массив байтов.
	 
	 <p>Если параметр <codeph>length</codeph> опущен, применение длины по умолчанию, равной 0, приведет к тому, что будет записан весь буфер, начиная со значения параметра <codeph>offset</codeph>. Если также опустить параметр <codeph>offset</codeph>, будет записываться весь буфер. </p>
	 
	 <p>Если параметры <codeph>offset</codeph> или <codeph>length</codeph> находятся за пределами диапазона, то они корректируются так, чтобы совпасть с началом и концом массива <codeph>bytes</codeph>.</p>
 	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	
	 Записывает число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число с двойной точностью (64-разрядное) и плавающей запятой.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeDouble_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	
	 Записывает число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число с одинарной точностью (32-разрядное) и плавающей запятой.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeFloat_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeInt"><apiName>writeInt</apiName><shortdesc>
	
	 Записывает 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение байта в виде целого числа со знаком.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает 32-разрядное целое число со знаком.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	
	 Записывает в поток файлов, байтов или массив байтов многобайтовую строку заданной длины с использованием заданного набора символов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, определяющая используемый набор символов. Возможные строки наборов символов: <codeph>"shift_jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает в поток файлов, байтов или массив байтов многобайтовую строку заданной длины с использованием заданного набора символов. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/systemCharset"><linktext>File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeMultiByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeObject"><apiName>writeObject</apiName><shortdesc>
	
	 Записывает объект в поток файлов, байтов или массив байтов в сериализованном формате AMF.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Объект для сериализации.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает объект в поток файлов, байтов или массив байтов в сериализованном формате AMF.
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeObject_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeShort"><apiName>writeShort</apiName><shortdesc>
	
	 Записывает 16-разрядное целое число.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение байта в виде целого числа.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает 16-разрядное целое число. Используются 16 младших битов параметра, а 16 старших битов игнорируются.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	
	 Записывает в поток файлов, байтов или массив байтов строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает в поток файлов, байтов или массив байтов строку UTF-8. Сначала записывается длина строки UTF-8 в байтах (в виде 16-разрядного целого числа), за которой следуют байты символов строки.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTF_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	
	 Записывает строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает строку UTF-8. Аналогично <codeph>writeUTF()</codeph>, но строке не предшествует 16-разрядное слово, указывающее длину.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTFBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	
	 Записывает 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не был открыт; файл был открыт, но без прав на запись; либо, если файл был открыт для синхронных операций (с помощью метода <codeph>open()</codeph>), в файл не может быть произведена запись (например, из-за отсутствия файла).
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Значение байта в виде целого числа без знака.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 Записывает 32-разрядное целое число без знака.
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUnsignedInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует). Данное событие вызывается только для файлов, открытых для асинхронных операций (с помощью метода <codeph>openAsync()</codeph>).
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вы не можете произвести запись в файл (например, потому что файл отсутствует).</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.filesystem:FileStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	
	 Возвращает число байтов данных, доступных для чтения во входном буфере.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	
	 Возвращает число байтов данных, доступных для чтения во входном буфере. В коде должен быть вызов свойства <codeph>bytesAvailable</codeph>, проверяющий доступность необходимого объема данных до того, как будет выполнена попытка их считывания с помощью одного из методов чтения.
	 </apiDesc><example conref="examples\FileStream.bytesAvailable.1.as"/></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:endian:get"><apiName>endian</apiName><shortdesc>
	
	 Порядок байтов данных, константа BIG_ENDIAN или LITTLE_ENDIAN класса Endian.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	 Порядок байтов данных, константа <codeph>BIG_ENDIAN</codeph> или <codeph>LITTLE_ENDIAN</codeph> класса Endian.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Указывает, какой формат, AMF3 или AMF0, используется для записи или чтения бинарных данных методом readObject() или writeObject().</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, какой формат, AMF3 или AMF0, используется для записи или чтения бинарных данных методом <codeph>readObject()</codeph> или <codeph>writeObject()</codeph>.
	 
	 <p>Значение представлено константой из класса ObjectEncoding. По умолчанию используется формат AMF3.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="flash.filesystem.xml#FileStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.filesystem.xml#FileStream/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:FileStream:position:get"><apiName>position</apiName><shortdesc>
	 Текущее положение в файле.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Текущее положение в файле. 
	 
	 <p>Данное значение изменяется при следующих условиях:</p>
	 
	 <ul>
	 
	 	<li>Если явно задано свойство.</li>
	 
	 	<li>Если производится считывание из объекта FileStream (с использованием одного из методов чтения).</li>
	 
	 	<li>Если производится запись в объект FileStream.</li>
	 
	 </ul>
	 
	 <p>Положение определяется как Number (а не uint) для поддержки файлов длиной более 2<sup>32</sup> байтов. Значение данного свойства всегда представлено целым числом до 2<sup>53</sup>. Если задать это значение дробным числом, то оно будет округлено до целого в меньшую сторону.</p>
	 
	 <p>Если при асинхронном чтении файла задать свойство <codeph>position</codeph>, приложение начнет заполнять буфер чтения данными, начиная с указанного положения, а свойство <codeph>bytesAvailable</codeph> может принять значение 0. Дождитесь события <codeph>complete</codeph>, прежде чем использовать метод read для чтения данных или дождитесь события <codeph>progress</codeph> и проверьте свойство <codeph>bytesAvailable</codeph>, прежде чем использовать метод read.</p>
	  
	 </apiDesc><example conref="examples\FileStream.position.1.as"> На примере следующего кода показано, как обновляется свойство <codeph>position</codeph> объекта FileStream по мере считывания приложением данных из файла.
<codeblock>
import flash.fileSystem.*;
import flash.utils.ByteArray;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory.resolvePath("Apollo Test/test.txt");
var stream:FileStream = new FileStream();
stream.addEventListener(Event.COMPLETE, readBytes);
stream.openAsync(sourceFile, File);

function readBytes(e:Event):void {
    var bytes:ByteArray = new ByteArray();
    trace("position 0:", stream.position); // 0
    bytes[0] = stream.readByte();
    trace("position 1:", stream.position); // 1
    fileStream.readBytes(bytes, stream.position, 4); 
    trace("position 2:", stream.position); // 5
    stream.close();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:readAhead:get"><apiName>readAhead</apiName><shortdesc>
	 При асинхронном чтении данных из файлов: требуемый объем данных.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Should the readAhead value dwindle to 0 as the data is read in.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 При асинхронном чтении данных из файлов: требуемый объем данных.
	 
	 <p>Это свойство указывает, сколько данных пытается считать асинхронный поток за точкой текущего положения. Значение этого свойства по умолчанию – бесконечность: по умолчанию из файла, открытого для асинхронного чтения, данные считываются, пока не будет достигнут конец файла.</p>
	 
	 <p>Считывание данных из буфера чтения не влияет на значение свойства <codeph>readAhead</codeph>. При считывании данных из буфера новые данные считываются в буфер для его пополнения.</p>
	 
	 <p>Свойство <codeph>readAhead</codeph> не влияет на файл, открытый в синхронном режиме.</p>
	 
	 <p>При считывании данных в асинхронном режиме объект FileStream отправляет события <codeph>progress</codeph>. В методе обработчика событий для события <codeph>progress</codeph> проверьте доступность необходимого количества байтов (это можно проверить с помощью свойства <codeph>bytesAvailable</codeph>), а затем считайте данные из буфера чтения с помощью метода read.</p>
	 
	 </apiDesc><example conref="examples\FileStream.readAhead.1.as">     На примере следующего кода показано, как с помощью свойства <codeph>readAhead</codeph> ограничить объем данных, считываемых в файл, до 100 байтов:
<codeblock>
import flash.filesystem.*;

var file:File = File.desktopDirectory.resolvePath("test.txt");
var fileStream:FileStream = new FileStream();
fileStream.readAhead = 100;
fileStream.addEventListener(ProgressEvent.PROGRESS, readProgressHandler)
fileStream.openAsync(file, FileMode.READ);
var results:ByteArray;

function readProgressHandler(event:ProgressEvent):void {
    if (fileStream.bytesAvailable >= 100) {
        fileStream.readBytes(results, 0, 100);
    }
}
</codeblock><swfblock conref="examples\FileStream.readAhead.1.swf"/></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filesystem:FileMode"><apiName>FileMode</apiName><shortdesc>
 Класс FileMode определяет строковые константы, которые применяются в параметре fileMode методов open() и openAsync() класса FileStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс FileMode определяет строковые константы, которые применяются в параметре <codeph>fileMode</codeph> методов <codeph>open()</codeph> и <codeph>openAsync()</codeph> класса FileStream. Параметр <codeph>fileMode</codeph>этих методов определяет доступные действия объекта FileStream при открытии файла. 
 
 <p>На основании значения параметра <codeph>fileMode</codeph>, заданного методом open, могут быть доступны следующие действия в различных сочетаниях:</p>
 
 <ul>
 
 	<li>Чтение – объект FileStream может считывать данные из файла.</li>
 	<li>Запись – объект FileStream может записывать данные в файл.</li>
 	<li>Создание – объект FileStream при открытии создает несуществующий файл.</li>
 	<li>Сокращение при открытии – данные в файле удаляются при открытии (прежде, чем начинается запись каких-либо данных).</li>
 	<li>Добавление записываемых данных – данные всегда записываются в конец файла (при вызове любого метода записи).</li>
 
 </ul>
 
 <p>В таблице ниже показаны возможные действия каждой из констант в классе FileMode при ее применении в качестве параметра <codeph>fileMode</codeph> метода open объекта FileStream:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="6"><thead><row><entry>Константа FileMode</entry><entry align="center">Чтение</entry><entry align="center">Создание сценариев на языке</entry><entry align="center">Создание</entry><entry align="center">Сокращение при открытии</entry><entry align="center">Добавление записываемых данных</entry></row></thead><tbody><row>
 	<entry><codeph>READ</codeph></entry>
 	<entry align="center"> • </entry>
 	<entry> </entry>
 	<entry> </entry>
 	<entry> </entry>
 	<entry> </entry>
 </row><row>
 	<entry><codeph>WRITE</codeph></entry>
 	<entry> </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry> </entry>
 </row><row>
 	<entry><codeph>APPEND</codeph></entry>
 	<entry> </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry/>
 	<entry align="center"> • </entry>
 </row><row>
 	<entry><codeph>UPDATE</codeph></entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"/>
 	<entry> </entry>
 </row></tbody></tgroup></adobetable>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>FileStream.open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()"><linktext>FileStream.openAsync()</linktext></link></related-links><apiValue id="flash.filesystem:FileMode:APPEND"><apiName>APPEND</apiName><shortdesc> 
	Используется для открытия файла только для записи, при этом все записываемые данные добавляются в конец файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для открытия файла только для записи, при этом все записываемые данные добавляются в конец файла. При открытии создаются все несуществующие файлы. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:READ"><apiName>READ</apiName><shortdesc> 
	Используется для открытия файла в режиме «только для чтения».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для открытия файла в режиме «только для чтения». Файл должен существовать (несуществующие файлы не будут созданы).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:UPDATE"><apiName>UPDATE</apiName><shortdesc> 
	Используется для открытия файла в режиме «чтение и запись».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для открытия файла в режиме «чтение и запись». При открытии создаются все несуществующие файлы. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:WRITE"><apiName>WRITE</apiName><shortdesc> 
	Используется для открытия файла в режиме «только для записи».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>write</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для открытия файла в режиме «только для записи». После открытия все несуществующие файлы будут созданы, а все существующие файлы будут сокращены (их данные будут удалены).
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filesystem:File"><apiName>File</apiName><shortdesc>
 Объект File представляет собой путь к файлу или каталогу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.net:FileReference</apiBaseClassifier></apiClassifierDef><apiDesc>
 Объект File представляет собой путь к файлу или каталогу. Это может быть существующий или еще не существующий файл или каталог. Так, можно задать путь к файлу или каталогу, который вы планируете создать. 
 
  <p>Класс File предлагает некоторые свойства и методы для получения информации о файловой системе и для выполнения таких операций, как копирование файлов и каталогов.</p>
  
  <p>Объекты File можно использовать с классом FileStream для чтения и записи файлов. </p>
  
  <p>Класс File является расширением класса FileReference. Класс FileReference, доступный в Flash<sup>®</sup> Player и Adobe<sup>®</sup> AIR<sup>®</sup>, содержит указатель на файл, а в класс File добавлены свойства и методы, не представленные в Flash Player (при проигрывании SWF-файла в обозревателе) из соображений безопасности.</p>
  
  <p>Класс File содержит статические свойства, которые позволяют указать часто используемые местоположения каталогов. К таким статическим свойствам относятся следующие:</p>
  
  <ul>
  	<li><codeph>File.applicationStorageDirectory</codeph> – каталог хранилища, который является уникальным для каждого установленного приложения AIR</li>
      <li><codeph>File.applicationDirectory</codeph> – каталог только для чтения, в который устанавливается приложение (вместе с установленными активами)</li>
      <li><codeph>File.desktopDirectory</codeph> – каталог рабочего стола пользователя</li>
      <li><codeph>File.documentsDirectory</codeph> – каталог с документами пользователя</li>
      <li><codeph>File.userDirectory</codeph> – каталог пользователя</li>
  </ul>
  
  <p>В различных операционных системах эти свойства имеют свои показательные значения. Например, в Mac OS, Linux и Windows собственные пути к каталогу рабочего стола пользователя отличаются. Однако свойство <codeph>File.desktopDirectory</codeph> указывает правильный путь к каталогу рабочего стола на каждой из этих платформ. При создании приложений для работы на различных платформах используйте эти свойства как основу для указания на другие файлы, используемые приложением. Затем используйте метод <codeph>resolvePath()</codeph> для коррекции пути. Например, данный код указывает на файл preferences.xml в каталоге хранилища приложения:</p>
  
  <codeblock platform="actionscript"> var prefsFile:File = File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  <codeblock platform="javascript"> var prefsFile = air.File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  <p>Если указать буквенный собственный путь в ссылке на файл, то он будет работать только на одной платформе. Например, следующий объект File будет работать только в Windows:</p> 
  
  <codeblock platform="actionscript">new File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  <codeblock platform="javascript">new air.File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  
  <p>Каталог хранилища приложения особенно полезен. Это каталог хранилища для каждого отдельного приложения AIR. Он определяется свойством <codeph>File.applicationStorageDirectory</codeph>.</p>
  
  <p>Нельзя добавлять в каталог приложения (в который установлено приложение AIR) или удалять из этого каталога содержимое. Это может повредить приложение AIR и сделать подпись приложения недействительной. Запись в каталог приложения запрещена в AIR по умолчанию, так как доступ на запись в этот каталог не предоставлен всем учетным записям пользователя во всех операционных системах. Каталог хранилища приложения можно использовать для записи внутренних файлов приложения. Каталог документов можно использовать для записи файлов, которые пользователь будет использовать за пределами приложения (например, отредактированные изображения и текстовые файлы).</p>
  
  </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.DIRECTORY_LISTING_directoryListing"><apiName>directoryListing</apiName><shortdesc>
 Вызывается, когда в результате запроса метода getDirectoryListingAsync() становится доступен список каталогов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FileListEvent.DIRECTORY_LISTING</apiEventType><adobeApiEventClassifier>flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается, когда в результате запроса метода <codeph>getDirectoryListingAsync()</codeph> становится доступен список каталогов.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListingAsync()"><linktext>File.getDirectoryListingAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.SELECT_MULTIPLE_selectMultiple"><apiName>selectMultiple</apiName><shortdesc>
 Вызывается, когда пользователь выбирает файлы из диалогового окна, открывшегося по вызову метода browseForOpenMultiple().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FileListEvent.SELECT_MULTIPLE</apiEventType><adobeApiEventClassifier>flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается, когда пользователь выбирает файлы из диалогового окна, открывшегося по вызову метода <codeph>browseForOpenMultiple()</codeph>. 
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#File/browseForMultiple()"><linktext>browseForMultiple()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 Вызывается, когда пользователь выбирает файл или каталог из окна просмотра файлов или каталогов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается, когда пользователь выбирает файл или каталог из окна просмотра файлов или каталогов. 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Вызывается, когда операция нарушает ограничения безопасности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается, когда операция нарушает ограничения безопасности.
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Вызывается, когда при выполнении асинхронной операции над файлом происходит ошибка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается, когда при выполнении асинхронной операции над файлом происходит ошибка.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Вызывается при завершении асинхронной операции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается при завершении асинхронной операции.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Вызывается при отмене асинхронной операции, ожидающей выполнения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Вызывается при отмене асинхронной операции, ожидающей выполнения.
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.filesystem:File:File"><apiName>File</apiName><shortdesc>
	Функция конструктора для класса File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Неверный синтаксис параметра <codeph>path</codeph>.
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>path</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Путь к файлу. Можно задать путь двумя способами: с помощью URL-адреса или записав путь в характерном для конкретной платформы виде. 
	
	<p>При вводе URL-адреса можно пользоваться следующими схемами URL: <codeph>file</codeph>, <codeph>app</codeph> или <codeph>app-storage</codeph>. Для параметра <codeph>path</codeph>, использующего запись URL, действительными являются следующие значения: </p>
	
	<ul>
	
		<li><codeph>"app:/DesktopPathTest.xml"</codeph></li> 
		<li><codeph>"app-storage:/preferences.xml"</codeph></li> 
		<li><codeph>"file:///C:/Documents%20and%20Settings/bob/Desktop"</codeph> (Рабочий стол на компьютере Боба)</li>
		<li><codeph>"file:///Users/bob/Desktop"</codeph> (Рабочий стол на компьютере Mac Боба)</li>
	
	</ul>
	
	<p>Схемы URL <codeph>app</codeph> и <codeph>app-storage</codeph> весьма полезны, т. к. могут указать на подходящий файл во всех файловых системах. Тем не менее, в двух других примерах, в которых для указания на каталог рабочего стола пользователя используется схема URL <codeph>file</codeph>, предпочтительно передавать аргумент <i>no</i> <codeph>path</codeph> конструктору <codeph>File()</codeph>, а затем назначать <codeph>File.desktopDirectory</codeph> объекту File. Таким образом, доступ к каталогу рабочего стола не будет зависеть от платформы или от пользователя.</p>
	
	<p>При задании пути на компьютере Windows разделителем в аргументе может выступать обратная или левая косая черта, а на компьютере Мас OS и Linux – левая косая черта. Для параметра <codeph>path</codeph>, использующего собственную запись пути, действительными являются следующие значения:</p>
	
	<ul>
	
		<li><codeph>"C:/Documents and Settings/bob/Desktop"</codeph></li>
		<li><codeph>"/Users/bob/Desktop"</codeph></li>
	
	</ul>
	
	<p>Тем не менее, в этих двух примерах следует передавать аргумент <i>no</i> <codeph>path</codeph> конструктору <codeph>File()</codeph>, а затем назначить <codeph>File.desktopDirectory</codeph> объекту File. Таким образом доступ к каталогу «Рабочий стол» не будет зависеть от платформы или от пользователя.</p>
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Функция конструктора для класса File. 
	
	<p>При передаче аргумента <codeph>path</codeph> объект File указывает на конкретный путь, а свойства <codeph>nativePath</codeph> и <codeph>url</codeph> отражают этот путь.</p>
	
	<p>Хотя можно передать аргумент <codeph>path</codeph>, чтобы указать путь к файлу, в результате может получиться код, предназначенный для конкретной платформы. Например, такой собственный путь, как <codeph>C:\\\\Documents and Settings\\bob\\Desktop</codeph>, или такой URL-адрес, как <codeph>file:///C:/Documents%20and%20Settings/bob/Desktop</codeph>, действителен только для Windows. Рекомендуется использовать следующие статические свойства, представляющие часто используемые каталоги и действительные для всех платформ:</p>
	
	<ul>
	<li><codeph>File.applicationDirectory</codeph></li>
	<li><codeph>File.applicationStorageDirectory</codeph></li>
	<li><codeph>File.desktopDirectory</codeph></li>
	<li><codeph>File.documentsDirectory</codeph></li>
	<li><codeph>File.userDirectory</codeph></li>
	</ul>
	
	<p>Затем можно вызвать метод <codeph>resolvePath()</codeph>, чтобы получить относительный путь к этим каталогам. Например, следующий код задает объект File для указания на файл settings.xml в каталоге хранилища приложения:</p>
	
	<codeblock platform="actionscript">var file:File = File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	<codeblock platform="javascript">var file = air.File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filesystem.xml#File/nativePath"><linktext>nativePath</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:File:browseForDirectory"><apiName>browseForDirectory</apiName><shortdesc>
	 Отображает для пользователя диалоговое окно выбора каталога.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, отображаемая в области заголовка диалогового окна.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает для пользователя диалоговое окно выбора каталога. При выборе каталога вызывается событие <codeph>select</codeph>. Свойство <codeph>target</codeph> события <codeph>select</codeph> является объектом File, указывающим на выбранный каталог.
	 
	 </apiDesc><example conref="examples\File.browseForDirectory.1.as"> Следующий код использует метод <codeph>File.browseForDirectory()</codeph>, чтобы позволить пользователю выбрать каталог. После выбора каталога код выводит список содержимого этого каталога в выходных данных метода <codeph>trace()</codeph>.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var directory:File = File.documentsDirectory;

try
{
    directory.browseForDirectory("Select Directory");
    directory.addEventListener(Event.SELECT, directorySelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function directorySelected(event:Event):void 
{
    directory = event.target as File;
    var files:Array = directory.getDirectoryListing();
    for(var i:uint = 0; i &lt; files.length; i++)
    {
        trace(files[i].name);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForDirectory_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Открыть файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Открыть файл».</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForDirectory_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при выборе каталога и закрытии диалогового окна выбора каталога. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при выборе каталога и закрытии диалогового окна выбора каталога.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpen"><apiName>browseForOpen</apiName><shortdesc>
	 Отображает диалоговое окно «Открыть файл», где можно выбрать файл для открытия.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, отображаемая в области заголовка диалогового окна.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив экземпляров FileFilter, который используется для фильтрации файлов, отображенных в диалоговом окне. Если данный параметр пропущен, то отображаются все файлы. Дополнительную информацию см. в описании класса FileFilter.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает диалоговое окно «Открыть файл», где можно выбрать файл для открытия.
	 
	 <p>При выборе файла вызывается событие <codeph>select</codeph>. Свойство <codeph>target</codeph> события <codeph>select</codeph> – это объект File, указывающий на выбранный файл.</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpen.1.as"> Следующий код использует метод <codeph>File.browseForOpen()</codeph>, чтобы позволить пользователю выбрать текстовый файл. После выбора файла код считывает данные этого файла в строку.
<codeblock>
import flash.filesystem.*;
import flash.events.Event;
import flash.net.FileFilter;

var fileToOpen:File = new File();
var txtFilter:FileFilter = new FileFilter("Text", "*.as;*.css;*.html;*.txt;*.xml");

try 
{
    fileToOpen.browseForOpen("Open", [txtFilter]);
    fileToOpen.addEventListener(Event.SELECT, fileSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function fileSelected(event:Event):void 
{
    var stream:FileStream = new FileStream();
    stream.open(event.target, FileMode.READ);
    var fileData:String = stream.readUTFBytes(stream.bytesAvailable);
    trace(fileData);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpenMultiple()"><linktext>browseForOpenMultiple()</linktext></link><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpen_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Открыть файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Открыть файл».</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpen_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при выборе файла и закрытии диалогового окна «Открыть файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при выборе файла и закрытии диалогового окна «Открыть файл».</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpenMultiple"><apiName>browseForOpenMultiple</apiName><shortdesc>
	 Отображает диалоговое окно «Открыть файл», в котором можно выбрать один или несколько файлов для открытия.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, отображаемая в области заголовка диалогового окна.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив экземпляров FileFilter, который используется для фильтрации файлов, отображенных в диалоговом окне. Если данный параметр пропущен, то отображаются все файлы. Дополнительную информацию см. в описании класса FileFilter.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает диалоговое окно «Открыть файл», в котором можно выбрать один или несколько файлов для открытия.
	 
	 <p>При выборе файлов вызывается событие <codeph>selectMultiple</codeph>. Свойство <codeph>target</codeph>события <codeph>select</codeph> является этим объектом File. В отличие от <codeph>browseForOpen()</codeph>, применение метода <codeph>browseForOpenMultiple()</codeph> не делает объект File ссылкой на выбранные файлы. Вместо этого конечное событие <codeph>selectMultiple</codeph> содержит массив выбранных файлов.</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpenMultiple.1.as"> Следующий код использует метод <codeph>File.browseForOpenMultiple()</codeph>, чтобы позволить пользователю выбрать несколько файлов. После выбора файлов код выводит список путей к ним.
<codeblock>
import flash.filesystem.*;
import flash.events.FileListEvent;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForOpenMultiple("Select Files");
    docsDir.addEventListener(FileListEvent.SELECT_MULTIPLE, filesSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function filesSelected(event:FileListEvent):void 
{
    for (var i:uint = 0; i &lt; event.files.length; i++) 
    {
        trace(event.files[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:selectMultiple"><linktext>selectMultiple</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Открыть файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Открыть файл».</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_selectMultiple"><apiName>selectMultiple</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при выборе файлов и закрытии диалогового окна «Открыть файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при выборе файлов и закрытии диалогового окна «Открыть файл».</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForSave"><apiName>browseForSave</apiName><shortdesc>
	 Отображает диалоговое окно «Сохранить файл», в котором можно выбрать место назначения файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, отображаемая в области заголовка диалогового окна.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отображает диалоговое окно «Сохранить файл», в котором можно выбрать место назначения файла. 
	 
	 <p>При выборе файла вызывается событие <codeph>select</codeph>. Свойство <codeph>target</codeph> события <codeph>select</codeph> является объектом File, который указывает на выбранное место для сохранения файла.</p>
	 
	 </apiDesc><example conref="examples\File.browseForSave.1.as"> Следующий код использует метод <codeph>File.browseForSave()</codeph>, чтобы позволить пользователю выбрать путь для сохранения файла. После выбора файлов код сохраняет данные по выбранному пути.
<codeblock>
import flash.filesystem.*;
import flash.events.Event;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForSave("Save As");
    docsDir.addEventListener(Event.SELECT, saveData);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function saveData(event:Event):void 
{
    var newFile:File = event.target as File;
    var str:String = "Hello.";
    if (!newFile.exists)
    {
        var stream:FileStream = new FileStream();
        stream.open(newFile, FileMode.WRITE);
        stream.writeUTFBytes(str);
        stream.close();
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForSave_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Сохранить файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при нажатии кнопки «Отмена» в диалоговом окне «Сохранить файл».</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForSave_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при выборе файла и закрытии диалогового окна «Сохранить файл». 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при выборе файла и закрытии диалогового окна «Сохранить файл».</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:cancel"><apiName>cancel</apiName><shortdesc>
	 Отменяет все операции, ожидающие выполнения.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Отменяет все операции, ожидающие выполнения.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:canonicalize"><apiName>canonicalize</apiName><shortdesc>
	 Устанавливает путь к файлу в качестве канонического.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Устанавливает путь к файлу в качестве канонического.
	 
	 <p>Если объект File представляет собой существующий файл или каталог, при установлении пути как канонического он корректируется в соответствии с регистром в имени реального файла или каталога. Если объект File – символьная ссылка, при установлении пути как канонического он корректируется для соответствия файлу или каталогу, на который указывает ссылка, независимо от того, существует ли такой файл или каталог. В файловых системах, учитывающих регистр (например, Linux), когда существует несколько файлов, имена которых отличаются только регистром, метод <codeph>canonicalize()</codeph> корректирует путь в соответствии с первым найденным файлом (в порядке, определенном файловой системой).</p>
	 
	 <p>Кроме того, при установлении канонического пути в ОС Windows короткие имена файлов переводятся в длинные.</p>
	 
	 </apiDesc><example conref="examples\File.canonicalize.2.as">     Следующий код показывает, как с помощью метода <codeph>canonicalize()</codeph> найти соответствующее имя каталога, в котором используются заглавные буквы. Перед выполнением этого кода необходимо создать каталог с именем AIR Test на рабочем столе компьютера.
<codeblock>
import flash.filesystem.*;

var path:File = File.desktopDirectory.resolvePath("air test");
trace(path.nativePath); 
path.canonicalize();
trace(path.nativePath); // ...\AIR Test

</codeblock></example><example conref="examples\File.canonicalize.1.as">     Следующий код показывает, как с помощью метода <codeph>canonicalize()</codeph> найти длинное имя каталога Windows, исходя из его короткого имени. В данном примере предполагается, что в корне диска C: имеется каталог с именем AIR Test и коротким системным именем AIR~1.
<codeblock>
import flash.filesystem.*;

var path:File = new File();
path.nativePath = "C:\\AIR~1";
path.canonicalize();
trace(path.nativePath); // C:\AIR Test
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:clone"><apiName>clone</apiName><shortdesc>
	 Возвращает копию данного объекта File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает копию данного объекта File. Регистрации событий не копируются.
	 
	 <p><i>Примечание.</i> Данный метод <i>не</i> копирует сам файл. Он просто создает копию экземпляра объекта File <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph>. Для копирования файла пользуйтесь методом <codeph>copyTo()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:copyTo"><apiName>copyTo</apiName><shortdesc>
	 Перемещает файл или каталог из места, заданного объектом File, в место, заданное параметром newLocation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Источник не существует; либо адресат существует, и <codeph>overwrite</codeph> равно <codeph>false</codeph>; либо источник не удалось скопировать в целевой объект; либо источник и целевой объект указывают на один файл или одну папку, и <codeph>overwrite</codeph> установлен на <codeph>true</codeph>. ОС Windows не позволяет копировать открытый файл или каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Место назначения нового файла. Обратите внимание, что данный объект File определяет конечный (скопированный) файл или каталог, а <i>не</i> путь к текущему каталогу.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При значении <codeph>false</codeph> невозможно выполнить копирование, если файл, заданный параметром <codeph>target</codeph>, уже существует. При значении <codeph>true</codeph> в ходе операции перезаписываются все существующие файлы или каталоги с таким же именем.  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Перемещает файл или каталог из места, заданного объектом File, в место, заданное параметром <codeph>newLocation</codeph>. Процесс копирования создает все необходимые вышестоящие каталоги (если возможно).
	 
	 </apiDesc><example conref="examples\File.copyTo.1.as"> Следующий код показывает, как скопировать файл с помощью метода <codeph>copyTo()</codeph>. Перед выполнением этого кода необходимо создать файл test1.txt во вложенном каталоге AIR Test каталога документов на компьютере. В результате копирования получается файл с именем test2.txt, который также находится во вложенном каталоге AIR Test. Если для параметра <codeph>clobber</codeph> задано значение <codeph>true</codeph>, эта операция перезаписывает любой существующий файл test2.txt.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:FileReference = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:FileReference = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

if (sourceFile.copyTo(destination, true)) {
    trace("Done.");
}
</codeblock></example><example conref="examples\File.copyTo.2.as"> Следующий код показывает, как скопировать файл с помощью метода <codeph>copyTo()</codeph>. Перед выполнением этого кода необходимо создать файл test1.txt во вложенном каталоге AIR Test основного каталога на компьютере. В результате копирования получается файл с именем test2.txt. На примере инструкций <codeph>try</codeph> и <codeph>catch</codeph> показан способ ответа на ошибки.
<codeblock>
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

try 
{
    sourceFile.copyTo(destination, true);
}
catch (error:Error)
{
    trace("Error:", error.message);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyToAsync()"><linktext>copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()"><linktext>moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:copyToAsync"><apiName>copyToAsync</apiName><shortdesc>
	 Начинает копирование файла или каталога из места, указанного данным объектом File, в место, заданное параметром destination.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Место назначения нового файла. Обратите внимание, что данный объект File определяет конечный (скопированный) файл или каталог, а <i>не</i> путь к текущему каталогу.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При значении <codeph>false</codeph> невозможно выполнить копирование, если файл, заданный параметром <codeph>target</codeph>, уже существует. При значении <codeph>true</codeph> в ходе операции сначала стираются все существующие файлы или каталоги с таким же именем.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Начинает копирование файла или каталога из места, указанного данным объектом File, в место, заданное параметром <codeph>destination</codeph>. 
	 
	 <p>После завершения вызывается событие <codeph>complete</codeph> (в случае успешного выполнения) или <codeph>ioError</codeph> (в случае невозможности завершения). Процесс копирования создает все необходимые вышестоящие каталоги (если возможно).</p>
	 
	 </apiDesc><example conref="examples\File.copyToAsync.1.as"> Следующий код показывает, как скопировать файл с помощью метода <codeph>copyToAsync()</codeph>. Перед выполнением этого кода необходимо создать файл test1.txt во вложенном каталоге AIR Test каталога документов на компьютере. В результате копирования получается файл с именем test2.txt, который также находится во вложенном каталоге AIR Test. Если для параметра <codeph>clobber</codeph> задано значение <codeph>true</codeph>, эта операция перезаписывает любой существующий файл test2.txt.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

sourceFile.copyToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileCopiedHandler);

function fileCopiedHandler(event:Event):void {
    trace("Done.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyTo()"><linktext>copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()"><linktext>moveToAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:copyToAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при успешном копировании файла или каталога. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при успешном копировании файла или каталога.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:copyToAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Источник не существует; либо целевой объект существует, и <codeph>overwrite</codeph> равно <codeph>false</codeph>; либо источник не удалось скопировать в целевой объект; либо источник и целевой объект указывают на один файл или одну папку, и <codeph>overwrite</codeph> установлен на <codeph>true</codeph>. ОС Windows не позволяет копировать открытый файл или каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Источник не существует; либо целевой объект существует, и overwrite равно false; либо источник не удалось скопировать в адресат; либо источник и целевой объект указывают на один файл или одну папку, и overwrite установлен на true.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:createDirectory"><apiName>createDirectory</apiName><shortdesc>
	 Создает указанный каталог и все необходимые вышестоящие каталоги.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Каталог не существовал и не мог быть создан. 
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Создает указанный каталог и все необходимые вышестоящие каталоги. Если каталог уже существует, никаких действий не предпринимается.
	 
	 </apiDesc><example conref="examples\File.createDirectory.1.as">     Следующий код перемещает файл с именем test.txt с рабочего стола во вложенный каталог AIR Test каталога документов. С помощью вызова метода <codeph>createDirectory()</codeph> перед перемещением файла можно убедиться в том, что каталог AIR Test действительно существует.
<codeblock>
import flash.filesystem.*;

var source:File = File.desktopDirectory.resolvePath("test.txt");
var target:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var targetParent:File = target.parent;
targetParent.createDirectory();
source.moveTo(target, true);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:createTempDirectory"><apiName>createTempDirectory</apiName><shortdesc>
	 Возвращает ссылку на новый временный каталог.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Объект File, ссылающийся на новый временный каталог.
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает ссылку на новый временный каталог. Это новый каталог в пути временного системного каталога.
	 
	 <p>Этот метод позволяет определить новый уникальный каталог, не отправляя запрос системе.</p>
	 
	 <p>Перед закрытием приложения рекомендуется удалять временные каталоги, так как они не удаляются автоматически.</p>
	 
	 </apiDesc><example conref="examples\File.createTempDirectory.1.as"> Следующий код использует метод <codeph>createTempFile()</codeph> для получения ссылки на новый временный каталог.
<codeblock>
import flash.File;

var temp:File = File.createTempDirectory();
trace(temp.nativePath);
</codeblock> При каждом выполнении этого кода создается новый (уникальный) файл. 
</example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/createTempFile()"><linktext>createTempFile()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:createTempFile"><apiName>createTempFile</apiName><shortdesc>
	 Возвращает ссылку на новый временный файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Объект File, ссылающийся на новый временный файл.
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает ссылку на новый временный файл. Это новый файл в пути временного системного каталога.
	 
	 <p>Этот метод позволяет определить новый уникальный файл, не запрашивая об этом систему.</p>
	 
	 <p>Перед закрытием приложения рекомендуется удалять временные файлы, так как они не удаляются автоматически.</p>
	 
	 </apiDesc><example conref="examples\File.createTempFile.1.as"> Следующий код использует метод <codeph>createTempFile()</codeph> для получения ссылки на новый временный файл.
<codeblock>
import flash.File;

var temp:File = File.createTempFile();
trace(temp.nativePath);
</codeblock> При каждом выполнении этого кода создается новый (уникальный) файл. 
</example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/createTempDirectory()"><linktext>createTempDirectory()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectory"><apiName>deleteDirectory</apiName><shortdesc>
	 Удаляет каталог.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Каталог нельзя удалить, или он не существует. ОС Windows не позволяет удалять каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deleteDirectoryContents</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, можно ли удалять каталог, содержащий файлы или подкаталоги. При значении <codeph>false</codeph> вызов этого метода создает исключение, если каталог содержит файлы или подкаталоги.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Удаляет каталог. Если этот объект File является символьной ссылкой на каталог, то удаляется эта ссылка, а не сам каталог.
	 
	 </apiDesc><example conref="examples\File.deleteDirectory.1.as"> Следующий код создает пустой каталог, затем удаляет его с помощью метода <codeph>deleteDirectory()</codeph>. 
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Empty Junk Directory/");
File.createDirectory(directory);
trace(directory.exists); // true
directory.deleteDirectory();
trace(directory.exists); // false
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectoryAsync()"><linktext>deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()"><linktext>deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectoryAsync"><apiName>deleteDirectoryAsync</apiName><shortdesc>
	 Удаляет каталог в асинхронном режиме.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deleteDirectoryContents</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, можно ли удалять каталог, содержащий файлы или подкаталоги. При значении <codeph>false</codeph> объект File вызывает событие <codeph>ioError</codeph>, если каталог содержит файлы или подкаталоги.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Удаляет каталог в асинхронном режиме. Если этот объект File является символьной ссылкой на каталог, то удаляется эта ссылка, а не сам каталог.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectory()"><linktext>deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()"><linktext>deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при успешном удалении каталога. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при успешном удалении каталога.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Каталог не может быть удален или такого каталога не существует. ОС Windows не позволяет удалять каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Каталог не может быть удален или такого каталога не существует.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:deleteFile"><apiName>deleteFile</apiName><shortdesc>
	 Удаляет файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Файл не может быть удален или такого файла не существует. ОС Windows не позволяет удалять открытые файлы.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Удаляет файл. Если этот объект File является символьной ссылкой, то удаляется эта ссылка, а не целевой файл.
	 
	 </apiDesc><example conref="examples\File.deleteFile.1.as"> Следующий код создает временный файл, затем вызывает метод <codeph>deleteFile()</codeph> для его удаления.
<codeblock>
import flash.filesystem.*;

var file:File = File.createTempFile();
trace(file.exists); // true
file.deleteFile();
trace(file.exists); // false
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectory()"><linktext>deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()"><linktext>deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteFileAsync"><apiName>deleteFileAsync</apiName><shortdesc>
	 Удаляет файл в асинхронном режиме.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Удаляет файл в асинхронном режиме. Если этот объект File является символьной ссылкой, то удаляется эта ссылка, а не целевой файл.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectoryAsync()"><linktext>deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()"><linktext>deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при успешном удалении файла. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при успешном удалении файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Файл не может быть удален или такого файла не существует. ОС Windows не позволяет удалять открытые файлы.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Файл не может быть удален или такого файла не существует.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListing"><apiName>getDirectoryListing</apiName><shortdesc>
	 Возвращает массив объектов File, связанных с файлами и каталогами, размещенными в каталоге, представленном данным объектом File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Массив объектов File.
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает массив объектов File, связанных с файлами и каталогами, размещенными в каталоге, представленном данным объектом File. При использовании этого метода не рассматривается содержимое подкаталогов.
	 
	 </apiDesc><example conref="examples\File.getDirectoryListing.1.as"> Следующий код показывает, как с помощью метода <codeph>getDirectoryListing()</codeph> можно вывести список содержимого каталога пользователя.
<codeblock>
import flash.filesystem.File;

var directory:File = File.userDirectory;
var list:Array = directory.getDirectoryListing();
for (var i:uint = 0; i &lt; list.length; i++) {
    trace(list[i].nativePath);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListingAsync()"><linktext>getDirectoryListingAsync()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()"><linktext>getRootDirectories()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListingAsync"><apiName>getDirectoryListingAsync</apiName><shortdesc>
	 В асинхронном режиме формирует массив объектов File, связанных с содержимым каталога, который представляется данным объектом File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 В асинхронном режиме формирует массив объектов File, связанных с содержимым каталога, который представляется данным объектом File. 
	 
	 </apiDesc><example conref="examples\File.getDirectoryListingAsync.1.as"> Следующий код показывает, как с помощью метода <codeph>getDirectoryListingAsync()</codeph> можно вывести список содержимого каталога пользователя.
<codeblock>
import flash.filesystem.File;
import flash.events.FileListEvent;

var directory:File = File.userDirectory;
directory.getDirectoryListingAsync();
directory.addEventListener(FileListEvent.DIRECTORY_LISTING, directoryListingHandler);

function directoryListingHandler(event:FileListEvent):void {
    var list:Array = event.files;
    for (var i:uint = 0; i &lt; list.length; i++) {
        trace(list[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListing()"><linktext>getDirectoryListing()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()"><linktext>getRootDirectories()</linktext></link><link href="flash.filesystem.xml#File/event:directoryListing"><linktext>Событие directoryListing</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>У вас нет прав для чтения данного каталога или его не существует.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>У вас нет прав для чтения данного каталога или его не существует.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_directoryListing"><apiName>directoryListing</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Содержимое каталога успешно пересчитано. Событие <codeph>contents</codeph> содержит свойство <codeph>files</codeph>, представляющее собой результирующий массив объектов File.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Содержимое каталога успешно пересчитано.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getRelativePath"><apiName>getRelativePath</apiName><shortdesc>
	 Находит среди двух путей к файлу относительный путь.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Ссылка имеет значение <codeph>null</codeph>.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Вызывающий оператор не находится в изолированной программной среде безопасности.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>Относительный путь между этим файлом (или каталогом) и файлом (или каталогом) <codeph>ref</codeph>, если возможно; в противном случае – <codeph>null</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>ref</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc> Объект File, относительно которого задан путь.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>useDotDot</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc> Указывает, может ли конечный относительный путь использовать компоненты «..».
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Находит среди двух путей к файлу относительный путь.
	 
	 <p>Относительный путь – это список компонентов, которые могут быть добавлены (разрешены по отношению) к этой ссылке для обнаружения второй (параметрической) ссылки. Для записи возвращенного относительного пути используется разделитель «/».</p>
	 
	 <p>В других случаях относительные пути могут содержать ссылки «..», но такие пути не могут превышать предельного объема.</p>
	 
	 </apiDesc><example conref="examples\File.getRelativePath.1.as"/></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:getRootDirectories"><apiName>getRootDirectories</apiName><shortdesc>
	 Возвращается массив объектов File, в котором перечислены корневые каталоги файловой системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Массив объектов File, в котором перечислены корневые каталоги. 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращается массив объектов File, в котором перечислены корневые каталоги файловой системы. 
	 
	 <p>Например, в ОС Windows это список томов, таких как C: и D:. Пустой том, например CD- или DVD-привод, в который не установлен диск, не учитывается в массиве. В Mac OS и Linux этот метод всегда возвращает уникальный корневой каталог компьютера (каталог «/»)</p>
	 
	 </apiDesc><example conref="examples\File.getRootDirectories.1.as"> Следующий код выводит список корневых каталогов:
<codeblock>
import flash.filesystem.File;
var rootDirs:Array = File.getRootDirectories();

for (var i:uint = 0; i &lt; rootDirs.length; i++) {
    trace(rootDirs[i].nativePath);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:moveTo"><apiName>moveTo</apiName><shortdesc>
	 Перемещает файл или каталог из места, заданного объектом File, в место, заданное параметром destination.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Источник не существует; либо адресат существует, и <codeph>overwrite</codeph> установлен на <codeph>false</codeph>; либо исходный файл или каталог не мог быть перемещен в целевое местоположение; либо источник и адресат указывают на один файл или одну папку, и <codeph>overwrite</codeph> установлен на <codeph>true</codeph>. ОС Windows не позволяет перемещать открытый файл или каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Место назначения для перемещения. Этот объект указывает путь к конечному (перемещенному) файлу или каталогу, а <i>не</i> к исходному каталогу.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При значении <codeph>false</codeph> перемещение не выполняется, если <codeph>целевой</codeph> файл уже существует. При значении <codeph>true</codeph> в ходе операции сначала стираются все существующие файлы или каталоги с таким же именем. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Перемещает файл или каталог из места, заданного объектом File, в место, заданное параметром <codeph>destination</codeph>. 
	 
	 <p>Для переименования файла задайте параметр <codeph>destination</codeph>, чтобы он указывал на путь в каталог, содержащий файл, но с другим именем файла.</p>
	 
	 <p>Процесс перемещения создает все необходимые вышестоящие каталоги (если возможно).</p>
	 
	 </apiDesc><example conref="examples\File.moveTo.1.as"> Следующий код показывает, как переименовать файл с помощью метода <codeph>moveTo()</codeph>. Исходное имя файла test1.txt в результате меняется на имя test2.txt. Так как и исходный, и целевой объекты File указывают на один и тот же каталог (вложенный каталог Apollo Test каталога документов пользователя), метод <codeph>moveTo()</codeph> переименовывает файл, а не перемещает его в новый каталог. Перед выполнением этого кода необходимо создать файл test1.txt во вложенном каталоге AIR Test каталога документов на компьютере. Если для параметра <codeph>clobber</codeph> задано значение <codeph>true</codeph>, эта операция перезаписывает любой существующий файл test2.txt.
<codeblock>

import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

try  
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" error.message);
}
</codeblock></example><example conref="examples\File.moveTo.2.as"> Следующий код показывает, как переместить файл с помощью метода <codeph>moveTo()</codeph>. Исходным файлом является файл test1.txt во вложенном каталоге Apollo Test каталога документов пользователя, и этот метод перемещает данный файл во вложенный каталог Results. Перед выполнением этого кода необходимо создать файл test1.txt во вложенном каталоге AIR Test основного каталога на компьютере. На примере инструкций <codeph>try</codeph> и <codeph>catch</codeph> показано, как отвечать на ошибки.
<codeblock>
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/Results/test1.txt");

try 
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" error.message);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyTo()"><linktext>copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()"><linktext>moveToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveToAsync"><apiName>moveToAsync</apiName><shortdesc>
	 Перемещает файл или каталог из места, заданного объектом File, в место, заданное параметром newLocation.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>Место назначения для перемещения. Этот объект указывает путь к конечному (перемещенному) файлу или каталогу, а <i>не</i> к исходному каталогу.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>При значении <codeph>false</codeph> перемещение не выполняется, если <codeph>целевой</codeph> файл уже существует. При значении <codeph>true</codeph> в ходе операции сначала стираются все существующие файлы или каталоги с таким же именем.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Перемещает файл или каталог из места, заданного объектом File, в место, заданное параметром <codeph>newLocation</codeph>. 
	 
	 <p>Для переименования файла задайте параметр <codeph>destination</codeph>, чтобы он указывал на путь в каталог, содержащий файл, но с другим именем файла.</p>
	 
	 <p>Процесс перемещения создает все необходимые вышестоящие каталоги (если возможно).</p>
	 
	 </apiDesc><example conref="examples\File.moveToAsync.1.as"> Следующий код показывает, как переименовать файл с помощью метода <codeph>moveToAsync()</codeph>. Исходное имя файла test1.txt в результате меняется на имя test2.txt. Так как и исходный, и целевой объекты File указывают на один и тот же каталог (вложенный каталог Apollo Test каталога документов пользователя), метод <codeph>moveToAsync()</codeph> переименовывает файл, а не перемещает его в новый каталог. Перед выполнением этого кода необходимо создать файл test1.txt во вложенном каталоге Apollo Test каталога документов на компьютере. Если для параметра <codeph>clobber</codeph> задано значение <codeph>true</codeph>, эта операция перезаписывает любой существующий файл test2.txt.
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("Apollo Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

var sourceFile.moveToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileMoveCompleteHandler);

function fileMoveCompleteHandler(event:Event):void 
{
    trace("Done.")
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyToAsync()"><linktext>copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()"><linktext>moveTo()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при успешном перемещении файла или каталога. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при успешном перемещении файла или каталога.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Источник не существует; либо адрес назначения существует, и <codeph>overwrite</codeph> имеет значение <codeph>false</codeph>; либо источник невозможно переместить в целевое местоположение; либо источник и адресат указывают на один файл или одну папку, и для <codeph>overwrite</codeph> установлено значение <codeph>true</codeph>. ОС Windows не позволяет перемещать открытый файл или каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Источник не существует; либо адрес назначения существует, и overwrite равно false; либо источник не удалось переместить в целевой объект; либо источник и адресат указывают на один файл или одну папку, и overwrite установлен на true.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:moveToTrash"><apiName>moveToTrash</apiName><shortdesc>
	 Перемещает файл или каталог в корзину.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Операционная система не разрешила выполнить операцию, либо файла или каталога не существует. ОС Windows не позволяет перемещать открытый файл или каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Перемещает файл или каталог в корзину.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveToTrashAsync"><apiName>moveToTrashAsync</apiName><shortdesc>
	 Перемещает файл или каталог в корзину в асинхронном режиме.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Перемещает файл или каталог в корзину в асинхронном режиме. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Операционная система не разрешила выполнить операцию, либо файла или каталога не существует. ОС Windows не позволяет перемещать открытый файл или каталог, если открыт хотя бы один из содержащихся в нем файлов.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Операционная система не позволяет выполнить операцию, либо файл или каталог не существуют.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при успешном перемещении файла или каталога в корзину. 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при успешном перемещении файла или каталога в корзину.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:resolvePath"><apiName>resolvePath</apiName><shortdesc>
	 Создает новый объект File с относительным для данного объекта File путем, на основе параметра path (строки).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Новый объект File, указывающий на получившийся путь.
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn><apiParam><apiItemName>path</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Путь, который нужно добавить в конец пути данного объекта File (если параметр <codeph>path</codeph> представляет относительный путь); или возвращаемый путь (если параметр <codeph>path</codeph> представляет абсолютный путь).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Создает новый объект File с относительным для данного объекта File путем, на основе параметра <codeph>path</codeph> (строки).
	 
	 <p>В качестве параметра <codeph>path</codeph> можно использовать относительный или абсолютный путь.</p>
	 
	 <p>При указании относительного пути заданный <codeph>path</codeph> добавляется в конец пути объекта File. Однако использование «..» в записи <codeph>path</codeph> может вернуть путь, не являющийся нижестоящим путем объекта File. Полученная ссылка не обязательно должна ссылаться на действительное место расположения файловой системы.</p>
	 
	 <p>При указании абсолютной ссылки на файл метод возвращает объект File, указывающий на этот путь. В абсолютной ссылке на файл должен использоваться допустимый синтаксис пути, присущий операционной системе пользователя (например, <codeph>С:\\test</codeph> в Windows). <i>Не</i> используйте URL-адрес (например, <codeph>file:///c:/test</codeph>) в качестве параметра <codeph>path</codeph>.</p>
	 
	 <p>Все полученные пути нормализуются следующим образом: </p>
	 
	 <ul>
	 
	 	<li>Все элементы «.» игнорируются.</li>
	 
	 	<li>Все элементы «..» замещают вышестоящие записи.  </li>
	 
	 	<li>Ни одна ссылка «..», достигающая корневого каталога файловой системы или корневого каталога хранения данных приложения, не проходит этот узел; такие ссылки игнорируются.</li>
	 
	 </ul>
	 
	 <p>В качестве разделителя в записи пути всегда следует использовать левую косую черту (<codeph>/</codeph>). В Windows можно также использовать обратную косую черту (<codeph>\</codeph>), но при этом приложение может не работать на других платформах.</p>
	 
	 <p>Имена файлов и каталогов в Linux чувствительны к регистру.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filesystem:File:applicationDirectory:get"><apiName>applicationDirectory</apiName><shortdesc>
	 Папка с установленными файлами приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Папка с установленными файлами приложения.
	 
	 <p>Свойство <codeph>url</codeph> для этого объекта использует схему URL-адресов <codeph>app</codeph> (не схему <codeph>file</codeph>). Это означает, что строка <codeph>url</codeph> открывается записью<codeph>app:</codeph> (а не <codeph>file:</codeph>). Кроме того, если создается объект File, связанный с каталогом <codeph>File.applicationDirectory</codeph> (с помощью метода <codeph>resolvePath()</codeph>), то <codeph>url</codeph> объекта File также использует схему URL-адреса <codeph>app</codeph> (как в примере). 
	 </p>
	 
	 <p><i>Примечание.</i> В файлы или каталоги, использующие схему URL-адреса <codeph>app</codeph>, невозможно производить запись. Также невозможно удалить или создать файлы и папки с путями, в которых используется схема URL <codeph>app</codeph>. Из соображений безопасности не следует модифицировать содержимое в каталоге приложения. Если требуется сохранить какие-то данные приложения, лучше использовать каталог хранения данных приложения (<codeph>File.applicationStorageDirectory</codeph>). Если необходимо дать каким-либо файлам в каталоге хранения данных приложения доступ к отдельным функциям приложений (API приложения AIR), можно поместить эти функции в изолированную программную среду безопасности.</p>
	 
	 <p>Свойство <codeph>applicationDirectory</codeph> позволяет создать ссылку на каталог приложения, который будет действительным для всех платформ. Если задать объект File для ссылки на каталог приложения с помощью свойства <codeph>nativePath</codeph> или <codeph>url</codeph>, эта ссылка будет работать только на той платформе, для которой этот путь является действительным.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filesystem.xml#File/applicationStorageDirectory"><linktext>applicationStorageDirectory</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:applicationStorageDirectory:get"><apiName>applicationStorageDirectory</apiName><shortdesc>
     Каталог для хранения данных приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
     Каталог для хранения данных приложения. 
	 
	 <p>Каждое приложение AIR имеет свой постоянный каталог для хранения данных, который создается при первом вызове <codeph>File.applicationStorageDirectory</codeph>. Этот каталог очень удобен для хранения данных приложения.</p>
	 
	 <p>При установке приложения AIR программа удаления не удаляет файлы, хранящиеся в этом каталоге.</p>
	 
	 <p>Свойство <codeph>url</codeph> для этого объекта использует схему URL-адреса <codeph>app-storage</codeph> (не схему <codeph>file</codeph>). Это означает, что строка <codeph>url</codeph> открывается записью<codeph>app-storage:</codeph> (а не <codeph>file:</codeph>). Кроме того, если создается объект File, связанный с каталогом <codeph>File.applicationStoreDirectory</codeph> (с помощью метода <codeph>resolvePath()</codeph>), то <codeph>url</codeph> объекта File также использует схему URL-адреса <codeph>app-storage</codeph> (как в примере).</p>
	 
	 <p>Свойство <codeph>applicationStorageDirectory</codeph> позволяет создать ссылку на каталог хранилища приложения, который будет действительным для всех платформ. Если задать объект File для ссылки на каталог хранилища приложения с помощью свойства <codeph>nativePath</codeph> или <codeph>url</codeph>, эта ссылка будет работать только на той платформе, для которой этот путь является действительным.</p>
	 
	 </apiDesc><example conref="examples\File.applicationStorageDirectory.1.as"> Следующий код создает объект File, указывающий на вложенный каталог images в каталоге хранилища приложения.
<codeblock>
import flash.filesystem.File;

var tempFiles:File = File.applicationStorageDirectory;
tempFiles = tempFiles.resolvePath("images/");
trace(tempFiles.url); // app-storage:/images
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:desktopDirectory:get"><apiName>desktopDirectory</apiName><shortdesc>
	 Каталог рабочего стола пользователя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Каталог рабочего стола пользователя.
	 
	 <p>Свойство <codeph>desktopDirectory</codeph> позволяет создать ссылку на каталог рабочего стола, который будет действительным для всех платформ. Если задать объект File для ссылки на каталог рабочего стола с помощью свойства <codeph>nativePath</codeph> или <codeph>url</codeph>, эта ссылка будет работать только на той платформе, для которой этот путь является действительным.</p>
	 
	 </apiDesc><example conref="examples\File.desktopDirectory.1.as"> Следующий код выводит список файлов и каталогов в каталоге рабочего стола пользователя.
<codeblock>
import flash.filesystem.File;
var desktop:File = File.desktopDirectory;

var files:Array = desktop.getDirectoryListing();

for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock><swfblock conref="examples\File.desktopDirectory.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:documentsDirectory:get"><apiName>documentsDirectory</apiName><shortdesc>
	 Каталог с документами пользователя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Каталог с документами пользователя.
	 
	 <p>В Windows это каталог «Мои документы» (например, C:\Documents and Settings\имя_пользователя\Мои документы). В Mac OS это по умолчанию каталог /Users/имя_пользователя/Documents. В Linux это по умолчанию каталог /home/имя_пользователя/Documents (в англоязычной системе), и это свойство учитывает настройку <codeph>xdg-user-dirs</codeph>.</p>
	 
	 <p>Свойство <codeph>documentsDirectory</codeph> позволяет создать ссылку на каталог документов, который будет действительным для всех платформ. Если задать объект File для ссылки на каталог документов с помощью свойства <codeph>nativePath</codeph> или <codeph>url</codeph>, эта ссылка будет работать только на той платформе, для которой этот путь является действительным.</p>
	 
	 </apiDesc><example conref="examples\File.documentsDirectory.1.as"> Следующий код использует свойство <codeph>File.documentsDirectory</codeph> и метод <codeph>File.createDirectory()</codeph> для проверки существования каталога с именем AIR Test в каталоге документов пользователя.
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory;
directory = directory.resolvePath("AIR Test");

File.createDirectory(directory);
trace(directory.exists); // true
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:exists:get"><apiName>exists</apiName><shortdesc>
     Определяет, существует ли файл или каталог, на который дается ссылка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, существует ли файл или каталог, на который дается ссылка. Значение <codeph>true</codeph> присваивается, если объект File указывает на существующий файл или каталог, в противном случае присваивается значение <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\File.exists.1.as"> Следующий код создает временный файл, затем удаляет его и с помощью свойства <codeph>File.exists</codeph> проверяет существование файла.
<codeblock>
import flash.filesystem.*;

var temp:File = File.createTempFile();
trace(temp.exists); // true
temp.deleteFile();
trace(temp.exists); // false
</codeblock><swfblock conref="examples\File.exists.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:icon:get"><apiName>icon</apiName><shortdesc>
	 Объект Icon, содержащий значки, заданные для этого файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:Icon</apiValueClassifier></apiValueDef><apiDesc>
	 Объект Icon, содержащий значки, заданные для этого файла. Объект Icon является массивом объектов BitmapData, связанных с различными состояниями значков. В Linux объект Icon не содержит значков.
	 
	 </apiDesc><example conref="examples\File.icon.1.as"> На примере следующего кода показан поиск в массиве <codeph>icon</codeph> изображения с наибольшей высотой и присвоение этого изображения объекту Bitmap.
<codeblock>
import flash.filesystem.File;
import flash.display.*;

var directory:File = File.documentsDirectory;
var bitmaps:Array = directory.icon.bitmaps;
var bmpData:BitmapData = new BitmapData(1, 1);
for (var i:uint = 0; i &lt; bitmaps.length; i++) {
    if (bitmaps[i].height > bmpData.height) {
        bmpData = directory.icon.bitmaps[i];
    }
}
var iconBmp:Bitmap = new Bitmap(bmpData);
</codeblock> Этот объект Bitmap можно добавить в качестве нижестоящего элемента контейнера экранного объекта, например объекта Sprite или объекта Flex UIComponent.
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isDirectory:get"><apiName>isDirectory</apiName><shortdesc>
     Указывает, ведет ли ссылка на каталог.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, ведет ли ссылка на каталог. Значение <codeph>true</codeph> присваивается, если объект File указывает на каталог, в противном случае присваивается значение <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\File.isDirectory.1.as"> Следующий код создает массив объектов File с указанием на файлы и каталоги в каталоге пользователя, затем с помощью свойства <codeph>isDirectory</codeph> выводит список только тех объектов File, которые указывают на каталоги, а не файлы.
<codeblock>
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isDirectory) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isDirectory.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isHidden:get"><apiName>isHidden</apiName><shortdesc>
     Указывает, являются ли файл или каталог, на которые ведет ссылка, скрытыми. Значение true присваивается, если файл или каталог, на которые указывает ссылка, являются скрытыми, в противном случае присваивается значение false.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>(Waiting for Stan's OK:)
	 
	 <ul>
	 
	 	<li>On Windows, a file or directory is designated as hidden by specifying the 
	 Hidden attribute (for example, in the File Properties dialog box) for the file.</li>
	 
	 	<li>On Mac OS and Linux, files can be designated as hidden for a number of reasons. Files with 
	 names that begin with the dot (.) character are designated as hidden. A .hidden file 
	 in the root directory lists other hidden files. Also, there is a bit in the file that, 
	 when set, makes it hidden.</li>
	 
	 </ul>
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, являются ли файл или каталог, на которые ведет ссылка, скрытыми. Значение <codeph>true</codeph> присваивается, если файл или каталог, на которые указывает ссылка, являются скрытыми, в противном случае присваивается значение <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\File.isHidden.1.as"> Следующий код создает массив объектов File с указанием на файлы и каталоги в каталоге пользователя, затем с помощью свойства <codeph>isHidden</codeph> выводит список скрытых файлов и каталогов.
<codeblock>
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isHidden) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isHidden.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isPackage:get"><apiName>isPackage</apiName><shortdesc>
     Указывает, является ли каталог, на который ссылаются, пакетом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, является ли каталог, на который ссылаются, пакетом.
     
	 <p>Значение <codeph>true</codeph>присваивается, если каталог, на который ссылаются, является пакетом, в противном случае присваивается значение <codeph>false</codeph>. Обратите внимание, что в классе File не предусмотрено прямое создание пакетов.</p>
	 
	 <ul>
	 
	 	<li>В Mac OS каталог может быть назначен пакетом и в этом случае будет отображаться в диспетчере файлов Finder как единый файл, а не как каталог. Этому свойству присваивается значение <codeph>true</codeph>, если каталог, на который ссылается объект, является пакетом; или значение <codeph>false</codeph>, если файл не является каталогом или пакетом или его не существует.</li>
	 
	 	<li>В других операционных системах это свойство всегда имеет значение <codeph>false</codeph>.</li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isSymbolicLink:get"><apiName>isSymbolicLink</apiName><shortdesc>
     Указывает, является ли ссылка символьной.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, является ли ссылка символьной.
     
	 <p>Значение <codeph>true</codeph> присваивается, если объект File указывает на каталог, в противном случае присваивается значение <codeph>false</codeph>. Обратите внимание, что в классе File не предусмотрено прямое создание символьных ссылок.</p>
	 
	 <p>С помощью символьных ссылок один файл может ссылаться на другой файл или каталог на диске. Не путайте символьные ссылки с псевдонимами в Mac OS и ярлыками в Windows, это не одно и то же. Псевдонимы и ярлыки всегда считаются файлами (не каталогами), а чтение или запись псевдонимов и ярлыков не изменяет файлы, на которые они указывают. Символьная ссылка, в свою очередь, повторяет поведение файла или каталога, на который она указывает. Она может считаться файлом или каталогом, а при чтении и записи символьной ссылки изменения будут производиться над самим файлом, на который она указывает, а не только над ссылкой. Удаление символьной ссылки приводит к удалению самой ссылки, а не целевого объекта.</p>
	 
	 <p>Операционные системы Mac<sup>®</sup> OS<sup>®</sup>, Linux и Windows<sup>®</sup> Vista<sup>®</sup> поддерживают символьные ссылки. Кроме этого, в Windows свойство <codeph>isSymbolicLink</codeph> для объекта File, ссылающегося на точку соединения (используется в файловой системе NTFS) имеет значение <codeph>true</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:lineEnding:get"><apiName>lineEnding</apiName><shortdesc>
	 Последовательность символов закрытия строки, используемая домашней операционной системой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Последовательность символов закрытия строки, используемая домашней операционной системой.
	 
	 <p>В Mac OS и Linux это знак перевода строки (шестнадцатеричный код символа 0x0A). В ОС Windows это знак возврата каретки (шестнадцатеричный код символа 0x0D) в сочетании со знаком перевода строки (шестнадцатеричный код символа 0x0A).</p>
	 
	 </apiDesc><example conref="examples\File.lineEnding.1.as"> Следующий код записывает строку (<codeph>str</codeph>) в текстовый файл и с помощью статического свойства <codeph>File.lineEnding</codeph> заменяет все экземпляры символа начала новой строки (представленного в коде регулярным выражением <codeph>/\n/g</codeph>) на предпочитаемый домашней операционной системой символ закрытия строки.
<codeblock>
import flash.filesystem.*;

var str:String = "Hello\n" + 
        "World\n";
str = str.replace(/\n/g, File.lineEnding);
var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF(str);
fileStream.close();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:nativePath:get"><apiName>nativePath</apiName><shortdesc>
	 Полный путь в представлении домашней операционной системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Вызывающий оператор не находится в изолированной программной среде безопасности.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Неверный синтаксис пути.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Полный путь в представлении домашней операционной системы. В Mac OS и Linux в качестве разделителя в записи пути используется левая косая черта (/). Однако в Windows можно <i>задать</i> свойство <codeph>nativePath</codeph>, используя в качестве разделителя в записи пути прямую (/) или обратную (\) косую черту, а AIR автоматически заменит все прямые косые черты обратными.
	 
	<p>Прежде чем написать код для прямого <i>задания</i> свойства <codeph>nativePath</codeph>, подумайте, не приведет ли это к созданию кода, который будет работать только на одной конкретной платформе. Например, такой собственный путь, как <codeph>C:\\Documents and Settings\\bob\\Desktop</codeph>, действителен только для Windows. Рекомендуется использовать следующие статические свойства, представляющие часто используемые каталоги и действительные для всех платформ:</p>
	
	<ul>
	<li><codeph>File.applicationDirectory</codeph></li>
	<li><codeph>File.applicationStorageDirectory</codeph></li>
	<li><codeph>File.desktopDirectory</codeph></li>
	<li><codeph>File.documentsDirectory</codeph></li>
	<li><codeph>File.userDirectory</codeph></li>
	</ul>
	
	<p>Можно вызвать метод <codeph>resolvePath()</codeph>, чтобы получить относительный путь к этим каталогам.</p>
	
	<p product="flex">Некоторые интерфейсы Flex API, например, свойство <codeph>source</codeph> класса SWFLoader, используют URL-адрес (свойство <codeph>url</codeph> объекта File), а не собственный путь (свойство <codeph>nativePath</codeph>).</p>
	
	<p platform="javascript">Некоторые интерфейсы API, например, свойство <codeph>src</codeph> объекта IMG, используют URL-адрес (свойство <codeph>url</codeph> объекта File), а не собственный путь (свойство <codeph>nativePath</codeph>).</p>
	
	 </apiDesc><example conref="examples\File.nativePath.1.as"> Следующий код иллюстрирует разницу между свойством <codeph>nativePath</codeph> и свойством <codeph>url</codeph> объекта File. Комментарии содержат результаты на примере компьютера Windows.
<codeblock>
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:parent:get"><apiName>parent</apiName><shortdesc>
     Каталог, содержащий файл или каталог, на который ссылается данный объект File.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
     Каталог, содержащий файл или каталог, на который ссылается данный объект File. 
	 
	 <p>Если файла или каталога не существует, свойство <codeph>parent</codeph> все равно будет возвращать объект File, указывающий на каталог, содержащий файл или каталог, даже если его не существует.</p>
	 
	 <p>Это свойство идентично возвращаемому значению для функции <codeph>resolvePath("..")</codeph>, но при этом вышестоящему элементу корневого каталога присваивается значение <codeph>null</codeph>.</p>
	 
	 </apiDesc><example conref="examples\File.parent.1.as"> Следующий код использует свойство <codeph>parent</codeph>, чтобы показать каталог, содержащий временный файл.
<codeblock>
import flash.filesystem.File;

var tempFile:File = File.createTempDirectory();
trace(tempFile.parent.nativePath);
tempFile.deleteFile();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:separator:get"><apiName>separator</apiName><shortdesc>
	 Разделительный символ, используемый в домашней операционной системе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Разделительный символ, используемый в домашней операционной системе.
	 
	 <p>В Mac OS и Linux таким разделителем является левая косая черта (/). В ОС Windows это обратная косая черта (\).</p>
	 
	 <p><i>Примечание.</i> При использовании обратной косой черты в строковом литерале необходимо вводить ее дважды (например, <codeph>directory\\file.ext</codeph>). Две обратных косых черты в строковом литерале идентичны одной обратной косой черте в строке.</p>
	 
	 </apiDesc><example conref="examples\File.separator.1.as"> Следующий код использует метод <codeph>getRelativePath()</codeph> для получения относительного пути от каталога к файлу. Затем с помощью статического свойства <codeph>File.separator</codeph> код заменяет символы левой косой черты (/) в обозначении пути на разделители, используемые операционной системой, т. е. на обратную косую черту (\) в Windows и левую косую черту в других операционных системах.
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Apollo Test");
var file:File = File.documentsDirectory.resolvePath("Apollo Test/employees/bob/test.txt");

var relativePath:String = directory.getRelativePath(file); // employees/bob/test.txt
relativePath = relativePath.replace(/\//g, File.separator);
trace(relativePath); 
</codeblock> В данном примере метод <codeph>replace()</codeph> использует регулярное выражение <codeph>/\//g</codeph> для поиска соответствий <i>всем</i> символам левой косой черты.
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:spaceAvailable:get"><apiName>spaceAvailable</apiName><shortdesc>
	 Доступное для использования пространство в данном местоположении File, в байтах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Доступное для использования пространство в данном местоположении File, в байтах. 
	 
	 <p> Если объект File ссылается на каталог, <codeph>spaceAvailable</codeph> указывает на объем пространства в каталоге, доступный для использования файлами. Если объект File ссылается на файл, <codeph>spaceAvailable</codeph> указывает доступный объем увеличения файла. Если местоположение файла не существует, <codeph>spaceAvailable</codeph> имеет значение 0. Если объект File указывает на символическую ссылку, <codeph>spaceAvailable</codeph> указывает на доступное пространство в указанном символической ссылкой местоположении.</p>
	 
	 <p>Как правило, доступное для файла или каталога пространство равно такому пространству в томе, содержащем этот файл или каталог. Однако при выделении доступного пространства могут учитываться квоты и ограничения, установленные для каталогов.</p>
	 
	 <p>При добавлении файла или каталога в том, как правило, требуется больше места, чем фактический размер файла или содержимого каталога. Например, операционной системе может потребоваться дополнительное место для хранения информации указателей. Или секторам диска может потребоваться дополнительное пространство. К тому же, доступное пространство динамически изменяется. Поэтому выделение <i>всего</i> требуемого пространства для хранения файлов может быть невозможно.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:systemCharset:get"><apiName>systemCharset</apiName><shortdesc>
	 Кодировка по умолчанию, используемая домашней операционной системой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Кодировка по умолчанию, используемая домашней операционной системой. 
	 
	 <p>Возможные значения включают <codeph>"windows-1252"</codeph> <codeph>"shift-jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>.</p>
	 
	 <p>Это значение можно использовать с методами <codeph>readMultiByte()</codeph> и <codeph>writeMultiByte()</codeph> класса FileStream.</p>
	 
	 </apiDesc><example conref="examples\File.systemCharSet.1.as"> Следующий код открывает файл (файл test.txt во вложенном каталоге AIR Test каталога документов пользователя) и использует статическое свойство <codeph>File.systemCharset</codeph> в качестве параметра <codeph>charSet</codeph> в вызове метода <codeph>readMultiByte()</codeph> объекта FileStream.
<codeblock>
import flash.filesystem.File;

var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);    
</codeblock></example></apiValueDetail><related-links><link href="flash.filesystem.xml#FileStream/readMultiByte()"><linktext>FileStream.readMultiByte()</linktext></link><link href="flash.filesystem.xml#FileStream/writeMultiByte()"><linktext>FileStream.writeMultiByte()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:url:get"><apiName>url</apiName><shortdesc>
	 URL-адрес данного пути к файлу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>The URL will have a null "host" specification. (As opposed to "localhost". This is more confusing than 
	 informative.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Неверный синтаксис URL-адреса.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Вызывающий оператор не находится в изолированной программной среде безопасности.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 URL-адрес данного пути к файлу.
	 
	 <p>Если это ссылка на путь в каталог хранения данных приложения, схема URL будет <codeph>app-storage</codeph>. Если это ссылка на путь в каталог приложения, схема URL будет <codeph>app</codeph>. Во всех остальных случаях схема будет <codeph>file</codeph>. </p>
	 
	 <p>Для <i>присвоения</i> значения свойству <codeph>url</codeph> рекомендуется использовать знаки пробела (вместо <codeph>"%20"</codeph>). AIR автоматически кодирует строки (например, переводит пробелы в <codeph>"%20"</codeph>).</p>
	 
	 </apiDesc><example conref="examples\File.nativePath.1.as"> Следующий код иллюстрирует разницу между свойством <codeph>nativePath</codeph> и свойством <codeph>url</codeph> объекта File. Комментарии содержат результаты на примере компьютера Windows.
<codeblock>
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail><related-links><link href="flash.filesystem.xml#File/nativePath"><linktext>nativePath</linktext></link><link href="../../package.html#decodeURI()"><linktext>Глобальная функция decodeURI()</linktext></link><link href="../../package.html#decodeURIComponent()"><linktext>Глобальная функция decodeURIComponent()</linktext></link><link href="../../package.html#encodeURI()"><linktext>Глобальная функция decodeURI()</linktext></link><link href="../../package.html#encodeURIComponent()"><linktext>Глобальная функция decodeURIComponent()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:userDirectory:get"><apiName>userDirectory</apiName><shortdesc>
	 Каталог пользователя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 Каталог пользователя.
	 
	 <p>В ОС Windows это вышестоящий элемент каталога «Мои документы» (например, C:\Мои документы\имя_пользователя). В Mac OS это /Users/имя_пользователя. В Linux это /home/имя_пользователя.</p>
	 
	 <p>Свойство <codeph>userDirectory</codeph> позволяет создать ссылку на каталог пользователя, который будет действительным для всех платформ. Если задать свойство <codeph>nativePath</codeph> или <codeph>url</codeph> объекта File напрямую, ссылка будет работать только на той платформе, для которой она является действительной.</p>
	 
	 </apiDesc><example conref="examples\File.userDirectory.1.as"> Следующий код выводит список файлов и каталогов корневого уровня каталога пользователя.
<codeblock>
import flash.filesystem.File;

var files:Array = File.userDirectory.listDirectory();
for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier></apiPackage>