<?xml version="1.0"?>
<apiPackage id="flash.filters"><apiName>flash.filters</apiName><apiDetail/><apiClassifier id="flash.filters:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
Класс ColorMatrixFilter позволяет применить матричное преобразование 4 x 5 в цветовой схеме RGBA с альфа-каналом к каждому пикселю входного изображения для получения результата с новым набором значений в схеме RGBA и альфа-канала.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Применяет преобразование матрицы цветов к значениям цвета и полупрозрачности каждого пикселя.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс ColorMatrixFilter позволяет применить матричное преобразование 4 x 5 в цветовой схеме RGBA с альфа-каналом к каждому пикселю входного изображения для получения результата с новым набором значений в схеме RGBA и альфа-канала. Благодаря этому можно изменять насыщенность, оттенок и яркость альфа-канала и применять другие эффекты. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.

<p><b>Примечание.</b> В значениях цветовой схемы RGBA наиболее значимый байт является значением красного канала, за которым следуют зеленый, голубой и альфа-канал.</p>

<p>Новая цветовая матрица создается с использованием синтаксиса <codeph>new ColorMatrixFilter()</codeph>. Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
<ul><li>Если фильтр применяется к фрагментам ролика, текстовым полям, кнопкам или видео, следует использовать свойство <codeph>filters</codeph> (наследуемое от класса DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>

<li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
</ul>

<p>При применении фильтра к визуализируемому объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>

<p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение достигнет максимальных размеров.</p>

</apiDesc><example conref="examples\ColorMatrixFilterExample.as"> В следующем примере показано, как различные фильтры цветовой матрицы применяются к файлу изображения. Конструктор фильтров четыре раза вызывает <codeph>buildChild()</codeph> для загрузки и отображения четырех экземпляров изображения. При первом вызове <codeph>buildChild()</codeph> аргумент принимается за <codeph>null</codeph>, и к первому экземпляру фильтр не применяется. При каждом последующем вызове <codeph>buildChild()</codeph> аргумент принимает значение функции, применяющей разные фильтры цветовых матриц к каждому последующему экземпляру изображения.
 <p>Функция <codeph>buildChild()</codeph> создает новый объект Loader и присваивает ему имя <codeph>loader</codeph>. При каждом вызове <codeph>buildChild()</codeph> нужно назначать объекту Loader прослушиватель событий, который будет регистрировать события <codeph>complete</codeph>, обрабатываемые функцией, которая передается к <codeph>buildChild()</codeph>.</p>
 
 <p>Функции <codeph>applyRed()</codeph>, <codeph>applyGreen()</codeph> и <codeph>applyBlue()</codeph> применяют к массиву <codeph>matrix</codeph> разные значения для получения различных эффектов.</p>
 <p><b>Примечание</b>. Для оптимального результата рекомендуется использовать изображения шириной около 80 пикселей. Имя и расположение файла с изображением должны совпадать со значением, которое передается свойству <codeph>url</codeph>. Например, значение, передаваемое свойству <codeph>url</codeph> в данном примере, указывает на файл с именем Image.jpg, который хранится в том же каталоге, что и SWF-файл.
 </p>
 <codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.filters.ColorMatrixFilter;
    import flash.net.URLRequest;

    public class ColorMatrixFilterExample extends Sprite {
        private var size:uint  = 140;
        private var url:String = "Image.jpg";

        public function ColorMatrixFilterExample() {
            buildChild(null);
            buildChild(applyRed);
            buildChild(applyGreen);
            buildChild(applyBlue);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if (loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyRed(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([1, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyGreen(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 1, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 0, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyBlue(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = new Array();
            matrix = matrix.concat([0, 0, 0, 0, 0]); // red
            matrix = matrix.concat([0, 0, 0, 0, 0]); // green
            matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
            matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha

            applyFilter(child, matrix);
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>flash.display.BitmapData.getPixel()</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:ColorMatrixFilter:ColorMatrixFilter"><apiName>ColorMatrixFilter</apiName><shortdesc>
	Инициализирует новый экземпляр ColorMatrixFilter с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив из 20 элементов, формирующий матрицу размером 4 x 5.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Инициализирует новый экземпляр ColorMatrixFilter.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Инициализирует новый экземпляр ColorMatrixFilter с заданными параметрами.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ColorMatrixFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
 	clones it using the <code>clone</code> method. The <code>matrix</code> property cannot be changed directly (for example,
	<code>clonedFilter.matrix[2] = 1;</code>). Instead, you must get a reference
	to the array, make the change, and reset the value using
	<code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter:       " + filter.matrix);
	
	var clonedFilter:ColorMatrixFilter = filter.clone();
	matrix = clonedFilter.matrix;
	matrix[2] = 1;
	clonedFilter.matrix = matrix;
	trace("clonedFilter: " + clonedFilter.matrix);
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр ColorMatrixFilter с теми же свойствами, что и оригинал.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ColorMatrixFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	Массив из 20 элементов для преобразования цвета 4 x 5.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new ColorMatrixFilter instance and then
  	changes its <code>matrix</code> property. The <code>matrix</code> property cannot be changed by directly modifying
  	its value (for example, <code>clonedFilter.matrix[2] = 1;</code>). Instead, you must
  	get a reference to the array, make the change to the reference, and reset the
	value using <code>clonedFilter.matrix = changedMatrix</code>.
	<listing version="2.0">
	import flash.filters.ColorMatrixFilter;
	
	var matrix:Array = new Array();
	matrix = matrix.concat([1, 0, 0, 0, 0]); // red
	matrix = matrix.concat([0, 1, 0, 0, 0]); // green
	matrix = matrix.concat([0, 0, 1, 0, 0]); // blue
	matrix = matrix.concat([0, 0, 0, 1, 0]); // alpha
	
	var filter:ColorMatrixFilter = new ColorMatrixFilter(matrix);
	trace("filter: " + filter.matrix);
	var changedMatrix:Array = filter.matrix;
	changedMatrix[2] = 1;
	filter.matrix = changedMatrix;
	trace("filter: " + filter.matrix);
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Массив из 20 элементов для преобразования цвета 4 x 5. Свойство <codeph>matrix</codeph> нельзя изменить, непосредственно изменив его значение (например, <codeph>myFilter.matrix[2] = 1;</codeph>). Вместо этого нужно внести изменения в ссылку на массив и сбросить значение.
	
	<p>Фильтр цветовой матрицы выделяет в каждом пикселе исходного изображения красный, зеленый, голубой и альфа-компонент, которые соответственно обозначаются srcR, srcG, srcB и srcA. Для вычисления результата по каждому из четырех каналов значение каждого пикселя изображения умножается на значение из матрицы преобразования. К каждому результату при необходимости можно добавить смещение от -255 до 255 (пятый элемент в каждом ряду матрицы). Фильтр собирает все цветовые компоненты в единый пиксель и записывает результат. В следующей формуле элементы от a[0] до a[19] соответствуют записям от 0 до 19 в массиве из 20 элементов, который передается свойству <codeph>matrix</codeph>:</p>
	<pre>
	redResult   = (a[0]  ~~ srcR) + (a[1]  ~~ srcG) + (a[2]  ~~ srcB) + (a[3]  ~~ srcA) + a[4]
	greenResult = (a[5]  ~~ srcR) + (a[6]  ~~ srcG) + (a[7]  ~~ srcB) + (a[8]  ~~ srcA) + a[9]
	blueResult  = (a[10] ~~ srcR) + (a[11] ~~ srcG) + (a[12] ~~ srcB) + (a[13] ~~ srcA) + a[14]
	alphaResult = (a[15] ~~ srcR) + (a[16] ~~ srcG) + (a[17] ~~ srcB) + (a[18] ~~ srcA) + a[19]
	</pre>
	
	<p>Единица в значении каждого из цветов означает, что 100% указанного канала передается на выход, при этом значение цветового канала сохраняется.</p>
	
	<p>Вычисления производятся над значениями цветов до умножения. Если графика на входе состоит из перемноженных значений цветов, эти значения для данной операции автоматически переводятся в неперемноженные.</p>
	
	<p>Доступны два режима оптимизации:</p>
	
	<p><b>Только альфа-канал. </b> При передаче фильтру матрицы, которая корректирует только альфа-компонент, как показано в примере, фильтр оптимизирует изображение:</p>
	<pre>
	    1 0 0 0 0
	    0 1 0 0 0
	    0 0 1 0 0
	    0 0 0 N 0  (where N is between 0.0 and 1.0)
	</pre>
	
	<p><b>Ускоренный вариант</b>. Доступен только на процессорах с аппаратным ускорением SSE/AltiVec, например Intel<sup>®</sup> Pentium<sup>®</sup> 3 и выше или Apple<sup>®</sup> G4 и выше. Ускорение используется, когда множители лежат в диапазоне от -15,99 до 15,99, а слагаемые a[4], a[9], a[14] и a[19] – в диапазоне от -8000 до 8000.</p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
 Класс GradientGlowFilter позволяет применять эффект градиентного свечения к экранным объектам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Позволяет добавлять эффект «Градиентное свечение».
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс GradientGlowFilter позволяет применять эффект градиентного свечения к экранным объектам. Градиентное свечение – это реалистичное свечение с цветовым градиентом, которым можно управлять. Можно накладывать градиентное свечение по внутреннему или внешнему краю объекта или поверх объекта. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.
 
 <p>Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
 <ul><li>Применить фильтр к экранным объектам можно с помощью свойства <codeph>filters</codeph>. При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>
 
 <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
 </ul>
 
 <p>При применении фильтра к визуализируемому объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p> 
 
 <p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, общее масштабирование, вращение и искажение не поддерживается. Если сам объект увеличен или уменьшен (т.е. если <codeph>scaleX</codeph> и <codeph>scaleY</codeph> имеют значение, отличное от 1,0), эффект фильтра не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>
 
 <p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>
 
 </apiDesc><example conref="examples\GradientGlowFilterExample.as"> При выполнении кода, приведенного в примере ниже, будет нарисован квадрат, к которому будет применен фильтр градиентного скоса. Порядок выполнения кода таков:
 <ol>
  <li>Импортируется требуемый класс.</li>
  <li>Объявляются глобальные переменные для определения квадрата и фильтра.</li>
  <li>Создается функция конструктора, которая выполняет следующее:
      <ul>
          <li>Вызывает метод <codeph>draw()</codeph>, который использует методы класса Graphics, доступные через свойство <codeph>graphics</codeph> спрайта для рисования квадрата.</li>
          <li>Создает новый объект BitmapFilter с именем <codeph>filter</codeph> и назначает ему возвращаемое значение вызова <codeph>getBitmapFilter()</codeph>, определяющего фильтр.</li>
          <li>Создает массив с именем <codeph>myFilters</codeph> и добавляет к нему <codeph>filter</codeph>.</li>
          <li>Назначает <codeph>myFilters</codeph> свойству <codeph>filters</codeph> объекта GradientBevelFilterExample. В результате применяются все фильтры, обнаруженные в <codeph>myFilters</codeph>. В нашем случае это только один фильтр <codeph>filter</codeph>.</li>
      </ul>
  </li>
 </ol>
<codeblock>
package {
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientGlowFilter;
    import flash.display.Sprite;

    public class GradientGlowFilterExample extends Sprite {
        private var bgColor:uint = 0xCCCCCC;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        private var distance:Number  = 0;
        private var angleInDegrees:Number = 45;
        private var colors:Array     = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
        private var alphas:Array     = [0, 1, 1, 1];
        private var ratios:Array     = [0, 63, 126, 255];
        private var blurX:Number     = 50;
        private var blurY:Number     = 50;
        private var strength:Number  = 2.5;
        private var quality:Number   = BitmapFilterQuality.HIGH;
        private var type:String      = BitmapFilterType.OUTER;
        private var knockout:Boolean = false;

        public function GradientGlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientGlowFilter(distance,
                                          angleInDegrees,
                                          colors,
                                          alphas,
                                          ratios,
                                          blurX,
                                          blurY,
                                          strength,
                                          quality,
                                          type,
                                          knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>Класс GlowFilter</linktext></link></related-links><apiConstructor id="flash.filters:GradientGlowFilter:GradientGlowFilter"><apiName>GradientGlowFilter</apiName><shortdesc>
	Инициализирует фильтр с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a gradient glow filter, assigns 
	its values, and applies it to a flat rectangle image.
	
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var art:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	var distance:Number = 0;
	var angleInDegrees:Number = 45;
 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
 	var alphas:Array = [0, 1, 1, 1];
 	var ratios:Array = [0, 63, 126, 255];
	var blurX:Number = 50;
	var blurY:Number = 50;
	var strength:Number = 2.5;
	var quality:Number = 3;
	var type:String = "outer";
	var knockout:Boolean = false;
	
	var filter:GradientGlowFilter = new GradientGlowFilter(distance, 
														 angleInDegrees, 
														 colors, 
														 alphas, 
														 ratios, 
														 blurX, 
														 blurY, 
														 strength, 
														 quality, 
														 type, 
														 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	art.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
	mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Расстояние смещения свечения. 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Угол в градусах. Действительны значения от 0 до 360. 
	
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив цветов, задающий градиент. Например, красный задается значением 0xFF0000, голубой – значением 0x0000FF и т.д.
	
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений альфа-прозрачности для соответствующих цветов в массиве <codeph>colors</codeph>. Действительные значения для каждого из элементов массива – от 0 до 1. Например, при задании значения 0,25 устанавливается 25% альфа-прозрачность.
	
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений распределения цветов. Действительны значения от 0 до 255. Это значение определяет процент ширины, на которой цвет представлен на 100%.
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по горизонтали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по вертикали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между свечением и фоном. Действительны значения от 0 до 255. Чем больше значение, тем более насыщен цвет. Значение 0 означает, что фильтр не применяется.
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Заданное число применений фильтра. Используйте константы BitmapFilterQuality:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Подробные сведения см. в описании свойства <codeph>quality</codeph>.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Расположение эффекта фильтра. Возможными значениями являются константы flash.filters.BitmapFilterType:
	<ul>
	<li><codeph>BitmapFilterType.OUTER</codeph> – свечение по внешнему краю объекта.</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – свечение по внутреннему краю объекта.</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – свечение по всему объекту.</li>
	</ul>
	
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, применяется ли к объекту эффект выбивки. Эффект выбивки делает заливку объекта прозрачной и выявляет цвет фона документа. Значение <codeph>true</codeph> указывает на наличие эффекта выбивки. По умолчанию задано значение <codeph>false</codeph> (без эффекта выбивки).
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Инициализирует фильтр с заданными параметрами.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:GradientGlowFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GradientGlowFilter objects and compares them; <code>filter_1</code>
	is created by using the GradientGlowFilter construtor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: outer
		// >> knockout: false
		// >> strength: 2.5
		// >> quality: 2
		// >> blurY: 55
		// >> blurX: 55
		// >> ratios: 0,63,126,255
		// >> alphas: 0,1,1,1
		// >> colors: 16777215,16711680,16776960,52479
		// >> angle: 45
		// >> distance: 0
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example below modifies the <code>knockout</code> property of <code>filter_1</code>. Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	
	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	var alphas:Array = [0, 1, 1, 1];
	var ratios:Array = [0, 63, 126, 255];
	var filter_1:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	var filter_2:GradientGlowFilter = filter_1;
	var clonedFilter:GradientGlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр GradientGlowFilter с теми же свойствами, что и оригинальный экземпляр GradientGlowFilter.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientGlowFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	Массив значений альфа-прозрачности для соответствующих цветов в массиве colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alphas</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAlphas");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var alphas:Array = filter.alphas;
		alphas.pop();
		alphas.pop();
		alphas.push(.3);
		alphas.push(1);
		filter.alphas = alphas;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Массив значений полупрозрачности.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Массив значений альфа-прозрачности для соответствующих цветов в массиве <codeph>colors</codeph>. Действительные значения для каждого из элементов массива – от 0 до 1. Например, при задании значения 0,25 устанавливается 25% альфа-прозрачность.
	
	<p>Свойство <codeph>alphas</codeph> нельзя изменить, непосредственно поменяв его значения. Вместо этого следует внести изменения в ссылку на <codeph>alphas</codeph>, а затем задать <codeph>alphas</codeph> для ссылки.</p>
	
	<p>Свойства <codeph>colors</codeph>, <codeph>alphas</codeph> и <codeph>ratios</codeph> связаны между собой. Первый элемент массива <codeph>colors</codeph> соответствует первому элементу массива <codeph>alphas</codeph> и массива <codeph>ratios</codeph> и т.д.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Угол в градусах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowAngle");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 50;
		filter.angle = 90;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Угол в градусах. Действительны значения от 0 до 360. По умолчанию – 45. 
	
	<p>Значение угла представляет угол, под которым падает свет из предполагаемого источника, и определяет расположение эффекта относительно объекта. Если <codeph>distance</codeph> равно 0, эффект не смещается относительно объекта и, следовательно, свойство <codeph>angle</codeph> никак не влияет на объект.</p>
        
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	 Степень размытия по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Степень размытия по горизонтали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. По умолчанию используется значение 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	 Степень размытия по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Степень размытия по вертикали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. По умолчанию используется значение 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:colors:get"><apiName>colors</apiName><shortdesc>
	 Массив цветов, задающий градиент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>colors</code> property on an existing movie clip 
	 when a user clicks it.
	 <listing version="2.0">
	 import flash.filters.GradientGlowFilter;
	 var mc:MovieClip = createGradientGlowRectangle("GlowColors");
	 mc.onRelease = function() {
	 	var filter:GradientGlowFilter = this.filters[0];
	 	var colors:Array = filter.colors;
	 	colors.pop();
	 	colors.push(0xFF00FF);
	 	filter.colors = colors;
	 	this.filters = new Array(filter);
	 }
	 
	 function createGradientGlowRectangle(name:String):MovieClip {
	 	var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
	 	var w:Number = 100;
	 	var h:Number = 100;
	 	art.beginFill(0x003366);
	 	art.lineTo(w, 0);
	 	art.lineTo(w, h);
	 	art.lineTo(0, h);
	 	art.lineTo(0, 0);
	 	art._x = 20;
	 	art._y = 20;
	 
	 	var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
	 	var alphas:Array = [0, 1, 1, 1];
	 	var ratios:Array = [0, 63, 126, 255];
	 	var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
	 	var filterArray:Array = new Array();
	 	filterArray.push(filter);
	 	art.filters = filterArray;
	 	return art;
	 }
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Массив цветов, задающий градиент. Например, красный задается значением 0xFF0000, голубой – значением 0x0000FF и т.д.
	 
	 <p>Свойство <codeph>colors</codeph> нельзя изменить, непосредственно поменяв его значения. Вместо этого следует внести изменения в ссылку на <codeph>colors</codeph>, а затем задать <codeph>colors</codeph> для ссылки.</p>
	 
	 <p>Свойства <codeph>colors</codeph>, <codeph>alphas</codeph> и <codeph>ratios</codeph> связаны между собой. Первый элемент массива <codeph>colors</codeph> соответствует первому элементу массива <codeph>alphas</codeph> и массива <codeph>ratios</codeph> и т.д.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.filters.xml#GradientGlowFilter/ratios"><linktext>GradientGlowFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Расстояние смещения свечения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowDistance");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.distance = 20;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Расстояние смещения свечения. Значением по умолчанию является 4.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Определяет, применяется ли к объекту эффект выбивки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowKnockout");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}

	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, применяется ли к объекту эффект выбивки. Эффект выбивки делает заливку объекта прозрачной и выявляет цвет фона документа. Значение <codeph>true</codeph> указывает на наличие эффекта выбивки. По умолчанию задано значение <codeph>false</codeph> (без эффекта выбивки).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Заданное число применений фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowQuality");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.quality = 3;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Заданное число применений фильтра. Значение по умолчанию – <codeph>BitmapFilterQuality.LOW</codeph>, что эквивалентно однократному применению фильтра. Значение <codeph>BitmapFilterQuality.MEDIUM</codeph> применяет фильтр дважды; значение <codeph>BitmapFilterQuality.HIGH</codeph> – трижды. Фильтры с более низкими значениями выполняются быстрее.
	
	<p>Для большинства приложений достаточно значения <codeph>quality</codeph> на уровне «low» («низкое»), «medium» («среднее») или «high» («высокое»). Хотя можно использовать дополнительные числовые значения до 15 для получения разнообразных эффектов, более высокие значения выполняются дольше. Вместо увеличения значения <codeph>quality</codeph> можно просто увеличить значения свойств <codeph>blurX</codeph> и <codeph>blurY</codeph>. Это даст похожий эффект, а выполнение будет происходить быстрее.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	Массив пропорций распределения цвета для соответствующих цветов в массиве colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>ratios</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowRatios");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		var ratios:Array = filter.ratios;
		ratios.shift();
		ratios.unshift(40);
		filter.ratios = ratios;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Массив пропорций распределения цвета для соответствующих цветов в массиве <codeph>colors</codeph>. Действительны значения от 0 до 255. 
	
	<p>Свойство <codeph>ratios</codeph> нельзя изменить, непосредственно поменяв его значения. Вместо этого следует внести изменения в ссылку на <codeph>ratios</codeph>, а затем задать <codeph>ratios</codeph> для ссылки.</p>
	
	<p>Свойства <codeph>colors</codeph>, <codeph>alphas</codeph> и <codeph>ratios</codeph> связаны между собой. Первый элемент массива <codeph>colors</codeph> соответствует первому элементу массива <codeph>alphas</codeph> и массива <codeph>ratios</codeph> и т.д.</p>
	
	<p>Представьте градиентное свечение как свечение, исходящее из центра объекта (если значение <codeph>distance</codeph> равно 0) и состоящее из цветовых полос, переходящих друг в друга. Первый цвет в массиве <codeph>colors</codeph> – это самый удаленный от центра цвет свечения. Последний цвет – самый близкий к центру свечения.</p> 
	
	<p>Каждое значение в массиве <codeph>ratios</codeph> задает положение цвета на линии радиуса градиента, где 0 – это самая удаленная от центра точка градиента, а 255 – самая близкая к центру. Значения пропорций могут варьироваться от 0 до 255 пикселей в порядке возрастания, например [0, 64, 128, 200, 255]. Значения от 0 до 128 отображаются во внешней области свечения. Значения от 129 до 255 отображаются во внутренней области свечения. В зависимости от значений пропорций цветов и значения <codeph>type</codeph> фильтра цвета фильтра могут замутняться под влиянием объекта, к которому применяется фильтр.</p>
	
	<p>В следующем коде и изображении рассматривается фильтр, примененный к фрагменту ролика в форме черного круга, тип которого <codeph>full</codeph>. В учебных целях первый цвет в массиве <codeph>colors</codeph> сделаем розовым, он будет иметь значение <codeph>alpha</codeph> 1, чтобы его было видно на белом фоне. (На практике вы, скорее всего, не захотите, чтобы первый цвет отображался таким образом). Последний цвет массива, желтый, замутняет черный круг, к которому применяется фильтр:</p>
	
	<p><pre>
	var colors:Array = [0xFFCCFF, 0x0000FF, 0x9900FF, 0xFF0000, 0xFFFF00];
	var alphas:Array = [1, 1, 1, 1, 1];
	var ratios:Array = [0, 32, 64, 128, 225];
	var myGGF:GradientGlowFilter = new GradientGlowFilter(0, 0, colors, alphas, ratios, 50, 50, 1, 2, "full", false);
	</pre></p>
    <p><adobeimage alt="Фильтр «Градиентное свечение» с массивом пропорций 0, 32, 64, 128, 225." href="../../images/gradientGlowDiagram.jpg"/></p>
	
	<p>Для получения ровного слияния с фоном документа при задании значения <codeph>type</codeph> <codeph>outer</codeph> или <codeph>full</codeph> нужно, чтобы первый цвет массива совпадал с цветом фона документа или чтобы значение альфа-канала первого цвета было 0. В любом случае, фильтр будет плавно накладываться на фон.</p>
	
	<p>Всего два небольших изменения в этом коде могут дать совершенно иной эффект свечения, даже при таких же массивах <codeph>ratios</codeph> и <codeph>colors</codeph>. Установите значение альфа-канала 0 для первого цвета массива, чтобы фильтр плавно накладывался на белый фон документа, а свойству <codeph>type</codeph> назначьте значение <codeph>outer</codeph> или <codeph>inner</codeph>. Сравните результат с рисунками ниже.</p>
        <p><adobeimage alt="внешнее свечение" href="../../images/gradientGlowOuter.jpg"/> <adobeimage alt="внутреннее свечение" href="../../images/gradientGlowInner.jpg"/></p>
	<p>Следует помнить, что распределение цветов в градиенте зависит от значений свойств <codeph>blurX</codeph>, <codeph>blurY</codeph>, <codeph>strength</codeph> и <codeph>quality</codeph>, а также от значений <codeph>ratios</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientGlowFilter/colors"><linktext>GradientGlowFilter.colors</linktext></link><link href="flash.filters.xml#GradientGlowFilter/alphas"><linktext>GradientGlowFilter.alphas</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientGlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Степень вдавливания или нанесения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowStrength");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между свечением и фоном. Действительны значения от 0 до 255. Значение 0 означает, что фильтр не применяется. Значением по умолчанию является 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientGlowFilter:type:get"><apiName>type</apiName><shortdesc>
	Расположение эффекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GradientGlowFilter;
	var mc:MovieClip = createGradientGlowRectangle("GlowType");
	mc.onRelease = function() {
		var filter:GradientGlowFilter = this.filters[0];
		filter.type = "inner";
		filter.strength = 1;
		this.filters = new Array(filter);
	}
	
	function createGradientGlowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var colors:Array = [0xFFFFFF, 0xFF0000, 0xFFFF00, 0x00CCFF];
		var alphas:Array = [0, 1, 1, 1];
		var ratios:Array = [0, 63, 126, 255];
		var filter:GradientGlowFilter = new GradientGlowFilter(0, 45, colors, alphas, ratios, 55, 55, 2.5, 2, "outer", false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Строка при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Расположение эффекта фильтра. Возможными значениями являются константы flash.filters.BitmapFilterType:
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> – свечение по внешнему краю объекта.</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – свечение по внутреннему краю объекта.</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – свечение по всему объекту.</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
Класс DisplacementMapFilter использует значения пикселей заданного объекта BitmapData (так называемого изображения схемы искривления) для искривления замещения объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Смещает исходный объект, к которому применен фильтр.
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс DisplacementMapFilter использует значения пикселей заданного объекта BitmapData (так называемого <i>изображения схемы искривления</i>) для искривления замещения объекта. Этот фильтр можно использовать для применения эффекта деформации или крапинок к любому объекту, наследуемому от класса DisplayObject, например MovieClip, SimpleButton, TextField и Video, а также к объектам BitmapData.

<p>Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
<ul><li>Применить фильтры к экранному объекту можно с помощью свойства <codeph>filters</codeph> этого объекта. При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>

<li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта filter формируется изображение с применением фильтра.</li>
</ul>

<p>При применении фильтра к экранному объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>

<p>В фильтре используется следующая формула:</p>

<codeblock>
dstPixel[x, y] = srcPixel[x + ((componentX(x, y) - 128) ~~ scaleX) / 256, y + ((componentY(x, y) - 128) ~~scaleY) / 256)
</codeblock>

<p>где <codeph>componentX(x, y)</codeph> получает значение цвета свойства <codeph>componentX</codeph> от свойства <codeph>mapBitmap</codeph> при <codeph>(x – mapPoint.x ,y – mapPoint.y)</codeph>.</p>

<p>Изображение карты, используемое фильтром, масштабируется по размеру сцены. Оно не масштабируется при масштабировании самого объекта.</p>

<p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, общее масштабирование, повороты и искажение не поддерживаются. Если сам объект увеличен или уменьшен (т.е. если свойства <codeph>scaleX</codeph> и <codeph>scaleY</codeph> принимают значение, отличное от 1,0), фильтр не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>

 </apiDesc><example conref="examples\DisplacementMapFilterExample.as"> При выполнении кода, приведенного в примере ниже, будет нарисован квадрат с радиальной градиентной заливкой, создано текстовое поле, создан объект BitmapData, а к объекту DisplacementMapFilterExample будет применен фильтр смещения карты. Порядок выполнения кода таков:
 <ol>
  <li>Класс определяет переменные цвета фона, отметки текстового поля, размера и смещения, которые будут использоваться в различных функциях.</li>
  <li>Функция конструктора вызывает метод <codeph>draw()</codeph>, использующий класс Graphics для отрисовки квадрата с радиальной градиентной заливкой. Следует помнить, что <codeph>graphics</codeph> – это свойство объекта DisplacementMapFilterExample, являющегося расширением класса Sprite.</li>
  <li>Функция конструктора вызывает метод <codeph>createLabel()</codeph>, который создает текстовое поле со значением <codeph>labelText</codeph> и добавляет его к списку отображения.</li>
  <li>Функция конструктора вызывает метод <codeph>createFilter()</codeph>, который выполняет следующие действия:
      <ul>
          <li>Создает переменную с именем <codeph>filter</codeph> для объекта filter.</li>
          <li>Вызывает метод <codeph>getDisplacementMapFilter()</codeph> и назначает возвращаемое им значение переменной <codeph>filter</codeph>.</li>
          <li>Передает <codeph>filter</codeph> свойству <codeph>filters</codeph> объекта DisplacementFilterExample (основной класс).</li>
      </ul>
   </li> 
  <li>Метод <codeph>getBitmapFilter()</codeph> создает объект BitmapData с именем <codeph>mapBitmap</codeph> и назначает его результатам метода <codeph>createBitmapData()</codeph>. Объект <codeph>mapBitmap</codeph>, как и другие переменные, определяет новый фильтр смещения изображения карты.</li>
  <li>Метод <codeph>createBitmapData()</codeph> создает новый объект BitmapData, основанный на текущем содержимом объекта DisplacementMapFilterExample. Он создает новое растровое изображение на основе <codeph>bitmapData</codeph> и добавляет его к сцене.</li>
 </ol>
<codeblock>
package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.BitmapDataChannel;
    import flash.display.GradientType;
    import flash.display.SpreadMethod;
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.DisplacementMapFilter;
    import flash.filters.DisplacementMapFilterMode;
    import flash.geom.Matrix;
    import flash.geom.Point;
    import flash.text.TextField;
    
    public class DisplacementMapFilterExample extends Sprite {
        private var bgColor:uint     = 0xFFCC00;
        private var size:uint        = 200;
        private var offset:uint      = 90;
        private var labelText:String = "Watch the text bend with the displacement map";

        public function DisplacementMapFilterExample() {
            draw();
            createLabel();
            createFilter();
        }

        private function createFilter():void {
            var filter:BitmapFilter = getBitmapFilter();
            filters = new Array(filter);
        }

        private function getBitmapFilter():BitmapFilter {
            var mapBitmap:BitmapData = createBitmapData();
            var mapPoint:Point       = new Point(0, 0);
            var channels:uint        = BitmapDataChannel.RED;
            var componentX:uint      = channels;
            var componentY:uint      = channels;
            var scaleX:Number        = 0.5;
            var scaleY:Number        = -30;
            var mode:String          = DisplacementMapFilterMode.CLAMP;
            var color:uint           = 0;
            var alpha:Number         = 0;
            return new DisplacementMapFilter(mapBitmap,
                                             mapPoint,
                                             componentX,
                                             componentY,
                                             scaleX,
                                             scaleY,
                                             mode,
                                             color,
                                             alpha);
        }

        private function draw():void {
            var matrix:Matrix = new Matrix();
            matrix.createGradientBox(size, size);
            graphics.beginGradientFill(GradientType.RADIAL,
                                       [0xFF0000, 0x0000FF],
                                       [100, 100],
                                       [55, 200],
                                       matrix,
                                       SpreadMethod.PAD);
            graphics.drawRect(0, 0, size, size);
        }

        private function createBitmapData():BitmapData {
            var bitmapData:BitmapData = new BitmapData(size, size, true, bgColor);
            bitmapData.draw(this, new Matrix());
            var bitmap:Bitmap = new Bitmap(bitmapData);
            bitmap.x = size;
            addChild(bitmap);
            return bitmapData;
        }

        private function createLabel():void {
            var tf:TextField = new TextField();
            tf.text = labelText;
            tf.y = offset;
            tf.width = size;
            addChild(tf);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DisplacementMapFilter:DisplacementMapFilter"><apiName>DisplacementMapFilter</apiName><shortdesc>
	Инициализирует экземпляр DisplacementMapFilter с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Constructor
	 
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>mapBitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект BitmapData, содержащий данные карты замещения.
	</apiDesc></apiParam><apiParam><apiItemName>mapPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Значение, содержащее смещение левого верхнего угла целевого экранного объекта из левого верхнего угла изображения карты.
	</apiDesc></apiParam><apiParam><apiItemName>componentX</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Указывает цветовой канал, который следует использовать в изображении карты для замещения результата <i>x</i>. Возможными значениями являются константы BitmapDataChannel: 
	</apiDesc></apiParam><apiParam><apiItemName>componentY</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Указывает цветовой канал, который следует использовать в изображении карты для замещения результата <i>y</i>. Возможными значениями являются константы BitmapDataChannel: 
	</apiDesc></apiParam><apiParam><apiItemName>scaleX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Множитель, с помощью которого масштабируется результат <i>x</i> замещения, полученного в ходе вычисления карты.
	</apiDesc></apiParam><apiParam><apiItemName>scaleY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Множитель, с помощью которого масштабируется результат <i>y</i> замещения, полученного в ходе вычисления карты.
	</apiDesc></apiParam><apiParam><apiItemName>mode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>wrap</apiData><apiDesc>Режим фильтра. Возможными значениями являются константы DisplacementMapFilterMode:
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Задает цвет, используемый при смещениях, выходящих за пределы границ. Допустимый диапазон смещений – от 0,0 до 1,0. Этот параметр используется, если для <codeph>mode</codeph> установлено значение <codeph>DisplacementMapFilterMode.COLOR</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Задает альфа-значение, используемое при смещениях, выходящих за пределы границ. Указывается в виде нормализованного значения от 0,0 до 1,0. Например, при 0,25 устанавливается 25-процентная прозрачность. Этот параметр используется, если для <codeph>mode</codeph> установлено значение <codeph>DisplacementMapFilterMode.COLOR</codeph>.
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Инициализирует экземпляр DisplacementMapFilter.
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Инициализирует экземпляр DisplacementMapFilter с заданными параметрами.
	
   	</apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DisplacementMapFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>DisplacementMapFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>DisplacementMapFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> mode: wrap
		// >> scaleY: 10
		// >> scaleX: 10
		// >> componentY: 1
		// >> componentX: 1
		// >> mapPoint: (-30, -30)
		// >> mapBitmap: [object Object]
	}		
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>mode</code> property of <code>filter_1</code>.  Modifying <code>mode</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial", true);
	
	var filter_1:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	var filter_2:DisplacementMapFilter = filter_1;
	var clonedFilter:DisplacementMapFilter = filter_1.clone();
	
	trace(filter_1.mode);			// wrap
	trace(filter_2.mode);			// wrap
	trace(clonedFilter.mode);		// wrap
		
	filter_1.mode = "ignore";
	
	trace(filter_1.mode);			// ignore
	trace(filter_2.mode);			// ignore
	trace(clonedFilter.mode);		// wrap
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр DisplacementMapFilter с теми же свойствами, что и оригинальный экземпляр.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DisplacementMapFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Задает значение альфа-прозрачности, применяемое для замещения «вне пределов».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>alpha</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Задает значение альфа-прозрачности, применяемое для замещения «вне пределов». Указывается в виде нормализованного значения от 0,0 до 1,0. Например, при 0,25 устанавливается 25-процентная прозрачность. Значением по умолчанию является 0. Это свойство используется, если свойство <codeph>mode</codeph> принимает значение <codeph>DisplacementMapFilterMode.COLOR</codeph>.  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:color:get"><apiName>color</apiName><shortdesc>
	Задает цвет, используемый при смещениях, выходящих за пределы границ.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example modifies the out of range 
	<code>color</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>0x00FF00</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "color";
		filter.alpha = .25;
		filter.color = 0x00FF00;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Задает цвет, используемый при смещениях, выходящих за пределы границ. Допустимый диапазон смещений – от 0,0 до 1,0. Значения приводятся в шестнадцатеричном формате. Значение <codeph>color</codeph> по умолчанию равно 0. Это свойство используется, если свойство <codeph>mode</codeph> принимает значение <codeph>DisplacementMapFilterMode.COLOR</codeph>. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentX:get"><apiName>componentX</apiName><shortdesc>
	Указывает цветовой канал, который следует использовать в изображении карты для замещения результата x.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.  It changes the value from 1 to 4 which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentX = 4;
		this.filters = new Array(filter);
	}
	
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>Цветовой канал, используемый для смещения результата x.
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Указывает цветовой канал, который следует использовать в изображении карты для замещения результата <i>x</i>. Возможные значения являются константами BitmapDataChannel:
	<ul>
		<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	<li><codeph>BitmapDataChannel.BLUE</codeph></li>
	<li><codeph>BitmapDataChannel.GREEN</codeph></li>
	<li><codeph>BitmapDataChannel.RED</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:componentY:get"><apiName>componentY</apiName><shortdesc>
	 Указывает цветовой канал, который следует использовать в изображении карты для замещения результата у.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example changes the <code>componentY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks it.  The value changes from 1 to 4, which changes the 
	color channel from red to blue.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.componentY = 4;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает цветовой канал, который следует использовать в изображении схемы для замещения результата <i>y</i>. Возможные значения являются константами BitmapDataChannel:
	 <ul>
	 	<li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
         </ul>
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapDataChannel"><linktext>flash.display.BitmapDataChannel</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapBitmap:get"><apiName>mapBitmap</apiName><shortdesc>
	Объект BitmapData, содержащий данные карты замещения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapBitmap</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	var scope:Object = this;
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapBitmap = scope.createGradientBitmap(300, 80, 0xFF000000, "linear");
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	
	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier><apiException><apiDesc>BitmapData при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Объект BitmapData, содержащий данные карты замещения.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mapPoint:get"><apiName>mapPoint</apiName><shortdesc>
	Значение, содержащее смещение левого верхнего угла целевого экранного объекта из левого верхнего угла изображения схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>mapPoint</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.mapPoint = new Point(-30, -40);
		this.filters = new Array(filter);
		this._x = 30;
		this._y = 40;
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>Точка при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Значение, содержащее смещение левого верхнего угла целевого экранного объекта из левого верхнего угла изображения схемы.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Point"><linktext>flash.geom.Point</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:mode:get"><apiName>mode</apiName><shortdesc>
	Режим для фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example modifies <code>scaleY</code> inorder to create a displacement
	value that is out of range and then changes the <code>mode</code> property on the existing MovieClip 
	<code>filteredMc</code> to <code>ignore</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 25;
		filter.mode = "ignore";
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	</oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Строка при назначении принимает значение null.
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Строка режима не относится к допустимым типам.
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Режим для фильтра. Возможные значения являются константами DisplacementMapFilterMode:
	<ul>
	<li><codeph>DisplacementMapFilterMode.WRAP</codeph> – переносит значение замещения на другую сторону исходного изображения.</li>
	<li><codeph>DisplacementMapFilterMode.CLAMP</codeph> – фиксирует значение замещения по краю исходного изображения.</li>
	<li><codeph>DisplacementMapFilterMode.IGNORE</codeph> – если значение замещения находится вне диапазона, игнорирует замещение и использует исходный пиксель.</li>
	<li><codeph>DisplacementMapFilterMode.COLOR</codeph> – если значение замещения находится вне изображения, заменяет значения свойств <codeph>color</codeph> и <codeph>alpha</codeph>.</li>
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilterMode"><linktext>flash.filters.DisplacementMapFilterMode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleX:get"><apiName>scaleX</apiName><shortdesc>
	Множитель, с помощью которого масштабируется результат x замещения, полученного в ходе вычисления схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleX</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
	
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleX = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Множитель, с помощью которого масштабируется результат замещения <i>x</i>, полученного в ходе вычисления схемы.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DisplacementMapFilter:scaleY:get"><apiName>scaleY</apiName><shortdesc>
	Множитель, с помощью которого масштабируется результат у замещения, полученного в ходе вычисления схемы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>scaleY</code> property on the existing MovieClip 
	<code>filteredMc</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DisplacementMapFilter;
	import flash.display.BitmapData;
	import flash.geom.Point;
	import flash.geom.Matrix;
	import flash.geom.ColorTransform;
	
	var filteredMc:MovieClip = createDisplacementMapRectangle();
		
	filteredMc.onPress = function() {
		var filter:DisplacementMapFilter = this.filters[0];
		filter.scaleY = 5;
		this.filters = new Array(filter);
	}
	
	function createDisplacementMapRectangle():MovieClip {
		var mapBitmap:BitmapData = createGradientBitmap(300, 80, 0xFF000000, "radial");
		var filter:DisplacementMapFilter = new DisplacementMapFilter(mapBitmap, new Point(-30, -30), 1, 1, 10, 10, "wrap", 0x000000, 0x000000);
	
   		var txtBlock:MovieClip = createTextBlock();
   		txtBlock._x = 30;
   		txtBlock._y = 30;
   		
 		txtBlock.filters = new Array(filter);
	
   		return txtBlock;
	}
	
	function createGradientBitmap(w:Number, h:Number, bgColor:Number, type:String, hide:Boolean):BitmapData {
		var mc:MovieClip = this.createEmptyMovieClip("mc", 1);
		var matrix:Matrix = new Matrix();
		matrix.createGradientBox(w, h, 0, 0, 0);
	
		mc.beginGradientFill(type, [0xFF0000, 0x0000FF], [100, 100], [0x55, 0x99], matrix, "pad");		
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc.endFill();
		(hide == true) ? mc._alpha = 0 : mc._alpha = 100;
		
		var bmp:BitmapData = new BitmapData(w, h, true, bgColor);
	 	bmp.draw(mc, new Matrix(), new ColorTransform(), "normal", bmp.rectangle, true);
		mc.attachBitmap(bmp, this.getNextHighestDepth());
	 
		return bmp;
	}
	
	function createTextBlock():MovieClip {
   		var txtBlock:MovieClip = this.createEmptyMovieClip("txtBlock", this.getNextHighestDepth());
   		txtBlock.createTextField("txt", this.getNextHighestDepth(), 0, 0, 300, 80);
   		txtBlock.txt.text = "watch the text bend with the displacement map";
   		return txtBlock;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Множитель, с помощью которого масштабируется результат <i>y</i> замещения, полученного в ходе вычисления схемы.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterType"><apiName>BitmapFilterType</apiName><shortdesc>
Класс BitmapFilterType содержит значения, позволяющие задавать тип объекта BitmapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс BitmapFilterType содержит значения, позволяющие задавать тип объекта BitmapFilter.

</apiDesc><example conref="examples\BitmapFilterTypeExample.as"> При выполнении приведенного ниже кода будет нарисован серый квадрат, а к нему будет применен объект BevelFilter. Приведенный код задает свойство <codeph>type</codeph> с помощью константы <codeph>BitmapFilterQuality.HIGH</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterTypeExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterTypeExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterType:FULL"><apiName>FULL</apiName><shortdesc>
	Определяет параметр, применяющий фильтр ко всей области объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Определяет параметр, применяющий фильтр ко всей области объекта.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:INNER"><apiName>INNER</apiName><shortdesc>
	Определяет параметр, применяющий фильтр к внутренней области объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>inner</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Определяет параметр, применяющий фильтр к внутренней области объекта.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterType:OUTER"><apiName>OUTER</apiName><shortdesc>
	Определяет параметр, применяющий фильтр к внешней области объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>outer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Определяет параметр, применяющий фильтр к внешней области объекта.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
Класс DropShadowFilter позволяет добавить эффект падающей тени к экранным объектам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс DropShadowFilter позволяет добавить эффект падающей тени к экранным объектам. Алгоритм теней основан на том же блоковом фильтре, который используется в фильтре размытия. При формировании отбрасываемой тени существует несколько вариантов выбора ее стиля, включая внешнюю или внутреннюю тень и режим выбивки. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.

<p>Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
 <ul><li>Применить фильтры к визуализируемым объектам можно с помощью свойства <codeph>filters</codeph> (наследуемого от DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>
 
 <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
 </ul>

<p>При применении фильтра к экранному объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>
 <p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, он не поддерживает общее масштабирование, повороты и искажение. Если сам объект увеличен или уменьшен (т.е. если свойства <codeph>scaleX</codeph> и <codeph>scaleY</codeph> принимают значение, отличное от 1,0), фильтр не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>
 
 <p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>

</apiDesc><example conref="examples\DropShadowFilterExample.as"> Код, представленный в следующем примере, рисует желтый квадрат и применяет к нему эффект отбрасываемой тени. В общих чертах последовательность действий в этом примере такова:
 <ol>
  <li>Задаются три свойства, которые используются для отрисовки квадрата, к которому применяется фильтр.</li>
  <li>Создается функция конструктора. Конструктор вызывает метод <codeph>draw()</codeph>, использующий методы класса Graphics, полученные через свойство <codeph>graphics</codeph> спрайта для рисования оранжевого квадрата.</li>
  <li>В конструкторе задается переменная <codeph>filter</codeph> в виде объекта BitmapFilter и назначается возвращаемому значению вызова метода <codeph>getBitmapFilter()</codeph>. Метод <codeph>getBitmapFilter()</codeph> определяет используемый фильтр теней.</li>
  <li>Создается новый объект массива <codeph>myFilters</codeph>, и к массиву добавляется фильтр <codeph>filter</codeph>. Массив <codeph>myFilters</codeph> назначается свойству <codeph>filters</codeph>объекта DropShadowFilterExample. В результате применяются все фильтры, обнаруженные в <codeph>myFilters</codeph>. В нашем случае это только один фильтр <codeph>filter</codeph>.</li>
  </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.DropShadowFilter;

    public class DropShadowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function DropShadowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x000000;
            var angle:Number = 45;
            var alpha:Number = 0.8;
            var blurX:Number = 8;
            var blurY:Number = 8;
            var distance:Number = 15;
            var strength:Number = 0.65;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;
            return new DropShadowFilter(distance,
                                        angle,
                                        color,
                                        alpha,
                                        blurX,
                                        blurY,
                                        strength,
                                        quality,
                                        inner,
                                        knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:DropShadowFilter:DropShadowFilter"><apiName>DropShadowFilter</apiName><shortdesc>
	Инициализирует новый экземпляр DropShadowFilter с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new DropShadowFilter object
	with the default values:
	<pre>
	myFilter = new flash.filters.DropShadowFilter()
	</pre>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Расстояние смещения для тени (в пикселях). 
	
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Угол падения тени, от 0 до 360 (плавающая точка). 
	
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Цвет тени в шестнадцатеричном формате <i>0xRRGGBB</i>. Значением по умолчанию является 0x000000.
	
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Значение альфа-прозрачности для цвета тени. Действительны значения от 0.0 до 1.0. Например, при 0,25 устанавливается 25-процентная прозрачность. 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по горизонтали. Действительны значения от 0 до 255.0 (плавающая точка). 
	
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по вертикали. Действительны значения от 0 до 255.0 (плавающая точка). 
	
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между тенью и фоном. Действительны значения от 0 до 255.0. 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Заданное число применений фильтра. Используйте константы BitmapFilterQuality:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Дополнительные сведения об этих значениях см. в описании свойства <codeph>quality</codeph>.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли тень внутренней тенью. Значение <codeph>true</codeph> задает внутреннюю тень. Значение <codeph>false</codeph> задает внешнюю тень (тень вокруг внешнего контура объекта).
	
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Применяет эффект выбивки (<codeph>true</codeph>), который фактически делает заливку объекта прозрачной и выявляет цвет фона документа. 
	
	</apiDesc></apiParam><apiParam><apiItemName>hideObject</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли объект скрытым. Значение <codeph>true</codeph> указывает на то, что сам объект не нарисован, видна только его день. 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Инициализирует новый экземпляр DropShadowFilter с заданными параметрами.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:DropShadowFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three DropShadowFilter objects and compares them.  <code>filter_1</code>
	is created using the DropShadowFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> hideObject: false
		// >> strength: 1
		// >> blurY: 16
		// >> blurX: 16
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 0
		// >> angle: 45
		// >> distance: 15
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	
	var filter_1:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
	var filter_2:DropShadowFilter = filter_1;
	var clonedFilter:DropShadowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр DropShadowFilter со всеми свойствами оригинального экземпляра DropShadowFilter.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:DropShadowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Значение альфа-прозрачности для цвета тени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAlpha");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Значение альфа-прозрачности для цвета тени. Действительны значения от 0,0 до 1,0. Например, при 0,25 устанавливается 25-процентная прозрачность. Значением по умолчанию является 1,0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Угол тени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowAngle");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.angle = 135;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Угол тени. Действительны значения от 0 до 360 градусов (плавающая точка). Значением по умолчанию является 45.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Степень размытия по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurX");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurX = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по горизонтали. Действительны значения от 0 до 255,0 (плавающая точка). Значением по умолчанию является 4,0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Степень размытия по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowBlurY");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.blurY = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по вертикали. Действительны значения от 0 до 255,0 (плавающая точка). Значением по умолчанию является 4,0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:color:get"><apiName>color</apiName><shortdesc>
	Цвет тени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowColor");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.color = 0xFF0000;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Цвет тени. Действительны значения в шестнадцатеричном формате <i>0xRRGGBB</i>. Значение по умолчанию равно 0x000000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Расстояние смещения для тени (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowDistance");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.distance = 40;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Расстояние смещения для тени (в пикселях). Значение по умолчанию – 4,0 (плавающая точка).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:hideObject:get"><apiName>hideObject</apiName><shortdesc>
	Определяет, является ли объект скрытым.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>hideObject</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowHideObject");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.hideObject = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, является ли объект скрытым. Значение <codeph>true</codeph> указывает на то, что сам объект не нарисован, видна только его день. Значение по умолчанию – <codeph>false</codeph> (объект отображается).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	Определяет, является ли тень внутренней тенью.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowInner");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, является ли тень внутренней тенью. Значение <codeph>true</codeph> указывает на наличие внутренней тени. Значение по умолчанию <codeph>false</codeph> задает внешнюю тень (тень вокруг внешнего контура объекта).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Применяет эффект выбивки (true), который фактически делает заливку объекта прозрачной и выявляет цвет фона документа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowKnockout");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Применяет эффект выбивки (<codeph>true</codeph>), который фактически делает заливку объекта прозрачной и выявляет цвет фона документа. Значение по умолчанию – <codeph>false</codeph> (без выбивки).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:DropShadowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	 Заданное число применений фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowQuality");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.quality = 0;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Заданное число применений фильтра. Значение по умолчанию – <codeph>BitmapFilterQuality.LOW</codeph>, что эквивалентно однократному применению фильтра. Значение <codeph>BitmapFilterQuality.MEDIUM</codeph> применяет фильтр дважды; значение <codeph>BitmapFilterQuality.HIGH</codeph> – трижды. Фильтры с более низкими значениями выполняются быстрее.
	 
	 <p>Для большинства приложений достаточно значений качества low (низкое), medium (среднее) или high (высокое). Хотя можно использовать дополнительные числовые значения до 15 для получения разнообразных эффектов, более высокие значения выполняются дольше. Вместо увеличения значения <codeph>quality</codeph> можно просто увеличить значения свойств <codeph>blurX</codeph> и <codeph>blurY</codeph>. Это даст похожий эффект, а выполнение будет происходить быстрее.</p>
         </apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:DropShadowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Степень вдавливания или нанесения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.DropShadowFilter;
	var mc:MovieClip = createDropShadowRectangle("DropShadowStrength");
	mc.onRelease = function() {
		var filter:DropShadowFilter = this.filters[0];
		filter.strength = .6;
		this.filters = new Array(filter);
	}
	
	function createDropShadowRectangle(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		art.beginFill(0x003366);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		art._x = 20;
		art._y = 20;
	
		var filter:DropShadowFilter = new DropShadowFilter(15, 45, 0x000000, .8, 16, 16, 1, 3, false, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		art.filters = filterArray;
		return art;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между тенью и фоном. Действительны значения от 0 до 255,0. По умолчанию – 1,0.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilterQuality"><apiName>BitmapFilterQuality</apiName><shortdesc>
Класс BitmapFilterQuality содержит значения, позволяющие задавать качество визуализации объекта BitmapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс BitmapFilterQuality содержит значения, позволяющие задавать качество визуализации объекта BitmapFilter.

</apiDesc><example conref="examples\BitmapFilterQualityExample.as"> При выполнении приведенного ниже кода будет нарисован серый квадрат, а к нему будет применен объект BevelFilter. Приведенный код задает свойство <codeph>quality</codeph> с помощью константы <codeph>BitmapFilterQuality.HIGH</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BitmapFilterQualityExample extends Sprite {
        private var bgColor:uint = 0x999999;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BitmapFilterQualityExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xCCCCCC;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x808080;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>BlurFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>GlowFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>DropShadowFilter</linktext></link><link href="flash.filters.xml#GradientBevelFilter"><linktext>GradientBevelFilter</linktext></link><link href="flash.filters.xml#GradientGlowFilter"><linktext>GradientGlowFilter</linktext></link></related-links><apiValue id="flash.filters:BitmapFilterQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
	Определяет параметр фильтра высокого качества.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Определяет параметр фильтра высокого качества.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:LOW"><apiName>LOW</apiName><shortdesc>
	Определяет параметр фильтра низкого качества.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Определяет параметр фильтра низкого качества. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BitmapFilterQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
	Определяет параметр фильтра среднего качества.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Определяет параметр фильтра среднего качества.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:DisplacementMapFilterMode"><apiName>DisplacementMapFilterMode</apiName><shortdesc>
Класс DisplacementMapFilterMode передает значения для свойства mode класса DisplacementMapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс DisplacementMapFilterMode передает значения для свойства <codeph>mode</codeph> класса DisplacementMapFilter.

</apiDesc></apiClassifierDetail><apiValue id="flash.filters:DisplacementMapFilterMode:CLAMP"><apiName>CLAMP</apiName><shortdesc>
	Фиксирует значение замещения по краю исходного изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>clamp</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Фиксирует значение замещения по краю исходного изображения. Используется со свойством <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:COLOR"><apiName>COLOR</apiName><shortdesc>
	Если значение смещения находится вне изображения, заменяет значения свойств color и alpha.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>color</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Если значение смещения находится вне изображения, заменяет значения свойств <codeph>color</codeph> и <codeph>alpha</codeph>. Используется со свойством <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:IGNORE"><apiName>IGNORE</apiName><shortdesc>
	Если значение замещения находится вне диапазона, игнорирует замещение и использует исходный пиксель.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ignore</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Если значение замещения находится вне диапазона, игнорирует замещение и использует исходный пиксель. Используется со свойством <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue><apiValue id="flash.filters:DisplacementMapFilterMode:WRAP"><apiName>WRAP</apiName><shortdesc>
	Переносит значение замещения на другую сторону исходного изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>wrap</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Переносит значение замещения на другую сторону исходного изображения. Используется со свойством <codeph>DisplacementMapFilter.mode</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#DisplacementMapFilter/mode"><linktext>flash.filters.DisplacementMapFilter.mode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.filters:BevelFilter"><apiName>BevelFilter</apiName><shortdesc> 
 Класс BevelFilter позволяет добавлять эффект наклона в экранные объекты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Добавляет эффект наклона. 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Класс BevelFilter позволяет добавлять эффект наклона в экранные объекты. Эффект наклона позволяет сделать объекты, например кнопки, трехмерными. Вид наклона можно изменять с помощью различных цветов подсветок и теней, силы размытия на наклоне, угла и расположения наклона, а также эффекта выбивки. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.
 
 <p>Новый фильтр можно создать с помощью конструктора <codeph>new BevelFilter()</codeph>. Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
 <ul><li>Если фильтр применяется к фрагментам ролика, текстовым полям, кнопкам или видео, следует использовать свойство <codeph>filters</codeph> (наследуемое от класса DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>
 
 <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
 </ul>
 
 <p>При применении фильтра к экранному объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>
 
 <p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, он не поддерживает общее масштабирование, повороты и искажение. Если сам объект увеличен или уменьшен (т.е. если свойства <codeph>scaleX</codeph> и <codeph>scaleY</codeph> не равны 100%), фильтр не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>
 
 <p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>
 
 </apiDesc><example conref="examples\BevelFilterExample.as"> В результате выполнения приведенного ниже кода будет нарисован темно-желтый квадрат, к которому будет применен фильтр наклона с ярко-желтой подсветкой (0xFFFF00) и голубой тенью (0x0000FF). Порядок выполнения кода таков:
 <ol>
  <li>Импортируется требуемый класс.</li>   
  <li>Объявляются три свойства функции <codeph>draw()</codeph>, рисующей объект, к которому и применяется фильтр наклона.</li>
  <li>Создается функция конструктора <codeph>BevelFilterExample()</codeph>, которая выполняет следующее:
      <ul>
          <li>Вызывает функцию <codeph>draw()</codeph>, которая объявляется позднее.</li>
          <li>Объявляет переменную <codeph>filter</codeph> в виде объекта BitmapFilter и назначает ее возвращаемому значению вызова <codeph>getBitmapFilter()</codeph>.</li>
          <li>Создает новый массив <codeph>myFilters</codeph> и добавляет к массиву <codeph>filter</codeph>, а также назначает <codeph>myFilters</codeph> свойству <codeph>filters</codeph> объекта BevelFilterExample. В результате применяются все фильтры, обнаруженные в <codeph>myFilters</codeph>. В нашем случае это только один фильтр <codeph>filter</codeph>.</li>      
      </ul>
 </li>
  <li>Создайте функцию <codeph>getBitmapFilter</codeph> для создания фильтра и задания его свойств.</li>
  <li>Создайте функцию <codeph>draw()</codeph>. Эта функция использует методы класса Graphics, доступные через свойство <codeph>graphics</codeph> класса Sprite для рисования квадрата.</li>
  
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.BevelFilter;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;

    public class BevelFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var distance:Number       = 5;
            var angleInDegrees:Number = 45;
            var highlightColor:Number = 0xFFFF00;
            var highlightAlpha:Number = 0.8;
            var shadowColor:Number    = 0x0000FF;
            var shadowAlpha:Number    = 0.8;
            var blurX:Number          = 5;
            var blurY:Number          = 5;
            var strength:Number       = 5;
            var quality:Number        = BitmapFilterQuality.HIGH;
            var type:String           = BitmapFilterType.INNER;
            var knockout:Boolean      = false;

            return new BevelFilter(distance,
                                   angleInDegrees,
                                   highlightColor,
                                   highlightAlpha,
                                   shadowColor,
                                   shadowAlpha,
                                   blurX,
                                   blurY,
                                   strength,
                                   quality,
                                   type,
                                   knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BevelFilter:BevelFilter"><apiName>BevelFilter</apiName><shortdesc>
	Инициализирует новый экземпляр BevelFilter с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following code creates a new BevelFilter instance. The values given 
	are the default values; you could call the constructor without any values and get the same result.
	<listing> filter = new flash.filters.BevelFilter (4, 45, 0xFFFFFF, 1, 0x000000, 1, 4, 4, 1, 
	1, "inner", false) 
	</listing>
	The next example instantiates a new BevelFilter and applies it to the MovieClip <code>rect</code>.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var distance:Number = 5;
	var angleInDegrees:Number = 45;
	var highlightColor:uint = 0xFFFF00;
	var highlightAlpha:Number = .8;
	var shadowColor:uint = 0x0000FF;
	var shadowAlpha:Number = .8;
	var blurX:Number = 20;
	var blurY:Number = 20;
	var strength:Number = 1;
	var quality:int = 3;
	var type:String = "inner";
	var knockout:Boolean = false;
	
	var filter:BevelFilter = new BevelFilter(distance, angleInDegrees, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout);
	
	var rect:MovieClip = createRectangle(100, 100, 0x00CC00, "bevelFilterExample");
	rect.filters = new Array(filter);
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Расстояние смещения наклона в пикселях (плавающая точка). 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Угол скоса, от 0 до 360 градусов. 
	</apiDesc></apiParam><apiParam><apiItemName>highlightColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFF</apiData><apiDesc>Цвет подсветки скоса, <i>0xRRGGBB</i>. 
	</apiDesc></apiParam><apiParam><apiItemName>highlightAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Значение альфа-прозрачности цвета выделения. Действительны значения от 0.0 до 1.0. Например, при 0,25 устанавливается 25-процентная прозрачность. 
	</apiDesc></apiParam><apiParam><apiItemName>shadowColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0x000000</apiData><apiDesc>Цвет подсветки скоса, <i>0xRRGGBB</i>. 
	</apiDesc></apiParam><apiParam><apiItemName>shadowAlpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Значение альфа-прозрачности цвета тени. Действительны значения от 0.0 до 1.0. Например, при 0,25 устанавливается 25-процентная прозрачность. 
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по горизонтали в пикселях. Действительны значения от 0 до 255.0 (плавающая точка). 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по вертикали в пикселях. Действительны значения от 0 до 255.0 (плавающая точка).
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между наклоном и фоном. Действительны значения от 0 до 255.0. 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Качество наклона. Действительны значения от 0 до 15, но для большинства приложений можно использовать константы <codeph>BitmapFilterQuality</codeph>:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Фильтры с более низкими значениями выполняются быстрее. Для достижения нужных эффектов можно использовать и другие числовые значения.</p>

	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Тип скоса. Действительные значения констант <codeph>BitmapFilterType</codeph>: <codeph>BitmapFilterType.INNER</codeph>, <codeph>BitmapFilterType.OUTER</codeph> или <codeph>BitmapFilterType.FULL</codeph>. 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Применяет эффект выбивки (<codeph>true</codeph>), который фактически делает заливку объекта прозрачной и выявляет цвет фона документа.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Инициализирует новый экземпляр BevelFilter с заданными параметрами.
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#BitmapFilterType"><linktext>BitmapFilterType</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:BevelFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BevelFilter objects and compares them.  <code>filter_1</code>
	is created using the BevelFilter construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
	 	// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> type: inner
		// >> blurY: 20
		// >> blurX: 20
		// >> knockout: false
		// >> strength: 1
		// >> quality: 3
		// >> shadowAlpha: 0.8
		// >> shadowColor: 255
		// >> highlightAlpha: 0.8
		// >> highlightColor: 16776960
		// >> angle: 45
		// >> distance: 5
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var filter_1:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
	var filter_2:BevelFilter = filter_1;
	var clonedFilter:BevelFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр BevelFilter с теми же свойствами, что и оригинальный экземпляр BevelFilter.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Угол наклона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>angle</code> property on an existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.angle = 225;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Угол наклона. Действительны значения от 0 до 360°. Значением по умолчанию является 45°.
	
	<p>Значение угла представляет угол, под которым падает свет из предполагаемого источника, и определяет расположение эффекта относительно объекта. Если свойство <codeph>distance</codeph> имеет значение 0, эффект не смещается относительно объекта и, следовательно, свойство <codeph>angle</codeph> никак не влияет на результат.</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Интенсивность горизонтальной размывки (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurX");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurX = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Интенсивность горизонтальной размывки (в пикселях). Действительны значения от 0 до 255 (плавающая точка). Значением по умолчанию является 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Интенсивность вертикальной размывки (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelBlurY");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.blurY = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Интенсивность вертикальной размывки (в пикселях). Действительны значения от 0 до 255 (плавающая точка). Значением по умолчанию является 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Расстояние смещения наклона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>distance</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelDistance");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.distance = 3;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Расстояние смещения наклона. Действительные значения заданы в пикселях (плавающая точка). По умолчанию – 4.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightAlpha:get"><apiName>highlightAlpha</apiName><shortdesc>
	Значение альфа-прозрачности цвета выделения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Значение альфа-прозрачности цвета выделения. Значение указано в виде нормализованного значения от 0 до 1. Например, при 0,25 устанавливается 25-процентная прозрачность. Значением по умолчанию является 1.
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:highlightColor:get"><apiName>highlightColor</apiName><shortdesc>
	Цвет подсветки наклона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>highlightColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelHighlightColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.highlightColor = 0x0000FF;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Цвет подсветки наклона. Действительны значения в шестнадцатеричном формате, <i>0xRRGGBB</i>. Значение по умолчанию – 0xFFFFFF.
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
    Применяет эффект выбивки (true), который фактически делает заливку объекта прозрачной и выявляет цвет фона документа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelKnockout");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    Применяет эффект выбивки (<codeph>true</codeph>), который фактически делает заливку объекта прозрачной и выявляет цвет фона документа. Значение по умолчанию – <codeph>false</codeph> (без эффекта выбивки).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Заданное число применений фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelQuality");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Заданное число применений фильтра. Значение по умолчанию – <codeph>BitmapFilterQuality.LOW</codeph>, что эквивалентно однократному применению фильтра. Значение <codeph>BitmapFilterQuality.MEDIUM</codeph> применяет фильтр дважды; значение <codeph>BitmapFilterQuality.HIGH</codeph> – трижды. Фильтры с более низкими значениями выполняются быстрее.
	
	<p>Для большинства приложений достаточно значения <codeph>quality</codeph> на уровне «low» («низкое»), «medium» («среднее») или «high» («высокое»). Хотя можно использовать дополнительные числовые значения до 15 для получения разнообразных эффектов, более высокие значения выполняются дольше. Вместо увеличения значения <codeph>quality</codeph> можно просто увеличить значения свойств <codeph>blurX</codeph> и <codeph>blurY</codeph>. Это даст похожий эффект, а выполнение будет происходить быстрее.</p>
	
	<p>Можно использовать следующие константы <codeph>BitmapFilterQuality</codeph> для задания значений свойства <codeph>quality</codeph>:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	</p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowAlpha:get"><apiName>shadowAlpha</apiName><shortdesc>
	Значение альфа-прозрачности цвета тени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowAlpha</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowAlpha");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowAlpha = .2;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Значение альфа-прозрачности цвета тени. Данное значение указано в виде нормализованного значения от 0 до 1. Например, при 0,25 устанавливается 25-процентная прозрачность. По умолчанию – 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:shadowColor:get"><apiName>shadowColor</apiName><shortdesc>
	Цвет тени для наклона.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>shadowColor</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelShadowColor");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.shadowColor = 0xFFFF00;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Цвет тени для наклона. Действительны значения в шестнадцатеричном формате, <i>0xRRGGBB</i>. Значение по умолчанию – 0x000000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Степень вдавливания или нанесения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelStrength");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.strength = 10;
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень вдавливания или нанесения. Действительны значения от 0 до 255. Чем выше значение, тем более насыщен цвет фаски и тем сильнее контраст между наклоном и фоном. Значением по умолчанию является 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BevelFilter:type:get"><apiName>type</apiName><shortdesc>
	Расположение наклона на объекте.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>type</code> property on the existing MovieClip 
	<code>rect</code> when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BevelFilter;
	
	var rect:MovieClip = createBevelRectangle("BevelType");
	rect.onRelease = function() {
		var filter:BevelFilter = this.filters[0];
		filter.type = "outer";
		this.filters = new Array(filter);
	}
	
	function createBevelRectangle(name:String):MovieClip {
		var w:uint = 100;
		var h:uint = 100;
		var bgColor:uint = 0x00CC00;
	
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		rect.beginFill(bgColor);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BevelFilter = new BevelFilter(5, 45, 0xFFFF00, .8, 0x0000FF, .8, 20, 20, 1, 3, "inner", false);
		rect.filters = new Array(filter);
		return rect;
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Строка при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Расположение наклона на объекте. Внутренний и внешний наклоны применяются к внутренней и внешней сторонам, а полная фаска применяется ко всему объекту. Действительными значениями являются константы <codeph>BitmapFilterType</codeph>:
	
	<ul>
	<li><codeph>BitmapFilterType.INNER</codeph></li>
	<li><codeph>BitmapFilterType.OUTER</codeph></li>
	<li><codeph>BitmapFilterType.FULL</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:BitmapFilter"><apiName>BitmapFilter</apiName><shortdesc>
 Класс BitmapFilter является базовым классом для всех фильтров эффектов изображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Базовый класс для всех эффектов фильтра изображения.
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс BitmapFilter является базовым классом для всех фильтров эффектов изображения. 
 
 <p>Классы BevelFilter, BlurFilter, ColorMatrixFilter, ConvolutionFilter, DisplacementMapFilter, DropShadowFilter, GlowFilter, GradientBevelFilter и GradientGlowFilter являются расширениями класс BitmapFilter. Эти фильтры можно применять к любому экранному объекту.</p>
 
 <p>Класс BitmapFilter невозможно обрабатывать или расширять непосредственно.</p>
 
 </apiDesc><example conref="examples\BitmapFilterExample.as"> В следующем примере показано, как применить несколько фильтров к конкретному объекту DisplayObject и как отслеживать их с помощью свойства <codeph>filters</codeph>.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.filters.*;

    public class BitmapFilterExample extends Sprite {
        public function BitmapFilterExample() {
            trace(this.filters.length);             // 0

            var tmpFilters:Array = this.filters;
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.BEVEL_FILTER));
            tmpFilters.push(FilterFactory.createFilter(FilterFactory.GLOW_FILTER));
            this.filters = tmpFilters;

            trace(this.filters.length);             // 2
            trace(this.filters[0] is BitmapFilter); // true
            trace(this.filters[0] is BevelFilter);  // true
            trace(this.filters[1] is BitmapFilter); // true
            trace(this.filters[1] is GlowFilter);   // true
        }
    }
}

import flash.filters.*;
class FilterFactory {
    public static var BEVEL_FILTER:String = "BevelFilter";
    public static var BevelFilterConstructor:Class = BevelFilter;

    public static var BLUR_FILTER:String = "BlurFilter";
    public static var BlurFilterConstructor:Class = BlurFilter;

    public static var COLOR_MATRIX_FILTER:String = "ColorMatrixFilter";
    public static var ColorMatrixFilterConstructor:Class = ColorMatrixFilter;

    public static var CONVOLUTION_FILTER:String = "ConvolutionFilter";
    public static var ConvolutionFilterConstructor:Class = ConvolutionFilter;

    public static var DISPLACEMENT_MAP_FILTER:String = "DisplacementMapFilter";
    public static var DisplacementMapFilterConstructor:Class = DisplacementMapFilter;

    public static var DROP_SHADOW_FILTER:String = "DropShadowFilter";
    public static var DropShadowFilterConstructor:Class = DropShadowFilter;

    public static var GLOW_FILTER:String = "GlowFilter";
    public static var GlowFilterConstructor:Class = GlowFilter;

    public static var GRADIENT_BEVEL_FILTER:String = "GradientBevelFilter";
    public static var GradientBevelFilterConstructor:Class = GradientBevelFilter;

    public static var GRADIENT_GLOW_FILTER:String = "GradientGlowFilter";
    public static var GradientGlowFilterConstructor:Class = GradientGlowFilter;

    public static function createFilter(type:String):BitmapFilter {
        return new FilterFactory[type + "Constructor"]();   
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.filters:BitmapFilter:clone"><apiName>clone</apiName><shortdesc>
	 Возвращает объект BitmapFilter, являющийся точной копией исходного объекта BitmapFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект BitmapFilter.
	 
	 </apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Копия объекта BitmapFilter.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает объект BitmapFilter, являющийся точной копией исходного объекта BitmapFilter.
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.filters:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
 Класс BlurFilter позволяет применять визуальный эффект размывки к экранным объектам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Эффект размытия.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс BlurFilter позволяет применять визуальный эффект размывки к экранным объектам. Эффект размытия смягчает детали изображения. Можно создавать различные размытия: от мягкого и расфокусированного до размытия по Гауссу – дымчатого изображения, которое зритель видит будто бы через полупрозрачное стекло. При значении low свойства <codeph>quality</codeph> этого фильтра результатом будет слегка расфокусированное изображение. Если же свойству <codeph>quality</codeph> присвоено значение high, то изображение будет ближе к размытию по Гауссу. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.
 
 <p>Новый фильтр можно создать с помощью конструктора <codeph>new BlurFilter()</codeph>. Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
 <ul><li>Если фильтр применяется к фрагментам ролика, текстовым полям, кнопкам или видео, следует использовать свойство <codeph>filters</codeph> (наследуемое от класса DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>
 
 <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
 </ul>
 
 <p>При применении фильтра к визуализируемому объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>
 
 <p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, он не поддерживает общее масштабирование, повороты и искажение. Если сам объект увеличен или уменьшен (т.е. если свойства <codeph>scaleX</codeph> и <codeph>scaleY</codeph> не равны 100%), эффект фильтр не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>
 
 <p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>
 
 </apiDesc><example conref="examples\BlurFilterExample.as"> Код, представленный в следующем примере, рисует темно-желтый квадрат и применяет к нему фильтр размытия по Гауссу. Порядок выполнения кода таков:
 <ol>
  <li>Импортируется требуемый класс.</li>   
  <li>Объявляются три свойства функции <codeph>draw()</codeph>, рисующей объект, к которому и применяется фильтр «Размытие». </li>
  <li>Создается функция конструктора <codeph>BlurFilterExample()</codeph>, которая выполняет следующее:
      <ul>
          <li>Вызывает функцию <codeph>draw()</codeph>, которая объявляется позднее.</li>
          <li>Объявляет переменную <codeph>filter</codeph> в виде объекта BitmapFilter и назначает ее возвращаемому значению вызова <codeph>getBitmapFilter()</codeph>.</li>
          <li>Создает новый массив <codeph>myFilters</codeph> и добавляет к массиву <codeph>filter</codeph>, а также назначает <codeph>myFilters</codeph> свойству <codeph>filters</codeph> объекта BlurFilterExample. В результате применяются все фильтры, обнаруженные в <codeph>myFilters</codeph>. В нашем случае это только один фильтр <codeph>filter</codeph>.</li>
      </ul>
  </li>
  <li>Создайте функцию <codeph>getBitmapFilter</codeph> для создания фильтра и задания его свойств.</li>
  <li>Создайте функцию <codeph>draw()</codeph>. Эта функция использует методы класса Graphics, доступные через свойство <codeph>graphics</codeph> класса Sprite для рисования квадрата.</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BlurFilter;

    public class BlurFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function BlurFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var blurX:Number = 30;
            var blurY:Number = 30;
            return new BlurFilter(blurX, blurY, BitmapFilterQuality.HIGH);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link></related-links><apiConstructor id="flash.filters:BlurFilter:BlurFilter"><apiName>BlurFilter</apiName><shortdesc>
	Инициализирует фильтр с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Instantiate a new <code>BlurFilter</code> and apply it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "BlurFilterExample");
	
	var blurX:Number = 30;
	var blurY:Number = 30;
	var quality:Number = 3;
	
	var filter:BlurFilter = new BlurFilter(blurX, blurY, quality);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Величина размытия по горизонтали. Действительны значения от 0 до 255,0 (значение с плавающей точкой). 
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Величина размытия по вертикали. Действительны значения от 0 до 255,0 (значение с плавающей точкой). 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Заданное число применений фильтра. Можно задать качество с помощью констант BitmapFilterQuality:
	<ul>
	<li><codeph>flash.filters.BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>flash.filters.BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>При высоком качестве (high) изображение похоже на размытие по Гауссу. Для большинства приложений этих значений достаточно. Хотя можно использовать дополнительные числовые значения до 15 для получения разнообразных эффектов, более высокие значения выполняются дольше.</p>
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>Инициализирует фильтр.
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	Инициализирует фильтр с заданными параметрами. Значения по умолчанию дают мягкое, расфокусированное изображение.
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:BlurFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three BlurFilter objects and compares them.  <code>filter_1</code>
	is created using the BlurFilter constructor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> quality: 2
		// >> blurY: 30
		// >> blurX: 30
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>quality</code> property of <code>filter_1</code>.  Modifying <code>quality</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	
	var filter_1:BlurFilter = new BlurFilter(30, 30, 2);
	var filter_2:BlurFilter = filter_1;
	var clonedFilter:BlurFilter = filter_1.clone();
	
	trace(filter_1.quality);			// 2
	trace(filter_2.quality);			// 2
	trace(clonedFilter.quality);		// 2
	
	filter_1.quality = 1;
	
	trace(filter_1.quality);			// 1
	trace(filter_2.quality);			// 1
	trace(clonedFilter.quality);		// 2
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр BlurFilter с теми же свойствами, что и оригинальный экземпляр BlurFilter.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:BlurFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Степень размытия по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurX");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurX = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по горизонтали. Действительны значения от 0 до 255 (плавающая точка). Значением по умолчанию является 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Степень размытия по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterBlurY");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.blurY = 200;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по вертикали. Действительны значения от 0 до 255 (плавающая точка). Значением по умолчанию является 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:BlurFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Число применений эффекта размытия.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing MovieClip 
	when a user clicks on it.
	<listing version="2.0">
	import flash.filters.BlurFilter;
	var mc:MovieClip = createBlurFilterRectangle("BlurFilterQuality");
	mc.onRelease = function() {
		var filter:BlurFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createBlurFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:BlurFilter = new BlurFilter(30, 30, 2);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Число применений эффекта размытия. Значение по умолчанию – <codeph>BitmapFilterQuality.LOW</codeph>, что эквивалентно однократному применению фильтра. Значение <codeph>BitmapFilterQuality.MEDIUM</codeph> применяет фильтр дважды; значение <codeph>BitmapFilterQuality.HIGH</codeph> – трижды для получения размытия по Гауссу. Фильтры с более низкими значениями выполняются быстрее.
	
	<p>Для большинства приложений достаточно значения <codeph>quality</codeph> на уровне «low» («низкое»), «medium» («среднее») или «high» («высокое»). Хотя можно использовать дополнительные числовые значения до 15 для увеличения числа раз применения эффекта размытия, более высокие значения выполняются дольше. Вместо увеличения значения <codeph>quality</codeph> можно просто увеличить значения свойств <codeph>blurX</codeph> и <codeph>blurY</codeph>. Это даст похожий эффект, а выполнение будет происходить быстрее.</p>
	
	<p>Можно использовать следующие константы BitmapFilterQuality для задания свойства <codeph>quality</codeph>:</p>
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
Класс ConvolutionFilter применяет эффект фильтра матричного свертывания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Do we allow anything other than 3x3 matrix convolution? Are default x y values correct?

</internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Применяет фильтр матричного свертывания.

</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс ConvolutionFilter применяет эффект фильтра матричного свертывания. Свертывание объединяет пиксели во входном изображении с соседними пикселями для создания изображения. С помощью свертывания можно выполнять множество различных операций по обработке изображений, включая размытие, определение краев, регулировку резкости, тиснение и наклон. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.

<p>Создать фильтр «Свертывание» можно с помощью синтаксиса <codeph>new ConvolutionFilter()</codeph>. Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
<ul><li>Если фильтр применяется к фрагментам ролика, текстовым полям, кнопкам или видео, следует использовать свойство <codeph>filters</codeph> (наследуемое от класса DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>

<li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
</ul>

<p>При применении фильтра к экранному объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>

<p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>

</apiDesc><example conref="examples\ConvolutionFilterExample.as"> В следующем примере показано, как различные фильтры свертывания применяются к файлу изображения. Конструктор фильтров четыре раза вызывает <codeph>buildChild()</codeph> для загрузки и отображения четырех экземпляров изображения. Каждый вызов <codeph>buildChild()</codeph> использует в качестве аргумента функцию, которая не применяет фильтры к первому экземпляру, но применяет разные фильтры свертывания к каждому последующему экземпляру.
 <p>Функция <codeph>buildChild()</codeph> создает новый объект Loader и присваивает ему имя <codeph>loader</codeph>. При каждом вызове <codeph>buildChild()</codeph> нужно назначать объекту Loader прослушиватель событий, который будет регистрировать события <codeph>complete</codeph>, обрабатываемые функцией, которая передается к <codeph>buildChild()</codeph>.</p>
 
 <p>Функции <codeph>applyBrightness()</codeph>, <codeph>applySharpness()</codeph> и <codeph>applyOutline()</codeph> применяют к массиву <codeph>matrix</codeph> разные значения для получения различных эффектов ConvolutionFilter.</p>
 <p><b>Примечание</b>. Для оптимального результата рекомендуется использовать изображения шириной около 80 пикселей. Имя и расположение файла с изображением должны совпадать со значением, которое передается свойству <codeph>url</codeph>. Например, значение, передаваемое свойству <codeph>url</codeph> в данном примере, указывает на файл с именем «Image.jpg», который хранится в том же каталоге, что и SWF-файл.
 </p>
 
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.filters.BitmapFilter;
    import flash.filters.ConvolutionFilter;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ConvolutionFilterExample extends Sprite {
        private var size:uint = 140;
        private var url:String = "Image.jpg";

        public function ConvolutionFilterExample() {
            buildChild(applyNothing);
            buildChild(applyBrightness);
            buildChild(applySharpness);
            buildChild(applyOutline);
        }

        private function buildChild(loadHandler:Function):void {
            var loader:Loader = new Loader();
            loader.x = numChildren * size;
            loader.y = size;
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            if(loadHandler != null) {
                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loadHandler);
            }

            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function applyNothing(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            applyLabel(child, "no filter");
        }

        private function applyBrightness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [5, 5, 5,
                                5, 0, 5,
                                5, 5, 5];
            applyFilter(child, matrix);
            applyLabel(child, "brightness");
        }

        private function applySharpness(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [0, -1, 0,
                               -1, 20, -1,
                                0, -1, 0];
            applyFilter(child, matrix);
            applyLabel(child, "sharpness");
        }

        private function applyOutline(event:Event):void {
            var child:DisplayObject = DisplayObject(event.target.loader);
            var matrix:Array = [-30, 30, 0,
                                -30, 30, 0,
                                -30, 30, 0];
            applyFilter(child, matrix);
            applyLabel(child, "outline");
        }

        private function applyFilter(child:DisplayObject, matrix:Array):void {
            var matrixX:Number = 3;
            var matrixY:Number = 3;
            var divisor:Number = 9;
            var filter:BitmapFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
            var filters:Array = new Array();
            filters.push(filter);
            child.filters = filters;
        }

        private function applyLabel(child:DisplayObject, label:String):void {
            var tf:TextField = new TextField();
            tf.x = child.x;
            tf.y = child.height;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.text = label;
            addChild(tf);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.filters.xml#ConvolutionFilter/matrix"><linktext>матрица</linktext></link></related-links><apiConstructor id="flash.filters:ConvolutionFilter:ConvolutionFilter"><apiName>ConvolutionFilter</apiName><shortdesc>
	Инициализирует новый экземпляр ConvolutionFilter с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a ConvolutionFilter
	object with the four required parameters <code>matrixX</code>, <code>matrixY</code>, 
	<code>matrix</code>, and <code>divisor</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var matrixX:Number = 3;
	var matrixY:Number = 3;
	var matrix:Array = [1, 1, 1, 1, 1, 1, 1, 1, 1];
	var divisor:Number = 9;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(matrixX, matrixY, matrix, divisor);
	
   	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
   	
  	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
  	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
   	myBitmapData.noise(128);
   		
   	mc.onPress = function() {
   		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
   	}
	</listing>
	
	 
	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>matrixX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Размер <i>x</i> матрицы (число столбцов в матрице). По умолчанию используется значение 0.
	</apiDesc></apiParam><apiParam><apiItemName>matrixY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Размер <i>y</i> матрицы (число столбцов в матрице). По умолчанию используется значение 0.
	</apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений, используемых для матричных преобразований. Число элементов массива должно равняться <codeph>matrixX ~~ matrixY</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>divisor</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Делитель, используемый при проведении преобразования матрицы. По умолчанию используется значение 1. Делитель, являющийся суммой всех значений матрицы, выравнивает интенсивность цвета получаемого изображения. Значение 0 игнорируется, а вместо него используется значение по умолчанию. 
	</apiDesc></apiParam><apiParam><apiItemName>bias</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Степень смещения, добавляемого к результату преобразования матрицы. По умолчанию используется значение 0.
	</apiDesc></apiParam><apiParam><apiItemName>preserveAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Значение <codeph>false</codeph> указывает, что значение альфа-канала не сохранено и что свертывание применяется ко всем каналам, включая альфа-канал. Значение <codeph>true</codeph> указывает, что свертывание применяется только к цветовым каналам. Значение по умолчанию – <codeph>true</codeph>.
	</apiDesc></apiParam><apiParam><apiItemName>clamp</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Для пикселей, лежащих за пределами исходного изображения, значение <codeph>true</codeph> указывает на то, что входное изображение растянуто по каждой из границ методом дублирования значений цветов на данном крае входного изображения. Значение <codeph>false</codeph> указывает на то, что следует использовать другой цвет, согласно значениям свойств <codeph>color</codeph> и <codeph>alpha</codeph>. Значение по умолчанию — <codeph>true</codeph>. 
	</apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Шестнадцатеричный цвет для замены пикселей, отсутствующих в исходном изображении.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Значение альфа-канала для цвета замены.
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Инициализирует новый экземпляр ConvolutionFilter с заданными параметрами.
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.filters:ConvolutionFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three <code>ConvolutionFilter</code> objects and compares them.  <code>filter_1</code>
	is created using the <code>ConvolutionFilter</code> construtor.  <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>.  And, <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that while <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> alpha: 0
		// >> color: 0
		// >> clamp: true
		// >> preserveAlpha: true
		// >> bias: 0
		// >> divisor: 9
		// >> matrix: 0,1,0,1,4,1,0,1,0
		// >> matrixY: 3
		// >> matrixX: 3
	}		
	</listing>
	
	<p>To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>
	the example below modifies the <code>bias</code> property of <code>filter_1</code>.  Modifying <code>bias</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on values of the <code>filter_1</code> instead of pointing to 
	them in reference.</p>
	
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	
	var filter_1:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	var filter_2:ConvolutionFilter = filter_1;
	var clonedFilter:ConvolutionFilter = filter_1.clone();
	trace(filter_1.bias);			// 0
	trace(filter_2.bias);			// 0
	trace(clonedFilter.bias);		// 0
	
	filter_1.bias = 20;
	
	trace(filter_1.bias);			// 20
	trace(filter_2.bias);			// 20
	trace(clonedFilter.bias);		// 0
	</listing>
	
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр ConvolutionFilter с теми же свойствами, что и оригинальный экземпляр ConvolutionFilter.
	
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:ConvolutionFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Значение альфа-прозрачности цвета замены.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property of <code>filter</code>
	from its default value of <code>1</code> to <code>.35</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var alpha:Number = .35;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, 0x0000FF, alpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	 
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, 98, 78), new Point(2, 2), filter);
  	}
	</listing>	
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Значение альфа-прозрачности цвета замены. Действительны значения от 0 до 1,0. По умолчанию – 0. Например, при 0,25 устанавливается 25-процентная прозрачность.	  
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:bias:get"><apiName>bias</apiName><shortdesc>
	Степень смещения, добавляемого к результату преобразования матрицы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>bias</code> property of <code>filter</code>
	from its default value of 0 to 50.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var bias:Number = 50;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, bias);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	
  	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
 	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень смещения, добавляемого к результату преобразования матрицы. Смещение увеличивает значение цвета в каждом канале, так что темные цвета кажутся светлее. Значением по умолчанию является 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:clamp:get"><apiName>clamp</apiName><shortdesc>
	Определяет, зафиксировано ли изображение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, зафиксировано ли изображение. Для пикселей, лежащих за пределами исходного изображения, значение <codeph>true</codeph> указывает, что входное изображение растянуто по каждой из границ методом дублирования значений цветов на соответствующем крае входного изображения. Значение <codeph>false</codeph> указывает на то, что следует использовать другой цвет, согласно значениям свойств <codeph>color</codeph> и <codeph>alpha</codeph>. Значение по умолчанию – <codeph>true</codeph>.
	
	</apiDesc><example conref="ConvolutionClampExample.as"> В следующем примере показан код для создания двух блоков с помощью класса <codeph>BitmapData</codeph>, из которых один в два раза меньше другого. При первой загрузке примера больший блок рисуется внутри <codeph>mc</codeph> с помощью <codeph>attachBitmap()</codeph>. При щелчке по <codeph>mc</codeph> и вызове метода <codeph>applyFilter()</codeph> экземпляр <codeph>largeBox</codeph> класса <codeph>BitmapData</codeph> снова отрисовывается, а исходным растровым изображением при этом служит <codeph>smallBox</codeph>. Так как метод <codeph>applyFilter()</codeph> рисует <codeph>smallBox</codeph> поверх <codeph>прямоугольника</codeph>, ширина и высота которого задается по размеру <codeph>largeBox</codeph>, исходное растровое изображение меньше, чем область отрисовки. Свойство <codeph>clamp</codeph> объекта <codeph>ConvolutionFilter</codeph> в этом случае имеет значение <codeph>false</codeph>, а область, не покрытая исходным растровым изображением, <codeph>smallBox</codeph>, имеет сплошную красную заливку, определяемую переменными <codeph>clampColor</codeph> и <codeph>clampAlpha</codeph>.
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.filters.ConvolutionFilter;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.geom.Point;

    public class ConvolutionClampExample extends Sprite {
        // Variables that affect clamping:
        var clamp:Boolean = false;
        var clampColor:Number = 0xFF0000;
        var clampAlpha:Number = 1;
        
        // For illustration, keep other ConvolutionFilter variables neutral:
        var bias:Number = 0;
        var preserveAlpha:Boolean = false;
        // Also, construct a neutral matrix
        var matrixCols:Number = 3;
        var matrixRows:Number = 3;
        var matrix:Array = [ 1,1,1,
                             1,1,1,
                             1,1,1 ];
        
        var filter:ConvolutionFilter = new ConvolutionFilter(matrixCols, matrixRows, matrix, matrix.length, bias, preserveAlpha, clamp, clampColor, clampAlpha);
        
        var largeBoxWidth:Number = 100;
        var largeBoxHeight:Number = 100;
        var largeBox:BitmapData = new BitmapData(largeBoxWidth, largeBoxWidth, true, 0xCC00FF00);
        var smallBoxWidth:Number = largeBoxWidth / 2;
        var smallBoxHeight:Number = largeBoxHeight / 2;
        var smallBox:BitmapData = new BitmapData(smallBoxWidth, smallBoxWidth, true, 0xCC0000FF);
            
        var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
        mc.attachBitmap(largeBox, this.getNextHighestDepth());
        
        mc.onPress = function() {
            largeBox.applyFilter(smallBox,
                                 new Rectangle(0,0, largeBoxWidth, largeBoxHeight),
                                 new Point(0,0),
                                 filter);
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:color:get"><apiName>color</apiName><shortdesc>
	Шестнадцатеричный цвет для замены пикселей, отсутствующих в исходном изображении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property of <code>filter</code>
	from its default value of <code>0</code> to <code>0xFF0000</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
	import flash.geom.Rectangle;
	import flash.geom.Point;
	
	var color:Number = 0x0000FF;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, true, false, color, 1);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
		
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
  	  	
  	var height:Number = 100;
  	var width:Number = 80;
  	mc.onPress = function() {
  		height -= 2;
  		width -= 2;
		myBitmapData.applyFilter(myBitmapData, new Rectangle(0, 0, height, width), new Point(2, 2), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Шестнадцатеричный цвет для замены пикселей, отсутствующих в исходном изображении. Это значение в формате RGB без альфа-компонента. По умолчанию – 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:divisor:get"><apiName>divisor</apiName><shortdesc>
	Делитель, используемый при проведении преобразования матрицы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>divisor</code> property of <code>filter</code>
	to 6.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  	
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	 	
  	mc.onPress = function() {
  		var newDivisor:Number = 6;
  		filter.divisor = newDivisor;
  	 	myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Делитель, используемый при проведении преобразования матрицы. По умолчанию используется значение 1. Делитель, являющийся суммой всех значений матрицы, сглаживает интенсивность цвета получаемого изображения. Значение 0 игнорируется, а вместо него используется значение по умолчанию. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrix:get"><apiName>matrix</apiName><shortdesc>
	Массив значений, используемых для матричных преобразований.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>matrix</code> property of <code>filter</code>
	from one that blurs a bitmap to one that sharpens it.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9);
	
  	var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);
  		
 	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
 	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
  	myBitmapData.noise(128);
  	  	
  	mc.onPress = function() {
  		var newMatrix:Array = [0, -1, 0, -1, 8, -1, 0, -1, 0];
  		filter.matrix = newMatrix;
  		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
  	}
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Массив значений, используемых для матричных преобразований. Число элементов массива должно равняться <codeph>matrixX ~~ matrixY</codeph>.
	<p> Свертывание матрицы исходит из размерности матрицы <i>n</i> x <i>m</i>, в которой описано, как значение каждого пикселя входного изображения сочетается со значением соседнего пикселя и какое значение получается в результате. Каждый получаемый пиксель определяется применением матрицы к соответствующему исходному пикселю и соседним с ним пикселям.</p>
	
	<p> При свертывании матрицы 3 x 3 для каждого отдельного цветового канала используется следующая формула:
	<pre><codeph>
	dst (x, y) = ((src (x-1, y-1) ~~ a0 + src(x, y-1) ~~ a1....
	                  src(x, y+1) ~~ a7 + src (x+1,y+1) ~~ a8) / divisor) + bias
	</codeph></pre>
	</p>
	
	<p>Некоторые фильтры работают быстрее при использовании процессоров с аппаратным ускорением SSE (Streaming SIMD Extensions). Ниже приведены критерии для ускорения операций свертывания:</p>
	<ul>
	<li>Фильтр должен иметь размерность 3x3.</li>
	<li>Все элементы фильтра должны быть целыми в диапазоне от -127 до +127.</li>
	<li>Сумма всех элементов фильтра не должна превышать 127.</li> 
	<li>Если один из элементов фильтра отрицательный, делитель должен быть от 2,00001 до 256.</li>
	<li>Если все элементы положительные, делитель должен быть от 1,1 до 256.</li>
	<li>Смещение должно быть представлено целым числом.</li>
	</ul>
    <p><b>Примечание.</b> При создании фильтра свертывания с помощью конструктора без параметров порядок, в котором задаются значения для свойств матрицы, влияет на поведение фильтра. В следующем случае при назначении массива матрицы свойства <codeph>matrixX</codeph> и <codeph>matrixY</codeph> по-прежнему имеют значение <codeph>0</codeph> (значение по умолчанию):</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    </codeblock>
    <p>В следующем случае при назначении массива матрицы свойства <codeph>matrixX</codeph> и <codeph>matrixY</codeph> по-прежнему имеют значение <codeph>3</codeph>:</p>
    <codeblock>
    public var myfilter:ConvolutionFilter = new ConvolutionFilter();
    myfilter.matrixX = 3;
    myfilter.matrixY = 3;
    myfilter.matrix = [0, 0, 0, 0, 1, 0, 0, 0, 0];
    </codeblock>
    
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixX:get"><apiName>matrixX</apiName><shortdesc>
	Размер x матрицы (число столбцов в матрице).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixX</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
 	
 	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixX);	// 2
	</listing>

	 

	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Размер <i>x</i> матрицы (число столбцов в матрице). Значением по умолчанию является 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:matrixY:get"><apiName>matrixY</apiName><shortdesc>
	Измерение y матрицы (число столбцов в матрице).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example displays the <code>matrixY</code>
	property of <code>filter</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
		
	var filter:ConvolutionFilter = new ConvolutionFilter(2, 3, [1, 0, 0, 1, 0, 0], 6);
	trace(filter.matrixY);	// 3
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Размер <i>y</i> матрицы (число столбцов в матрице). Значением по умолчанию является 0.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ConvolutionFilter:preserveAlpha:get"><apiName>preserveAlpha</apiName><shortdesc>
	Определяет, сохраняется ли альфа-канал без эффекта фильтра, или фильтр свертывания применяется к альфа-каналу так же, как и к цветовым каналам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>preserveAlpha</code> property of <code>filter</code>
	from its default value of <code>true</code> to <code>false</code>.
	<listing version="2.0">
	import flash.filters.ConvolutionFilter;
	import flash.display.BitmapData;
		
	var preserveAlpha:Boolean = false;
	var filter:ConvolutionFilter = new ConvolutionFilter(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1], 9, 0, preserveAlpha);
	
	var myBitmapData:BitmapData = new BitmapData(100, 80, true, 0xCCFF0000);
	
	var mc:MovieClip = this.createEmptyMovieClip("mc", this.getNextHighestDepth());
	mc.attachBitmap(myBitmapData, this.getNextHighestDepth());
	myBitmapData.noise(128, 0, 255, 1 | 2 | 4 | 8, false);
	
	mc.onPress = function() {
		myBitmapData.applyFilter(myBitmapData, myBitmapData.rectangle, new Point(0, 0), filter);
	}
	</listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, сохраняется ли альфа-канал без эффекта фильтра, или фильтр свертывания применяется к альфа-каналу так же, как и к цветовым каналам. Значение <codeph>false</codeph> указывает, что свертывание применяется ко всем каналам, включая альфа-канал. Значение <codeph>true</codeph> указывает, что свертывание применяется только к цветовым каналам. По умолчанию используется значение <codeph>true</codeph>.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
Класс GradientBevelFilter позволяет применять эффект градиентного наклона к экранным объектам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Позволяет добавлять эффект «Градиентный наклон».
</apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс GradientBevelFilter позволяет применять эффект градиентного наклона к экранным объектам. Градиентный наклон представляет собой скошенный край с цветовым градиентом на внешней или внутренней стороне или поверх всего объекта. Скошенные края придают объектам эффект трехмерности. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.

 <p>Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
 <ul><li>Применить фильтр к экранным объектам можно с помощью свойства <codeph>filters</codeph>. При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>
 
 <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
 </ul>

<p>При применении фильтра к визуализируемому объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p> 

<p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, общее масштабирование, вращение и искажение не поддерживается. Если сам объект увеличен или уменьшен (т.е. если <codeph>scaleX</codeph> и <codeph>scaleY</codeph> имеют значение, отличное от 1,0), эффект фильтра не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>

<p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>

 </apiDesc><example conref="examples\GradientBevelFilterExample.as"> При выполнении кода, приведенного в примере ниже, будет нарисован квадрат, к которому будет применен фильтр градиентного наклона. В общих чертах последовательность действий в этом примере такова:
 <ol>
  <li>Импортируется требуемый класс.</li>
  <li>Объявляются глобальные переменные для определения квадрата и фильтра.</li>
  <li>Создается функция конструктора, которая выполняет следующее:
      <ul>
          <li>Вызывает метод <codeph>draw()</codeph>, который использует методы класса Graphics, доступные через свойство <codeph>graphics</codeph> спрайта для рисования серого квадрата.</li>
          <li>Создает новый объект BitmapFilter с именем <codeph>filter</codeph> и назначает ему возвращаемое значение вызова <codeph>getBitmapFilter()</codeph>, определяющего фильтр.</li>
          <li>Создает массив с именем <codeph>myFilters</codeph> и добавляет к нему <codeph>filter</codeph>.</li>
          <li>Назначает <codeph>myFilters</codeph> свойству <codeph>filters</codeph> объекта GradientBevelFilterExample. В результате применяются все фильтры, обнаруженные в <codeph>myFilters</codeph>. В нашем случае это только один фильтр <codeph>filter</codeph>.</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.BitmapFilterType;
    import flash.filters.GradientBevelFilter;

    public class GradientBevelFilterExample extends Sprite {
        private var bgColor:uint     = 0xCCCCCC;
        private var size:uint        = 80;
        private var offset:uint      = 50;
        private var distance:Number  = 5;
        private var angleInDegrees:Number = 225; // opposite 45 degrees
        private var colors:Array     = [0xFFFFFF, 0xCCCCCC, 0x000000];
        private var alphas:Array     = [1, 0, 1];
        private var ratios:Array     = [0, 128, 255];
        private var blurX:Number     = 8;
        private var blurY:Number     = 8;
        private var strength:Number  = 2;
        private var quality:Number   = BitmapFilterQuality.HIGH
        private var type:String      = BitmapFilterType.INNER;
        private var knockout:Boolean = true;

        public function GradientBevelFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            return new GradientBevelFilter(distance,
                                           angleInDegrees,
                                           colors,
                                           alphas,
                                           ratios,
                                           blurX,
                                           blurY,
                                           strength,
                                           quality,
                                           type,
                                           knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.filters.xml#BevelFilter"><linktext>BevelFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link></related-links><apiConstructor id="flash.filters:GradientBevelFilter:GradientBevelFilter"><apiName>GradientBevelFilter</apiName><shortdesc>
	Инициализирует фильтр с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Constructor
	</category></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>distance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Расстояние смещения. Действительны значения от 0 до 8. 
	</apiDesc></apiParam><apiParam><apiItemName>angle</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>45</apiData><apiDesc>Угол в градусах. Действительны значения от 0 до 360. 
	</apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив шестнадцатеричных значений цвета RGB для применения в градиенте. Например, красный задается значением 0xFF0000, голубой – значением 0x0000FF и т.д.
	</apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений альфа-прозрачности для соответствующих цветов в массиве <codeph>colors</codeph>. Действительные значения для каждого из элементов массива – от 0 до 1. Например, при 0,25 устанавливается 25-процентная прозрачность.
	</apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив значений распределения цветов; действительными являются значения от 0 до 255.
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по горизонтали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. По умолчанию используется значение 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>4.0</apiData><apiDesc>Степень размытия по вертикали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между наклоном и фоном. Действительны значения от 0 до 255. Значение 0 означает, что фильтр не применяется. 
	
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Качество фильтра. Используйте константы BitmapFilterQuality:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Подробные сведения см. в описании свойства <codeph>quality</codeph>.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>inner</apiData><apiDesc>Местоположение эффекта «Наклон». Возможные значения констант BitmapFilterType:
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> – наклон по внешнему краю объекта.</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – наклон по внутреннему краю объекта.</li>
	<li><codeph>BitmapFilterType.FULL</codeph> – наклон по всему объекту.</li>
	</ul>
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, применяется ли эффект выбивки. Значение <codeph>true</codeph> делает заливку объекта прозрачной и делает видимым цвет фона документа. 
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Инициализирует фильтр с заданными параметрами.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/quality"><linktext>GradientBevelFilter.quality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GradientBevelFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two rectangle shapes. The first, 
	<code>sourceClip</code> has a bevel effect. The second, 
	<code>resultClip</code> has no effect until it is clicked.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var sourceClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneSourceClip");
	var resultClip:MovieClip = setUpFlatRectangle(150, 150, 0xCCCCCC, "cloneResultClip");
	
	resultClip.source = sourceClip;
	
	var sourceFilter:GradientBevelFilter = getNewFilter();
	sourceClip.filters = new Array(sourceFilter);
	
	resultClip._x = 180;
	resultClip.onRelease = function() {
		this.filters = new Array(this.source.filters[0].clone());
	}
	
	function setUpFlatRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		return mc;
	}
	
	function getNewFilter():GradientBevelFilter {
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		return new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	}
	
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр GradientBevelFilter с теми же свойствами, что и оригинальный экземпляр GradientBevelFilter.
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GradientBevelFilter:alphas:get"><apiName>alphas</apiName><shortdesc>
	Массив значений альфа-прозрачности для соответствующих цветов в массиве colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>alphas</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("alphasExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [.2, 0, .2];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var alphas:Array = [1, 0, 1];
		arr[0].alphas = alphas;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Массив значений альфа-канала.
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Массив значений альфа-прозрачности для соответствующих цветов в массиве <codeph>colors</codeph>. Действительные значения для каждого из элементов массива – от 0 до 1. Например, при 0,25 устанавливается 25-процентная прозрачность.
	
	<p>Свойство <codeph>alphas</codeph> невозможно изменить, непосредственно поменяв его значения. Вместо этого следует внести изменения в ссылку на <codeph>alphas</codeph>, а затем задать <codeph>alphas</codeph> для ссылки.</p>
	
	<p>Свойства <codeph>colors</codeph>, <codeph>alphas</codeph> и <codeph>ratios</codeph> связаны между собой. Первый элемент массива <codeph>colors</codeph> соответствует первому элементу массива <codeph>alphas</codeph> и массива <codeph>ratios</codeph> и т.д.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:angle:get"><apiName>angle</apiName><shortdesc>
	Угол в градусах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>angle</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("angleExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].angle = 45;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Угол в градусах. Действительны значения от 0 до 360. По умолчанию – 45.
	
	<p>Значение угла задает угол, под которым на объект падает свет из предполагаемого источника. Это значение определяет угол, под которыми цветовые градиенты прикладываются к объекту: где располагаются подсветка и тень и в какой точке отображается первый цвет массива. Затем цвета накладываются в том же порядке, в каком они заданы в массиве.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Степень размытия по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurX</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurXExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurX = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по горизонтали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. По умолчанию используется значение 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Степень размытия по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>blurY</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("blurYExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].blurY = 16;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по вертикали. Действительны значения от 0 до 255. Размытие со значением 1 или менее означает, что исходное изображение копируется как есть. По умолчанию используется значение 4. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:colors:get"><apiName>colors</apiName><shortdesc>
	Массив шестнадцатеричных значений цвета RGB для применения в градиенте.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>colors</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("colorsExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0x000000, 0xCCCCCC, 0xFFFFFF];
		arr[0].colors = colors;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		arr[0].colors = colors;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
	
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Массив шестнадцатеричных значений цвета палитры RGB.
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	Массив шестнадцатеричных значений цвета RGB для применения в градиенте. Например, красный задается значением 0xFF0000, голубой – значением 0x0000FF и т.д.
	
	<p>Свойство <codeph>colors</codeph> нельзя изменить, непосредственно поменяв его значения. Вместо этого следует внести изменения в ссылку на <codeph>colors</codeph>, а затем задать <codeph>colors</codeph> для ссылки.</p>
	
	<p>Свойства <codeph>colors</codeph>, <codeph>alphas</codeph> и <codeph>ratios</codeph> связаны между собой. Первый элемент массива <codeph>colors</codeph> соответствует первому элементу массива <codeph>alphas</codeph> и массива <codeph>ratios</codeph> и т.д.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:distance:get"><apiName>distance</apiName><shortdesc>
	Расстояние смещения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>distance</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("distanceExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].distance = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Расстояние смещения. Действительны значения от 0 до 8. Значением по умолчанию является 4.0.
	
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Определяет, применяется ли к объекту эффект выбивки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>knockout</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("knockoutExample");
	mc.onRelease = function() {
	var arr:Array = this.filters;
		arr[0].knockout = true;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, применяется ли к объекту эффект выбивки. Эффект выбивки делает заливку объекта прозрачной и выявляет цвет фона документа. Значение <codeph>true</codeph> указывает на наличие эффекта выбивки. По умолчанию задано значение <codeph>false</codeph> (без эффекта выбивки).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GradientBevelFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Заданное число применений фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>quality</code> property on an existing
	object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("qualityExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].quality = 1; // low quality
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Заданное число применений фильтра. Значение по умолчанию – <codeph>BitmapFilterQuality.LOW</codeph>, что эквивалентно однократному применению фильтра. Значение <codeph>BitmapFilterQuality.MEDIUM</codeph> применяет фильтр дважды; значение <codeph>BitmapFilterQuality.HIGH</codeph> – трижды. Фильтры с более низкими значениями выполняются быстрее.
	
	<p>Для большинства приложений достаточно значения <codeph>quality</codeph> на уровне «low» («низкое»), «medium» («среднее») или «high» («высокое»). Хотя можно использовать дополнительные числовые значения до 15 для получения разнообразных эффектов, более высокие значения выполняются дольше. Вместо увеличения значения <codeph>quality</codeph> можно просто увеличить значения свойств <codeph>blurX</codeph> и <codeph>blurY</codeph>. Это даст похожий эффект, а выполнение будет происходить быстрее.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:ratios:get"><apiName>ratios</apiName><shortdesc>
	Массив пропорций распределения цвета для соответствующих цветов в массиве colors.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>ratios</code> property on an existing entity.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("ratiosExample");
	mc.onPress = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [127, 128, 129];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	mc.onRelease = function() {
		var arr:Array = this.filters;
 		var ratios:Array = [0, 128, 255];
		arr[0].ratios = ratios;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
		
 		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 2, "inner", false);
		
 		art.filters = new Array(filter);
 		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>Массив при назначении принимает значение null.
	
	</apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Массив пропорций распределения цвета для соответствующих цветов в массиве <codeph>colors</codeph>. Действительные значения для каждого из элементов массива – от 0 до 255.
	
	<p>Свойство <codeph>ratios</codeph> невозможно изменить, непосредственно поменяв его значения. Вместо этого следует внести изменения в ссылку на <codeph>ratios</codeph>, а затем задать <codeph>ratios</codeph> для ссылки.</p>
	
	<p> Свойства <codeph>colors</codeph>, <codeph>alphas</codeph> и <codeph>ratios</codeph> связаны между собой. Первый элемент массива <codeph>colors</codeph> соответствует первому элементу массива <codeph>alphas</codeph> и массива <codeph>ratios</codeph> и т.д.</p>
	
	<p> Чтобы представить, как распределяются цвета в градиентном наклоне, представьте какой-нибудь цвет. Предположим что, простой наклон имеет сплошной цвет подсветки и сплошной цвет тени, а градиентный наклон имеет градиентную подсветку и градиентную тень. Представьте, что подсветка располагается в верхнем левом углу, а тень – в правом верхнем. Представьте, что одинарное использование фильтра позволяет получить четыре цвета подсветки и четыре цвета тени. В дополнение к подсветке и тени фильтр использует базовый цвет заливки, который отображается на стыке областей подсветки и тени. Таким образом, всего получается девять цветов, поэтому соответствующее число элементов в массиве пропорций тоже девять.</p>
	
	<p> Представьте градиент как сочетание переходящих друг в друга полос разных цветов. Каждое значение пропорции задает положение цвета по радиусу градиента, где 0 – это самая удаленная от центра точка, а 255 – самая ближняя к центру. Как правило, среднее значение – 128, оно же является значением базовой заливки. Для получения эффекта наклона, показанного на рисунке ниже, необходимо назначить значения пропорций, как показано ниже, и использовать девятицветный пример:</p>
	
	<ul> 
	<li> Первые четыре цвета лежат в диапазоне от 0 до 127, при этом каждое последующее значение должно быть больше предыдущего. Это подсвеченная сторона.</li>
	<li> Пятый цвет (средний) – это базовая заливка, его значение 128. Значение пикселя 128 задает базовую заливку, которая отображается за границами фигуры (и вокруг краев наклона), если задан внешний тип. Если же задан внутренний тип, то она отображается внутри фигуры и перекрывает собственную заливку объекта.</li>
	<li> Последние четыре цвета лежат в диапазоне от 129 до 255, при этом каждое последующее значение должно быть больше предыдущего. Это теневая сторона.</li>
	</ul>
	
	<p> Если необходимо, чтобы цвета с каждой стороны распределялись ровно, рекомендуется использовать нечетное количество цветов, где средний цвет будет цветом заливки. Распределите значения цветов равномерно в диапазонах 0-127 и 129-255, затем скорректируйте значение, чтобы изменить ширину каждой из полосок градиента. Для градиентного наклона из девяти цветов возможен массив [16, 32, 64, 96, 128, 160, 192, 224, 235]. На рисунке ниже показан рассмотренный градиентный наклон.</p>
	
	<p><adobeimage alt="Девятицветный градиентный наклон." href="../../images/gradientBevelRainbow.jpg"/></p>
	
	<p>Следует помнить, что распределение цветов в градиенте зависит от значений свойств <codeph>blurX</codeph>, <codeph>blurY</codeph>, <codeph>strength</codeph> и <codeph>quality</codeph>, а также от значений <codeph>ratios</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/alphas"><linktext>GradientBevelFilter.alphas</linktext></link><link href="flash.filters.xml#GradientBevelFilter/colors"><linktext>GradientBevelFilter.colors</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Степень вдавливания или нанесения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>strength</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("strengthExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].strength = 1;
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между наклоном и фоном. Действительны значения от 0 до 255. Значение 0 означает, что фильтр не применяется. Значением по умолчанию является 1.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#GradientBevelFilter/ratios"><linktext>GradientBevelFilter.ratios</linktext></link></related-links></apiValue><apiValue id="flash.filters:GradientBevelFilter:type:get"><apiName>type</apiName><shortdesc>
	Местоположение эффекта «Наклон».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates how to set the <code>type</code> property on an existing object.
	<listing version="2.0">
	import flash.filters.GradientBevelFilter;
	
	var mc:MovieClip = setUpFilter("typeExample");
	mc.onRelease = function() {
		var arr:Array = this.filters;
		arr[0].type = "outer";
		this.filters = arr;
	}
	
	function setUpFilter(name:String):MovieClip {
		var art:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 150;
		var h:Number = 150;
		art.beginFill(0xCCCCCC);
		art.lineTo(w, 0);
		art.lineTo(w, h);
		art.lineTo(0, h);
		art.lineTo(0, 0);
	
		var colors:Array = [0xFFFFFF, 0xCCCCCC, 0x000000];
		var alphas:Array = [1, 0, 1];
		var ratios:Array = [0, 128, 255];
		var filter:GradientBevelFilter = new GradientBevelFilter(5, 225, colors, alphas, ratios, 5, 5, 5, 3, "inner", false);
	
		art.filters = new Array(filter);
		return art;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Местоположение эффекта «Наклон». Возможные значения констант BitmapFilterType:
	<ul><li><codeph>BitmapFilterType.OUTER</codeph> – наклон по внешнему краю объекта.</li>
	<li><codeph>BitmapFilterType.INNER</codeph> – наклон по внутреннему краю объекта.</li>
	<li><codeph>BitmapFilterType.FULL</codeph> –наклон по верхнему краю объекта.</li>
	</ul>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
 Класс GlowFilter позволяет применять эффект свечения к экранным объектам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Позволяет добавлять эффект «Свечение».
 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс GlowFilter позволяет применять эффект свечения к экранным объектам. Существует несколько вариантов выбора стиля свечения, включая внутреннее и внешнее свечения и эффект выбивки. Фильтр свечения похож на фильтр тени, у которого свойствам <codeph>distance</codeph> и <codeph>angle</codeph> присвоено значение 0. Фильтр можно применять к любому экранному объекту (т.е. объекту, наследуемому от класса DisplayObject), например MovieClip, SimpleButton, TextField, Video, а также объектам BitmapData.
 
 <p>Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
 <ul><li>Применить фильтр к экранным объектам можно с помощью свойства <codeph>filters</codeph> (наследуется от DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>. </li>
 
 <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
 </ul>
 
 
 <p>При применении фильтра к визуализируемому объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение <codeph>true</codeph>. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>

 <p>Этот фильтр поддерживает масштабирование сцены. Тем не менее, он не поддерживает общее масштабирование, повороты и искажение. Если сам объект увеличен или уменьшен (т.е. если свойства <codeph>scaleX</codeph> и <codeph>scaleY</codeph> принимают значение, отличное от 1,0), фильтр не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой сцене.</p>
 
 <p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>
 
 </apiDesc><example conref="examples\GlowFilterExample.as"> При выполнении приведенного ниже кода будет нарисован квадрат и к нему будет применен фильтр «Размытие». Порядок выполнения кода таков:
 <ol>
  <li>Импортируется требуемый класс.</li>
  <li>Объявляются три свойства метода <codeph>draw</codeph>, который использует методы класса Graphics, полученные через свойство <codeph>graphics</codeph> спрайта для рисования оранжевого квадрата.</li>
  <li>Создается функция конструктора, которая выполняет следующее:
      <ul>
          <li>Вызывает метод <codeph>draw</codeph>.</li> 
          <li>Создает новый объект BitmapFilter с именем <codeph>filter</codeph> и назначает ему возвращаемое значение вызова <codeph>getBitmapFilter()</codeph>, определяющего фильтр.</li>
          <li>Создает массив с именем <codeph>myFilters</codeph> и добавляет к нему <codeph>filter</codeph>. </li>
          <li>Назначает <codeph>myFilters</codeph> свойству <codeph>filters</codeph> объекта BevelFilterExample. В результате применяются все фильтры, обнаруженные в <codeph>myFilters</codeph>. В нашем случае это только один фильтр <codeph>filter</codeph>.</li>
      </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.filters.BitmapFilter;
    import flash.filters.BitmapFilterQuality;
    import flash.filters.GlowFilter;

    public class GlowFilterExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint    = 80;
        private var offset:uint  = 50;

        public function GlowFilterExample() {
            draw();
            var filter:BitmapFilter = getBitmapFilter();
            var myFilters:Array = new Array();
            myFilters.push(filter);
            filters = myFilters;
        }

        private function getBitmapFilter():BitmapFilter {
            var color:Number = 0x33CCFF;
            var alpha:Number = 0.8;
            var blurX:Number = 35;
            var blurY:Number = 35;
            var strength:Number = 2;
            var inner:Boolean = false;
            var knockout:Boolean = false;
            var quality:Number = BitmapFilterQuality.HIGH;

            return new GlowFilter(color,
                                  alpha,
                                  blurX,
                                  blurY,
                                  strength,
                                  quality,
                                  inner,
                                  knockout);
        }

        private function draw():void {
            graphics.beginFill(bgColor);
            graphics.drawRect(offset, offset, size, size);
            graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/scaleX"><linktext>flash.display.DisplayObject.scaleX</linktext></link><link href="flash.display.xml#DisplayObject/scaleY"><linktext>flash.display.DisplayObject.scaleY</linktext></link><link href="flash.filters.xml#DropShadowFilter/distance"><linktext>flash.filters.DropShadowFilter.distance</linktext></link><link href="flash.filters.xml#DropShadowFilter/angle"><linktext>flash.filters.DropShadowFilter.angle</linktext></link></related-links><apiConstructor id="flash.filters:GlowFilter:GlowFilter"><apiName>GlowFilter</apiName><shortdesc>
	Инициализирует новый экземпляр GlowFilter с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example instantiates a new GlowFilter instance and applies
	it to a flat, rectangular shape.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var rect:MovieClip = createRectangle(100, 100, 0x003366, "gradientGlowFilterExample");
	
	var color:Number = 0x33CCFF;
	var alpha:Number = .8;
	var blurX:Number = 35;
	var blurY:Number = 35;
	var strength:Number = 2;
	var quality:Number = 3;
	var inner:Boolean = false;
	var knockout:Boolean = false;
	
	var filter:GlowFilter = new GlowFilter(color, 
										 alpha, 
										 blurX, 
										 blurY, 
										 strength, 
										 quality, 
										 inner, 
										 knockout);
	var filterArray:Array = new Array();
	filterArray.push(filter);
	rect.filters = filterArray;
	
	function createRectangle(w:Number, h:Number, bgColor:Number, name:String):MovieClip {
		var mc:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		mc.beginFill(bgColor);
		mc.lineTo(w, 0);
		mc.lineTo(w, h);
		mc.lineTo(0, h);
		mc.lineTo(0, 0);
		mc._x = 20;
		mc._y = 20;
		return mc;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFF0000</apiData><apiDesc>Цвет свечения в шестнадцатеричном формате 0x<i>RRGGBB</i>. Значение по умолчанию – 0xFF0000.
	</apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Значение альфа-прозрачности цвета. Действительны значения от 0 до 1. Например, при 0,25 устанавливается 25-процентная прозрачность.
	</apiDesc></apiParam><apiParam><apiItemName>blurX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>Степень размытия по горизонтали. Действительны значения от 0 до 255 (плавающая точка). Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	</apiDesc></apiParam><apiParam><apiItemName>blurY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>6.0</apiData><apiDesc>Степень размытия по вертикали. Действительны значения от 0 до 255 (плавающая точка). Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	</apiDesc></apiParam><apiParam><apiItemName>strength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>2</apiData><apiDesc>Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между свечением и фоном. Действительны значения от 0 до 255. 
	</apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>1</apiData><apiDesc>Заданное число применений фильтра. Используйте константы BitmapFilterQuality:
	<ul>
	<li><codeph>BitmapFilterQuality.LOW</codeph></li>
	<li><codeph>BitmapFilterQuality.MEDIUM</codeph></li>
	<li><codeph>BitmapFilterQuality.HIGH</codeph></li>
	</ul>
	<p>Подробные сведения см. в описании свойства <codeph>quality</codeph>.</p>
	</apiDesc></apiParam><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли свечение внутренним свечением. Значение <codeph> true</codeph> говорит о том, что свечение внутреннее. Значение <codeph>false</codeph> задает внешнее свечение (свечение вокруг внешнего контура объекта). 
	</apiDesc></apiParam><apiParam><apiItemName>knockout</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, применяется ли к объекту эффект выбивки. Значение <codeph>true</codeph> делает заливку объекта прозрачной и делает видимым цвет фона документа. 
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	Инициализирует новый экземпляр GlowFilter с заданными параметрами.
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>BitmapFilterQuality</linktext></link><link href="flash.filters.xml#GlowFilter/quality"><linktext>GlowFilter.quality</linktext></link></related-links></apiConstructor><apiOperation id="flash.filters:GlowFilter:clone"><apiName>clone</apiName><shortdesc>
	Возвращает копию данного объекта фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates three GlowFilter objects and compares them: <code>filter_1</code>
	is created by using the GlowFilter constructor; <code>filter_2</code> is created by setting it equal to 
	<code>filter_1</code>; and <code>clonedFilter</code> is created by cloning <code>filter_1</code>.  Notice
	that although <code>filter_2</code> evaluates as being equal to <code>filter_1</code>, <code>clonedFilter</code>,
	even though it contains the same values as <code>filter_1</code>, does not.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1 == filter_2);		// true
	trace(filter_1 == clonedFilter);	// false
	
	for(var i in filter_1) {
		trace(">> " + i + ": " + filter_1[i]);
		// >> clone: [type Function]
		// >> strength: 2
		// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	
	for(var i in clonedFilter) {
		trace(">> " + i + ": " + clonedFilter[i]);
		// >> clone: [type Function]
		// >> strength: 2
	// >> blurY: 35
		// >> blurX: 35
		// >> knockout: false
		// >> inner: false
		// >> quality: 3
		// >> alpha: 0.8
		// >> color: 3394815
	}
	</listing>
	To further demonstrate the relationships between <code>filter_1</code>, <code>filter_2</code>, and <code>clonedFilter</code>,
	the following example modifies the <code>knockout</code> property of <code>filter_1</code>.  Modifying <code>knockout</code> demonstrates
	that the <code>clone()</code> method creates a new instance based on the values of <code>filter_1</code> instead of pointing to 
	them in reference.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var filter_1:GlowFilter = new GlowFilter(0x33CCFF, .8, 35, 35, 2, 3, false, false);
	var filter_2:GlowFilter = filter_1;
	var clonedFilter:GlowFilter = filter_1.clone();
	
	trace(filter_1.knockout);			// false
	trace(filter_2.knockout);			// false
	trace(clonedFilter.knockout);		// false
	
	filter_1.knockout = true;
	
	trace(filter_1.knockout);			// true
	trace(filter_2.knockout);			// true
	trace(clonedFilter.knockout);		// false
	</listing>
	</maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>Новый экземпляр GlowFilter со всеми свойствами оригинального экземпляра GlowFilter.
	</apiDesc><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	Возвращает копию данного объекта фильтра.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filters:GlowFilter:alpha:get"><apiName>alpha</apiName><shortdesc>
	Значение альфа-прозрачности цвета.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>alpha</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterAlpha");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.alpha = .4;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Значение альфа-прозрачности цвета. Действительны значения от 0 до 1. Например, при 0,25 устанавливается 25-процентная прозрачность. Значением по умолчанию является 1.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurX:get"><apiName>blurX</apiName><shortdesc>
	Степень размытия по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurX</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurX");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurX = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по горизонтали. Действительны значения от 0 до 255 (плавающая точка). Значением по умолчанию является 6. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:blurY:get"><apiName>blurY</apiName><shortdesc>
	Степень размытия по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>blurY</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterBlurY");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.blurY = 20;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень размытия по вертикали. Действительны значения от 0 до 255 (плавающая точка). Значением по умолчанию является 6. Значения, являющиеся степенью 2 (т.е. 2, 4, 8, 16 и 32), оптимизируются и выполняются быстрее, чем остальные.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:color:get"><apiName>color</apiName><shortdesc>
	Цвет свечения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>color</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterColor");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.color = 0x00FF33;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	Цвет свечения. Действительны значения в шестнадцатеричном формате 0x<i>RRGGBB</i>. Значение по умолчанию – 0xFF0000.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:inner:get"><apiName>inner</apiName><shortdesc>
	Определяет, является ли свечение внутренним свечением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>inner</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterInner");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.inner = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, является ли свечение внутренним свечением. Значение <codeph> true</codeph> говорит о том, что свечение внутреннее. Значение <codeph>false</codeph> задает внешнее свечение (свечение вокруг внешнего контура объекта). 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:knockout:get"><apiName>knockout</apiName><shortdesc>
	Определяет, применяется ли к объекту эффект выбивки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>knockout</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterKnockout");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.knockout = true;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	Определяет, применяется ли к объекту эффект выбивки. Значение <codeph>true</codeph> делает заливку объекта прозрачной и делает видимым цвет фона документа. Значение по умолчанию – <codeph>false</codeph> (без эффекта выбивки).
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:GlowFilter:quality:get"><apiName>quality</apiName><shortdesc>
	Заданное число применений фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>quality</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterQuality");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.quality = 1;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>
	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	Заданное число применений фильтра. Значение по умолчанию – <codeph>BitmapFilterQuality.LOW</codeph>, что эквивалентно однократному применению фильтра. Значение <codeph>BitmapFilterQuality.MEDIUM</codeph> применяет фильтр дважды; значение <codeph>BitmapFilterQuality.HIGH</codeph> – трижды. Фильтры с более низкими значениями выполняются быстрее.
	
	<p>Для большинства приложений достаточно значения <codeph>quality</codeph> на уровне «low» («низкое»), «medium» («среднее») или «high» («высокое»). Хотя можно использовать дополнительные числовые значения до 15 для получения разнообразных эффектов, более высокие значения выполняются дольше. Вместо увеличения значения <codeph>quality</codeph> можно просто увеличить значения свойств <codeph>blurX</codeph> и <codeph>blurY</codeph>. Это даст похожий эффект, а выполнение будет происходить быстрее.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.filters.xml#BitmapFilterQuality"><linktext>flash.filters.BitmapFilterQuality</linktext></link></related-links></apiValue><apiValue id="flash.filters:GlowFilter:strength:get"><apiName>strength</apiName><shortdesc>
	Степень вдавливания или нанесения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example changes the <code>strength</code> property on an existing movie clip 
	when a user clicks it.
	<listing version="2.0">
	import flash.filters.GlowFilter;
	
	var mc:MovieClip = createGlowFilterRectangle("GlowFilterStrength");
	mc.onRelease = function() {
		var filter:GlowFilter = this.filters[0];
		filter.strength = .8;
		this.filters = new Array(filter);
	}
	
	function createGlowFilterRectangle(name:String):MovieClip {
		var rect:MovieClip = this.createEmptyMovieClip(name, this.getNextHighestDepth());
		var w:Number = 100;
		var h:Number = 100;
		rect.beginFill(0x003366);
		rect.lineTo(w, 0);
		rect.lineTo(w, h);
		rect.lineTo(0, h);
		rect.lineTo(0, 0);
		rect._x = 20;
		rect._y = 20;
	
		var filter:GlowFilter = new GlowFilter(0x000000, .8, 16, 16, 1, 3, false, false);
		var filterArray:Array = new Array();
		filterArray.push(filter);
		rect.filters = filterArray;
		return rect;
	}
	</listing>

	</maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	Степень вдавливания или нанесения. Чем выше значение, тем более насыщен цвет тени и тем сильнее контраст между свечением и фоном. Действительны значения от 0 до 255. По умолчанию – 2.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filters:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
	 Класс ShaderFilter применяет фильтр, выполняя шейдеры на объекте, к которому применяется фильтр.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.filters:BitmapFilter</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс ShaderFilter применяет фильтр, выполняя шейдеры на объекте, к которому применяется фильтр. Объект, к которому применен фильтр, используется в качестве входящих данных для шейдера, а выходные данные после выполнения шейдера являются результатом применения фильтра.
	 
	 <p>Новый фильтр можно создать с помощью конструктора <codeph>new ShaderFilter()</codeph>. Выбор фильтра зависит от объекта, к которому требуется его применить:</p>
	 
	 <ul>
	   <li>Если фильтр применяется к фрагментам ролика, текстовым полям, кнопкам или видео, следует использовать свойство <codeph>filters</codeph> (наследуемое от класса DisplayObject). При задании объекту свойства <codeph>filters</codeph> сам объект не изменяется, а фильтр можно удалить через свойство <codeph>filters</codeph>.</li>
	   <li>Для применения фильтров к объектам BitmapData следует пользоваться методом <codeph>BitmapData.applyFilter()</codeph>. При вызове <codeph>applyFilter()</codeph> для объекта BitmapData из исходного объекта BitmapData и объекта фильтра формируется изображение с применением фильтра.</li>
	 </ul>
	 
	 <p>При применении фильтра к экранному объекту свойство <codeph>cacheAsBitmap</codeph> этого объекта принимает значение true. Если удалить все фильтры, будет восстановлено исходное значение <codeph>cacheAsBitmap</codeph>.</p>
	 
	 <p>Этот фильтр поддерживает масштабирование рабочей области. Тем не менее, он не поддерживает общее масштабирование, повороты и искажение. Если сам объект увеличен или уменьшен (т.е. если свойства <codeph>scaleX</codeph> и <codeph>scaleY</codeph> не равны 100%), фильтр не масштабируется. Он масштабируется, только когда пользователь применяет увеличение к самой рабочей области.</p>
	 
	 <p>Фильтр не применяется, если полученное изображение превышает максимальные размеры. В AIR 1.5 и Flash Player 10 максимальный размер изображения составляет 8 191 пикселей в ширину или высоту, а общее количество пикселей не может превышать 16 777 215. (Т. е. если ширина изображения составляет 8 191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Например, при масштабировании большого фрагмента ролика, к которому применен фильтр, фильтр будет снят, если получившееся изображение превысит максимальные размеры.</p>
	 
	 <p>Для задания экземпляра Shader, который будет использоваться вместе с фильтром, необходимо передать экземпляр Shader в виде аргумента конструктору <codeph>ShaderFilter()</codeph> или задать его как значение свойства <codeph>shader</codeph>.</p>
	 
	 <p>Чтобы действие Shader не было ограничено пределами объекта, к которому применен фильтр, пользуйтесь свойствами <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> и <codeph>bottomExtension</codeph>.</p>
	 
	 </apiDesc><example conref="examples\ShaderFilterExample.1.as"> В следующем примере показан код, который загружает шейдер, используемый в качестве свойства <codeph>shader</codeph> класса ShaderFilter. Этот код рисует круг в экземпляре спрайта и добавляет его к сцене. При загрузке шейдера к этому спрайту применяется фильтр шейдера.
 
 <p>Обратите внимание, что в этом примере мы исходим из того, что существует файл байт-кодов с именем gradient.pbj, хранящийся в каталоге, который является выходным для приложения.</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel RedGradientFilter
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "Applies a gradient across the red channel of the input image.";
>
{
    input image4 src;
    output pixel4 dst;
    
    parameter float width
    &lt;
        description: "The width of the image to which the shader is applied.";
        minValue: 0.0;
    >;

    void evaluatePixel()
    {
        pixel4 temp = sampleNearest(src, outCoord());
        temp.r = 1.0 - (outCoord().x * (1.0 / width));
        dst = temp;
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.filters.ShaderFilter;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderFilterExample extends Sprite {
        
        private var loader:URLLoader;
        private var s:Sprite;
        
        public function ShaderFilterExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("gradient.pbj"));
            
            s = new Sprite();
            s.graphics.beginFill(0x009900);
            s.graphics.drawCircle(100, 100, 100);
            addChild(s);
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader(loader.data);
            shader.data.width.value = [s.width];
            
            var gradientFilter:ShaderFilter = new ShaderFilter(shader);
            s.filters = [gradientFilter];
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>flash.display.DisplayObject.cacheAsBitmap</linktext></link><link href="flash.display.xml#BitmapData/applyFilter()"><linktext>flash.display.BitmapData.applyFilter()</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links><apiConstructor id="flash.filters:ShaderFilter:ShaderFilter"><apiName>ShaderFilter</apiName><shortdesc>
		 Создает новый фильтр «Шейдер».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>Шейдер для использования с этим фильтром. Подробные сведения и ограничения, которым должен подчиняться шейдер, см. в описании свойства <codeph>shader</codeph>.
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Создает новый фильтр «Шейдер».
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.filters.xml#ShaderFilter/shader"><linktext>shader</linktext></link></related-links></apiConstructor><apiValue id="flash.filters:ShaderFilter:bottomExtension:get"><apiName>bottomExtension</apiName><shortdesc>
		 Прирост в пикселях с нижней стороны целевого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Прирост в пикселях с нижней стороны целевого объекта.
		 
		 <p>Прирост – это область за границами целевого объекта, передаваемая шейдеру во время выполнения. Во время выполнения Flash Player или AIR вычисляет обычные границы фрагмента ролика и расширяет их в соответствии со значениями <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> и <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:leftExtension:get"><apiName>leftExtension</apiName><shortdesc>
		 Прирост в пикселях с левой стороны целевого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Прирост в пикселях с левой стороны целевого объекта.
		 
		 <p>Прирост – это область за границами целевого объекта, передаваемая шейдеру во время выполнения. Во время выполнения Flash Player или AIR вычисляет нормальные границы фрагмента ролика и расширяет их в соответствии со значениями <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> и <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:rightExtension:get"><apiName>rightExtension</apiName><shortdesc>
		 Прирост в пикселях с правой стороны целевого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Прирост в пикселях с правой стороны целевого объекта.
		 
		 <p>Прирост – это область за границами целевого объекта, передаваемая шейдеру во время выполнения. Во время выполнения Flash Player или AIR вычисляет нормальные границы фрагмента ролика и расширяет их в соответствии со значениями <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> и <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:shader:get"><apiName>shader</apiName><shortdesc>
		 Шейдер для использования с этим фильтром.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 Шейдер для использования с этим фильтром.
		 
		 <p>Шейдер, назначенный свойству <codeph>shader</codeph>, должен указывать хотя бы на одно входное значение <codeph>image4</codeph>. В коде <b>не обязательно</b> указывать код с помощью ассоциативного свойства <codeph>input</codeph> объекта ShaderInput. Вместо этого объект, к которому применяется фильтр, автоматически становится первым значением входа (вход с <codeph>index</codeph> 0). Шейдер, используемый в качестве фильтра, может задавать более одного входа. В этом случае любые дополнительные входы должны быть заданы через свойство <codeph>input</codeph> экземпляра ShaderInput.</p>
		 
		 <p>При назначении экземпляра шейдера данному свойству создается внутренняя копия шейдера, а операция фильтра использует эту копию, а не ссылку на исходный файл Все изменения, производимые над шейдером, например изменение значения параметров, входа или байт-кода, не влияют на скопированный шейдер, к которому обращается фильтр. Чтобы изменения отражались и на шейдере при выводе результатов фильтра, необходимо переназначить экземпляр шейдера свойству <codeph>shader</codeph>. Как и в случае с другими фильтрами, чтобы применить изменения фильтра, необходимо также повторно назначить экземпляр ShaderFilter свойству <codeph>filters</codeph> экранного объекта.</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filters:ShaderFilter:topExtension:get"><apiName>topExtension</apiName><shortdesc>
		 Прирост в пикселях с верхней стороны целевого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 Прирост в пикселях с верхней стороны целевого объекта.
		 
		 <p>Прирост – это область за границами целевого объекта, передаваемая шейдеру во время выполнения. Во время выполнения Flash Player или AIR вычисляет нормальные границы фрагмента ролика и расширяет их в соответствии со значениями <codeph>leftExtension</codeph>, <codeph>rightExtension</codeph>, <codeph>topExtension</codeph> и <codeph>bottomExtension</codeph>.</p>
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>