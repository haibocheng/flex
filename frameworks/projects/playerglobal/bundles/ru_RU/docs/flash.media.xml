<?xml version="1.0"?>
<apiPackage id="flash.media"><apiName>flash.media</apiName><apiDetail/><apiClassifier id="flash.media:SoundCodec"><apiName>SoundCodec</apiName><shortdesc>
Класс SoundCodec является перечислением значений констант, с помощью которых задается свойство codec класса Microphone.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс SoundCodec является перечислением значений констант, с помощью которых задается свойство <codeph>codec</codeph> класса <codeph>Microphone</codeph>.

</apiDesc></apiClassifierDetail><apiValue id="flash.media:SoundCodec:NELLYMOSER"><apiName>NELLYMOSER</apiName><shortdesc> 
	Используется для указания того, что для сжатия аудиоданных должен использоваться кодек Nellymoser.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>NellyMoser</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для указания того, что для сжатия аудиоданных должен использоваться кодек Nellymoser. Данная константа является значением по умолчанию свойства <codeph>Microphone.codec</codeph>.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundCodec:SPEEX"><apiName>SPEEX</apiName><shortdesc> 
	Используется для указания того, что для сжатия аудиоданных должен использоваться кодек Speex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>Speex</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для указания того, что для сжатия аудиоданных должен использоваться кодек Speex.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:ID3Info"><apiName>ID3Info</apiName><shortdesc>
	 Класс ID3Info содержит свойства, отражающие метаданные ID3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс ID3Info содержит свойства, отражающие метаданные ID3. Для получения дополнительных метаданных для МР3-файлов можно обратиться к свойству <codeph>id3</codeph> класса Sound, например, <codeph>mySound.id3.TIME</codeph>. Дополнительные сведения см. в описании <codeph>Sound.id3</codeph> и определениях тегов ID3 на странице <xref href="http://www.id3.org">http://www.id3.org</xref>.
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links><apiValue id="flash.media:ID3Info:album"><apiName>album</apiName><shortdesc>
		 Название альбома. Соответствует тегу TALB в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Название альбома. Соответствует тегу TALB в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:artist"><apiName>artist</apiName><shortdesc>
		 Имя исполнителя. Соответствует тегу TPE1 в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Имя исполнителя. Соответствует тегу TPE1 в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:comment"><apiName>comment</apiName><shortdesc>
		 Комментарий о записи. Соответствует тегу COMM в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Комментарий о записи. Соответствует тегу COMM в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:genre"><apiName>genre</apiName><shortdesc>
		 Жанр композиции. Соответствует тегу TCON в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Жанр композиции. Соответствует тегу TCON в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:songName"><apiName>songName</apiName><shortdesc>
		 Название композиции. Соответствует тегу TIT2 в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Название композиции. Соответствует тегу TIT2 в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:track"><apiName>track</apiName><shortdesc>
		 Номер дорожки. Соответствует тегу TRCK в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Номер дорожки. Соответствует тегу TRCK в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:ID3Info:year"><apiName>year</apiName><shortdesc>
		 Год записи. Соответствует тегу TYER в ID3 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="AS3"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Год записи. Соответствует тегу TYER в ID3 2.0.
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Microphone"><apiName>Microphone</apiName><shortdesc>
 Используйте класс Microphone для записи звука с микрофона, подключенного к компьютеру, на котором выполняется Flash Player или Adobe AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Используйте класс Microphone для записи звука с микрофона, подключенного к компьютеру, на котором выполняется <ph platform="actionScript">Flash Player или</ph> Adobe AIR. Используйте класс Microphone для локального отслеживания аудиоданных. Используйте классы NetConnection и NetStream для передачи аудиоданных на сервер Flash Media Server. Flash Media Server может передавать аудио другим серверам и транслировать его на другие клиентские компьютеры, на которых выполняется <ph platform="actionScript">Flash Player или</ph> Adobe AIR.
 
 <p>
 Сведения о записи видео см. в описании класса Camera.
 </p>
 
 <p>
 <b>Важно! </b>Проигрыватель Flash Player показывает диалоговое окно «Конфиденциальность», в котором пользователь может предоставить или запретить доступ к микрофону. Убедитесь в том, что размеры окна приложения составляют не менее 215 х 138 пикселей. Это минимальный размер, необходимый для отображения диалогового окна.
 </p>
 
 <p>
 Чтобы создать объект Microphone или сослаться на него, используйте метод <codeph>Microphone.getMicrophone()</codeph>.
 </p>
 
 <p platform="actionscript"><b>Важно!</b> Для содержимого, находящегося за пределами изолированной программной среды приложения, отображается диалоговое окно «Конфиденциальность», в котором пользователь может предоставить или запретить доступ к микрофону. Минимальный размер окна приложения, необходимый для отображения этого диалогового окна, составляет 215 x 138 пикселей. Для содержимого Adobe AIR в изолированной программной среде приложения доступ разрешен, и это диалоговое окно не отображается.</p>
 
 </apiDesc><example conref="examples\MicrophoneExample.as"> В следующем примере записывается звук с эхокомпенсацией, после того как пользователь разрешает доступ к микрофону на своем компьютере. Метод <codeph>Security.showSettings()</codeph> отображает диалоговое окно проигрывателя Flash Player, в котором запрашивается разрешение на доступ к микрофону пользователя. Вызов <codeph>setLoopBack(true)</codeph> переводит ввод на локальный динамик, чтобы при выполнения примера можно быть слышать звук.
 
 <p>Добавляется два прослушивателя для событий <codeph>activity</codeph> и <codeph>status</codeph>. Событие <codeph>activity</codeph> отправляется при запуске и после окончания (если это применимо) сеанса методу <codeph>activityHandler()</codeph>, который отслеживает информацию события. Событие <codeph>status</codeph> отправляется, если присоединенный объект Microphone сообщает информацию о состоянии. Его получает и отслеживает метод <codeph>statusHandler()</codeph>.</p>
 
 <p><b>Примечание.</b> Для правильной работы примера к компьютеру должен быть подключен микрофон.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Microphone;
    import flash.system.Security;

    public class MicrophoneExample extends Sprite {
        public function MicrophoneExample() {
            var mic:Microphone = Microphone.getMicrophone();
            Security.showSettings("2");
            mic.setLoopBack(true);
                    
            if (mic != null) {
                mic.setUseEchoSuppression(true);
                mic.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                mic.addEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }

        private function statusHandler(event:StatusEvent):void {
            trace("statusHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Отправляется, когда микрофон сообщает о своем состоянии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда микрофон сообщает о своем состоянии. Если свойство <codeph>code</codeph> имеет значение <codeph>Microphone.Muted</codeph>, пользователь отказался предоставить SWF-файлу доступ к микрофону. Если свойство <codeph>code</codeph> имеет значение<codeph>Microphone.Unmuted</codeph>, пользователь предоставил SWF-файлу доступ к микрофону.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>Microphone.getMicrophone()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Microphone_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Отправляется, когда микрофон начинает или заканчивает сеанс.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда микрофон начинает или заканчивает сеанс. 
 
 <p>
 Чтобы указать, сколько звука требуется для запуска события со свойством <codeph>activating</codeph> в значении <codeph>true</codeph> или сколько времени должно пройти без звука для запуска этого события со свойством <codeph>activating</codeph> в значении <codeph>false</codeph>, используйте метод <codeph>Microphone.setSilenceLevel()</codeph>.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>setSilenceLevel()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.media:Microphone:getMicrophone"><apiName>getMicrophone</apiName><shortdesc>
	 
	 Возвращает ссылку на объект Microphone для записи аудио.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, Microphone.getMicropone, getMicrophone
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Ссылка на объект Microphone для записи аудио.
	 
 	 </apiDesc><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Значение индекса микрофона.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Возвращает ссылку на объект Microphone для записи аудио. Для начала записи аудио, необходимо присоединить объект Microphone к объекту NetStream (см. <codeph>NetStream.attachAudio()</codeph>).
	 
	 <p>
	 Многочисленные вызовы <codeph>Microphone.get()</codeph> ссылаются на один микрофон. Таким образом, если код содержит строки <codeph>mic1 = Microphone.get()</codeph> и <codeph>mic2 = Microphone.get()</codeph>, и <codeph>mic1</codeph> и <codeph>mic2</codeph> ссылаются на один и тот же микрофон (по умолчанию).</p>
	 <p>
	 Чтобы получить микрофон по умолчанию, нужно вызвать метод <codeph>getMicrophone()</codeph>, указав значение -1. Также его можно вызвать без параметров, тогда метод возвратит первый микрофон в списке.
	 </p>
	 
	 <p>
	 Используйте свойство <codeph>index</codeph> для получения значения индекса текущего объекта Microphone. Затем можно передать это значение другим методам класса Microphone.
	 </p>
	 
	 <p>
	 Как правило, не следует передавать значение для <codeph>index</codeph>. Просто используйте метод <codeph>Microphone.getMicrophone()</codeph> для получения ссылки на микрофон по умолчанию. На панели «Настройки микрофона» можно задать микрофон по умолчанию, который должно использовать приложение. Если передать значение для параметра <codeph>index</codeph>, то метод может ссылаться не на тот микрофон, который выберет пользователь. Параметр <codeph>index</codeph> можно использовать в редких случаях, например, если приложение записывает аудио одновременно с двух микрофонов.
	 </p>
	 
	 <p>
	 Когда SWF-файл пытается обратиться к объекту, возвращенному методом <codeph>Microphone.getMicrophone()</codeph>, например при вызове метода <codeph>NetStream.attachAudio()</codeph>, проигрыватель Flash Player отображает диалоговое окно «Конфиденциальность», с помощью которого пользователь может разрешить или запретить доступ к микрофону. (Убедитесь в том, что размеры рабочей области составляют не менее 215х 138 пикселей. Это минимальный размер, необходимый проигрывателю Flash Player для отображения диалогового окна.)
	 </p>
	 
	 <p>
     Когда пользователь отвечает на запрос диалогового окна, отправляется соответствующее событие <codeph>status</codeph>. Также можно проверить свойство <codeph>Microphone.muted</codeph> для определения, предоставил пользователь доступ к микрофону или нет. 
	 </p>
	 
	 <p>
	 Если метод <codeph>Microphone.getMicrophone()</codeph> возвращает значение <codeph>null</codeph>, это значит, что микрофон используется другим приложением или в системе не установлены микрофоны. Чтобы узнать, установлены ли микрофоны, используйте <codeph>Microphones.names.length</codeph>. Чтобы отобразить панель «Настройки микрофона» проигрывателя Flash Player, где пользователь может выбрать микрофон для метода <codeph>Microphone.getMicrophone</codeph>, используйте метод <codeph>Security.showSettings()</codeph>. 
	 
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/event:status"><linktext>Microphone.status</linktext></link><link href="flash.net.xml#NetStream/attachAudio()"><linktext>flash.net.NetStream.attachAudio()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>flash.system.Security.showSettings()</linktext></link></related-links><adobeApiEvent id="flash.media:Microphone:getMicrophone_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда микрофон сообщает о своем состоянии. Если свойство <codeph>code</codeph> имеет значение <codeph>Microphone.Muted</codeph>, пользователь отказался предоставить SWF-файлу доступ к микрофону. Если свойство <codeph>code</codeph> имеет значение <codeph>Microphone.Unmuted</codeph>, пользователь предоставил SWF-файлу доступ к микрофону.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда микрофон сообщает о своем состоянии.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Microphone:setLoopBack"><apiName>setLoopBack</apiName><shortdesc>
	 Направляет записываемое микрофоном аудио на локальные динамики.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>state</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData></apiParam></apiOperationDef><apiDesc>
	 Направляет записываемое микрофоном аудио на локальные динамики.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.media:Microphone:setSilenceLevel"><apiName>setSilenceLevel</apiName><shortdesc>
	 Задает минимальный входной уровень, который будет обрабатываться как звук и (дополнительно) продолжительность тишины, по которой настоящую тишину можно будет отличить от паузы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setSilenceLevel, setSilenceLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>silenceLevel</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Уровень звука, необходимый для активации микрофона и передачи события <codeph>activity</codeph>. Диапазон допустимых значений – от 0 до 100. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Число миллисекунд, которое должно пройти без активности, прежде чем проигрыватель Flash Player или Adobe AIR зарегистрирует остановку звука и отправит событие <codeph>dispatch</codeph>. Значение по умолчанию 2000 (две секунды). (<b>Примечание</b>. Значение по умолчанию, показываемое в подписи, -1, – это внутреннее значение, предписывающее проигрывателю Flash Player или Adobe AIR использовать значение 2000.)
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает минимальный входной уровень, который будет обрабатываться как звук и (дополнительно) продолжительность тишины, по которой настоящую тишину можно будет отличить от паузы.
	 <ul>
	   <li>Чтобы микрофон совсем не улавливал звук, передайте значение 100 для <codeph>silenceLevel</codeph>; в этом случае событие <codeph>activity</codeph> никогда не отправляется. </li>
	   <li>Чтобы определить уровень звука, в данный момент улавливаемый микрофоном, используйте <codeph>Microphone.activityLevel</codeph>. </li>
	 </ul>
	 
	 <p>Обнаружение активности – это способность определять, когда уровень звука указывает на то, что пользователь говорит. Когда пользователь не говорит, можно экономить полосу пропускания, так как не требуется передавать соответствующий аудиопоток. Эти сведения также можно использовать для визуальной обратной связи, чтобы сообщить пользователям о том, что они (или другие) молчат.</p>
	 
	 <p>Значения тишины прямо соответствуют значениям активности. Полную тишину представляет значение активности 0. Постоянный громкий шум (настолько громкий, насколько это возможно зарегистрировать на основе текущей настройки усиления) соответствует значению активности 100. После соответствующей регулировки усиления значение активности составляет меньше, чем значение тишины, когда вы не говорите. Во время разговора значение активности превышает значение тишины.</p>
	 
	 <p>Этот метод похож на <codeph>Camera.setMotionLevel()</codeph>; они оба используются для определения момента отправки события <codeph>activity</codeph>. Однако эти методы имеют в значительной степени различное влияние на публикацию потоков.</p>
	 
	 <ul>
	   <li>Метод <codeph>Camera.setMotionLevel()</codeph> предназначен для определения движения и не влияет на использование полосы пропускания. Даже если видеопоток не обнаруживает движения, видео все равно передается.</li>
	 
	   <li>Метод <codeph>Microphone.setSilenceLevel()</codeph> предназначен для оптимизации использования полосы пропускания. Когда аудиопоток считается тихим, аудиоданные не передаются. Вместо этого отправляется одно сообщение, свидетельствующее о наступлении тишины. </li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>flash.media.Camera.setMotionLevel()</linktext></link><link href="flash.media.xml#Microphone/activityLevel"><linktext>flash.media.Microphone.activityLevel</linktext></link><link href="flash.media.xml#Microphone/event:activity"><linktext>flash.media.Microphone.activity</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/silenceLevel"><linktext>flash.media.Microphone.silenceLevel</linktext></link><link href="flash.media.xml#Microphone/silenceTimeout"><linktext>flash.media.Microphone.silenceTimeout</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Microphone:setUseEchoSuppression"><apiName>setUseEchoSuppression</apiName><shortdesc>
	 Определяет, используется ли функция эхокомпенсации аудиокодека.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.setUseEchoSuppression, setUseEchoSuppression
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>useEchoSuppression</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение, указывающее на то, должна ли использоваться эхокомпенсация (<codeph>true</codeph>) или нет (<codeph>false</codeph>). 	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, используется ли функция эхокомпенсации аудиокодека. Значение по умолчанию – <codeph>false</codeph>, если пользователь не выбрал «Уменьшить эхо» на панели «Параметры микрофона» проигрывателя Flash Player.
	 
	 <p>Эхокомпенсацией называется попытка уменьшить эффект звуковой обратной связи, возникающей при улавливании звука из динамика микрофоном, подключенным к тому же компьютеру. (Следует отличать эхокомпенсацию от эхоподавления, при котором обратная связь убирается полностью.)</p>
	 
	 <p>Как правило, эхокомпенсацию рекомендуется использовать, когда записываемый звук воспроизводится на том же компьютере через динамики, а не наушники. Если SWF-файл разрешает пользователям указывать устройство вывода звука, можно вызвать метод<codeph>Microphone.setUseEchoSuppression(true)</codeph>, если они используют динамики и собираются использовать микрофон. </p>
	 
	 <p>Пользователи могут также регулировать параметры на панели параметров микрофона проигрывателя Flash Player.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link><link href="flash.media.xml#Microphone/useEchoSuppression"><linktext>flash.media.Microphone.useEchoSuppression</linktext></link></related-links></apiOperation><apiValue id="flash.media:Microphone:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 Уровень звука, распознаваемый микрофоном.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.activityLevel, activityLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Уровень звука, распознаваемый микрофоном. Значения находятся в диапазоне от 0 (звук не определяется) до 100 (определяется очень громкий звук). Значение этого свойства помогает определить подходящее значение для передачи методу <codeph>Microphone.setSilenceLevel()</codeph>.
	 
	 <p>Если микрофон доступен, но не используется, потому что не вызван метод <codeph>Microphone.getMicrophone()</codeph>, это свойство имеет значение -1.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:codec:get"><apiName>codec</apiName><shortdesc>
	 Кодек для сжатия аудио.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.getCodec, getCodec
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Кодек для сжатия аудио. Доступные кодеки: Nellymoser (по умолчанию) и Speex. Класс перечисления <codeph>SoundCodec</codeph> содержит различные значения, действительные для свойства <codeph>codec</codeph>.
	 
	 <p>При использовании кодека Nellymoser можно установить частоту дискретизации с помощью <codeph>Microphone.rate()</codeph>. При использовании кодека Speex частота дискретизации составляет 16 кГц.</p>
	 
	 <p>Speex включает систему обнаружения речевой активности (Voice Activity Detection, VAD) и обеспечивает автоматическое уменьшение полосы пропускания при отсутствии речевой активности. При использовании кодека Speex компания Adobe рекомендует установить значение уровня тишины на 0. Для установки уровня тишины используйте метод <codeph>Microphone.setSilenceLevel()</codeph>.</p>
	 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()s"><linktext>setSilenceLevel()s</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:encodeQuality:get"><apiName>encodeQuality</apiName><shortdesc>
	 Качество зашифрованной речи при использовании кодека Speex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Качество зашифрованной речи при использовании кодека Speex. Допускаются значения от 0 до 10. Значением по умолчанию является 6. Более высокие значение подразумевают лучшее качество, но требуют большей пропускной способности в соответствии с таблицей ниже. Приведенные значения скорости потока являются чистыми значениями без учета данных пакетирования.
	 <p>
	  <adobetable class="innertable">
	 
	    
	    
	    
	    
	    
	    
	    
	    
	 
	    
	    
	  <tgroup cols="2"><thead><row><entry>Уровень качества</entry><entry>Необходимая скорость потока (килобит в секунду)</entry></row></thead><tbody><row>
	      <entry>0</entry>
	      <entry> 3.95</entry>
	    </row><row>
	      <entry>1</entry>
	      <entry>5.75</entry>
	    </row><row>
	      <entry>2</entry>
	      <entry>7.75</entry>
	    </row><row>
	      <entry>3</entry>
	      <entry>9.80</entry>
	    </row><row>
	      <entry>4</entry>
	      <entry>12.8</entry>
	    </row><row>
	      <entry>5</entry>
	      <entry>16.8</entry>
	    </row><row>
	      <entry>6</entry>
	      <entry>20.6</entry>
	    </row><row>
	      <entry>7</entry>
	      <entry>23.8</entry>
	    </row><row>
	 <entry>8</entry>
	 <entry>27.8</entry>
	    </row><row>
	      <entry>9</entry>
	      <entry>34.2</entry>
	    </row><row>
	      <entry>10</entry>
	      <entry>42.2</entry>
	    </row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>Кодек</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:framesPerPacket:get"><apiName>framesPerPacket</apiName><shortdesc>
	 Количество речевых кадров Speex, передаваемых в пакете (сообщении).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound,
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Количество речевых кадров Speex, передаваемых в пакете (сообщении). Длина каждого кадра составляет 20 мс. Значение по умолчанию – два кадра в пакете.
	 
	 <p>Чем больше кадров в сообщении Speex, тем уже необходимая полоса пропускания, но дольше задержка при отправке сообщения. При уменьшении количества кадров Speex увеличивается необходимая полоса пропускания, но сокращается задержка.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:gain:get"><apiName>gain</apiName><shortdesc>
	 Степень усиления сигнала микрофоном.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.gain, gain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Степень усиления сигнала микрофоном. Действительны значения от 0 до 100. Значением по умолчанию является 50.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:index:get"><apiName>index</apiName><shortdesc>
	 Индекс микрофона согласно содержимому массива, возвращаемого функцией Microphone.names.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.index, index
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Индекс микрофона согласно содержимому массива, возвращаемого функцией <codeph>Microphone.names</codeph>.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:muted:get"><apiName>muted</apiName><shortdesc>
	 Определяет наличие у пользователя доступа к микрофону: нет доступа (true), или доступ разрешен (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.muted, muted
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет наличие у пользователя доступа к микрофону: нет доступа (<codeph>true</codeph>), или доступ разрешен (<codeph>false</codeph>). При изменении этого значения отправляется событие <codeph>status</codeph>. Дополнительные сведения см. в описании метода <codeph>Microphone.getMicrophone()</codeph>. 
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/event:status"><linktext>flash.media.Microphone.status</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:name:get"><apiName>name</apiName><shortdesc>
	 Имя текущего устройства звукозаписи, возвращаемое данным устройством.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.name, name
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Имя текущего устройства звукозаписи, возвращаемое данным устройством.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.media.xml#Microphone/names"><linktext>flash.media.Microphone.names</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:names:get"><apiName>names</apiName><shortdesc>
	 Массив строк, содержащих имена всех доступных устройств звукозаписи.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.names, names
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Массив строк, содержащих имена всех доступных устройств звукозаписи. При возвращении имен пользователю не отображается панель параметров конфиденциальности. Этот массив передает индекс от нуля для каждого устройства звукозаписи и количество этих устройств в системе посредством свойства <codeph>Microphone.names.length</codeph>. Дополнительные сведения см. в разделе в описании класса Array.
	 
	 <p>Вызов метода <codeph>Microphone.names</codeph> требует обширного анализа аппаратных средств, и на составление массива может потребоваться несколько секунд. В большинстве случаев можно использовать микрофон по умолчанию.</p>
	 
	 <p><b>Примечание.</b> Для определения имени текущего микрофона используйте свойство <codeph>name</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Array"><linktext>Array</linktext></link><link href="flash.media.xml#Microphone/name"><linktext>flash.media.Microphone.name</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:rate:get"><apiName>rate</apiName><shortdesc>
	 Частота, с которой микрофон записывает звук, в кГц.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.rate, rate
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Частота, с которой микрофон записывает звук, в кГц. Допустимыми являются значения 5, 8, 11, 22 и 44. Значение по умолчанию – 8 кГц, если его поддерживает звукозаписывающее устройство. В противном случае, значением по умолчанию становится ближайший уровень записи выше 8 кГц, поддерживаемый звукозаписывающим устройством, обычно это 11 кГц. Flash Player 10 и AIR 1.5 или более поздней версии поддерживают частоту 16 кГц.
	 
	 <p><b>Примечание.</b> При использовании кодека Speex (<codeph>Microphone.codec = SoundCodec.SPEEX</codeph>) для Flashayer 10 и AIR 1.5 или более поздней версии значение частоты по умолчанию – 16 кГц. Если изменить значение используемого кодека со Speex на Nellymoser (<codeph>Microphone.codec = SoundCodec.NELLYMOSER</codeph>), частота будет иметь прежнее значение 16 кГц, пока явно не установить новое значение частоты. Для получения звука с помощью Flash Player более ранней версии, чем 10, и AIR более ранней версии, чем 1.5, необходимо при публикации звука изменить как значение кодека, так и значение частоты.</p>
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/codec"><linktext>flash.media.Microphone.codec</linktext></link><link href="flash.media.xml#SoundCodec"><linktext>flash.media.SoundCodec</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceLevel:get"><apiName>silenceLevel</apiName><shortdesc>
	 Уровень звука, необходимый для активации микрофона и передачи события activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceLevel, silenceLevel
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Уровень звука, необходимый для активации микрофона и передачи события <codeph>activity</codeph>. Значением по умолчанию является 10.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/gain"><linktext>flash.media.Microphone.gain</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:silenceTimeout:get"><apiName>silenceTimeout</apiName><shortdesc>
	 Число миллисекунд с момента, когда микрофон камера прекратила распознавать звук, до вызова события activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.silenceTimeout, silenceTimeout
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Число миллисекунд с момента, когда микрофон камера прекратила распознавать звук, до вызова события <codeph>activity</codeph>. Значение по умолчанию 2000 (две секунды).
	 
	 <p>Для установки этого значения используйте метод <codeph>Microphone.setSilenceLevel()</codeph>.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>flash.media.Microphone.setSilenceLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Microphone:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Управляет звуком этого объекта Microphone, когда микрофон работает в режиме петли.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Document this better with examples.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Управляет звуком этого объекта Microphone, когда микрофон работает в режиме петли.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Microphone:useEchoSuppression:get"><apiName>useEchoSuppression</apiName><shortdesc>
	 Возвращает true, если эхокомпенсация включена, в противном случае возвращает false.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Microphone, audio, sound, Microphone.useEchoSuppression, useEchoSuppression
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Возвращает <codeph>true</codeph>, если эхокомпенсация включена, в противном случае возвращает <codeph>false</codeph>. Значение по умолчанию – <codeph>false</codeph>, если пользователь не выбрал «Уменьшить эхо» на панели «Параметры микрофона» проигрывателя Flash Player.
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Microphone/setUseEchoSuppression()"><linktext>flash.media.Microphone.setUseEchoSuppression()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.media:scanHardware"><apiName>scanHardware</apiName><shortdesc>
	 Предписывает выполнить принудительное повторное сканирование микрофонов и камер системы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Предписывает выполнить принудительное повторное сканирование микрофонов и камер системы.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="flash.media:Camera"><apiName>Camera</apiName><shortdesc>
 Используйте класс Camera для записи видео с камеры, подключенной к компьютеру, на котором работает проигрыватель Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Используйте класс Camera для записи видео с камеры, подключенной к компьютеру, на котором работает проигрыватель Flash Player. Используйте класс Video для локального отслеживания видеоданных. Используйте классы NetConnection и NetStream для передачи видеоданных на сервер Flash Media Server. Flash Media Server может передавать видео другим серверам и транслировать его на другие клиентские компьютеры, на которых работает Flash Player.
 
 <p>
 Сведения о записи звука см. в описании класса Microphone.
 </p>
 
 <p>
 <b>Важно! </b>Проигрыватель Flash Player показывает диалоговое окно «Конфиденциальность», в котором пользователь может предоставить или запретить доступ к камере. Убедитесь в том, что размеры окна приложения составляют не менее 215 х 138 пикселей. Это минимальный размер, необходимый для отображения диалогового окна.
 </p>
 
 <p>Чтобы создать объект Camera или сослаться на него, используйте метод <codeph>getCamera()</codeph>.</p>
 
 </apiDesc><example conref="examples\CameraExample.as"> В следующем примере показывается изображение с камеры после подтверждения сообщения о безопасности. Настройка рабочей области не допускает масштабирования, он выровнен по верхнему левому углу окна проигрывателя. Событие <codeph>activity</codeph> отправляется при запуске и после окончания (если это применимо) сеанса методу <codeph>activityHandler()</codeph>, который печатает информацию о событии.
 
 <p><b>Примечание.</b> Для правильной работы примера к компьютеру должна быть подключена камера.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Camera;
    import flash.media.Video;

    public class CameraExample extends Sprite {
        private var video:Video;
        
        public function CameraExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            
            var camera:Camera = Camera.getCamera();
            
            if (camera != null) {
                camera.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
                video = new Video(camera.width * 2, camera.height * 2);
                video.attachCamera(camera);
                addChild(video);
            } else {
                trace("You need a camera.");
            }
        }
        
        private function activityHandler(event:ActivityEvent):void {
            trace("activityHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links><adobeApiEvent id="flash.media:Camera_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Отправляется, когда камера сообщает о своем состоянии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда камера сообщает о своем состоянии. Если свойство <codeph>code</codeph> имеет значение <codeph>Camera.Muted</codeph>, пользователь отказался предоставить SWF-файлу доступ к камере. Если свойство <codeph>code</codeph> имеет значение<codeph>Camera.Unmuted</codeph>, пользователь предоставил SWF-файлу доступ к камере.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>Camera.getCamera()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Camera_flash.events.ActivityEvent.ACTIVITY_activity"><apiName>activity</apiName><shortdesc>
 Отправляется, когда камера начинает или заканчивает сеанс.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ActivityEvent.ACTIVITY</apiEventType><adobeApiEventClassifier>flash.events.ActivityEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда камера начинает или заканчивает сеанс. Вызовите метод <codeph>Camera.setMotionLevel()</codeph>, чтобы задать уровень движения, необходимого для отправки события <codeph>activity</codeph> со свойством <codeph>activating</codeph> в значении<codeph>true</codeph>, или время без активности, которое должно пройти перед отправкой события <codeph>activity</codeph> со свойством <codeph>activating</codeph> в значении <codeph>false</codeph>.
 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:Camera:getCamera"><apiName>getCamera</apiName><shortdesc>
	 Возвращает ссылку на объект Camera для записи видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, constructor, Camera.getCamera, getCamera
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Если не задан параметр <codeph>name</codeph>, этот метод возвращает ссылку на камеру по умолчанию или, если она используется другим приложением, первую доступную камеру. (Если установлено несколько камер, пользователь может указать камеру по умолчанию на панели настроек камеры в проигрывателе Flash Player.) Если нет доступных или установленных камер, метод возвращает значение <codeph>null</codeph>. 
 	  
 	 </apiDesc><apiOperationClassifier>flash.media:Camera</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Задает, какую камеру использовать в соответствии с данными массива, возвращенного свойством <codeph>names</codeph>. Для большинства приложений можно получить камеру по умолчанию, опустив этот параметр. Чтобы задать значение для этого параметра, используйте строковое представление позиции индекса от нуля в массиве Camera.names. Например, чтобы задать третью камеру в массиве, укажите<codeph>Camera.getCamera("2")</codeph>. 
 	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает ссылку на объект Camera для записи видео. Для начала записи видео необходимо присоединить объект Camera к объекту Video (см. описание <codeph>Video.attachCamera() </codeph>). Для передачи видео на сервер Flash Media Server вызовите метод <codeph>NetStream.attachCamera()</codeph>, чтобы присоединить объект Camera к объекту NetStream.
	 
	 <p>Повторные вызовы метода <codeph>getCamera()</codeph> ссылаются на тот же драйвер камеры. Таким образом, если код содержит подобные значения: <codeph>firstCam:Camera = getCamera()</codeph> и <codeph>secondCam:Camera = getCamera()</codeph>, то и <codeph>firstCam</codeph> и <codeph>secondCam</codeph> ссылаются на одну и ту же камеру, которая используется по умолчанию.</p>
	 
	 <p>Как правило, не следует передавать значение для параметра <codeph>name</codeph>. Просто используйте метод <codeph>getCamera()</codeph>, который вернет ссылку на камеру по умолчанию. На панели параметров камеры (о ней будет говориться далее) пользователь может задать камеру по умолчанию для проигрывателя Flash Player. </p>
	 
  	 <p>Нельзя использовать ActionScript для задания параметра «Разрешить или запретить доступ» для использования камеры, однако можно отобразить диалоговое окно параметром камеры проигрывателя Adobe Flash Player, где пользователь может настроить разрешение для камеры. Когда SWF-файл, использующий метод <codeph>attachCamera()</codeph>, пытается присоединить камеру, возвращенную методом <codeph>getCamera()</codeph> к объекту Video или NetStream, проигрыватель Flash Player отображает диалоговое окно, в котором пользователь может предоставить или запретить доступ к камере. (Убедитесь в том, что размеры окна приложения составляют не менее 215 х 138 пикселей. Это минимальный размер, необходимый проигрывателю Flash Player для отображения диалогового окна.) Когда пользователь отвечает на запрос диалогового окна параметров камеры, проигрыватель Flash Player возвращает объект Info в событии <codeph>status</codeph> с ответом пользователя: <codeph>Camera.muted</codeph> говорит о том, что пользователь запретил доступ к камере; <codeph>Camera.Unmuted</codeph> указывает на то, что он предоставил доступ. Для определения, предоставил или запретил пользователь доступ к камере, не обрабатывая событие<codeph>status</codeph>, используйте свойство <codeph>muted</codeph>.</p>
  	 
 	 <p>Пользователь может задать постоянные параметры конфиденциальности для определенного домена: во время воспроизведения SWF-файла нужно щелкнуть правой кнопкой (Windows и Linux) мыши или нажать клавишу Control и щелкнуть мышью (Macintosh), выбрать «Параметры», открыть диалоговое окно «Конфиденциальность» и выбрать «Запомнить». Если пользователь выберет «Запомнить», проигрыватель Flash Player больше не будет спрашивать у него разрешения на доступ к камере для SWF-файлов из этого домена.</p>
  	 
  	 <p><b>Примечание.</b> Метод <codeph>attachCamera()</codeph> не будет вызывать диалоговое окно «Разрешить или запретить доступ к камере», если пользователь запретил доступ, выбрав «Запомнить» в окне настроек проигрывателя Flash Player. В этом случае можно попросить пользователя изменить настройки доступа, отобразив панель конфиденциальности Flash Player с помощью метода <codeph>Security.showSettings(SecurityPanel.PRIVACY)</codeph>.</p>
 	 
 	 <p>Если <codeph>getCamera()</codeph> возвращает значение <codeph>null</codeph>, это значит, что камера используется другим приложением или что в системе не установлены камеры. Определить, установлены ли камеры, можно с помощью свойства <codeph>names.length</codeph>. Для отображения панели параметров камеры в Flash Player, с помощью которой пользователь может выбрать камеру, на которую будет ссылаться метод <codeph>getCamera()</codeph>, используйте <codeph>Security.showSettings(SecurityPanel.CAMERA)</codeph>. </p>
 	 
	 <p>На сканирование аппаратных средств для камер требуется время. Когда проигрыватель Flash Player находит хотя бы одну камеру, он больше никогда не сканирует аппаратные средства для данного экземпляра проигрывателя. Однако если Flash Player не найдет камер, сканирование будет повторяться при каждом вызове метода <codeph>getCamera</codeph>. Это удобно, если пользователь забыл подключить камеру. Если в SWF-файле предусмотрена кнопка «Повторить попытку», которая вызывает <codeph>getCamera</codeph>, проигрыватель Flash Player сможет найти камеру без повторного запуска SWF-файла.</p>
 	 
	 </apiDesc><example conref="examples\Camera_getCameraExample.as"> В следующем примере после того, как пользователь разрешает доступ к камере, она используется для записи видеоизображений. Также отображается информация о видеопотоке, такая как текущая частота кадров.
 
 <p>Метод <codeph>Camera.getCamera()</codeph> возвращает ссылку на объект Camera или возвращает нуль, если камера недоступна или не установлена. Оператор if проверяет, обнаружена ли камера и предоставил ли пользователь доступ к ней. Если пользователь запрещает доступ, свойство <codeph>muted</codeph> получает значение <codeph>true</codeph>.</p> 
 
 <p>При вызове метода <codeph>attachCamera()</codeph> обычно появляется диалоговое окно с запросом доступа к камере для проигрывателя Flash Player. Однако, если пользователь запретил доступ и выбрал параметр <codeph>Remember</codeph>, диалоговое окно не появляется и ничего не отображается. Чтобы обеспечить пользователю возможность предоставить доступ к камере, текстовое поле <codeph>myTextField</codeph> дает пользователю указание щелкнуть текстовое поле, чтобы открыть диалоговое окно параметров проигрывателя Flash Player.</p>
 
 <p>Метод <codeph>clickHandler()</codeph> вызывает <codeph>Security.showSettings()</codeph>, отображающий панель <codeph>PRIVACY</codeph> диалогового окна настроек. Если пользователь предоставляет доступ, отправляется событие <codeph>StatusEvent.STATUS</codeph>, свойство<codeph>code</codeph> которого получает значение <codeph>Camera.Unmuted</codeph>. (Свойство <codeph>mute</codeph> объекта Camera также имеет значение <codeph>false</codeph>.)</p>
 
 <p>Метод <codeph>statusHandler()</codeph>, добавленный для прослушивания изменения состояния пользовательских настроек, вызывает метод <codeph>connectCamera()</codeph>, если пользователь предоставляет доступ. Метод <codeph>connectCamera()</codeph> создает экземпляр объекта Video с шириной и высотой записываемого потока. Для отображения видео, записываемого с камеры, ссылка на видеопоток добавляется к объекту Video, который в свою очередь добавляется в список отображения.</p>
 
 <p>Также запускается объект Timer. Каждую секунду отправляется событие timer объекта Timer, и вызывается метод <codeph>timerHandler()</codeph>. Метод <codeph>timerHandler()</codeph> отображается и обновляет ряд свойств объекта Camera. </p> 
 <p><b>Примечание.</b> В этом примере изменяется только свойство <codeph>currentFPS</codeph>.</p>    
    
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.StatusEvent;
    import flash.events.MouseEvent;
    import flash.system.SecurityPanel;
    import flash.system.Security;

    public class Camera_getCameraExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);
        
        public function Camera_getCameraExample() {
            myTextField = new TextField();
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";
                
            } else if (cam.muted) {
                myTextField.text = "To enable the use of the camera,\n"
                                 + "please click on this text field.\n" 
                                 + "When the Flash Player Settings dialog appears,\n"
                                 + "make sure to select the Allow radio button\n" 
                                 + "to grant access to your camera.";

                myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            }else {
                myTextField.text = "Connecting";
                connectCamera(); 
            }
   
            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            Security.showSettings(SecurityPanel.PRIVACY);

            cam.addEventListener(StatusEvent.STATUS, statusHandler);

            myTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function statusHandler(event:StatusEvent):void {

            if (event.code == "Camera.Unmuted") {
                connectCamera(); 
                cam.removeEventListener(StatusEvent.STATUS, statusHandler);
            }
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                t.start();
        }

        private function timerHandler(event:TimerEvent):void {
            myTextField.y = cam.height + 20;
            myTextField.text = "";
            myTextField.appendText("bandwidth: " + cam.bandwidth + "\n");
            myTextField.appendText("currentFPS: " + Math.round(cam.currentFPS) + "\n");
            myTextField.appendText("fps: " + cam.fps + "\n");
            myTextField.appendText("keyFrameInterval: " + cam.keyFrameInterval + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/muted"><linktext>muted</linktext></link><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links><adobeApiEvent id="flash.media:Camera:getCamera_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда камера сообщает о своем состоянии. Если свойство <codeph>code</codeph> имеет значение <codeph>Camera.Muted</codeph>, пользователь отказался предоставить SWF-файлу доступ к камере. Если свойство <codeph>code</codeph> имеет значение<codeph>Camera.Unmuted</codeph>, пользователь предоставил SWF-файлу доступ к камере.
 	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда камера сообщает о своем состоянии.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.media:Camera:setKeyFrameInterval"><apiName>setKeyFrameInterval</apiName><shortdesc>
	 Определяет, какие кадры видео передаются целиком (так называемые ключевые кадры), а не подвергаются интерполяции по алгоритму сжатия видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>keyFrameInterval</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение, определяющее, какие кадры видео передаются целиком (так называемые ключевые кадры), а не подвергаются интерполяции по алгоритму сжатия видео. Значение 1 указывает на то, что каждый кадр является ключевым, значение 3 – на то, что каждый третий файл является ключевым и т.д. Допускаются значения от 1 до 48.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, какие кадры видео передаются целиком (так называемые <i>ключевые кадры</i>), а не подвергаются интерполяции по алгоритму сжатия видео. Этот метод применим, только если видео передается через сервер Flash Media Server.
	 
	 <p>Алгоритм сжатия видеоданных проигрывателя Flash Video сжимает видео, передавая только то, что изменилось по сравнению с последним кадром. Такие порции называются интерполированными кадрами. Кадры видео могут подвергаться интерполяции в соответствии с содержимым предыдущего кадра. Однако ключевой кадр видео передается полностью, без интерполяции по предыдущим кадрам.</p> 
	 
	 <p>При определении, какое значение задать для параметра <codeph>keyFrameInterval</codeph>, необходимо учитывать использование полосы пропускания и доступность воспроизведения видео. Например, если задать для <codeph>keyFrameInterval</codeph> более высокое значение (то есть, отправлять ключевые кадры реже), уменьшится использование полосы пропускания. Однако при этом может требоваться больше времени на перемещения точки воспроизведения в требуемое положение видео, так как перед возобновлением воспроизведения необходимо выполнить интерполяцию большего числа предшествующих кадров.</p> 
	 
	 <p>И наоборот, если задать для <codeph>keyFrameInterval</codeph> более низкое значение (отправлять ключевые кадры чаще), то использование полосы пропускания увеличивается, так как чаще передаются полные кадры видео, однако при этом может сократиться время, необходимое на поиск требуемого кадра в видеозаписи.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/keyFrameInterval"><linktext>keyFrameInterval</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setLoopback"><apiName>setLoopback</apiName><shortdesc>
	 Определяет, должен ли использоваться сжатый видеопоток для локального представления камеры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>compress</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, должен использоваться сжатый (<codeph>true</codeph>) или несжатый видеопоток (<codeph>false</codeph>) для локального представления камеры.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, должен ли использоваться сжатый видеопоток для локального представления камеры. Этот метод применим, только если видео передается с помощью сервера Flash Media Server. Если задать свойству <codeph>compress</codeph> значение <codeph>true</codeph>, можно увидеть, как именно видео будет отображаться пользователям, просматривающим его в режиме реального времени.
	 
	 <p>Хотя сжатый поток удобен для тестирования, например для предварительного просмотра настроек качества видеопотока, он означает значительные затраты на обработку, так как локальный вид не просто сжимается: он сжимается, редактируется для передачи, как при реальном подключении, а затем распаковывается для локального просмотра.</p>
	 
	 <p>Чтобы задать уровень сжатия для использования вместе со свойством <codeph>compress</codeph> в значении <codeph>true</codeph>, используйте метод <codeph>Camera.setQuality()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMode"><apiName>setMode</apiName><shortdesc>
	 Задает для камеры собственный режим записи, наилучшим образом удовлетворяющий заданным требованиям.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMode, setMode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Требуемая ширина записи в пикселях. Значением по умолчанию является 160.	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Требуемая высота записи в пикселях. Значением по умолчанию является 120.	 
	 </apiDesc></apiParam><apiParam><apiItemName>fps</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Требуемая частота, с которой камера должна записывать данные (в кадрах в секунду). Значением по умолчанию является 15.	 
	 </apiDesc></apiParam><apiParam><apiItemName>favorArea</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>Определяет, должны изменяться настройки ширины, высоты и частоты кадров, если собственный режим камеры не соответствует заданным требованиям. Значение по умолчанию – <codeph>true</codeph>. Это значит, что предпочтение отдается сохранению размеров записи. При использовании этого параметра выбирается режим, наиболее близкий к значениям <codeph>width</codeph> и <codeph>height</codeph> даже если это негативно отражается на производительности из-за сокращения частоты кадров. Для увеличения частоты кадров за счет настроек высоты и ширины камеры передайте значение <codeph>false</codeph> для параметра <codeph>favorArea</codeph>.
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает для камеры собственный режим записи, наилучшим образом удовлетворяющий заданным требованиям. Если у камеры нет собственного режима, соответствующего всем переданным параметрам, проигрыватель Flash Player выбирает режим записи, наиболее близкий к запрашиваемому режиму. При такой манипуляции изображение может обрезаться, а кадры – пропускаться. 
	 
	 <p>По умолчанию Flash Player при необходимости пропускает кадры для сохранения размера изображения. Чтобы сократить число пропускаемых кадров, даже если это делается для уменьшения размера изображения, передайте значение <codeph>false</codeph> для параметра <codeph>favorArea</codeph>.</p>
	 
	 <p>При выборе собственного режима проигрыватель Flash Player пытается сохранить требуемое соотношение сторон, если это возможно. Например, если передается команда <codeph>myCam.setMode(400, 400, 30)</codeph>, а максимально доступные размеры камеры – 320 и 288, Flash Player задает и ширине и высоте значение 288. Задавая свойствам одинаковые значения, проигрыватель сохраняет требуемое соотношение сторон 1:1.</p>
	 
	 <p>Для определения значений, присвоенных этим свойствам после того, как проигрыватель Flash Player выберет режим, максимально соответствующий требуемым значениям, используйте свойства <codeph>width</codeph>, <codeph>height</codeph> и <codeph>fps</codeph>.</p>
	 
	 <p>
	 Если используется сервер Flash Media Server, можно также снимать отдельные кадры или делать покадровую съемку. Дополнительные сведения см. в описании метода <codeph>NetStream.attachCamera()</codeph>.
	 </p>
	 
	 </apiDesc><example conref="examples\Camera_setModeExample.as"> В следующем примере, когда пользователь щелкает по монтажному столу, размер видео изменяется, и скорость записи (в кадрах в секунду) получает новое значение.  
 
 <p>Рабочая область не масштабируется. Метод <codeph>Camera.getCamera()</codeph> возвращает ссылку на объект Camera или возвращает нуль, если камера недоступна или не установлена. Если камера существует, вызывается метод <codeph>connectCamera()</codeph>. Метод <codeph>connectCamera()</codeph> создает экземпляр объекта Video. Для отображения видео, записываемого с камеры, ссылка на видеопоток добавляется к объекту Video, который в свою очередь добавляется в список отображения. Создается прослушиватель для события <codeph>MouseEvent.CLICK</codeph>. Когда пользователь щелкает по рабочей области, запускается метод <codeph>clickHandler()</codeph>. Метод проверяет ширину записываемого видео и задает ширину, высоту и требуемую частоту кадров для режима камеры. Чтобы эти параметры вступили в силу, объект Video необходимо удалить и создавать заново. Ширина и высота видео также должны соответствовать ширине и высоте объекта Camera.</p>      
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.events.MouseEvent;
    import flash.display.StageScaleMode;

    public class Camera_setModeExample extends Sprite {
        private var cam:Camera;
        private var vid:Video;

        public function Camera_setModeExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;

            cam = Camera.getCamera();
            
            if (!cam) {
                trace("No camera is installed.");
            }else {
                connectCamera();
            }
        }

        private function connectCamera():void {
            vid = new Video();
            vid.width = cam.width;
            vid.height = cam.height; 
            vid.attachCamera(cam);
            addChild(vid);    

            stage.addEventListener(MouseEvent.CLICK, clickHandler);
        }
    
        private function clickHandler(e:MouseEvent):void {

            switch (cam.width) {
                case 160:
                cam.setMode(320, 240, 10); 
                break;
                case 320:
                cam.setMode(640, 480, 5); 
                break;
                default:
                cam.setMode(160, 120, 15); 
                break;
            } 

            removeChild(vid);           
            connectCamera();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/fps"><linktext>fps</linktext></link><link href="flash.media.xml#Camera/height"><linktext>height</linktext></link><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.net.xml#NetStream/attachCamera()"><linktext>flash.net.NetStream.attachCamera()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setMotionLevel"><apiName>setMotionLevel</apiName><shortdesc>
	 Задает количество движения, необходимое для отправки события activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.setMotionLevel, setMotionLevel
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>motionLevel</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Задает количество движения, необходимое для передачи события <codeph>activity</codeph>. Диапазон допустимых значений – от 0 до 100. Значением по умолчанию является 50.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>timeout</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>2000</apiData><apiDesc>Задает, сколько миллисекунд должно пройти без активности, прежде чем проигрыватель Flash Player определит, что активность прекратилась, и отправит событие <codeph>activity</codeph>. Значение по умолчанию 2000 миллисекунд (две секунды).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает количество движения, необходимое для отправки события <codeph>activity</codeph>. Дополнительно задает число миллисекунд, которое должно пройти без активности, прежде чем проигрыватель Flash Player зарегистрирует остановку движения и отправит событие. 
	 <p><b>Примечание. </b>Видео может отображаться независимо от значения параметра <codeph>motionLevel</codeph>. Этот параметр определяет только то, когда и при каких обстоятельствах отправляется событие, а не то, записывается или воспроизводится видео на самом деле.</p>
	 <p>
	 Чтобы камера совсем не улавливала движение, передайте значение 100 для <codeph>motionLevel</codeph>; в этом случае событие <codeph>activity</codeph> никогда не отправляется. (Скорее всего, это значение будет использоваться только для тестирования. Например, для временного отключения обработчиков, которые обычно запускаются при отправке события.)
	 </p>
	 <p>
	 Определить количество движения, определяемого камерой в настоящий момент можно с помощью свойства <codeph>activityLevel</codeph>. Значения чувствительности к движению прямо соответствуют значениям активности. При полном отсутствии движения свойство activity имеет значение 0. При постоянном движении свойство activity имеет значение 100. Значение активности меньше значения чувствительности к движению, если движения нет, тогда как во время движения значения активности часто превышают значение чувствительности к движению.
	 </p>
	 <p>
	 Этот метод имеет сходное применение с методом <codeph>Microphone.setSilenceLevel()</codeph>: они оба используются для определения, когда должно отправляться событие <codeph>activity</codeph>. Однако эти методы имеют в значительной степени различное влияние на публикацию потоков.
	 </p>
	 
	 <ul>
	   <li>Метод <codeph>Microphone.setSilenceLevel()</codeph> предназначен для оптимизации использования полосы пропускания. Когда аудиопоток считается тихим, аудиоданные не передаются. Вместо этого отправляется одно сообщение, свидетельствующее о наступлении тишины. </li>
	   <li>Метод <codeph>Camera.setMotionLevel()</codeph> предназначен для определения движения и не влияет на использование полосы пропускания. Даже если видеопоток не обнаруживает движения, видео все равно передается.</li>
	 </ul>
	   
	 
	 
	 </apiDesc><example conref="examples\Camera_setMotionLevelExample.as"> В следующем примере камера пользователя используется в качестве камеры слежения или обзора. Камера регистрирует движение и текстовое поле показывает уровень активности. (Пример можно расширить, добавив включение звукового сигнала или отправку сообщения через web-службу в другие приложения.)
 
 <p>Метод <codeph>Camera.getCamera()</codeph> возвращает ссылку на объект Camera или возвращает нуль, если камера недоступна или не установлена. Инструкция if проверяет, доступна ли камера, и, если да, вызывает метод <codeph>connectCamera()</codeph>. Метод <codeph>connectCamera()</codeph> создает экземпляр объекта Video с шириной и высотой записываемого потока. Для отображения видео, записываемого с камеры, ссылка на видеопоток добавляется к объекту Video, который в свою очередь добавляется в список отображения. (При вызове метода <codeph>attachCamera()</codeph> обычно появляется диалоговое окно с запросом доступа к камере для проигрывателя Flash Player. Однако, если пользователь запретил доступ и выбрал параметр <codeph>Remember</codeph>, диалоговое окно не появляется и ничего не отображается. Чтобы предоставить пользователю возможность разрешить доступ к камере, используйте метод <codeph>system.Security.showSettings()</codeph>, чтобы вызвать диалоговое окно параметров Flash Player.)</p>
 
 <p>Метод <codeph>setMotionLevel()</codeph> задает значение 5 для минимального уровня активности (количество движения), необходимого для отправки события activity. Интервал между прекращением регистрации движения и отправкой события activity равен одной секунде (1000 миллисекунд). Когда проходит одна секунда без активности или уровень активности достигает пяти, отправляется событие <codeph>ActivityEvent.ACTIVITY</codeph> и вызывается метод <codeph>activityHandler()</codeph>. Если событие запущено уровнем активности, свойство <codeph>activating</codeph> получает значение <codeph>true</codeph> и запускается объект Timer. Каждую секунду отправляется событие timer объекта Timer, и вызывается метод <codeph>timerHandler()</codeph>, отображающий текущий уровень активности. (Хотя таймер запускается при уровне, равном или больше 5, отображаемый текущий уровень активности может быть меньше.)</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Camera;
    import flash.media.Video;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.ActivityEvent;

    public class Camera_setMotionLevelExample extends Sprite {
        private var myTextField:TextField;
        private var cam:Camera;
        private var t:Timer = new Timer(1000);

        public function Camera_setMotionLevelExample() {
            myTextField = new TextField();
            myTextField.background = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;    
        
            cam = Camera.getCamera();
            
            if (!cam) {
                myTextField.text = "No camera is installed.";

            }else {
                myTextField.text = "Waiting to connect.";
                connectCamera(); 
            }

            addChild(myTextField);

            t.addEventListener(TimerEvent.TIMER, timerHandler);
        }

        private function connectCamera():void {
                var vid:Video = new Video(cam.width, cam.height);
                vid.x = 10;
                vid.y = 10;
                vid.attachCamera(cam);
                addChild(vid);    

                cam.setMotionLevel(5, 1000);
                cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);
        }

        private function activityHandler(e:ActivityEvent):void {
            if (e.activating == true) {
                t.start();    
            } else {
                myTextField.text = "Everything is quiet.";
                t.stop();
            }    
        }

        private function timerHandler(event:TimerEvent):void {
             myTextField.x = 10;
             myTextField.y = cam.height + 20;
             myTextField.text = "There is some activity. Level: " + cam.activityLevel;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/motionTimeout"><linktext>motionTimeout</linktext></link><link href="flash.media.xml#Microphone/setSilenceLevel()"><linktext>Microphone.setSilenceLevel()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Camera:setQuality"><apiName>setQuality</apiName><shortdesc>
	 Задает максимальную пропускную способность в секунду или требуемое качество картинки для текущего исходящего видеоканала.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera.setQuality, setQuality
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bandwidth</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Задает максимальную пропускную способность в секунду, которую может использовать текущий исходящий видеоканал (в байтах в секунду). Чтобы указать, что проигрыватель Flash Player может использовать любую пропускную способность, необходимую для сохранения значения свойства <codeph>quality</codeph>, передайте значение 0 для свойства <codeph>bandwidth</codeph>. Значением по умолчанию является 16384.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>quality</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Целое число, задающее требуемый уровень качества картинки, который определяется степенью сжатия, применяемой к каждому кадру видео. Допускаются значения от 1 (самое низкое качество и максимальное сжатие) до 100 (самое высокое качество без сжатия). Чтобы указать, что качество изображения может изменяться, чтобы избежать превышения пропускной способности, передайте 0 для свойства <codeph>quality</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает максимальную пропускную способность в секунду или требуемое качество картинки для текущего исходящего видеоканала. Как правило, этот метод применяется, только если видео передается через сервер Flash Media Server.
	 
	 <p>С помощью этого метода можно указать, какой элемент исходящего видеоканала важнее для приложения: использование пропускной способности или качество изображения.</p>
	 
	 <ul>
	   <li>Если предпочтение отдается использованию пропускной способности, передайте значение для <codeph>bandwidth</codeph> и 0 для <codeph>quality</codeph>. Проигрыватель Flash Player передает видео с максимально высоким качеством, возможным при заданной пропускной способности. При необходимости проигрыватель уменьшает качество изображения, чтобы не превышать пропускную способность. Как правило, при увеличении уровня движения качество снижается.</li>
	   <li>Если предпочтение отдается качеству, передайте 0 для <codeph>bandwidth</codeph> и числовое значение для <codeph>quality</codeph>. Проигрыватель Flash Player использует всю пропускную способность, необходимую для сохранения заданного качества. При необходимости проигрыватель снижает частоту кадров для сохранения качества изображения. Как правило, при увеличении уровня движения увеличивается и использование пропускной способности.</li>
	   <li>Если пропускная способность и качество одинаково важны, передайте числовые значения для обоих параметров. Проигрыватель Flash Player передает видео заданного качества, не превышающее заданной пропускной способности. При необходимости проигрыватель уменьшает частоту кадров для сохранения качества изображения без превышения заданной пропускной способности.</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/quality"><linktext>quality</linktext></link></related-links></apiOperation><apiValue id="flash.media:Camera:activityLevel:get"><apiName>activityLevel</apiName><shortdesc>
	 Порог интенсивности движения, определяемой камерой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Порог интенсивности движения, определяемой камерой. Допускаются значения от 0 (движение не регистрируется) до 100 (регистрируется большое количество движения). Значение этого свойства помогает определить, нужно ли передавать параметр для метода <codeph>setMotionLevel()</codeph>.
	 <p>Если камера доступна, но не используется, потому что не вызван метод <codeph>Video.attachCamera()</codeph>, это свойство имеет значение -1.</p>
	 <p>Если осуществляется потоковая передача только несжатого локального видео, это свойство задается, только если назначена функция для обработчика событий. В противном случае оно не определяется.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/motionLevel"><linktext>motionLevel</linktext></link><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:bandwidth:get"><apiName>bandwidth</apiName><shortdesc>
	 Максимальная пропускная способность в байтах, доступная для текущего исходящего видеоканала.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.bandwidth, bandwidth
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Максимальная пропускная способность в байтах, доступная для текущего исходящего видеоканала. Значение 0 указывает на то, что канал может использовать любую пропускную способность, необходимую для сохранения желаемого качества кадра.
	 <p>Это свойство можно задать с помощью метода <codeph>setQuality()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>	
	 Частота, с которой камера записывает данные (в кадрах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.currentFPS, currentFPS
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>	
	 Частота, с которой камера записывает данные (в кадрах в секунду). Это свойство задать нельзя, однако можно использовать метод <codeph>setMode()</codeph> для настройки связанного с ним свойства <codeph>fps</codeph>, которое задает максимальную частоту кадров, с которой камера должна записывать данные. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:fps:get"><apiName>fps</apiName><shortdesc>
	 Максимальная частота, с которой камера может записывать данные (в кадрах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.fps, fps
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Максимальная частота, с которой камера может записывать данные (в кадрах в секунду). Максимально возможная частота зависит от возможностей камеры. Иногда заданная частота не достигается.
	 <ul>
	   <li>Задать требуемое значение для этого свойства можно с помощью метода <codeph>setMode()</codeph>.</li>
	   <li>Определить скорость, с которой камера записывает данные в настоящий момент, можно с помощью свойства <codeph>currentFPS</codeph>.</li>
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/currentFPS"><linktext>currentFPS</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:height:get"><apiName>height</apiName><shortdesc>
	 Текущая высота записи в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.height, height
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Текущая высота записи в пикселях. Задать требуемое значение для этого свойства можно с помощью метода <codeph>setMode()</codeph>. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>width</linktext></link><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:index:get"><apiName>index</apiName><shortdesc>
	 Целое число, отсчитываемое от нуля, которым задается индекс камеры согласно содержимому массива, возвращаемого свойством names.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.index, index
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Целое число, отсчитываемое от нуля, которым задается индекс камеры согласно содержимому массива, возвращаемого свойством <codeph>names</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:keyFrameInterval:get"><apiName>keyFrameInterval</apiName><shortdesc>
	 Номер видеокадра, который передается целиком (так называемый ключевой кадр), а не подвергается интерполяции по алгоритму сжатия видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Номер видеокадра, который передается целиком (так называемый <i>ключевой кадр</i>), а не подвергается интерполяции по алгоритму сжатия видео. Значение по умолчанию — 15, то есть ключевым является каждый пятнадцатый кадр. Значение 1 указывает на то, что каждый кадр является ключевым. Допускаются значения от 1 до 48.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setKeyFrameInterval()"><linktext>setKeyFrameInterval()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:loopback:get"><apiName>loopback</apiName><shortdesc>
	 Определяет режим локального представления данных, записываемых камерой: подвергается сжатию и распаковке, как при прямой передаче с помощью Flash Media Server (true), или не подвергается сжатию (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет режим локального представления данных, записываемых камерой: подвергается сжатию и распаковке, как при прямой передаче с помощью Flash Media Server (<codeph>true</codeph>), или не подвергается сжатию (<codeph>false</codeph>). Значение по умолчанию <codeph>false</codeph>. 
	 
	 <p>
	 Хотя сжатый поток удобен для тестирования, например для просмотра параметров качества видеопотока, он означает значительные затраты на обработку. Локальный вид сжимается, редактируется для передачи, как при реальном подключении, а затем распаковывается для локального просмотра.
	 </p>
	 
	 <p>Задать это значение можно с помощью метода <codeph>Camera.setLoopback()</codeph>. Задать уровень сжатия, используемый при этом свойстве в значении true, можно с помощью метода <codeph>Camera.setQuality()</codeph>.</p>
	  
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setLoopback()"><linktext>setLoopback()</linktext></link><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionLevel:get"><apiName>motionLevel</apiName><shortdesc>
	 Задает количество движения, необходимое для отправки события activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionLevel, motionLevel
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Задает количество движения, необходимое для отправки события <codeph>activity</codeph>. Диапазон допустимых значений – от 0 до 100. Значением по умолчанию является 50.
	 <p>Видео может отображаться независимо от значения параметра <codeph>motionLevel</codeph>. Дополнительные сведения см. в описании метода <codeph> setMotionLevel()</codeph>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:motionTimeout:get"><apiName>motionTimeout</apiName><shortdesc>
	 Число миллисекунд с момента, когда камера прекратила распознавать движение, до момента передачи события activity.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.motionTimeout, motionTimeout
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Число миллисекунд с момента, когда камера прекратила распознавать движение, до момента передачи события <codeph>activity</codeph>. Значение по умолчанию 2000 (две секунды). 
	 <p>Задать это значение можно с помощью метода <codeph>setMotionLevel()</codeph>. </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMotionLevel()"><linktext>setMotionLevel()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:muted:get"><apiName>muted</apiName><shortdesc>
	 Логическое значение, показывающее, что пользователь запретил (true), или разрешил (false) доступ к камере в диалоговом окне «Конфиденциальность» проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.muted, muted
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Логическое значение, показывающее, что пользователь запретил (<codeph>true</codeph>), или разрешил (<codeph>false</codeph>) доступ к камере в диалоговом окне «Конфиденциальность» проигрывателя Flash Player. При изменении этого значения отправляется событие <codeph>status</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/event:status"><linktext>status</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:name:get"><apiName>name</apiName><shortdesc>
	 Имя текущей камеры, возвращенное самой камерой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Имя текущей камеры, возвращенное самой камерой.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/names"><linktext>names</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:names:get"><apiName>names</apiName><shortdesc>
	 Массив строк, отражающих имена всех доступных камер, без вывода диалогового окна «Конфиденциальность» проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.names, names
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Массив строк, отражающих имена всех доступных камер, без вывода диалогового окна «Конфиденциальность» проигрывателя Flash Player. Этот массив имеет такое же поведение, что и все массивы ActionScript: он неявно передает индекс каждой камеры, отсчитываемый от нуля, и количество камер в системе (с помощью <codeph>names.length</codeph>). Дополнительные сведения см. в разделе <codeph>names</codeph> в описании класса Array.
	 
	 <p>Вызов метода <codeph>names</codeph> требует обширного анализа аппаратных средств, и на составление массива может потребоваться несколько секунд. В большинстве случаев можно использовать камеру по умолчанию.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>getCamera()</linktext></link><link href="flash.media.xml#Camera/index"><linktext>index</linktext></link><link href="flash.media.xml#Camera/name"><linktext>name</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:quality:get"><apiName>quality</apiName><shortdesc>
	 Требуемый уровень качества изображения, который определяется степенью сжатия, применяемого к каждому кадру видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.quality, quality
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Требуемый уровень качества изображения, который определяется степенью сжатия, применяемого к каждому кадру видео. Допускаются значения качества от 1 (самое низкое качество и максимальное сжатие) до 100 (самое высокое качество без сжатия). Значение по умолчанию – 0, при котором качество изображения может по необходимости изменяться, чтобы не допустить превышения доступной пропускной способности.
	 
	 <p>Это свойство можно задать с помощью метода <codeph>setQuality()</codeph>.</p>
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setQuality()"><linktext>setQuality()</linktext></link></related-links></apiValue><apiValue id="flash.media:Camera:width:get"><apiName>width</apiName><shortdesc>
	 Текущая ширина записи в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Camera.width, width
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Текущая ширина записи в пикселях. Задать требуемое значение для этого свойства можно с помощью метода <codeph>setMode()</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/setMode()"><linktext>setMode()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
 Класс SoundTransform содержит свойства громкости и панорамирования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SoundTransform содержит свойства громкости и панорамирования. 
 
 </apiDesc><example conref="examples\SoundTransformExample.as"> В следующем примере загружается и воспроизводится МР3-файл. Во время воспроизведения МР3-файла двигайте мышь: громкость и панорама изменяются при перемещении мыши по рабочей области. Для запуска данного примера поместите файл MySound.mp3 в тот каталог, где находится рассматриваемый SWF-файл.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundTransformExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundTransformExample() {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.load(request);
            channel = soundFactory.play();
            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function setPan(pan:Number):void {
            trace("setPan: " + pan.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.pan = pan;
            channel.soundTransform = transform;
        }

        private function setVolume(volume:Number):void {
            trace("setVolume: " + volume.toFixed(2));
            var transform:SoundTransform = channel.soundTransform;
            transform.volume = volume;
            channel.soundTransform = transform;
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            var halfStage:uint = Math.floor(stage.stageWidth / 2);
            var xPos:uint = event.stageX;
            var yPos:uint = event.stageY;
            var value:Number;
            var pan:Number;

            if (xPos > halfStage) {
                value = xPos / halfStage;
                pan = value - 1;
            } else if (xPos &lt; halfStage) {
                value = (xPos - halfStage) / halfStage;
                pan = value;
            } else {
                pan = 0;
            }

            var volume:Number = 1 - (yPos / stage.stageHeight);

            setVolume(volume);
            setPan(pan);
            
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#SimpleButton/soundTransform"><linktext>flash.display.SimpleButton.soundTransform</linktext></link><link href="flash.display.xml#Sprite/soundTransform"><linktext>flash.display.Sprite.soundTransform</linktext></link><link href="flash.media.xml#Microphone/soundTransform"><linktext>flash.media.Microphone.soundTransform</linktext></link><link href="flash.media.xml#SoundChannel/soundTransform"><linktext>flash.media.SoundChannel.soundTransform</linktext></link><link href="flash.media.xml#SoundMixer/soundTransform"><linktext>flash.media.SoundMixer.soundTransform</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link></related-links><apiConstructor id="flash.media:SoundTransform:SoundTransform"><apiName>SoundTransform</apiName><shortdesc>
	 Создает объект SoundTransform.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vol</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>Громкость от 0 (тишина) до 1 (полная громкость).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>panning</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Панорамирование звука слева направо, в диапазоне от -1 (полная панорама слева) до 1 (полная панорама справа). Значение 0 указывает на отсутствие панорамы (по центру). 
	 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает объект SoundTransform. 
	 
	 </apiDesc><example conref="examples\SoundTransform_constructorExample.as"> В следующем примере звук воспроизводится только правым каналом, громкость установлена на 50 процентов.
 
 <p>Конструктор загружает звук и назначает его звуковому каналу (<codeph>channel</codeph>). Также создается объект SoundTranform (<codeph>transform</codeph>). Его первый аргумент устанавливает громкость на 50 процентов (диапазон значений – от 0,0 до 1,0). Второй аргумент задает панораму. В этом примере панорама имеет значение 1,0, то есть звук выводится только из правого динамика. Чтобы эти параметры вступили в силу объект SoundTranform с именем <codeph>transform</codeph> назначается свойству <codeph>soundTransform</codeph> звукового канала.</p> 
<p> <b>Примечание.</b> Для этого примера определена ограниченная обработка ошибок.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundTransform;
    import flash.events.IOErrorEvent;

    public class SoundTransform_constructorExample extends Sprite
    {
        public function SoundTransform_constructorExample() {
            var mySound:Sound = new Sound();
            var url:URLRequest = new URLRequest("mySound.mp3");
            var channel:SoundChannel;
            var transform:SoundTransform = new SoundTransform(0.5, 1.0);

            mySound.load(url);    
            channel = mySound.play();
            channel.soundTransform = transform;

            mySound.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundTransform:leftToLeft:set"><apiName>leftToLeft</apiName><shortdesc>
	 Значение от 0 (нет) до 1 (все), указывающее, какая доля левого входа воспроизводится в левом динамике.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение от 0 (нет) до 1 (все), указывающее, какая доля левого входа воспроизводится в левом динамике.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:leftToRight:set"><apiName>leftToRight</apiName><shortdesc>
	 Значение, от 0 (нет) до 1 (все), указывающее, какая доля левого входа воспроизводится в правом динамике.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение, от 0 (нет) до 1 (все), указывающее, какая доля левого входа воспроизводится в правом динамике.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:pan:set"><apiName>pan</apiName><shortdesc>
	 Панорамирование звука слева направо, в диапазоне от -1 (полная панорама слева) до 1 (полная панорама справа).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Панорамирование звука слева направо, в диапазоне от -1 (полная панорама слева) до 1 (полная панорама справа). Значение 0 представляет отсутствие панорамы (сбалансированный центр между правым и левым каналами).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToLeft:set"><apiName>rightToLeft</apiName><shortdesc>
	 Значение от 0 (нет) до 1 (все), указывающее, какая доля правого входа воспроизводится в левом динамике.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение от 0 (нет) до 1 (все), указывающее, какая доля правого входа воспроизводится в левом динамике.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:rightToRight:set"><apiName>rightToRight</apiName><shortdesc>
	 Значение от 0 (нет) до 1 (все), указывающее, какая доля правого входа воспроизводится в правом динамике.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение от 0 (нет) до 1 (все), указывающее, какая доля правого входа воспроизводится в правом динамике.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundTransform:volume:set"><apiName>volume</apiName><shortdesc>
	 Громкость от 0 (тишина) до 1 (полная громкость).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Громкость от 0 (тишина) до 1 (полная громкость).
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.media:Sound"><apiName>Sound</apiName><shortdesc>
  Класс Sound позволяет работать со звуком в приложении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  Класс Sound позволяет работать со звуком в приложении. Класс Sound позволяет создавать объект Sound, загружать в него и воспроизводить внешние МР3-файлы, закрывать поток звука и получать данные о звуке, такие как сведения о количестве байтов в потоке и метаданные ID3. Более детальное управление звуком выполняется через источник звука (объект SoundChannel или Microphone звука) и через свойства класса SoundTransform, управляющего выводом звука на динамики компьютера. 
  
  <p>В проигрывателе Flash Player 10 и более поздних версий и в AIR 1.5 и более поздних версий этот класс можно также использовать для работы с динамически создаваемым звуком. В таком случае объект Sound использует функцию, назначенную обработчику события <codeph>sampleData</codeph>, для выполнения опроса на наличие звуковых данных. Звук воспроизводится по мере его извлечения из объекта ByteArray, наполненного звуковыми данными. Можно также использовать метод <codeph>Sound.extract()</codeph> для извлечения данных из объекта Sound, которые можно обработать перед записыванием в поток для воспроизведения.</p>
  
  <p>Для управления звуками, встроенными в SWF-файл используются свойства класса SoundMixer.</p>
  
  <p platform="actionscript"><b>Примечание.</b> Звуковой API-интерфейс в ActionScript 3.0 отличается от такового в ActionScript 2.0. В ActionScript 3.0 невозможно организовывать объекты Sound в виде иерархии для управления их свойствами.</p>
  
  <p>При использовании данного класса необходимо учесть следующую модель безопасности: </p>
  
  <ul>
  
      <li>Загрузка и воспроизведение звука запрещены, если вызывающий файл находится в изолированной программной среде сети, а звуковой файл для загрузки сохранен на локальном компьютере.</li>
  
      <li>По умолчанию загрузка и воспроизведение звука не разрешены, если вызывающий локальный файл пытается загрузить и воспроизвести удаленный звук. Пользователь должен явно определить права, чтобы разрешить этот тип доступа.</li>
  
      <li>Запрещены определенные операции со звуком. Данные в загруженном звуке не могут быть получены файлом, находящимся в другом домене, если не используется файл междоменной политики. Данное ограничение распространяется на следующие API-интерфейсы для работы со звуком: <codeph>Sound.id3</codeph>, <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph> и класс <codeph>SoundTransform</codeph>.</li>
  
  </ul>
  
  <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p>
  
  <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
  
  <ul>
  
  <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
  <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
  
    <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
  
  </ul>
  
  </apiDesc><example conref="examples\SoundExample.as"> В следующем примере отображаются сведения о звуковых событиях, происходящих по мере открытия и воспроизведения МР3-файла. Для запуска данного примера поместите файл MySound.mp3 в тот каталог, где находится рассматриваемый SWF-файл.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;

    public class SoundExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var song:SoundChannel;

        public function SoundExample() {
            var request:URLRequest = new URLRequest(url);
            var soundFactory:Sound = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);
            song = soundFactory.play();
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.media.xml#Microphone"><linktext>Microphone</linktext></link><link href="flash.media.xml#SoundChannel"><linktext>SoundChannel</linktext></link><link href="flash.media.xml#SoundMixer"><linktext>SoundMixer</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:Sound_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Отправляется в случае получения данных в ходе операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется в случае получения данных в ходе операции загрузки.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Отправляется при запуске операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при запуске операции загрузки.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.ID3_id3"><apiName>id3</apiName><shortdesc>
 Отправляется объектом Sound, если для звука в формате MP3 доступны данные ID3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ID3</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется объектом Sound, если для звука в формате MP3 доступны данные ID3. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/id3"><linktext>Sound.id3</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Отправляется после успешной загрузки данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после успешной загрузки данных. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.media:Sound_flash.events.Event.SAMPLE_DATA_sampleData"><apiName>sampleData</apiName><shortdesc>
  Отправляется при запросе проигрывателем новых аудиоданных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SAMPLE_DATA</apiEventType><adobeApiEventClassifier>flash.events.SampleDataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Отправляется при запросе проигрывателем новых аудиоданных. 
 
 </apiDesc><example conref="examples\Sound_SampleDataExample.as"> Следующий пример воспроизводит простую гармоническую волну.
 
<codeblock>
var mySound:Sound = new Sound();
function sineWaveGenerator(event:SampleDataEvent):void {
    for ( var c:int=0; c&lt;8192; c++ ) {
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
        event.data.writeFloat(Math.sin((Number(c+event.position)/Math.PI/2))*0.25);
    }
}

mySound.addEventListener(Event.SAMPLE_DATA,sineWaveGenerator);
mySound.play();
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.media.xml#Sound/extract()"><linktext>extract()</linktext></link><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.events.xml#SampleDataEvent"><linktext>flash.events.SampleDataEvent</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.media:Sound:Sound"><apiName>Sound</apiName><shortdesc>
     Создает новый объект Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc> URL-адрес, указывающий на внешний МР3-файл.
     
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> Дополнительный объект контекста SoundLoader, который может задать время буферизации (минимальное число миллисекунд, в течение которых данные MP3 будут храниться в буфере объекта Sound) и указать, следует ли приложению проверять наличие файла междоменной политики перед загрузкой звука.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект Sound. При передаче действительного объекта URLRequest конструктору Sound он автоматически вызывает функцию <codeph>load()</codeph> для объекта Sound. Если конструктору Sound не передается действительный объект URLRequest, необходимо самостоятельно вызвать функцию <codeph>load()</codeph> для объекта Sound, иначе поток не загрузится.
     
     <p>После вызова <codeph>load()</codeph> для объекта Sound невозможно загрузить другой звуковой файл в этот объект. Для загрузки другого звукового файла необходимо создать новый объект Sound.</p>
     
     В проигрывателе Flash Player 10 и более поздних версий, а также в AIR 1.5 и более поздних версий, вместо метода <codeph>load()</codeph> можно использовать обработчик событий <codeph>sampleData</codeph> для динамической загрузки звука в объект Sound.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Sound:close"><apiName>close</apiName><shortdesc>
     Закрывает поток, в результате чего загрузка данных прекращается.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Не удалось закрыть поток или поток не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Закрывает поток, в результате чего загрузка данных прекращается. После вызова метода <codeph>close()</codeph> данные из потока не считываются.
     
     </apiDesc><example conref="examples\Sound_closeExample.as"> В следующем примере, когда пользователь нажимает кнопку «Стоп», вызывается метод <codeph>Sound.close()</codeph> и поток звука останавливается.
 
 <p>В конструкторе создается текстовое поле для кнопки «Пуск» и «Стоп». Когда пользователь щелкает текстовое поле, вызывается метод <codeph>clickHandler()</codeph>. Он обрабатывает запуск и остановку воспроизведения звукового файла. Обратите внимание, что в зависимости от сетевого подключения или времени нажатия кнопки «Стоп» большая часть файла может быть уже загружена и на остановку воспроизведения звукового файла может потребоваться время. Для перехвата возможных ошибок ввода/вывода при закрытии потока используется блок <codeph>try...catch</codeph>. Например, если звук загружается из локального каталога и поток не передается, перехватывается ошибка 2029 с сообщением «Объект URLStream не имеет открытого канала».</p> 
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;    
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;

    public class Sound_closeExample extends Sprite {
        private var snd:Sound = new Sound();
        private var button:TextField = new TextField();
        private var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
        
        public function Sound_closeExample() {
            button.x = 10;
            button.y = 10;
            button.text = "START";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.LEFT;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {

            if(button.text == "START") {

                snd.load(req);
                snd.play();        

                snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);

                button.text = "STOP";
            }
            else if(button.text == "STOP") {
                    
                try {
                    snd.close();
                    button.text = "Wait for loaded stream to finish.";
                }
                catch (error:IOError) {
                    button.text = "Couldn't close stream " + error.message;    
                }
            }
        }
        
        private function errorHandler(event:IOErrorEvent):void {
                button.text = "Couldn't load the file " + event.text;
        }
    }
}


</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:extract"><apiName>extract</apiName><shortdesc>
      Извлекает необработанные звуковые данные из объекта Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Количество доступных образцов в объекте Sound.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, в котором размещаются извлеченные звуковые образцы.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Количество звуковых образцов для извлечения. Образец содержит и левый, и правый канал – т. е. два 32-разрядных значения с плавающей запятой.
          
     </apiDesc></apiParam><apiParam><apiItemName>startPosition</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>-1</apiData><apiDesc>Образец, с которого начинается извлечение. Если не указать значение, первый вызов метода <codeph>Sound.extract()</codeph> начнет извлечение с начала звука; последующие вызовы метода <codeph>startPosition</codeph> без указания значения продолжат последовательное извлечение данных из файла.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
      Извлекает необработанные звуковые данные из объекта Sound.
     
      <p>Данный метод предназначен для использования при работе с динамическими данными, используя функцию, назначенную событию <codeph>sampleData</codeph>, для другого объекта Sound. То есть можно использовать этот метод для извлечения звуковых данных из объекта Sound. Затем можно записать данные в массив байтов, который другой объект Sound использует для потокового воспроизведения динамического звука.</p>
     
      <p>Звуковые данные будут помещены в целевой массив байтов, начиная с текущей позиции массива. Аудиоданные всегда представлены в формате стереозвучания с частотой дискретизации 44 100 Гц. Образец имеет значение типа 32-разрядного числа с плавающей запятой, которое может быть преобразовано в значение типа «число» при помощи метода <codeph>ByteArray.readFloat()</codeph>. </p>
     
     </apiDesc><example conref="examples\Sound_extractExample.as"> В следующем примере выполняется загрузка файла mp3 и используется метод <codeph>extract()</codeph> класса Sound для доступа к звуковым данным.
 <p>Данные mp3 загружены в объект Sound – <codeph>sourceSnd</codeph>. Когда приложение загружает данные mp3, оно вызывает функцию <codeph>loaded()</codeph> (обработчик событий для события <codeph>complete</codeph> объекта <codeph>sourceSnd</codeph>). Второй объект Sound, <codeph>outputSound</codeph>, используется для воспроизведения измененного звука. Объект <codeph>outputSound</codeph> имеет прослушиватель событий <codeph>sampleData</codeph>; поэтому объект выполняет отправку периодических событий <codeph>sampleData</codeph> после вызова метода <codeph>play()</codeph> объекта. Метод <codeph>upOctave()</codeph> возвращает массив байтов измененных звуковых данных на основе исходных звуковых данных. Он возвращает звук, который на одну октаву выше, за счет пропуска каждого второго звукового сэмпла в исходных данных. Обработчик событий для события <codeph>sampleData</codeph> записывает возвращенный массив байтов в свойство <codeph>data</codeph> объекта <codeph>outputSound</codeph>. Массив байтов <codeph>data</codeph> добавляется к выходным звуковым данным для объекта <codeph>outputSound</codeph>.</p>
 <p>Чтобы проверить этот пример, добавьте файл test.mp3 в каталог, в котором находится SWF-файл.</p>
<codeblock>

var sourceSnd:Sound = new Sound();
var outputSnd:Sound = new Sound();
var urlReq:URLRequest = new URLRequest("test.mp3");

sourceSnd.load(urlReq);
sourceSnd.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void
{
    outputSnd.addEventListener(SampleDataEvent.SAMPLE_DATA, processSound);
    outputSnd.play();
}

function processSound(event:SampleDataEvent):void
{
    var bytes:ByteArray = new ByteArray();
    sourceSnd.extract(bytes, 4096);
    event.data.writeBytes(upOctave(bytes));
}

function upOctave(bytes:ByteArray):ByteArray
{
    var returnBytes:ByteArray = new ByteArray();
    bytes.position = 0;
    while(bytes.bytesAvailable > 0)
    {
        returnBytes.writeFloat(bytes.readFloat());
        returnBytes.writeFloat(bytes.readFloat());
        if (bytes.bytesAvailable > 0)
        {
            bytes.position += 8;
        }
    }
    return returnBytes;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#Sound/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Sound/event:sampleData"><linktext>sampleData</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Sound:load"><apiName>load</apiName><shortdesc>
     Инициирует загрузку внешнего файла MP3 с заданного URL-адреса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Сетевая ошибка помешала загрузке файла.
	 
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Локальные ненадежные файлы изолируются от Интернета. Этого можно избежать, если переклассифицировать этот файл как <ph platform="actionscript">локальный с сетевым подключением</ph> или доверенный.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Значением свойства <codeph>digest</codeph> объекта <codeph>stream</codeph> не является <codeph>null</codeph>. Свойство <codeph>digest</codeph> объекта URLRequest следует задавать только при вызове метода <codeph>URLLoader.load()</codeph> во время загрузки SWZ-файла (компонент платформы Adobe).
     
      </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stream</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> URL-адрес, указывающий на внешний МР3-файл.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.media:SoundLoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc> Дополнительный объект контекста SoundLoader, который может задать время буферизации (минимальное число миллисекунд, в течение которых данные MP3 будут храниться в буфере объекта Sound) и указать, следует ли приложению проверять наличие файла междоменной политики перед загрузкой звука.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Инициирует загрузку внешнего файла MP3 с заданного URL-адреса. При передаче действительного объекта URLRequest конструктору Sound он сам вызывает <codeph>Sound.load()</codeph>. Вызывать <codeph>Sound.load()</codeph> самостоятельно нужно только тогда, когда классу Sound не передан объект URLRequest или передано значение <codeph>null</codeph>.
     
     <p>После вызова <codeph>load()</codeph> для объекта Sound невозможно загрузить другой звуковой файл в этот объект. Чтобы загрузить другой звуковой файл, нужно создать новый объект Sound.</p>
     
	 <p platform="actionscript">При использовании данного метода необходимо учесть следующую модель безопасности:</p>
     
     <ul platform="actionscript">
     
     <li>Вызов метода <codeph>Sound.load()</codeph> запрещен, если вызывающий файл находится в локальной для файловой системы изолированной программной среде, а звук – в сетевой изолированной программной среде.</li>
     
     <li>Для доступа из доверенной локальной среды, или изолированной локальной среды с сетевым подключением, требуется разрешение web-сайта, которое можно получить с помощью файла политики URL-адресов.</li>
     
      <li>Невозможно подключиться к зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>. </li>
     
     <li>Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</li>
     
     </ul>
     
     <p platform="actionscript"> В приложении Flash Player 10 и более поздней версии при использовании типа содержимого multipart (например, multipart/form-data), в котором содержится отправка (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для отправок:</p>
	 <ul platform="actionscript">
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p platform="actionscript">Кроме того, все объекты multipart Content-Type должны иметь допустимый синтаксис (в соответствии со стандартами RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для отправок.</p>
     <p platform="actionscript">В Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
     
     <p platform="actionscript">Дополнительные сведения по обеспечению безопасности см. в следующих источниках.</p>
     
     <ul platform="actionscript">
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li>Раздел «Understanding AIR Security» (Сведения о безопасности AIR) главы «Getting started with Adobe AIR» (Начало работы с Adobe AIR) книги <i>Developing AIR Applications</i> (Разработка приложений AIR).</li>
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\Sound_loadExample.as"> В следующем примере демонстрируется процесс загрузки звукового файла.
 
 <p>В конструкторе создается объект <codeph>URLRequest</codeph>, чтобы указать местоположение звукового файла – подкаста компании Adobe. Файл загружается в блок <codeph>try...catch</codeph>, чтобы перехватить возможные ошибки при загрузке. В случае ошибки ввода/вывода вызывается метод <codeph>errorHandler()</codeph>, и в текстовом поле отчета о прогрессе отображается сообщение об ошибке. По мере выполнения загрузки отправляется событие <codeph>ProgressEvent.PROGRESS</codeph>, и вызывается метод <codeph>progressHandler()</codeph>. В данном случае событие <codeph>ProgressEvent.PROGRESS</codeph> используется в качестве таймера для расчета прогресса загрузки.</p> 
  
 <p>Метод <codeph>progressHandler()</codeph> делит значение <codeph>bytesLoaded</codeph>, переданное с объектом <codeph>ProgressEvent</codeph>, на значение <codeph>bytesTotal</codeph>, чтобы вычислить процент загружаемых звуковых данных. Затем эти значения отображаются в текстовом поле. (Обратите внимание, что если файл небольшой, сохранен в кэше или находится в локальном каталоге, то прогресс может быть незаметным.)</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.ProgressEvent;
    import flash.events.IOErrorEvent;
    
    public class Sound_loadExample extends Sprite {
        private var snd:Sound = new Sound();
        private var statusTextField:TextField  = new TextField();

        public function Sound_loadExample(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
            snd.load(req);
            
            snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(ProgressEvent.PROGRESS, progressHandler);
                     
            this.addChild(statusTextField);
        }
    
        private function progressHandler(event:ProgressEvent):void {
            var loadTime:Number = event.bytesLoaded / event.bytesTotal;
            var LoadPercent:uint = Math.round(100 * loadTime);
              
            statusTextField.text = "Sound file's size in bytes: " + event.bytesTotal + "\n" 
                                 + "Bytes being loaded: " + event.bytesLoaded + "\n" 
                                 + "Percentage of sound file that is loaded " + LoadPercent + "%.\n";
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.media:Sound:play"><apiName>play</apiName><shortdesc>
     Создает новый объект SoundChannel для воспроизведения звука.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект SoundChannel, используемый для управления звуком. Этот метод возвращает значение <codeph>null</codeph>, если не установлена звуковая карта или нет доступных аудиоканалов. Одновременно доступно не больше 32 каналов.
     
     </apiDesc><apiOperationClassifier>flash.media:SoundChannel</apiOperationClassifier></apiReturn><apiParam><apiItemName>startTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>Исходное положение в миллисекундах, с которого должно начинаться воспроизведение.
     </apiDesc></apiParam><apiParam><apiItemName>loops</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Определяет, сколько раз звук возвращается к значению <codeph>startTime</codeph>, прежде чем прекратится воспроизведение звукового канала. 
     </apiDesc></apiParam><apiParam><apiItemName>sndTransform</apiItemName><apiOperationClassifier>flash.media:SoundTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>Исходный объект SoundTransform, назначенный для звукового канала.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Создает новый объект SoundChannel для воспроизведения звука. Этот метод возвращает объект SoundChannel, к которому нужно обращаться, чтобы остановить воспроизведение или отрегулировать громкость. (Чтобы управлять громкостью, панорамой и балансом, необходимо использовать объект SoundTransform, назначенный звуковому каналу.)
     
     </apiDesc><example conref="examples\Sound_playExample1.as"> В следующем примере после загрузки файла пользователь может выбрать начальное положение (время начала) звукового файла с помощью графической полосы.
 
 <p>Конструктор вызывает метод <codeph>Sound.load()</codeph>, чтобы начать загрузку звуковых данных. Затем вызывается метод <codeph>Sound.play()</codeph>, который начнет воспроизведение, как только будет загружено достаточно данных. Метод <codeph>Sound.play()</codeph> возвращает объект SoundChannel, с помощью которого можно управлять воспроизведением звука. В текстовом поле отображаются инструкции. Чтобы убедиться, что содержимое, с которого пользователь хочет начать воспроизведение звука, уже загружено, создается объект Sprite с именем <codeph>bar</codeph> и отображается после завершения загрузки файла. После успешной загрузки файла отправляется событие <codeph>Event.COMPLETE</codeph>, которое запускает метод <codeph>completeHandler()</codeph>. Затем метод <codeph>completeHandler()</codeph> создает полосу прокрутки и добавляет ее в список отображения. (Чтобы обеспечить интерактивные возможности, вместо объекта Shape используется объект Sprite.) Когда пользователь щелкает по полосе прокрутки, запускается метод <codeph>clickHandler()</codeph>.</p> 
 
 <p>В методе <codeph>clickHandler()</codeph> положение по оси Х (<codeph>event.localX</codeph>), в котором пользователь щелкает мышкой, используется для определения начальной точки воспроизведения. Так как длина полосы прокрутки составляет 100 пикселей, и она начинается в точке 100 по оси Х, нетрудно вычислить точку воспроизведения в процентном соотношении. Кроме того, файл уже загружен, и поэтому свойство <codeph>length</codeph> звукового файла будет иметь значение длины полного файла в миллисекундах. Имея длину файла и положение на линии, можно определить начальное положение для звукового файла. После остановки воспроизведения звука файл запускается снова с выбранного начального положения, переданного в качестве параметра <codeph>startTime</codeph> метода <codeph>play()</codeph>.</p>
 
<codeblock> 
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.MouseEvent;
    import flash.media.Sound;;
    import flash.net.URLRequest;
    import flash.media.SoundChannel;
    import flash.events.ProgressEvent;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample1 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var infoTextField:TextField = new TextField();
    
        public function Sound_playExample1() {

            var req:URLRequest = new URLRequest("MySound.mp3");
            
            infoTextField.autoSize = TextFieldAutoSize.LEFT;
            infoTextField.text = "Please wait for the file to be loaded.\n" 
                                + "Then select from the bar to decide where the file should start.";
            
            snd.load(req);               
            channel = snd.play();

            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            snd.addEventListener(Event.COMPLETE, completeHandler);


            this.addChild(infoTextField);
        }

        private function completeHandler(event:Event):void {                
            infoTextField.text = "File is ready.";

            var bar:Sprite = new Sprite();

            bar.graphics.lineStyle(5, 0xFF0000);
            bar.graphics.moveTo(100, 100);
            bar.graphics.lineTo(200, 100);

            bar.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(bar);
        }
    
        private function clickHandler(event:MouseEvent):void {
            
                var position:uint = event.localX;
                var percent:uint = Math.round(position) - 100;   
                var cue:uint = (percent / 100) * snd.length;

                channel.stop();
                channel = snd.play(cue);    
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            infoTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample2.as"> В следующем примере звук должен воспроизводиться один или два раза в зависимости от того, нажмет пользователь кнопку одним или двойным щелчком.
 
 <p>В конструкторе загружается звук, и создается простой прямоугольный объект Sprite с именем <codeph>button</codeph>. (Чтобы обеспечить интерактивные возможности, вместо объекта Shape используется объект Sprite.) Предполагается, что звуковой файл находится в том же каталоге, что и SWF-файл. (В данном примере не используется код обработки событий.)</p>
 
 <p>Настраиваются два прослушивателя событий для нажатий кнопки одним или двойным щелчком мыши. Если пользователь щелкает один раз, вызывается метод <codeph>clickHandler()</codeph>, который воспроизводит звук. Если пользователь дважды щелкает кнопку, вызывается метод <codeph>doubleClickHandler()</codeph>, который воспроизводит звук два раза. Второму аргументу метода <codeph>play()</codeph> задается значение <codeph>1</codeph>, в результате чего звук будет возвращаться к времени начала один раз для повторного воспроизведения. Время начала, первый аргумент, имеет значение <codeph>0</codeph>. Это значит, что файл будет воспроизводиться от начальной точки.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.media.Sound;
    import flash.net.URLRequest;

    public class Sound_playExample2 extends Sprite {
        private var button:Sprite = new Sprite(); 
        private var snd:Sound = new Sound();
            
        public function Sound_playExample2() {

            var req:URLRequest = new URLRequest("click.mp3");
            snd.load(req);               
     
            button.graphics.beginFill(0x00FF00);
            button.graphics.drawRect(10, 10, 50, 30);
            button.graphics.endFill();
     
            button.addEventListener(MouseEvent.CLICK, clickHandler);
            button.addEventListener(MouseEvent.DOUBLE_CLICK, doubleClickHandler);
     
            this.addChild(button);
        }

        private function clickHandler(event:MouseEvent):void {
            snd.play();            
        }

        private function doubleClickHandler(event:MouseEvent):void {
            snd.play(0, 2);        
        }
    }
}
</codeblock></example><example conref="examples\Sound_playExample3.as"> В следующем примере демонстрируется процесс и воспроизведения загрузки звукового файла.
 
 <p>В конструкторе файл загружается в блок <codeph>try...catch</codeph>, чтобы можно было перехватить возможные ошибки при загрузке. Один прослушиватель событий добавляется для объекта Sound: он будет реагировать на событие <codeph>IOErrorEvent</codeph> и вызывать метод <codeph>errorHandler()</codeph>. Другой прослушиватель добавляется для основного приложения: он будет реагировать на событие <codeph>Event.ENTER_FRAME</codeph> и использоваться в качестве таймера для отображения прогресса воспроизведения. И, в завершение, третий прослушиватель добавляется для звукового канала: он будет реагировать на событие <codeph>Event.SOUND_COMPLETE</codeph> (по завершении воспроизведения звука) и вызывать метод <codeph>soundCompleteHandler()</codeph>. Метод <codeph>soundCompleteHandler()</codeph> также удаляет прослушиватель события <codeph>Event.ENTER_FRAME</codeph>.</p>
 
 <p>Метод <codeph>enterFrameHandler()</codeph> делит значение <codeph>bytesLoaded</codeph>, переданное с объектом <codeph>ProgressEvent</codeph>, на значение <codeph>bytesTotal</codeph>, чтобы вычислить процент загружаемых звуковых данных. Процент воспроизводимых звуковых данных можно определить, разделив значение свойства <codeph>position</codeph> звукового канала на длину звуковых данных. Однако если звуковые данные загружены не полностью, свойство <codeph>length</codeph> объекта Sound показывает только размер данных, загруженных на текущий момент. Оценка конечного размера полного звукового файла вычисляется путем деления <codeph>length</codeph> текущего звукового объекта на значение свойства <codeph>bytesLoaded</codeph>, деленное на значение свойства <codeph>bytesTotal</codeph>.</p>
 
 <p>Обратите внимание, что если файл небольшой, сохранен в кэше или находится в локальном каталоге, то прогресс может быть незаметным. Кроме того, отрезок времени между началом загрузки звуковых данных и началом воспроизведения загруженных данных определяется значением свойства <codeph>SoundLoaderContext.buffertime</codeph>, которое по умолчанию составляет 1000 миллисекунд и может быть изменено.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    
    public class Sound_playExample3 extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel;
        private var statusTextField:TextField  = new TextField();

        public function Sound_playExample3(){

            statusTextField.autoSize = TextFieldAutoSize.LEFT;

           var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            
            try {
                snd.load(req);
            
                channel = snd.play();
            }
            catch (err:Error) {
                trace(err.message);
            }
                    
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            addEventListener(Event.ENTER_FRAME, enterFrameHandler);
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                    
            this.addChild(statusTextField);
        }
    
        private function enterFrameHandler(event:Event):void {    
            var loadTime:Number = snd.bytesLoaded / snd.bytesTotal;
            var loadPercent:uint = Math.round(100 * loadTime);
            var estimatedLength:int = Math.ceil(snd.length / (loadTime));
            var playbackPercent:uint = Math.round(100 * (channel.position / estimatedLength));
      
            statusTextField.text = "Sound file's size is " + snd.bytesTotal + " bytes.\n" 
                                   + "Bytes being loaded: " + snd.bytesLoaded + "\n" 
                                   + "Percentage of sound file that is loaded " + loadPercent + "%.\n"
                                   + "Sound playback is " + playbackPercent + "% complete.";     
        }
 
        private function errorHandler(errorEvent:IOErrorEvent):void {
            statusTextField.text = "The sound could not be loaded: " + errorEvent.text;
        }

        private function soundCompleteHandler(event:Event):void {
            statusTextField.text = "The sound has finished playing.";
            removeEventListener(Event.ENTER_FRAME, enterFrameHandler);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundChannel/stop()"><linktext>SoundChannel.stop()</linktext></link><link href="flash.media.xml#SoundMixer/stopAll()"><linktext>SoundMixer.stopAll()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Sound:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
     Возвращает число байтов, доступных в настоящий момент в данном объекте Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает число байтов, доступных в настоящий момент в данном объекте Sound. Это свойство обычно необходимо только для внешних загружаемых файлов.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
     Возвращает общее число байтов в данном объекте Sound.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает общее число байтов в данном объекте Sound. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:id3:get"><apiName>id3</apiName><shortdesc>
     Обеспечивает доступ к метаданным, которые являются частью MP3-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sound, Sound.id3, id3, mp3
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.media:ID3Info</apiValueClassifier></apiValueDef><apiDesc>
     Обеспечивает доступ к метаданным, которые являются частью MP3-файла.
     
     <p>Звуковые МР3-файлы могут содержать теги ID3, передающие метаданные о файле. Если звук MP3, загружаемый с помощью метода <codeph>Sound.load()</codeph>, содержит теги ID3, эти свойства можно запрашивать. Поддерживаются только теги ID3, которые могут использовать набор символов UTF-8.</p>
     
	 <p><ph outputclass="actionscript">Flash Player 9 и более поздних версий, а также среда выполнения AIR поддерживают</ph> <ph platform="javascript">Среда выполнения AIR поддерживает</ph> теги ID3 2.0, а именно 2.3 и 2.4. В следующих таблицах перечислены стандартные теги ID3 2.0 и представляемые ими типы содержимого. Свойство <codeph>Sound.id3</codeph> обеспечивает доступ к этим тегам посредством формата <codeph>my_sound.id3.COMM</codeph>, <codeph>my_sound.id3.TIME</codeph> и т.д. В первой таблице описываются теги, к которым можно обратиться и через имя свойства ID3 2.0 и через имя свойства ActionScript. Во второй таблице описаны теги ID3, которые поддерживаются, но не имеют предварительно определенных свойств в ActionScript. </p>
     
     <adobetable class="innertable">
       
      
      
      
     
     
     
     
     <tgroup cols="2"><tbody><row>
         <entry><b>Тег ID3 2.0</b></entry>
	    <entry><b>Соответствующее свойство класса Sound</b></entry>
      </row><row>
        <entry>COMM</entry>
        <entry>Sound.id3.comment</entry>
      </row><row>
        <entry>TALB</entry>
        <entry>Sound.id3.album </entry>
      </row><row>
     
       <entry>TCON</entry>
       <entry>Sound.id3.genre</entry>
      </row><row>
       <entry>TIT2</entry>
       <entry>Sound.id3.songName </entry>
     </row><row>
       <entry>TPE1</entry>
       <entry>Sound.id3.artist</entry>
     </row><row>
       <entry>TRCK</entry>
       <entry>Sound.id3.track </entry>
     </row><row>
       <entry>TYER</entry>
       <entry>Sound.id3.year </entry>
     </row></tbody></tgroup></adobetable>
     
     <p>Во следующей таблице описаны теги ID3, которые поддерживаются, но не имеют предварительно определенных свойств в классе Sound. Для обращения к ним требуется вызвать<codeph>mySound.id3.TFLT</codeph>, <codeph>mySound.id3.TIME</codeph>и т.д.</p>  
      <adobetable class="innertable">
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      <tgroup cols="2"><tbody><row>
          <entry><b>Свойство</b></entry>
          <entry><b>Описание</b></entry>
        </row><row>
          <entry>TFLT</entry>
          <entry>Тип файла</entry>
        </row><row>
          <entry>TIME</entry>
          <entry>Время</entry>
        </row><row>
          <entry>TIT1</entry>
          <entry>Описание группы содержимого</entry>
        </row><row>
          <entry>TIT2</entry>
          <entry>Описание заголовка, названия песни и содержимого</entry>
        </row><row>
          <entry>TIT3</entry>
          <entry>Уточнение подзаголовка и описания</entry>
        </row><row>
          <entry>TKEY</entry>
          <entry>Клавиша запуска</entry>
        </row><row>
          <entry>TLAN</entry>
          <entry>Языки</entry>
        </row><row>
          <entry>TLEN</entry>
          <entry>Длина</entry>
        </row><row>
          <entry>TMED</entry>
          <entry>Тип материала</entry>
        </row><row>
          <entry>TOAL</entry>
          <entry>Название альбома, ролика и изображения</entry>
        </row><row>
          <entry>TOFN</entry>
          <entry>Имя исходного файла</entry>
        </row><row>
          <entry>TOLY</entry>
          <entry>Авторы текстов</entry>
        </row><row>
          <entry>TOPE</entry>
          <entry>Артисты и исполнители</entry>
        </row><row>
          <entry>TORY</entry>
          <entry>Год выпуска</entry>
        </row><row>
          <entry>TOWN</entry>
          <entry>Владелец файла или лицензиат</entry>
        </row><row>
          <entry>TPE1</entry>
          <entry>Ведущие исполнители и солисты</entry>
        </row><row>
          <entry>TPE2</entry>
          <entry>Ансамбль, оркестр или аккомпанемент</entry>
        </row><row>
          <entry>TPE3</entry>
          <entry>Уточнение дирижера или исполнителя</entry>
        </row><row>
          <entry>TPE4</entry>
          <entry>Автор интерпретации, ремикса или другого вида модификации</entry>
        </row><row>
          <entry>TPOS</entry>
          <entry>Часть набора</entry>
        </row><row>
          <entry>TPUB</entry>
          <entry>Издатель</entry>
        </row><row>
          <entry>TRCK</entry>
          <entry>Номер дорожки или позиции в наборе</entry>
        </row><row>
          <entry>TRDA</entry>
          <entry>Даты записи</entry>
        </row><row>
          <entry>TRSN</entry>
          <entry>Название Интернет-радиостанции</entry>
        </row><row>
          <entry>TRSO</entry>
          <entry>Владелец Интернет-радиостанции</entry>
        </row><row>
          <entry>TSIZ</entry>
          <entry>Размер</entry>
        </row><row>
          <entry>TSRC</entry>
          <entry>Международный стандартный код записи (ISRC)</entry>
        </row><row>
          <entry>TSSE</entry>
          <entry>Программные/аппаратные средства и их параметры, используемые для кодирования</entry>
        </row><row>
          <entry>TYER</entry>
          <entry>Год</entry>
        </row><row>
          <entry>WXXX</entry>
          <entry>Кадр ссылки на URL-адрес</entry>
        </row></tbody></tgroup></adobetable>
     
     
     <p>При использовании данного свойства необходимо продумать модель безопасности проигрывателя Flash Player.</p>
     
     <ul>
     
     <li>Свойство <codeph>id3</codeph> объекта Sound всегда разрешено для SWF-файлов, находящихся в той же изолированной программной среде безопасности, что и звуковой файл. Для файлов из других изолированных сред выполняется проверка системы безопасности.</li>
     
     <li>При загрузке звука с помощью метода <codeph>load()</codeph> класса Sound можно задать параметр <codeph>context</codeph>, представленный объектом SoundLoaderContext. Если задать свойству <codeph>checkPolicyFile</codeph> объекта SoundLoaderContext значение <codeph>true</codeph>, проигрыватель Flash Player проверяет наличие файла политики URL-адресов на сервере, с которого загружается звук. Если имеется файл политики, разрешающий доступ к домену загружающего SWF-файла, тогда этот файл получает доступ к свойству <codeph>id3</codeph> объекта Sound; в противном случае – не получает.</li>
     
     </ul>
     
     <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p>
     
     <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul>
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
     
     

     
     </apiDesc><example conref="examples\Sound_id3Example.as"> В следующем примере данные ID3 считываются из звукового файла и отображаются в текстовом поле.
 
 <p>Конструктор загружает звуковой файл, но на запускает его воспроизведение. Предполагается, что файл находится в том же каталоге, что и SWF-файл. Система должна иметь разрешение, чтобы считывать теги ID3 из загруженного звукового файла. Если в файле есть данные ID3 и программа получает разрешение на их чтение, отправляется событие <codeph>Event.ID3</codeph>, и заполняется свойство <codeph>id3</codeph> звукового файла. Свойство <codeph>id3</codeph> содержит объект <codeph>ID3Info</codeph> со всеми данными ID3.</p>
 
 <p>В методе <codeph>id3Handler()</codeph> теги ID3 файла сохраняются в объекте класса ID3Info с именем <codeph>id3</codeph>. Инициируется текстовое поле для отображения списка тегов ID3. Цикл for повторяется для отображения всех тегов ID3 2.0 и добавляет имя и значение к содержимому текстового поля С помощью свойств данных ID3 (<codeph>ID3Info</codeph>) также добавляется имя исполнителя, название песни и альбома. ActionScript 3.0 и Flash Player 9 и более поздних версий поддерживают теги ID3 2.0, а именно 2.3 и 2.4. Если выполнять итерацию для свойств, как в цикле for, будут отображаться только теги ID3 2.0. Однако данные из более ранних версий также сохраняются в свойстве <codeph>id3</codeph> песни: их можно получить с помощью свойств класса ID3 info. Теги для ID3 1.0 помещаются в конце файла, а теги ID3 2.0 – в начале. (Иногда файлы могут содержать теги и старых и новых версий в одном месте.) Если файл закодирован с использованием тегов двух версий (1.0 и 2.0) в начале и в конце, метод <codeph>id3Handler()</codeph> вызывается два раза. Сначала считываются теги версии 2.0, а затем версии 1.0. Если имеются только теги ID3 1.0, то эту информацию можно получить через свойства данных ID3, такие как <codeph>id3.songname</codeph>. Для ID3 2.0 свойство <codeph>id3.TITS</codeph> получит название песни с помощью нового тега (TITS).</p>
 
 <p>Обратите внимание, что в данном примере не применяется обработка ошибок и, если содержимое ID3 имеет большую длину, результат может выходить за пределы видимой области.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.net.URLRequest;
    import flash.media.ID3Info;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.Event;

    public class Sound_id3Example extends Sprite {
        private var snd:Sound = new Sound();       
        private var myTextField:TextField = new TextField();

        public function Sound_id3Example() {
            snd.addEventListener(Event.ID3, id3Handler);
            snd.load(new URLRequest("mySound.mp3"));
        }
    
        private function id3Handler(event:Event):void {
            var id3:ID3Info = snd.id3;

            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.border = true;

            myTextField.appendText("Received ID3 Info: \n");
              
            for (var propName:String in id3) {
                myTextField.appendText(propName + " = " + id3[propName] + "\n");
            }
 
            myTextField.appendText("\n" + "Artist: " + id3.artist + "\n");
            myTextField.appendText("Song name: " + id3.songName + "\n");
            myTextField.appendText("Album: " + id3.album + "\n\n"); 
 
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiValue><apiValue id="flash.media:Sound:isBuffering:get"><apiName>isBuffering</apiName><shortdesc>
     Возвращает состояние буферизации внешних файлов MP3.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает состояние буферизации внешних файлов MP3. Если значение <codeph>true</codeph>, воспроизведение приостанавливается, пока объект ожидает загрузки дополнительных данных.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:length:get"><apiName>length</apiName><shortdesc>
     Длина текущего звука в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Длина текущего звука в миллисекундах.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Sound:url:get"><apiName>url</apiName><shortdesc>
     URL-адрес, с которого был загружен звук.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     URL-адрес, с которого был загружен звук. Это свойство применимо только к объектам Sound, загруженным с помощью метода <codeph>Sound.load()</codeph>. Для объектов Sound, связанных с ресурсами звука из библиотеки SWF-файла, свойство <codeph>url</codeph> имеет значение <codeph>null</codeph>.
     
     <p>При первом вызове <codeph>Sound.load()</codeph>, свойство <codeph>url</codeph> сначала имеет значение <codeph>null</codeph>, так как окончательный URL еще неизвестен. Свойство <codeph>url</codeph> получит другое значение, как только объект Sound отправит событие <codeph>open</codeph>.</p>
     
     <p>Свойство <codeph>url</codeph> содержит окончательный абсолютный URL, с которого загружался звук. Как правило, значение <codeph>url</codeph> совпадает со значением параметра <codeph>stream</codeph> метода <codeph>Sound.load()</codeph>. Однако, если методу <codeph>Sound.load()</codeph> был передан относительный URL-адрес, то значение свойства <codeph>url</codeph> будет представлять абсолютный URL-адрес. Если HTTP-сервер переадресует исходный запрос URL, то свойство <codeph>url</codeph> отражает конечный URL, с которого фактически был загружен файл. Такое сообщение абсолютного конечного URL эквивалентно поведению метода <codeph>LoaderInfo.url</codeph>.</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>load()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
 Класс SoundLoaderContext обеспечивает проверку безопасности для файлов, загружающих звук.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SoundLoaderContext обеспечивает проверку безопасности для файлов, загружающих звук. Объекты SoundLoaderContext передаются в качестве аргументов конструктору и методу <codeph>load()</codeph> класса Sound.
 
 <p>При использовании данного класса необходимо учесть следующие ограничения безопасности. </p>
 
 <ul>
 <li>Загрузка и воспроизведение звука запрещены, если вызывающий файл находится в изолированной программной среде сети, а звуковой файл для загрузки сохранен на локальном компьютере.</li>
 
 	<li>По умолчанию загрузка и воспроизведение звука не разрешены, если вызывающий локальный файл пытается загрузить и воспроизвести удаленный звук. Чтобы разрешить это, пользователь должен предоставить явное разрешение.</li>
 
 	<li>Запрещены определенные операции со звуком. Данные в загруженном звуке не могут быть получены файлом, находящимся в другом домене, если не используется файл политики URL-адресов. Данное ограничение распространяется на следующие API-интерфейсы для работы со звуком: свойство<codeph>Sound.id3</codeph>, и методы <codeph>SoundMixer.computeSpectrum()</codeph>, <codeph>SoundMixer.bufferTime</codeph> и <codeph>SoundTransform</codeph>.</li>
 
 </ul>
 
 <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p>
 
 <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел «Understanding AIR Security» (Сведения о безопасности AIR) главы «Getting started with Adobe AIR» (Начало работы с Adobe AIR) книги <i>Developing AIR Applications</i> (Разработка приложений AIR).</li>
 
   <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/devnet/flashplayer/security.html" scope="external">Безопасность</xref></li>
 
 </ul>
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.media:SoundLoaderContext:SoundLoaderContext"><apiName>SoundLoaderContext</apiName><shortdesc>
     Создает новый объект Context для загрузчика звука.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bufferTime</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1000</apiData><apiDesc>Число секунд для предварительной загрузки потокового звука в буфер перед началом передачи звука в поток.
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, стоит проверять наличие файла политики URL-адресов при загрузке объекта (<codeph>true</codeph>) или нет.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект Context для загрузчика звука.  
     
     </apiDesc><example conref="examples\SoundLoaderContextExample.as"> В следующем примере время буферизации загружаемого звука составляет три секунды.
 
 <p>Первый параметр объекта SoundLoaderContext (<codeph>context</codeph>) используется для увеличения значения буфера по умолчанию с одной до трех секунд. (Значение выражено в миллисекундах.) Если второму параметру объекта SoundLoaderContext задать значение <codeph>true</codeph>, Flash Player будет проверять наличие файла междоменной политики при загрузке объекта. В данном примере используется значение по умолчанию <codeph>false</codeph>, поэтому проверка выполняться не будет. Метод <codeph>load()</codeph> объекта Sound будет использовать контекстные настройки, чтобы перед началом потокового воспроизведения звук загружался в буфер в течение трех секунд. Объект <codeph>URLRequest</codeph> определяет местоположение файла, подкаста от компании Adobe. Если во время загрузки звука возникает ошибка <codeph>IOErrorEvent.IO_ERROR</codeph>, вызывается метод <codeph>errorHandler()</codeph>.</p> 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.events.IOErrorEvent;
    
    public class SoundLoaderContextExample extends Sprite {

        public function SoundLoaderContextExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3");
            var context:SoundLoaderContext = new SoundLoaderContext(3000, false);

            snd.load(req, context);
            snd.play();      
 
            snd.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace("The sound could not be loaded: " + errorEvent.text);
        }

    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.media:SoundLoaderContext:bufferTime"><apiName>bufferTime</apiName><shortdesc>
	 Количество миллисекунд для предварительной загрузки потокового звука в буфер перед началом передачи звука в реальном времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1000</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Количество миллисекунд для предварительной загрузки потокового звука в буфер перед началом передачи звука в реальном времени.
	 
	 <p>Обратите внимание, что значение <codeph>SoundLoaderContext.bufferTime</codeph> нельзя переопределить заданием свойства <codeph>SoundMixer.bufferTime</codeph>. <ph platform="actionscript"> Свойство <codeph>SoundMixer.bufferTime</codeph> затрагивает только время буферизации для встроенных потоковых звуков в SWF-файле и не зависит от динамически созданных объектов Sound (то есть, объектов Sound, созданных в ActionScript).</ph></p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundLoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 Указывает, будет ли приложение пытаться загрузить файл политики URL-адресов с сервера загружаемого звука перед началом загрузки самого звука.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext, NetStream
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, будет ли приложение пытаться загрузить файл политики URL-адресов с сервера загружаемого звука перед началом загрузки самого звука. Это свойство применяется к звуку, загружаемому не с того домена, в котором находится вызывающий файл, с помощью метода <codeph>Sound.load()</codeph>.
	 
	 <p platform="javascript">Это свойство применяется только к SWF-содержимому, выполняемому за пределами изолированной среды приложения AIR. </p>
	 
	 <p platform="actionscript">Установите для данного свойства значение <codeph>true</codeph>, если вы загружаете звук, размещенный за пределами домена вызывающего файла, а для кода в вызывающем файле требуется доступ на низком уровне к звуковым данным. Например, доступ низкого уровня к данным звука требуется для ссылки на свойство <codeph>Sound.id3</codeph> с целью получения объекта ID3Info или для вызова метода <codeph>SoundMixer.computeSpectrum()</codeph> для получения образцов загруженного звука При попытке доступа к данным звука без установки значения <codeph>true</codeph> для параметра <codeph>checkPolicyFile</codeph> во время загрузки можно получить исключение SecurityError, так как требуемый файл политик не был загружен.</p>
	 
	 <p platform="actionscript">Если вам не требуется доступ низкого уровня к данным загружаемого звука, не устанавливайте для параметра <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>. Проверка наличия файла политики снижает пропускную способность сети и может задержать начало загрузки, поэтому ее следует выполнять только при необходимости.</p>
	 
	 <p platform="actionscript">При вызове метода <codeph>Sound.load()</codeph> со свойством <codeph>SoundLoaderContext.checkPolicyFile</codeph> в значении <codeph>true</codeph> проигрыватель Flash Player или AIR должен либо успешно загрузить соответствующий файл политики URL-адресов, либо определить, что его не существует, прежде чем начнется загрузка заданного звука. <ph platform="actionscript">Flash Player или</ph> AIR выполняет следующие действия в указанном порядке, чтобы проверить существование файла политики:</p>
	 
	 <ul platform="actionscript">
	 
	 <li>Проигрыватель Flash Player или AIR анализирует ранее загруженные файлы политик.</li>
	 
	 <li>Проигрыватель Flash Player или AIR пытается загрузить любые ожидаемые файлы политик, указанные в вызовах метода <codeph>Security.loadPolicyFile()</codeph>.</li>
	 
	 <li>Проигрыватель Flash Player или AIR пытается загрузить файл политики из местоположения по умолчанию, которое соответствует URL-адресу звука (файл <codeph>/crossdomain.xml</codeph> на том же сервере, что и <codeph>URLRequest.url</codeph>). (URL-адрес звука задается в свойстве <codeph>url</codeph> объекта URLRequest, переданного методу <codeph>Sound.load()</codeph> или функции конструктора Sound().)</li>
	 </ul>
	 
	 <p platform="actionscript">Во всех случаях проигрыватель Flash Player или AIR требует наличия на сервере звука соответствующего файла политики, который предоставляет доступ к звуковому файлу по адресу <codeph>URLRequest.url</codeph> на основе места размещения файла политики, а также, обеспечивает домену вызывающего файла доступ к звуку посредством одного или нескольких тегов <codeph>&lt;allow-access-from></codeph>.
	 </p>
	 
	 <p platform="actionscript">Если установить для параметра <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>, то перед загрузкой звука проигрыватель Flash Player или AIR будет ожидать проверки файла политики. Прежде чем выполнять операции низкого уровня с данными звука, такие как вызов <codeph>Sound.id3</codeph> или <codeph>SoundMixer.computeSpectrum()</codeph>, необходимо дождаться отправки событий <codeph>progress</codeph> и <codeph>complete</codeph> объектом Sound.
	 </p>
	 
	 <p platform="actionscript">Если задать для параметра <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>, но при этом соответствующий файл политики не будет найден, сообщение об ошибке будет отправлено только при попытке выполнить операцию, требующую наличия файла политики, после чего проигрыватель Flash Player или AIR выдаст исключение <codeph>SecurityError</codeph>. После получения события <codeph>complete</codeph> можно проверить, найден ли релевантный файл политики, получив значение <codeph>Sound.id3</codeph> в блоке <codeph>try</codeph> и посмотрев, будет ли выдано исключение <codeph>SecurityError</codeph>.</p>
	 
	 
	 <p platform="actionscript">Будьте внимательны при установке параметра <codeph>checkPolicyFile</codeph>, если вы загружаете файл с URL-адреса, в котором используется HTTP-переадресация на стороне сервера. Проигрыватель Flash Player или AIR пытается получить файлы политик, соответствующие свойству <codeph>url</codeph> объекта URLRequest, переданного методу <codeph>Sound.load()</codeph>. Если окончательный звуковой файл передается с другого URL-адреса из-за HTTP-переадресации, то изначально загруженные файлы политик могут быть не применимы к конечному URL-адресу объекта, который и следует учитывать при принятии мер безопасности.</p>
	 
	 <p platform="actionscript">В подобном случае можно предпринять следующее. Получив событие <codeph>progress</codeph> или <codeph>complete</codeph>, нужно проанализировать значение свойства <codeph>Sound.url</codeph>, которое содержит конечный URL звука. Затем вызовите метод <codeph>Security.loadPolicyFile()</codeph> в файле политики которого указан URL-адрес, полученный исходя из конечного URL звука. В завершение запрашивайте значение свойства <codeph>Sound.id3</codeph> до тех пор, пока не перестанет выдаваться исключение.</p>
	 
	 <p platform="actionscript">Это условие не применимо к содержимому в изолированной программной среде безопасности приложения AIR. Содержимое, находящееся в изолированной программной среде приложения, всегда имеет программный доступ к звуковому содержимому независимо от источника его происхождения.</p>
	 
	 <p platform="actionscript">Дополнительные сведения о файлах политик см. в главе «Система безопасности проигрывателя Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound/load()"><linktext>flash.media.Sound.load()</linktext></link><link href="flash.media.xml#Sound/id3"><linktext>flash.media.Sound.id3</linktext></link><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>flash.media.SoundMixer.computeSpectrum()</linktext></link><link href="flash.media.xml#Sound/url"><linktext>flash.media.Sound.url</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundChannel"><apiName>SoundChannel</apiName><shortdesc>
 Класс «SoundChannel» управляет звуком в приложении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс «SoundChannel» управляет звуком в приложении. Каждому звуку назначается звуковой канал, и приложение может иметь несколько смешанных между собой звуковых каналов. Класс SoundChannel содержит метод <codeph>stop()</codeph>, свойства для отслеживания амплитуды (громкости) канала и свойство для назначения объекта SoundTransform каналу.
 
 </apiDesc><example conref="examples\SoundChannelExample.as"> В следующем примере загружается и воспроизводится МР3-файл, а также отображаются данные о звуковых событиях, которые происходят по мере загрузки и воспроизведения файла. Объект Timer передает обновленную информацию о положении точки воспроизведения каждые 50 миллисекунд. Чтобы запустить данный пример, поместите файл MySound.mp3 в тот каталог, где находится рассматриваемый SWF-файл.

<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.utils.Timer;

    public class SoundChannelExample extends Sprite {
        private var url:String = "MySound.mp3";
        private var soundFactory:Sound;
        private var channel:SoundChannel;
        private var positionTimer:Timer;

        public function SoundChannelExample() {
            var request:URLRequest = new URLRequest(url);
            soundFactory = new Sound();
            soundFactory.addEventListener(Event.COMPLETE, completeHandler);
            soundFactory.addEventListener(Event.ID3, id3Handler);
            soundFactory.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            soundFactory.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            soundFactory.load(request);

            channel = soundFactory.play();
            channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);

            positionTimer = new Timer(50);
            positionTimer.addEventListener(TimerEvent.TIMER, positionTimerHandler);
            positionTimer.start();
        }
        

        private function positionTimerHandler(event:TimerEvent):void {
            trace("positionTimerHandler: " + channel.position.toFixed(2));
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function id3Handler(event:Event):void {
            trace("id3Handler: " + event);
        }

        private function ioErrorHandler(event:Event):void {
            trace("ioErrorHandler: " + event);
            positionTimer.stop();       
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: " + event);
        }

        private function soundCompleteHandler(event:Event):void {
            trace("soundCompleteHandler: " + event);
            positionTimer.stop();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links><adobeApiEvent id="flash.media:SoundChannel_flash.events.Event.SOUND_COMPLETE_soundComplete"><apiName>soundComplete</apiName><shortdesc>
 Отправляется после завершения воспроизведения звука.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SOUND_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после завершения воспроизведения звука. 
 </apiDesc><example conref="examples\SoundChannel_event_soundCompleteExample.as"> В следующем примере пользователь выбирает песни из списка воспроизведения, а затем нажимает кнопку «Воспроизведение», чтобы прослушать их в выбранном порядке.
 
 <p>В конструкторе определяется текстовое поле, которое содержит список песен и строку для каждого элемента, выбранного для воспроизведения. (Как правило, для воспроизведения используются кнопки, а для списка песен – окна списков.) Определяется объект формата текста, который изменяет формат строк выбранных песен на курсив. Когда пользователь щелкает текстовое поле, запускается метод <codeph>clickHandler()</codeph>.</p> 
 
<p>В методе <codeph>clickHandler()</codeph> метод <codeph>getLineIndexAtPoint()</codeph> объекта текстового поля возвращает индекс строки, которую щелкнул пользователь. Используя индекс строки, метод <codeph>getLineText()</codeph> получает содержимое текста. Инструкция if проверяет, выбрал ли пользователь песню для воспроизведения или для добавления в список воспроизведения. Если пользователь выбрал песню для воспроизведения, прослушиватель событий щелчка мыши удаляется, и вызывается метод <codeph>playNext()</codeph> для начала воспроизведения. Если пользователь выделил название песни, содержимое строки добавляется в массив <codeph>songList</codeph> и формат текста меняется на курсив.</p>
 
 <p>Метод <codeph>playNext()</codeph> повторяется для загрузки и воспроизведения каждой песни в списке массива. Песне также назначается звуковой канал. Для звукового канала добавляется прослушиватель событий, реагирующий на завершение воспроизведения песни и отправку события <codeph>Event.SOUND_COMPLETE</codeph>. Затем метод <codeph>soundCompleteHandler()</codeph> вызывает метод <codeph>playNext()</codeph> для воспроизведения следующей песни. Этот процесс продолжается, пока не завершится воспроизведение всех песен, перечисленных в массиве.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;

    public class SoundChannel_event_soundCompleteExample extends Sprite {
        private var channel:SoundChannel = new SoundChannel();
        private var songList:Array = new Array();
        private var listTextField:TextField = new TextField();
        private var songFormat:TextFormat = new TextFormat();
        private var arrayIndex:int = 0;
        private var songSelected:Boolean = false;
        
        public function SoundChannel_event_soundCompleteExample() {
            
            listTextField.autoSize = TextFieldAutoSize.LEFT;
            listTextField.border = true
            listTextField.background = true;
            listTextField.text = "Song1.mp3\n" + "Song2.mp3\n" 
                                + "Song3.mp3\n" + "Song4.mp3\n" + "PLAY";
        
            songFormat.italic = true;
 
            listTextField.addEventListener(MouseEvent.CLICK, clickHandler);
                        
            addChild(listTextField);
        }
        
        private function clickHandler(e:MouseEvent):void {
            var index:int = listTextField.getLineIndexAtPoint(e.localX, e.localY);
            var line:String = listTextField.getLineText(index);
            var firstIndex:uint = listTextField.getLineOffset(index);
            var playLine:uint = listTextField.numLines - 1;

                if((index == playLine) &amp;&amp; (songSelected == true)) {
                    listTextField.removeEventListener(MouseEvent.CLICK, clickHandler);
                    playNext();       

                } else if (index != playLine) {
                     songList.push(line.substr(0, (line.length - 1)));
                     listTextField.setTextFormat(songFormat, firstIndex, 
                                (firstIndex + listTextField.getLineLength(index)));     
                    songSelected = true;
                 }
        }

        private function playNext():void {
 
             if(arrayIndex &lt; songList.length) {
                var snd:Sound = new Sound();
                snd.load(new URLRequest(songList[arrayIndex]));
                channel = snd.play();
                
                channel.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler);
                arrayIndex++;
 
            } else {
                songSelected = false;
                    
                while(arrayIndex > 0) {
                    songList.pop();
                    arrayIndex--;
                }
            }
        }    

        private function soundCompleteHandler(e:Event):void {
            playNext();
        }

        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.media:SoundChannel:stop"><apiName>stop</apiName><shortdesc> 
	 Останавливает воспроизведение звука в канале.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 
	 </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 Останавливает воспроизведение звука в канале.
	 
	 </apiDesc><example conref="examples\SoundChannel_stopExample.as"> В следующем примере пользователь может нажать кнопку, чтобы приостановить звуковой файл и повторно воспроизвести его.
 
 <p>Конструктор загружает звуковой файл. (В данном примере предполагается, что файл находится в том же каталоге, что и SWF-файл.) Текстовое поле используется в качестве кнопки, нажатием которой пользователь может начать или приостановить воспроизведение. Когда пользователь щелкает текстовое поле <codeph>button</codeph>, запускается метод <codeph>clickHandler()</codeph>.</p>
 
 <p>В методе <codeph>clickHandler()</codeph> при первом щелчке по текстовому полю начинается воспроизведение звука и назначается звуковой канал. Затем, когда пользователь щелкает текстовое поле, чтобы поставить звук на паузу, воспроизведение останавливается. Свойство <codeph>position</codeph> звукового канала записывает положение звука на момент остановки. Это свойство используется для возобновления воспроизведения с того же положения, когда пользователь снова щелкает текстовое поле, чтобы отменить паузу. Каждый раз при вызове метода <codeph>Sound.play()</codeph> создается новый объект SoundChannel, и ему назначается переменная <codeph>channel</codeph>. Объект Sound должен быть назначен объекту SoundChannel, чтобы использовать метод <codeph>stop()</codeph> звукового канала для приостановки звука.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
            
    public class SoundChannel_stopExample extends Sprite {
        private var snd:Sound = new Sound();
        private var channel:SoundChannel = new SoundChannel();
        private var button:TextField = new TextField();

        public function SoundChannel_stopExample() {
            var req:URLRequest = new URLRequest("MySound.mp3");
            snd.load(req);
            
            button.x = 10;
            button.y = 10;
            button.text = "PLAY";
            button.border = true;
            button.background = true;
            button.selectable = false;
            button.autoSize = TextFieldAutoSize.CENTER;

            button.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(button);
        }

        private function clickHandler(e:MouseEvent):void {
            var pausePosition:int = channel.position;

            if(button.text == "PLAY") {
                channel = snd.play(pausePosition);
                button.text = "PAUSE";
            } 
            else {
                channel.stop();
                button.text = "PLAY";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundChannel:leftPeak:get"><apiName>leftPeak</apiName><shortdesc> 
	 Текущая амплитуда (громкость) левого канала от 0 (тишина) до 1 (полная амплитуда).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Текущая амплитуда (громкость) левого канала от 0 (тишина) до 1 (полная амплитуда).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:position:get"><apiName>position</apiName><shortdesc>
	 Во время воспроизведения звука свойство position показывает (в миллисекундах) текущую точку воспроизведения в звуковом файле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Во время воспроизведения звука свойство <codeph>position</codeph> показывает (в миллисекундах) текущую точку воспроизведения в звуковом файле. Когда звук останавливается или приостанавливается, свойство <codeph>position</codeph> показывает последнюю воспроизведенную точку в звуковом файле.
	 
	 <p>Чаще всего при остановке звука значение свойства <codeph>position</codeph> сохраняется. Позже можно возобновить воспроизведение, запустив звук с сохраненного положения.
	 </p>
	 
	 <p>Если звук воспроизводится циклично, значение свойства <codeph>position</codeph> сбрасывается на 0 в начале каждого цикла.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:rightPeak:get"><apiName>rightPeak</apiName><shortdesc> 
	 Текущая амплитуда (громкость) правого канала от 0 (тишина) до 1 (полная амплитуда).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Текущая амплитуда (громкость) правого канала от 0 (тишина) до 1 (полная амплитуда).
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:SoundChannel:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 Объект SoundTransform, назначенный для данного звукового канала.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
	 </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 Объект SoundTransform, назначенный для данного звукового канала. Объект SoundTransform включает свойства для настройки громкости, панорамы, назначения левого и правого динамиков.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:Video"><apiName>Video</apiName><shortdesc>
 
 Класс Video отображает эфирное или записанное видео в приложении, не внедряя видео в SWF-файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Класс Video отображает эфирное или записанное видео в приложении, не внедряя видео в SWF-файл. Этот класс создает в интерфейсе Adobe Flash или Adobe Flex объект Video, который воспроизводит следующие типы видео: записанные FLV-файлы, сохраненные на сервере или на жестком диске, или эфирное видео, передаваемое с компьютера пользователя. Объект Video – это экранный объект в списке отображения приложения, который представляет визуальное пространство пользовательского интерфейса, в котором воспроизводится видео.
 
 <p>
 При использовании сервера Flash Media Server объект Video позволяет передавать эфирное видео с компьютера пользователя на сервер и транслировать его с сервера другим пользователям. С помощью этих функций можно разрабатывать мультимедийные приложения, такие как простой видеопроигрыватель, видеопроигрыватель с несколькими точками публикации с одного сервера на другой или приложение для обмена видеосодержимым для сообщества пользователей
 </p>
 
 <p>
 Flash Player 9 поддерживает публикацию и воспроизведение FLV-файлов, закодированных с помощью кодека Sorenson Spark или On2 VP6, а также поддерживает альфа-канал. Видеокодек On2 VP6 использует меньшую пропускную способности, чем более старые технологии, и предоставляет дополнительные фильтры подавления блочноcти и реверберации. Дополнительные сведения о воспроизведении видео см. в описании класса flash.net.NetStream.</p>
 
 
 <p>
 Flash Player 9.0.115.0 и более поздние версии поддерживают множественное отображение для оптимизации качества и производительности визуализации во время выполнения. Для воспроизведения видео проигрыватель Flash Player использует оптимизацию множественного отображения, если свойству <codeph>smoothing</codeph> объекта Video задано значение <codeph>true</codeph>. 
 </p> 
 
 <p>
 Как и с другими экранными объектами в списке отображения, можно управлять различными свойствами объектов Video. Например, можно перемещать объект Video в рабочей области, используя свойства <codeph>x</codeph> и <codeph>y</codeph>, можно изменять размер с помощью свойств <codeph>height</codeph> и <codeph>width</codeph> и т.д. 
 </p>
 
 <p>
 Для потокового воспроизведения видео нужно использовать метод <codeph>attachCamera()</codeph> или <codeph>attachNetStream()</codeph>, чтобы прикрепить видео к объекту Video. После этого нужно добавить объект Video в список отображения с помощью метода <codeph>addChild()</codeph>.
 </p>
 
 <p product="flash">
 Если используется инструмент разработки Flash объект Video можно также поместить в рабочую область, а не добавлять его методом <codeph>addChild()</codeph>. Это делается следующим образом.
 </p>
 
 <ol product="flash">
   <li>Если панель «Библиотека» скрыта, выберите «Окно» > «Библиотека», чтобы показать ее.</li>
   <li>Добавьте встроенный объект Video в библиотеку, открыв меню «Параметры» справа на строке заголовка панели «Библиотека» и выберите «Создать видео».</li>
   <li>В диалоговом окне «Свойства видео» присвойте имя встроенному объекту Video, которое будет использоваться в библиотеке и нажмите кнопку «ОК».</li>
   <li>Перетащите объект Video в рабочую область и с помощью Инспектора свойств присвойте ему уникальное имя экземпляра, например <codeph>my_video</codeph>. (Не называйте его Video.)</li>
 </ol>
 
 <p><b>Примечание.</b> Класс Video не является подклассом класса InteractiveObject, поэтому он не может отправлять события мыши. Однако можно использовать метод <codeph>addEventListener()</codeph> контейнера экранного объекта, содержащего объект Video.
 </p>
 
 </apiDesc><example conref="examples\VideoExample.as"> В следующем примере объект Video с классами NetConnection и NetStream используется для загрузки и воспроизведения FLV-файла. Чтобы запустить данный пример, вам потребуется FLV-файл, имя и место расположения которого совпадают с переменной, переданной <codeph>videoURL</codeph>. В данном случае, FLV-файл Video.flv находится в том же каталоге, где размещается SWF-файл.
 <p>В данном примере код, создающий объекты Video и NetStream, а также вызывающий методы <codeph>Video.attachNetStream()</codeph> и <codeph>NetStream.play()</codeph>, размещен в функции обработчика. Обработчик вызывается только при успешном подключении к объекту NetConnection (другими словами, когда событие <codeph>netStatus</codeph> возвращает объект <codeph>info</codeph> со свойством code, что свидетельствует об успешном выполнении задачи). Рекомендуется перед вызовом <codeph>NetStream.play()</codeph> дождаться успешного подключения. </p>
 <codeblock>

 package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;

    public class VideoExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function VideoExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }

        private function connectStream():void {
            stream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }
    }
 }
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>attachCamera()</linktext></link><link href="flash.media.xml#Video/attachNetStream()"><linktext>attachNetStream()</linktext></link><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#Stage/addChild()"><linktext>flash.display.Stage.addChild()</linktext></link></related-links><apiConstructor id="flash.media:Video:Video"><apiName>Video</apiName><shortdesc>
     Создает новый экземпляр Video.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, NetStream
     </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>320</apiData><apiDesc>Ширина видео в пикселях.
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>240</apiData><apiDesc>Высота видео в пикселях.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый экземпляр Video. Если не заданы значения для свойств <codeph>width</codeph> и <codeph>height</codeph> используются значения по умолчанию. Свойства width и height объекта Video можно настроить и после создания с помощью <codeph>Video.width</codeph> и <codeph>Video.height</codeph>. Когда создается новый объект Video, нулевые значения ширины и высоты не допускаются; при их передаче используются значения по умолчанию.
     
     <p>После создания объекта Video следует вызвать метод <codeph>DisplayObjectContainer.addChild()</codeph> или <codeph>DisplayObjectContainer.addChildAt()</codeph>, чтобы добавить его в вышестоящий объект DisplayObjectContainer.</p>
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.media:Video:attachCamera"><apiName>attachCamera</apiName><shortdesc>
     Задает видеопоток с камеры для отображения в пределах объекта Video в окне приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.attachCamera, attachCamera()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>camera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>Объект Camera, получающий видеоданные. Чтобы разорвать соединение с объектом Video, передайте значение <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Задает видеопоток с камеры для отображения в пределах объекта Video в окне приложения.
     
     <p>
     Используйте этот метод для прикрепления к объекту Video эфирного видео с компьютера пользователя. Эфирное видео можно воспроизводить локально на том же компьютере, с которого оно передается, или передавать на Flash Media Server и затем транслировать его другим пользователям.
     </p>
     
     </apiDesc><example>Пример использования этого метода см. в примере для метода <xref href="Camera.html#getCamera()">Camera.getCamera()</xref>. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachNetStream()"><linktext>Video.attachNetStream()</linktext></link><link href="flash.media.xml#Camera"><linktext>flash.media.Camera</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:attachNetStream"><apiName>attachNetStream</apiName><shortdesc>
     Задает видеопоток для отображения в пределах объекта Video в окне приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, video, Video.attachNetStream, attachNetStream()
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>netStream</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier><apiDesc>Объект NetStream. Чтобы разорвать соединение с объектом Video, передайте значение <codeph>null</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Задает видеопоток для отображения в пределах объекта Video в окне приложения. Видеопоток является либо FLV-файлом, воспроизводимым методом <codeph>NetStream.play()</codeph>, объектом Camera или имеет значение <codeph>null</codeph>. Если используется FLV-файл, его можно сохранить в локальной файловой системе или на сервере Flash Media Server. Если аргумент <codeph>netStream</codeph> имеет значение <codeph>null</codeph>, воспроизведение видео в объекте Video прекращается.
     
     <p>
     Не нужно использовать этот метод, если FLV-файл содержит только аудио. Аудиокомпонент FLV-файла воспроизводится автоматически при вызове метода <codeph>NetStream.play()</codeph>. Чтобы управлять аудиосодержимым, связанным с FLV-файлом, используйте свойство <codeph>soundTransform</codeph> объекта NetStream, воспроизводящего FLV-файл.
     </p>
     
     </apiDesc><example>См. пример использования этого метода в конце описания класса. 
     </example></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/soundTransform"><linktext>flash.net.NetStream.soundTransform</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>flash.net.NetStream.play()</linktext></link><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiOperation><apiOperation id="flash.media:Video:clear"><apiName>clear</apiName><shortdesc>
     Удаляет отображаемое в данный момент изображение в объекте Video (а не видеопоток).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.clear, clear
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет отображаемое в данный момент изображение в объекте Video (а не видеопоток). Данный метод используется для обработки текущих изображений. Например, можно удалить последнее изображение или отобразить информацию ждущего режима, не скрывая объект Video.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#Video/attachCamera()"><linktext>Video.attachCamera()</linktext></link></related-links></apiOperation><apiValue id="flash.media:Video:deblocking:get"><apiName>deblocking</apiName><shortdesc>
     Указывает тип фильтра, применяемого к дешифрованному видео в ходе последующей обработки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.deblocking, deblocking
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Указывает тип фильтра, применяемого к дешифрованному видео в ходе последующей обработки. Значение по умолчанию – 0, оно позволяет видеокомпрессору при необходимости применять фильтр подавления блочности.
     
     <p>Сжатие видео может приводить к нежелательным искажениям. Можно использовать свойство <codeph>deblocking</codeph>, чтобы настраивать фильтры, уменьшающие блочность и реверберацию (для видео, сжатого с помощью кодека On2).</p>
     
     <p><i>Блочностью</i> называются видимая несогласованность между границами соседних квадратов, составляющих каждый видеокадр. <i>Реверберацией</i> называется шум вокруг элементов видеоизображения.</p>
     
     <p>Имеется два фильтра подавления блочности: один в кодеке Sorenson, а другой в On2 VP6. Кроме того, при использовании кодека On2 VP6 становится доступным фильтр подавления реверберации. При настройке фильтров используйте одно из следующих значений.</p>
     
     <ul>
       <li>0 – позволяет видеокомпрессору при необходимости применять фильтр подавления блочности.</li>
       <li>1 – не использует фильтр подавления блочности.</li>
       <li>2 – использует фильтр подавления блочности Sorenson.</li>
       <li>3 – (только для кодека On2) использует фильтр подавления блочности On2, но не фильтр подавления реверберации.</li>
       <li>4 – (только для кодека On2) использует фильтр подавления блочности и реверберации On2.</li>
       <li>5 – (только для кодека On2) использует фильтр подавления блочности и более производительный фильтр On2 подавления реверберации.</li>
     </ul>
     
     <p>Если при использовании кодека Sorenson для видео выбирается значение больше 2, то по умолчанию используется значение 2.</p>
     
     <p>Использование фильтра подавления блочности оказывает общее влияние на производительность воспроизведения, обычно оно не требуется для широкополосного видео. Если пользовательская система недостаточно мощная, то, если включен фильтр подавления блочноcти, при воспроизведении видео могут возникнуть проблемы.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:smoothing:get"><apiName>smoothing</apiName><shortdesc>
     Определяет, должно ли выполняться сглаживание (интерполяция) видео при масштабировании.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.smoothing, smoothing
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, должно ли выполняться сглаживание (интерполяция) видео при масштабировании. Для реализации сглаживания проигрыватель должен работать в высококачественном режиме. Значение по умолчанию – <codeph>false</codeph> (без сглаживания).
     <p>При воспроизведении видео с помощью Flash Player 9.0.115.0 и более поздних версий, этому свойству необходимо задать значение <codeph>true</codeph>, чтобы применить оптимизацию изображения методом множественного отображения.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.media:Video:videoHeight:get"><apiName>videoHeight</apiName><shortdesc>
      Целое число, задающее высоту видеопотока в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.height, height
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      Целое число, задающее высоту видеопотока в пикселях. Для потоков в реальном времени это свойство имеет то же значение, что и свойство <codeph>Camera.height</codeph> объекта Camera, получающего видеопоток. Для FLV-файлов это значение высоты файла, экспортированного в виде FLV-файла.
     <p>Например, это свойство можно использовать, чтобы пользователь просматривал видео с сохранением того размера, в каком оно было получено, независимо от действительного размера объекта Video в рабочей области.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/height"><linktext>flash.media.Camera.height</linktext></link></related-links></apiValue><apiValue id="flash.media:Video:videoWidth:get"><apiName>videoWidth</apiName><shortdesc>
      Целое число, задающее ширину видеопотока в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Camera, video, Video.width, width
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
      Целое число, задающее ширину видеопотока в пикселях. Для эфирных потоков это свойство имеет то же значение, что и свойство <codeph>Camera.width</codeph> объекта Camera, получающего видеопоток. Для FLV-файлов это значение ширины файла, экспортированного в виде FLV-файла.
     <p>Например, это свойство можно использовать, чтобы пользователь просматривал видео в том же размере, в каком оно было получено, независимо от действительного размера объекта Video в рабочей области.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/width"><linktext>flash.media.Camera.width</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.media:SoundMixer"><apiName>SoundMixer</apiName><shortdesc>
Класс SoundMixer содержит статические свойства и методы для глобального управления звуком в приложении.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс SoundMixer содержит статические свойства и методы для глобального управления звуком в приложении. Класс SoundMixer управляет встроенным и потоковым звуком в приложении. Он не управляет динамически создаваемым звуком (т.е. звуком, созданным в ответ на отправку события <codeph>sampleData</codeph> объектом Sound).

</apiDesc></apiClassifierDetail><apiOperation id="flash.media:SoundMixer:areSoundsInaccessible"><apiName>areSoundsInaccessible</apiName><shortdesc> 
     Определяет, являются ли какие-либо звуки недоступными из-за ограничений безопасности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     
     </refpath></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Строковое представление логического значения.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc> 
     Определяет, являются ли какие-либо звуки недоступными из-за ограничений безопасности. Например, звук, загруженный не с того же домена, в котором находится вызывающее этот метод содержимое, будет недоступен, если на его сервере нет файла политики URL-адресов, предоставляющего доступ к домену этого содержимого. Звук будет загружен и воспроизведен, но для недоступных звуков не выполняются операции более низкого уровня, такие как получение метаданных ID3 для звука.
     
     <p>В отношении содержимого приложений AIR, находящегося в изолированной программной среде безопасности приложения, вызов этого метода всегда возвращает значение <codeph>false</codeph>. Все звуки, включая те, что загружены с других доменов, доступны для содержимого в изолированной программной среде безопасности приложения.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/computeSpectrum()"><linktext>computeSpectrum()</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:computeSpectrum"><apiName>computeSpectrum</apiName><shortdesc>
     Создает снимок текущей звуковой волны и помещает его в заданный объект ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should confirm if the floating point numbers are single- or double-precision.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>outputArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, содержащий значения, связанные со звуком. Если какие-то звуки недоступные вследствие ограничений безопасности (<codeph>areSoundsInaccessible == true</codeph>), объект <codeph>outputArray</codeph> остается без изменений. Если выключены все звуки, объект <codeph>outputArray</codeph> заполняется нулями.
     
     </apiDesc></apiParam><apiParam><apiItemName>FFTMode</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Логическое значение, указывающее на то, подвергается ли звук сначала преобразованию Фурье. Если этому параметру задать значение <codeph>true</codeph>, вместо необработанной звуковой волны метод возвращает спектр частот. В спектре низкие частоты представлены слева, а высокие – справа.
     
     </apiDesc></apiParam><apiParam><apiItemName>stretchFactor</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Разрешение звуковых образцов. Если задать для <codeph>stretchFactor</codeph> значение 0, образцы создаются с использованием частоты 44,1 кГц, при значении 1 используется частота 22,05 кГц, при значении 2 используется частота 11,025 кГц и т.д.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Создает снимок текущей звуковой волны и помещает его в заданный объект ByteArray. Значения форматируются как нормализованные значения с плавающей запятой в диапазоне от -1 до 1. Объект ByteArray, передаваемый параметру <codeph>outputArray</codeph>, перезаписывается новыми значениями. Размер созданного объекта ByteArray фиксируется на 512 значениях с плавающей запятой, где первые 256 значений представляют левый канал, а следующие 256 значений – правый.
     
     <p><b>Примечание.</b> Этот метод учитывает ограничения безопасности для локального файла и для междоменной загрузки. При работе с локальными файлами или звуками, загруженными с сервера, находящегося не в том же домене, что и вызывающее содержимое, возможно, потребуется создать файл междоменной политики, чтобы преодолеть ограничения изолированной программной среды. Дополнительные сведения см. в описании класса Sound. Более того, этот метод нельзя использовать для извлечения данных из потоков RTMP, даже если он вызывается содержимым, находящимся в том же домене, что и сервер RTMP.</p>
     
     
     <p>Этот метод поддерживается через протокол RTMP в Flash Player 9.0.115.0 и более поздних версиях и в Adobe AIR. Можно контролировать потоки на сервере Flash Media Server в сценарии, выполняемом на стороне сервера. Дополнительные сведения см. в разделах о свойствах <codeph>Client.audioSampleAccess</codeph> и <codeph>Client.videoSampleAccess</codeph> в документе <xref href="http://www.adobe.com/go/documentation_ru" scope="external"> <i>Справочник по языку ActionScript на стороне сервера для Adobe Flash Media Server</i></xref>.</p>
     
     </apiDesc><example conref="examples\SoundMixer_computeSpectrumExample.as"> В следующем примере метод <codeph>computeSpectrum()</codeph> используется для создания графического представления данных звуковой волны. 
 
 <p>Конструктор загружает и запускает звуковой файл. (В данном примере ошибки не обрабатываются, и предполагается, что звуковой файл находится в том же каталоге, что и SWF-файл.) При воспроизведении звука прослушивается событие <codeph>Event.ENTER_FRAME</codeph>, в результате чего многократно вызывается метод <codeph>onEnterFrame()</codeph> для рисования графика значений звуковых данных. После завершения воспроизведения звука метод <codeph>onPlaybackComplete()</codeph> останавливает рисование, удалив прослушиватель события <codeph>Event.ENTER_FRAME</codeph>.</p>
 
 <p>В методе <codeph>onEnterFrame()</codeph> метод <codeph>computeSpectrum()</codeph> сохраняет необработанный звук в объекте массива байтов <codeph>bytes</codeph>. Образец создается с использованием частоты 44,1 кГц. Массив байтов, содержащий 512 байтов данных, каждый из которых содержит значение с плавающей запятой от -1 до 1. Первые 256 значений представляют левый канал, а следующие 256 значений – правый. Первый цикл for считывает первые 256 значений (левый стереоканал) и рисует линию от одной точки к другой с помощью метода <codeph>Graphics.lineTo()</codeph>. (Векторное графическое представление звуковой волны записывается непосредственно на объекте Sprite класса.) Байты звука считываются как 32-разрядное число с плавающей запятой из потока байтов и умножаются на высоту графика, чтобы получить вертикальный диапазон кривой. Ширина равна удвоенной ширине длины канала. Второй цикл for считывает следующие 256 значений (правый стереоканал) и строит кривую в обратном порядке. Методы <codeph>g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);</codeph> и <codeph>g.lineTo(0, PLOT_HEIGHT);</codeph> рисуют основную линию для графиков волн. Полученная кривая волны похожа на зеркальное отражение первой.</p>  

<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.net.URLRequest;
    import flash.utils.ByteArray;
    import flash.text.TextField;

    public class SoundMixer_computeSpectrumExample extends Sprite {

        public function SoundMixer_computeSpectrumExample() {
            var snd:Sound = new Sound();
            var req:URLRequest = new URLRequest("Song1.mp3");
            snd.load(req);
            
            var channel:SoundChannel;
            channel = snd.play();
            addEventListener(Event.ENTER_FRAME, onEnterFrame);
            channel.addEventListener(Event.SOUND_COMPLETE, onPlaybackComplete);
        }

        private function onEnterFrame(event:Event):void {
            var bytes:ByteArray = new ByteArray();
            const PLOT_HEIGHT:int = 200;
            const CHANNEL_LENGTH:int = 256;

            SoundMixer.computeSpectrum(bytes, false, 0);
            
            var g:Graphics = this.graphics;
            
            g.clear();
       
            g.lineStyle(0, 0x6600CC);
            g.beginFill(0x6600CC);
            g.moveTo(0, PLOT_HEIGHT);
            
            var n:Number = 0;
            
            for (var i:int = 0; i &lt; CHANNEL_LENGTH; i++) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }

            g.lineTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            g.endFill();
 
            g.lineStyle(0, 0xCC0066);
            g.beginFill(0xCC0066, 0.5);
            g.moveTo(CHANNEL_LENGTH * 2, PLOT_HEIGHT);
            
            for (i = CHANNEL_LENGTH; i > 0; i--) {
                n = (bytes.readFloat() * PLOT_HEIGHT);
                g.lineTo(i * 2, PLOT_HEIGHT - n);
            }
  
            g.lineTo(0, PLOT_HEIGHT);
            g.endFill();
        }
        
        private function onPlaybackComplete(event:Event):void {
            removeEventListener(Event.ENTER_FRAME, onEnterFrame);
        }
    }
}

</codeblock></example></apiOperationDetail><related-links><link href="flash.media.xml#SoundMixer/areSoundsInaccessible()"><linktext>areSoundsInaccessible()</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.media.xml#Sound"><linktext>flash.media.Sound</linktext></link><link href="flash.media.xml#SoundLoaderContext/checkPolicyFile"><linktext>flash.media.SoundLoaderContext.checkPolicyFile</linktext></link></related-links></apiOperation><apiOperation id="flash.media:SoundMixer:stopAll"><apiName>stopAll</apiName><shortdesc>
     Останавливает воспроизведение всех звуков, воспроизводимых в данный момент.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Останавливает воспроизведение всех звуков, воспроизводимых в данный момент. 
     
     <p product="flash">Этот метод не останавливает точку воспроизведения. Звуки, настроенные для потоковой передачи, снова будут воспроизводиться по мере перехода точки воспроизведения к кадрам, в которых они находятся.</p>
     
     <p platform="actionscript">При использовании данного свойства необходимо учесть следующую модель безопасности:</p>
     
     <ul platform="actionscript">
     
     <li> По умолчанию вызов метода <codeph>SoundMixer.stopAll()</codeph> прекращает воспроизведение только тех звуков, которые находятся в той же изолированной программной среде безопасности, что и вызывающий его объект. Все звуки, воспроизведение которых было начато из другой изолированной программной среды, продолжают воспроизводиться.</li>
     
     <li>При загрузке звука с помощью метода <codeph>load()</codeph> класса Sound можно задать параметр <codeph>context</codeph>, представленный объектом SoundLoaderContext. Если задать свойству <codeph>checkPolicyFile</codeph> объекта SoundLoaderContext значение <codeph>true</codeph>, проигрыватель <ph platform="actionscript">Flash Player или</ph> Adobe AIR проверяет наличие файла междоменной политики на сервере, с которого загружается звук. Если на сервере есть файл междоменной политики, который допускает домен вызывающего содержимого, то файл может остановить загруженный звук с помощью метода <codeph>SoundMixer.stopAll()</codeph>; если же нет, то этого сделать нельзя.</li>
     
     </ul>
     
     <p platform="actionscript">Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
     
     <p platform="actionscript">Дополнительные сведения см. в следующих источниках.</p>
     
     <ul platform="actionscript">
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
     </apiDesc><example conref="examples\SoundMixer_stopAllExample.as"> В следующем примере метод <codeph>stopAll()</codeph> используется для отключения двух звуков, воспроизводимых одновременно. 
 
 <p>В конструкторе загружаются и запускаются два разных звуковых файла. Первый звук загружается локально и назначается звуковому каналу. (Предполагается, что файл находится в том же каталоге, что и SWF-файл.) Второй файл загружается и передается в виде потока с сайта Adobe. Для использования метода <codeph>SoundMixer.stopAll()</codeph> должны быть доступными все звуки. (Для проверки файла междоменной политики может использоваться объект SoundLoaderContext.) Для каждого звука настроен прослушиватель событий, который вызывается в случае возникновения ошибки ввода/вывода при загрузке звукового файла. Также создается текстовое поле <codeph>muteButton</codeph>. Оно прослушивает щелчки мыши, при которых вызывается метод <codeph>muteButtonClickHandler()</codeph>.</p>
 
 <p>Если в методе <codeph>muteButtonClickHandler()</codeph> текстовое поле содержит MUTE, то метод <codeph>areSoundsInaccessible()</codeph> проверяет, имеет ли микшер доступ к файлам. Если файлы доступны, метод <codeph>stopAll()</codeph> выключает звуки. При повторном щелчке по текстовому полю возобновляется воспроизведение первого звука, а в текстовом поле снова отображается MUTE. На этот раз метод <codeph>stopAll()</codeph> выключает один воспроизводимый звук. Обратите внимание, что метод <codeph>stop()</codeph> звукового канала также можно использовать для выключения определенного звука, назначенного каналу. (Для функционального использования канала звук необходимо повторно назначать каналу при каждом вызове метода <codeph>play()</codeph>.)</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.media.Sound;
    import flash.media.SoundLoaderContext;
    import flash.media.SoundChannel;
    import flash.media.SoundMixer;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.events.IOErrorEvent;

    public class SoundMixer_stopAllExample extends Sprite  {
        private var firstSound:Sound = new Sound();
        private var secondSound:Sound = new Sound();
        private var muteButton:TextField = new TextField();
        private var channel1:SoundChannel = new SoundChannel();
        
        public function SoundMixer_stopAllExample() {
            firstSound.load(new URLRequest("mySound.mp3"));
            secondSound.load(new URLRequest("http://av.adobe.com/podcast/csbu_dev_podcast_epi_2.mp3"));

            firstSound.addEventListener(IOErrorEvent.IO_ERROR, firstSoundErrorHandler);
            secondSound.addEventListener(IOErrorEvent.IO_ERROR, secondSoundErrorHandler);
            
            channel1 = firstSound.play();
            secondSound.play();
            
            muteButton.autoSize = TextFieldAutoSize.LEFT;
            muteButton.border = true;
            muteButton.background = true;
            muteButton.text = "MUTE";
        
            muteButton.addEventListener(MouseEvent.CLICK, muteButtonClickHandler);         
        
            this.addChild(muteButton);
        }

        private function muteButtonClickHandler(event:MouseEvent):void {

            if(muteButton.text == "MUTE") {        
  
                if(SoundMixer.areSoundsInaccessible() == false) {
                    SoundMixer.stopAll();
                    muteButton.text = "click to play only one of sound.";
                }
                else {
                    muteButton.text = "The sounds are not accessible.";
                }
            }
           else {
                firstSound.play();        
                muteButton.text = "MUTE";
           }
        } 

        private function firstSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }

        private function secondSoundErrorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.media:SoundMixer:bufferTime:get"><apiName>bufferTime</apiName><shortdesc>
     Число секунд для предварительной загрузки внедренного потокового звука в буфер перед началом передачи звука в поток.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Число секунд для предварительной загрузки внедренного потокового звука в буфер перед началом передачи звука в поток. Данные в загруженном звуке, включая время буферизации, не могут быть получены SWF-файлом, находящимся в другом домене, если не используется файл междоменной политики. Дополнительные сведения о безопасности и звуке см. в описании класса Sound. передачи звука в поток. <ph platform="actionscript">Данные в загруженном звуке, включая время буферизации, не могут быть получены кодом файла, находящегося в другом домене, если не используется файл междоменной политики. Однако код в изолированной программной среде приложения AIR имеет доступ к данным звуковых файлов, полученных из любого источника. Дополнительные сведения о безопасности и звуке см. в описании класса Sound.</ph> 
     
     <p>Свойство <codeph>SoundMixer.bufferTime</codeph> затрагивает только время буферизации для встроенных потоковых звуков в SWF-файле и не зависит от динамически созданных объектов Sound (т.е. объектов Sound, созданных в ActionScript). Значение свойства <codeph>SoundMixer.bufferTime</codeph> не может переопределять или задавать значение по умолчанию для времени буферизации, заданного объектом SoundLoaderContext, который передан методу <codeph>Sound.load()</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Sound"><linktext>Sound</linktext></link></related-links></apiValue><apiValue id="flash.media:SoundMixer:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
     Объект SoundTransform, управляющий глобальными свойствами звука.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
     Объект SoundTransform, управляющий глобальными свойствами звука. Объект SoundTransform включает свойства для настройки громкости, панорамы, назначения левого и правого динамиков. Объект SoundTransform, использованный в данном свойстве, передает окончательные параметры звука, которые применяются ко всем звукам после задания отдельных параметров звука.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>SoundTransform</linktext></link></related-links></apiValue></apiClassifier></apiPackage>