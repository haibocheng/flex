<?xml version="1.0"?>
<apiPackage id="flash.net"><apiName>flash.net</apiName><apiDetail/><apiClassifier id="flash.net:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
 
 Класс XMLSocket реализует клиентские сокеты, позволяющие проигрывателю Flash Player или приложению AIR поддерживать связь с компьютером сервера, который определяется по IP-адресу или имени домена.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLsocket, XMLsocket object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Класс XMLSocket реализует клиентские сокеты, позволяющие проигрывателю <ph platform="actionscript">Flash Player или</ph> приложению AIR поддерживать связь с компьютером сервера, который определяется по IP-адресу или имени домена. Класс XMLSocket предназначен для клиент-серверных приложений, которым требуется наименьшая задержка, например системам интерактивного общения в реальном времени. В традиционном механизме веб-дискуссии (чата) на основе HTTP сервер часто опрашивается, при этом новые сообщения загружаются посредством HTTP-запроса. В противоположность этому, решение на базе XMLSocket поддерживает открытое подключение к серверу, позволяющее этому серверу мгновенно отправлять входящие сообщения без запроса от клиента. Для работы с классом XMLSocket на серверном компьютере необходимо запустить скрытый процесс (daemon), который понимает протокол, используемый классом XMLSocket. Данный протокол описывается в следующем списке: 
 <ul>
   <li>XML-сообщения пересылаются через полнодуплексное потоковое подключение к сокету TCP/IP.</li>
   <li>Каждое XML-сообщение представляет собой полноценный XML-документ, в конце которого стоит нулевой байт (0).</li>
   <li>С помощью одного подключения XMLSocket можно пересылать и получать неограниченное количество XML-сообщений.</li>
 </ul>
 
 <p>Настройка сервера на взаимодействие с объектом XMLSocket может вызвать определенные трудности. Если вашему приложению не требуется обмен данными в режиме реального времени, вместо класса XMLSocket можно использовать класс URLLoader. </p>
 
 <p>Для использования методов класса XMLSocket необходимо сначала создать объект XMLSocket с помощью конструктора <codeph>new XMLSocket</codeph>.</p>
 
 <p>SWF-файлам в изолированной программной среде, локальной для файловой системы, запрещено использовать сокеты.</p>
      
  <p> <i>Файлы политик сокетов</i> на целевом узле определяют узлы, с которых SWF-файлы могут создавать подключения к сокетам, а также порты, доступные для таких подключений. В нескольких последних версиях Flash Player были ужесточены требования по безопасности относительно файлов политик сокетов. Компания Adobe рекомендует использовать файл политик для сокетов для всех версий Flash Player, а в некоторых случаях его применение является обязательным. Поэтому, если используются объекты XMLSocket, проследите, чтобы целевой узел при необходимости предоставлял файл политик для сокетов. </p>
 
  <p>В следующем списке приводятся все требования к файлам политик сокетов для разных версий Flash Player.</p>
 
  <ul>
  
   <li> В Flash Player 9.0.124.0 и более поздних версиях файл политик для сокетов является обязательным для любого подключения XMLSocket. Другими словами, файл политик для сокетов обязательно должен быть на целевом узле независимо от того, к какому порту выполняется подключение. Этот файл должен быть, даже если устанавливается подключение к порту на том же узле, на котором находится SWF-файл. </li>
 
   <li> В приложении Flash Player 9.0.115.0 и более ранних версиях файл политик для сокетов на целевом узле является обязательным, если устанавливается подключение к порту с номером меньше 1024 или если требуется подключиться не к тому узлу, на котором размещен SWF-файл. </li>
 
  <li> В Flash Player 9.0.115.0 при использовании отладочной версии проигрывателя в случае отсутствия файла политик для сокетов на целевом сервере отображается предупреждение, даже если файл политик для сокетов не является обязательным. </li>
 
  </ul>
 
 <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
 
 <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\XMLSocketExample.as"> В следующем примере класс XMLSocketExample используется для отправки данных с помощью XMLSocket и печати информации во время событий XMLSocket. Это можно сделать, выполнив следующие действия:
 <ol>
  <li>Конструктор XMLSocketExample создает экземпляр XMLSocket под именем <codeph>socket</codeph> и передает значение <codeph>socket</codeph> методу <codeph>ConfigureListeners()</codeph> (см. описание ниже), а затем вызывает метод <codeph>connect()</codeph> XMLSocket, используя имя узла localhost и номер порта <codeph>8080</codeph>.</li>
  <li>Затем вызывается метод <codeph>configureListeners()</codeph>, добавляющий прослушивателей для каждого поддерживаемого события XMLSocket:
  <ul>
      <li><codeph>closeHandler()</codeph>: находится в ожидании события <codeph>close</codeph>, которое отправляется после закрытия сетевого подключения.</li>
      <li><codeph>connectHandler()</codeph>: находится в ожидании события <codeph>connect</codeph>, отправляется при установке сетевого подключения.</li>
      <li><codeph>dataHandler()</codeph>: находится в ожидании событий <codeph>data</codeph>, отправляется каждый раз, когда XMLSocket получает новые данные.</li>
      <li><codeph>progressHandler()</codeph>: находится в ожидании событий <codeph>progress</codeph>, отправляется после вызова <codeph>send()</codeph> и в процессе отправки.</li>
      <li><codeph>securityErrorHandler()</codeph>: находится в ожидании событий <codeph>securityError</codeph>, которые отправляются при выявлении попытки доступа к XMLSocket с применением неправильной настройки безопасности локального воспроизведения или при использовании номера порта ниже 1024.</li>  
      <li><codeph>ioErrorHandler()</codeph>: находится в ожидании событий <codeph>ioError</codeph>, которые могут возникнуть только при сбое операции по отправке или получению данных.</li>  
  </ul></li>
 </ol>
 <p><b>Примечания.</b>
 <ul>
  <li>SWF-файл требуется откомпилировать с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети».</li>
  <li>Для того чтобы этот пример работал, вам необходим сервер, запущенный в вашем домене и использующий порт 8080.</li>
  <li>Если используется Flash Player 9.0.124.0 или более поздняя версия на сервере необходимо поместить файл политик для сокетов, разрешающий для вашего домена подключения к сокетам через порт 8080. Сведения о размещении файлов политик сокетов см. в разделе Центра разработки Flash Player: <xref href="http://www.adobe.com/devnet/flashplayer/articles/socket_policy_files.html" scope="external"> Setting up a socket policy file server</xref> (Настройка сервера с файлом политик для сокетов).</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.XMLSocket;

    public class XMLSocketExample extends Sprite {
        private var hostName:String = "localhost";
        private var port:uint = 8080;
        private var socket:XMLSocket;

        public function XMLSocketExample() {
            socket = new XMLSocket();
            configureListeners(socket);
            if (hostName &amp;&amp; port) {
                socket.connect(hostName, port);
            }
        }

        public function send(data:Object):void {
            socket.send(data);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CLOSE, closeHandler);
            dispatcher.addEventListener(Event.CONNECT, connectHandler);
            dispatcher.addEventListener(DataEvent.DATA, dataHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function closeHandler(event:Event):void {
            trace("closeHandler: " + event);
        }

        private function connectHandler(event:Event):void {
            trace("connectHandler: " + event);
        }

        private function dataHandler(event:DataEvent):void {
            trace("dataHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>flash.net.URLLoader.load()</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Отправляется, если вызов метода XMLSocket.connect() инициирует попытку подключения к серверу за пределами изолированной среды вызывающего объекта, или к порту с номером, меньшим чем 1024.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>XMLSocket.connect()</codeph> инициирует попытку подключения к серверу за пределами изолированной среды вызывающего объекта, или к порту с номером, меньшим чем 1024.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>XMLSocket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции отправки или получения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции отправки или получения. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.DataEvent.DATA_data"><apiName>data</apiName><shortdesc>
 Отправляется после отправки или получения необработанных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после отправки или получения необработанных данных.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 Отправляется после успешного вызова метода XMLSocket.connect().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после успешного вызова метода <codeph>XMLSocket.connect()</codeph>.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Отправляется, когда сервер закрывает подключение к сокету.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда сервер закрывает подключение к сокету. Событие <codeph>close</codeph> отправляется только в тот момент, когда сервер закрывает соединение. Оно не отправляется при вызове метода <codeph>XMLSocket.close()</codeph>.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:XMLSocket:XMLSocket"><apiName>XMLSocket</apiName><shortdesc>
    Создает новый объект XMLSocket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Полностью определенное имя домена DNS или IP-адрес в формате <i>.222.333.444</i>. В приложении Flash Player 9.0.115.0 и AIR 1.0 и более поздней версии можно задать IPv6- адреса, например rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. Также можно указать <codeph>null</codeph>, чтобы подключиться к серверу узла, на котором размещен рассматриваемый SWF-файл. Если SWF-файл, инициирующий данный вызов, запущен в web-браузере, то в параметре <codeph>host</codeph> должен указываться тот же домен, в котором находится SWF-файл.
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Номер TCP-порта на целевом узле, используемый для установки подключения. Для Flash Player 9.0.124.0 и более поздних версий на целевом узле должен быть файл политик для сокетов, разрешающий подключения к сокетам через указанный порт для узла, на котором размещен SWF-файл. Для более ранних версий Flash Player файл политик для сокетов является обязательным, только если требуется подключиться к порту с номером ниже 1024 или если SWF-файл находится не на том узле, к которому выполняется подключение.
    
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Создает новый объект XMLSocket. Если не указаны никакие параметры, создается первоначально отключенный сокет. Если параметры указаны, производится попытка подключиться к указанному узлу и порту.
    
    <p><b>Примечание.</b> Настоятельно рекомендуется использовать форму конструктора <b>без параметров</b>, затем добавить любые прослушиватели событий, после чего вызвать метод <codeph>connect</codeph> с параметрами <codeph>host</codeph> и <codeph>port</codeph>. Эта последовательность гарантирует правильную работу всех приемников событий.</p>
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:XMLSocket:close"><apiName>close</apiName><shortdesc>
     Закрывает подключение, заданное объектом XMLSocket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.close, close
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Закрывает подключение, заданное объектом XMLSocket. Событие <codeph>close</codeph> отправляется только в тот момент, когда сервер закрывает соединение. Оно не отправляется при вызове метода <codeph>close()</codeph>.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:XMLSocket:connect"><apiName>connect</apiName><shortdesc>
     Создает подключение к заданному узлу в Интернете на указанный порт TCP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.connect, connect
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Локальные ненадежные файлы изолируются от Интернета. Можно устранить это ограничение, если переклассифицировать файл как локальный с сетевым подключением или доверенный.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Нельзя указывать номер порта сокета выше 65535.
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Полностью определенное имя домена DNS или IP-адрес в формате <i>111.222.333.444</i>. Также можно указать <codeph>null</codeph>, чтобы подключиться к серверу узла, на котором размещен рассматриваемый SWF-файл. Если вызывающим файлом является SWF-файл, выполняющийся в web-браузере, то в параметре <codeph>host</codeph> должен указываться тот же домен, в котором находится SWF-файл.
     
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Номер TCP-порта на целевом узле, используемый для установки подключения. Для Flash Player 9.0.124.0 и более поздних версий на целевом узле должен быть файл политик для сокетов, разрешающий подключения к сокетам через указанный порт для узла, на котором размещен SWF-файл. Для более ранних версий Flash Player файл политик для сокетов является обязательным, только если требуется подключиться к порту с номером ниже 1024 или если SWF-файл находится не на том узле, к которому выполняется подключение.
     
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Создает подключение к заданному узлу в Интернете на указанный порт TCP.
     
     <p>Если для параметра <codeph>host</codeph> указать значение <codeph>null</codeph>, то обращение производится к тому узлу, на котором размещен файл, вызывающий метод <codeph>XMLSocket.connect()</codeph>. Например, если вызывающий файл загружен с www.adobe.com, то использование значения <codeph>null</codeph> для параметра host указывает на то, что вы подключаетесь к сайту www.adobe.com.</p>
     
     
     <p platform="actionscript">Можно запретить использование файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</p>
     
     <p>Дополнительные сведения см. в следующих источниках.</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/CONNECT"><linktext>flash.events.Event.CONNECT</linktext></link></related-links><adobeApiEvent id="flash.net:XMLSocket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Операция подключения предприняла попытку подключения к узлу за пределами изолированной программной среды безопасности вызывающего компонента или к порту, для которого требуется файл политик для сокетов. Устранить эту проблему можно с использованием файла политик для сокетов на целевом узле.
     </apiDesc></adobeApiEventDetail><shortdesc>Операция подключения предприняла попытку подключения к узлу за пределами изолированной программной среды безопасности вызывающего компонента или к порту, для которого требуется файл политик для сокетов.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_data"><apiName>data</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после получения необработанных данных.
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после получения необработанных данных.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:XMLSocket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после установления сетевого подключения. 
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после установления сетевого подключения.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:XMLSocket:send"><apiName>send</apiName><shortdesc>
     Преобразует объект XML или данные, заданные параметром object, в строку, за которой следует нулевой байт (0), и передает ее на сервер.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>xmlsocket.send, send
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объект XMLSocket не подключен к серверу.
     
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>XML-объект или другие данные, которые необходимо передать на сервер.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Преобразует объект XML или данные, заданные параметром <codeph>object</codeph>, в строку, за которой следует нулевой байт (0), и передает ее на сервер. Если в качестве <codeph>object</codeph> используется XML-объект, строка является представлением XML-объекта в формате XML-текста. Операция отправки проходит в асинхронном режиме. Результат возвращается сразу же, но сами данные могут передаваться чуть позже. Метод <codeph>XMLSocket.send()</codeph> не возвращает значение, определяющее, успешно ли прошла передача данных.
     
     <p>Если вы не подключите объект XMLSocket к серверу с помощью <codeph>XMLSocket.connect()</codeph>), произойдет сбой операции <codeph>XMLSocket.send()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#XMLSocket/connect()"><linktext>connect()</linktext></link></related-links></apiOperation><apiValue id="flash.net:XMLSocket:connected:get"><apiName>connected</apiName><shortdesc>
     Определяет, подключен ли в настоящий момент данный объект XMLSocket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, подключен ли в настоящий момент данный объект XMLSocket. Для того чтобы также проверить успешность подключения, можно зарегистрироваться на получение события <codeph>connect</codeph> и события <codeph>ioError</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#XMLSocket/event:connect"><linktext>connect</linktext></link><link href="flash.net.xml#XMLSocket/event:ioError"><linktext>ioError</linktext></link></related-links></apiValue><apiValue id="flash.net:XMLSocket:timeout:set"><apiName>timeout</apiName><shortdesc>
     Указывает время ожидания подключения в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     Указывает время ожидания подключения в миллисекундах.
     
     <p>Если подключение не будет установлено в течение заданного срока, попытка завершается ошибкой. Значение по умолчанию: 20,000 (двадцать секунд).</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:ObjectEncoding"><apiName>ObjectEncoding</apiName><shortdesc>
 Класс ObjectEncoding используется для определения параметров сериализации в классах, сериализующих объекты (таких как FileStream, NetStream, NetConnection, SharedObject и ByteArray) для работы с предыдущими версиями ActionScript.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>ObjectEncoding, ObjectEncoding object, built-in class, AMF, Action Message Format
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс ObjectEncoding используется для определения параметров сериализации в классах, сериализующих объекты (таких как FileStream, NetStream, NetConnection, SharedObject и ByteArray) для работы с предыдущими версиями ActionScript. 
 
 <p>Кодировка объектов управляет представлением этих объектов в формате Action Message Format (AMF). С помощью AMF проигрыватель Flash Player обеспечивает эффективное взаимодействие между приложением и удаленным сервером. AMF кодирует удаленные вызовы процедуры в компактное двоичное представление, которое может быть передано по протоколу HTTP/HTTPS или RTMP/RTMPS, используемому сервером Flash Media Server. Объекты и значения данных сериализуются в этот двоичный формат, который в большинстве случаев обеспечивает более компактное представление данных, чем например язык XML.</p>
 
 <p>Adobe AIR и проигрыватель Flash Player 9 осуществляют сериализацию в двух различных форматах: AMF3 и AMF0. AMF3, используемая по умолчанию сериализация для ActionScript 3.0, обладает целым рядом преимуществ по сравнению с AMF0, которая используется для ActionScript 1.0 и 2.0. AMF3 отправляет данные по сети намного эффективнее, чем AMF0. <ph platform="actionscript">Формат AMF3 поддерживает отправку объектов <codeph>int</codeph> и <codeph>uint</codeph> в виде целых чисел, а также поддерживает типы данных, доступные только в ActionScript 3.0 (такие как ByteArray, XML и IExternalizable). Это доступно только в ActionScript 3.0 и на серверах, использующих кодировку AMF3, таких как Flex 2. </ph></p>
 
 <p>Классы ByteArray, FileStream, NetConnection, NetStream, <ph platform="actionscript">SharedObject,</ph> Socket и URLStream содержат свойство <codeph>objectEncoding</codeph>, которому присваивается константа из класса ObjectEncoding. Характеристики свойства <codeph>objectEncoding</codeph> зависят от самого объекта. В описании свойства <codeph>objectEncoding</codeph> для каждого класса даны более подробные сведения по этому вопросу.</p>
 
 
 </apiDesc></apiClassifierDetail><apiValue id="flash.net:ObjectEncoding:AMF0"><apiName>AMF0</apiName><shortdesc>
	 Указывает, что объекты сериализуются с помощью формата AMF для ActionScript 1.0 и 2.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объекты сериализуются с помощью формата AMF для ActionScript 1.0 и 2.0.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:AMF3"><apiName>AMF3</apiName><shortdesc>
	 Указывает, что объекты сериализуются с помощью формата AMF для ActionScript 3.0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объекты сериализуются с помощью формата AMF для ActionScript 3.0.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Указывает формат по умолчанию (последний) для текущей среды выполнения (Flash&amp;#xAE; Player или Adobe&amp;#xAE; AIR&amp;#xAE;).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает формат по умолчанию (последний) для текущей среды выполнения (Flash<sup>®</sup> Player или Adobe<sup>®</sup> AIR<sup>®</sup>). Поскольку управление кодировкой объекта доступно только в проигрывателе Flash Player 9, его более поздних версиях, а также в Adobe AIR, самым ранним применяемым форматом будет считаться Action Message Format for ActionScript 3.0.
	 
	 <p>Например, если свойство <codeph>objectEncoding</codeph> объекта установлено на значение <codeph>ObjectEncoding.DEFAULT</codeph>, используется кодировка AMF3. Если в будущем, в более поздней версии Flash Player или Adobe AIR будет представлена новая версия AMF и вы заново опубликуете содержимое, приложение будет использовать именно эту новую версию AMF. Эту константу можно применять только в том случае, если возможность взаимодействия с предыдущими версиями не является для вас актуальной.</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:ObjectEncoding:dynamicPropertyWriter:get"><apiName>dynamicPropertyWriter</apiName><shortdesc>
	 Обеспечивает более строгий контроль за сериализацией динамических свойств динамических объектов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.net:IDynamicPropertyWriter</apiValueClassifier></apiValueDef><apiDesc>
	 Обеспечивает более строгий контроль за сериализацией динамических свойств динамических объектов. Если данное свойство имеет значение <codeph>null</codeph> (значение по умолчанию), динамические свойства сериализуются с помощью собственного кода, который записывает все динамические свойства, за исключением тех, чьим значением является функция.
     <p>Данное значение вызывается только для свойств динамического объекта (объект, объявленный в рамках динамического класса) или для объектов, объявленных с помощью оператора <codeph>new</codeph>.</p>
	 
	 <p platform="actionscript">Данное свойство можно использовать для исключения сериализации свойств динамических объектов, а также для записи значений в свойства динамических объектов или создания для этих объектов новых свойств. Для этого установите данное свойство тому объекту, который реализует интерфейс IDynamicPropertyWriter. Дополнительную информацию см. в интерфейсе IDynamicPropertyWriter.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:Socket"><apiName>Socket</apiName><shortdesc>
 Класс Socket позволяет коду создавать подключения к сокету, а также считывать и записывать необработанные двоичные данные.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Socket позволяет коду создавать подключения к сокету, а также считывать и записывать необработанные двоичные данные. Он схож с XMLSocket, но не требует четкого формата полученных или переданных данных.
 
 <p>Класс Socket применяется при работе с серверами, использующими двоичные протоколы.</p>
 
 <p>Для использования методов класса Socket, необходимо сначала создать объект Socket с помощью конструктора <codeph>new Socket</codeph>.</p>
 
 <p>SWF-файлам в изолированной программной среде, локальной для файловой системы, запрещено использовать сокеты.</p>
      
  <p> <i>Файлы политик сокетов</i> на целевом узле определяют узлы, с которых SWF-файлы могут создавать подключения к сокетам, а также порты, доступные для таких подключений. В нескольких последних версиях Flash Player были ужесточены требования по безопасности относительно файлов политик сокетов. Компания Adobe рекомендует использовать файл политик для сокетов для всех версий Flash Player, а в некоторых случаях его применение является обязательным. Поэтому, если используются объекты XMLSocket, проследите, чтобы целевой узел при необходимости предоставлял файл политик для сокетов. </p>
 
  <p>В следующем списке приводятся все требования к файлам политик сокетов для разных версий Flash Player.</p>
 
  <ul>
  
   <li> В Flash Player 9.0.124.0 и более поздних версиях файл политик для сокетов является обязательным для любого подключения Socket. Другими словами, файл политик для сокетов обязательно должен быть на целевом узле независимо от того, к какому порту выполняется подключение. Этот файл должен быть, даже если устанавливается подключение к порту на том же узле, на котором находится SWF-файл. </li>
 
   <li> В приложении Flash Player 9.0.115.0 и более ранних версиях файл политик для сокетов на целевом узле является обязательным, если устанавливается подключение к порту с номером меньше 1024 или если требуется подключиться не к тому узлу, на котором размещен SWF-файл. </li>
 
  <li> В Flash Player 9.0.115.0 при использовании отладочной версии проигрывателя в случае отсутствия файла политик для сокетов на целевом сервере отображается предупреждение, даже если файл политик для сокетов не является обязательным. </li>
 
  </ul>
 
 <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
  
 <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\SocketExample.as"> В следующем примере рассматриваются операции записи и чтения на сокете, а также вывод информации, переданной во время событий сокета. Основные моменты данного примера представлены ниже:
 <ol>
    <li>Конструктор создает экземпляр <codeph>CustomSocket</codeph> с именем <codeph>socket</codeph> и передает в качестве аргументов имя узла <codeph>localhost</codeph> и порт 80. Так как <codeph>CustomSocket</codeph> расширяет Socket, вызов метода <codeph>super()</codeph> расширяет конструктор Socket.</li>
    <li>Затем в примере вызывается метод <codeph>configureListeners()</codeph>, добавляющий прослушивателей для событий Socket.</li>
      <li>В завершение, вызывается метод <codeph>connect()</codeph> сокета с именем узла <codeph>localhost</codeph> и номером порта 80.</li>
 </ol>
 
 <p> <b>Примечание.</b> Для запуска данного примера вам потребуется сервер, запущенный в том же домене, где размещен SWF-файл (в данном примере: <codeph>localhost</codeph>), и прослушивающий порт 80.</p>
<codeblock>

package {
    import flash.display.Sprite;

    public class SocketExample extends Sprite {

        public function SocketExample() {
            var socket:CustomSocket = new CustomSocket("localhost", 80);
        }
    }
}

import flash.errors.*;
import flash.events.*;
import flash.net.Socket;

class CustomSocket extends Socket {
    private var response:String;

    public function CustomSocket(host:String = null, port:uint = 0) {
        super();
        configureListeners();
        if (host &amp;&amp; port)  {
            super.connect(host, port);
        }
    }

    private function configureListeners():void {
        addEventListener(Event.CLOSE, closeHandler);
        addEventListener(Event.CONNECT, connectHandler);
        addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);
    }

    private function writeln(str:String):void {
        str += "\n";
        try {
            writeUTFBytes(str);
        }
        catch(e:IOError) {
            trace(e);
        }
    }

    private function sendRequest():void {
        trace("sendRequest");
        response = "";
        writeln("GET /");
        flush();
    }

    private function readResponse():void {
        var str:String = readUTFBytes(bytesAvailable);
        response += str;
    }

    private function closeHandler(event:Event):void {
        trace("closeHandler: " + event);
        trace(response.toString());
    }

    private function connectHandler(event:Event):void {
        trace("connectHandler: " + event);
        sendRequest();
    }

    private function ioErrorHandler(event:IOErrorEvent):void {
        trace("ioErrorHandler: " + event);
    }

    private function securityErrorHandler(event:SecurityErrorEvent):void {
        trace("securityErrorHandler: " + event);
    }

    private function socketDataHandler(event:ProgressEvent):void {
        trace("socketDataHandler: " + event);
        readResponse();
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.net:Socket_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Отправляется, если вызов метода Socket.connect() инициирует попытку подключения к серверу за пределами изолированной среды вызывающего объекта, или к порту с номером, меньшим чем 1024.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS check this info
 </internal></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>Socket.connect()</codeph> инициирует попытку подключения к серверу за пределами изолированной среды вызывающего объекта, или к порту с номером, меньшим чем 1024.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>Socket.connect()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.ProgressEvent.SOCKET_DATA_socketData"><apiName>socketData</apiName><shortdesc>
 Отправляется, когда сокет получает данные.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.SOCKET_DATA</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда сокет получает данные. В событиях типа <codeph>socketData</codeph> не используется свойство <codeph>ProgressEvent.bytesTotal</codeph>. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции отправки или загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции отправки или загрузки. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CONNECT_connect"><apiName>connect</apiName><shortdesc>
 Отправляется после установления сетевого подключения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CONNECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после установления сетевого подключения. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:Socket_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 Отправляется, когда сервер закрывает подключение к сокету.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда сервер закрывает подключение к сокету. Событие <codeph>close</codeph> отправляется только в тот момент, когда сервер закрывает соединение. Оно не отправляется при вызове метода <codeph>Socket.close()</codeph>.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:Socket:Socket"><apiName>Socket</apiName><shortdesc>
    Создает новый объект Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS determine if all above events are accurate, and which ones also apply
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Эта ошибка возникает в SWF-содержимом<ph platform="javascript">.</ph> <ph platform="actionscript"> по следующим причинам:</ph>
	 
     <ul platform="actionscript">
       <li>Локальные для файловой системы файлы изолированы от Интернета. Данную проблему можно обойти, если переклассифицировать этот SWF-файл как локальный с сетевым подключением или доверенный. Это ограничение не применимо к содержимому приложения AIR в изолированной программной среде безопасности приложения.</li>
	 
      <li>Не допускается указывать номер порта сокета выше 65535.</li>
    </ul>
	 
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Полностью определенное имя домена DNS или IP-адрес в формате <i>111.222.333.444</i>. В приложении Flash Player 9.0.115.0 и AIR 1.0 и более поздней версии можно задать IPv6- адреса, например rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]. Также можно указать <codeph>null</codeph>, чтобы подключиться к серверу узла, на котором размещен рассматриваемый SWF-файл. Если SWF-файл, инициирующий данный вызов, запущен в web-браузере, то в параметре <codeph>host</codeph> должен указываться тот же домен, в котором находится SWF-файл.
    
    </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Номер TCP-порта на целевом узле, используемый для установки подключения. Для Flash Player 9.0.124.0 и более поздних версий на целевом узле должен быть файл политик для сокетов, разрешающий подключения к сокетам через указанный порт для узла, на котором размещен SWF-файл. Для более ранних версий Flash Player файл политик для сокетов является обязательным, только если требуется подключиться к порту с номером ниже 1024 или если SWF-файл находится не на том узле, к которому выполняется подключение.
    
    
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
    Создает новый объект Socket. Если не указаны никакие параметры, создается первоначально отключенный сокет. Если параметры указаны, производится попытка подключиться к указанному узлу и порту.
    
    <p><b>Примечание.</b> Настоятельно рекомендуется использовать форму конструктора <b>без параметров</b>, затем добавить любые прослушиватели событий, после чего вызвать метод <codeph>connect</codeph> с параметрами <codeph>host</codeph> и <codeph>port</codeph>. Эта последовательность гарантирует правильную работу всех прослушивателей событий.</p>
    
    </apiDesc></apiConstructorDetail><adobeApiEvent id="flash.net:Socket:Socket_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после установления сетевого подключения.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после установления сетевого подключения.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою подключения.
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою подключения.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:Socket_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><ph platform="javascript">Эта ошибка возникает в SWF-содержимом. </ph> <ph platform="actionscript"> Отправляется, если вызов <codeph>Socket.connect()</codeph> пытается установить подключение к серверу, на котором нет файла политик для сокетов, либо к серверу, на котором файл политик для сокетов не предоставляет вызывающему узлу доступ к указанному порту. Подробные сведения о файлах политик для сокетов см. в главе «Система безопасности проигрывателя Flash Player» руководства <i>Programming ActionScript 3.0</i>.</ph>
	 
    </apiDesc></adobeApiEventDetail><shortdesc>Эта ошибка возникает в SWF-содержимом. Отправляется, если вызов Socket.connect() пытается установить подключение к серверу, на котором нет файла политик для сокетов, либо к серверу, на котором файл политик для сокетов не предоставляет вызывающему узлу доступ к указанному порту.</shortdesc></adobeApiEvent></apiConstructor><apiOperation id="flash.net:Socket:close"><apiName>close</apiName><shortdesc>
     Закрывает сокет.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Не удалось закрыть сокет или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Закрывает сокет. После вызова метода <codeph>close()</codeph> вы не сможете считать или записать какие-либо данные.
     
     <p>Событие <codeph>close</codeph> отправляется только в тот момент, когда сервер закрывает соединение. Оно не отправляется при вызове метода <codeph>close()</codeph>.</p>
     
     <p>Для повторного использования объекта Socket снова вызовите для него метод <codeph>connect()</codeph>.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:connect"><apiName>connect</apiName><shortdesc>
     Подключает сокет к заданному узлу и порту.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>BRS compare this entire description with XMLSocket.connect() and make consistent
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Сбой подключения, так как не был указан узел.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Эта ошибка возникает в SWF-содержимом<ph platform="javascript">.</ph> <ph platform="actionscript"> по следующим причинам:</ph>
	 
          <ul platform="actionscript">
              <li>Локальные ненадежные SWF-файлы могут быть изолированы от Интернета. Можно устранить это ограничение, если переклассифицировать файл как локальный с сетевым подключением или доверенный.</li>
               <li>Не допускается указывать номер порта сокета выше 65535.</li>
           <li>На HTML-странице с SWF-cодержимым для параметра <codeph>allowNetworking</codeph> тегов <codeph>object</codeph> и <codeph>embed</codeph> устанавливается значение <codeph>none</codeph>.</li>
	 
          </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>host</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя или IP-адрес узла, к которому нужно подключиться. Если узел не указан, то обращение производится к тому узлу, на котором размещен вызывающий файл. Если узел не указан, для определения успешности подключения используйте прослушиватель событий.
     </apiDesc></apiParam><apiParam><apiItemName>port</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Номер порта для подключения.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Подключает сокет к заданному узлу и порту. Мгновенный сбой подключения приводит к отправке события или созданию исключения: если узел был указан, отправляется событие ошибки, а если узел не был указан, то создается исключение. В противном случае, состояние подключения сообщается посредством события. Если сокет уже подключен, то сначала закрывается именно существующее подключение.
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:Socket:connect_connect"><apiName>connect</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после установления сетевого подключения.
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после установления сетевого подключения.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, если узел указан, но возникает ошибка ввода-вывода, вызывающая сбой подключения.
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, если узел указан, но возникает ошибка ввода-вывода, вызывающая сбой подключения.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:Socket:connect_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, если вызов <codeph>Socket.connect()</codeph> пытается установить подключение к серверу, на котором нет файла политик для сокетов, либо к серверу, на котором файл политик для сокетов не предоставляет вызывающему узлу доступ к указанному порту. Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, если вызов Socket.connect() пытается установить подключение к серверу, на котором нет файла политик для сокетов, либо к серверу, на котором файл политик для сокетов не предоставляет вызывающему узлу доступ к указанному порту.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:Socket:flush"><apiName>flush</apiName><shortdesc>
     Очищает любые накопленные данные в выходном буфере сокета.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.       
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Очищает любые накопленные данные в выходном буфере сокета. Данные, записанные методом <codeph>write</codeph>, передаются не сразу – они находятся в очереди до вызова метода <codeph>flush()</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     Считывает из сокета логическое значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение равно <codeph>true</codeph>, если считывается ненулевой байт, в противном случае используется значение <codeph>false</codeph>.
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета логическое значение. После считывания одного байта метод возвращает <codeph>true</codeph>, если этот байт ненулевой, в противном случае, возвращается значение <codeph>false</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readByte"><apiName>readByte</apiName><shortdesc>
     Считывает из сокета байт со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от -128 до 127.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета байт со знаком.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readBytes"><apiName>readBytes</apiName><shortdesc>
     Считывает из сокета число байт данных, заданное параметром length.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, в который считываются данные.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Смещение, с которого должно начинаться считывание данных в байтовом массиве.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Число байт для считывания. Если значение по умолчанию равно 0, считываются все доступные данные.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Считывает из сокета число байт данных, заданное параметром <codeph>length</codeph>. Байты считываются в указанный байтовый массив, при этом начальная позиция указывается в параметре <codeph>offset</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readDouble"><apiName>readDouble</apiName><shortdesc>
     Считывает из сокета число IEEE 754 двойной точности с плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число IEEE 754 двойной точности с плавающей запятой.
     
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета число IEEE 754 двойной точности с плавающей запятой.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readFloat"><apiName>readFloat</apiName><shortdesc>
     Считывает из сокета число IEEE 754 одинарной точности с плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число IEEE 754 одинарной точности с плавающей запятой.
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета число IEEE 754 одинарной точности с плавающей запятой.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readInt"><apiName>readInt</apiName><shortdesc>
     Считывает из сокета 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от -2147483648 до 2147483647.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета 32-разрядное целое число со знаком.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     Считывает многобайтовую строку из потока байт с использованием заданного набора знаков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8.
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число считываемых из потока байтов.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, обозначающая набор символов, которые используются для интерпретации байтов. Возможные строки наборов символов: <codeph>shift_jis</codeph>, <codeph>CN-GB</codeph> и <codeph>iso-8859-1</codeph>. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>.
     
     <p><b>Примечание.</b> Если текущая система не распознает значение параметра <codeph>charSet</codeph>, то в качестве набора символов приложение будет использовать кодовую страницу по умолчанию. Так, значение параметра <codeph>charSet</codeph>, например в <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph>, которое использует <codeph>01</codeph>вместо <codeph>1</codeph> может работать на вашем компьютере, но привести к сбою на другой рабочей станции. На другом компьютере приложение будет использовать кодовую страницу, заданную по умолчанию в системе.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Считывает многобайтовую строку из потока байт с использованием заданного набора знаков.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readObject"><apiName>readObject</apiName><shortdesc>
     Считывает объект из сокета, зашифрованного в сериализованный формат AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Десериализованный объект
     
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     Считывает объект из сокета, зашифрованного в сериализованный формат AMF.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:readShort"><apiName>readShort</apiName><shortdesc>
     Считывает из сокета 16-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от -32768 до 32767.
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета 16-разрядное целое число со знаком.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTF"><apiName>readUTF</apiName><shortdesc>
     Считывает из сокета строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка UTF-8.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета строку UTF-8. Предполагается, что в строку вставляется префикс с неподписанным коротким целым числом, указывающим длину в байтах.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     Считывает из сокета число байт данных UTF-8, заданное параметром length и возвращает строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка UTF-8.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число байт для считывания.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Считывает из сокета число байт данных UTF-8, заданное параметром <codeph>length</codeph> и возвращает строку.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     Считывает из сокета байт без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от 0 до 255.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета байт без знака.  
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     Считывает из сокета 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от 0 до 4294967295.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета 32-разрядное целое число без знака.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     Считывает из сокета 16-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от 0 до 65535.
     
     </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из сокета 16-разрядное целое число без знака.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:Socket:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
     Записывает логическое значение в сокет.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Значение, записываемое в сокете: 1 (<codeph>true</codeph>) или 0 (<codeph>false</codeph>).
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает логическое значение в сокет. Данный метод записывает один байт со значением 1 (<codeph>true</codeph>) или 0 (<codeph>false</codeph>).
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeByte"><apiName>writeByte</apiName><shortdesc>
     Записывает байт в сокет.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение, записываемое в сокет. Используются 8 младших битов значения, а 24 старших бита игнорируются.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает байт в сокет.
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeBytes"><apiName>writeBytes</apiName><shortdesc>
     Записывает последовательность байт из заданного массива байт.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, из которого должны записываться данные.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Нулевое смещение в объекте ByteArray <codeph>bytes</codeph>, с которого должна начаться запись данных.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Число записываемых байтов. Использование значения по умолчанию, равного 0, приводит к записи всего буфера, начиная со значения, указанного параметром <codeph>offset</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает последовательность байт из заданного массива байт. Операция записи начинается в позиции, указанной в <codeph>offset</codeph>.
     
     <p>Если будет опущен параметр <codeph>length</codeph>, применение длины по умолчанию, равной 0, приведет к тому, что метод будет записывать весь буфер, начиная со смещения <codeph>offset</codeph>.</p>
     
     <p>Если также опустить параметр <codeph>offset</codeph>, будет записываться весь буфер.</p> 
      
     <p>Если параметры <codeph>offset</codeph> или <codeph>length</codeph> находятся за пределами диапазона, то они корректируются, чтобы совпасть с началом и концом массива <codeph>bytes</codeph>.</p>
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeDouble"><apiName>writeDouble</apiName><shortdesc>
     Записывает в сокет число IEEE 754 двойной точности с плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Значение, записываемое в сокет.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает в сокет число IEEE 754 двойной точности с плавающей запятой.
     
     <p><b>Примечание.</b> Записанные этим методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeFloat"><apiName>writeFloat</apiName><shortdesc>
     Записывает в сокет число IEEE 754 одинарной точности с плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Значение, записываемое в сокет.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает в сокет число IEEE 754 одинарной точности с плавающей запятой.
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeInt"><apiName>writeInt</apiName><shortdesc>
     Записывает в сокет 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение, записываемое в сокет.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает в сокет 32-разрядное целое число со знаком.
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
     Записывает многобайтовую строку из потока байт с использованием заданного набора знаков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Socket, Socket.writeMultiByte, writeMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, обозначающая набор символов, которые используются для интерпретации байтов. Возможные строки наборов символов: <codeph>shift_jis</codeph>, <codeph>CN-GB</codeph> и <codeph>iso-8859-1</codeph>. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает многобайтовую строку из потока байт с использованием заданного набора знаков.
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeObject"><apiName>writeObject</apiName><shortdesc>
     Записывает объект в сокет в сериализованном формате AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Объект для сериализации.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает объект в сокет в сериализованном формате AMF.
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeShort"><apiName>writeShort</apiName><shortdesc>
     Записывает в сокет 16-разрядное целое число.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение, записываемое в сокет.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает в сокет 16-разрядное целое число. Записанные байты выглядят следующим образом:
     
     <pre><codeph>(v >> 8) &amp; 0xff v &amp; 0xff</codeph></pre>
     
     <p>Используются 16 младших битов параметра, а 16 старших битов игнорируются.</p>
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTF"><apiName>writeUTF</apiName><shortdesc>
     Записывает следующие данные в сокет: 16-разрядное целое число без знака, указывающее на длину заданной строки UTF-8 в байтах, а затем саму строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Длина превышает 65535.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, записываемая в сокет.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает следующие данные в сокет: 16-разрядное целое число без знака, указывающее на длину заданной строки UTF-8 в байтах, а затем саму строку.
     
     <p>Перед тем как записать строку, метод рассчитывает количество байтов, необходимое для представления всех символов строки.</p>
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
     Записывает строку UTF-8 в сокет.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, записываемая в сокет.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает строку UTF-8 в сокет. 
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:Socket:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
     Записывает в сокет 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>В сокете возникла ошибка ввода-вывода или сокет не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Значение, записываемое в сокет.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Записывает в сокет 32-разрядное целое число без знака.
     
     <p><b>Примечание.</b> Записанные таким методом данные передаются не сразу – они находятся в очереди до того, как будет вызван метод <codeph>flush()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Socket/flush()"><linktext>flush()</linktext></link></related-links></apiOperation><apiValue id="flash.net:Socket:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     Число байт данных, доступных для чтения во входном буфере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Число байт данных, доступных для чтения во входном буфере.
     
     <p>В вашем коде должен быть вызов свойства <codeph>bytesAvailable</codeph>, проверяющий доступность необходимого объема данных до того, как вы попытаетесь сосчитать их с помощью одного из методов <codeph>read</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:connected:get"><apiName>connected</apiName><shortdesc>
     Определяет, подключен ли в настоящий момент этот объект Socket.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, подключен ли в настоящий момент этот объект Socket. Вызов этого свойства возвращает значение <codeph>true</codeph>, если сокет в настоящий момент подключен, или значение <codeph>false</codeph>, если не подключен.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:Socket:endian:get"><apiName>endian</apiName><shortdesc>
     Определяет порядок байтов данных. Возможными значениями являются константы из класса flash.utils.Endian, Endian.BIG_ENDIAN или Endian.LITTLE_ENDIAN.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     Определяет порядок байтов данных. Возможными значениями являются константы из класса flash.utils.Endian, <codeph>Endian.BIG_ENDIAN</codeph> или <codeph>Endian.LITTLE_ENDIAN</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Управляет версией AMF, применяемой при записи или чтении объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Управляет версией AMF, применяемой при записи или чтении объекта.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link><link href="flash.net.xml#Socket/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#Socket/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.net:Socket:timeout:set"><apiName>timeout</apiName><shortdesc>
     Указывает время ожидания подключения в миллисекундах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Указывает время ожидания подключения в миллисекундах.
     
     <p>Если подключение не будет установлено в течение заданного срока, попытка завершается ошибкой. Значение по умолчанию 20,000 (двадцать секунд).</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoader"><apiName>URLLoader</apiName><shortdesc>
 Класс URLLoader загружает данные с URL-адреса в виде текста, двоичных данных или переменных в кодировке URL.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс URLLoader загружает данные с URL-адреса в виде текста, двоичных данных или переменных в кодировке URL. Данная функция целесообразна при загрузке текстовых файлов, XML-объектов или других сведений, которые будут использованы в динамическом приложении по обработке данных.
 
 <p>Объект URLLoader загружает все данные с URL-адреса, прежде чем сделать их доступными для кода в приложениях. Он отправляет оповещения о состоянии загрузки, которые можно отслеживать с помощью свойств <codeph>bytesLoaded</codeph> и <codeph>bytesTotal</codeph>, а также посредством отправленных событий.</p>
 
 <p>При загрузке очень больших видеофайлов, таких как FLV, могут возникнуть ошибки из-за нехватки памяти.
 </p>
 
 
 
 <p>При использовании данного класса в содержимом проигрывателя<ph platform="actionscript">Flash Player</ph> и приложения AIR, размещенном в изолированных программных средах безопасности, отличных от среды безопасности приложения, необходимо учитывать следующую модель безопасности:</p>
 
 <ul>
 <li>SWF-файл в изолированной программной среде, локальной для файловой системы, может не поддерживать загрузку и передачу данных для ресурса, находящегося в сетевой изолированной программной среде. </li>
 
 <li> По умолчанию вызывающий SWF-файл и загружаемый URL-адрес должны находиться в одном и том же домене. Например, SWF-файл на www.adobe.com может загружать данные только из источников, которые также размещены на сайте www.adobe.com. Чтобы загрузить данные с другого домена, разместите файл политик для URL на сервере, где расположены эти данные.</li>
 </ul>
  
 <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
 
 <ul>
 
 <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
   <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 
 </ul>
 
 
 </apiDesc><example conref="examples\URLLoaderExample.as"> В следующем примере загружаются и отображаются данные, найденные в локальном текстовом файле. Здесь также отслеживается информация по обработке событий.
 
 <p><b>Примечание.</b> Для выполнения этого примера поместите файл urlLoaderExample.txt в тот же каталог, где находится ваш SWF-файл. Данный файл должен содержать только следующую строку текста: <codeph>answer=42&amp;question=unknown</codeph>
 </p>
 <p>Данный пример кода выполняет следующее:</p>
 <ol>
    <li>Функция конструктора создает экземпляр URLLoader под именем <codeph>loader</codeph> и экземпляр URLRequest под именем <codeph>request</codeph>, в котором указывается место размещения и имя загружаемого файла.</li>
    <li>Объект <codeph>loader</codeph> передается методу <codeph>configureListeners()</codeph>, который добавляет прослушивателей для каждого из поддерживаемых событий URLLoader.</li>
    <li>Далее объект <codeph>request</codeph> передается методу <codeph>loader.load()</codeph>, который загружает текстовый файл.</li>
      <li>После того как URLLoader завершит загрузку текстового файла, отправляется событие <codeph>Event.COMPLETE</codeph>, которое запускает метод <codeph>completeHandler()</codeph>. Метод <codeph>completeHandler()</codeph> создает объект URLVariables на основе текста, загруженного из файла. Чтобы облегчить манипулирование загруженными данными, объект URLVariables преобразует пары «имя-значение» (в кодировке URL) в свойства ActionScript.</li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderExample extends Sprite {
        public function URLLoaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("urlLoaderExample.txt");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
    
            var vars:URLVariables = new URLVariables(loader.data);
            trace("The answer is " + vars.answer);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 Отправляется, если вызов метода load(), пытающийся обратиться к данным через HTTP и Adobe AIR, может обнаружить и вернуть код состояния для запроса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>load()</codeph>, пытающийся обратиться к данным через HTTP и Adobe AIR, может обнаружить и вернуть код состояния для запроса. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Отправляется, если вызов метода URLLoader.load() инициирует попытку доступа к данным по протоколу HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>URLLoader.load()</codeph> инициирует попытку доступа к данным по протоколу HTTP. <ph platform="actionscript">В отношении содержимого, выполняющегося в проигрывателе Flash Player, это событие отправляется, только если текущая среда Flash Player может определить и вернуть код состояния для запроса. (В некоторых браузерах данная информация не предоставляется.)</ph> Обратите внимание на то, что событие <codeph>httpStatus</codeph> (при наличии такового) будет отправляться до (как дополнение) любого события <codeph>complete</codeph> или <codeph>error</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Отправляется, если путем вызова метода URLLoader.load() предпринимается попытка загрузить данные с сервера, расположенного за пределами изолированной среды.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>URLLoader.load()</codeph> инициирует попытку загрузить данные с сервера, расположенного за пределами изолированной среды. Кроме того, отправляется, если при вызове <codeph>URLLoader.load()</codeph> предпринимается попытка загрузить SWZ-файл, при этом сертификат является недействительным, либо строка дайджеста не соответствует компоненту.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, если вызов метода URLLoader.load() приводит к неустранимой ошибке, прекращающей загрузку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>URLLoader.load()</codeph> приводит к неустранимой ошибке, прекращающей загрузку.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Отправляется в случае получения данных в ходе операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется в случае получения данных в ходе операции загрузки.
 
 <p>Обратите внимание на то, что в случае с объектом URLLoader, данные становятся доступными только после полной загрузки. Поэтому событие состояния служит лишь оповещением о том, как проходит загрузка. Для доступа к данным, которые еще не загружены полностью, используйте объект URLStream. </p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Отправляется после декодирования всех полученных данных и размещения их в свойстве data объекта URLLoader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после декодирования всех полученных данных и размещения их в свойстве <codeph>data</codeph> объекта URLLoader. Полученные данные станут доступными, как только будет отправлено это событие.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Отправляется, когда операция загрузки начинается после вызова метода URLLoader.load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда операция загрузки начинается после вызова метода <codeph>URLLoader.load()</codeph>. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:URLLoader:URLLoader"><apiName>URLLoader</apiName><shortdesc>
	 Создает объект URLLoader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiData>null</apiData><apiDesc>Объект URLRequest, определяющий URL-адрес для загрузки. Если данный оператор пропущен, операция загрузки не начинается. При указании такового операция загрузки начинается немедленно (дополнительные сведения см. в разделе о <codeph>load</codeph>).
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает объект URLLoader.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#URLLoader/load()"><linktext>URLLoader.load()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:URLLoader:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Тип события.
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Функция прослушивателя, обрабатывающая событие. Эта функция должна принимать объект Event в качестве единственного параметра и не должна что-либо возвращать <ph platform="actionscript">, как показано в примере:</ph> <ph platform="javascript">.</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>Эта функция может иметь любое имя.</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">Этот параметр применяется для отображения объектов в архитектуре списка отображения ActionScript 3.0, используемой в SWF-содержимом. </ph> <ph platform="actionscript">Определяет, работает ли прослушиватель в фазе захвата или в целевой фазе и в фазе восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>true</codeph>, прослушиватель обрабатывает событие только во время фазы захвата, но не во время целевой фазы или фазы восходящей цепочки. Если значение <codeph>useCapture</codeph> равно <codeph>false</codeph>, то прослушиватель обрабатывает событие только в целевой фазе или фазе восходящей цепочки. Чтобы прослушивать событие во всех трех фазах, необходимо вызвать <codeph>addEventListener()</codeph> дважды: один раз с <codeph>useCapture</codeph> в значении <codeph>true</codeph>, а другой – с <codeph>useCapture</codeph> в значении <codeph>false</codeph>. </ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Уровень приоритета прослушивателя событий. Приоритет определяется 32-разрядным целым числом со знаком. Чем больше число, тем выше приоритет. Все прослушиватели событий с приоритетом <i>n</i> обрабатываются перед прослушивателями с приоритетом <i>n</i>-1. Прослушиватели с одинаковым приоритетом обрабатываются в порядке их добавления. Значение приоритета по умолчанию равно 0.
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, является ли ссылка на прослушивателя «сильной» или «слабой». «Сильная» ссылка (по умолчанию) предотвращает удаление прослушивателя сборщиком мусора. «Слабая» ссылка позволяет удалить прослушиватель. <p>Функции элементов уровня класса не подлежат удалению в качестве мусора, вследствие чего можно установить <codeph>useWeakReference</codeph> равным <codeph>true</codeph> для функций элементов уровня класса, не подвергая их возможности подобного удаления. Если свойству <codeph>useWeakReference</codeph> присвоить значение <codeph>true</codeph> для прослушивателя, который является вложенной внутренней функцией, то функция будет очищена и перестанет быть постоянной. При создании ссылок на внутреннюю функцию (возможно сохранение в другой переменной) она не будет собираться в качестве мусора и останется устойчивой.</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии. <ph platform="actionscript">Можно регистрировать прослушиватели событий в любом узле из списка отображения для каждого типа события, фазы и приоритета.</ph>
	
	<p platform="javascript">В коде JavaScript в среде выполнения AIR этот метод используется в целях регистрации прослушивателей событий, определенных интерфейсами AIR API. Для других событий JavaScript (таких как событие <codeph>onload</codeph> объекта <codeph>body</codeph> в модели DOM) можно использовать те же стандартные способы обработки событий, что и для содержимого в обозревателе.</p>
	
	<p>После успешной регистрации прослушивателя событий невозможно изменить его приоритет путем дополнительных вызовов <codeph>addEventListener()</codeph>. Чтобы изменить приоритет прослушивателя, необходимо сначала вызвать метод <codeph>removeListener()</codeph>. Затем можно снова зарегистрировать прослушиватель с новым приоритетом. </p>
	
	<p>Следует учесть, что после регистрации прослушивателя последующие вызовы метода <codeph>addEventListener()</codeph> с другим значением свойства <codeph>type</codeph> или <codeph>useCapture</codeph> приводят к регистрации другого прослушивателя. <ph platform="actionscript">Например, прослушиватель, изначально зарегистрированный со значением <codeph>useCapture</codeph>, равным <codeph>true</codeph>, прослушивает только во время фазы захвата. Если вызвать метод <codeph>addEventListener()</codeph> еще раз с тем же объектом прослушивателя, но со свойством <codeph>useCapture</codeph> в значении <codeph>false</codeph>, то будет два прослушивателя: один – прослушивающий в фазе захвата, а другой – в целевой фазе и фазе восходящей цепочки. </ph>
	</p>
	
	<p platform="actionscript">Невозможно зарегистрировать прослушиватель события только для целевой фазы или для фазы восходящей цепочки. Эти фазы соединены при регистрации, поскольку восходящая цепочка применяется только к предшественникам целевого узла.</p>
	
	<p>Если прослушиватель событий больше не нужен, его можно удалить, вызвав метод <codeph>removeEventListener()</codeph>, иначе могут возникнуть проблемы с памятью. Прослушиватели событий не удаляются из памяти автоматически, так как сборщик мусора не удаляет прослушиватель, пока существует объект, отправляющий соответствующее событие (если параметру <codeph>useWeakReference</codeph> не задано значение <codeph>true</codeph>).</p>
		
	<p>Копирование экземпляра EventDispatcher не приводит к копированию прослушивателей событий, присоединенных к нему. (Если для вновь создаваемого узла требуется прослушиватель событий, его необходимо присоединить после создания узла.) При этом при перемещении экземпляра EventDispatcher присоединенные к нему прослушиватели событий перемещаются вместе с ним.</p>
	
	
	<p platform="actionscript">Если прослушиватель регистрируется для узла в тот момент, когда на нем обрабатывается событие, то в текущей фазе он не запускается, однако может запуститься в следующей фазе потока события, например в фазе восходящей цепочки.</p>
	
	<p platform="actionscript">Прослушиватель событий, удаленный из узла во время обработки события на этом узле, будет запускаться текущими операциями. После удаления прослушиватель событий больше не вызывается (если не будет снова зарегистрирован для дальнейшей обработки). </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:close"><apiName>close</apiName><shortdesc>
	 Закрывает выполняемую операцию загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Закрывает выполняемую операцию загрузки. Любая операция загрузки, выполняемая в данный момент, немедленно прекращается. Если в текущий момент нет потокового воспроизведения с URL-адреса, создается ошибка «недопустимый поток».
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLLoader:load"><apiName>load</apiName><shortdesc>
	 Отправляет и загружает данные с заданного URL-адреса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты <codeph>URLRequest.requestHeader</codeph> могут не содержать определенные запрещенные заголовки запроса HTTP. Дополнительную информацию см. в описании класса URLRequestHeader.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка может возникнуть по следующим причинам: 1) проигрыватель <ph platform="actionscript">Flash Player </ph> или приложение AIR не могут преобразовать значение параметра <codeph>URLRequest.data</codeph> из UTF8 в MBCS. Данная ошибка может возникнуть, если объект URLRequest, переданный методу <codeph>load()</codeph>, настроен на выполнение операции <codeph>GET</codeph>, а параметр <codeph>System.useCodePage</codeph> имеет значение <codeph>true</codeph>. 2) Проигрыватель <ph platform="actionscript">Flash Player </ph> или приложение AIR не могут выделить память для данных <codeph>POST</codeph>. Данная ошибка может возникнуть, если переданный для <codeph>load</codeph> объект URLRequest настроен на выполнение операции <codeph>POST</codeph>.
	 
	 </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Локальные ненадежные файлы изолируются от Интернета. Чтобы обойти эту проблему, можно переклассифицировать данный файл как локальный с сетевым подключением или доверенный.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Значение параметра запроса или свойства <codeph>URLRequest.url</codeph> переданного объекта URLRequest равно <codeph>null</codeph>.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest, определяющий URL-адрес для загрузки.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отправляет и загружает данные с заданного URL-адреса. Данные могут быть получены как текст, необработанные двоичные данные или переменные в кодировке URL. Это зависит от значения, установленного для свойства <codeph>dataFormat</codeph>. Обратите внимание на то, что значением свойства <codeph>dataFormat</codeph> по умолчанию является текст. Для отправки данных на указанный URL-адрес можно установить в объекте URLRequest свойство <codeph>data</codeph>.
	 
	 <p><b>Примечание.</b> Если загружаемый файл содержит не-ASCII-символы (присутствующие во многих языках, кроме английского), рекомендуется сохранить файл в кодировке UTF-8 или UTF-16.</p>
	 
	 <p> SWF-файл в изолированной программной среде, локальной для файловой системы, может не поддерживать загрузку и передачу данных для ресурса, находящегося в сетевой изолированной программной среде.</p> 
	  
	 <p> По умолчанию вызывающий SWF-файл и загружаемый URL-адрес должны находиться в одном и том же домене. Например, SWF-файл на www.adobe.com может загружать данные только из источников, которые также размещены на сайте www.adobe.com. Чтобы загрузить данные с другого домена, разместите файл политик для URL на сервере, где расположены эти данные.</p>
	 
      <p>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава «Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
     
     <p> В приложении Flash Player 10 и более поздней версии при использовании типа содержимого multipart (например, multipart/form-data), в котором содержится загрузка (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для отправок:</p>
	 <ul>
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p>Кроме того, все объекты multipart Content-Type должны иметь допустимый синтаксис (в соответствии со стандартами RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для загрузок.</p>
     
	 <p>Дополнительные сведения о безопасности см. в следующих ресурсах:</p>
	 
     <ul>
     
     
	 <li>Раздел Understanding AIR Security главы Getting started with Adobe AIR книги <i>Developing AIR Applications</i>.</li>
	 
	 <li><xref href="http://www.adobe.com/go/fp9_0_security_ru" scope="external">Технический бюллетень по вопросам безопасности в проигрывателе Flash Player 9</xref>.</li>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава «Безопасность»</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
	 
	 </apiDesc><example conref="examples\URLLoader_loadExample.as"> В следующем примере загружается XML-файл, а затем содержимое первых аргументов его элементов отображается в текстовом поле.
 
 <p>Для определения местоположения XML-файла создается объект <codeph>URLRequest</codeph> (например, он может находиться в том же каталоге, что и SWF-файл). Для того чтобы выявить возможные ошибки, файл загружается в блок <codeph>try...catch</codeph>. (Здесь выявляются ошибки <codeph>SecurityError</codeph>.) При возникновении события <codeph>IO_ERROR</codeph> вызывается метод <codeph>errorHandler()</codeph>, записывающий сообщение об ошибке в текстовом поле <codeph>xmlTextField</codeph>. После того как данные XML-файла получены и помещены в свойство данных URLLoader-объекта <codeph>loader</codeph>, отправляется событие <codeph>Event.COMPLETE</codeph> и вызывается метод <codeph>loaderCompleteHandler()</codeph>.</p>
 
 <p>В методе <codeph>loaderCompleteHandler()</codeph> блок <codeph>try...catch</codeph> используется для выявления любых ошибок анализа, которые могут возникнуть при преобразовании загруженных данных из файла в объект XML. Далее метод <codeph>readNodes()</codeph> рекурсивно обрабатывает все элементы в узлах XML-документа и добавляет текстовое поле <codeph>xmlTextField</codeph> со списком первых атрибутов всех элементов.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.xml.*;
    import flash.events.IOErrorEvent;
  
    public class URLLoader_loadExample extends Sprite {
        private var xmlTextField:TextField = new TextField();
        private var externalXML:XML;    
        private var loader:URLLoader;

        public function URLLoader_loadExample() {
            var request:URLRequest = new URLRequest("xmlFile.xml");

            loader = new URLLoader();
            
            try {
                loader.load(request);
            }
            catch (error:SecurityError)
            {
                trace("A SecurityError has occurred.");
            }

             loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);

            xmlTextField.x = 10;
            xmlTextField.y = 10;
            xmlTextField.background = true;
            xmlTextField.autoSize = TextFieldAutoSize.LEFT;

            addChild(xmlTextField);
        }

        private function loaderCompleteHandler(event:Event):void {

                try {
                    externalXML = new XML(loader.data);
                    readNodes(externalXML);    
                } catch (e:TypeError) {
                    trace("Could not parse the XML file.");
                }
        }

        private function readNodes(node:XML):void {

                for each (var element:XML in node.elements()) {
                    xmlTextField.appendText(element.attributes()[0] + "\n");

                    readNodes(element);
                }    
        }

        private function errorHandler(e:IOErrorEvent):void {
            xmlTextField.text = "Had problem loading the XML File.";
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequest/requestHeaders"><linktext>URLRequest.requestHeaders</linktext></link><link href="flash.net.xml#URLRequest/data"><linktext>URLRequest.data</linktext></link><link href="flash.net.xml#URLRequest/digest"><linktext>URLRequest.digest</linktext></link></related-links><adobeApiEvent id="flash.net:URLLoader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешной загрузки данных.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешной загрузки данных.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Если доступ осуществляется по протоколу HTTP и текущая среда Flash Player поддерживает получение кодов состояния, то можно получить эти события дополнительно к событию <codeph>complete</codeph> или <codeph>error</codeph>.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Если доступ осуществляется по протоколу HTTP и текущая среда Flash Player поддерживает получение кодов состояния, то в дополнении к любым событиям complete или error могут возникнуть следующие события.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Не удается завершить операцию загрузки.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Не удается завершить операцию загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется в случае получения данных в ходе операции загрузки.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется в случае получения данных в ходе операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>В рамках операции загрузки была произведена попытка извлечь данные с сервера, расположенного за пределами изолированной среды вызывающего объекта. Для решения этой проблемы можно использовать файл политики на сервере.
	 </apiDesc></adobeApiEventDetail><shortdesc>В рамках операции загрузки была произведена попытка извлечь данные с сервера, расположенного за пределами изолированной среды вызывающего объекта.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Операция загрузки предприняла попытку загрузить SWZ-файл (компонент платформы Adobe), но сертификат является недействительным или строка дайджеста не соответствует компоненту.
	 </apiDesc></adobeApiEventDetail><shortdesc>Операция загрузки предприняла попытку загрузить SWZ-файл (компонент платформы Adobe), но сертификат является недействительным или строка дайджеста не соответствует компоненту.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется в начале операции загрузки.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется в начале операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLLoader:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, если вызов метода <codeph>load()</codeph> пытается обратиться к данным через HTTP, и Adobe AIR может обнаружить и вернуть код состояния для запроса.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, если вызов метода load() пытается обратиться к данным через HTTP и Adobe AIR может обнаружить и вернуть код состояния для запроса.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:URLLoader:bytesLoaded"><apiName>bytesLoaded</apiName><shortdesc>
	 Определяет число байтов, загруженных до настоящего момента в ходе операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет число байтов, загруженных до настоящего момента в ходе операции загрузки.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:bytesTotal"><apiName>bytesTotal</apiName><shortdesc>
	 Определяет общее число байтов загруженных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет общее число байтов загруженных данных. Во время операции загрузки данное свойство имеет значение 0 и заполняется по завершении операции. Вдобавок, отсутствие заголовка Content-Length не позволит определить параметр bytesTotal.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoader:data"><apiName>data</apiName><shortdesc>
	 Данные, полученные при загрузке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
	 Данные, полученные при загрузке. Данное свойство заполняется только после завершения операции загрузки. Формат данных зависит от значения свойства <codeph>dataFormat</codeph>:
	 
	 <p>Если свойство <codeph>dataFormat</codeph> имеет значение <codeph>URLLoaderDataFormat.TEXT</codeph>, то в качестве данных будет получена строка, содержащая текст загруженного файла.</p>
	 
	 <p>Если свойство <codeph>dataFormat</codeph> имеет значение <codeph>URLLoaderDataFormat.BINARY</codeph>, то в качестве данных будет получен объект ByteArray, содержащий необработанные двоичные данные.</p>
	 
	 <p>Если свойство <codeph>dataFormat</codeph> имеет значение <codeph>URLLoaderDataFormat.VARIABLES</codeph>, то в качестве данных будет получен объект URLVariables, содержащий переменные в кодировке URL-адреса.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link><link href="flash.net.xml#URLLoader/dataFormat"><linktext>URLLoader.dataFormat</linktext></link></related-links></apiValue><apiValue id="flash.net:URLLoader:dataFormat"><apiName>dataFormat</apiName><shortdesc>
	 Определяет, в каком виде получаются загружаемые данные: в виде текста (URLLoaderDataFormat.TEXT), необработанных двоичных данных (URLLoaderDataFormat.BINARY) или переменных в кодировке URL (URLLoaderDataFormat.VARIABLES).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>URLLoaderDataFormat.TEXT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Определяет, в каком виде получаются загружаемые данные: в виде текста (<codeph>URLLoaderDataFormat.TEXT</codeph>), необработанных двоичных данных (<codeph>URLLoaderDataFormat.BINARY</codeph>) или переменных в кодировке URL (<codeph>URLLoaderDataFormat.VARIABLES</codeph>).
	 
	 <p>Если свойство <codeph>dataFormat</codeph> имеет значение <codeph>URLLoaderDataFormat.TEXT</codeph>, то в качестве данных будет получена строка, содержащая текст загруженного файла.</p>
	 
	 <p>Если свойство <codeph>dataFormat</codeph> имеет значение <codeph>URLLoaderDataFormat.BINARY</codeph>, то в качестве данных будет получен объект ByteArray, содержащий необработанные двоичные данные.</p>
	 
	 <p>Если свойство <codeph>dataFormat</codeph> имеет значение <codeph>URLLoaderDataFormat.VARIABLES</codeph>, то в качестве данных будет получен объект URLVariables, содержащий переменные в кодировке URL-адреса.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLLoaderDataFormat"><linktext>URLLoaderDataFormat</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
 
 Класс NetStreamPlayOptions определяет различные параметры, которые могут быть переданы методу NetStream.play2().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Класс NetStreamPlayOptions определяет различные параметры, которые могут быть переданы методу NetStream.play2(). 
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Класс NetStreamPlayOptions определяет различные параметры, которые могут быть переданы методу <codeph>NetStream.play2()</codeph>. Объект NetStreamPlayOptions передается методу <codeph>play2()</codeph>, а свойства класса задают разные варианты. Этот класс, в основном, используется для динамической реализации переходов между потоками для переключения между потоками с разными размерами и скоростями потока или для замены содержимого в списке воспроизведения.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamPlayOptions:NetStreamPlayOptions"><apiName>NetStreamPlayOptions</apiName><shortdesc>
     
     Создает объект NetStreamPlayOptions для определения вариантов, передаваемых методу NetStream.play2().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     
     Создает объект NetStreamPlayOptions для определения вариантов, передаваемых методу <codeph>NetStream.play2()</codeph>. 
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiConstructor><apiValue id="flash.net:NetStreamPlayOptions:len"><apiName>len</apiName><shortdesc>
    Продолжительность воспроизведения (в секундах) для потока, заданного в streamName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Продолжительность воспроизведения (в секундах) для потока, заданного в streamName.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Продолжительность воспроизведения (в секундах) для потока, заданного в <codeph>streamName</codeph>. Значение по умолчанию – -1, то есть Flash Player воспроизводит поток в реальном времени, пока он доступен, или записанный поток до его окончания. Если передать значение 0 для свойства <codeph>len</codeph>, Flash Player воспроизводит один кадр на секунде, заданной в <codeph>start</codeph>, от начала записанного потока, (при условии что значение <codeph>start</codeph> равно или больше 0).
    <p>Если передать положительное число для свойства <codeph>len</codeph>, Flash Player воспроизводит эфирный поток в течение заданного количества секунд <codeph>len</codeph> с того момента, как он станет доступным, или записанный поток в течение <codeph>len</codeph> секунд. (Если поток закончится раньше, чем задано в свойстве <codeph>len</codeph>, воспроизведение заканчивается вместе с потоком.)</p> 
    <p>Если передать в качестве значения для <codeph>len</codeph> отрицательное число, отличное от -1, Flash Player обрабатывает его как -1.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/start"><linktext>start</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:oldStreamName"><apiName>oldStreamName</apiName><shortdesc>
    Имя старого потока или потока, с которого нужно перейти на другой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Имя старого потока или потока, с которого нужно перейти на другой. Когда метод <codeph>NetStream.play2()</codeph> используется просто для воспроизведения потока (не для перехода), это свойство должно быть неопределенным или иметь значение null или undefined. В противном случае следует указать поток, с которого будет выполняться переход.   
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/streamName"><linktext>streamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:start"><apiName>start</apiName><shortdesc>
    Время начала для streamName (в секундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Время начала для streamName (в секундах).
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Время начала для <codeph>streamName</codeph> (в секундах). Допустимыми являются значения -2, -1 и 0.
    
    <p>По умолчанию <codeph>start</codeph> имеет значение -2, то есть, Flash Player сначала пытается в реальном времени воспроизвести поток, определенный свойством <codeph>streamName</codeph>. Если не удается найти поток в реальном времени с таким именем, Flash Player воспроизводит поток, заданный в <codeph>streamName</codeph>. Если поток в реальном времени или записанный потока не найдены, Flash Player открывает поток в реальном времени с именем <codeph>streamName</codeph>, даже если в нем не публикуется содержимое. Когда кто-то начинает публикацию в этом потоке, Flash Player начинает его воспроизводить.</p>
    
    <p>Если передать значение -1 для <codeph>start</codeph>, Flash Player воспроизводит только канал в реальном вреени, заданный в <codeph>streamName</codeph>. Если найти канал в реальном времени не удается, Flash Player ждет его бесконечно долго, если <codeph>len</codeph> имеет значение -1; если же <codeph>len</codeph> имеет другое значение, Flash Player ждет в течение указанного в <codeph>len</codeph> количества секунд, прежде чем начинать воспроизведение следующего элемента в списке.</p>
    
    <p> Если передать значение 0 или положительное число для свойства <codeph>start</codeph>, Flash Player воспроизводит только записанный поток с именем<codeph>streamName</codeph> с секунды, указанной в <codeph>start</codeph> от начала потока. Если не удается найти записанный поток, Flash Player немедленно начинает воспроизведение следующего элемента в списке.</p>
    
    <p>Если передать отрицательное число, не являющееся -1 или -2, в качестве значения для <codeph>start</codeph>, Flash Player обрабатывает его как -2.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions/len"><linktext>len</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:streamName"><apiName>streamName</apiName><shortdesc>
    Имя нового потока для перехода или воспроизведения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Имя нового потока для перехода или воспроизведения. Когда <codeph>oldStreamName</codeph> имеет значение 0 или не определено, вызов <codeph>NetStream.play2()</codeph> просто начинает воспроизведение <codeph>streamName</codeph>. Если задано свойство <codeph>oldStreamName</codeph>, при вызове <codeph>NetStream.play2()</codeph> выполняется переход с <codeph>oldStreamName</codeph> на <codeph>streamName</codeph> с использованием режима перехода, определенного свойством <codeph>transition</codeph>. 
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions/oldStreamName"><linktext>oldStreamName</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamPlayOptions:transition"><apiName>transition</apiName><shortdesc>
    Режим воспроизведения streamName или режим перехода к нему.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Режим воспроизведения streamName или режим перехода к нему.
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Режим воспроизведения <codeph>streamName</codeph> или режим перехода к нему. Возможными значениями являются константы класса NetStreamPlayTransitions. В зависимости от того, вызывается метод <codeph>Netstream.play2()</codeph> для воспроизведения потока или для перехода между потоками, режим перехода вызывает разное поведение. Более подробные сведения о режимах перехода см. в описании класса NetStreamPlayTransitions.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyOutput"><apiName>IDynamicPropertyOutput</apiName><shortdesc>
	 Этот интерфейс управляет сериализацией динамических свойств динамических объектов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Этот интерфейс управляет сериализацией динамических свойств динамических объектов. Данный интерфейс используется с интерфейсом IDynamicPropertyWriter и свойством <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>.
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyOutput:flash.net:IDynamicPropertyOutput:writeDynamicProperty"><apiName>writeDynamicProperty</apiName><shortdesc>
		 Добавляет динамическое свойство к двоичному выводу сериализованного объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя свойства. Этот параметр можно использовать для указания имени существующего свойства динамического объекта или для создания нового свойства.  
		 
		 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Значение, записываемое в указанное свойство.
		 
         </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Добавляет динамическое свойство к двоичному выводу сериализованного объекта. При последующем считывании (с помощью метода <codeph>readObject</codeph>) объект содержит новое свойство. Данный метод можно использовать для исключения сериализации свойств динамических объектов, а также для записи значения в свойства динамических объектов или создания новых свойств для этих объектов.
		 
         </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyWriter"><linktext>IDynamicPropertyWriter</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLVariables"><apiName>URLVariables</apiName><shortdesc>
 
 Класс URLVariables позволяет передавать переменные между приложением и сервером.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, constructor
</keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Класс URLVariables позволяет передавать переменные между приложением и сервером. Объекты URLVariables можно использовать с методами класса URLLoader, со свойством <codeph>data</codeph> класса URLRequest, а также с функциями пакета flash.net.
 
 </apiDesc><example conref="examples\URLVariablesExample.as"> В следующем примере удаленное приложение, размещенное по адресу http://www. [yourDomain].com/application.jsp, открывается в новом окне обозревателя и передает приложению данные о сеансе пользователя, извлеченные из объекта URLVariables. 
  
 <p>Основные моменты данного примера представлены ниже:</p>
 <ol>
    <li>Функция конструктора создает экземпляр URLRequest под именем <codeph>request</codeph>, принимая в качестве параметра URL-адрес удаленного приложения.</li>
    <li>Создается объект URLVariables, двум свойствам которого присваиваются значения.</li>
    <li>Объект URLVariables присваивается свойству <codeph>data</codeph> объекта URLRequest.</li>
    <li>В примере вызывается <codeph>navigateToURL</codeph>, открывающий новое окно обозревателя с URL-адресом удаленного приложения.</li>
 </ol>
 <p> <b>Примечание.</b> Чтобы запустить данный пример, необходимо заменить в примере URL-адрес удаленного приложения на любой действующий URL-адрес. Вдобавок, необходимо, чтобы код сервера обработал информацию, захваченную проигрывателем Flash Player в объекте URLVariables.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLVariables:URLVariables"><apiName>URLVariables</apiName><shortdesc>
	 Создает новый объект URLVariables.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Строка в кодировке URL-адреса, содержащая пары «имя/значение».
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект URLVariables. Объекты URLVariables следует передать свойству <codeph>data</codeph> объектов URLRequest.
	 
	 <p>Если вызвать конструктор URLVariables с определенной строкой, то при этом будет автоматически вызван метод <codeph>decode()</codeph>, преобразующий строку в свойства объекта URLVariables.</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:URLVariables:decode"><apiName>decode</apiName><shortdesc>
	 Преобразует переменную строку в свойства заданного объекта URLVariables.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.decode, decode
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Исходным параметром должна быть строка запроса в кодировке URL-адреса, содержащая пары «имя-значение».
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка запроса в кодировке URL-адреса, содержащая пары «имя-значение».	 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Преобразует переменную строку в свойства заданного объекта URLVariables.
	 <p>Этот метод используется событиями URLVariables в скрытой форме. Большинству пользователей не требуется вызывать этот метод напрямую.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLVariables:toString"><apiName>toString</apiName><shortdesc>
	 Возвращает строку, содержащую все перечисляемые переменные в кодировке содержимого MIME application/x-www-form-urlencoded.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLVariables, URLVariables.toString, toString
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка в кодировке URL-адреса, содержащая пары «имя-значение».
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Возвращает строку, содержащую все перечисляемые переменные в кодировке содержимого MIME <i>application/x-www-form-urlencoded</i>.
	 
	 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.net:IDynamicPropertyWriter"><apiName>IDynamicPropertyWriter</apiName><shortdesc>
     Этот интерфейс используется с интерфейсом IDynamicPropertyOutput для управления сериализацией динамических свойств динамических объектов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
     Этот интерфейс используется с интерфейсом IDynamicPropertyOutput для управления сериализацией динамических свойств динамических объектов. Чтобы использовать этот интерфейс, присвойте объект, реализующий интерфейс IDynamicPropertyWriter, свойству <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>.
      
     </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links><apiOperation id="flash.net:IDynamicPropertyWriter:flash.net:IDynamicPropertyWriter:writeDynamicProperties"><apiName>writeDynamicProperties</apiName><shortdesc>
         Записывает имя и значение объекта IDynamicPropertyOutput в объект с динамическими свойствами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект, в который будет произведена запись данных.
		 </apiDesc></apiParam><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.net:IDynamicPropertyOutput</apiOperationClassifier><apiDesc>Объект IDynamicPropertyOutput, который содержит имя и значение, динамически записываемые в объект.
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
         Записывает имя и значение объекта IDynamicPropertyOutput в объект с динамическими свойствами. Если установлено значение <codeph>ObjectEncoding.dynamicPropertyWriter</codeph>, данный метод вызывается для каждого объекта с динамическими свойствами. 
		 
		 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#IDynamicPropertyOutput"><linktext>IDynamicPropertyOutput</linktext></link><link href="flash.net.xml#ObjectEncoding/dynamicPropertyWriter"><linktext>ObjectEncoding.dynamicPropertyWriter</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.net:URLRequestDefaults"><apiName>URLRequestDefaults</apiName><shortdesc>
 Класс URLRequestDefaults включает в себя статические свойства, настройка которых позволяет определить значения по умолчанию для свойств класса URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс URLRequestDefaults включает в себя статические свойства, настройка которых позволяет определить значения по умолчанию для свойств класса URLRequest. Оно также включает в себя статический метод <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>, позволяющий определить используемые по умолчанию учетные данные для аутентификации запросов. Класс URLRequest определяет информацию, используемую в запросе HTTP. 
 
 <p>Любые свойства, установленные в объекте URLRequest, заменяют упомянутые статические свойства для класса URLRequestDefaults.</p>
 
 <p>Параметры URLRequestDefault применяются только к содержимому в домене приложения вызывающего абонента за одним исключением: параметры, установленные путем вызова <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>, применяются в отношении всех доменов приложений в рамках запущенного в данный момент приложения.</p>
 
 <p>Класс URLRequestDefaults может быть использован только содержимым Adobe<sup>®</sup> AIR<sup>®</sup>, выполняемым в изолированной программной среде приложения. Другое содержимое приведет к ошибке SecurityError, появляющейся при обращении к членам или свойствам данного класса.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><apiOperation id="flash.net:URLRequestDefaults:setLoginCredentialsForHost"><apiName>setLoginCredentialsForHost</apiName><shortdesc>
	Задает используемые по умолчанию имя пользователя и пароль для указанного узла.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>hostname</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя узла, к которому применяется имя пользователя и пароль. Это может быть просто домен, например <codeph>www.example.com</codeph>, или домен и номер порта, например <codeph>www.example.com:80</codeph>. Обратите внимание на то, что <codeph>example.com</codeph>, <codeph>www.example.com</codeph> и <codeph>sales.example.com</codeph> рассматриваются как уникальные узлы. 
	
	</apiDesc></apiParam><apiParam><apiItemName>user</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя пользователя по умолчанию, используемое при аутентификации запроса для указанного узла.
	
	</apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Пароль по умолчанию, используемый при аутентификации запроса для указанного узла.
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Задает используемые по умолчанию имя пользователя и пароль для указанного узла. Эти параметры применяются ко всем объектам URLRequest не только в домене приложения того объекта, который вызывает этот метод, но и во всех доменах приложения, в то время как статические свойства класса URLRequest применяются только к домену приложения вызывающего объекта). Это позволяет содержимому во всем приложении (независимо от домена приложения данного содержимого) быть уже загруженным в тот момент, когда будет регистрироваться/загружаться другая часть приложения.
	
	<p><i>Примечание для приложений, запущенных в операционной системе Mac OS.</i> При вызове этого метода в системе Mac OS приложение применяет рассматриваемые учетные данные для указанного узла до тех пор, пока приложение не будет закрыто, даже если позднее для этого же узла будет вызван метод <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph>. Тем не менее, если сервер отклонит учетную запись, указанную данным методом, то последующий вызов метода <codeph>URLRequestDefaults.setLoginCredentialsForHost()</codeph> (для того же самого узла) будет распознан.</p>
	
	<p><i>Примечание.</i> Данный метод не применяется в отношении объектов URLRequest, используемых при отправке файлов или в RTMP-запросах.</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLRequestDefaults:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	Параметр по умолчанию для свойства authenticate объектов URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Параметр по умолчанию для свойства <codeph>authenticate</codeph> объектов URLRequest. Установка свойства <codeph>authenticate</codeph> в объекте URLRequest заменяет указанный параметр по умолчанию.
	
	<p><i>Примечание.</i> Данный параметр не применяется в отношении объектов URLRequest, используемых при отправке файлов или в RTMP-запросах.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/authenticate"><linktext>URLRequest.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	Параметр по умолчанию для свойства cacheResponse объектов URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Параметр по умолчанию для свойства <codeph>cacheResponse</codeph> объектов URLRequest. Установка свойства <codeph>cacheResponse</codeph> в объекте URLRequest заменяет указанный параметр по умолчанию. Если установлено значение <codeph>true</codeph>, по умолчанию приложение AIR использует кэш-память HTTP операционной системы. Данный параметр не применяется в отношении объектов URLRequest, используемых при отправке файлов или в RTMP-запросах.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/cacheResponse"><linktext>URLRequest.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	Параметр по умолчанию для свойства followRedirects объектов URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Параметр по умолчанию для свойства <codeph>followRedirects</codeph> объектов URLRequest. Установка свойства <codeph>followRedirects</codeph> в объекте URLRequest заменяет указанный параметр по умолчанию. Данный параметр не применяется в отношении объектов URLRequest, используемых при отправке файлов или в RTMP-запросах.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/followRedirects"><linktext>URLRequest.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	Параметр по умолчанию для свойства manageCookies объектов URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Параметр по умолчанию для свойства <codeph>manageCookies</codeph> объектов URLRequest. Установка свойства <codeph>manageCookies</codeph> в объекте URLRequest заменяет указанный параметр по умолчанию.
	
	<p><i>Примечание.</i> Данный параметр не применяется в отношении объектов URLRequest, используемых при отправке файлов или в RTMP-запросах.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/manageCookies"><linktext>URLRequest.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:useCache:get"><apiName>useCache</apiName><shortdesc>
	Параметр по умолчанию для свойства useCache объектов URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Параметр по умолчанию для свойства <codeph>useCache</codeph> объектов URLRequest. Установка свойства <codeph>useCache</codeph> в объекте URLRequest заменяет указанный параметр по умолчанию. Данный параметр не применяется в отношении объектов URLRequest, используемых при отправке файлов или в RTMP-запросах.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/useCache"><linktext>URLRequest.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequestDefaults:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	Параметр по умолчанию для свойства userAgent объектов URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Параметр по умолчанию для свойства <codeph>userAgent</codeph> объектов URLRequest. Установка свойства <codeph>userAgent</codeph> в объекте URLRequest заменяет указанный параметр по умолчанию.
	
	<p>Это также является используемой по умолчанию строкой агента пользователя для всех объектов HTMLLoader (применяется при вызове метода <codeph>load()</codeph> объекта HTMLLoader). Установка свойства <codeph>userAgent</codeph> объекта HTMLLoader перезаписывает параметр <codeph>URLRequestDefaults.userAgent</codeph>.</p>
	
	<p>Это значение по умолчанию зависит от конечной операционной системы (Mac OS, Linux или Windows), языка и версии, как указано в следующих примерах:</p>
	
	<ul>
	
		<li><codeph>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5</codeph></li>
		<li><codeph>Mozilla/5.0 (Windows; U; en) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5</codeph></li>
     <li><codeph>"Mozilla/5.0 (X11; U; Linux i686; en-US) AppleWebKit/526.9+ (KHTML, like Gecko) AdobeAIR/1.5</codeph></li>
	
	</ul>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/userAgent"><linktext>flash.net.URLRequest.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:flash.net:getClassByAlias"><apiName>getClassByAlias</apiName><shortdesc>
     Выполняет поиск класса, у которого ранее был псевдоним, зарегистрированный через вызов метода registerClassAlias().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>includeExample examples\GetClassByAliasExample.as -noswf
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Псевдоним не был зарегистрирован.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Класс, связанный с данным псевдонимом. Если не будет найдено, будет создано исключение.
     
     </apiDesc><apiOperationClassifier>Class</apiOperationClassifier></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Искомый псевдоним.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Выполняет поиск класса, у которого ранее был псевдоним, зарегистрированный через вызов метода <codeph>registerClassAlias()</codeph>.
     <p>Данный метод не взаимодействует с методом <codeph>flash.utils.getDefinitionByName()</codeph>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#/registerClassAlias()"><linktext>registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:navigateToURL"><apiName>navigateToURL</apiName><shortdesc>
     Открывает или заменяет окно в приложении, которое содержит контейнер Flash Player (обычно браузер).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
     are not supported by URLLoader.navigate.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Значением свойства <codeph>digest</codeph> объекта <codeph>request</codeph> не является <codeph>null</codeph>. Свойство <codeph>digest</codeph> объекта URLRequest следует задавать только при вызове метода <codeph>URLLoader.load()</codeph> во время загрузки SWZ-файла (компонент платформы Adobe).
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>В приложении Flash Player (и в содержимом Adobe AIR, находящемся не в изолированной программной среде приложения) эта ошибка возникает в следующих ситуациях.
     <ul>
       <li>Локальные ненадежные SWF-файлы могут быть изолированы от Интернета. Этой ситуации можно избежать, если повторно классифицировать данный SWF-файл как локальный с сетевым подключением или доверенный.</li>
     
       <li>Операция навигации произвела попытку оценить псевдо адрес URL создания сценариев, но затронутый документ (HTML-документ в обозревателе) находится в изолированной программной среде, доступ к которой закрыт. Чтобы избежать этой ситуации, укажите <codeph>allowScriptAccess="always"</codeph> в соответствующем документе.</li>
     
       <li>Навигация по специальным окнам <codeph>_self</codeph>, <codeph>_top</codeph> или <codeph>_parent</codeph> невозможна, если ваш SWF-файл содержится на HTML-странице, у которой свойство <codeph>allowScriptAccess</codeph> имеет значение <codeph>none</codeph> или <codeph>sameDomain</codeph>, в то время как домены HTML-файла и SWF-файла не совпадают.</li>
     
       <li>Навигация окна с нестандартным именем из SWF-файла, размещенного в локальной изолированной программной среде для файловой системы, запрещена.</li>
     
      <li>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>. </li>
     
     </ul>
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вызов метода не выполняется в ответ на действие пользователя, такое как событие мыши или нажатие клавиши. Это требование применимо только к содержимому в Flash Player и к содержимому Adobe AIR, находящемуся не в изолированной программной среде приложения.
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest, указывающий URL-адрес, на который необходимо перейти.
     
     <p><ph platform="actionscript">В случае с содержимым, выполняемым в Adobe AIR при </ph><ph platform="javascript">. При </ph> использовании функции <codeph>navigateToURL()</codeph> средой выполнения обрабатывается URLRequest, использующий метод POST (свойство <codeph>method</codeph> которого имеет значение <codeph>URLRequestMethod.POST</codeph>), как при использовании метода GET.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Окно обозревателя или HTML-фрейм, в котором будет отображаться документ, указанный в параметре <codeph>request</codeph>. Вы можете ввести имя определенного окна или использовать одно из следующих значений:
     <ul>
     <li><codeph>"_self"</codeph> указывает текущий фрейм в текущем окне.</li>
     <li><codeph>"_blank"</codeph> определяет новое окно.</li>
     <li><codeph>"_parent"</codeph> указывает вышестоящий объект текущего фрейма.</li>
     <li><codeph>"_top"</codeph> указывает фрейм самого верхнего уровня в текущем окне.</li>
     </ul>
     <p>Если не будет указано значение для данного параметра, то будет создано новое пустое окно. В автономном проигрывателе можно указать новое окно (<codeph>_blank</codeph>) или определенное окно с именем. Другие значения не применяются.</p>
     
     <p platform="actionscript"><b>Примечание.</b> Когда код в SWF-файле, запущенном в локальной изолированной программной среде для файловой системы, вызывает функцию <codeph>navigateToURL()</codeph> и указывает специальное имя окна для параметра <codeph>window</codeph>, имя окна преобразуется в случайное имя. Имя представлено в формате <codeph>_flashXXXXXXXX</codeph>, где каждый X представляет случайную шестнадцатеричную цифру. Если в рамках одного сеанса (до закрытия используемого окна браузера) вы снова вызовете эту функцию и определите то же самое имя для параметра <codeph>window</codeph>, будет использована та же случайно выбранная строка.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     <ph platform="actionscript">Открывает или заменяет окно в приложении, которое содержит контейнер Flash Player (обычно браузер). В AIR функция открывает URL-ссылку в системном web-браузере по умолчанию</ph> <ph platform="javascript">Открывает URL-ссылку в системном web-браузере по умолчанию.</ph>
     
	 	<p>  <b><i>Важное примечание о безопасности </i></b> </p>
     	<p>Разработчики часто передают функции <codeph>navigateToURL()</codeph> значения URL-адресов, полученные из внешних источников, таких как FlashVars. Злоумышленники могут использовать эти внешние источники для таких атак, как выполнение межузловых сценариев. В связи с этим разработчикам следует проверять все URL-адреса перед тем, как передать их этой функции. </p>
     	
     <p>Надлежащая проверка данных в отношении URL-адресов может иметь разное значение в зависимости от использования URL-адреса в приложении. К типичным методам проверки данных относится проверка правильности схемы URL-адреса. Например, непреднамеренное разрешение URL-адресов javascript: может привести к выполнению межузловых сценариев. Проверка принадлежности URL-адреса вашему домену позволит избежать использования SWF-файла в качестве перенаправителя людьми, совершающими фишинг-атаки. Для лучшей защиты можно также проверить путь URL-адреса и то, что URL-адрес соответствует рекомендациям RFC</p>
     
     <p platform="actionscript">Следующий код является простым примером выполнения проверки данных, которая предусматривает отклонение всех URL-адресов, которые не начинаются с http:// или https:// и проверку принадлежности URL-адреса вашему доменному имени. Этот пример может не подходить для всех web-приложений, поэтому при необходимости следует предусмотреть дополнительную проверку URL-адресов. </p>
	 
     	<codeblock platform="actionscript">
     // AS3 Regular expression pattern match for URLs that start with http:// and https:// plus your domain name.
     function checkProtocol (flashVarURL:String):Boolean {
        // Get the domain name for the SWF if it is not known at compile time.
        // If the domain is known at compile time, then the following two lines can be replaced with a hard coded string.
        var my_lc:LocalConnection = new LocalConnection();
        var domainName:String = my_lc.domain;
        // Build the RegEx to test the URL.
        // This RegEx assumes that there is at least one "/" after the
        // domain. http://www.mysite.com will not match.
        var pattern:RegExp = new RegExp("^http[s]?\:\\/\\/([^\\/]+)\\/");
        var result:Object = pattern.exec(flashVarURL);
        if (result == null || result[1] != domainName || flashVarURL.length >= 4096) {
          return (false);
        }
        return (true);
     }  
     
     	</codeblock>
	 <p platform="actionscript">Для <i>локального</i> содержимого, выполняющегося в браузере, вызовы метода <codeph>navigateToURL()</codeph>, указывающие псевдо-протокол <codeph>javascript:</codeph> (с помощью объекта <codeph>URLRequest</codeph>, переданного в качестве первого параметра), допустимы только в том случае, если SWF-файл и рассматриваемая web-страница (если существует) находятся в локальной доверенной изолированной программной среде. В некоторых обозревателях не поддерживается применение протокола javascript с методом <codeph>navigateToURL()</codeph>. Вместо этого следует использовать метод <codeph>call()</codeph> API-интерфейса <codeph>ExternalInterface</codeph>, чтобы вызвать методы JavaScript в рамках закрытой HTML-страницы.</p>
     
      <p platform="actionscript">В проигрывателе Flash Player, а также в изолированных программных средах Adobe AIR, отличных от среды приложения, нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.</p>
     
     <p platform="actionscript">В приложении Flash Player версии 10 и старше, запущенном в браузере, при использовании этого метода в программных средствах открытие всплывающего окна может не выполняться. Различные браузеры (и конфигурации браузеров) могут блокировать всплывающие окна в любое время; невозможно гарантировать, что какое-либо всплывающее окно будет отображаться. Однако для повышения вероятности открытия всплывающего окна используйте этот метод только в коде, который выполняется в качестве непосредственного результата действия пользователя (например, в обработчике событий для события щелчка мышью или нажатия клавиши).</p>
     
     <p platform="actionscript"> В приложении Flash Player версии 10 и старше при использовании типа содержимого multipart (например, multipart/form-data), в котором содержится загрузка (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для загрузок:</p>
	 <ul platform="actionscript">
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p platform="actionscript">Кроме того, все объекты multipart Content-Type должны иметь допустимый синтаксис (в соответствии со стандартами RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для загрузок.</p>
     
     <p platform="actionscript">Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul platform="actionscript">
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
     
     </apiDesc><example conref="examples\NavigateToURLExample.as"> В следующем примере URL-адрес http://www.adobe.com открывается в новом окне браузера, при этом web-серверу передаются данные о сеансе пользователя, извлеченные из объекта URLVariables.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class NavigateToURLExample extends Sprite {

        public function NavigateToURLExample() {
            var url:String = "http://www.adobe.com";
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "Your Name";
            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            try {            
                navigateToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.external.xml#ExternalInterface/call()"><linktext>flash.external.ExternalInterface.call()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:registerClassAlias"><apiName>registerClassAlias</apiName><shortdesc>
     Сохраняет класс (тип) объекта при шифровании объекта в формат AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если один из параметров имеет значение <codeph>null</codeph>.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>aliasName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Используемый псевдоним.
     </apiDesc></apiParam><apiParam><apiItemName>classObject</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>Класс, связанный с данным псевдонимом.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Сохраняет класс (тип) объекта при шифровании объекта в формат AMF. Когда вы кодируете объект в формат AMF, данная функция сохраняет псевдоним для его класса, что позволит при декодировании объекта восстановить нужный класс. Если в контексте кодирования псевдоним для класса объекта не был зарегистрирован, то объект кодируется как анонимный. Аналогичным образом, если в контексте декодирования отсутствует зарегистрированный псевдоним, для декодированных данных создается анонимный объект.
     
     <p>Примерами классов, кодирующих объекты в формат AMF, могут служить LocalConnection, ByteArray, SharedObject, NetConnection и NetStream.</p>
     
     <p>Контекстам кодирования и декодирования не требуется использовать один и тот же класс для псевдонима. Они могут сменить классы при условии, что целевой класс содержит все члены, сериализуемые исходным классом.</p>
     
     </apiDesc><example conref="examples\RegisterClassAliasExample.as"> В данном примере с помощью функции <codeph>registerClassAlias()</codeph> регистрируется псевдоним (<codeph>com.example.eg</codeph>) для класса ExampleClass. Так как для класса регистрируется нужный псевдоним, объект может быть десериализован как экземпляр ExampleClass, при этом код выдаст значение <codeph>true</codeph>. Если бы вызов <codeph>registerClassAlias()</codeph> был удален, код бы выдал значение <codeph>false</codeph>. 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.registerClassAlias;
    import flash.utils.ByteArray;

    public class RegisterClassAliasExample extends Sprite {
        public function RegisterClassAliasExample() {
            registerClassAlias("com.example.eg", ExampleClass);
            var eg1:ExampleClass = new ExampleClass();
            var ba:ByteArray = new ByteArray();
            ba.writeObject(eg1);
            ba.position = 0;
            var eg2:* = ba.readObject();
            trace(eg2 is ExampleClass); // true
        }
    }
}

class ExampleClass {}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.net:sendToURL"><apiName>sendToURL</apiName><shortdesc>
     Отправляет на сервер запрос URL-адреса, но игнорирует ответ.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError The "digest" and "importToSandbox" properties of URLRequest
         are not supported by URLLoader.send.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Локальные ненадежные SWF-файлы изолированы от Интернета. Этой ситуации можно избежать, если переклассифицировать данный SWF-файл как локальный с сетевым подключением или доверенный.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest, определяющий URL-адрес отправки данных.
         </apiDesc></apiParam></apiOperationDef><apiDesc>
     Отправляет на сервер запрос URL-адреса, но игнорирует ответ.
     <p>Для изучения ответа сервера используйте метод <codeph>URLLoader.load()</codeph>.</p>
     
      <p>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.</p>
     
     <p>Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</p>
	 
     <p> В приложении Flash Player 10 и более поздней версии при использовании типа содержимого multipart (например, multipart/form-data), в котором содержится отправка (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для загрузок:</p>
	 <ul>
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p>Кроме того, все объекты multipart Content-Type должны иметь допустимый синтаксис (в соответствии со стандартами RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для загрузок.</p>
     
     <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul>
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
         
         </apiDesc><example conref="examples\SendToURLExample.as"> В следующем примере данные о сеансе пользователя, извлеченные из объекта URLVariables, передаются приложению по адресу http://www.yourDomain.com/application.jsp.
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.net.URLRequest;
    import flash.net.URLVariables;
    import flash.net.sendToURL;

    public class SendToURLExample extends Sprite {

        public function SendToURLExample() {
            var url:String = "http://www.yourDomain.com/application.jsp";
            var variables:URLVariables = new URLVariables();
            variables.sessionId = new Date().getTime();
            variables.userLabel = "Your Name";

            var request:URLRequest = new URLRequest(url);
            request.data = variables;
            trace("sendToURL: " + request.url + "?" + request.data);
            try {
                sendToURL(request);
            }
            catch (e:Error) {
                // handle error here
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiClassifier id="flash.net:Responder"><apiName>Responder</apiName><shortdesc>
 Класс Responder содержит объект, который применяется методом NetConnection.call() для обработки возвращаемых значений, получаемых с сервера и свидетельствующих об успешном или неуспешном завершении отдельных операций.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Responder содержит объект, который применяется методом <codeph>NetConnection.call()</codeph> для обработки возвращаемых значений, получаемых с сервера и свидетельствующих об успешном или неуспешном завершении отдельных операций. При работе с методом <codeph>NetConnection.call()</codeph> может возникнуть сбой в сетевой операции, относящийся только к текущей операции, или сбой, связанный с текущим состоянием подключения. В целях облегчения обработки ошибок, операционные ошибки направляются не на объект NetConnection, а на объект Responder.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links><apiConstructor id="flash.net:Responder:Responder"><apiName>Responder</apiName><shortdesc>
	 Создает новый объект Responder.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>result</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Эта функция вызывается, если вызов сервера выполняется успешно с возвратом результата.
	 </apiDesc></apiParam><apiParam><apiItemName>status</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiData>null</apiData><apiDesc>Функция, вызываемая в случае, если на сервере возникает ошибка.
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект Responder. Для обработки возвращенных от сервера значений необходимо передать объект Responder методу <codeph>NetConnection.call()</codeph>. Для одного или сразу двух параметров можно установить значение <codeph>null</codeph>.
	 
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="flash.net:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
 Объект URLRequestHeader инкапсулирует одиночный заголовок запроса HTTP и состоит из имени и значения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Объект URLRequestHeader инкапсулирует одиночный заголовок запроса HTTP и состоит из имени и значения. Объекты URLRequestHeader используются в свойстве <codeph>requestHeaders</codeph> класса URLRequest.
 
 <p>В Adobe<sup>®</sup> AIR содержимое в изолированной программной среде безопасности приложения (содержимое, установленное с приложением AIR) может использовать любые заголовки запросов, не вызывая ошибки. Однако в случае с содержимым, выполняющимся в Adobe AIR и находящимся в другой изолированной программной среде безопасности, <ph outputclass="actionscript"> или в случае с содержимым, выполняющимся в проигрывателе Flash<sup>®</sup> Player,</ph> использование следующих заголовков запросов приводит к ошибке времени выполнения, причем запрещенные термины не зависят от регистра (например, варианты <codeph>Get</codeph>, <codeph>get</codeph> и <codeph>GET</codeph> в равной степени недопустимы): </p>
 
 <p>В содержимом Flash Player и Adobe AIR за пределами изолированной программной среды безопасности приложения нельзя использовать следующие заголовки запросов, причем запрещенные термины не зависят от регистра (например, варианты <codeph>Get</codeph>, <codeph>get</codeph> и <codeph>GET</codeph> в равной степени недопустимы). Вдобавок, написанные через дефис термины применяются, если используется символ подчеркивания (например, <codeph>Content-Length</codeph> и <codeph>Content_Length</codeph> недопустимы): </p>
 
 <p><codeph>Accept-Charset</codeph>, <codeph>Accept-Encoding</codeph>, <codeph>Accept-Ranges</codeph>, <codeph>Age</codeph>, <codeph>Allow</codeph>, <codeph>Allowed</codeph>, <codeph>Authorization</codeph>, <codeph>Charge-To</codeph>, <codeph>Connect</codeph>, <codeph>Connection</codeph>, <codeph>Content-Length</codeph>, <codeph>Content-Location</codeph>, <codeph>Content-Range</codeph>, <codeph>Cookie</codeph>, <codeph>Date</codeph>, <codeph>Delete</codeph>, <codeph>ETag</codeph>, <codeph>Expect</codeph>, <codeph>Get</codeph>, <codeph>Head</codeph>, <codeph>Host</codeph>, <codeph>Keep-Alive</codeph>, <codeph>Last-Modified</codeph>, <codeph>Location</codeph>, <codeph>Max-Forwards</codeph>, <codeph>Options</codeph>, <codeph>Origin</codeph>, <codeph>Post</codeph>, <codeph>Proxy-Authenticate</codeph>, <codeph>Proxy-Authorization</codeph>, <codeph>Proxy-Connection</codeph>, <codeph>Public</codeph>, <codeph>Put</codeph>, <codeph>Range</codeph>, <codeph>Referer</codeph>, <codeph>Request-Range</codeph>, <codeph>Retry-After</codeph>, <codeph>Server</codeph>, <codeph>TE</codeph>, <codeph>Trace</codeph>, <codeph>Trailer</codeph>, <codeph>Transfer-Encoding</codeph>, <codeph>Upgrade</codeph>, <codeph>URI</codeph>, <codeph>User-Agent</codeph>, <codeph>Vary</codeph>, <codeph>Via</codeph>, <codeph>Warning</codeph>, <codeph>WWW-Authenticate</codeph>, <codeph>x-flash-version</codeph>.</p>
 
 <p>Объекты URLRequestHeader имеют ограниченную длину. Если суммарная длина объекта URLRequestHeader (длина свойства <codeph>name</codeph> плюс свойства <codeph>value</codeph>) или массива объектов URLRequestHeader, использованных в свойстве <codeph>URLRequest.requestHeaders</codeph>, превышает допустимую длину, выдается исключение.</p>
 
 <p>Содержимое, выполняющееся в Adobe AIR, задает для заголовка <codeph>ACCEPT</codeph> следующее значение, если для заголовка <codeph>ACCEPT</codeph> в свойстве <codeph>requestHeaders</codeph> класса URLRequest не задано значение:</p>
 
 <codeph>text/xml, application/xml, application/xhtml+xml, text/html;q=0.9, text/plain;q=0.8, image/png, application/x-shockwave-flash, video/mp4;q=0.9, flv-application/octet-stream;q=0.8, video/x-flv;q=0.7, audio/mp4, ~~/~~;q=0.5</codeph>
 <p>Не все методы, принимающие параметры URLRequest, поддерживают свойство <codeph>requestHeaders</codeph>. Дополнительные сведения см. в описании вызываемого метода. Например, методы <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph> не поддерживают свойство <codeph>URLRequest.requestHeaders</codeph>.</p>
 <p>Вследствие ограниченных возможностей обозревателей пользовательские заголовки запросов НТТР поддерживаются только для запросов <codeph>POST</codeph>, а для <codeph>GET</codeph> не поддерживаются.</p>  
 
 </apiDesc><example conref="examples\URLRequestHeaderExample.as"> В следующем примере отдельный заголовок HTTP-запроса <codeph>header</codeph> добавляется в массив для свойства <codeph>requestHeaders</codeph>. Заголовок указывает, что приложение должно переправить запрос на исходный сервер, даже если оно имеет кэшированную копию запрашиваемого объекта.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.net.URLRequestHeader;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequestHeaderExample extends Sprite {
        public function URLRequestHeaderExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var header:URLRequestHeader = new URLRequestHeader("pragma", "no-cache");
            var request:URLRequest = new URLRequest("http://www.[yourdomain].com/greeting.cfm");
            request.data = new URLVariables("name=John+Doe");
            request.method = URLRequestMethod.POST;
            request.requestHeaders.push(header);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLRequestHeader:URLRequestHeader"><apiName>URLRequestHeader</apiName><shortdesc>
	 Создает новый объект URLRequestHeader, инкапсулирующий одиночный заголовок запроса HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Имя заголовка HTTP-запроса (например, <codeph>Content-Type</codeph> или <codeph>SOAPAction</codeph>).
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Значение, связанное со свойством <codeph>name</codeph> (например, <codeph>text/plain</codeph>).
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект URLRequestHeader, инкапсулирующий одиночный заголовок запроса HTTP. Объекты URLRequestHeader используются в свойстве <codeph>requestHeaders</codeph> класса URLRequest.
     
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:URLRequestHeader:name"><apiName>name</apiName><shortdesc>
	 Имя заголовка HTTP-запроса (например, Content-Type или SOAPAction).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Имя заголовка HTTP-запроса (например, <codeph>Content-Type</codeph> или <codeph>SOAPAction</codeph>).
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestHeader:value"><apiName>value</apiName><shortdesc>
	 Значение, связанное со свойством name (например, text/plain).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Значение, связанное со свойством <codeph>name</codeph> (например, <codeph>text/plain</codeph>).
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequestMethod"><apiName>URLRequestMethod</apiName><shortdesc>
 Класс URLRequestMethod передает значения, указывающие метод, который объект URLRequest должен использовать при отправке данных на сервер: POST или GET.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс URLRequestMethod передает значения, указывающие метод, который объект URLRequest должен использовать при отправке данных на сервер: <codeph>POST</codeph> или <codeph>GET</codeph>.
 
 </apiDesc><example conref="examples\URLRequestMethodExample.as"> В следующем примере загружаются и отображаются данные, найденные в локальном текстовом файле. Здесь также отслеживается информация по обработке событий.
 
 <p><b>Примечание.</b> Чтобы запустить этот пример, поместите файл example.txt в тот же каталог, где находится ваш SWF-файл. Данный файл должен представлять собой простой текстовый файл, содержащий несколько слов или строк текста.
 </p>
 <p>Данный пример кода выполняет следующее:</p>
 <ol>
    <li>Функция конструктора создает экземпляр URLLoader под именем <codeph>loader</codeph>.</li>
    <li>Объект <codeph>loader</codeph> передается методу <codeph>configureListeners()</codeph>, который добавляет прослушиватели для каждого из поддерживаемых событий URLLoader.</li>
  <li>Под именем <codeph>request</codeph> создается экземпляр URLRequest, определяющий имя загружаемого файла.</li>
  <li>Свойство запроса <codeph>method</codeph> имеет значение <codeph>URLRequestMethod.POST</codeph>.</li>
    <li>Далее объект <codeph>request</codeph> передается методу <codeph>loader.load()</codeph>, который загружает текстовый файл.</li>
  <li>После того как URLLoader завершит загрузку текстового файла, отправляется событие <codeph>Event.COMPLETE</codeph>, которое запускает метод <codeph>completeHandler()</codeph>. Метод <codeph>completeHandler()</codeph> просто отслеживает свойство <codeph>data</codeph> (содержимое текстового файла).</li>
 </ol>
<codeblock>


package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestMethodExample extends Sprite {

        public function URLRequestMethodExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("example.txt");
            
            request.method = URLRequestMethod.POST;
            loader.load(request);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link></related-links><apiValue id="flash.net:URLRequestMethod:DELETE"><apiName>DELETE</apiName><shortdesc>
	 Указывает, что объект URLRequest использует метод DELETE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>DELETE</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объект URLRequest использует метод <codeph>DELETE</codeph>.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:GET"><apiName>GET</apiName><shortdesc>
	 Указывает, что объект URLRequest использует метод GET.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>GET</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объект URLRequest использует метод <codeph>GET</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:HEAD"><apiName>HEAD</apiName><shortdesc>
	 Указывает, что объект URLRequest использует метод HEAD.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>HEAD</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объект URLRequest использует метод <codeph>HEAD</codeph>.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:OPTIONS"><apiName>OPTIONS</apiName><shortdesc>
	 Указывает, что объект URLRequest использует метод OPTIONS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>OPTIONS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объект URLRequest использует метод <codeph>OPTIONS</codeph>.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:POST"><apiName>POST</apiName><shortdesc>
	 Указывает, что объект URLRequest использует метод POST.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>POST</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объект URLRequest использует метод <codeph>POST</codeph>.
	 
	 <p><i> Примечание..</i> <ph platform="actionscript">Для содержимого, выполняемого в Adobe AIR при</ph> <ph platform="javascript">При </ph>использовании функции <codeph>navigateToURL()</codeph> среда выполнения обрабатывает URLRequest, использующий метод POST (свойство <codeph>method</codeph> которого имеет значение <codeph>URLRequestMethod.POST</codeph>), как при использовании метода GET.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequestMethod:PUT"><apiName>PUT</apiName><shortdesc>
	 Указывает, что объект URLRequest использует метод PUT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>PUT</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что объект URLRequest использует метод <codeph>PUT</codeph>.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 Класс FileReferenceList обеспечивает работу средств, позволяющих пользователю выбрать один или несколько файлов для отправки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReferenceList
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Дает возможность отправить один или несколько файлов.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс FileReferenceList обеспечивает работу средств, позволяющих пользователю выбрать один или несколько файлов для отправки. Объект FileReferenceList представляет группу из одного или нескольких локальных файлов на диске пользователя в форме массива объектов FileReference. Подробную информацию и важные аспекты работы с объектами FileReference и классом FileReference см. в описании класса FileReference.
 
 <p>Для работы с классом FileReferenceList выполните следующее</p>
 <ul>
 <li>создайте экземпляры класса: <codeph>var myFileRef = new FileReferenceList();</codeph></li>
 <li>вызовите метод <codeph>FileReferenceList.browse()</codeph>, открывающий диалоговое окно, с помощью которого пользователь может выбрать один или несколько файлов для отправки: <codeph>myFileRef.browse();</codeph></li>
 <li>после успешного вызова метода <codeph>browse()</codeph> свойство <codeph>fileList</codeph> объекта FileReferenceList заполняется массивом объектов FileReference.</li>
 <li>Вызовите <codeph>FileReference.upload()</codeph> по каждому элементу в массиве <codeph>fileList</codeph>.</li>
 </ul>
 
 <p>Для работы с несколькими файлами класс FileReferenceList снабжен методом <codeph>browse()</codeph> и свойством <codeph>fileList</codeph>. Во время выполнения вызова <codeph>FileReferenceList.browse()</codeph> воспроизведение SWF-файла приостанавливается в автономных и внешних версиях Flash Player и в AIR для Linux и Mac OS X 10.1 и более ранних версий.</p>
 
 </apiDesc><example conref="examples\FileReferenceListExample.as"> В следующем примере показано, как можно использовать события для управления отправкой нескольких файлов. Класс CustomFileReferenceList расширяет FileReferenceList и включает в себя событие <codeph>complete</codeph>, которое отправляется при отправке каждого отдельного файла в объекте FileReferenceList. Событие <codeph>LIST_COMPLETE</codeph> в классе FileReferenceListExample отправляется, когда будут загружены все файлы в объекте FileReferenceList.
 
 <p>Чтобы запустить данный пример, разместите сценарий, предназначенный для принятия отправки файла, по адресу http://www. [yourDomain].com/yourUploadHandlerScript.cfm. Чтобы обеспечить сетевой доступ к указанному файлу, в зависимости от того, где расположен ваш SWF-файл и куда вы передаете файлы, может также потребоваться скомпилировать SWF-файл, определив для параметра «Безопасность локального воспроизведения» значение «Доступ только к сети», или обновить настройки безопасности проигрывателя Flash<sup>®</sup> Player. Если для отправки используется удаленный сервер и данный пример запускается с настольного компьютера, на вашем сервере должен присутствовать файл crossdomain.xml.</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.FileReferenceList;
 
    public class FileReferenceListExample extends Sprite {
        public static var LIST_COMPLETE:String = "listComplete";
        public function FileReferenceListExample() {
            initiateFileUpload();
        }

        private function initiateFileUpload():void {
            var fileRef:CustomFileReferenceList = new CustomFileReferenceList();
            fileRef.addEventListener(FileReferenceListExample.LIST_COMPLETE, listCompleteHandler);
            fileRef.browse(fileRef.getTypes());
        }

        private function listCompleteHandler(event:Event):void {
            trace("listCompleteHandler");
        }
    }
}
 
import flash.events.*;
import flash.net.FileReference;
import flash.net.FileReferenceList;
import flash.net.FileFilter;
import flash.net.URLRequest;
 
class CustomFileReferenceList extends FileReferenceList {
    private var uploadURL:URLRequest;
    private var pendingFiles:Array;

    public function CustomFileReferenceList() {
        uploadURL = new URLRequest();
        uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
        initializeListListeners();
    }

    private function initializeListListeners():void {
        addEventListener(Event.SELECT, selectHandler);
        addEventListener(Event.CANCEL, cancelHandler);
    }

    public function getTypes():Array {
        var allTypes:Array = new Array();
        allTypes.push(getImageTypeFilter());
        allTypes.push(getTextTypeFilter());
        return allTypes;
    }
 
    private function getImageTypeFilter():FileFilter {
        return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
    }
 
    private function getTextTypeFilter():FileFilter {
        return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
    }
 
    private function doOnComplete():void {
        var event:Event = new Event(FileReferenceListExample.LIST_COMPLETE);
        dispatchEvent(event);
    }
 
    private function addPendingFile(file:FileReference):void {
        trace("addPendingFile: name=" + file.name);
        pendingFiles.push(file);
        file.addEventListener(Event.OPEN, openHandler);
        file.addEventListener(Event.COMPLETE, completeHandler);
        file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
        file.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        file.upload(uploadURL);
    }
 
    private function removePendingFile(file:FileReference):void {
        for (var i:uint; i &lt; pendingFiles.length; i++) {
            if (pendingFiles[i].name == file.name) {
                pendingFiles.splice(i, 1);
                if (pendingFiles.length == 0) {
                    doOnComplete();
                }
                return;
            }
        }
    }
 
    private function selectHandler(event:Event):void {
        trace("selectHandler: " + fileList.length + " files");
        pendingFiles = new Array();
        var file:FileReference;
        for (var i:uint = 0; i &lt; fileList.length; i++) {
            file = FileReference(fileList[i]);
            addPendingFile(file);
        }
    }
 
    private function cancelHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("cancelHandler: name=" + file.name);
    }
 
    private function openHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("openHandler: name=" + file.name);
    }
 
    private function progressHandler(event:ProgressEvent):void {
        var file:FileReference = FileReference(event.target);
        trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
    }
 
    private function completeHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("completeHandler: name=" + file.name);
        removePendingFile(file);
    }
 
    private function httpErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("httpErrorHandler: name=" + file.name);
    }
 
    private function ioErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("ioErrorHandler: name=" + file.name);
    }
 
    private function securityErrorHandler(event:Event):void {
        var file:FileReference = FileReference(event.target);
        trace("securityErrorHandler: name=" + file.name + " event=" + event.toString());
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 Отправляется, когда пользователь выбирает один или несколько файлов для загрузки в диалоговом окне обзора файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example demonstrates the usage of the <code>select</code> event.
 <listing version="2.0">
 import flash.net.FileReferenceList;
 import flash.net.FileReference;
 
 var listener:Object = new Object();
 
 listener.onSelect = function(fileRefList:FileReferenceList) {
 	trace("onSelect");
 	var list:Array = fileRefList.fileList;
 	var item:FileReference;
 	for(var i:Number = 0; i &lt; list.length; i++) {
 		item = list[i];
 		trace("name: " + item.name);
 		trace(item.addListener(this));
 		item.upload("http://www.yourdomain.com/");
 	}
 }
 
 listener.onComplete = function(file:FileReference):void {
 	trace("onComplete: " + file.name);
 }
 
 var fileRef:FileReferenceList = new FileReferenceList();
 fileRef.addListener(listener);
 fileRef.browse();
 </listing>
 </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь выбирает один или несколько файлов для загрузки в диалоговом окне обзора файлов. (Это диалоговое окно открывается при вызове метода <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> или<codeph>FileReference.download()</codeph>.) Когда пользователь выбирает файл и подтверждает эту операцию (например, путем нажатия на кнопку «Сохранить»), объект <codeph>FileReferenceList</codeph> заполняется объектами FileReference, представляющими выбранные пользователем файлы.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 Отправляется, когда пользователь закрывает диалоговое окно обозревателя файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
 </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь закрывает диалоговое окно обозревателя файлов. (Это диалоговое окно открывается при вызове метода <codeph>FileReferenceList.browse()</codeph>, <codeph>FileReference.browse()</codeph> или<codeph>FileReference.download()</codeph>.)
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:FileReferenceList:FileReferenceList"><apiName>FileReferenceList</apiName><shortdesc>
 	 Создает новый объект FileReferenceList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReferenceList</code> object,
	 iterates over each selected file, and outputs their names.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var arr:Array = fileRefList.fileList;
	 	for(var i:Number = 0; i &lt; arr.length; i++) {
	 		trace("name: " + arr[i].name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
  	 
  	 </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 	 Создает новый объект FileReferenceList. До тех пор пока вы не вызовете в отношении объекта FileReferenceList метод <codeph>browse()</codeph> и пользователь не выберет один или несколько файлов, данный объект остается пустым. При вызове метода <codeph>browse()</codeph> в отношении объекта FileReference свойство <codeph>fileList</codeph> данного объекта заполняется массивом объектов <codeph>FileReference</codeph>.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReferenceList:browse"><apiName>browse</apiName><shortdesc>
	 Отображает диалоговое окно выбора файлов, позволяющее пользователю выбрать один или несколько локальных файлов для загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample><pre>
	 // ask the user to choose an image file for upload
	 var fileRef = new FileReference();
	 if (fileRef.browse(["Images", "jpg;gif;png", "Flash Movies", "swf"])) {
	   trace("Opened " + fileRef.name);
	 } else {
	   trace("User canceled");
	 }
	 </pre>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра FileReference или FileReferenceList (единовременно может быть запущен только один сеанс просмотра файлов). 2) Настройка в файле пользователя mms.cfg запрещает данную операцию. 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если массив <codeph>typeFilter</codeph> не содержит правильно сформатированные объекты FileFilter, создается исключение. Подробные сведения о правильном форматировании фильтров см. в документации по FileFilter.
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если вызов метода не выполняется в ответ на действие пользователя, такое как событие мыши или нажатие клавиши.
     
	  
	  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращает значение <codeph>true</codeph> при наличии допустимых параметров и открытии диалогового окна просмотра файлов.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив экземпляров FileFilter, который используется для фильтрации файлов, отображенных в диалоговом окне. Если данный параметр пропущен, то отображаются все файлы. Дополнительную информацию см. в описании класса <xref href="FileFilter.html">FileFilter</xref>. 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Отображает диалоговое окно выбора файлов, позволяющее пользователю выбрать локальные файлы для загрузки.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Отображает диалоговое окно выбора файлов, позволяющее пользователю выбрать один или несколько локальных файлов для загрузки. Это диалоговое окно принадлежит операционной системе пользователя.
	 
	 <p platform="actionscript">В приложении Flash Player версии 10 и старше этот метод можно вызывать только в ответ на пользовательское событие (например, в обработчике событий щелчка мыши или нажатия клавиши). В противном случае в результате вызова этого метода в приложении Flash Player возникает ошибка.</p>
	 
	 <p>Когда вы вызываете этот метод и пользователь успешно выбирает файлы, свойство <codeph>fileList</codeph> данного объекта FileReferenceList заполняется массивом объектов FileReference (по одному для каждого выбранного пользователем файла). При каждом последующем вызове метода FileReferenceList.browse() свойство <codeph>FileReferenceList.fileList</codeph> указывает файлы, которые пользователь выбрал в диалоговом окне.</p>
	 
	 <p>С помощью параметра <codeph>typeFilter</codeph>можно определить, какие файлы будут отображаться в диалоговом окне.</p>
	 
	 <p>Единовременно в отношении объекта FileReferenceList может быть запущен только один сеанс <codeph>FileReference.browse()</codeph>, <codeph>FileReference.download()</codeph> или <codeph>FileReferenceList.browse()</codeph> (за раз может быть открыто только одно диалоговое окно).</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference"><linktext>Класс FileReference</linktext></link><link href="flash.net.xml#FileFilter"><linktext>Класс FileFilter</linktext></link></related-links><adobeApiEvent id="flash.net:FileReferenceList:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается, когда пользователь успешно выбирает в диалоговом окне элемент для загрузки.
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается, когда пользователь успешно выбирает в диалоговом окне элемент для отправки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReferenceList:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается, когда пользователь прекращает работу с диалоговым окном путем его закрытия или нажатия на кнопку «Отмена».
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Вызывается, когда пользователь прекращает работу с диалоговым окном путем его закрытия или нажатия на кнопку «Отмена».</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReferenceList:fileList:get"><apiName>fileList</apiName><shortdesc>
	 Массив объектов FileReference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example demonstrates the <code>fileList</code> property.
	 <listing version="2.0">
	 import flash.net.FileReferenceList;
	 import flash.net.FileReference;
	 
	 var listener:Object = new Object();
	 listener.onSelect = function(fileRefList:FileReferenceList) {
	 	trace("onSelect");
	 	var list:Array = fileRefList.fileList;
	 	var item:FileReference;
	 	for(var i:Number = 0; i &lt; list.length; i++) {
	 		item = list[i];
	 		trace("name: " + item.name);
	 	}
	 }
	 
	 var fileRef:FileReferenceList = new FileReferenceList();
	 fileRef.addListener(listener);
	 fileRef.browse();
	 </listing>
	 
	  
	  </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>Массив объектов FileReference.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Массив объектов <codeph>FileReference</codeph>.
	 
	 <p>Когда вызывается метод <codeph>FileReferenceList.browse()</codeph> и пользователь выбирает один или несколько файлов в диалоговом окне, которое открывает метод <codeph>browse()</codeph>, данное свойство заполняется массивом объектов FileReference, каждый из которых представляет выбранный пользователем файл. В дальнейшем можно использовать данный массив для загрузки каждого файла с помощью метода <codeph>FileReference.upload()</codeph>. За один раз следует загружать по одному файлу.</p>
	 
	 <p>Свойство <codeph>fileList</codeph> заполняется заново при каждом вызове метода browse() в отношении данного объекта FileReferenceList.</p>
	 
	 <p>Свойства объектов <codeph>FileReference</codeph> описаны в документации по классу FileReference.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileReference"><apiName>FileReference</apiName><shortdesc>
  Класс FileReference обеспечивает работу средств загрузки файлов между компьютером пользователя и сервером.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>FileReference, FileReference.browse, FileReference.download, FileReference.create, browse, download, create
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  Класс FileReference обеспечивает работу средств загрузки файлов между компьютером пользователя и сервером. В диалоговом окне операционной системы пользователю предлагается выбрать файл для загрузки или адрес загрузки. Каждый объект FileReference ссылается на отдельный файл на диске пользователя и имеет свойства, в которых содержится различная информация о файле: размер, тип, имя, дата создания, дата модификации и тип создателя (только для Macintosh). 
  
  <p><b>Примечание.</b> В Adobe AIR класс File, расширяющий класс FileReference, предоставляет больше возможностей и имеет меньше ограничений по безопасности, чем сам класс FileReference.</p>
  
  <p>Существуют следующие способы создания экземпляров FileReference.</p>
  <ul>
  <li>При использовании оператора <codeph>new</codeph> с конструктором FileReference: <codeph>var myFileReference = new FileReference();</codeph></li>
  
  <li>Происходит при вызове метода <codeph>FileReferenceList.browse()</codeph>, который создает массив объектов FileReference.</li>
  </ul>
  
  <p>Во время операции загрузки все свойства объекта FileReference заполняются вызовами метода <codeph>FileReference.browse()</codeph> или <codeph>FileReferenceList.browse()</codeph>. Во время операции загрузки свойство <codeph>name</codeph> заполняется при отправке события <codeph>select</codeph>. Все остальные свойства заполняются при отправке события <codeph>complete</codeph>.</p>
  
  <p>Метод <codeph>browse()</codeph> открывает диалоговое окно операционной системы, предлагающее пользователю выбрать файл для загрузки. С помощью метода <codeph>FileReference.browse()</codeph> пользователь может выбрать один файл, метод <codeph>FileReferenceList.browse()</codeph> позволяет выбирать сразу несколько файлов. После успешного вызова метода <codeph>browse()</codeph> для последовательной загрузки файлов вызовите метод <codeph>FileReference.upload()</codeph>. Метод <codeph>FileReference.download()</codeph> запрашивает у пользователя адрес для сохранения файла и начинает загрузку с удаленного URL-адреса.</p>
  
  <p>Классы FileReference и FileReferenceList не позволяют определять место хранения файла по умолчанию для диалогового окна, которое создают методы <codeph>browse()</codeph> или <codeph>download()</codeph>. Адресом по умолчанию, отображаемым в диалоговом окне, служит папка, просмотренная в самый последний раз (если это место может быть определено), или рабочий стол. Эти классы не разрешают операции записи или чтения в отношении переданного файла. Они закрывают для SWF-файла, который инициировал загрузку, доступ к загруженному файлу или месту размещения файла на диске пользователя.</p>
  
  <p>Классы FileReference и FileReferenceList также не предоставляют методы аутентификации. При работе с серверами, требующими аутентификации, можно загружать файлы с помощью модуля обозревателя Flash<sup>®</sup> Player, но при этом озагрузка (во всех проигрывателях) и загрузка (в автономном или внешнем проигрывателе) закончатся сбоем. Следует прослушать события FileReference, чтобы определить, успешно ли завершились операции, а также обработать ошибки.</p>
  
  <p>Для <ph platform="actionscript">содержимого в Flash Player или</ph> в Adobe AIR, выполняемого за пределами изолированной программной среды безопасности для приложения, операции загрузки могут обращаться только к файлам, находящимся в его собственном домене и в доменах, перечисленных в файле политик для URL-адресов. Файл политик для следует разместить на файловом сервере, если содержимое, инициирующее отправку, не принадлежит тому домену, в котором размещается файловый сервер.</p>
  
  <p>Примите во внимание эти особенности, поскольку в приложение Flash Player добавлены новые функции. При публикации в приложении Flash Player 10 одновременно может быть активна только одна из следующих операций: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. В противном случае в приложении Flash Player возникает ошибка выполнения (код 2174). Используйте метод <codeph>FileReference.cancel()</codeph> для остановки выполняющейся операции. Это ограничение применяется только в приложении Flash Player 10. В предыдущих версиях Flash Player ограничение на одновременное выполнение нескольких операций не действует.</p>
  
  <p platform="actionscript">Во время выполнения вызова методов <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> воспроизведение SWF-файла приостанавливается в автономных и внешних версиях Flash Player и в AIR для Linux и Mac OS X 10.1 и более ранних версий.</p>
  
  <p platform="actionscript">Следующий пример запроса HTTP <codeph>POST</codeph> отправляется из Flash Player сценарию на сервере, если не заданы параметры:
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  
  <p platform="actionscript">Flash Player отправляет следующий запрос HTTP <codeph>POST</codeph>, если заданы параметры <codeph>"api_sig"</codeph>, <codeph>"api_key"</codeph> и <codeph>"auth_token"</codeph>:
  </p>
  
  <pre platform="actionscript">
  POST /handler.cfm HTTP/1.1 
  Accept: text/~~
  Content-Type: multipart/form-data; 
  boundary=----------Ij5ae0ae0KM7GI3KM7 
  User-Agent: Shockwave Flash 
  Host: www.example.com 
  Content-Length: 421 
  Connection: Keep-Alive 
  Cache-Control: no-cache
  
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filename"
  
  MyFile.jpg
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_sig"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="api_key"
  
  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="auth_token"
  
  XXXXXXXXXXXXXXXXXXXXXX
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Filedata"; filename="MyFile.jpg"
  Content-Type: application/octet-stream
  
  FileDataHere
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7
  Content-Disposition: form-data; name="Upload"
  
  Submit Query
  ------------Ij5GI3GI3ei4GI3ei4KM7GI3KM7KM7--
  </pre>
  </apiDesc><example conref="examples\FileReferenceExample.as"> В следующем примере отображается формат данных и информация о состоянии файла, загруженного при выполнении кода.  
 <p> <b>Примечание.</b> Чтобы запустить данный пример, следует изменить свойство uploadURL.url, чтобы вместо фиктивного адреса в этом примере оно указывало фактический (действующий) URL-адрес. URL-адрес должен указывать на файл <codeph>yourUploadHandlerScript.cfm</codeph> в корневом web-каталоге указанного URL-адреса. В зависимости от вашей конфигурации, чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player.
 </p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileFilter;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReferenceExample extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReferenceExample() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            configureListeners(file);
            file.browse(getTypes());
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
            dispatcher.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA,uploadCompleteDataHandler);
        }

        private function getTypes():Array {
            var allTypes:Array = new Array(getImageTypeFilter(), getTextTypeFilter());
            return allTypes;
        }

        private function getImageTypeFilter():FileFilter {
            return new FileFilter("Images (*.jpg, *.jpeg, *.gif, *.png)", "*.jpg;*.jpeg;*.gif;*.png");
        }

        private function getTextTypeFilter():FileFilter {
            return new FileFilter("Text Files (*.txt, *.rtf)", "*.txt;*.rtf");
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function uploadCompleteDataHandler(event:DataEvent):void {
            trace("uploadCompleteData: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReferenceList"><linktext>flash.net.FileReferenceList</linktext></link><link href="flash.filesystem.xml#File"><linktext>flash.filesystem.File</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference_flash.events.DataEvent.UPLOAD_COMPLETE_DATA_uploadCompleteData"><apiName>uploadCompleteData</apiName><shortdesc>
    Отправляется после получения с сервера данных о успешном завершении загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DataEvent.UPLOAD_COMPLETE_DATA</apiEventType><adobeApiEventClassifier>flash.events.DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
    Отправляется после получения с сервера данных об успешном завершении загрузки. Это событие не отправляется, если сервер не возвращает данные.
    </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
	 Отправляется, если вызов метода upload() или uploadUnencoded() пытается обратиться к данным через http, и Adobe AIR может обнаружить и вернуть код состояния для запроса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 Отправляется, если вызов метода <codeph>upload()</codeph> или <codeph>uploadUnencoded()</codeph> пытается обратиться к данным через HTTP, и Adobe AIR может обнаружить и вернуть код состояния для запроса. 
	 
	 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link><link href="flash.net.xml#FileReference/uploadUnencoded()"><linktext>uploadUnencoded()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
     Отправляется, когда при загрузке происходит ошибка и доступен код состояния HTTP, описывающий ошибку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Отправляется, когда при загрузке происходит ошибка и доступен код состояния HTTP, описывающий ошибку. Отправляется событие <codeph>httpStatus</codeph>, а после него сразу же отправляется событие <codeph>ioError</codeph>.
     
     <p>Событие <codeph>httpStatus</codeph> отправляется только в случае сбоя операции загрузки. Для содержимого, запущенного в проигрывателе Flash Player, это событие не применимо для сбоя загрузки. Если сбой загрузки происходит по причине ошибки HTTP, данная ошибка представляется как ошибка ввода-вывода.</p>
     
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
	Отправляется, когда пользователь выбирает файл для загрузки в диалоговом окне обзора файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Отправляется, когда пользователь выбирает файл для загрузки в диалоговом окне обзора файлов. (Это диалоговое окно открывается при вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph>.) Когда пользователь выбирает файл и подтверждает эту операцию (например, путем нажатия кнопки «ОК»), происходит заполнение свойств объекта FileReference.
    
    <p>Для содержимого, выполняемого <ph platform="actionscript">в Flash Player или</ph> за пределами изолированной программной среды приложения <ph platform="actionscript">в среде выполнения Adobe AIR</ph>, событие <codeph>select</codeph> ведет себя немного по-разному в зависимости от вызывающего его метода. Когда событие <codeph>select</codeph> отправляется после вызова метода <codeph>browse()</codeph>, <ph platform="actionscript">Flash Player или</ph> приложение AIR получает возможность считывания всех свойств объекта FileReference, так как выбранный пользователем файл находится в локальной файловой системе. Когда событие <codeph>select</codeph> возникает после вызова <codeph>download()</codeph>, <ph platform="actionscript">Flash Player или</ph>приложение AIR может считать только свойство <codeph>name</codeph>, так как на момент отправки события <codeph>select</codeph> файл еще не загружен в локальную файловую систему. После того как файл загружен и событие <codeph>complete</codeph> отправлено, <ph platform="actionscript">Flash Player или</ph>приложение AIR может считывать все остальные свойства объекта FileReference.</p>
    
    </apiDesc><example conref="examples\FileReference_event_select.as"> В следующем примере показано применение объекта события <codeph>select</codeph>. Чтобы запустить данный пример, измените свойство <codeph>uploadURL.url</codeph> так, чтобы оно указывало реальный домен и файл, а не выдуманный http://www. [yourDomain].com/SomeFile.pdf. Чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player. Для того чтобы этот пример можно было запустить с рабочего стола, необходимо, чтобы ваш сервер опубликовал файл crossdomain.xml. Запуск функции <codeph>ioErrorHandler()</codeph> свидетельствует о том, что, возможно, необходимо обновить предоставленный <codeph>uploadURL</codeph>, указав в нем действующий URL-адрес, настроенный на получение загружаемых данных.
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_select extends Sprite {
        private var uploadURL:URLRequest;
        private var file:FileReference;

        public function FileReference_event_select() {
            uploadURL = new URLRequest();
            uploadURL.url = "http://www.[yourDomain].com/yourUploadHandlerScript.cfm";
            file = new FileReference();
            file.addEventListener(Event.SELECT, selectHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.browse();
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + uploadURL.url);
            file.upload(uploadURL);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
     Отправляется, когда путем вызова метода FileReference.upload() или FileReference.download() предпринимается попытка передать файл на сервер или получить файл с сервера, находящегося за пределами изолированной среды вызывающего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
     
     </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     Отправляется, когда путем вызова метода <codeph>FileReference.upload()</codeph> или <codeph>FileReference.download()</codeph> предпринимается попытка передать файл на сервер или получить файл с сервера, находящегося за пределами изолированной среды вызывающего объекта. Значением текстового свойства, описывающего возникшую специфическую ошибку, обычно является <codeph>securitySandboxError</codeph>. Возможно, вызывающий SWF-файл произвел попытку обращения к SWF-файлу за пределами своего домена, на что у него нет соответствующего разрешения. Для исправления данной ошибки можно использовать файл политики для URL.
     
     <p>В Adobe AIR эти ограничения по безопасности не применяются к содержимому в изолированной программной среде безопасности приложения.</p>
     
	 <p>В Adobe AIR эти ограничения по безопасности не применяются к содержимому в изолированной программной среде безопасности приложения.</p>
	 
     </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
	Отправляется периодически в ходе операции загрузки или передачи файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
    </helpid></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Отправляется периодически в ходе операции загрузки или передачи файла. Событие <codeph>progress</codeph> отправляется в процессе передачи проигрывателем Flash Player байтов на сервер. Оно периодически отправляется в течение всей операции передачи, даже если эта операция в конечном итоге не становится успешной. Чтобы определить, когда произойдет фактическое успешное завершение передачи файла, следует ожидать появления события <codeph>complete</codeph>.
    
    <p>В некоторых случаях события <codeph>progress</codeph> не могут быть получены. Например, при отправке файла очень небольшого размера или при очень быстрой отправке или загрузке событие <codeph>progress</codeph> может быть не передано.</p>
    
    <p>Невозможно определить состояние процесса загрузки файла на платформах Macintosh более ранней версии, чем OS X 10.3. Событие <codeph>progress</codeph> вызывается в течение операции загрузки, однако значением свойства <codeph>bytesLoaded</codeph> события progress является -1, что указывает на невозможность определения состояния.</p>
    
    </apiDesc><example conref="examples\FileReference_event_progress.as"> В следующем примере показано применение объекта <codeph>progress</codeph>. Чтобы запустить данный пример, измените свойство <codeph>downloadURL.url</codeph> так, чтобы оно указывало реальный домен и файл, а не выдуманный http://www. [yourDomain].com/SomeFile.pdf. Чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_progress extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_progress() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            file.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            file.addEventListener(Event.COMPLETE, completeHandler);
            file.download(downloadURL, fileName);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler: name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
        
        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/event:complete"><linktext>FileReference.complete</linktext></link><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
	Отправляется в начале операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>open</code> event.
    It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onOpen = function(file:FileReference):void {
      trace("onOpen: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Отправляется в начале операции загрузки.
    
    
    </apiDesc><example conref="examples\FileReference_download.as"> В следующем примере показано применение объекта события <codeph>download</codeph>. Чтобы запустить данный пример, измените свойство <codeph>downloadURL.url</codeph> так, чтобы оно указывало реальный домен и файл, а не выдуманный http://www. [yourDomain].com/SomeFile.pdf. Чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
	Отправляется в случае ошибки при загрузке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows the usage of the <code>ioError</code> event. 
    Note that for simplicity, none of the other event types are used in this
    example.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onIOError = function(file:FileReference):void {
      trace("onIOError");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download("http://www.adobe.com/NonExistentFile.pdf", "NonExistentFile.pdf");
    
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Отправляется в случае ошибки при загрузке. Сбой при передачи файла может возникнуть по одной из следующих причин:
    
    <ul>
    <li>Ошибка ввода-вывода возникает в тот момент, когда проигрыватель считывает, записывает или передает файл.</li>
    <li><ph platform="actionscript">В SWF-файле </ph><ph platform="javascript"> в приложении AIR</ph> предпринимается попытка загрузить файл на сервер, на котором требуется аутентификация (например, имя пользователя и пароль). В процессе отправки <ph platform="actionscript">Flash Player или</ph> Adobe AIR не дает пользователям возможности ввести пароли. Если <ph platform="actionscript">SWF-файл </ph> <ph platform="javascript">в приложении AIR</ph> попытается загрузить файл на сервер, на котором требуется аутентификация, произойдет сбой отправки.</li>
    <li><ph platform="actionscript">SWF-файл </ph><ph platform="javascript">в приложении AIR</ph> пытается загрузить файл с сервера, на котором требуется аутентификация, в автономный или внешний проигрыватель. Во время загрузки автономные и внешние проигрыватели не обеспечивают пользователей возможностью ввода паролей. Если <ph platform="actionscript">SWF-файл </ph> <ph platform="javascript">в приложении AIR</ph> в этих проигрывателях предпринимает попытку загрузки файла с сервера, на котором требуется аутентификация, происходит сбой загрузки. <ph platform="actionscript">Загрузка файла может быть успешно выполнена только в элементе управления ActiveX, дополнительных модулях обозревателей и в среде выполнения Adobe AIR.</ph></li>
    <li>Значение, переданное параметру <codeph>url</codeph> в методе <codeph>upload()</codeph>, содержит недопустимый протокол. Допустимые протоколы: HTTP и HTTPS.</li>
    </ul>
    
    <p platform="actionscript"><b>Важно!</b> Только приложения, выполняемые в браузере (то есть использующие дополнительный модуль браузера или элемент управления ActiveX) и содержимое, выполняемое в Adobe AIR, могут сначала показывать диалоговое окно с запросом имени пользователя и пароля для проверки подлинности и только после этого открывать окно загрузки. Для отправки данных с помощью версии Flash Player, подключаемой к обозревателю или использующей элемент управления ActiveX, или для загрузки с помощью автономного или внешнего проигрывателя, отправка файлов заканчивается ошибкой.</p>
    
    </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	Отправляется, когда загрузка завершается или в ходе загрузки создается код состояния HTTP со значением 200.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example shows usage of the <code>complete</code> event 
    listener. It should be made clear that there is no way to actually track the progress
    of a download, just that it hasn't yet finished or failed.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onComplete = function(file:FileReference):void {
      trace("onComplete: " + file.name);
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Отправляется, когда загрузка завершается или в ходе отправки создается код состояния HTTP со значением 200. При загрузке файла это событие отправляется в тот момент, когда <ph platform="actionscript">Flash Player или</ph> Adobe AIR завершает загрузку всего файла на диск. При загрузке файла это событие отправляется после того, как <ph platform="actionscript">Flash Player или</ph> Adobe AIR получает от принимающего сервера код состояния НТТР со значением 200.
    
    </apiDesc><example conref="examples\FileReference_event_complete.as"> В следующем примере показано применение объекта события <codeph>complete</codeph>. Чтобы запустить данный пример, измените свойство <codeph>downloadURL.url</codeph> так, чтобы оно указывало реальный домен и файл, а не выдуманный http://www. [yourDomain].com/SomeFile.pdf. Чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_complete extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_complete() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:FileReference_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
	Отправляется, когда загрузка файла прервана пользователем в диалоговом окне обзора файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example traces a message if the user dismisses the file-
    browsing dialog box. This method
    is triggered only if the user selects Cancel or presses the escape key after
    the dialog box opens.
    
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    
    listener.onCancel = function(file:FileReference):void {
      trace("onCancel");
    }
    
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    if(!fileRef.download(url, "FlashPlatform.pdf")) {
      trace("dialog box failed to open.");
    }
    </listing>
    
    </maelexample></asCustoms></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	Отправляется, когда загрузка файла прервана пользователем в диалоговом окне обзора файлов. Проигрыватель Flash Player не отправляет это событие, если пользователь отменяет загрузку каким-либо другим способом (путем закрытия браузера или остановки текущего приложения).
    
    </apiDesc><example conref="examples\FileReference_event_cancel.as"> В следующем примере показано применение объекта события <codeph>cancel</codeph>. Чтобы запустить данный пример, измените свойство <codeph>downloadURL.url</codeph> так, чтобы оно указывало реальный домен и файл, а не выдуманный http://www. [yourDomain].com/SomeFile.pdf. Чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;

    public class FileReference_event_cancel extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_event_cancel() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            file.addEventListener(Event.CANCEL, cancelHandler);
            file.download(downloadURL, fileName);
        }
        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:FileReference:FileReference"><apiName>FileReference</apiName><shortdesc>
    Создает новый объект FileReference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a new <code>FileReference</code> object and 
    initiates the download of a pdf file.
    <listing version="2.0">
    import flash.net.FileReference;
    
    var listener:Object = new Object();
    listener.onComplete = function(file:FileReference) {
      trace("onComplete : " + file.name);
    }
    
    var url:String = "http://www.adobe.com/platform/whitepapers/platform_overview.pdf";
    var fileRef:FileReference = new FileReference();
    fileRef.addListener(listener);
    fileRef.download(url, "FlashPlatform.pdf");
    </listing>
    
    </maelexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
    Создает новый объект FileReference. В заполненном состоянии объект FileReference представляет собой файл на локальном диске пользователя.
    
    </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:FileReference:browse"><apiName>browse</apiName><shortdesc>
    Отображает диалоговое окно выбора файлов, позволяющее пользователю выбрать файл для загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>browse, FileReference.browse
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра FileReference или FileReferenceList (единовременно может быть запущен только один сеанс просмотра файлов). 2) Настройка в файле пользователя mms.cfg запрещает данную операцию.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если массив <codeph>typeFilter</codeph> содержит неправильно сформатированные объекты FileFilter, создается соответствующее исключение. Сведения о правильном формате для объектов FileFilter представлены в описании класса <xref href="FileFilter.html">FileFilter</xref>.
  
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если вызов метода не выполняется в ответ на действие пользователя, такое как событие мыши или нажатие клавиши.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращает значение <codeph>true</codeph> при наличии допустимых параметров и открытии диалогового окна просмотра файлов.  
  
  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>Массив экземпляров FileFilter, который используется для фильтрации файлов, отображенных в диалоговом окне. Если данный параметр пропущен, то отображаются все файлы. Дополнительную информацию см. в описании класса <xref href="FileFilter.html">FileFilter</xref>.
    
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Отображает диалоговое окно выбора файлов, позволяющее пользователю выбрать файл для загрузки. Это диалоговое окно принадлежит операционной системе пользователя. Пользователь может выбрать файл на локальном компьютере или в других системах (например, с помощью UNC-пути в операционной системе Windows).
    
    <p><b>Примечание.</b> Класс File, доступный в Adobe AIR, включает методы для вызова более специфических системных диалогов для выбора файлов. Это методы <codeph>File.browseForDirectory()</codeph>, <codeph>File.browseForOpen()</codeph>, <codeph>File.browseForOpenMultiple()</codeph> и <codeph>File.browseForSave()</codeph>.</p>
    
    <p>Когда вы вызываете этот метод и пользователь успешно выбирает файл, свойства данного объекта FileReference заполняются свойствами выбранного файла. <codeph/> Единовременно может выполняться только один сеанс <codeph>browse()</codeph> или <codeph>download()</codeph> (так как в любой момент времени можно вызвать только одно диалоговое окно).</p>
    
    <p>С помощью параметра <codeph>typeFilter</codeph>можно определить, какие файлы будут отображаться в диалоговом окне.</p>
    
    <p platform="actionscript">В приложении Flash Player 10 и Flash Player 9 Update 5 этот метод можно вызывать только в ответ на пользовательское событие (например, в обработчике событий щелчка мыши или нажатия клавиши). В противном случае в результате вызова этого метода в приложении Flash Player возникает исключение Error.</p>
    
    <p platform="actionscript">Примите во внимание эти особенности, поскольку в приложение Flash Player добавлены новые функции. При публикации в приложении Flash Player 10 одновременно может быть активна только одна из следующих операций: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. В противном случае в приложении Flash Player возникает ошибка выполнения (код 2174). Используйте метод <codeph>FileReference.cancel()</codeph> для остановки выполняющейся операции. Это ограничение применяется только в приложении Flash Player 10. В предыдущих версиях Flash Player ограничение на одновременное выполнение нескольких операций не действует.</p> 
    
  </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/event:select"><linktext>select event</linktext></link><link href="flash.net.xml#FileReference/event:cancel"><linktext>cancel event</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForDirectory().xml"><linktext>File.browseForDirectory()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpen().xml"><linktext>File.browseForOpen()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForOpenMultiple().xml"><linktext>File.browseForOpenMultiple()</linktext></link><link href="" invalidHref="flash.filesystem.File.browseForSave().xml"><linktext>File.browseForSave()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:browse_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда пользователь успешно выбирает элемент в окне выбора файлов.
  </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда пользователь успешно выбирает элемент в окне выбора файлов.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:browse_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда пользователь закрывает окно выбора файлов для загрузки.
  
  </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда пользователь закрывает окно выбора файлов для загрузки.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:cancel"><apiName>cancel</apiName><shortdesc>
  Отменяет любую текущую операцию загрузки в отношении данного объекта FileReference.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>cancel, FileReference.cancel
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Отменяет все активные процессы отправки или загрузки.
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  Отменяет любую текущую операцию загрузки в отношении данного объекта FileReference. Вызов данного метода не приводит к отправке события <codeph>cancel</codeph>. Оно отправляется только в тот момент, когда пользователь отменяет операцию путем закрытия диалогового окна загрузки файлов.
  
    </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:FileReference:download"><apiName>download</apiName><shortdesc>
    Открывает диалоговое окно, позволяющее пользователю загрузить файл с удаленного сервера.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра (единовременно может быть запущен только один сеанс просмотра файлов). 2) Значение, переданное <codeph>request</codeph>, не содержит допустимый путь или протокол. 3) Имя загружаемого файла содержит запрещенные символы. 4) Настройка в файле пользователя mms.cfg запрещает данную операцию.
    
    	</apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Локальное ненадежное содержимое изолируется от Интернета. Чтобы избежать этой ситуации, следует переклассифицировать данный SWF-файл как локальный с сетевым подключением или доверенный. При создании данное исключение сопровождается сообщением, указывающим на отсутствие доступа к имени файла или URL-адресу вследствие локальных ограничений в системе безопасности файлов.
    
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
    
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если параметр <codeph>url.data</codeph> имеет тип ByteArray, создается исключение. Для использования с методами <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph> параметр <codeph>url.data</codeph> может быть только следующего типа: URLVariables или String.
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка может возникнуть по следующим причинам: 1) Проигрыватель Flash Player не может преобразовать значение параметра <codeph>URLRequest.data</codeph> из UTF8 в MBCS. Данная ошибка применяется, если объект URLRequest, переданный методу <codeph>FileReference.download()</codeph>, настроен на выполнение операции GET, а параметр <codeph>System.useCodePage</codeph> имеет значение <codeph>true</codeph>. 2) Проигрыватель Flash Player не может выделить память для данных <codeph>POST</codeph>. Данная ошибка применима, если переданный методу <codeph>FileReference.download()</codeph> объект URLRequest настроен на выполнение операции <codeph>POST</codeph>.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Если вызов метода не выполняется в ответ на действие пользователя, такое как событие мыши или нажатие клавиши.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest. В свойстве <codeph>url</codeph> объекта URLRequest должен быть указан URL-адрес файла, который необходимо загрузить на локальный компьютер. Если значение этого параметра равно <codeph>null</codeph>, создается исключение. Свойство <codeph>requestHeaders</codeph> объекта URLRequest игнорируется. Пользовательские заголовки запросов HTTP не поддерживаются при загрузке данных. Чтобы отправить параметры <codeph>POST</codeph> или GET на сервер, установите для них значение <codeph>URLRequest.data</codeph>, а затем установите значение <codeph>URLRequest.method</codeph> для <codeph>URLRequestMethod.POST</codeph> или <codeph>URLRequestMethod.GET</codeph>.
    
    	<p platform="actionscript">В некоторых браузерах строки URL-адреса имеют ограниченную длину. Строки длиной свыше 256 символов могут не обрабатываться в некоторых обозревателях и серверах.</p>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Имя файла, отображаемое по умолчанию в диалоговом окне загрузки файла. Данная строка не должна содержать следующие символы: / \ : ~~ ? " &lt; > | %
    <p>Если данный параметр опустить, будет обрабатываться и использоваться по умолчанию имя файла удаленного URL-адреса. </p>
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    Открывает диалоговое окно, позволяющее пользователю загрузить файл с удаленного сервера. <ph platform="actionscript">Несмотря на то, что Flash Player не имеет ограничений на размер загружаемых файлов, официально проигрыватель поддерживает обработку информации, объем которой не превышает 100 МБ.</ph>
    
    <p>Сначала метод <codeph>download()</codeph> открывает диалоговое окно операционной системы, в котором пользователь должен ввести имя файла и выбрать место на локальном компьютере для сохранения этого файла. После того как пользователь выберет нужное место и подтвердит операцию загрузки (например, путем нажатия кнопки «Сохранить»), начнется загрузка с удаленного сервера. Прослушиватели получают события для определения состояния, успешности или сбоя загрузки. Чтобы определить состояние диалогового окна и операции загрузки после вызова метода <codeph>download()</codeph>, ваш код должен предусматривать прослушивание таких событий как <codeph>cancel</codeph>, <codeph>open</codeph>, <codeph>progress</codeph> и <codeph>complete</codeph>.
    </p>
    
    <p>Функции <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph> не являются блокирующими. Эти функции возвращаются после вызова до завершения операции передачи файла. Кроме этого, если объект FileReference покинет зону действия, любая незавершенная отправка или загрузка в отношении данного объекта будет отменена в момент его выхода из зоны действия. Следите за тем, чтобы объект FileReference оставался в области действия на всем протяжении операции загрузки.</p>
    
    <p>После успешной загрузки файла свойства объекта FileReference заполняются свойствами локального файла. Событие <codeph>complete</codeph> отправляется при успешном завершении загрузки.</p>
    
    <p>Единовременно может выполняться только один сеанс <codeph>browse()</codeph> или <codeph>download()</codeph> (так как в любой момент времени можно вызвать только одно диалоговое окно).</p>
    
    <p>Данный метод поддерживает загрузку файла любого типа по протоколу HTTP или HTTPS.</p>
    
     <p>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
    
    <p><b>Примечание</b>. Если ваш сервер требует аутентификации пользователей, только Flash-приложения, запущенные в обозревателе (то есть с использованием дополнительного модуля обозревателя или элемента управления ActiveX), могут представить пользователю диалоговое окно для ввода имени пользователя и пароля (для аутентификации) и только потом перейти к загрузкам. При загрузке с помощью дополнительного модуля или элемента управления ActiveX, а также при загрузке данных посредством автономного или внешнего проигрывателя происходит сбой передачи файлов.</p>
    
    <p>При использовании этого метода <ph platform="javascript">в содержимом, находящемся в изолированных программных средах безопасности, отличных от изолированной среды приложения</ph>, учитывайте модель безопасности <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph>: </p>
    
    <ul>
    <li>Операции загрузки запрещены, если вызывающий SWF-файл находится в ненадежной локальной изолированной среде.</li>
    
    <li>По умолчанию, взаимодействие между изолированными средами запрещено. Чтобы обеспечить доступ к ресурсу, web-сайт может добавить файл политик для URL.</li>
    
    <li platform="actionscript">Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</li>
    
    <li platform="actionscript">В приложении Flash Player 10 и Flash Player 9 Update 5 этот метод можно вызывать только в ответ на пользовательское событие (например, в обработчике событий щелчка мыши или нажатия клавиши). В противном случае в результате вызова этого метода в приложении Flash Player возникает исключение Error.</li>
    
    </ul>
    
    <p>Однако в <ph platform="actionscript">Adobe AIR</ph> эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
    
    <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
    
    <ul>
           
    <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
    
    <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
    
    <li>Раздел «Understanding AIR Security» (Сведения о безопасности AIR) главы «Getting started with Adobe AIR» (Начало работы с Adobe AIR) книги <i>Developing AIR Applications</i> (Разработка приложений AIR).</li>
    
    <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
    
    </ul>
    
    <p>Примите во внимание эти особенности, поскольку в приложение Flash Player добавлены новые функции. При публикации в приложении Flash Player 10 одновременно может быть активна только одна из следующих операций: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. В противном случае в приложении Flash Player возникает ошибка выполнения (код 2174). Используйте метод <codeph>FileReference.cancel()</codeph> для остановки выполняющейся операции. Это ограничение применяется только в приложении Flash Player 10. В предыдущих версиях Flash Player ограничение на одновременное выполнение нескольких операций не действует.</p> 
	
    </apiDesc><example conref="examples\FileReference_download.as"> В следующем примере показано применение объекта события <codeph>download</codeph>. Чтобы запустить данный пример, измените свойство <codeph>downloadURL.url</codeph> так, чтобы оно указывало реальный домен и файл, а не выдуманный http://www. [yourDomain].com/SomeFile.pdf. Чтобы обеспечить сетевой доступ к этому файлу, может также потребоваться скомпилировать SWF-файл с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к сети» или обновить параметры безопасности проигрывателя Flash Player.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.FileReference;
    import flash.net.URLRequest;
    import flash.net.FileFilter;

    public class FileReference_download extends Sprite {
        private var downloadURL:URLRequest;
        private var fileName:String = "SomeFile.pdf";
        private var file:FileReference;

        public function FileReference_download() {
            downloadURL = new URLRequest();
            downloadURL.url = "http://www.[yourDomain].com/SomeFile.pdf";
            file = new FileReference();
            configureListeners(file);
            file.download(downloadURL, fileName);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.CANCEL, cancelHandler);
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(Event.SELECT, selectHandler);
        }

        private function cancelHandler(event:Event):void {
            trace("cancelHandler: " + event);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            var file:FileReference = FileReference(event.target);
            trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function selectHandler(event:Event):void {
            var file:FileReference = FileReference(event.target);
            trace("selectHandler: name=" + file.name + " URL=" + downloadURL.url);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>FileReference.upload()</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:download_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при запуске операции загрузки.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при запуске операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется периодически в ходе операции загрузки файла.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется периодически в ходе операции загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции загрузки файла.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда пользователь закрывает диалоговое окно.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда пользователь закрывает диалоговое окно.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда пользователь выбирает в диалоговом окне файл для загрузки. 
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда пользователь выбирает в диалоговом окне файл для загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при сбое загрузки вследствие ошибки в системе безопасности.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при сбое загрузки вследствие ошибки в системе безопасности.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:download_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется по одной из причин, перечисленных ниже.
    <ul>
    <li>Ошибка ввода-вывода возникает при считывании или отправке файла.</li>
    	<li>SWF-содержимое в автономных или внешних версиях проигрывателя Flash Player пытается загрузить файл с сервера, требующего аутентификации. Во время загрузки автономные и внешние проигрыватели не обеспечивают пользователей возможностью ввода паролей. Если SWF-файл в этих проигрывателях пытается загрузить файл с сервера, требующего аутентификацию, то происходит сбой загрузки. Загрузка файлов может быть успешной только при использовании проигрывателей с дополнительными модулями и элементами управления ActiveX.</li>
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется по любой из следующих причин: возникновение ошибки ввода-вывода в процессе чтения или передачи файла. SWF-содержимое в автономных или внешних версиях проигрывателя Flash Player пытается загрузить файл с сервера, требующего аутентификации.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:load"><apiName>load</apiName><shortdesc>
    Начинает загрузку локального файла, выбранного пользователем.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>load, FileReference.load
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра FileReference или FileReferenceList (единовременно может быть запущен только один сеанс просмотра файлов). 2) Настройка в файле пользователя mms.cfg запрещает данную операцию.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка возникает в том случае, если приложение не может выделить память для указанного файла. Слишком большой файл или очень мало доступной памяти.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>Начинает загрузку локального файла.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Начинает загрузку локального файла, выбранного пользователем. <ph platform="actionscript"> Несмотря на то, что Flash Player не имеет ограничений в отношении размера передаваемых, загружаемых или сохраняемых файлов, гарантированно проигрыватель поддерживает обработку информации, объем которой не превышает 100 МБ. Для содержимого, воспроизводимого в проигрывателе Flash Player, необходимо вызвать метод <codeph>FileReference.browse()</codeph> или <codeph>FileReferenceList.browse()</codeph> перед вызовом метода <codeph>load()</codeph>. Однако содержимое, воспроизводимое в изолированной программной среде приложения AIR, может вызывать метод <codeph>load()</codeph> объекта File без необходимости предварительного вызова метода <codeph>browse()</codeph>. (Класс File в AIR является расширением класса FileReference.) </ph>
    
    <p>Прослушиватели получают события для определения состояния, успешности или сбоя загрузки. Несмотря на то, что с помощью объекта FileReferenceList можно предоставить пользователям возможность выбирать для загрузки сразу несколько файлов, загружать эти файлы следует по одному. Для этого надо выполнить итерации в отношении массива <codeph>FileReferenceList.fileList</codeph> объектов FileReference.</p>
    
    <p>Adobe AIR также включает класс FileStream, который предоставляет больше возможностей для чтения файлов.</p>
    
    <p>Функции <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> и <codeph>FileReference.save()</codeph> не являются блокирующими. Эти функции возвращаются после вызова до завершения операции передачи файла. Кроме этого, если объект FileReference покинет область приложения, любая незавершенная операция в отношении данного объекта будет отменена в момент его выхода из области приложения. Следите за тем, чтобы объект FileReference оставался в области действия на всем протяжении операции отправки, загрузки или сохранения.</p>
    
    <p>При успешном завершении загрузки файла его содержимое сохраняется как массив байтов в свойстве <codeph>data</codeph> объекта FileReference.</p>
    
    <p platform="actionscript">Применяются следующие правила безопасности:</p>
    
    <ul platform="actionscript">
    <li>Операции загрузки запрещены, если вызывающий SWF-файл находится в ненадежной локальной изолированной среде.</li>
    <li>По умолчанию, взаимодействие между изолированными средами запрещено. Чтобы обеспечить доступ к ресурсу, web-сайт может добавить файл междоменной политики.</li>
    <li>Можно запретить использование файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</li>
    </ul>
    
    <p platform="actionscript">Однако эти ограничения не применимы к содержимому AIR в изолированной программной среде приложения.</p>
    
    <p>Обратите внимание, что при публикации в приложении Flash Player 10 или AIR 1.5 одновременно может быть активна только одна из следующих операций: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. В противном случае в приложении возникает ошибка времени выполнения (код 2174). Используйте метод <codeph>FileReference.cancel()</codeph> для остановки выполняющейся операции. Это ограничение применяется только к Flash Player 10 и AIR 1.5. В предыдущих версиях Flash Player или AIR отсутствует ограничение на одновременное выполнение нескольких операций.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/data"><linktext>FileReference.data</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/save()"><linktext>FileReference.save()</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>flash.filesystem.FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется в начале операции загрузки.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется в начале операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется периодически в ходе операции загрузки файла.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется периодически в ходе операции загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции загрузки файла.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при сбое загрузки вследствие ошибки ввода-вывода, возникшей во время считывания или записи файла приложением.
    
    </apiDesc></adobeApiEventDetail><shortdesc>Вызывается при сбое загрузки вследствие ошибки ввода-вывода, возникшей во время считывания или записи файла приложением.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:save"><apiName>save</apiName><shortdesc>
    Открывает диалоговое окно, позволяющее пользователю сохранить файл в локальной файловой системе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра (единовременно может быть запущен только один сеанс просмотра файлов). 2) Имя загружаемого файла содержит запрещенные символы. 3) Настройка в файле пользователя mms.cfg запрещает данную операцию.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если параметр <codeph>data</codeph> не относится к типу ByteArray и не имеет метода <codeph>toString()</codeph>, создается исключение. Если параметр <codeph>data</codeph> не относится к типу XML и не имеет метода <codeph>toXMLString()</codeph>, создается исключение.
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Если вызов метода не выполняется в ответ на действие пользователя, такое как событие мыши или нажатие клавиши.
    
    </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка возникает в том случае, если проигрыватель Flash Player не может выделить память для указанного файла. Слишком большой файл или очень мало доступной памяти.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>data</apiItemName><apiType value=""/><apiDesc>Сохраняемые данные. Данные могут быть представлены в одном из форматов и обработаны соответствующим образом:
    <ul>
    <li>Если значение равно <codeph>null</codeph>, приложение выдает исключение ArgumentError.</li> 
    <li>Если значением является String, данные сохраняются как текстовый файл в кодировке UTF-8.</li>
    <li platform="actionscript">Если значением является XML, данные сохраняются в текстовом файле формата XML с сохранением всего форматирования.</li> 
    <li>Если значением является ByteArray, данные дословно записываются в файл данных.</li> 
    <li>Если параметр имеет значение, отличное от приведенных выше, метод <codeph>save()</codeph> вызывает метод <codeph>toString()</codeph> объекта для преобразования данных в строку и их последующего сохранения в текстовый файл. В случае сбоя операции приложение выдает исключение ArgumentError.</li> 
    </ul>
    
    </apiDesc></apiParam><apiParam><apiItemName>defaultFileName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Имя файла, отображаемое по умолчанию в диалоговом окне сохранения файла. Данная строка не должна содержать следующие символы: / \ : ~~ ? " &lt; > | %
    <p><ph platform="javascript">В Flash Player если этот параметр опускается, имя файла будет пустым по умолчанию. </ph>При вызове этого метода объектом File именем файла будет являться имя файла, на который ссылается объект File. (Класс File в AIR является расширением класса FileReference.)</p>
    
	</apiDesc></apiParam></apiOperationDef><apiDesc>
    Открывает диалоговое окно, позволяющее пользователю сохранить файл в локальной файловой системе. <ph platform="actionscript">Несмотря на то, что Flash Player не имеет ограничений на размер отправляемых, загружаемых или сохраняемых файлов, официально проигрыватель поддерживает обработку информации, объем которой не превышает 100 МБ.</ph>
    
    <p>Сначала метод <codeph>save()</codeph> открывает диалоговое окно операционной системы, в котором пользователь должен ввести имя файла и выбрать место на локальном компьютере для сохранения этого файла. После того как пользователь выберет нужное место и подтвердит операцию сохранения (например, путем нажатия кнопки «Сохранить»), начнется процесс сохранения. Прослушиватели получают события для определения состояния, успешности или сбоя операции сохранения. Для определения состояния диалогового окна и операции сохранения после вызова метода <codeph>save()</codeph>, ваш код должен предусматривать прослушивание таких событий как <codeph>cancel</codeph>, <codeph>open</codeph>, <codeph>progress</codeph> и <codeph>complete</codeph>.
    </p>
    
    <p>Adobe AIR также включает класс FileStream, который предоставляет больше возможностей для сохранения файлов в локальной системе</p>
    
    <p>Функции <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph> и <codeph>FileReference.save()</codeph> не являются блокирующими. Эти функции возвращаются после вызова до завершения операции передачи файла. Кроме этого, если объект FileReference покинет область приложения, любая незавершенная операция в отношении данного объекта будет отменена в момент его выхода из области приложения. Следите за тем, чтобы объект FileReference оставался в области приложения на всем протяжении операции отправки, загрузки или сохранения.</p>
    
    <p>При успешном сохранении файла свойства объекта FileReference заполняются свойствами локального файла. Событие <codeph>complete</codeph> отправляется при успешном завершении операции сохранения.</p>
    
    <p>Единовременно может выполняться только один сеанс <codeph>browse()</codeph> или <codeph>save()</codeph> (так как в любой момент времени можно вызвать только одно диалоговое окно).</p>
    
    <p platform="actionscript">В приложении Flash Player этот метод можно успешно вызвать только в ответ на пользовательское событие (например, в обработчике событий щелчка мыши или нажатия клавиши). В противном случае в результате вызова этого метода в приложении Flash Player возникает исключение Error. Это ограничение не применимо к содержимому AIR в изолированной программной среде приложения.</p>
    
    </apiDesc><example conref="examples\FileReference_save.as"> В следующем примере содержимое, введенное в текстовом поле, сохраняется в файл. Код создает редактируемое текстовое поле (<codeph>MyTextField</codeph>) и нередактируемое текстовое поле (<codeph>MyButtonField</codeph>), которое будет выполнять функцию кнопки и реагировать на щелчок мыши. Пользователь может отредактировать содержимое первого текстового поля, а затем нажать кнопку, чтобы сохранить измененное содержимое в локальном файле. Обработчик события щелчка мыши <codeph>clickhandler</codeph> использует метод <codeph>FileReference.save()</codeph> (для объекта FileReference с именем <codeph>MyFileReference</codeph>), чтобы открыть диалоговое окно в текущей операционной системе, чтобы пользователь мог сохранить содержимое в локальный файл с указанным именем.
<codeblock>
var MyTextField:TextField = new TextField();
var MyButtonField:TextField = new TextField();
var MyFile:FileReference = new FileReference();

MyTextField.border = true;
MyTextField.type = TextFieldType.INPUT;

MyButtonField.background = true;
MyButtonField.backgroundColor = 0x339933;
MyButtonField.x = 150;
MyButtonField.height = 20;
MyButtonField.text = "Click here to save";

addChild(MyTextField);
addChild(MyButtonField);
MyButtonField.addEventListener(MouseEvent.CLICK, clickhandler);

function clickhandler(e:MouseEvent): void {
    MyFile.save(MyTextField.text);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/load()"><linktext>FileReferenceList.load()</linktext></link><link href="flash.net.xml#FileReferenceList/data"><linktext>FileReferenceList.data</linktext></link><link href="flash.net.xml#FileReferenceList/upload"><linktext>FileReferenceList.upload</linktext></link><link href="flash.net.xml#FileReferenceList/download"><linktext>FileReferenceList.download</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:save_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при запуске операции загрузки.
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется при запуске операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется периодически в ходе операции загрузки файла.
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется периодически в ходе операции загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции загрузки файла.
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции загрузки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда пользователь закрывает диалоговое окно.
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда пользователь закрывает диалоговое окно.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, когда пользователь выбирает в диалоговом окне файл для загрузки. 
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, когда пользователь выбирает в диалоговом окне файл для загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:save_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, если при считывании или передаче файла возникает ошибка ввода-вывода.
    
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, если при считывании или передаче файла возникает ошибка ввода-вывода.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:upload"><apiName>upload</apiName><shortdesc>
    Запускает отправку выбранного пользователем файла на удаленный сервер.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>upload, FileReference.upload
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Локальные ненадежные SWF-файлы могут быть изолированы от Интернета. Чтобы избежать этой ситуации, следует переклассифицировать данный SWF-файл как локальный с сетевым подключением или доверенный. При создании данное исключение сопровождается сообщением, указывающим имя недоступного локального файла и URL-адрес.
    
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
    </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра FileReference или FileReferenceList (единовременно может быть запущен только один сеанс просмотра файлов). 2) Параметр URL не является допустимым путем или протоколом. При передаче файлов должен использоваться протокол HTTP, а при загрузке файлов - FTP или HTTP. 3) Параметр <codeph>uploadDataFieldName</codeph> имеет значение <codeph>null</codeph>. 4) Настройка в файле пользователя mms.cfg запрещает данную операцию.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Создается в следующих ситуациях: 1) Параметр <codeph>uploadDataFieldName</codeph> содержит пустую строку. 2) <codeph>url.data</codeph> имеет тип ByteArray. Для использования с методами <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph> параметр <codeph>url.data</codeph> может быть только следующего типа: URLVariables или String. 3) В модуле выполнения AIR (в изолированной программной среде безопасности приложения) метод запроса URLRequest не является GET или POST (вместо этого следует использовать <codeph>uploadEncoded()</codeph>).
    
    </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка может возникнуть по следующим причинам: 1) Проигрыватель Flash Player не может преобразовать значение параметра <codeph>URLRequest.data</codeph> из UTF8 в MBCS. Данная ошибка применяется, если объект URLRequest, переданный методу <codeph>FileReference.upload()</codeph>, настроен на выполнение операции <codeph>GET</codeph>, а параметр <codeph>System.useCodePage</codeph> имеет значение true. 2) Проигрыватель Flash Player не может выделить память для данных <codeph>POST</codeph>. Данная ошибка применима, если объект URLRequest, переданный методу <codeph>FileReference.upload()</codeph>, настроен на выполнение операции <codeph>POST</codeph>.
    
    </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest. Свойство <codeph>url</codeph> объекта URLRequest должно содержать URL-адрес сценария сервера, настроенного на обработку операции отправки с помощью HTTP-вызовов <codeph>POST</codeph>. В некоторых обозревателях URL-строки имеют ограниченную длину. Строки длиной свыше 256 символов могут не обрабатываться в некоторых обозревателях и серверах. Если значение этого параметра равно <codeph>null</codeph>, создается исключение. Свойство <codeph>requestHeaders</codeph> объекта URLRequest игнорируется. Пользовательские заголовки запросов HTTP не поддерживаются ни при отправке, ни при загрузке данных.
     
    <p>Для URL-адреса может использоваться протокол HTTP или HTTPS (для защищенной передачи данных). Для использования HTTPS следует в параметре <codeph>url</codeph> указать URL-адрес с протоколом HTTPS. Если в параметре <codeph>url</codeph> не указан номер порта, то по умолчанию используется порт 80 для протокола HTTP и порт 443 для протокола HTTPS.</p>
    
    <p>Чтобы отправить параметры <codeph>POST</codeph> или <codeph>GET</codeph> на сервер, установите необходимые параметры для свойства <codeph>data</codeph> объекта URLRequest, а также установите для свойства <codeph>method</codeph> значение <codeph>URLRequestMethod.POST</codeph> или <codeph>URLRequestMethod.GET</codeph>.</p>
    
    
    </apiDesc></apiParam><apiParam><apiItemName>uploadDataFieldName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>Filedata</apiData><apiDesc>Имя поля, предшествующее данным файла при операции передачи <codeph>POST</codeph>. Значение <codeph>uploadDataFieldName</codeph> не должно быть нулевым или пустой строкой. По умолчанию значение <codeph>uploadDataFieldName</codeph> равно <codeph>Filedata</codeph>, как показано в следующем примере запроса <codeph>POST</codeph>:
    <pre>
    Content-Type: multipart/form-data; boundary=AaB03x
    --AaB03x 
    Content-Disposition: form-data; name="Filedata"; filename="example.jpg" 
    Content-Type: application/octet-stream
    ... contents of example.jpg ... 
    --AaB03x-- 
    </pre>
    
    </apiDesc></apiParam><apiParam><apiItemName>testUpload</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Настройка, позволяющая запросить тестовую загрузку файла. Если параметр <codeph>testUpload</codeph> имеет значение <codeph>true</codeph>, то для файлов с размером больше 10 Кб проигрыватель Flash Player инициирует тестовую загрузку <codeph>POST</codeph>, в которой параметр Content-Length имеет значение 0. При тестовой передаче проверяется, будет ли успешной загрузка фактических файлов и, при необходимости, аутентификация сервера. Тестовая загрузка доступна только для проигрывателей Windows.
    
    
    </apiDesc></apiParam><apiTipTexts><apiTipText>Запускает загрузку файла на удаленный сервер.
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Запускает загрузку выбранного пользователем файла на удаленный сервер. <ph platform="actionscript">Несмотря на то, что Flash Player не имеет ограничений на размер загружаемых файлов, официально проигрыватель поддерживает обработку информации, объем которой не превышает 100 МБ. </ph>Перед тем как вызвать данный метод, следует вызвать метод <codeph>FileReference.browse()</codeph> или <codeph>FileReferenceList.browse()</codeph>.
    
    <p>Прослушиватели получают события для определения состояния, успешного выполнения или сбоя загрузки. Несмотря на то, что с помощью объекта FileReferenceList можно предоставить пользователям возможность выбирать для загрузки сразу несколько файлов, загружать эти файлы следует по одному. Для этого надо выполнить итерации в отношении массива <codeph>FileReferenceList.fileList</codeph> объектов FileReference.</p>
    
    <p>Функции <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph> не являются блокирующими. Эти функции возвращаются после вызова до завершения операции передачи файла. Кроме этого, если объект FileReference покинет зону действия, любая незавершенная отправка или загрузка в отношении данного объекта будет отменена в момент его выхода из зоны действия. Следите за тем, чтобы объект FileReference оставался в области действия на всем протяжении операции загрузки.</p>
    
    <p>Файл загружается на URL-адрес, указанный в параметре <codeph>url</codeph>. В качестве URL-адреса должен выступать сценарий сервера, сконфигурированный на принятие загружаемых данных. Проигрыватель Flash Player загружает файлы с помощью метода <codeph>POST</codeph> по протоколу HTTP. Сценарий сервера, обрабатывающий загрузку, должен ожидать запрос <codeph>POST</codeph> со следующими элементами:</p>
    <ul>
    <li><codeph>Content-Type</codeph> со значением <codeph>multipart/form-data</codeph></li>
    <li><codeph>Content-Disposition</codeph>, у которого атрибут <codeph>name</codeph> имеет по умолчанию значение <codeph>Filedata</codeph>, а атрибут <codeph>filename</codeph> указывает имя исходного файла.</li>
    <li>Двоичное содержимое файла</li></ul>
    
     <p>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
    
    <p>Образец запроса <codeph>POST</codeph> представлен в описании параметра <codeph>uploadDataFieldName</codeph>. Параметры <codeph>POST</codeph> или <codeph>GET</codeph> можно загрузить на сервер вместе с методом <codeph>upload()</codeph> (см. описание параметра <codeph>request</codeph>).</p>
    
    <p>Если параметр <codeph>testUpload</codeph> имеет значение <codeph>true</codeph>, а размер передаваемого файла превышает 10 Кб, то в ОС Windows проигрыватель Flash Player сначала отправляет операцию тестовой загрузки <codeph>POST</codeph> с нулевым содержимым. Это выполняется до загрузки фактического файла с целью проверки механизма передачи. Затем проигрыватель Flash Player отправляет вторую операцию <codeph>POST</codeph>, в которой находится фактическое содержимое файла. При обработке файлов, размер которых не превышает 10 КБ, проигрыватель Flash Player выполняет отдельную загрузку <codeph>POST</codeph>, используя при этом фактическое содержимое загружаемого файла. На компьютерах Macintosh проигрыватель Flash Player не выполняет операции тестовой передачи <codeph>POST</codeph>.</p>
    
    <p><b>Примечание</b>: Если ваш сервер требует аутентификации пользователей, только Flash-приложения, запущенные в браузере (то есть с использованием дополнительного модуля браузера или элемента управления ActiveX), могут представить пользователю диалоговое окно для ввода имени пользователя и пароля (для аутентификации) и только потом перейти к загрузкам. При загрузке с помощью дополнительного модуля или элемента управления ActiveX, а также при загрузке данных посредством автономного или внешнего проигрывателя происходит сбой передачи файлов.</p>
    
    <p>При использовании этого метода <ph platform="javascript">в содержимом, находящемся в изолированных программных средах безопасности, отличных от изолированной среды приложения</ph>, учитывайте модель безопасности <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR</ph>: </p>
    
    
    <ul>
    <li>Операции загрузки запрещены, если вызывающий SWF-файл находится в ненадежной локальной изолированной среде.</li>
    
    <li>По умолчанию, взаимодействие между изолированными средами запрещено. Чтобы обеспечить доступ к ресурсу, web-сайт может добавить файл политик для URL.</li>
    
	<li platform="actionscript">Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</li>
    
    </ul>
    
    <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p>
    
	<p>Дополнительные сведения см. в следующих источниках.</p>
    
    <ul>
    
    <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
    
    <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
    
    <li>Раздел «Understanding AIR Security» (Сведения о безопасности AIR) главы «Getting started with Adobe AIR» (Начало работы с Adobe AIR) книги <i>Developing AIR Applications</i> (Разработка приложений AIR).</li>
    
    <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
    </ul>
    <p>Примите во внимание эти особенности, поскольку в приложение Flash Player добавлены новые функции. При публикации в приложении Flash Player 10 одновременно может быть активна только одна из следующих операций: <codeph>FileReference.browse()</codeph>, <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph>, <codeph>FileReference.load()</codeph>, <codeph>FileReference.save()</codeph>. В противном случае в приложении Flash Player возникает ошибка выполнения (код 2174). Используйте метод <codeph>FileReference.cancel()</codeph> для остановки выполняющейся операции. Это ограничение применяется только в приложении Flash Player 10. В предыдущих версиях Flash Player ограничение на одновременное выполнение нескольких операций не действует.</p>
    
    </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:upload_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется в начале операции отправки.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется в начале операции отправки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется периодически в ходе операции отправки файла.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется периодически в ходе операции отправки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции отправки файла.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции отправки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при получении данных с сервера после успешной отправки файла.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при получении данных с сервера после успешной отправки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при сбое отправки вследствие нарушений в системе безопасности.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при сбое отправки вследствие нарушений в системе безопасности.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при возникновении сбоя отправки в результате ошибки протокола HTTP.
	
 	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется при возникновении сбоя отправки в результате ошибки протокола HTTP.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Операция отправки успешно завершается и сервер возвращает URL и заголовки ответа.
	
    </apiDesc></adobeApiEventDetail><shortdesc>Операция отправки успешно завершается и сервер возвращает URL и заголовки ответа.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:upload_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при любой из следующих ситуаций.
    <ul>
    <li>Загрузка выполняется с ошибками из-за ошибки ввода-вывода при считывании, записи или передаче файла <ph platform="actionscript">Flash Player или</ph> Adobe AIR.</li>
    <li>Сбой отправки, вызванный попыткой загрузить файл на сервер, требующий аутентификации (имя пользователя и пароль). В процессе отправки у пользователя нет возможности ввести пароль.</li>
    <li>Загрузка выполняется с ошибками, так как параметр <codeph>url</codeph> содержит недопустимый протокол. В<codeph>FileReference.upload()</codeph> требуется использовать HTTP или HTTPS.</li>
    
    </ul>
    
    </apiDesc></adobeApiEventDetail><shortdesc>Вызывается в любой из следующих ситуаций: сбой отправки из-за ошибки ввода-вывода, возникшей в момент считывания, записи или передачи файла проигрывателем Flash Player или приложением Adobe AIR; Сбой отправки, вызванный попыткой загрузить файл на сервер, требующий аутентификации (имя пользователя и пароль).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:FileReference:uploadUnencoded"><apiName>uploadUnencoded</apiName><shortdesc>
    Инициируют отправку файла в URL-адрес без кодировки.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Локальные ненадежные SWF-файлы могут быть изолированы от Интернета. Чтобы избежать этой ситуации, следует переклассифицировать данный SWF-файл как локальный с сетевым подключением или доверенный. При создании данное исключение сопровождается сообщением, указывающим имя недоступного локального файла и URL-адрес.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Создается в следующих ситуациях: 1) В текущий момент запущен другой сеанс просмотра FileReference или FileReferenceList (единовременно может быть запущен только один сеанс просмотра файлов). 2) Параметр URL не является допустимым путем или протоколом. При отправке файла должен использоваться протокол НТТР.
	
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest. Свойство <codeph>url</codeph> объекта URLRequest должно содержать URL-адрес сценария сервера, настроенного на обработку операции отправки с помощью HTTP-вызовов <codeph>POST</codeph>. В некоторых обозревателях URL-строки имеют ограниченную длину. Строки длиной больше 256 символов могут не обрабатываться в некоторых обозревателях и серверах. Если значение этого параметра равно <codeph>null</codeph>, создается исключение.  
	 
	<p>Для URL-адреса может использоваться протокол HTTP или HTTPS (для защищенной передачи данных). Для использования HTTPS следует в параметре <codeph>url</codeph> указать URL-адрес с протоколом HTTPS. Если в параметре <codeph>url</codeph> не указан номер порта, то по умолчанию используется порт 80 для протокола HTTP и порт 443 для протокола HTTPS.</p>
	
	<p>Для отправки параметров <codeph>POST</codeph> или <codeph>GET</codeph> на сервер, установите необходимые параметры для свойства <codeph>data</codeph> объекта URLRequest, а также установите для свойства <codeph>method</codeph> значение <codeph>URLRequestMethod.POST</codeph> или <codeph>URLRequestMethod.GET</codeph>.</p>
   	
    </apiDesc></apiParam><apiTipTexts><apiTipText>Запускает загрузку файла на удаленный сервер без кодирования. 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    Инициируют отправку файла в URL-адрес без кодировки. Тогда как метод <codeph>upload()</codeph> кодирует файл в виде пакета данных, метод <codeph>uploadUnencoded()</codeph> передает содержимое файла как есть в теле запроса НТТР. Используйте метод uploadUnencoded(), если отправляемые данные уже закодированы в формате, понятном для получающего сервера. Обычно метод <codeph>uploadeUnencoded()</codeph> используется вместе с методом <codeph>HTTP/WebDAV PUT</codeph>.
	
	</apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReferenceList/browse()"><linktext>FileReferenceList.browse()</linktext></link><link href="flash.net.xml#FileReference/download()"><linktext>FileReference.download()</linktext></link><link href="flash.net.xml#FileReferenceList/fileList"><linktext>FileReferenceList.fileList</linktext></link><link href="flash.net.xml#FileReference/upload()"><linktext>upload()</linktext></link></related-links><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется в начале операции отправки.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется в начале операции отправки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется периодически в ходе операции отправки файла.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется периодически в ходе операции отправки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешного завершения операции отправки файла.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешного завершения операции отправки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_uploadCompleteData"><apiName>uploadCompleteData</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:DataEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при получении данных с сервера после успешной отправки файла.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется при получении данных с сервера после успешной отправки файла.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при сбое отправки вследствие нарушений в системе безопасности.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется при сбое отправки вследствие нарушений в системе безопасности.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при возникновении сбоя отправки в результате ошибки протокола HTTP.
	
 	</apiDesc></adobeApiEventDetail><shortdesc>Отправляется при возникновении сбоя отправки в результате ошибки протокола HTTP.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Операция отправки успешно завершается и сервер возвращает URL и заголовки ответа.
	
	</apiDesc></adobeApiEventDetail><shortdesc>Операция отправки успешно завершается и сервер возвращает URL и заголовки ответа.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:FileReference:uploadUnencoded_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызывается при любой из следующих ситуаций.
    <ul>
	<li>Загрузка выполняется с ошибками из-за ошибки ввода-вывода при считывании, записи или передаче файла посредством Adobe AIR.</li>
	<li>Сбой отправки, вызванный попыткой загрузить файл на сервер, требующий аутентификации (имя пользователя и пароль). В процессе отправки у пользователя нет возможности ввести пароль.</li>
	<li>Загрузка выполняется с ошибками, так как параметр <codeph>url</codeph> содержит недопустимый протокол. В<codeph>FileReference.upload()</codeph> требуется использовать HTTP или HTTPS.</li>
	</ul>
	
	</apiDesc></adobeApiEventDetail><shortdesc>Вызывается в любой из следующих ситуаций: сбой отправки из-за ошибки ввода-вывода, возникшей в момент, когда чтения, записи или передачи файла приложением Adobe AIR; Сбой отправки, вызванный попыткой загрузить файл на сервер, требующий аутентификации (имя пользователя и пароль).</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:FileReference:creationDate:get"><apiName>creationDate</apiName><shortdesc>
    Дата создания файла на локальном диске.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creationDate, FileReference.creationDate
    
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>При неудачном вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> создается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем. В этом случае значение свойства <codeph>creationDate</codeph> равно <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если информация файла недоступна, создается исключение с сообщением, регистрирующим ошибку ввода-вывода файла.
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Определяет дату создания файла в виде объекта Date.
    
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Дата создания файла на локальном диске. Если объект не был заполнен, вызов с целью получения значения данного свойства возвращает значение <codeph>null</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:creator:get"><apiName>creator</apiName><shortdesc>
    Тип создателя Macintosh для файла, который используется только в версиях OS, предшествующих Mac OS X.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>creator, FileReference.creator
    </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>На компьютерах Macintosh при неудачном вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> создается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем. В этом случае значение свойства <codeph>creator</codeph> равно <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Тип создателя в Macintosh.
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Тип создателя Macintosh для файла, который используется только в версиях OS, предшествующих Mac OS X. В Windows или Linux это свойство имеет значение <codeph>null</codeph>. Если объект FileReference не был заполнен, вызов с целью получения значения данного свойства возвращает значение <codeph>null</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:data:get"><apiName>data</apiName><shortdesc>
    Объект ByteArray, представляющий данные из файла, загруженного в результате успешного вызова метода load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><refpath>
    </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>При неудачном вызове метода <codeph>load()</codeph> выдается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем. В этом случае значение свойства <codeph>data</codeph> равно <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если файл не открывается или не считывается или если подобная ошибка возникает при обращении к файлу, в системе создается исключение с сообщением, указывающим на ошибку ввода-вывода файла. В этом случае значение свойства <codeph>data</codeph> равно <codeph>null</codeph>.
    
    </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Загруженные данные файла (в качестве ByteArray).
    </apiTipText></apiTipTexts></apiValueDef><apiDesc>
    Объект ByteArray, представляющий данные из файла, загруженного в результате успешного вызова метода <codeph>load()</codeph>.
    
    </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link><link href="flash.net.xml#FileReference/load()"><linktext>FileReference.load()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:extension:get"><apiName>extension</apiName><shortdesc>
	 Расширение имени файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Если ссылка не инициализирована.
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Расширение имени файла.
	 
	 <p>Расширение файла – это часть имени после последней точки («.»), не включая ее. Если в имени файла нет точки, то расширение имеет значение <codeph>null</codeph>.</p>
	 
	 <p><i>Примечание.</i> Для определения типа файла следует использовать свойство <codeph>extension</codeph>, а не <codeph>creator</codeph> или <codeph>type</codeph>. Свойства <codeph>creator</codeph> и <codeph>type</codeph> в данном случае несущественны. Они применяются к устаревшим версиям Mac OS.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileReference:modificationDate:get"><apiName>modificationDate</apiName><shortdesc>
   Дата последнего изменения файла на локальном диске.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>modificationDate, FileReference.modificationDate
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Date</apiValueClassifier><apiException><apiDesc>При неудачном вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> создается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем. В этом случае значение свойства <codeph>modificationDate</codeph> равно <codeph>null</codeph>.
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если информация файла недоступна, создается исключение с сообщением, регистрирующим ошибку ввода-вывода файла.
   
   </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Определяет дату изменения файла в виде объекта Date.
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   Дата последнего изменения файла на локальном диске. Если объект FileReference не был заполнен, вызов с целью получения значения данного свойства возвращает значение <codeph>null</codeph>.
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:name:get"><apiName>name</apiName><shortdesc>
   Имя файла на локальном диске.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
   </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>При неудачном вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> создается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем.
   
   </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Получает имя файла в виде строковой переменной (типа String).
   </apiTipText></apiTipTexts></apiValueDef><apiDesc>
   Имя файла на локальном диске. Если объект FileReference не был заполнен (путем допустимого вызова <codeph>FileReference.download()</codeph> или <codeph> FileReference.browse()</codeph>), то при запросе значения данного свойства проигрыватель Flash Player выдает ошибку.
   <p>Все свойства объекта FileReference заполняются путем вызова метода <codeph>browse()</codeph>. В отличие от других свойств FileReference, при вызове метода <codeph>download()</codeph> свойство <codeph>name</codeph> заполняется после отправления события <codeph>select</codeph>.</p>
   
   </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:size:get"><apiName>size</apiName><shortdesc>
  Размер файла на локальном диске в байтах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>
  </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>При неудачном вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> создается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>Если файл не открывается или не считывается или если подобная ошибка возникает при обращении к файлу, в системе создается исключение с сообщением, указывающим на ошибку ввода-вывода файла.
  
  </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Размер файла в байтах.
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Размер файла на локальном диске в байтах. <ph platform="actionscript">Если <codeph>size</codeph> имеет значение 0, выдается исключение.</ph>
  
  <p platform="actionscript"><i>Примечание.</i> В исходной версии ActionScript 3.0 свойство <codeph>size</codeph> было определено как объект uint, поддерживавший файлы размером до 4 Гб. Сейчас он реализуется как объект Number для поддержки более крупных файлов. </p>
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/browse()"><linktext>FileReference.browse()</linktext></link></related-links></apiValue><apiValue id="flash.net:FileReference:type:get"><apiName>type</apiName><shortdesc>
  Тип файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>type, FileReference.type
  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>При неудачном вызове метода <codeph>FileReference.browse()</codeph>, <codeph>FileReferenceList.browse()</codeph> или <codeph>FileReference.download()</codeph> создается исключение, сопровождаемое сообщением о том, что функции были вызваны в неправильном порядке или предыдущий вызов закончился сбоем. В этом случае значение свойства <codeph>type</codeph> равно <codeph>null</codeph>.
  
  </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Определяет тип файла или расширение.
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  Тип файла. 
  
  <p>В операционной системе Windows или Linux это свойство указывает расширение файла. В Macintosh это свойство представляет собой четырехзначный тип файла, используемый только в версиях Mac OS, предшествующих Mac OS X. Если объект FileReference не был заполнен, вызов с целью получения значения данного свойства возвращает значение <codeph>null</codeph>.</p>
    
	<p>Для Windows, Linux и Mac OS X расширение файла (то есть, часть свойства <codeph>name</codeph> после последней точки (.)), определяет тип файла.</p>
	
  
  </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#FileReference/extension"><linktext>FileReference.extension</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObjectFlushStatus"><apiName>SharedObjectFlushStatus</apiName><shortdesc>
 Класс SharedObjectFlushStatus передает значения для кода, возвращаемого в результате вызова метода SharedObject.flush().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SharedObjectFlushStatus передает значения для кода, возвращаемого в результате вызова метода <codeph>SharedObject.flush()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links><apiValue id="flash.net:SharedObjectFlushStatus:FLUSHED"><apiName>FLUSHED</apiName><shortdesc>
 Указывает на успешное завершение сброса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>flushed</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Указывает на успешное завершение сброса.
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObjectFlushStatus:PENDING"><apiName>PENDING</apiName><shortdesc>
 Указывает, что перед сбросом пользователю выдается запрос на увеличение дискового пространства для общего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pending</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 Указывает, что перед сбросом пользователю выдается запрос на увеличение дискового пространства для общего объекта.
 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>SharedObject.flush()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:URLRequest"><apiName>URLRequest</apiName><shortdesc>
  Класс URLRequest фиксирует все сведения в одном запросе HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The above include is not a mistake, but rather code re-use.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  Класс URLRequest фиксирует все сведения в одном запросе HTTP. Объекты URLRequest передаются методам <codeph>load()</codeph> классов Loader, URLStream и URLLoader, а также другим операциям загрузки для инициации загрузок URL. Кроме того, они передаются методам <codeph>upload()</codeph> и <codeph>download()</codeph> класса FileReference.
 
  <p platform="actionscript">SWF-файл в изолированной программной среде, локальной для файловой системы, может не поддерживать загрузку и передачу данных для ресурса, находящегося в сетевой изолированной программной среде. </p>
 
  <p>По умолчанию вызывающий <ph platform="actionscript">SWF-</ph>файл и загружаемый URL-адрес должны находиться в одном домене. Например, <ph platform="actionscript">SWF-файл</ph> на www.adobe.com может загружать данные только из источников, которые также размещены на сайте www.adobe.com. <ph platform="actionscript">Чтобы загрузить данные с другого домена, разместите файл политик для URL на сервере, где расположены эти данные.</ph></p>
 
  <p> Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности приложения (содержимое, установленное с приложением AIR). В Adobe AIR файлы, находящиеся в изолированной программной среде приложения могут обращаться к URL-адресам с использованием любой из следующих схем URL:</p>

  <p platform="javascript"> Файлы, находящиеся в изолированной программной среде приложения, то есть установленные вместе с приложением AIR, могут обращаться к URL-адресам с использованием любой из следующих схем URL:</p>
 
 <ul>
 
  <li><codeph>http</codeph> и <codeph>https</codeph> </li>
 
  <li><codeph>файл</codeph> </li>
 
  <li><codeph>app-storage</codeph> </li>
 
  <li><codeph>app</codeph> </li>
 
 </ul>
 
  <p>К содержимому <ph platform="actionscript">в Adobe AIR</ph>, то есть за пределами изолированной программной среды безопасности приложения, применяются те же ограничения, что и к содержимому в обозревателе <ph platform="actionscript">(в Flash Player)</ph>, и загрузка управляется доменом содержимого<ph platform="actionscript"> и всем правами доступа, предоставленными в файлах политик для URL</ph>.</p>
 
 <p>Дополнительные сведения о безопасности см. в следующих источниках.</p>
 
 <ul>
 
 <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел «Understanding AIR Security» (Сведения о безопасности AIR) главы «Getting started with Adobe AIR» (Начало работы с Adobe AIR) книги <i>Developing AIR Applications</i> (Разработка приложений AIR).</li>
 
  <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 </ul>
 
 </apiDesc><example conref="examples\URLRequestExample.as"> В следующем примере создается новый объект Loader, которому затем передается объект URLRequest, содержащий путь к XML-файлу. При успешном выполнении операции загрузки отправляется событие <codeph>complete</codeph>, а данные в XML-файле переходят в выходные данные. Дополнительные обработчики событий регистрируют другие события, включая события ошибки.
 <p>Чтобы запустить данный пример, поместите файл XMLFile.xml в тот каталог, где находится рассматриваемый SWF-файл.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLRequestExample extends Sprite {

        public function URLRequestExample() {
            var loader:URLLoader = new URLLoader();
            configureListeners(loader);

            var request:URLRequest = new URLRequest("XMLFile.xml");
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Unable to load requested document.");
            }
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            trace("completeHandler: " + loader.data);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#FileReference"><linktext>FileReference</linktext></link><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link><link href="flash.net.xml#URLRequestDefaults"><linktext>URLRequestDefaults</linktext></link><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLStream"><linktext>URLStream</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>Класс HTMLLoader</linktext></link></related-links><apiConstructor id="flash.net:URLRequest:URLRequest"><apiName>URLRequest</apiName><shortdesc>
     Создает объект URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>URL-адрес, к которому будет выполнен запрос. Установить URL-адрес можно позже, используя свойство <codeph>url</codeph>.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает объект URLRequest. Если параметр <codeph>System.useCodePage</codeph> имеет значение <codeph>true</codeph>, запрос кодируется с помощью не Unicode, а системной кодовой страницы. Если параметр <codeph>System.useCodePage</codeph> имеет значение <codeph>false</codeph>, запрос кодируется не с использованием системной кодовой страницы, а с помощью Unicode.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.system.xml#System/useCodePage"><linktext>flash.system.System.useCodePage</linktext></link></related-links></apiConstructor><apiValue id="flash.net:URLRequest:authenticate:get"><apiName>authenticate</apiName><shortdesc>
	Указывает, должны обрабатываться запросы с аутентификацией (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Указывает, должны обрабатываться запросы с аутентификацией (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Если задано значение <codeph>false</codeph>, при выполнении заданий аутентификации возвращается ошибка HTTP.  
	
	<p>Поддерживаются следующие методы аутентификации:</p>
    
	<ul>
	
		<li>Windows–HTTP Basic/Digest, встроенная аутентификация Windows (включая NTLM и Kerberos), аутентификация с использованием сертификатов SSL;</li>
    
		<li>Mac–HTTP Basic/Digest, NTLM, аутентификация с использованием сертификатов SSL.</li>
	
	</ul>
	
	<p><b>Примечание. </b>Методы <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> и <codeph>HTMLLoader.load()</codeph> не поддерживают свойство <codeph>URLRequest.authenticate</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/authenticate"><linktext>flash.net.URLRequestDefaults.authenticate</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:cacheResponse:get"><apiName>cacheResponse</apiName><shortdesc>
	Указывает, должны ли сохраняться в кэше данные успешного ответа на этот запрос.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Указывает, должны ли сохраняться в кэше данные успешного ответа на этот запрос. При значении <codeph>true</codeph> приложение AIR использует кэш HTTP операционной системы.
	
	<p><b>Примечание</b>. Метод <codeph>HTMLLoader.load()</codeph> не поддерживает свойство <codeph>URLRequest.cacheResponse</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/cacheResponse"><linktext>flash.net.URLRequestDefaults.cacheResponse</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:contentType:get"><apiName>contentType</apiName><shortdesc>
     MIME-тип содержимого в свойстве data.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     MIME-тип содержимого в свойстве <codeph>data</codeph>.
     
     <p>Значение по умолчанию: <codeph>application/x-www-form-urlencoded</codeph>.</p>
     
     <p><b>Примечание. </b>Методы <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> и <codeph>HTMLLoader.load()</codeph> не поддерживают свойство <codeph>URLRequest.contentType</codeph>.</p>
     
     <p>При отправке запроса POST значения свойств <codeph>contentType</codeph> и <codeph>data</codeph> должны быть надлежащим образом согласованы. Значение свойства <codeph>contentType</codeph> указывает серверам, как интерпретировать значение свойства <codeph>data</codeph>. </p>
     
     <ul> 
     <li>Если значением свойства <codeph>data</codeph> является объект URLVariables, значением <codeph>contentType</codeph> должно быть <codeph>application/x-www-form-urlencoded</codeph>. </li>
     
     <li> Если свойство <codeph>data</codeph> имеет значение любого другого типа, значение <codeph>contentType</codeph> должно указывать тип отправляемых данных POST (двоичные или строковые данные, содержащиеся в значении свойства <codeph>data</codeph>). </li>
     
     <li>Для метода <codeph>FileReference.upload()</codeph> тип содержимого запроса автоматически получает значение <codeph>multipart/form-data</codeph>, при этом значение свойства <codeph>contentType</codeph> игнорируется.</li>
     </ul>
     
     <p> В приложении Flash Player 10 и более поздней версии при использовании типа содержимого multipart (например, multipart/form-data), в котором содержится загрузка (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для загрузок:</p>
	 <ul>
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p>Кроме того, все объекты multipart Content-Type должны иметь допустимый синтаксис (в соответствии со стандартами RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для загрузок.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/data"><linktext>data</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:data:get"><apiName>data</apiName><shortdesc>
     Объект, содержащий данные, которые должны быть переданы с запросом URL-адреса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Объект, содержащий данные, которые должны быть переданы с запросом URL-адреса. 
     
     <p>Данное свойство используется вместе со свойством <codeph>method</codeph>. Когда <codeph>method</codeph> имеет значение <codeph>GET</codeph>, значение <codeph>data</codeph> добавляется к значению <codeph>URLRequest.url</codeph> с использованием синтаксиса строки запроса HTTP. Когда <codeph>method</codeph> имеет значение <codeph>POST</codeph> (или любое другое, кроме <codeph>GET</codeph>), значение <codeph>data</codeph> передается в теле запроса HTTP.</p>
     
     <p>API-интерфейс URLRequest поддерживает двоичный <codeph>POST</codeph> и переменные в кодировке URL-адреса, а также строки. Объект данных может быть следующего типа: ByteArray, URLVariables или String.</p>
     
     <p>Способ применения данных зависит от типа используемого объекта:</p>
     
     <ul>
     
         <li>Если объект относится к типу ByteArray, то двоичные данные этого объекта используются в качестве данных <codeph>POST</codeph>. Данные типа ByteArray не поддерживаются для метода <codeph>GET</codeph>. Вдобавок, данные ByteArray не поддерживаются для <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph>.</li>
     
         <li>Если используется объект URLVariables и метод <codeph>POST</codeph>, переменные кодируются с помощью формата <i>x-www-form-urlencoded</i>. Полученная в результате строка используется как данные <codeph>POST</codeph>. Исключением является вызов метода <codeph>FileReference.upload()</codeph>, в котором переменные отправляются как отдельные поля в формате <codeph>multipart/form-data</codeph>.</li>
     
      <li>При использовании объекта URLVariables и метода <codeph>GET</codeph> данный объект URLVariables определяет переменные, которые должны быть отправлены с объектом URLRequest.</li>
     
         <li>В противном случае, объект преобразуется в строку, которая используется в качестве данных <codeph>POST</codeph> или <codeph>GET</codeph>.</li>
     
     </ul>
     
     <p>Эти данные не отправляются до тех пор, пока метод (например, <codeph>navigateToURL()</codeph> или <codeph>FileReference.upload()</codeph>) не будет использовать объект URLRequest.</p>
     
     <p><b>Примечание.</b> Значение <codeph>contentType</codeph> должно соответствовать типу данных в свойстве <codeph>data</codeph>. См. примечание в описании свойства <codeph>contentType</codeph>.</p>
     
     </apiDesc><example conref="examples\URLVariablesExample.as"> В следующем примере удаленное приложение, размещенное по адресу http://www. [yourDomain].com/application.jsp, открывается в новом окне обозревателя и передает приложению данные о сеансе пользователя, извлеченные из объекта URLVariables. 
  
 <p>Основные моменты данного примера представлены ниже:</p>
 <ol>
    <li>Функция конструктора создает экземпляр URLRequest под именем <codeph>request</codeph>, принимая в качестве параметра URL-адрес удаленного приложения.</li>
    <li>Создается объект URLVariables, двум свойствам которого присваиваются значения.</li>
    <li>Объект URLVariables присваивается свойству <codeph>data</codeph> объекта URLRequest.</li>
    <li>В примере вызывается <codeph>navigateToURL</codeph>, открывающий новое окно обозревателя с URL-адресом удаленного приложения.</li>
 </ol>
 <p> <b>Примечание.</b> Чтобы запустить данный пример, необходимо заменить в примере URL-адрес удаленного приложения на любой действующий URL-адрес. Вдобавок, необходимо, чтобы код сервера обработал информацию, захваченную проигрывателем Flash Player в объекте URLVariables.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLVariables;

    public class URLVariablesExample extends Sprite {

        public function URLVariablesExample() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequest/method"><linktext>URLRequest.method</linktext></link><link href="flash.net.xml#URLRequestMethod"><linktext>URLRequestMethod</linktext></link><link href="flash.net.xml#URLVariables"><linktext>URLVariables</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.net.xml#URLRequest/contentType"><linktext>contentType</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:digest:set"><apiName>digest</apiName><shortdesc>
     Строка, уникальным образом идентифицирующая подписанный компонент платформы Adobe, который должен быть сохранен (или извлечен) в кэш-памяти проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Предоставленный дайджест не совпадает с дайджестом файла, извлеченным из загруженного файла с подписью или из файла с подписью, загруженного из кэш-памяти. Приложение также создает данную ошибку, если предоставленный дайджест имеет неправильную длину или содержит недопустимые (не шестнадцатеричные) символы.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Строка, уникальным образом идентифицирующая подписанный компонент платформы Adobe, который должен быть сохранен (или извлечен) в кэш-памяти проигрывателя Flash Player. <ph platform="actionscript"> Компонент платформы Adobe является подписанным файлом (SWZ-файл) с содержимым SWF, непрерывно кэшированным на компьютере пользователя. Все SWZ-файлы подписаны компанией Adobe. Дайджест соответствует одному кэшированному файлу. При внесении любых изменений в файл его дайджест изменится непредсказуемым образом. С помощью дайджеста можно проверять кэшированный файл по нескольким доменам. Если у двух файлов одинаковый дайджест, это один и тот же файл. Если же у двух файлов разные дайджесты, значит, это не один и тот же файл. Практически невозможно создать файл с фальшивым дайджестом, и выдать его за другой. </ph><ph platform="javascript">Это свойство применяется только к SWF-содержимому и не применяется к коду JavaScript, выполняемому в AIR.</ph>
     
     <p platform="actionscript">Дайджест основан на алгоритме дайджеста сообщения SHA-256 (с длиной 64 в шестнадцатеричном формате).</p>
     
     <p platform="actionscript">Например, компонент Flex SDK включает SWZ-файл для среды Flex (и предоставляет строку дайджеста для этого SWZ-файла). Можно опубликовать этот SWZ-файл на web-сервере и загрузить его в SWF-файл (с использованием метода <codeph>load()</codeph> объекта URLLoader). Если на компьютере конечного пользователя уже существует соответствующий кэшированный SWZ-файл, в приложении используется кэшированный SWZ-файл. (SWZ-файл соответствует, если его свойство <codeph>digest</codeph> соответствует свойству digest, указанному пользователем.) В противном случае в приложении выполняется загрузка SWZ-файла с использованием указанного URL-адреса. </p>
     
     <p platform="actionscript">Параметр <codeph>digest</codeph> необходимо задать только в объекте URLRequest, используемом в обращении к методу <codeph>URLLoader.load()</codeph> для загрузки SWZ-файла. Если свойство <codeph>digest</codeph> объекта URLRequest задается при использовании объекта в другом методе, в приложении создается исключение IOError.</p>
     
     </apiDesc><example conref="examples\URLRequest_digest.as"> В следующем примере удаленный файл загружается в кэш-память. В конце загрузки массив байт содержит действительный файл (а не подписанный). В этом примере операция загрузки завершается путем вызова метода <codeph>loadBytes()</codeph>:
<codeblock>
 
var myURLReq:URLRequest = new URLRequest();
myURLReq.url = "http://yourdomain/users/jdoe/test01/_rsc/Automated/AssetCaching_rsc/test01/rsl.swz";
myURLReq.digest = "3B0AA28C7A990385E044D80F5637FB036317BB41E044D80F5637FB036317BB41";
var myURLLoader:URLLoader = new URLLoader();
myURLLoader.dataFormat = URLLoaderDataFormat.BINARY;
myURLLoader.addEventListener("complete", onC);

myURLLoad.load(myURLReq);

function onC(e) {
    var someLoader:Loader = new Loader();
    addChild(someLoader);
    someLoader.loadBytes((ByteArray)(myURLLoad.data)); 
}

</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:followRedirects:get"><apiName>followRedirects</apiName><shortdesc>
	Задает, следует выполнять перенаправления (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Задает, следует выполнять перенаправления (<codeph>true</codeph>) или нет (<codeph>false</codeph>). 
	
	<p><b>Примечание. </b>Методы <codeph>FileReference.upload()</codeph>, <codeph>FileReference.download()</codeph> и <codeph>HTMLLoader.load()</codeph> не поддерживают свойство <codeph>URLRequest.followRedirects</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/followRedirects"><linktext>URLRequestDefaults.followRedirects</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:manageCookies:get"><apiName>manageCookies</apiName><shortdesc>
	Определяет, должен ли стек протокола НТТР управлять файлами cookie для данного запроса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true 
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Определяет, должен ли стек протокола НТТР управлять файлами cookie для данного запроса. При значении <codeph>true</codeph> файлы cookie добавляются в запрос и cookie ответа запоминаются. При значении <codeph>false</codeph> файлы cookie <i>не</i> добавляются в запрос и cookie ответа <i>не</i> запоминаются, однако пользователи могут самостоятельно управлять cookie путем непосредственных манипуляций с заголовком. 
	
	<p>В системе Mac OS файлы cookie используются совместно с Safari. Чтобы удалить файлы cookie в Mac OS, выполните следующие действия.</p>
	
	<ol>
		<li>Откройте Safari.</li>
      <li>Выберите Safari > Preferences и выберите панель Security.</li>
      <li>Нажмите кнопку Show Cookies.</li>
		<li>Нажмите кнопку Remove All.</li>
	</ol>
	
	<p>Чтобы удалить файлы cookie в Windows, выполните следующие действия.</p>
	
	<ol>
		<li>Откройте панель управления «Свойства браузера» и перейдите на вкладку «Общие».</li>
		<li>Нажмите кнопку «Удалить Cookie». </li>
	</ol>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/manageCookies"><linktext>flash.net.URLRequestDefaults.manageCookies</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:method:get"><apiName>method</apiName><shortdesc>
     Управляет методом отправки форм НТТР.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Если параметр <codeph>value</codeph> не имеет значение <codeph>URLRequestMethod.GET</codeph> или <codeph>URLRequestMethod.POST</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>URLRequestMethod.GET
     
     </apiDefaultValue></apiValueDef><apiDesc>
     Управляет методом отправки форм НТТР. 
     
     <p><ph platform="actionscript">Для SWF-содержимого, выполняемого в Flash Player (в обозревателе), это свойство ограничено операциями GET и POST, поэтому действительными являются значения <codeph>URLRequestMethod.GET</codeph> и <codeph>URLRequestMethod.POST</codeph>.</ph></p>
     
     <p><ph platform="actionscript">Для содержимого, выполняемого в Adobe AIR,</ph> <ph platform="javascript">можно </ph>использовать любое строковое значение, если содержимое находится в изолированной программной среде приложения. В противном случае, <ph platform="actionscript">как и для содержимого, выполняемого в приложении Flash Player,</ph> применяется ограничение на использование операции GET или POST<ph platform="javascript"> и допустимыми значениями являются <codeph>URLRequestMethod.GET</codeph> или <codeph>URLRequestMethod.POST</codeph></ph>.</p>
     
     <p><ph platform="actionscript">В случае с содержимым, выполняемым в Adobe AIR при </ph><ph platform="javascript">. При </ph> использовании функции <codeph>navigateToURL()</codeph> средой выполнения обрабатывается URLRequest, использующий метод POST (свойство <codeph>method</codeph> которого имеет значение <codeph>URLRequestMethod.POST</codeph>), как при использовании метода GET.</p>
     
     <p><ph platform="actionscript"><b>Примечание.</b> Если в Flash Player указанная форма не имеет содержимого, проигрыватель автоматически использует операцию GET, даже если для метода установлено значение <codeph>URLRequestMethod.POST</codeph>. По этой причине рекомендуется всегда вставлять фиктивное содержимое, тем самым обеспечивая применение нужного метода.</ph></p>
     
     </apiDesc><example conref="examples\URLRequest_method.as"> В следующем примере удаленное приложение, размещенное по адресу http://www. [yourDomain].com/application.jsp, открывается в новом окне обозревателя и передает приложению данные о сеансе пользователя, извлеченные из объекта URLVariables. Оно четко устанавливает для свойства <codeph>URLRequest.method</codeph> значение <codeph>URLRequestMethod.POST</codeph>.
 <p>Основные моменты данного примера представлены ниже:</p>
 <ol>
    <li>Функция конструктора создает экземпляр URLRequest под именем <codeph>request</codeph>, принимая в качестве параметра URL-адрес удаленного приложения.</li>
    <li>Создается объект URLVariables, двум свойствам которого присваиваются значения.</li>
    <li>Объект URLVariables присваивается свойству <codeph>data</codeph> объекта URLRequest.</li>
  <li>Для свойства <codeph>URLRequest.method</codeph> установлено значение <codeph>URLRequestMethod.POST</codeph>.</li>
    <li>В примере вызывается <codeph>navigateToURL</codeph>, открывающий новое окно обозревателя с URL-адресом удаленного приложения.</li>
 </ol>
 <p> <b>Примечание.</b> Чтобы запустить данный пример, необходимо заменить в примере URL-адрес удаленного приложения на любой действующий URL-адрес. Вдобавок, необходимо, чтобы код сервера обработал информацию, захваченную проигрывателем Flash Player в объекте URLVariables.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    import flash.net.URLRequestMethod;
    import flash.net.URLVariables;

    public class URLRequest_method extends Sprite {

        public function URLRequest_method() {
            var url:String = "http://www.[yourDomain].com/application.jsp";
            var request:URLRequest = new URLRequest(url);
            
            var variables:URLVariables = new URLVariables();
            variables.exampleSessionId = new Date().getTime();
            variables.exampleUserLabel = "guest";
            request.data = variables;
            request.method = URLRequestMethod.POST;
            
            navigateToURL(request);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.net.xml#URLRequestMethod"><linktext>Класс URLRequestMethod</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:requestHeaders:get"><apiName>requestHeaders</apiName><shortdesc>
     Массив заголовков запроса HTTP, который должен быть добавлен к запросу HTTP.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     Массив заголовков запроса HTTP, который должен быть добавлен к запросу HTTP. Массив состоит из объектов URLRequestHeader. Каждый объект в массиве должен быть объектом URLRequestHeader, содержащим строку имени и строку значения, как показано ниже: 
     <codeblock>
     var rhArray:Array = new Array(new URLRequestHeader("Content-Type", "text/html"));
     </codeblock>
     
     <p><ph platform="actionscript">Среда выполнения Flash Player и AIR накладывают</ph> <ph platform="javascript">Среда выполнения AIR накладывает</ph> определенные ограничения на заголовки запросов. Дополнительные сведения см. в описании класса URLRequestHeader.</p>
     
     <p>Не все методы, принимающие параметры URLRequest, поддерживают свойство <codeph>requestHeaders</codeph>. Дополнительные сведения см. в описании вызываемого метода. Например, методы <codeph>FileReference.upload()</codeph> и <codeph>FileReference.download()</codeph> не поддерживают свойство <codeph>URLRequest.requestHeaders</codeph>.</p>
     <p>Вследствие ограниченных возможностей обозревателей, пользовательские заголовки запросов НТТР поддерживаются только для запросов <codeph>POST</codeph>, а для <codeph>GET</codeph> не поддерживается.</p> 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestHeader"><linktext>URLRequestHeader</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:url:get"><apiName>url</apiName><shortdesc>
     URL-адрес, к которому будет выполнен запрос.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     URL-адрес, к которому будет выполнен запрос. 
     
     <p>Обязательно закодируйте все символы, которые описаны как небезопасные в спецификации URL (см. http://www.faqs.org/rfcs/rfc1738.html) или зарезервированы в схеме URL объекта URLRequest (когда они не используются с указанной целью). Например, используйте <codeph>%25</codeph> для символа процентов (%) и <codeph>%23</codeph> для знака (#), как в <codeph>http://www.example.com/orderForm.cfm?item=%23B-3&amp;discount=50%25</codeph>.</p>
     
      <p>По умолчанию URL-адрес должен находиться в том же домене, что и вызывающий файл, если содержимое не выполняется в изолированной программной среде безопасности приложения <ph platform="actionscript">Adobe AIR</ph>. <ph platform="actionscript">Если требуется загрузить данные из другого домена, на сервере, на котором находятся данные, необходимо поместить файл политик для URL-адресов</ph>. Подробные сведения см. в описании класса URLRequest.</p>
     
     <p><ph platform="actionscript">Для содержимого, выполняемого в Adobe AIR</ph>, <ph platform="javascript">файлы</ph>, находящиеся в изолированной программной среде приложения, то есть установленные вместе с приложением AIR, могут обращаться к URL-адресам с использованием любой из следующих схем URL-адреса:</p>
     
     <ul>
     
      <li><codeph>http</codeph> и <codeph>https</codeph> </li>
     
      <li><codeph>файл</codeph> </li>
     
      <li><codeph>app-storage</codeph> </li>
     
      <li><codeph>app</codeph> </li>
     
     </ul>
     
     <p><b>Примечание.</b> IPv6 (интернет-протокол версии 6) поддерживается<ph platform="actionscript"> в AIR и Flash Player 9.0.115.0 и более поздних версиях</ph>. IPv6 – это версия Интернет-протокола, поддерживающего 128-разрядные адреса (усовершенствование протокола IPv4, поддерживающего только 32-разрядные адреса). Вам может потребоваться активировать IPv6 на используемых интерфейсах сетевых соединений. Более подробные сведения представлены в справочных документах операционной системы, в которой размещены ваши данные. <ph platform="actionscript">Если система хостинга поддерживает IPv6, можно указать цифровые адреса IPv6 в URL-адресах, заключенные в квадратные скобки ([ ]), как показано ниже</ph>. </p>
     
     <ph platform="actionscript">
     <pre>
     rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]:1935/test
     </pre>
     </ph>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLRequest:useCache:get"><apiName>useCache</apiName><shortdesc>
	Указывает, необходимо ли обращаться в локальный кэш перед получением данных этим запросом URLRequest.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiDefaultValue>true
	
	</apiDefaultValue></apiValueDef><apiDesc>
	Указывает, необходимо ли обращаться в локальный кэш перед получением данных этим запросом URLRequest. 
	
	<p><b>Примечание</b>. Метод <codeph>HTMLLoader.load()</codeph> не поддерживает свойство <codeph>URLRequest.useCache</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/useCache"><linktext>flash.net.URLRequestDefaults.useCache</linktext></link></related-links></apiValue><apiValue id="flash.net:URLRequest:userAgent:get"><apiName>userAgent</apiName><shortdesc>
	Задает строку user-agent для запроса НТТР.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Вызывающий абонент не находится в изолированной программной среде AIR.
	
	</apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	Задает строку user-agent для запроса НТТР. 
	
	<p platform="actionscript">Значением по умолчанию является та же строка user-agent, которая используется Flash Player (она отличается для Mac, Linux и Windows).</p>
	
	<p><i>Примечание.</i> Это свойство не затрагивает строку user-agent, когда объект URLRequest используется с методом <codeph>load()</codeph> объекта HTMLLoader. Чтобы задать строку user-agent для объекта HTMLLoader, настройте свойство <codeph>userAgent</codeph> объекта HTMLLoader или статическое свойство <codeph>URLRequestDefaults.userAgent</codeph>.</p>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLRequestDefaults/userAgent"><linktext>flash.net.URLRequestDefaults.userAgent</linktext></link><link href="../../flash/html/HTMLLoader.html#userAgent"><linktext>flash.html.HTMLLoader.userAgent</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:FileFilter"><apiName>FileFilter</apiName><shortdesc>
 Класс FileFilter используется для указания на то, какие файлы системы пользователя отображаются в диалоговом окне обзора файлов, которое открывается при вызове метода FileReference.browse(), метода FileReferenceList.browse() или метода browse объекта File, FileReference или FileReferenceList.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс FileFilter используется для указания на то, какие файлы системы пользователя отображаются в диалоговом окне обзора файлов, которое открывается при вызове метода <codeph>FileReference.browse()</codeph>, метода <codeph>FileReferenceList.browse()</codeph> или метода browse объекта File, FileReference или FileReferenceList. Экземпляры FileFilter в качестве значений дополнительного параметра <codeph>typeFilter</codeph> этого метода. При использовании экземпляра FileFilter расширения и типы файлов, которые не указаны в экземпляре FileFilter, отфильтровываются. Другими словами, они недоступны для выбора пользователем. Если методу не передается какой-либо объект FileFilter, все файлы отображаются в диалоговом окне.
 
 <p>Экземпляры FileFilter можно использовать одним из двух следующих способов:</p>
 
 <ul>
 
   <li>Описание, в котором приводятся только расширения файлов</li>
 
   <li>Описание с расширениями файлов и типами файлов Macintosh</li>
 
 </ul>
 
 <p>Эти два формата не являются взаимозаменяемыми в одном вызове метода browse. Следует выбрать только один из них.</p>
 
 <p>Можно передать один или несколько экземпляров FileFilter методу browse, как показано ниже:</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFileReference:FileReference = new FileReference();
 myFileReference.browse([imagesFilter, docFilter]);
 </codeblock>
 
 <p platform="actionscript">Или в приложении AIR:</p>
 
 <codeblock platform="actionscript">
 var imagesFilter:FileFilter = new FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter:FileFilter = new FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile:File = new File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <codeblock platform="javascript">
 var imagesFilter = new air.FileFilter("Images", "~~.jpg;~~.gif;~~.png");
 var docFilter = new air.FileFilter("Documents", "~~.pdf;~~.doc;~~.txt");
 var myFile = new air.File();
 myFile.browseForOpen("Open", [imagesFilter, docFilter]);
 </codeblock>
 
 <p>Список расширений в свойстве <codeph>FileFilter.extension</codeph> используется для фильтрации файлов, отображаемых в диалоговом окне обзора файлов. На самом деле этот список не отображается в диалоговом окне. Чтобы отобразить типы файлов для пользователей, вам необходимо перечислить типы файлов в строке описания, а также в списке расширений. В операционной системе Windows и Linux строка описания отображается в диалоговом окне. (Не используется в платформе Macintosh<sup>®</sup>.) На компьютерах Macintosh для фильтрации файлов используется сам предоставленный список типов файлов Macintosh. В противном случае используется список расширений файлов. </p> 
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:FileFilter:FileFilter"><apiName>FileFilter</apiName><shortdesc>
	 Создает новый экземпляр FileFilter.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>description</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка описания, отображаемая для пользователей, выбирающих файлы для загрузки.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>extension</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Список расширений файлов, указывающий, какие форматы файлов отображаются для пользователей при выборе файлов для загрузки.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>macType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Список типов файлов Macintosh, указывающий, какие типы файлов видны пользователям при выборе файлов для загрузки. Если ни одно значение не передается, данный параметр получает значение <codeph>null</codeph>.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый экземпляр FileFilter.
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.net:FileFilter:description:get"><apiName>description</apiName><shortdesc>
	 Строка описания для фильтра.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка описания для фильтра. Описание представлено пользователю в диалоговом окне, которое открывается при вызове <codeph>FileReference.browse()</codeph> или <codeph>FileReferenceList.browse()</codeph>. Строка описания содержит строку, например <codeph>Images (~~.gif, ~~.jpg, ~~.png)</codeph>, которая позволяет проинформировать пользователя о том, какие типы файлов могут быть загружены. Обратите внимание на то, что фактические типы файлов, поддерживаемые данным объектом FileReference, хранятся в свойстве <codeph>extension</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:extension:get"><apiName>extension</apiName><shortdesc>
	 Список расширений файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Список расширений файлов. Данный список содержит типы файлов, которые будут отображаться в диалоговом окне выбора файлов. (Пользователь видит не сам список, а только значение свойства <codeph>description</codeph>.) Свойство <codeph>extension</codeph> содержит список расширений файлов, где в качестве разделителя значений используется точка с запятой. Перед каждым расширением добавляется подстановочный знак (~~), как показано в следующей строке: <codeph>"~~.jpg;~~.gif;~~.png"</codeph>.
	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:FileFilter:macType:get"><apiName>macType</apiName><shortdesc>
	 Список типов файлов Macintosh.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Список типов файлов Macintosh. Данный список содержит типы файлов, которые будут отображаться в диалоговом окне выбора файлов. (Пользователь видит не сам список, а только значение свойства <codeph>description</codeph>.) Свойство <codeph>macType</codeph> содержит список типов файлов Macintosh, где в качестве разделителя используется точка с запятой, как показано в следующей строке: <codeph>"JPEG;jp2_;GIFF"</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStream"><apiName>NetStream</apiName><shortdesc>
 Класс NetStream устанавливает одностороннее потоковое подключение между приложением AIR или Flash Player и сервером Flash Media Server или между приложением AIR или Flash Player и локальной файловой системой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс NetStream устанавливает одностороннее потоковое подключение между приложением AIR <ph platform="actionscript">или Flash Player</ph> и сервером Flash Media Server или между приложением AIR <ph platform="actionscript">или Flash Player</ph> и локальной файловой системой. Объект NetStream является каналом в рамках объекта NetConnection. Данный канал может опубликовать поток с помощью метода <codeph>NetStream.publish()</codeph> или подписаться на опубликованный поток и получать данные с помощью метода <codeph>NetStream.play()</codeph>. Вы можете публиковать или воспроизводить данные в режиме реального времени или предварительно записанные данные. Также можно вызвать метод <codeph>NetStream.send()</codeph> для отправки текстовых сообщений всем подписанным клиентам.
 
 <p platform="actionscript">По сравнению с внедрением видео в SWF-файл, воспроизведение внешних видеофайлов имеет ряд преимуществ, таких как повышение производительности и оптимизация управления памятью, а также независимость частоты кадров видео- и SWF-содержимого. </p>
 
 <p>Adobe AIR и Flash Player версии 9.0.115.0 и более поздних версий поддерживают файлы, извлеченные из стандартного формата контейнера MPEG-4 (включая F4V, MP4, M4A, MOV, MP4V, 3GP и 3G2), если они содержат видео формата H.264 и/или аудио формата HEAAC v2. По сравнению со схожим профилем кодирования в Sorenson или On2, формат H.264 обеспечивает более высокое качество видеоизображения при невысоких скоростях передачи битов. HE-AAC v2 является усовершенствованным форматом AAC (стандартный аудиоформат, определенный в стандарте видео MPEG-4), в котором с помощью технологий Spectral Band Replication (SBR) и Parametric Stereo (PS) увеличивается качество кодирования на низких скоростях передачи битов. Информация о поддерживаемых кодеках и форматах файлов представлена по адресу <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> and the <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.</p>
 
 <p><b>Процедура для публикующих и воспроизводимых потоков:</b></p>
 
 <ol>
 <li>Создайте новый объект NetConnection.</li>
 <li>Для подключения к экземпляру приложения на сервере необходимо вызвать метод <codeph>NetConnection.connect()</codeph>.</li>
 <li>Создайте объект NetStream для создания потока в рамках подключения.</li>
 <li>Для записи, кодировки и публикации аудио и видео требуется вызвать методы <codeph>NetStream.attachAudio()</codeph> и <codeph>NetStream.attachCamera()</codeph>.</li>
 <li>Для присвоения уникального имени потоку и отправки данных через поток к серверу, чтобы остальные пользователи могли их получить, необходимо вызвать метод <codeph>NetStream.publish()</codeph>. В процессе публикации также можно записывать данные, которые пользователи смогут позже воспроизвести.</li>
 <li>Для воспроизведения записанного видео или потокового видео в реальном времени требуется вызвать метод <codeph>NetStream.play()</codeph>. В метод <codeph>play()</codeph> требуется передать имя строки, переданной в метод <codeph>publish()</codeph>.</li>
 </ol>
 
 <p><b>Использование ключевых кадров данных вместе с Flash Media Server.</b> После создания объектов NetConnection и NetStream можно с помощью метода <codeph>NetStream.send()</codeph> добавить метаданные в аудио- или видеосодержимое во время его прямой потоковой передачи на сервер. Метаданными может служить такая информация, как высота и ширина кадра видеосъемки, ее продолжительность, имя создателя и т.п. Чтобы определить метаданные, используйте имя специального обработчика <codeph>@setDataFrame</codeph> в качестве первого аргумента для <codeph>NetStream.send()</codeph>.</p>
 
 <p><b>Получение данных из потока с Flash Media Server или последовательно загружаемого F4V- или FLV-файла.</b> Flash Media Server и FLV-файлы могут во время потоковой передачи или воспроизведения отправлять объекты событий со сведениями о конкретных точках данных. Обрабатывать данные потока или FLV-файла во время воспроизведения можно двумя способами.</p>
 
 <ul><li>Можно связать свойство client с обработчиком события для получения объекта данных. С помощью свойства <codeph>NetStream.client</codeph> назначьте объект для вызова определенных функций обработки данных. Объект, назначенный свойству <codeph>NetStream.client</codeph> может вызвать прослушиватель для следующих точек данных: <codeph>onCuePoint()</codeph>, <codeph>onImageData()</codeph>, <codeph>onMetaData()</codeph>, <codeph>onPlayStatus()</codeph>, <codeph>onTextData()</codeph> и <codeph>onXMPData()</codeph>. Затем в этих функциях запишите процедуры для обработки объекта данных, возвращенного потоком или FLV-файлом во время воспроизведения. Дополнительные сведения см. в описании <codeph>NetStream.client</codeph>.</li>
 <li>Свяжите свойство client с подклассом класса NetStream, а затем создайте обработчик события для получения объекта данных. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li></ul>
 
 <p><b>Примечание.</b> Чтобы отправить данные через аудиофайл, например в формате MP3, используйте класс Sound для связи файла с объектом Sound. Затем используйте свойство <codeph>Sound.id3</codeph> для считывания метаданных из звукового файла.</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> В следующем примере объект Video с классами NetConnection и NetStream используется для загрузки и воспроизведения FLV-файла. Чтобы запустить данный пример, вам потребуется FLV-файл, имя и место расположения которого совпадают с переменной, переданной <codeph>videoURL</codeph>. В данном случае, FLV-файл Video.flv находится в том же каталоге, где размещается SWF-файл.
 <p>В данном примере код, создающий объекты Video и NetStream, а также вызывающий методы <codeph>Video.attachNetStream()</codeph> и <codeph>NetStream.play()</codeph>, размещен в функции обработчика. Обработчик вызывается только при успешном подключении к объекту NetConnection (другими словами, когда событие <codeph>netStatus</codeph> возвращает объект <codeph>info</codeph> со свойством <codeph>code</codeph>, что свидетельствует об успешном выполнении задачи). Рекомендуется перед вызовом <codeph>NetStream.play()</codeph> дождаться успешного подключения. </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.media.xml#Video"><linktext>flash.media.Video</linktext></link><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream_flash.events.DRMStatusEvent.DRM_STATUS_drmStatus"><apiName>drmStatus</apiName><shortdesc>
 Отправляется при начале воспроизведения содержимого, зашифрованного с помощью технологии управления цифровыми правами (DRM) (когда пользователь проходит аутентификацию и получает право на просмотр содержимого).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMStatusEvent.DRM_STATUS</apiEventType><adobeApiEventClassifier>flash.events.DRMStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при начале воспроизведения содержимого, зашифрованного с помощью технологии управления цифровыми правами (DRM) (когда пользователь проходит аутентификацию и получает право на просмотр содержимого).
 <p>
 Объект DRMStatusEvent содержит информацию, связанную с ваучером, например, может ли содержимое предоставляться в автономном режиме, или когда истекает срок действия ваучера и просмотр содержимого будет запрещен.
 </p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMStatusEvent"><linktext>flash.events.DRMStatusEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMErrorEvent.DRM_ERROR_drmError"><apiName>drmError</apiName><shortdesc>
 Отправляется, когда объект NetStream, пытающийся воспроизвести файл с DRM-шифрованием, сталкивается с ошибкой, связанной с DRM.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMErrorEvent.DRM_ERROR</apiEventType><adobeApiEventClassifier>flash.events.DRMErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда объект NetStream, пытающийся воспроизвести файл с DRM-шифрованием, сталкивается с ошибкой, связанной с DRM. Например, объект DRMErrorEvent отправляется в случае ошибки авторизации пользователя. Это может произойти потому, что пользователь не приобрел права на просмотр содержимого или поставщик содержимого не поддерживает приложение для его просмотра.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMErrorEvent"><linktext>flash.events.DRMErrorEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE_drmAuthenticate"><apiName>drmAuthenticate</apiName><shortdesc>
 Отправляется, когда объект NetStream пытается воспроизвести содержимое, зашифрованное с помощью технологии управления цифровыми правами (DRM) и требующее ввода учетных данных пользователя для проверки подлинности перед воспроизведением.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.DRMAuthenticateEvent.DRM_AUTHENTICATE</apiEventType><adobeApiEventClassifier>flash.events.DRMAuthenticateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда объект NetStream пытается воспроизвести содержимое, зашифрованное с помощью технологии управления цифровыми правами (DRM) и требующее ввода учетных данных пользователя для проверки подлинности перед воспроизведением. 
 
 <p>
 С помощью метода <codeph>setDRMAuthenticationCredentials()</codeph> объекта NetStream можно выполнить аутентификацию пользователя. При неудачной проверке подлинности пользователя приложение попытается проверить подлинность повторно и отправит новое событие DRMAuthenticateEvent для объекта NetStream.
 </p>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link><link href="flash.net.xml#NetStream/resetDRMVouchers()"><linktext>resetDRMVouchers()</linktext></link><link href="flash.net.xml#NetStream/setDRMAuthenticationCredentials()"><linktext>setDRMAuthenticationCredentials()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onDRMContentData"><apiName>onDRMContentData</apiName><shortdesc>
 Добавляет прослушиватель событий, реагирующий на извлечение приложением AIR метаданных DRM-содержимого, внедренных в мультимедийный файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Добавляет прослушиватель событий, реагирующий на извлечение приложением AIR метаданных DRM-содержимого, внедренных в мультимедийный файл.
 
 <p>Объект DRMContentData содержит информацию, необходимую для получения ваучера на воспроизведение мультимедийного файла с защитой по технологии DRM. С помощью класса DRMManager можно загрузить ваучер с данной информацией.</p>
 
 <p><codeph>onDRMContentData</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Это не событие, однако его можно найти в разделе «События», так как он реагирует на событие данных при предварительной загрузке внедренных данных из локального мультимедийного файла. Дополнительные сведения см. в описании класса NetStream. Нельзя использовать метод <codeph>addEventListener()</codeph> или любой другой метод EventDispatcher для прослушивания или обработки <codeph>onDRMContentData</codeph> в качестве события. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов:</p>
 <ul>
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
 </ul>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.xml#NetStream/preloadEmbeddedData()"><linktext>preloadEmbeddedData()</linktext></link><link href="flash.net.drm.xml#DRMManager"><linktext>flash.net.drm.DRMManager</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onPlayStatus"><apiName>onPlayStatus</apiName><shortdesc>
 Добавляет прослушиватель, который реагирует на завершение воспроизведения потока объектом NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Добавляет прослушиватель, который реагирует на завершение воспроизведения потока объектом NetStream. Связанный объект событий передает информацию в дополнение к сведениям, возвращенным событием <codeph>netStatus</codeph>. С помощью этого свойства можно запускать действия в коде, когда объект NetStream переключится с одного потока на другой поток в списке воспроизведения (на что указывает информационный объект <codeph>NetStream.Play.Switch</codeph>) или когда объект NetStream завершит воспроизведение (на что указывает информационный объект <codeph>NetStream.Play.Complete</codeph>). 
 
 <p>Объект <codeph>onPlayStaus</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Не является событием, однако его можно найти в разделе «События», так как он реагирует на событие данных при потоковой передаче мультимедийного содержимого с помощью Flash Media Server или при воспроизведении FLV-файла. Дополнительные сведения см. в описании класса NetStream. Нельзя использовать метод <codeph>addEventListener()</codeph> или любой другой метод EventDispatcher для прослушивания или обработки <codeph>onPlayStatus</codeph> в качестве события. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов.</p>
 
 <ul>
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
    
 </ul>
 
 <p>Данное событие возвращает информационный объект со следующими свойствами:</p>
 
 <adobetable class="innertable">
  
  
  
   
 <tgroup cols="3"><thead><row><entry>Свойство code</entry><entry>Свойство level</entry><entry>Значение</entry></row></thead><tbody><row>
    <entry><codeph>NetStream.Play.Switch</codeph></entry>
    <entry><codeph>status</codeph></entry>
    <entry>Подписчик переключается в списке воспроизведения с одного потока на другой.</entry>
  </row><row>
    <entry><codeph>NetStream.Play.Complete</codeph></entry>
    <entry><codeph>status</codeph></entry>
    <entry>Воспроизведение завершено.</entry>
  </row><row>
    <entry><codeph>NetStream.Play.TransitionComplete</codeph></entry>
    <entry><codeph>status</codeph></entry>
    <entry>Подписчик переключается на новый поток в результате переключения скорости передачи битов потока.</entry>
  </row></tbody></tgroup></adobetable>
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.events.xml#NetStatusEvent/NET_STATUS"><linktext>flash.events.NetStatusEvent.NET_STATUS</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onCuePoint"><apiName>onCuePoint</apiName><shortdesc>
 Добавляет прослушиватель, реагирующий на достижение встроенной ключевой точки во время воспроизведения видеофайла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Добавляет прослушиватель, реагирующий на достижение встроенной ключевой точки во время воспроизведения видеофайла. Данный прослушиватель можно использовать для запуска действий в коде, когда воспроизведение видео достигает определенной ключевой точки. Это позволяет синхронизировать другие действия в приложении с событиями воспроизведения видео. Информацию о форматах видеофайлов, поддерживаемых Flash Media Server, см. в <xref href="http://www.adobe.com/go/learn_fms_fileformats_ru" scope="external">www.adobe.com/go/learn_fms_fileformats_ru</xref>.

 
 <p><codeph>onCuePoint</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Это не событие, однако его можно найти в разделе «События», так как он реагирует на событие данных при потоковой передаче мультимедийного содержимого с помощью Flash Media Server или при воспроизведении FLV-файла. Дополнительные сведения см. в описании класса NetStream. Нельзя использовать метод <codeph>addEventListener()</codeph> или любой другой метод EventDispatcher для прослушивания или обработки <codeph>onCuePoint</codeph> в качестве события. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов:</p>
 
 <ul>
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
    
 </ul>
 
 <p>Связанный прослушиватель событий запускается после вызова метода <codeph>NetStream.play()</codeph>, но перед продвижением точки воспроизведения.</p>
 
 <p>В видеофайл можно встроить следующие типы ключевых точек:</p>
 
 <ul>
 <li>Ключевая точка навигации указывает внутри видеофайла ключевой кадр, которому соответствует свойство <codeph>time</codeph> данной точки. Ключевые точки навигации часто используются как закладки или точки входа, облегчающие пользователям перемещение по видеофайлу.</li>
 
 <li>Ключевая точка события указывается по времени независимо от того, соотносится или не соотносится данное время с определенным ключевым кадром. Ключевая точка события обычно представляет собой определенный момент видео, в котором происходит что-то, что можно использовать для вызова других событий.</li>
 </ul>
 
 <p>Объект события <codeph>onCuePoint</codeph> имеет следующие свойства:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Свойство</entry><entry>Описание</entry></row></thead><tbody><row>
   <entry><codeph>name</codeph></entry>
   <entry>Имя, присвоенное данной ключевой точке при встраивании в видеофайл.</entry></row><row>
   <entry><codeph>параметры</codeph></entry>
   <entry>Ассоциативный массив парных строк «имя-значение», определенных для данной ключевой точки. В качестве имени или значения параметра можно использовать любую допустимую строку.</entry>
 </row><row>
   <entry><codeph>time</codeph></entry>
   <entry>Время (в секундах) возникновения ключевой точки во время воспроизведения видеофайла.</entry>
 </row><row>
   <entry><codeph>type</codeph></entry>
   <entry>Тип достигнутой ключевой точки (точка навигации или события).</entry>
 </row></tbody></tgroup></adobetable>
 
 <p>Ключевые точки в видеофайле можно определить при первом кодировании файла или при импортировании фрагмента ролика в инструменте разработки Flash с помощью мастера импорта видео.</p>
 
 <p>Событие <codeph>onMetaData</codeph> также извлекает информацию о ключевых точках в видеофайле. Тем не менее, событие <codeph>onMetaData</codeph> получает информацию обо всех ключевых точках до начала воспроизведения видеоданных. Событие <codeph>onCuePoint</codeph> получает сведения об отдельной ключевой точке в момент времени, указанной для данной точки во время воспроизведения.</p>
 
 <p>Как правило, для того чтобы ваш код отреагировал на определенную ключевую точку в момент ее возникновения, следует применить в коде событие <codeph>onCuePoint</codeph>, позволяющее инициировать какое-либо действие.</p>
 
 <p>С помощью списка ключевых точек, предоставленных событию <codeph>onMetaData</codeph>, пользователь может начинать воспроизведение видео в предварительно определенных точках внутри видеопотока. Чтобы воспроизвести видео с определенной ключевой точки, передайте значение свойства <codeph>time</codeph> данной точки методу <codeph>NetStream.seek()</codeph>.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onTextData"><apiName>onTextData</apiName><shortdesc>
  Добавляет прослушиватель событий, реагирующий на получение проигрывателем Flash Player текстовых данных, встроенных в воспроизводимый мультимедийный файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  Добавляет прослушиватель событий, реагирующий на получение проигрывателем Flash Player текстовых данных, встроенных в воспроизводимый мультимедийный файл. Текстовые данные представлены в формате UTF-8 и могут содержать информацию о форматировании на основе спецификации 3GP Timed Text.
  <p><codeph>onTextData</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Это не событие, однако его можно найти в разделе «События», так как он реагирует на событие данных при потоковой передаче мультимедийногосодержимого с помощью Flash Media Server или при воспроизведении FLV-файла. Дополнительные сведения см. в описании класса NetStream. Нельзя использовать метод <codeph>addEventListener()</codeph> или любой другой метод EventDispatcher для прослушивания или обработки <codeph>onTextData</codeph> в качестве события. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов:</p>
 
 <ul>
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
    
 </ul>
 
 <p>Связанный прослушиватель событий запускается после вызова метода <codeph>NetStream.play()</codeph>, но перед продвижением точки воспроизведения.</p>
  
  <p>Объект события onTextData содержит по одному свойству для каждого фрагмента текстовых данных.</p>
  
  </apiDesc><example conref="examples\OnTextDataExample.as"> В данном примере код использует свойство <codeph>Netstream.client</codeph> для обработки функций обратного вызова для <codeph>onTextData</codeph> и <codeph>onImageData</codeph>. Для хранения байтового массива функция <codeph>onImageDataHandler()</codeph> использует объект события onImageData <codeph>imageData</codeph>. Функция <codeph>onTextDataHandler()</codeph> использует объект события onTextData <codeph>textData</codeph> для хранения блоков текстовых данных (каждый блок данных является свойством объекта <codeph>textData</codeph>).
 <p>Значение параметра <codeph>yourURL</codeph> в коде необходимо изменить на фактическое место размещения мультимедийного файла, содержащего метаданные в форме текста или изображения.</p>
 <p> Также для обработки данных изображения и текста можно использовать специальный класс. Подробные сведения и примеры см. в статье <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Обработка метаданных и ключевых точек в видеоматериалах Flash</xref>.</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onImageData"><apiName>onImageData</apiName><shortdesc>
 Добавляет прослушиватель событий, реагирующий на получение проигрывателем Flash Player графических данных в виде массива байтов, встроенного в воспроизводимый мультимедийный файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Добавляет прослушиватель событий, реагирующий на получение проигрывателем Flash Player графических данных в виде массива байт, встроенного в воспроизводимый мультимедийный файл. Данные изображения могут быть преобразованы в содержимое формата JPEG, PNG или GIF. Используйте метод <codeph>flash.display.Loader.loadBytes()</codeph> для загрузки байтового массива в экранный объект.
 <p><codeph>onImageData</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Это не событие, однако его можно найти в разделе «События», так как он реагирует на событие данных при потоковой передаче мультимедийногосодержимого с помощью Flash Media Server или при воспроизведении FLV-файла. Дополнительные сведения см. в описании класса NetStream. Для прослушивания или обработки <codeph>onImageData</codeph> в качестве события нельзя использовать ни метод <codeph>addEventListener()</codeph>, ни любые другие методы EventDispatcher. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов:</p>
 
 <ul>
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
    
 </ul>
 
 <p>Связанный прослушиватель событий запускается после вызова метода <codeph>NetStream.play()</codeph>, но перед продвижением точки воспроизведения.</p>
 
 <p>Объект события onImageData содержит данные изображения в качестве байтового массива, переданного по каналу данных AMF0.</p>
 
 </apiDesc><example conref="examples\OnTextDataExample.as"> В данном примере код использует свойство <codeph>Netstream.client</codeph> для обработки функций обратного вызова для <codeph>onTextData</codeph> и <codeph>onImageData</codeph>. Для хранения байтового массива функция <codeph>onImageDataHandler()</codeph> использует объект события onImageData <codeph>imageData</codeph>. Функция <codeph>onTextDataHandler()</codeph> использует объект события onTextData <codeph>textData</codeph> для хранения блоков текстовых данных (каждый блок данных является свойством объекта <codeph>textData</codeph>).
 <p>Значение параметра <codeph>yourURL</codeph> в коде необходимо изменить на фактическое место размещения мультимедийного файла, содержащего метаданные в форме текста или изображения.</p>
 <p> Также для обработки данных изображения и текста можно использовать специальный класс. Подробные сведения и примеры см. в статье <xref href="http://www.adobe.com/devnet/flash/quickstart" scope="external">Обработка метаданных и ключевых точек в видеоматериалах Flash</xref>.</p>
 <codeblock>
package {
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.system.*;
    import flash.events.*;

        public class OnTextDataExample extends Sprite {
                                              
            public function OnTextDataExample():void {

                var customClient:Object = new Object();
                customClient.onImageData = onImageDataHandler;           
                customClient.onTextData = onTextDataHandler;               

                var my_nc:NetConnection = new NetConnection();
                my_nc.connect(null);
                var my_ns:NetStream = new NetStream(my_nc);
                my_ns.play("yourURL");
                my_ns.client = customClient;

                var my_video:Video = new Video();
                my_video.attachNetStream(my_ns);
                addChild(my_video);

            }

            public function onImageDataHandler(imageData:Object):void {

                trace("imageData length: " + imageData.data.length);
                var imageloader:Loader = new Loader();           
                imageloader.loadBytes(imageData.data); // imageData.data is a ByteArray object.
                addChild(imageloader);
            }

    
            public function onTextDataHandler(textData:Object):void {

                trace("--- textData properties ----");
                var key:String;

                for (key in textData) {
                    trace(key + ": " + textData[key]);
                }
            }

        }

}

</codeblock></example></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onMetaData"><apiName>onMetaData</apiName><shortdesc>
 Добавляет прослушиватель, реагирующий на получение проигрывателем Flash Player описательной информации, встроенной в воспроизводимое видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Добавляет прослушиватель, реагирующий на получение проигрывателем Flash Player описательной информации, встроенной в воспроизводимое видео. Информацию о форматах видеофайлов, поддерживаемых Flash Media Server, см. в <xref href="http://www.adobe.com/go/learn_fms_fileformats_ru" scope="external">www.adobe.com/go/learn_fms_fileformats_ru</xref>.
 
 <p><codeph>onMetaData</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Это не событие, однако его можно найти в разделе «События», так как он реагирует на событие данных при потоковой передаче мультимедийногосодержимого с помощью Flash Media Server или при воспроизведении FLV-файла. Дополнительные сведения см. в описании класса NetStream и свойства <codeph>NetStream.client</codeph>. Для прослушивания или обработки <codeph>onImageData</codeph> в качестве события нельзя использовать ни метод <codeph>addEventListener()</codeph>, ни любые другие методы EventDispatcher. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов:</p>
 
 <ul>
 
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
 
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
    
 </ul>
 
 <p>Служебная программа Flash Video Exporter (версии 1.1 или более поздней версии) встраивает различные данные (продолжительность видео, дата создания, скорости передачи данных и т.п.) в сам видеофайл. Разные видеокодеры вставляют разные наборы метаданных.</p>
 
 <p>Связанный прослушиватель событий запускается после вызова метода <codeph>NetStream.play()</codeph>, но перед продвижением точки воспроизведения.</p>
 
 <p>В большинстве случаев, значение продолжительности, встроенное в метаданные потока, является не точным, а лишь приблизительным показателем фактической продолжительности. Другими словами, оно не всегда совпадает со значением свойства <codeph>NetStream.time</codeph>, когда точка воспроизведения находится в конце видеопотока.</p>
 <p>Объект события, передаваемый обработчику событий onMetaData, содержит одно свойство для каждого элемента данных.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream__onXMPData"><apiName>onXMPData</apiName><shortdesc>
 Устанавливает прослушиватель, реагирующий на получение проигрывателем Flash Player информации о платформе Adobe Extensible Metadata Platform (XMP), встроенной в воспроизводимое видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier/><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Устанавливает прослушиватель, реагирующий на получение проигрывателем Flash Player информации о платформе Adobe Extensible Metadata Platform (XMP), встроенной в воспроизводимое видео. Информацию о форматах видеофайлов, поддерживаемых Flash Media Server, см. в <xref href="http://www.adobe.com/go/learn_fms_fileformats_ru" scope="external">www.adobe.com/go/learn_fms_fileformats_ru</xref>.
 
 <p><codeph>onXMPData</codeph> на самом деле является свойством объекта <codeph>NetStream.client</codeph>. Это не событие, однако его можно найти в разделе «События», так как он реагирует на событие данных при потоковой передаче мультимедийногосодержимого с помощью Flash Media Server или при воспроизведении FLV-файла. Дополнительные сведения см. в описании класса NetStream и свойства <codeph>NetStream.client</codeph>. Для прослушивания или обработки <codeph>onImageData</codeph> в качестве события нельзя использовать ни метод <codeph>addEventListener()</codeph>, ни любые другие методы EventDispatcher. В данном случае необходимо определить отдельную функцию обратного вызова и прикрепить ее непосредственно к одному из следующих объектов:</p>
 
 <ul>
  <li>Объект, на который ссылается свойство <codeph>client</codeph> экземпляра NetStream.</li>    
  <li>Экземпляр подкласса NetStream. NetStream представляет собой защищенный класс. Это означает, что при выполнении кода объекту NetStream не могут быть добавлены какие-либо свойства или методы. Тем не менее, можно создать подкласс NetStream и определить свой обработчик событий в этом подклассе. Также можно создать динамический подкласс и добавить функцию обработчика событий отдельному экземпляру подкласса.</li>
    
 </ul>
 
 <p>Связанный прослушиватель событий запускается после вызова метода <codeph>NetStream.play()</codeph>, но перед продвижением точки воспроизведения.</p>
 
 <p>Объект, передаваемый функции обработчика события<codeph>onXMPData()</codeph>, имеет одно свойство <codeph>data</codeph>, содержащее строковое значение. Эта строка генерируется из поля UUID верхнего уровня. (Для поля верхнего уровня 128-разрядный UUID имеет значение <codeph>BE7ACFCB-97A9-42E8-9C71-999491E3AFAC</codeph>.) Это поле UUID верхнего уровня содержит только один документ XML, представленный в виде строки UTF-8, заканчивающейся на 0.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream/event:asyncError"><linktext>asyncError</linktext></link><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Отправляется, когда объект NetStream сообщает о своем состоянии или о случившейся ошибке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда объект NetStream сообщает о своем состоянии или о случившейся ошибке. Событие <codeph>netStatus</codeph> содержит свойство <codeph>info</codeph>, представляющее собой информационный объект, который содержит определенные сведения о событии (например, количество успешных и неудачных попыток подключения).
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою сетевой операции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою сетевой операции. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Отправляется, когда исключение создается асинхронным образом &amp;#x2014; то есть в коде, изначально имеющем асинхронную природу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда исключение создается асинхронным образом, то есть в коде, изначально имеющем асинхронную природу. Данное событие отправляется, если сервер вызывает метод на клиенте, который не был определен.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>NetStream.onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>NetStream.onMetaData</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetStream_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Отправляется при попытке приложения воспроизвести содержимое, зашифрованное с помощью технологии управления цифровыми правами (DRM), путем вызова метода NetStream.play().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при попытке приложения воспроизвести содержимое, зашифрованное с помощью технологии управления цифровыми правами (DRM), путем вызова метода <codeph>NetStream.play()</codeph>. Значение свойства кода состояния будет равно <codeph>DRM.encryptedFLV</codeph>. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.net:NetStream:NetStream"><apiName>NetStream</apiName><shortdesc>
 	 Создает поток, с помощью которого можно воспроизводить видеофайлы через заданный объект NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, constructor
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>Экземпляр NetConnection не подключен.
 	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>connection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>Объект NetConnection
     </apiDesc></apiParam><apiParam><apiItemName>peerID</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>connectToFMS</apiData><apiDesc>Этот параметр является необязательным. Доступно для Flash Player 10 и более поздних версий. Задайте значение <codeph>NetStream.CONNECT_TO_FMS</codeph> для подключения к FMS. Чтобы провести публикацию непосредственно для одноранговых пользователей, укажите <codeph>NetStream.DIRECT_CONNECTIONS</codeph>. Чтобы начать воспроизведение непосредственно с определенного однорангового узла, укажите идентификационные данные этого узла (см. описание <codeph>NetConnection.nearID</codeph> и <codeph>NetConnection.farID</codeph>). Свойство <codeph>NetConnection.protocol</codeph> должно иметь значение <codeph>rtmfp</codeph>, если в качестве значения параметра <codeph>peerID</codeph> указан одноранговый узел. Параметр <codeph>peerID</codeph> игнорируется при подключении по любому протоколу, кроме RTMFP. ActionScript использует значение по умолчанию <codeph>connectToFMS</codeph> для параметра <codeph>peerID</codeph>, чтобы программными средствами перехватывать значение 0, передаваемое в качестве параметра метода NetStream().
     <p>Однако вследствие того, что параметр <codeph>peerID</codeph> является необязательным, для воспроизведения с последовательной загрузкой через подключение клиента к серверу действует следующее:</p>
     <codeblock>
     new NetStream(nc:NetConnection);
     </codeblock>
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Создает поток, с помощью которого можно воспроизводить видеофайлы через заданный объект NetConnection. 
     
     <p>
     Информация о поддерживаемых кодеках и форматах файлов представлена по адресу <xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">http://www.adobe.com/go/hardware_scaling_en</xref> and the <xref href="http://www.adobe.com/go/learn_fms_fileformats_en" scope="external">www.adobe.com/go/learn_fms_fileformats_en</xref>.
     </p>
	 
 	 </apiDesc><example conref="examples\NetStreamExample_constructor.as"> Следующий код демонстрирует подключение для загрузки и последовательного воспроизведения видео, назначенного переменной <codeph>videoURL</codeph>:
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect(null);
            var my_ns:NetStream = new NetStream(my_nc);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example><example conref="examples\NetStreamExample_constructor2.as"> Следующий код демонстрирует подключение для потоковой передачи и воспроизведения видео (назначенного переменной <codeph>videoURL</codeph>) на удаленном экземпляре Flash Media Server, заданном в команде <codeph>connect()</codeph>:
<codeblock>
            var my_nc:NetConnection = new NetConnection();
            my_nc.connect("rtmp://www.yourfmsserver.com/someappname");
            var my_ns:NetStream = new NetStream(my_nc, NetStream.CONNECT_TO_FMS);
            my_ns.play(videoURL);
            var my_video:Video = new Video();
            my_video.attachNetStream(my_ns);
            addChild(my_video);
</codeblock></example></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection"><linktext>flash.net.NetConnection</linktext></link><link href="flash.media.xml#Video/attachCamera()"><linktext>flash.media.Video.attachCamera()</linktext></link><link href="flash.net.xml#NetStream/CONNECT_TO_FMS"><linktext>CONNECT_TO_FMS</linktext></link><link href="flash.net.xml#NetStream/DIRECT_CONNECTIONS"><linktext>DIRECT_CONNECTIONS</linktext></link><link href="flash.net.xml#NetConnection/nearID"><linktext>flash.net.NetConnection.nearID</linktext></link><link href="flash.net.xml#NetConnection/farID"><linktext>flash.net.NetConnection.farID</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetStream:attachAudio"><apiName>attachAudio</apiName><shortdesc>
	 Задает аудиопоток, отправляемый через объект NetStream из объекта Microphone, переданного в качестве источника.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiDefaultValue>"null" 
	 </apiDefaultValue><apiParam><apiItemName>microphone</apiItemName><apiOperationClassifier>flash.media:Microphone</apiOperationClassifier><apiDesc>Источник передаваемого аудиопотока.
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает аудиопоток, отправляемый через объект NetStream из объекта Microphone, переданного в качестве источника. Данный метод доступен только издателю указанного потока.
	 
	 <p>Метод <codeph>attachAudio</codeph> используется при работе с сервером Flash Media Server. Данный метод часто вызывается пользователем, отправляющим аудио в реальном времени (или видео в реальном времени вместе с аудиоданными) с клиентского компьютера на сервер.
	 </p>
	 
	 <p>Данный метод можно вызвать до или после того, как будет вызван метод <codeph>publish()</codeph>, и фактически начата передача. Для прослушивания аудио подписчики должны вызвать метод <codeph>NetStream.play()</codeph>. Настройте параметр <codeph>rate</codeph> микрофона, чтобы он соответствовал чувствительности устройства захвата звука, и задайте пороговое значение уровня тишины с использованием метода <codeph>setSilenceLevel()</codeph>. Можно управлять свойствами звука (громкость и панорамирование) этого звукового потока с использованием свойства <codeph>soundTransform</codeph> объекта микрофона.</p>
     <codeblock>
     var conn:NetConnection = new NetConnection();
     conn.connect("rtmp://server.domain.com/path");
     var stream:NetStream = new NetStream(conn);
     var live_mic:Microphone = Microphone.get();
     live_mic.rate = 8;
     live_mic.setSilenceLevel(20,200);
     var soundTrans:SoundTransform = new SoundTransform();
     soundTrans.volume = 6;
     live_mic.soundTransform = soundTrans;
     stream.attachAudio(live_mic);
     stream.publish("mic_stream","live")
     </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.media.xml#Microphone"><linktext>flash.media.Microphone</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:attachCamera"><apiName>attachCamera</apiName><shortdesc>
	 Начинает захват видео с видеокамеры, либо останавливает запись, если параметр theCamera имеет значение null.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>theCamera</apiItemName><apiOperationClassifier>flash.media:Camera</apiOperationClassifier><apiDesc>Источник передачи видео. Допустимые значения: объект Camera (запускающий захват видео) и <codeph>null</codeph>. При установке значения <codeph>null</codeph> приложение прекращает захват видео, при этом любые дополнительные параметры, которые вы отправляете, игнорируются. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>snapshotMilliseconds</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Указывает, что собой представляет видеопоток: непрерывный поток, отдельный кадр или серия отдельных кадров, используемая для создания замедленной киносъемки.
	 
	 <ul>
     <li>Если опустить этот параметр, приложение будет записывать все видео до тех пор, пока значение <codeph>null</codeph> не будет передано методу <codeph>attachCamera</codeph>.</li>
	 <li>Если значение равно 0, приложение захватывает только один видеокадр. Используйте данное значение для передачи «снимков» в рамках предварительно существующего потока. <ph platform="actionscript">Flash Player или</ph> AIR интерпретирует недопустимые, отрицательные или нечисловые аргументы как 0.</li>
     <li>Если передать положительное число, приложение захватит одиночный видеокадр, а затем добавит паузу заданной длины в качестве концевого кадра на снимке. Используйте данное значение для создания эффектов замедленной киносъемки.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Начинает захват видео с видеокамеры, либо останавливает запись, если параметр <codeph>theCamera</codeph> имеет значение <codeph>null</codeph>. Данный метод доступен только издателю указанного потока. 
	 
     <p>Данный метод используется при работе с сервером Flash Media Server (более подробную информацию см. в описании класса).</p>
	 
	 <p> Чтобы начать передачу, следует после прикрепления видеоисточника вызвать метод <codeph>NetStream.publish()</codeph>. Чтобы отобразить видео в рабочей области, подписчики, которым необходимо отобразить видеоданные, должны вызвать методы <codeph>NetStream.play()</codeph> и <codeph>Video.attachCamera()</codeph>.</p>
	 
	 <p>С помощью <codeph>snapshotMilliseconds</codeph> можно отправить отдельный снимок (необходимое значение 0) или серию снимков (для создания эффектов замедленной киносъемки). Для этого нужно указать положительное число, которое добавляет в видеоданные концевой кадр на указанное число миллисекунд. Концевой кадр увеличивает время отображения видеосообщения. С помощью повторных вызовов метода <codeph>attachCamera()</codeph> с положительным значением для параметра <codeph>snapshotMilliseconds</codeph> последовательность сменяющих друг друга снимков и концевых кадров создает эффект замедленной киносъемки. Например, вы можете снимать по одному кадру в день и вставлять такой кадр в видеофайл. Когда подписчик воспроизводит файл, каждый кадр отображается на экране заданное количество миллисекунд, а затем сменяется на следующий кадр.</p>
	 
	 <p>Функция параметра <codeph>snapshotMilliseconds</codeph> отличается от функции параметра <codeph>fps</codeph>, который можно установить для метода <codeph>Camera.setMode()</codeph>. Определение параметра <codeph>snapshotMilliseconds</codeph> позволяет установить промежуток времени между записываемыми кадрами. Контроль за тем, сколько времени проходит между записью и воспроизведением, осуществляется путем определения параметра <codeph>fps</codeph>с помощью <codeph>Camera.setMode()</codeph>.</p>
	 
	 <p>Например, предположим, что вам необходимо сделать 100 снимков с периодичностью в 5 минут. Это можно выполнить двумя различными способами:</p>
     
	 <ul>
	 <li>Можно 100 раз, через каждые 5 минут, запустить команду <codeph>NetStream.attachCamera(myCamera, 500)</codeph>. На эту запись потребуется 500 минут, но полученный файл будет воспроизводиться в течение 50 секунд (100 кадров с промежутком в 500 миллисекунд).</li> 
	 
	 <li>Можно запустить команду <codeph>Camera.setMode()</codeph>, установив для параметра <codeph>fps</codeph> значение 1/300 (1 раз в 300 секунд или 1 раз каждые 5 минут), а затем запустить команду <codeph>NetStream.attachCamera(source)</codeph>, позволяя камере непрерывно захватывать данные в течение 500 минут. Полученный файл будет воспроизводиться 500 минут (тот же отрезок времени, который потребовался для записи данных): каждый кадр будет отображаться на экране в течение 5 минут.</li>
	 </ul>
     
	 <p>В обоих случаях захватываются одни и те же 500 кадров, и оба подхода имеют функциональное применение. Выбор нужного подхода в основном зависит от требований к воспроизведению снятого материала. Например, во втором случае аудио может записываться на протяжении всего времени. Вдобавок, оба файла будут приблизительно одного размера.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:close"><apiName>close</apiName><shortdesc>
	 Останавливает воспроизведение всех данных в потоке, присваивает свойству time значение 0 и делает поток доступным для использования.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Останавливает воспроизведение всех данных в потоке, присваивает свойству <codeph>time</codeph> значение 0 и делает поток доступным для использования. Данный метод также удаляет локальную копию видеофайла, загруженную по протоколу HTTP. Несмотря на то, что приложение удаляет локальную копию созданного им файла, она может сохраняться в кэш-каталоге. Чтобы полностью предотвратить кэширование или локальное хранение видеофайла, используйте Flash Media Server.
     
     <p>
     При использовании Flash Media Server данный метод вызывается незаметно при вызове <codeph>NetStream.play()</codeph> из публикующего потока или при вызове <codeph>NetStream.publish()</codeph> из подписывающего потока. Обратите внимание:
     </p>
     
     <ul>
     <li>
     Если из публикующего потока вызывается <codeph>close()</codeph>, поток прекращает публикацию, после чего издатель может использовать этот поток по другому назначению. Подписчики больше не получают данные, публикуемые в потоке, так как публикация потока была остановлена. 
     </li>
     <li>
     Если из подписывающего потока вызывается <codeph>close()</codeph>, то поток прекращает воспроизведение для подписчика, после чего подписчик может использовать данный поток для других целей. Это не касается остальных подписчиков.
     </li>
     <li>
     С помощью <codeph>flash.net.NetStream.play(false)</codeph> можно остановить воспроизведение подписывающего потока без закрытия самого потока или изменения его типа.
     </li>
     </ul>
     
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/publish()"><linktext>publish()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:onPeerConnect"><apiName>onPeerConnect</apiName><shortdesc>
	 
     Вызывается, когда поток одноранговой публикации совпадает с потоком одноранговой подписки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscriber</apiItemName><apiOperationClassifier>flash.net:NetStream</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 
     Вызывается, когда поток одноранговой публикации совпадает с потоком одноранговой подписки. Перед тем как подписчик будет подключен к издателю, вызовите этот метод, чтобы обеспечить четкое управление доступом к коду ActionScript для одноранговой публикации. Следующий код демонстрирует создание функции обратного вызова для этого метода
     <codeblock>
	 var c:Object = new Object;
	 c.onPeerConnect = function(subscriber:NetStream):Boolean {
	 if (accept)
	 	return true;
	  else
	      return false;
	  };
	  m_netStream.client = c;
     </codeblock>
     
     <p>Если одноранговый издатель не реализует этот метод, всем одноранговым узлам разрешается воспроизводить любое опубликованное содержимое.</p>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:pause"><apiName>pause</apiName><shortdesc>
	 Приостанавливает воспроизведение видеопотока.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.pause, pause
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Приостанавливает воспроизведение видеопотока. Вызов данного метода ни к чему не приводит, если видеопоток уже был приостановлен. Чтобы продолжить воспроизведение видео после временной остановки, вызовите <codeph>resume()</codeph>. Переключение между паузой и воспроизведением (сначала пауза, затем возобновление воспроизведения) выполняется с помощью <codeph>togglePause()</codeph>.
	 
	 <p>Начиная с версии 9.0.115.0, проигрыватель Flash Player больше не очищает буфер при вызове метода <codeph>NetStream.pause()</codeph>. До версии 9.0.115.0, перед тем как продолжить воспроизведение, проигрыватель Flash Player находился в ожидании заполнения буфера, что часто вызывало задержку.</p>
	 
	 <p>Для одиночной паузы свойство <codeph>NetStream.bufferLength</codeph> имеет ограничение в 60 секунд или удвоенное значение параметра <codeph>NetStream.bufferTime</codeph> (выбирается большее значение из двух). Например, если параметр <codeph>bufferTime</codeph> равен 20 секундам, то проигрыватель Flash Player заполняет буфер до тех пор, пока <codeph>NetStream.bufferLength</codeph> не примет верхнее значение 20~~2 (40) или 60. В данном случае, буферизация проводится до того, как параметр <codeph>bufferLength</codeph> не будет иметь значение 60. Если параметр <codeph>bufferTime</codeph> равен 40 секундам, то проигрыватель Flash Player заполняет буфер до тех пор, пока <codeph>bufferLength</codeph> не примет верхнее значение 40~~2 (80) или 60. В этом случае буферизация проводится до того, как параметр <codeph>bufferLength</codeph> не будет иметь значение 80.</p>
	 
	 <p>Свойство <codeph>bufferLength</codeph> также имеет абсолютный предел. Если любой вызов <codeph>pause()</codeph> приводит к тому, что значение параметра <codeph>bufferLength</codeph> увеличивается на 600 секунд или на значение <codeph>bufferTime</codeph> ~~ 2 (выбирается наибольшее из двух), проигрыватель Flash Player очищает буфер и устанавливает для параметра <codeph>bufferLength</codeph> значение, равное 0. Например, если значение параметра <codeph>bufferTime</codeph> равно 120 секундам, проигрыватель Flash Player заполняет буфер до тех пор, пока параметр <codeph>bufferLength</codeph> не примет значение в 600 секунд. Если значение параметра <codeph>bufferTime</codeph> - 360 секунд, то Flash Player заполняет буфер до тех пор, пока <codeph>bufferLength</codeph> не станет равным 720 секундам.</p>
	 
	 <p><b>Совет</b>: Метод <codeph>NetStream.pause()</codeph> можно использовать в коде для буферизации данных в тот момент, например, когда зрители смотрят рекламу, и последующего воспроизведения потока в начале основной видеопрограммы.</p>
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:play"><apiName>play</apiName><shortdesc>
     Воспроизводит мультимедийные файлы.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>"at"see flash.media.Video#attachVideo()  This method no longer exists.  Replace with new method.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Локальные ненадежные SWF-файлы изолированы от Интернета. Данное ограничение можно обойти, если переклассифицировать этот SWF-файл как локальный с сетевым подключением или доверенный.
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Необходимо указать не менее одного параметра.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Недопустимый NetStream Object. Это может быть вызвано сбоем NetConnection.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Местоположение мультимедийного файла для воспроизведения в виде строки, свойства <codeph>URLRequest.url</codeph> или ссылающейся на них переменной. В содержимом <ph platform="actionscript">Flash Player и</ph> AIR за пределами изолированной программной среды безопасности приложения можно воспроизводить локальные видеофайлы, хранящиеся в том же каталоге, что и SWF-файл, или во вложенном каталоге. Однако переход к каталогу более верхнего уровня невозможен.
	 
	 <p>
	 При работе с Flash Media Server метод <codeph>play()</codeph> принимает следующие аргументы:
	 </p>
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>Имя</entry><entry>Обязательное</entry><entry>Описание</entry></row></thead><tbody><row>
	   <entry><codeph>name:Object</codeph></entry>
	   <entry>Обязательное </entry>
       <entry> Имя записанного файла, идентификатор для данных в реальном времени, опубликованных <codeph>NetStream.publish()</codeph>, или значение <codeph>false</codeph>. Если значение равно <codeph>false</codeph>, воспроизведение потока прекращается и любые дополнительные параметры игнорируются. Для получения дополнительной информации о синтаксисе имени файла см. таблицу с форматами файлов ниже следующей таблицы.</entry>
	 </row><row>
	   <entry><codeph>start:Number</codeph></entry>
	   <entry>Дополнительно</entry>
	   <entry> Время запуска (в секундах). Допустимые значения: -2, -1, 0 или любое положительное число. Значение по умолчанию: -2. В этом случае сначала идет поиск потока в реальном времени, затем – записанного потока. Если ни один из них не будет найден, то будет открыт поток в реальном времени. Если значение равно -1, воспроизводится только поток в реальном времени. Если значение равно 0 или представлено положительным числом, воспроизводит записанный поток, начиная с секунд, указанных в параметре <codeph>start</codeph>.
	   </entry>
	 </row><row>
	   <entry> <codeph>len:Number</codeph> </entry>
	   <entry> Необязательно, если указан параметр <codeph>start</codeph>. </entry>
	   <entry> Продолжительность воспроизведения (в секундах). Допустимые значения: -1, 0 или любое положительное число. Значение по умолчанию: -1. В этом случае до конца воспроизводится видео в реальном времени или записанный поток. Если значение равно 0, воспроизводится один кадр, находящийся <codeph>start</codeph> секунд от начала записанного потока. Если значением является положительное число, воспроизводится прямой или записанный поток в течение <codeph>len</codeph> секунд.
	   </entry>
	 </row><row>
	   <entry> <codeph>reset:Object</codeph> </entry>
	   <entry> Необязательно, если указан параметр <codeph>len</codeph>. </entry>
	   <entry> Необходимо ли очистить список воспроизведения. Значение по умолчанию равно 1 или <codeph>true</codeph>. В этом случае очищаются все предыдущие вызовы <codeph>play</codeph> и сразу же воспроизводится <codeph>name</codeph>. Если значение равно 0 или <codeph>false</codeph>, то поток добавляется в список воспроизведения. Если значение равно 2, то список воспроизведения сохраняется, при этом все сообщения потока возвращаются не через определенные интервалы, а сразу. Если значение равно 3, то производится удаление списка воспроизведения и одновременный возврат всех сообщений потока.  </entry>
	 </row></tbody></tgroup></adobetable>
	 
     <p>
     Для воспроизведения доступны форматы файлов, описанные в следующей таблице. Синтаксис отличается в зависимости от формата файла.</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Формат файла</entry><entry>Синтаксис</entry><entry>Пример</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>Указать имя потока в виде строки без расширения имени файла.</entry>
     <entry><codeph>ns.play("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 или ID3</entry>
     <entry>Указать имя потока в виде строки с префиксом <codeph>mp3:</codeph> или <codeph>id3:</codeph> и без расширения имени файла.</entry>
     <entry><codeph>ns.play("mp3:mymp3stream");</codeph> <codeph>ns.play("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>Файлы на основе MPEG-4 (например, F4V и MP4)</entry>
      <entry>Указать имя потока в виде строки с префиксом <codeph>mp4:</codeph> с расширением имени файла или без него. Префикс указывает серверу, что в файле содержатся данные видео в кодировке H.264 и данные аудио в кодировке AAC в формате контейнера MPEG-4 Part 14. Если файл на сервере имеет расширение имени файла, следует указать расширение имени файла. Если расширение имени файла было указано в методе <codeph>publish()</codeph>, следует определить расширение имени файла.</entry>
     <entry><codeph>ns.play("mp4:myvideo.f4v")</codeph> <codeph>ns.play("mp4:myvideo.mp4")</codeph> <codeph>ns.play("mp4:myvideo")</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Воспроизводит мультимедийные файлы. 
     
     <p>
     Информация о поддерживаемых кодеках и форматах файлов представлена по адресу <xref href="http://www.adobe.com/go/hardware_scaling_ru" scope="external">http://www.adobe.com/go/hardware_scaling_ru</xref> and the <xref href="http://www.adobe.com/go/learn_fms_fileformats_ru" scope="external">www.adobe.com/go/learn_fms_fileformats_ru</xref>.</p>
     
	 <p>Для просмотра видеоданных необходимо создать объект Video и вызвать метод <codeph>Video.attachNetStream()</codeph>. Для потоковой передачи аудио через микрофон необходимо использовать метод <codeph>NetStream.attachAudio()</codeph>. Некоторыми параметрами аудио можно управлять с помощью объекта Microphone.</p>
	 
	 <p>Чтобы направить аудио к объекту в списке отображения, используйте метод <codeph>DisplayObjectContainer.addChild()</codeph>. Некоторыми параметрами аудио можно управлять, создав объект Sound. Дополнительную информацию см. в описании метода <codeph>DisplayObjectContainer.addChild()</codeph>.</p>
	 
	 <p>Если не удается найти видеофайл, отправляется объект <codeph>NetStatusEvent</codeph>.</p>
	 
     <p>При использовании этого метода без Flash Media Server необходимо учитывать ограничения безопасности. Файл в локальной доверенной изолированной среде или среде, локальной для сети, может загружать и воспроизводить видеофайл из удаленной изолированной программной среды, но при этом он не имеет доступа к данным этого удаленного файла без явного разрешения в форме файла политик для URL. <ph platform="actionscript"> Также можно запретить SWF-файлу, выполняемому в приложении Flash Player, использовать этот метод путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML с SWF-содержимым. </ph></p>
	 
      <p>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
     
      <p>Невозможно подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
     
	 <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
	 
     <ul>
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     <li>Свойство <codeph>Netstream.checkPolicyFile</codeph>.</li>
     </ul>
     
	 
     </apiDesc><example><b>Flash Media Server</b> В данном примере воспроизводится записанный файл F4V с самого начала в течение 100 секунд. Если файл MPEG-4 на сервере имеет расширение имени файла, следует указать одно расширение имени файла в методе <codeph>play()</codeph>. 
	 <codeblock>
     ns.play("mp4:record1.f4v", 0, 100, true);
	 </codeblock>
	 
	 </example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>DisplayObjectContainer.addChild()</linktext></link><link href="flash.net.xml#NetStream/checkPolicyFile"><linktext>checkPolicyFile</linktext></link></related-links><adobeApiEvent id="flash.net:NetStream:play_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при попытке воспроизвести содержимое, зашифрованное с помощью технологии управления цифровыми правами (DRM). Значением свойства <codeph>code</codeph> по умолчанию является <codeph>DRM.encryptedFLV</codeph>.
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при попытке воспроизвести содержимое, зашифрованное с помощью технологии управления цифровыми правами (DRM).</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetStream:play2"><apiName>play2</apiName><shortdesc>
     Начинает воспроизведение мультимедийных файлов с использованием одного из нескольких вариантов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
     Начинает воспроизведение мультимедийных файлов с использованием одного из нескольких вариантов.
     
     <p>Этот метод представляет собой расширенную версию <codeph>NetStream.play()</codeph>. Как и <codeph>play()</codeph>, метод <codeph>play2()</codeph> начинает воспроизведение мультимедийного файла или отправляет мультимедийные файлы в очередь для создания списка воспроизведения. При использовании с Flash Media Server он может также запрашивать у сервера переключение на другой мультимедийный файл. Переход происходит незаметно для клиентского приложения.</p> 
     
     <p>Используйте метод <codeph>play2()</codeph> для переключения на потоки с одинаковым содержимым, закодированным с разной скоростью потока или для замены потоков в списке воспроизведения. С помощью класса <codeph>NetStreamInfo</codeph> можно отслеживать условия работы сети и переключать потоки на основе полученных данных. Можно также переключать потоки для клиентов с различными возможностями. Переключение потоков с помощью ActionScript называется <i>динамическая потоковая передача</i>. Для получения дополнительной информации выполните поиск по ключевым словам dynamic streaming (динамическая потоковая передача) в документе Adobe Flash Media Server Developer Guide (Руководство разработчика Adobe Flash Media Server) по адресу <xref href="http://www.adobe.com/go/learn_fms_devguide_en">www.adobe.com/go/learn_fms_devguide_ru</xref>. Adobe создал пользовательский класс ActionScript под названием DynamicStream, который расширяет класс NetStream. С помощью класса DynamicStream можно выполнять динамическую потоковую передачу в приложении вместо написания собственного кода для определения условий работы сети. Даже если вы предпочтете написать собственный код для выполнения динамической потоковой передачи, обратитесь к описанию класса DynamicStream для ознакомления с рабочей реализацией. Загрузить класс и документацию к нему можно со страницы <xref href="http://www.adobe.com/go/fms_tools">www.adobe.com/go/fms_tools_ru</xref>.</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStreamPlayTransitions"><linktext>NetStreamPlayTransitions</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:preloadEmbeddedData"><apiName>preloadEmbeddedData</apiName><shortdesc>
	 Извлекает метаданные DRM из локального мультимедийного файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>flash.net:NetStreamPlayOptions</apiOperationClassifier><apiDesc>Объект NetStreamPlayOptions, описывающий параметры обработки файла содержимого.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Извлекает метаданные DRM из локального мультимедийного файла.
	 
	 <p>Используйте <codeph>preloadEmbeddedMetaData()</codeph> в качестве первого этапа загрузки и кэширования ваучеров DRM, необходимых для автономного просмотра. При обнаружении внедренных в мультимедийный файл метаданных DRM объект DRMContentData передается функции клиента NetStream <codeph>onDRMContentData</codeph>. Объект DRMContentData содержит информацию, необходимую для получения ваучера на воспроизведение содержимого. Для загрузки ваучера необходимо передать DRMContentDataObject методу DRMManager <codeph>loadVoucher()</codeph>.</p>
	 
	 <p>Предварительная загрузка ваучера DRM включает в себя следующие действия.</p>
	 <ul>
	 <li>
	 <p>Создайте новый объект NetStream для предварительной загрузки метаданных.</p>
	 </li>
	 <li>Назначьте функцию обратного вызова свойству <codeph>onDRMContentData</codeph> для NetStream <codeph>client</codeph>.</li>
	 <li>Создайте новый объект NetStreamPlayOptions и установите его свойство <codeph>streamName</codeph> на строку URL-адреса локального видеофайла.</li>
	 <li>Вызовите метод <codeph>preloadEmbeddedMetadata()</codeph>, передав ему объект NetStreamPlayOptions.</li>
	 <li>В ответ на обратный вызов <codeph>onDRMContentData</codeph> вызовите метод DRMManager <codeph>loadVoucher()</codeph> с передачей ему объекта DRMContentData. Если свойству <codeph>authenticationMethod</codeph> объекта DRMContentData присвоено значение <codeph>userNameAndPassWord</codeph>, перед загрузкой ваучера необходимо, чтобы пользователь прошел аутентификацию на сервере управления правами доступа к содержимому.</li>
	 <li>Закройте NetStream, используемый для предварительной загрузки.</li> 
	 </ul>
	 
	 <p><b>Примечание.</b> Если один и тот же объект NetStream используется для предварительной загрузки метаданных и воспроизведения содержимого, перед началом воспроизведения необходимо дождаться вызова <codeph>onPlayStatus</codeph>, генерируемого операцией предварительной загрузки.</p>
	 
	 <p>Загруженные ваучеры хранятся в локальном кэше. При воспроизведении содержимого онлайн также загружаются и кэшируются ваучеры. При просмотре файла содержимого с защитой по технологии DRM кэшированный ваучер автоматически извлекается из локального хранилища. С помощью DRMManager можно управлять кэшем ваучеров.</p>
	   
	 <p><b>Примечание.</b> Предварительная загрузка метаданных DRM через соединение HTTP, HTTPS или RTMP не поддерживается. Метаданные можно предварительно загружать только из файлов, хранящихся в файловой системе.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/event:onDRMContentData"><linktext>onDRMContentData</linktext></link><link href="flash.net.drm.xml#DRMContentData"><linktext>flash.net.drm.DRMContentData</linktext></link><link href="flash.net.drm.xml#DRMManager/loadVoucher()"><linktext>flash.net.drm.DRMManager.loadVoucher()</linktext></link><link href="flash.net.drm.xml#DRMVoucher"><linktext>flash.net.drm.DRMVoucher</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:publish"><apiName>publish</apiName><shortdesc>
	 Отправляет потоковое аудио, видео и текстовые сообщения от клиента на сервер Flash Media Server, дополнительно записывая поток в ходе передачи.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Строка, идентифицирующая поток. Клиенты, подписывающиеся на данный поток, должны передать это же имя при вызове метода <codeph>NetStream.play()</codeph>. Не ставьте после имени потока символ «/». Например, не используйте в качестве имени потока <codeph>bolero/</codeph>. 
     
     <p>
     Для публикации доступны форматы файлов, приведенные в следующей таблице. Синтаксис отличается в зависимости от формата файла.</p>
     <p>
     <adobetable class="innertable">
     
     
     
     
     <tgroup cols="3"><thead><row><entry>Формат файла</entry><entry>Синтаксис</entry><entry>Пример</entry></row></thead><tbody><row>
     <entry>FLV</entry>
     <entry>Имя потока необходимо указать в виде строки без расширения имени файла.</entry>
     <entry><codeph>ns.publish("myflvstream");</codeph></entry>
     </row><row>
     <entry>MP3 или ID3</entry>
     <entry>Указать имя потока в виде строки с префиксом <codeph>mp3:</codeph> или <codeph>id3:</codeph> и без расширения имени файла.</entry>
     <entry><codeph>ns.publish("mp3:mymp3stream");</codeph> <codeph>ns.publish("id3:myid3data");</codeph></entry>
     </row><row>
     <entry>Файлы на основе MPEG-4 (например, F4V и MP4)</entry>
     <entry>Указать имя потока в виде строки с префиксом <codeph>mp4:</codeph> с расширением имени файла или без него. Префикс указывает серверу, что в файле содержатся данные видео в кодировке H.264 и данные аудио в кодировке AAC в формате контейнера MPEG-4 Part 14.</entry>
     <entry><codeph>ns.publish("mp4:myvideo.f4v")</codeph> <codeph>ns.publish("mp4:myvideo.mp4");</codeph> <codeph>ns.publish("mp4:myvideo");</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>     
	 
	 </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Строка, указывающая способ публикации потока. Допустимые значения: <codeph>record</codeph>, <codeph>append</codeph> и <codeph>live</codeph>. Значение по умолчанию: <codeph>live</codeph>.
	 <ul>
	 <li>Если будет передано значение <codeph>record</codeph>, Flash Media Server публикует и записывает данные в реальном времени, сохраняя записанные данные в новом файле под именем, совпадающим со значением, которое было передано параметру <codeph>name</codeph>. Если файл существует, он будет перезаписан.</li>
	 <li>Если будет передано значение <codeph>append</codeph>, Flash Media Server публикует и записывает данные в реальном времени, сохраняя записанные данные в новом файле под именем, совпадающим со значением, которое было передано параметру <codeph>name</codeph>. Если не будет найден файл с идентичным значением параметра <codeph>name</codeph>, такой файл будет создан. </li>
	 <li>Если данный параметр опущен или передано значение <codeph>live</codeph>, Flash Media Server публикует данные в реальном времени, но не записывает их. Существующий файл, имя которого совпадает со значением, переданным параметру <codeph>name</codeph>, будет удален.</li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отправляет потоковое аудио, видео и текстовые сообщения от клиента на сервер Flash Media Server, дополнительно записывая поток в ходе передачи. Данный метод доступен только издателю указанного потока.
	 
	 <p>Запись файлов возможна в формате FLV или MPEG-4. При записи файла в формате MPEG-4 необходимо использовать средство преобразования для изменения или воспроизведения файла в другом приложении. Для загрузки инструмента см. <xref href="http://www.adobe.com/go/fms_tools_ru" scope="external">www.adobe.com/go/fms_tools_ru</xref>.</p>
     
     <p>Не используйте этот метод для воспроизведения потока, который уже был опубликован и записан. Для воспроизведения потока вызовите метод <codeph>NetStream.play()</codeph>.</p>
	 
	 <codeblock platform="actionscript">
	 var subscribeNS:NetStream = new NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var subscribeNS = new air.NetStream(myNetConnection);
	 subscribeNS.play("streamToPlay");
	 </codeblock>
	 
     <p>Когда Flash Media Server записывает поток, он создает файл и сохраняет его во вложенном каталоге каталога приложения на сервере. Каждый поток сохраняется в каталоге, имя которого совпадает с именем экземпляра приложения, переданным методу <codeph>NetConnection.connect()</codeph>. Сервер создает эти каталоги автоматически. Например, следующий код подключается к приложению lectureseries и записывает поток с именем lecture. Файл lecture.flv записывается в каталог applications/lectureseries/streams/_definst_:
     </p>
     
     <codeblock platform="actionscript">
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <p>В следующем примере показано, как выполнить подключение к другому экземпляру того же самого приложения. Файл lecture.flv записывается в каталог /applications/lectureseries/streams/monday:</p>
     
     <codeblock>
     var myNC:NetConnection = new NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS:NetStream = new NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
     
     <codeblock platform="javascript">
     var myNC = new air.NetConnection();
     myNC.connect("rtmp://fms.example.com/lectureseries/monday");
     var myNS = new air.NetStream(myNC);
     myNS.publish("lecture", "record");
     </codeblock>
   	 
	 <p>Этот метод отправляет объект <codeph>NetStatusEvent</codeph>. Например, если опубликование потока с указанным именем уже выполняется, объект <codeph>NetStatusEvent</codeph> отправляется со свойством <codeph>code</codeph> <codeph>"NetStream.Publish.BadName"</codeph>. Для получения дополнительной информации см. объект <codeph>NetStatusEvent</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>NetConnection.connect()</linktext></link><link href="" invalidHref="flash.net.xml#NetStatusEvent/info"><linktext>NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:receiveAudio"><apiName>receiveAudio</apiName><shortdesc>
	 Определяет, воспроизводится ли входящий звук в потоке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Указывает, воспроизводится (<codeph>true</codeph>) или не воспроизводится (<codeph>false</codeph>) входящее аудио в потоке. По умолчанию используется значение <codeph>true</codeph>. 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, воспроизводится ли входящий звук в потоке. Данный метод доступен не издателю потока, а только клиентам, подписанным на указанный поток.
	 
     <p>Данный метод используется преимущественно для работы с сервером Flash Media Server (более подробную информацию см. в описании класса).</p> 
	 
	 <p>Данный метод можно вызвать до или после того, как будет вызван метод <codeph>NetStream.play()</codeph>и фактически начат прием потока. Например, эти методы можно присвоить той кнопке, которую пользователь нажимает, чтобы включить или выключить звук на входящем аудиопотоке.</p>
	 
	 <p>Если указанный поток содержит только аудиоданные, то передача значения <codeph>false</codeph> данному методу останавливает приращение <codeph>NetStream.time</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideo"><apiName>receiveVideo</apiName><shortdesc>
	 Определяет, воспроизводится ли входящее видео в потоке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>flag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Указывает, воспроизводится (<codeph>true</codeph>) или не воспроизводится (<codeph>false</codeph>) входящее видео в этом потоке. По умолчанию используется значение <codeph>true</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Определяет, воспроизводится ли входящее видео в потоке. Данный метод доступен не издателю потока, а только клиентам, подписанным на указанный поток.
	 
     <p>Данный метод используется преимущественно для работы с сервером Flash Media Server (более подробную информацию см. в описании класса).</p>
	 
	 <p>Данный метод можно вызвать до или после того, как будет вызван метод <codeph>NetStream.play()</codeph>и фактически начат прием потока. Например, эти методы можно присвоить той кнопке, которую пользователь нажимает, чтобы отобразить или скрыть входящий видеопоток.</p>
	 
	 <p>Если указанный поток содержит только видеоданные, то передача значения <codeph>false</codeph> данному методу останавливает приращение <codeph>NetStream.time</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:receiveVideoFPS"><apiName>receiveVideoFPS</apiName><shortdesc>
	 Указывает частоту кадров для входящего видео.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>FPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Указывает частоту кадров (в секунду), с которой будет воспроизводиться входящее видео.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Указывает частоту кадров для входящего видео. Данный метод доступен не издателю потока, а только клиентам, подписанным на указанный поток.
	 
     <p>Данный метод используется преимущественно для работы с сервером Flash Media Server (более подробную информацию см. в описании класса).</p>
	 
	 <p>Данный метод можно вызвать до или после того, как будет вызван метод <codeph>NetStream.play()</codeph>и фактически начат прием потока. Например, можно присоединить эти методы к текстовому полю, где пользователь может задать частоту кадров входящего видео.</p>
     
     <p>Чтобы остановить получение видеоданных, передайте для параметра FPS значение 0. Чтобы определить текущую частоту кадров, используйте <codeph>NetStream.currentFPS</codeph>.</p>
     
     <p>Если в целях уменьшения частоты видеокадров передать определенное значение параметру <codeph>FPS</codeph>, проигрыватель Flash Media Server предпримет попытку снизить частоту кадров, при этом сохраняя целостность видеоизображения. Через каждые два ключевых кадра сервер посылает минимальное количество кадров, необходимое для обеспечения заданной частоты кадров. Тем не менее, следует помнить, что промежуточные кадры должны отправляться рядом с ключевыми. В противном случае, видеоизображение будет испорченным. Таким образом, необходимое число кадров отправляется немедленно в сопровождении ключевого кадра. Так как кадры распределены неравномерно, движение выглядит сглаженным в тех сегментах, прерываемых остановками.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetStream:resetDRMVouchers"><apiName>resetDRMVouchers</apiName><shortdesc>
     Удаляет все данные ваучера DRM из локального кэша.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, resetDRMVouchers
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Невозможно удалить данные ваучера.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет все данные ваучера DRM из локального кэша.
     <p>
     Чтобы пользователь мог снова получить доступ к зашифрованному содержимому, приложение должно снова загрузить необходимые ваучеры с сервера управления правами доступа к содержимому. Вызов этой функции равнозначен вызову функции <codeph>resetDRMVouchers()</codeph> объекта DRMManager.</p>
     
     </apiDesc><example conref="examples\NetStream.resetDRMVouchers.1.as"> Следующий пример сбрасывает все ваучеры DRM:
<codeblock>

NetStream.resetDRMVouchers();
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.drm.xml#DRMManager/resetDRMVouchers()"><linktext>flash.net.drm.DRMManager.resetDRMVouchers()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:resume"><apiName>resume</apiName><shortdesc>
	 Возобновляет воспроизведение приостановленного видеопотока.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Возобновляет воспроизведение приостановленного видеопотока. Если видео уже воспроизводится, вызов данного метода ни к чему не приведет.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/togglePause()"><linktext>togglePause()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:seek"><apiName>seek</apiName><shortdesc>
	 
	 Осуществляет поиск ключевого кадра (так называемого I-кадра), расположенного ближе всего к указанной точке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.seek, seek
	 
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Приблизительное время (в секундах), к которому надо перейти в видеофайле. Если при работе с Flash Media Server параметр <codeph>&lt;EnhancedSeek></codeph> имеет значение <codeph>true</codeph> в файле конфигурации Application.xml (значение по умолчанию), сервер генерирует ключевой кадр со смещением <codeph>offset</codeph>. 
	 
	 <ul>
	   <li>Чтобы вернуться в начало потока, укажите 0 для <codeph>offset</codeph>.</li>
	   <li>Чтобы выполнить прямой поиск от начала потока, передайте число секунд, которое надо пропустить. Например, чтобы установить точку воспроизведения через 15 секунд от начала видео (или ключевой кадр перед 15 секундами), используйте <codeph>myStream.seek(15)</codeph>.</li>
	   <li>Для поиска относительно текущего положения передайте <codeph>NetStream.time + n</codeph> или <codeph>NetStream.time - n</codeph>, чтобы поиск начинался на <codeph>n</codeph> секунд вперед или назад относительно текущего положения. Например, чтобы перейти на 20 секунд вперед от текущего положения, используйте синтаксис <codeph>NetStream.seek(NetStream.time - 20).</codeph></li>
	 </ul>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 Осуществляет поиск ключевого кадра (так называемого I-кадра), расположенного ближе всего к указанной точке. Ключевой кадр размещается в точке смещения, измеряемой в секундах от начала потока. 
	 
     <p>
     Видеопотоки обычно кодируются с двумя типами кадров: ключевые кадры (или I-кадры) и P-кадры. Ключевой кадр содержит все изображение, в то время как P-кадр является промежуточным кадром, предоставляющим дополнительную видеоинформацию между ключевыми кадрами. Как правило, в видеопотоке ключевой кадр ставится через каждые 10-50 кадров. 
     </p>
     
     <p>
     На сервере Flash Media Server поведение <codeph>seek()</codeph> контролируется с помощью значения элемента <codeph>EnhancedSeek</codeph> в файле конфигурации <codeph>Application.xml</codeph>.
     </p>
     
     <p>
     Если параметр <codeph>EnhancedSeek</codeph> имеет значение <codeph>false</codeph>, сервер использует обычный режим поиска. В обычном режиме поиска сервер начинает потоковое воспроизведение с ближайшего ключевого кадра. Например, если в видео ключевые кадры размещены на нулевой и десятой секундах, то в результате поиска четвертой секунды воспроизведение начнется с четвертой секунды с использованием ключевого кадра, установленного на нулевой секунде. Изображение не меняется до тех пор, пока на десятой секунде не будет достигнут следующий ключевой кадр. Для того чтобы оптимизировать операцию поиска, необходимо сократить интервал между ключевыми кадрами. В нормальном режиме поиска нельзя запустить видео в точке между ключевыми кадрами.
     </p>
     
     <p>
     Если параметр <codeph>EnhancedSeek</codeph> имеет значение <codeph>true</codeph> (значение по умолчанию), то сервер генерирует новый ключевой кадр в точке смещения <codeph>offset</codeph> на основе предыдущего ключевого кадра и любых промежуточных P-кадров. Тем не менее, это создает большую нагрузку на вычислительные ресурсы сервера, что может привести к искажению сгенерированного ключевого кадра. Если в качестве видеокодека применяется On2, то клиенту отправляются ключевой кадр перед точкой поиска и любые P-кадры между ключевым кадром и точкой поиска.
     </p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/time"><linktext>time</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:send"><apiName>send</apiName><shortdesc>
	 Отправляет сообщение по опубликованному потоку всем подписавшимся клиентам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>handlerName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Отправляемое сообщение, а также имя обработчика ActionScript, который должен получить это сообщение. Имя обработчика должно быть исключительно одноуровневым (то есть, форма «вышестоящий/нижестоящий объект» не используется) и связанным с объектом потока. Не используйте в качестве имени обработчика зарезервированный термин. Например, использование <codeph>close</codeph> в качестве имени обработчика приведет к сбою метода. При работе с Flash Media Server используйте <codeph>@setDataFrame</codeph>, чтобы добавить ключевой кадр метаданных в прямой поток, а <codeph>@clearDataFrame</codeph> - чтобы удалить ключевой кадр.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Необязательные (дополнительные) аргументы любого типа. Они сериализуются и отправляются посредством подключения, при этом принимающий обработчик получает их в том же самом порядке. Если параметр представляет собой объект круглой формы (например, связанный в круглую форму список), сериализатор обрабатывает ссылки надлежащим образом. Если при работе с Flash Media Server в качестве первого аргумента используется <codeph>@setDataFrame</codeph>, то как второй аргумент следует использовать <codeph>onMetaData</codeph>. В качестве третьего аргумента передайте экземпляр <codeph>Object</codeph> или <codeph>Array</codeph>, в котором свойствами выступают метаданные. Для получения списка предлагаемых имен свойств см. <xref href="http://www.adobe.com/go/learn_fms_devguide_ru" scope="external">Flash Media Server Developer Guide</xref>. Если в качестве первого аргумента указан <codeph>@clearDataFrame</codeph>, в качестве второго аргумента используйте <codeph>onMetaData</codeph>, третий аргумент не требуется.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Отправляет сообщение по опубликованному потоку всем подписавшимся клиентам. Этот метод доступен только издателю указанного потока и предназначен для работы с сервером Flash Media Server. Чтобы обработать данное сообщение и отреагировать на него, создайте обработчик на объекте <codeph>NetStream</codeph> - например, <codeph>ns.HandlerName</codeph>.
     
     <p>
     <ph platform="actionscript">Приложение Flash Player или</ph> AIR не проводит сериализацию методов или их данных, переменных для прототипов объектов или несчетных переменных. Для отображаемых объектов проигрыватель <ph platform="actionscript">Flash Player или</ph> AIR сериализует не данные, а только сам путь.
	 </p>
	 
	 <p>
	 Для добавления ключевых кадров данных в прямой поток, отправляемый на сервер Flash Media Server, можно вызвать метод <codeph>send()</codeph>. Ключевой кадр данных – это сообщение, добавляемое сервером публикаций в прямой поток. Ключевые кадры данных обычно используются для добавления метаданных в прямой поток до того, как будет происходить захват данных (для этого потока) с камеры и микрофона. Издатель может добавлять ключевой кадр данных в любой момент в процессе публикации прямого потока. Ключевой кадр данных хранится в памяти сервера, пока издатель подключен к данному серверу. 
	 </p>
	 <p>
	 Клиенты, подписанные на прямой поток до добавления ключевого кадра данных, получают этот кадр в момент его добавления в поток. Клиенты, подписывающиеся на прямой поток после добавления ключевого кадра данных, получают этот кадр в момент подписки.
	 </p>
	 <p>
	 Для добавления ключевого кадра метаданных в прямой поток, отправляемый на сервер Flash Media Server, используйте <codeph>@setDataFrame</codeph> в качестве имени обработчика, а затем добавьте два дополнительных аргумента, например:
	 </p>
	 
	 <codeblock platform="actionscript">
	 var ns:NetStream = new NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var ns = new air.NetStream(nc);
	 ns.send("@setDataFrame", "onMetaData", metaData);
	 </codeblock>
	 
	 <p>
	 Аргумент <codeph>@setDataFrame</codeph> ссылается на специальный обработчик, встроенный в сервер Flash Media Server. Аргумент <codeph>onMetaData</codeph> – это имя функции обратного вызова в клиентском приложении, которая прослушивает событие <codeph>onMetaData</codeph> и извлекает метаданные. Третий элемент, <codeph>metaData</codeph>, представляет собой экземпляр <codeph>Object</codeph> или <codeph>Array</codeph> со свойствами, определяющими значения метаданных. Издатели должны устанавливать имена свойств, понятные для подписчиков. Для получения списка предлагаемых имен свойств см. <xref href="http://www.adobe.com/go/learn_fms_devguide_en" scope="external">Flash Media Server Developer Guide</xref>.
	 </p>
	 
	 <p>Для удаления ключевого кадра метаданных, который был предварительно определен в потоке, используйте <codeph>@clearDataFrame</codeph>:
	 </p>
	 <codeblock>
	 ns.send("@clearDataFrame", "onMetaData");
	 </codeblock>
	 
	 
	 </apiDesc><example conref="examples\NetStream.send.1.as"> В следующем примере создаются два объекта <codeph>NetStream</codeph>. Один используется для публикации потока в реальном времени на сервере, в то время как второй объект осуществляет подписку на данный поток.
<codeblock>
package {
   import flash.display.Sprite;
   import flash.net.NetConnection;
   import flash.net.NetStream;
   import flash.events.NetStatusEvent;
   import flash.media.Video;
   import flash.utils.setTimeout;

 
   public class TestExample extends Sprite
   {
     var nc:NetConnection = new NetConnection();
     var ns1:NetStream;
     var ns2:NetStream;
     var vid:Video = new Video(300,300);
     var obj:Object = new Object();
 
     public function TestExample() {
        nc.objectEncoding = 0;
        nc.addEventListener("netStatus", onNCStatus);
        nc.connect("rtmp://localhost/FlashVideoApp");
        addChild(vid); 
     }
  
     function onNCStatus(event:NetStatusEvent):void {
       switch (event.info.code) {
           case "NetConnection.Connect.Success":
               trace("You've connected successfully");
               ns1 = new NetStream(nc);
               ns2 = new NetStream(nc);
               
               ns1.client = new CustomClient();
               ns1.publish("dummy", "live");
    
               ns2.play("dummy");
               ns2.client = new CustomClient();
               vid.attachNetStream(ns2);
               setTimeout(sendHello, 3000);
               break;
              
           case "NetStream.Publish.BadName":
               trace("Please check the name of the publishing stream" );
               break;
        }   
     }

     function sendHello():void {
         ns1.send("myFunction", "hello");
     }       
   }
 }
 
 class CustomClient {
    public function myFunction(event:String):void {
       trace(event);
    }
 }
</codeblock></example><example conref="examples\NetStream.send.2.as"> В следующем примере создаются метаданные, которые затем добавляются в поток реального времени:
<codeblock>
private function netStatusHandler(event:NetStatusEvent):void {
     switch (event.info.code) {  
        case "NetStream.Publish.Start":
            var metaData:Object = new Object();
            metaData.title = "myStream";
            metaData.width = 400;
            metaData.height = 200;
            ns.send("&amp;#64;setDataFrame", "onMetaData", metaData);
            ns.attachCamera( Camera.getCamera() );
            ns.attachAudio( Microphone.getMicrophone() );        
    }
}
</codeblock></example><example conref="examples\NetStream.send.3.as"> Чтобы отреагировать на ключевой кадр данных, добавленный в видео, клиенту необходимо определить обработчик событий <codeph>onMetaData</codeph>. Обработчик событий <codeph>onMetaData</codeph> не регистрируется с методом <codeph>addEventListener()</codeph>. Он представляет собой функцию обратного вызова с именем <codeph>onMetaData</codeph>, например:
<codeblock>
 public function onMetaData(info:Object):void {
    trace("width: " + info.width);
    trace("height: " + info.height);
 }
</codeblock></example><example conref="examples\NetStream.send.4.as"> В данном примере показан процесс создания списка воспроизведения на сервере:
<codeblock>
 // Create a NetStream for playing
 var my_ns:NetStream = new NetStream(my_nc);
 my_video.attachNetStream(my_ns);
 
 // Play the stream record1
 my_ns.play("record1", 0, -1, true);
 
 // Switch to the stream live1 and play for 5 seconds.  
 // Since reset is false, live1 will start to play after record1 is done.
 my_ns.play("live1", -1 , 5, false);
</codeblock></example><example conref="examples\NetStream.send.5.as"> Если записанный видеофайл содержит только блоки данных, вы можете воспроизвести видеофайл с той скоростью, на которой он был изначально записан, или просто сразу получить все блоки данных.
<codeblock>
 //To play at normal speed
 var my_ns:NetStream = new NetStream(my_nc);
 my_ns.play("log", 0, -1);
 
 //To get the data messages all at once
 my_ns.play("log", 0, -1, 3);
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/client"><linktext>client</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:setDRMAuthenticationCredentials"><apiName>setDRMAuthenticationCredentials</apiName><shortdesc>
     Задает учетные данные для прохождения аутентификации DRM, необходимой для просмотра соответствующего зашифрованного содержимого.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>NetStream, setDRMAuthenticationCredentials
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>userName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Действительное имя пользователя.
     </apiDesc></apiParam><apiParam><apiItemName>password</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Пароль для предоставленного имени пользователя.
     </apiDesc></apiParam><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, указывающая тип предоставленных учетных данных для аутентификации. Допустимыми значениями являются <codeph>drm</codeph> и <codeph>proxy</codeph>. Значением по умолчанию является <codeph>drm</codeph>.
     <ul>
     <li>Если задан тип аутентификации <codeph>drm</codeph>, предоставленные учетные данные проверяются с помощью сервера Flash Media Rights Management Server (FMRMS).</li>
     <li>Если задан тип аутентификации <codeph>proxy</codeph>, предоставленные учетные данные проверяются с помощью прокси-сервера и должны совпадать с данными этого сервера. Например, вариант <codeph>proxy</codeph> позволяет приложению выполнять проверку подлинности на прокси-сервере, если организация требует от пользователя выполнения этого шага перед выходом в Интернет. Если не используется анонимная проверка подлинности, то после проверки подлинности на прокси-сервере пользователю все равно нужно пройти авторизацию FMRMS, чтобы получить ваучер и воспроизвести содержимое. Метод <codeph>setDRMAuthenticationcredentials()</codeph> можно использовать во второй раз с параметром <codeph>drm</codeph> для проверки подлинности FMRMS.</li>
     </ul>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Задает учетные данные для прохождения аутентификации DRM, необходимой для просмотра соответствующего зашифрованного содержимого.
     <p>
     Метод <codeph>setDRMAuthenticationCredentials()</codeph> должен предоставлять учетные данные, известные поставщику содержимого или прокси-серверу и принимаемые ими. Это те же учетные данные, которые пользователь использует при получении разрешения на просмотр содержимого.
     </p>
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#DRMAuthenticateEvent"><linktext>flash.events.DRMAuthenticateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetStream:togglePause"><apiName>togglePause</apiName><shortdesc>
	 Приостанавливает или возобновляет воспроизведение потока.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.resume, resume
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Приостанавливает или возобновляет воспроизведение потока. При первом вызове данный метод временно останавливает воспроизведение, при последующем вызове он продолжает воспроизведение. Применение этого метода позволяет пользователям временно останавливать или продолжать воспроизведение путем нажатия одной кнопки.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream/close()"><linktext>close()</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link><link href="flash.net.xml#NetStream/pause()"><linktext>pause()</linktext></link><link href="flash.net.xml#NetStream/resume()"><linktext>resume()</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetStream:CONNECT_TO_FMS"><apiName>CONNECT_TO_FMS</apiName><shortdesc>
     Статический объект, передаваемый в качестве параметра конструктору для экземпляра NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>connectToFMS</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Статический объект, передаваемый в качестве параметра конструктору для экземпляра NetStream. Это значение по умолчанию для второго параметра в конструкторе NetStream. Оно не используется приложением для последовательного воспроизведения содержимого. Когда этот параметр используется, конструктор создает подключение к экземпляру Flash Media Server.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:DIRECT_CONNECTIONS"><apiName>DIRECT_CONNECTIONS</apiName><shortdesc>
     Создает подключение между одноранговыми издателями</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>directConnections</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Создает подключение между одноранговыми издателями Передайте эту строку в качестве второго (необязательного) параметра конструктору для экземпляра NetStream. С помощью этой строки приложение может создать подключение NetStream с целью публикации аудио и видео для клиентов.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:bufferLength:get"><apiName>bufferLength</apiName><shortdesc>
	 Число секунд данных, в настоящий момент находящихся в буфере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bufferLength, bufferLength
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число секунд данных, в настоящий момент находящихся в буфере. Используя данное свойство вместе со свойством <codeph>bufferTime</codeph>, можно определить, насколько близок момент полного заполнения буфера (это необходимо, например, чтобы оповестить пользователя, ожидающего загрузки данных в буфер).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bufferTime:set"><apiName>bufferTime</apiName><shortdesc>
	 Определяет, как долго сообщения должны накапливаться в буфере до начала отображения потока.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.setBufferTime, setBufferTime
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, как долго сообщения должны накапливаться в буфере до начала отображения потока. Например, для того чтобы первые 15 секунд потока воспроизводились без прерываний, следует установить для параметра <codeph>bufferTime</codeph> значение 15. Приложение начнет воспроизведение потока только после того, как буферизацию пройдут 15 секунд данных.
	 
	 <p>По умолчанию используется значение 0,1 (одна десятая секунды). Определить количество секунд, которые в данный момент находятся в буфере, можно с помощью свойства <codeph>bufferLength</codeph>.</p>
	 
     <p><b>Примечание.</b> Во избежание искажения при потоковой передаче предварительно записанного (не эфирного) содержимого, не задавайте для <codeph>NetStream.bufferTime</codeph> значение 0. По умолчанию приложение использует входящий буфер для предварительно записанного содержимого, который ставит данные мультимедиа в очередь и надлежащим образом их воспроизводит. Для предварительно записанного содержимого используйте параметр по умолчанию или увеличьте время буферизации.</p>
     
     <p>Начиная с версии 9.0.115.0, проигрыватель Flash Player больше не очищает буфер при вызове метода <codeph>NetStream.pause()</codeph>. До версии 9.0.115.0, перед тем как продолжить воспроизведение, проигрыватель Flash Player находился в ожидании заполнения буфера, что часто вызывало задержку.</p>
     	 
     	 <p>Для одиночной паузы свойство <codeph>NetStream.bufferLength</codeph> имеет ограничение в 60 секунд или удвоенное значение параметра <codeph>NetStream.bufferTime</codeph> (выбирается большее значение из двух). Например, если параметр <codeph>bufferTime</codeph> равен 20 секундам, то проигрыватель Flash Player заполняет буфер до тех пор, пока <codeph>NetStream.bufferLength</codeph> не примет верхнее значение 20~~2 (40) или 60. В данном случае, буферизация проводится до того, как параметр <codeph>bufferLength</codeph> не будет иметь значение 60. Если параметр <codeph>bufferTime</codeph> равен 40 секундам, то проигрыватель Flash Player заполняет буфер до тех пор, пока <codeph>bufferLength</codeph> не примет верхнее значение 40~~2 (80) или 60. В этом случае буферизация проводится до того, как параметр <codeph>bufferLength</codeph> не будет иметь значение 80.</p>
     	 
     	 <p>Свойство <codeph>bufferLength</codeph> также имеет абсолютный предел. Если любой вызов <codeph>pause()</codeph> приводит к тому, что значение параметра <codeph>bufferLength</codeph> увеличивается на 600 секунд или на значение <codeph>bufferTime</codeph> ~~ 2 (выбирается наибольшее из двух), проигрыватель Flash Player очищает буфер и устанавливает для параметра <codeph>bufferLength</codeph> значение, равное 0. Например, если значение параметра <codeph>bufferTime</codeph> равно 120 секундам, проигрыватель Flash Player заполняет буфер до тех пор, пока параметр <codeph>bufferLength</codeph> не примет значение в 600 секунд. Если значение параметра <codeph>bufferTime</codeph> - 360 секунд, то Flash Player заполняет буфер до тех пор, пока <codeph>bufferLength</codeph> не станет равным 720 секундам.</p>
     	 
     	 <p><b>Совет</b>: Метод <codeph>NetStream.pause()</codeph> можно использовать в коде для буферизации данных в тот момент, например, когда зрители смотрят рекламу, и последующего воспроизведения потока в начале основной видеопрограммы.</p>
     	 
     	 <p>Дополнительные сведения о новых возможностях механизма паузы см. по адресу <xref href="http://www.adobe.com/go/learn_fms_smartpause_ru" scope="external">http://www.adobe.com/go/learn_fms_smartpause_ru</xref>.</p>
     <p>
     <b>Flash Media Server</b>. Поведение буфера зависит от того, в отношении какого потока установлено время буферизации: публикующего или подписывающего. Для публикующего потока параметр <codeph>bufferTime</codeph> указывает, как долго может расширяться исходящий буфер до тех пор, пока приложение не начнет пропускать кадры. При высокоскоростном подключении время буферизации не столь важно, так как данные будут отправляться настолько же быстро, насколько быстро приложение сможет поместить их в буфер. Однако при медленном подключении может появиться существенная разница между тем, как быстро приложение помещает данные в буфер, и тем, с какой скоростью эти данные отправляются клиенту. 
     </p>
     
     <p>
     Для подписывающего потока параметр <codeph>bufferTime</codeph> указывает, как долго может происходить буферизация входящих данных до того, как поток будет отображаться на экране. Например, для того чтобы первые 15 секунд потока воспроизводились без прерываний, следует установить для параметра <codeph>bufferTime</codeph> значение 15. Flash начнет воспроизведение потока только после того, как буферизацию пройдут 15 секунд данных.
     </p>
     
     <p>
     Если при воспроизведении записанного потока параметр <codeph>bufferTime</codeph> равен нулю, то проигрыватель Flash устанавливает для него малое значение (приблизительно 10 миллисекунд). Если в дальнейшем воспроизводятся (например, из списка воспроизведения) потоки в реальном времени, данное значение времени буферизации не меняется. Другими словами, параметр <codeph>bufferTime</codeph> остается для потока ненулевым. 
     </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#bufferTime/bufferLength"><linktext>bufferLength</linktext></link><link href="" invalidHref="flash.net.xml#bufferTime/time"><linktext>time</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 Число байт данных, загруженных в приложение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesLoaded, bytesLoaded
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Число байт данных, загруженных в приложение. Используя данное свойство вместе со свойством <codeph>bytesTotal</codeph>, можно определить, насколько близок момент полного заполнения буфера (это необходимо, например, чтобы оповестить пользователя, ожидающего загрузки данных в буфер).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesTotal"><linktext>bytesTotal</linktext></link><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 Общий размер файла, загружаемого в приложение (в байтах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.bytesTotal, bytesTotal
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Общий размер файла, загружаемого в приложение (в байтах).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link><link href="flash.net.xml#NetStream/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:checkPolicyFile:get"><apiName>checkPolicyFile</apiName><shortdesc>
	 Указывает, будет ли приложение пытаться загрузить файл междоменных политик с сервера загружаемого видеофайла перед началом загрузки самого файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>: please review at same time: checkPolicyFile property in LoaderContext
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, будет ли приложение пытаться загрузить файл междоменных политик с сервера загружаемого видеофайла перед началом загрузки самого файла. Данное свойство применяется при использовании объекта NetStream для последовательной загрузки отдельных видеофайлов или при загрузке файлов, размещенных за пределами собственного домена вызывающего файла. Данное свойство игнорируется, если для получения ресурса RTMP используется объект NetStream.
	 
     <p>Установите для данного свойства значение <codeph>true</codeph>, если вы загружаете видеофайл, размещенный за пределами домена вызывающего SWF-файла. Для доступа с возможностью обработки этого видеоматериала вам следует использовать метод <codeph>BitmapData.draw()</codeph>. При вызове <codeph>BitmapData.draw()</codeph> без установки значения <codeph>true</codeph> для параметра <codeph>checkPolicyFile</codeph> во время загрузки можно получить исключение <codeph>SecurityError</codeph>, так как требуемый файл политик не был загружен.</p>
	 
	 <p>Если вам не требуется доступ к загружаемому видео на уровне обработки изображения, не устанавливайте для параметра <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>. Проверка наличия файла политик снижает пропускную способность сети и может задержать начало загрузки.</p>
	 
	 <p>При вызове метода <codeph>NetStream.play()</codeph>, в котором параметр <codeph>checkPolicyFile</codeph> имеет значение <codeph>true</codeph>, приложение <ph platform="actionscript">Flash Player или</ph> AIR должно успешно загрузить соответствующий файл междоменных политик или определить, что такой файл не существует, и только потом перейти к загрузке объекта, указанного в вызове <codeph>NetStream.play()</codeph>. Чтобы убедиться в существовании файла политик, приложение <ph platform="actionscript">Flash Player или</ph> AIR выполняет следующие действия в указанном ниже порядке:</p>
	 
	 <ol>
	 
     <li>Приложение анализирует ранее загруженные файлы политик.</li>
	 
	 <li>Приложение пытается загрузить любые файлы действующих политик, указанные в вызовах метода <codeph>Security.loadPolicyFile()</codeph>.</li>
	 
	 <li>Приложение производит попытку загрузить файл политик из местоположения по умолчанию, которое соответствует URL-адресу, переданному <codeph>NetStream.play()</codeph> (файл <codeph>/crossdomain.xml</codeph> на том же сервере, что и данный URL-адрес).</li>
	 
	 </ol>
	 
	 <p>Во всех случаях для работы приложения <ph platform="actionscript">Flash Player или </ph>AIR требуется, чтобы на сервере видеоданных существовал подходящий файл политики, чтобы он предоставлял доступ к объекту по URL-адресу, переданному методу <codeph>play()</codeph> на основе места размещения файла политики, а также, чтобы он обеспечивал домену вызывающего файла доступ к видео посредством одного или нескольких тегов <codeph>&lt;allow-access-from></codeph>.</p>
	 
	 <p>Если установить для параметра <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>, то перед тем как загрузить видео, приложение будет ожидать проверки файла политики. Чтобы выполнять какие-либо операции по обработке видеоданных на уровне пикселей (например, вызов <codeph>BitmapData.draw()</codeph>), следует дождаться получения от своего объекта NetStream событий <codeph>onMetaData</codeph> или <codeph>NetStatus</codeph>.</p>
	 
	 <p>Если для параметра <codeph>checkPolicyFile</codeph> задано значение <codeph>true</codeph>, но при этом соответствующий файл политики не найден, сообщение об ошибке не будет получено до тех пор, пока не будет выполнена операция, требующая файл политики, после чего приложение выдаст исключение SecurityError.</p>
	 
	 <p>Будьте внимательны при установке параметра <codeph>checkPolicyFile</codeph>, если вы загружаете файл с URL-адреса, в котором используется HTTP-переадресация на стороне сервера. Приложение выполняет попытку извлечь файлы политики, соответствующие первоначальному URL-адресу, который указывается в <codeph>NetStream.play()</codeph>. Если из-за HTTP-переадресации конечный файл поступает с другого URL-адреса, первоначально загруженные файлы политик могут не применяться в отношении конечного URL-адреса файла. С точки зрения безопасности, именно этот URL-адрес представляет большую важность.</p>
	 
	 <p>Дополнительные сведения о файлах политик см. в главе «Система безопасности проигрывателя Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link><link href="flash.net.xml#NetStream/event:netStatus"><linktext>netStatus</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>play()</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:client:get"><apiName>client</apiName><shortdesc>
     Задает объект, для которого вызываются методы обратного вызова для обработки потоковой передачи или данных FLV-файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>В качестве свойства <codeph>client</codeph> должен быть указан ненулевой объект.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Задает объект, для которого вызываются методы обратного вызова для обработки потоковой передачи или данных FLV-файла. Объект по умолчанию: <codeph>this</codeph> (создаваемый объект NetStream). Если в свойстве <codeph>client</codeph> указать другой объект, методы обратного вызова будут вызываться на этом другом объекте. Объект <codeph>NetStream.client</codeph> может вызывать следующие функции и получать связанный объект данных: <codeph>onCuePoint()</codeph>, <codeph>onImageData()</codeph>, <codeph>onMetaData()</codeph>, <codeph>onPlayStatus()</codeph> <codeph>onTextData()</codeph> и <codeph>onXMPData</codeph>.
     <p><b>Чтобы связать свойство <codeph>client</codeph> с обработчиком событий, выполните следующие действия.</b></p>
     <p><ol><li>Создайте объект и назначьте его свойству <codeph>client</codeph> объекта NetStream:
     <codeblock>
     var customClient:Object = new Object();
     my_netstream.client = customClient;
     </codeblock>
     </li>
     <li>Назначьте функцию обработчика для нужного события данных в качестве свойства объекта Client:
     <codeblock>
     customClient.onImageData = onImageDataHandler;           
     </codeblock>
     </li>
     <li>Напишите функцию обработчика для получения объекта события данных, такого как:
     <codeblock>
      public function onImageDataHandler(imageData:Object):void {
              trace("imageData length: " + imageData.data.length);
      }
     </codeblock></li>
     </ol></p>
     <p>Когда данные передаются через поток или при воспроизведении, объект события данных (в данном случае это объект <codeph>imageData</codeph>) заполняется данными. См. описание <codeph>onImageData</codeph>, содержащее полный пример объекта, назначенного свойству <codeph>client</codeph>.</p>
     <p><b>Чтобы связать свойство <codeph>client</codeph> с подклассом, выполните следующие действия.</b></p>
     <p><ol><li>Создайте подкласс с функцией обработчика, чтобы получить объект события данных:
     <codeblock>
     class CustomClient {
        public function onMetaData(info:Object):void {
            trace("metadata: duration=" + info.duration + " framerate=" + info.framerate);
     }
     </codeblock>
     </li>
     <li>Назначьте экземпляр подкласса свойству <codeph>client</codeph> объекта NetStream:
     <codeblock>
     my_netstream.client = new CustomClient();
     </codeblock>
     </li>
     </ol></p>     
     <p>Когда данные передаются через поток или при воспроизведении, объект события данных (в данном случае это объект <codeph>info</codeph>) заполняется данными. В конце описания класса NetStream приводится пример, демонстрирующий назначение экземпляра подкласса свойству <codeph>client</codeph>.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/event:onCuePoint"><linktext>onCuePoint</linktext></link><link href="flash.net.xml#NetStream/event:onImageData"><linktext>onImageData</linktext></link><link href="flash.net.xml#NetStream/event:onMetaData"><linktext>onMetaData</linktext></link><link href="flash.net.xml#NetStream/event:onPlayStatus"><linktext>onPlayStatus</linktext></link><link href="flash.net.xml#NetStream/event:onTextData"><linktext>onTextData</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:currentFPS:get"><apiName>currentFPS</apiName><shortdesc>
	 Число кадров, отображаемых за одну секунду.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.currentFPS, currentFPS
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число кадров, отображаемых за одну секунду. При экспорте видеофайлов для воспроизведения на нескольких системах можно проверить это значение в процессе тестирования, чтобы определить, какой уровень сжатия необходим при экспортировании файла.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farID:get"><apiName>farID</apiName><shortdesc>
     Идентификатор удаленного узла, подключенного к данному экземпляру NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Идентификатор удаленного узла, подключенного к данному экземпляру <codeph>NetStream</codeph>. Это свойство определяется только для подключений RTMFP.
     
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     Значение, выбираемое преимущественно на другом конце этого потока (уникальное в отношении данного подключения).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение, выбираемое преимущественно на другом конце этого потока (уникальное в отношении данного подключения). Это значение появляется на другом конце потока в качестве его значения <codeph>nearNonce</codeph>. Это свойство определяется только для подключений RTMFP.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:info:get"><apiName>info</apiName><shortdesc>
     Возвращает объект NetStreamInfo, свойства которого содержат статистические данные о качестве обслуживания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.net:NetStreamInfo</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает объект NetStreamInfo, свойства которого содержат статистические данные о качестве обслуживания. Объект представляет собой снимок текущего состояния. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo"><linktext>NetStreamInfo</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:liveDelay:get"><apiName>liveDelay</apiName><shortdesc>
	 Число секунд данных в буфере подписывающего потока в режиме реального времени (небуферизованном).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><category>Property
	 
	 </category></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Число секунд данных в буфере подписывающего потока в режиме реального времени (небуферизованном). Данное свойство указывает текущую задержку в сетевой передаче данных (время запаздывания).
	 
	 <p>Данное свойство используется преимущественно для работы с сервером Flash Media Server (более подробную информацию см. в описании класса).</p>
	 
	 <p>С помощью значения этого свойства можно приблизительно измерить качество передачи потока и сообщить результат пользователю. </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:maxPauseBufferTime:set"><apiName>maxPauseBufferTime</apiName><shortdesc>
     Задает время буферизации сообщений во время режима паузы (в секундах).</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Задает время буферизации сообщений во время режима паузы (в секундах). Это свойство можно использовать для ограничения времени буферизации во время режима паузы. По достижении предельного значения <codeph>NetStream.bufferLength</codeph> буферизация прекращается. Если это значение не задано, по умолчанию используется ограничение 60 секунд или удвоенное значение <codeph>NetStream.bufferTime</codeph> при каждой паузе в зависимости от того, какое значение выше.
     </apiDesc></apiValueDetail><related-links><link href="" invalidHref="flash.net.xml#maxPauseBufferTime/bufferTime"><linktext>bufferTime</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     Значение, выбираемое преимущественно на этом конце потока (уникальное в отношении данного подключения).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение, выбираемое преимущественно на этом конце потока (уникальное в отношении данного подключения). Это значение появляется на другом конце потока в качестве его значения <codeph>farNonce</codeph>. Это свойство определяется только для подключений RTMFP.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 Кодировка объекта (версия AMF) для данного объекта NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Кодировка объекта (версия AMF) для данного объекта NetStream. Объект NetStream наследует значение <codeph>objectEncoding</codeph> от соответствующего объекта NetConnection. Необходимо хорошо понимать назначение этого свойства, если вашему SWF-файлу версии ActionScript 3.0 требуется обмен данными с серверами, программное обеспечение которых было выпущено до выхода Flash Player версии 9. Подробные сведения см. в описании свойства <codeph>objectEncoding</codeph> для класса NetConnection.
	 
	 <p>Значение этого свойства зависит от того, каким является данный поток – локальным или удаленным. Локальные потоки, в которых значение <codeph>null</codeph> было передано методу <codeph>NetConnection.connect()</codeph>, возвращают значение <codeph>NetConnection.defaultObjectEncoding</codeph>. Удаленные потоки возвращают кодировку объекта для подключения к серверу.</p>
	 
	 <p>При попытке прочитать это свойство при отсутствии подключения или при попытке его изменить приложение выдаст исключение.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:peerStreams:get"><apiName>peerStreams</apiName><shortdesc>
	 
     Объект, содержащий все подписывающие экземпляры NetStream, прослушивающие этот публикующий экземпляр NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 
     Объект, содержащий все подписывающие экземпляры NetStream, прослушивающие этот публикующий экземпляр NetStream.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStream:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 Управляет звуком в данном объекте NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 Управляет звуком в данном объекте NetStream. Дополнительную информацию см. в описании класса SoundTransform.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStream:time:get"><apiName>time</apiName><shortdesc>
	 Положение точки воспроизведения (в секундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetStream.time, time
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Положение точки воспроизведения (в секундах).
	 <p>
	 <b>Flash Media Server</b> Для подписывающего потока – число секунд воспроизведения потока. Для публикующего потока – продолжительность публикации потока (в секундах). Это число используется с точностью до тысячных долей. Умножьте его на 1000, чтобы получить число миллисекунд воспроизведения потока.
	 </p>
	 <p>
	 Если для подписывающего потока сервер прекращает отправку данных, но при этом сам поток остается открытым, то значение свойства <codeph>time</codeph> перестает увеличиваться. Когда сервер начинает повторную отправку данных, значение, которое существовало на момент прекращения отправки данных сервером, продолжает увеличиваться. 
	 </p>
	 <p>
     Значение <codeph>time</codeph> продолжает увеличиваться, когда поток переключается с одного элемента списка воспроизведения на другой. Данное свойство получает значение 0, когда <codeph>NetStream.play()</codeph> вызывается с параметром <codeph>reset</codeph>, значение которого равно <codeph>1</codeph> или <codeph>true</codeph>, а также при вызове метода <codeph>NetStream.close()</codeph>. 
	 </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/bufferLength"><linktext>bufferLength</linktext></link><link href="flash.net.xml#NetStream/bytesLoaded"><linktext>bytesLoaded</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
 Класс LocalConnection позволяет создать объект LocalConnection, который может вызвать метод в другом объекте LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс LocalConnection позволяет создать объект LocalConnection, который может вызвать метод в другом объекте LocalConnection. Обмен данными может осуществляться:
 
 <ul>
 		<li>В пределах одного SWF-файла</li>
 		<li>Между несколькими SWF-файлами</li>
 		<li>Между содержимым (на базе SWF или HTML) приложений AIR</li>
		<li>Между содержимым (на базе SWF или HTML) приложения AIR и содержимым SWF, выполняющимся в обозревателе</li>
 </ul>
 
 <p>Локальные подключения обеспечивают подобное взаимодействие между SWF-файлами, не требующее использования <codeph>fscommand()</codeph> или JavaScript. Объекты LocalConnection могут обмениваться данными только с файлами, запущенными на том же клиентском компьютере, но при этом могут быть запущены в различных приложениях (например, файл, запущенный в обозревателе, и SWF-файл, запущенный в Adobe AIR). </p>
 
 <p platform="actionscript">Объекты LocalConnection, созданные в ActionScript 3.0, могут взаимодействовать с объектами LocalConnection, созданными в ActionScript 1.0 или 2.0. То же самое верно также в обратном направлении: объекты LocalConnection, созданные в ActionScript 1.0 или 2.0, могут взаимодействовать с объектами LocalConnection, созданными в ActionScript 3.0. Проигрыватель Flash Player автоматически обрабатывает связь между объектами LocalConnection разных версий.</p>
 
 <p>Для того чтобы разобраться в применении объектов LocalConnection для реализации механизма взаимодействия между двумя файлами, рекомендуется определить команды, используемые в каждом файле. Один из файлов называется <i>отправляющим</i> – в этом файле содержится вызываемый метод. Отправляющий файл должен содержать объект LocalConnection и вызов метода <codeph>send()</codeph>. Второй файл называется <i>принимающим</i>. Этот файл и будет вызывать упомянутый метод. Принимающий файл должен содержать другой объект LocalConnection и вызов метода <codeph>connect()</codeph>.</p>
 
 <p>Применение <codeph>send()</codeph> и <codeph>connect()</codeph> зависит от размещения файлов: в том же домене, в разных доменах с предсказуемыми именами доменов или в разных доменах с непредсказуемыми или динамическими именами. В последующих абзацах описываются три разные ситуации (с примерами кода для каждой из них).</p>
 
 <p><b>Один и тот же домен</b>. Это самый простой способ использования объекта LocalConnection, обеспечивающий обмен данными только между теми объектами LocalConnection, которые размещены в одном и том же домене, так как взаимодействие внутри одного домена разрешено по умолчанию. При взаимодействии двух файлов из одного домена не требуется обеспечивать какие-либо специальные меры безопасности. Просто передайте одинаковое значение параметру <codeph>connectionName</codeph> для методов <codeph>connect()</codeph> и <codeph>send()</codeph>:</p>
 
 <p><adobeimage alt="Загрузка из одного и того же домена" href="../../images/localconnection_samedomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.connect('myConnection');

// sendingLC is in http://www.domain.com/sending.swf
// myMethod() is defined in sending.swf
sendingLC.send('myConnection', 'myMethod');
</codeblock>
 <p><b>Разные домены с предсказуемыми именами</b>. При взаимодействии двух SWF-файлов из разных доменов необходимо разрешить обмен данными между двумя доменами путем вызова метода <codeph>allowDomain()</codeph>. Также следует определить имя домена принимающего объекта LocalConnection как имя подключения в методе <codeph>send()</codeph>:</p>
 
 <p><adobeimage alt="Загрузка с разных доменов" href="../../images/localconnection_differentdomains.gif"/></p>
 
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('www.anotherdomain.com');
receivingLC.connect('myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('www.domain.com:myConnection', 'myMethod');
</codeblock>
 
 <p><b>Разные домены с непредсказуемыми именами</b>. В некоторых случаях может потребоваться обеспечить большую междоменную мобильность файла с принимающим объектом LocalConnection. Для того чтобы сообщить проигрывателю Flash Player о том, что принимающий и отправляющий объекты LocalConnection находятся в разных доменах, но при этом не указывать имя домена в методе <codeph>send()</codeph>, поставьте перед именем подключения символ подчеркивания (_) в вызовах <codeph>connect()</codeph> и <codeph>send()</codeph>. Для обеспечения обмена данными между двумя доменами, вызовите метод <codeph>allowDomain()</codeph> и укажите домены, с которых следует разрешить вызовы LocalConnection. Также, чтобы разрешить вызовы со всех доменов, следует передать аргумент с подстановочным знаком (~~):</p>
 
 <p><adobeimage alt="Загрузка с неизвестных доменных имен" href="../../images/localconnection_unknowndomains.gif"/></p>
<codeblock>
// receivingLC is in http://www.domain.com/receiving.swf
receivingLC.allowDomain('~~');
receivingLC.connect('_myConnection');

// sendingLC is in http://www.anotherdomain.com/sending.swf
sendingLC.send('_myConnection', 'myMethod');
</codeblock>
 
 <p>Объекты LocalConnection можно использовать для отправки и получения данных внутри отдельного файла, но такое применение не является стандартным.</p>
 
 <p>Более подробную информацию о методах <codeph>send()</codeph> и <codeph>connect()</codeph> см. в обсуждении параметра <codeph>connectionName</codeph> в разделах, посвященных <codeph>LocalConnection.send()</codeph> и <codeph>LocalConnection.connect()</codeph>. Также см. материалы по <codeph>allowDomain()</codeph> и <codeph>domain</codeph>.</p>
 
 </apiDesc><example conref="examples\LocalConnectionSenderExample.as"> Данный пример состоит из двух классов ActionScript, которые должны быть скомпилированы в два отдельных SWF-файла:
 
 <p>В SWF-файле LocalConnectionSenderExample создается экземпляр LocalConnection. При нажатии на кнопку с помощью метода <codeph>call()</codeph> вызывается метод с именем <codeph>lcHandler</codeph> в SWF-файле с именем подключения myConnection, при этом в качестве параметра передается содержимое TextField.</p>
 
 <p>В SWF-файле LocalConnectionReceiverExample создается экземпляр LocalConnection, а затем с помощью вызванного метода <codeph>connect()</codeph> данный SWF-файл определяется как получатель сообщений, адресованных подключению myConnection. Вдобавок, в данный класс входит публичный метод <codeph>lcHandler()</codeph>, который вызывается SWF-файлом LocalConnectionSenderExample. При вызове этого метода текст, переданный в качестве параметра, прикрепляется к полю TextField в компоненте Stage.</p>
 
 <p><b>Примечание.</b> Чтобы протестировать этот пример, необходимо одновременно загрузить на одном компьютере оба SWF-файла.</p>
<codeblock>

// Code in LocalConnectionSenderExample.as
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.net.LocalConnection;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.StatusEvent;
    import flash.text.TextFieldAutoSize;

    public class LocalConnectionSenderExample extends Sprite {
        private var conn:LocalConnection;
        
        // UI elements
        private var messageLabel:TextField;
        private var message:TextField;
        private var sendBtn:Sprite;
        
        public function LocalConnectionSenderExample() {
            buildUI();
            sendBtn.addEventListener(MouseEvent.CLICK, sendMessage);
            conn = new LocalConnection();
            conn.addEventListener(StatusEvent.STATUS, onStatus);
        }
        
        private function sendMessage(event:MouseEvent):void {
            conn.send("myConnection", "lcHandler", message.text);
        }
        
        private function onStatus(event:StatusEvent):void {
            switch (event.level) {
                case "status":
                    trace("LocalConnection.send() succeeded");
                    break;
                case "error":
                    trace("LocalConnection.send() failed");
                    break;
            }
        }
        
        private function buildUI():void {
            const hPadding:uint = 5;
            // messageLabel
            messageLabel = new TextField();
            messageLabel.x = 10;
            messageLabel.y = 10;
            messageLabel.text = "Text to send:";
            messageLabel.autoSize = TextFieldAutoSize.LEFT;
            addChild(messageLabel);
            
            // message
            message = new TextField();
            message.x = messageLabel.x + messageLabel.width + hPadding;
            message.y = 10;
            message.width = 120;
            message.height = 20;
            message.background = true;
            message.border = true;
            message.type = TextFieldType.INPUT;
            addChild(message);
            
            // sendBtn
            sendBtn = new Sprite();
            sendBtn.x = message.x + message.width + hPadding;
            sendBtn.y = 10;
            var sendLbl:TextField = new TextField();
            sendLbl.x = 1 + hPadding;
            sendLbl.y = 1;
            sendLbl.selectable = false;
            sendLbl.autoSize = TextFieldAutoSize.LEFT;
            sendLbl.text = "Send";
            sendBtn.addChild(sendLbl);
            sendBtn.graphics.lineStyle(1);
            sendBtn.graphics.beginFill(0xcccccc);
            sendBtn.graphics.drawRoundRect(0, 0, (sendLbl.width + 2 + hPadding + hPadding), (sendLbl.height + 2), 5, 5);
            sendBtn.graphics.endFill();
            addChild(sendBtn);
        }
    }
}
</codeblock></example><example conref="examples\LocalConnectionReceiverExample.as"><codeblock>
// Code in LocalConnectionReceiverExample.as
package {
    import flash.display.Sprite;
    import flash.net.LocalConnection;
    import flash.text.TextField;

    public class LocalConnectionReceiverExample extends Sprite {
        private var conn:LocalConnection;
        private var output:TextField;
        
        public function LocalConnectionReceiverExample()     {
            buildUI();
            
            conn = new LocalConnection();
            conn.client = this;
            try {
                conn.connect("myConnection");
            } catch (error:ArgumentError) {
                trace("Can't connect...the connection name is already being used by another SWF");
            }
        }
        
        public function lcHandler(msg:String):void {
            output.appendText(msg + "\n");
        }
        
        private function buildUI():void {
            output = new TextField();
            output.background = true;
            output.border = true;
            output.wordWrap = true;
            addChild(output);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection_flash.events.StatusEvent.STATUS_status"><apiName>status</apiName><shortdesc>
 Отправляется, когда объект LocalConnection сообщает о своем состоянии.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.StatusEvent.STATUS</apiEventType><adobeApiEventClassifier>flash.events.StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда объект LocalConnection сообщает о своем состоянии. При успешном вызове <codeph>LocalConnection.send()</codeph> свойство <codeph>level</codeph> объекта события <codeph>status</codeph> получает значение <codeph>status</codeph>. В противном случае свойство <codeph>level</codeph> имеет значение <codeph>error</codeph>. Если принимающий файл отказывает в подключении, сбой вызова может произойти без оповещения отправляющего файла. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>LocalConnection.send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Отправляется, если путем вызова метода LocalConnection.send() предпринимается попытка отправить данные в другую изолированную среду.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если путем вызова метода <codeph>LocalConnection.send()</codeph> предпринимается попытка отправить данные в другую изолированную среду.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>send()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Отправляется, когда исключение создается асинхронным образом &amp;#x2014; то есть в коде, изначально имеющем асинхронную природу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда исключение создается асинхронным образом, то есть в коде, изначально имеющем асинхронную природу. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:LocalConnection:LocalConnection"><apiName>LocalConnection</apiName><shortdesc>
	 Создает объект LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how receiving and sending files create LocalConnnection objects. 
	 The two files can use the same name or different names for their respective LocalConnection objects. 
	 In this example they use different names.
	 
	 <listing>
	 // Code in the receiving file
	 this.createTextField("result_txt", 1, 10, 10, 100, 22);
	 result_txt.border = true;
	 var receiving_lc:LocalConnection = new LocalConnection();
	 receiving_lc.methodToExecute = function(param1:Number, param2:Number) {
	   result_txt.text = param1+param2;
	 };
	 receiving_lc.connect("lc_name");
	 </listing>
	 
	 <p>The following file sends the request to the first file.</p>
	 
	 <listing>
	 // Code in the sending file
	 var sending_lc:LocalConnection = new LocalConnection();
	 sending_lc.send("lc_name", "methodToExecute", 5, 7);
	 </listing>
	 
	 </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Создает объект LocalConnection. С помощью объектов LocalConnection можно обеспечить обмен данными между различными файлами, запущенными на одном и том же клиентском компьютере.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:LocalConnection:allowDomain"><apiName>allowDomain</apiName><shortdesc>
	 Задает один или несколько доменов, которые могут направлять вызовы LocalConnection к данному экземпляру LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Change the first example in the listing.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Все указанные параметры должны быть ненулевыми строками.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Одна или несколько строк, называющих домены, с которых необходимо разрешить вызовы LocalConnection. Данный параметр имеет два особых случая:
	 
	 <ul>
	   <li>Чтобы разрешить вызовы со всех доменов, можно указать подстановочный знак «~~».</li>
	 
	   <li>Определение строки <codeph>localhost</codeph> обеспечивает вызовы данного файла от локально установленных файлов. <ph platform="actionscript"> В проигрыватель Flash Player 8 были внесены ограничения в сфере безопасности локальных файлов. По умолчанию SWF-файл, который выполняется в проигрывателе Flash Player и которому разрешен доступ к Интернету, не может иметь доступ к локальной файловой системе. В проигрывателе Flash Player, если вы определите <codeph>localhost</codeph>, данный SWF-файл будет доступен любому локальному SWF-файлу. </ph> </li>
	 
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает один или несколько доменов, которые могут направлять вызовы LocalConnection к данному экземпляру LocalConnection.
	 
	 <p>Данный метод нельзя использовать в целях предоставления файлам, размещенным по незащищенным протоколам, доступа к файлам, размещенным с помощью защищенного протокола (HTTPS). Вместо этого используйте метод <codeph>allowInsecureDomain()</codeph>.</p> 
	 
	 <p>Этот метод можно использовать для того, чтобы нижестоящий файл из другого домена мог осуществлять вызовы LocalConnection, направленные вышестоящему файлу, при этом не будет известен конечный домен, который будет источником нижестоящего файла. Это может случиться, например, при использовании перенаправлений для балансировки нагрузки или серверов независимых производителей. В этой ситуации можно с помощью свойства <codeph>url</codeph>, используемого с нагрузкой объекта LoaderInfo, получить домен для использования с методом <codeph>allowDomain()</codeph>. Например, рассмотрим ситуацию использования объекта Loader для загрузки дочернего файла. Как только файл будет загружен, можно будет просмотреть свойство <codeph>contentLoaderInfo.url</codeph> объекта Loader и извлечь домен из строки полного URL-адреса. При этом необходимо дождаться полной загрузки файла, так как свойство <codeph>contentLoaderInfo.url</codeph> будет иметь свое конечное правильное значение только после завершения загрузки файла. </p> 
	 
	 <p>Также может возникнуть и противоположная ситуация: создан нижестоящий файл, которому необходимо принимать вызовы LocalConnection от вышестоящего файла, но домен вышестоящего объекта неизвестен. В этой ситуации реализация данного метода подразумевает следующую проверку: совпадает ли аргумент домена с доменом свойства <codeph>loaderInfo.url</codeph> в загруженном файле. Здесь также необходимо извлечь домен из полного URL-адреса в свойстве <codeph>loaderInfo.url</codeph>. В этой ситуации нет необходимости ждать загрузки вышестоящего файла – он уже будет загружен к тому времени, когда будет проходить загрузка нижестоящего файла.</p> 
	 
	 <p platform="actionscript">При использовании данного метода необходимо продумать модель безопасности проигрывателя Flash Player. По умолчанию объект LocalConnection связан с изолированной программной средой создавшего его файла, при этом вызовы объектов LocalConnection между доменами запрещены, если только вы не вызываете метод <codeph>LocalConnection.allowDomain()</codeph> в принимающем файле. Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p>
	 
	 <p platform="actionscript">Дополнительные сведения см. в следующих источниках.</p>
	 
     <ul platform="actionscript">
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
	 <p platform="actionscript"><b>Примечание</b>. Метод <codeph>allowDomain()</codeph> изменился по сравнению с тем, каким он был в ActionScript 1.0 и 2.0. В этих ранних версиях <codeph>allowDomain</codeph> представлял собой реализованный метод обратного вызова. В ActionScript 3.0 <codeph>allowDomain()</codeph> является встроенным методом вызываемого LocalConnection. После этого изменения <codeph>allowDomain()</codeph> функционирует практически так же, как и <codeph>flash.system.Security.allowDomain()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowInsecureDomain()"><linktext>flash.net.LocalConnection.allowInsecureDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
	 Задает один или несколько доменов, которые могут направлять вызовы LocalConnection к данному объекту LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Seems like a security note is in order here.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Все указанные параметры должны быть строками, имеющими значение, отличное от null.
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Одна или несколько строк, называющих домены, с которых необходимо разрешить вызовы LocalConnection. Для данного параметра существуют два особых случая:
	 <ul>
	   <li>Чтобы разрешить вызовы со всех доменов, можно указать подстановочный знак «~~». Определение «~~» не включает в себя локальные узлы.</li>
	   <li>Определение строки <codeph>localhost</codeph> обеспечивает вызовы данного SWF-файла от локально установленных SWF-файлов. В проигрыватель Flash Player 8 были внесены ограничения в сфере безопасности локальных SWF-файлов. SWF-файл, которому разрешен доступ к Интернету, не может иметь доступ к локальной файловой системе. Если вы определите <codeph>localhost</codeph>, данный SWF-файл будет доступен любому локальному SWF-файлу. Помните, что во время разработки вызывающий SWF-файл должен быть обозначен как локальный с сетевым подключением во время авторизации.</li>
	 </ul>
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает один или несколько доменов, которые могут направлять вызовы LocalConnection к данному объекту LocalConnection.  
	 
	 <p>Метод <codeph>allowInsecureDomain()</codeph> функционирует так же, как и <codeph>allowDomain()</codeph>, за исключением того, что метод <codeph>allowInsecureDomain()</codeph> дополнительно разрешает SWF-файлам, поступившим не по протоколу HTTPS, отправлять вызовы LocalConnection в адрес файлов, полученных по протоколу HTTPS. Это различие имеет значение только в том случае, если метод <codeph>allowInsecureDomain()</codeph> вызывается из файла, который был загружен по протоколу HTTPS. Метод <codeph>allowInsecureDomain()</codeph> следует вызывать даже в том случае, если происходит пересечение границ HTTPS/HTTPS в рамках одного домена. По умолчанию вызовы LocalConnection, направленные от файлов, поступивших не по протоколу HTTPS, к файлам, загруженным с помощью протокола HTTPS, всегда запрещены даже в рамках одного и того же домена.</p>
	 
	 <p>Не рекомендуется вызывать метод <codeph>allowInsecureDomain()</codeph>, так как он может нарушить безопасность, обеспечиваемую протоколом HTTPS. При загрузке файла по протоколу HTTPS у вас должна присутствовать обоснованная уверенность в том, что в процессе доставки по сети на данный файл не будет оказываться никакого вредного воздействия. Если вы позднее разрешите файлу, поступившему не по протоколу HTTPS, делать вызовы LocalConnection в отношении файла, загруженного с помощью HTTPS, то тем самым вы будете принимать вызовы от файла, который мог в процессе доставки подвергнуться вмешательству. Это, как правило, требует особой осторожности, так как нельзя быть полностью уверенным в подлинности вызовов LocalConnection, поступающих вашему файлу по протоколу HTTPS.</p>
	 
	 <p>По умолчанию файлы, размещенные с помощью протокола HTTPS, доступны только для любых других файлов, размещенных посредством того же протокола (HTTPS). Такая реализация позволяет сохранить целостность, обеспечиваемую протоколом HTTPS.</p>
	 
	 <p>Не рекомендуется использовать этот метод для переназначения характеристик по умолчанию, так как это может ослабить систему защиты протокола HTTPS. Тем не менее, это может потребоваться, например, если вам необходимо разрешить HTTP-файлам, опубликованным для Flash Player 6 и более ранних версий, доступ к HTTPS-файлам, опубликованным для Flash Player 9 и более поздних версий.</p>
	 
	 <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:close"><apiName>close</apiName><shortdesc>
	 Закрывает (отключает) объект LocalConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.close, close
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Экземпляр LocalConnection не подключен, поэтому не может быть закрыт.
	 
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Закрывает (отключает) объект LocalConnection. Запустите данную команду, если больше не требуется, чтобы объект принимал команды, например при необходимости инициировать команду <codeph>connect()</codeph> с помощью того же самого параметра <codeph>connectionName</codeph> в другом SWF-файле.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:connect"><apiName>connect</apiName><shortdesc>
	 Подготавливает объект LocalConnection к получению команд от команды send() (вызываемой отправляющим объектом LocalConnection).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.connect, connect
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Параметру <codeph>connectionName</codeph> следует передавать ненулевое значение.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка может возникнуть по трем причинам: 1) Параметру <codeph>connectionName</codeph> было передано нулевое значение строки. Передайте ненулевое значение. 2) Значение, переданное параметру <codeph>connectionName</codeph>, содержало двоеточие (:). Двоеточие используется как специальный символ для отделения супердомена от строки <codeph>connectionName</codeph> в методе <codeph>send()</codeph>, а не в методе <codeph>connect()</codeph>. 3) Экземпляр LocalConnection уже подключен.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, которая соответствует имени подключения, указанному в команде <codeph>connect()</codeph>, которой требуется взаимодействие с принимающим объектом LocalConnection. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Подготавливает объект LocalConnection к получению команд от команды <codeph>send()</codeph> (вызываемой отправляющим объектом <i>LocalConnection</i>). Используемый с этой командой объект называется <i>принимающим объектом LocalConnection</i>. Принимающий и отправляющий объекты должны запускаться с одного и того же клиентского компьютера.
	 
	 <p>Чтобы избежать состязания, определите методы, прикрепленные к принимающему объекту LocalConnection, до вызова данного метода, как показано в примере с классом LocalConnection. </p>
	 
	 <p>По умолчанию аргумент <codeph>connectionName</codeph> преобразуется в значение <codeph><i>superdomain</i>:connectionName</codeph>, в котором <codeph><i>superdomain</i></codeph> – это супердомен файла, содержащего команду <codeph>connect()</codeph>. Например, если файл, содержащий принимающий объект LocalConnection, размещается по адресу www.someDomain.com, то <codeph>connectionName</codeph> преобразуется в <codeph>someDomain.com:connectionName</codeph>. (Если файл, выполняющийся в проигрывателе Flash Player, размещается на клиентском компьютере, то параметру <codeph>superdomain</codeph> присваивается значение <codeph>localhost</codeph>.)</p>
	 
	 <p>В содержимом, выполняющемся в изолированной программной среде безопасности <codeph>application</codeph> в Adobe AIR (содержимое, установленное с приложением AIR), среда выполнения использует строку <codeph>app#</codeph>, за которой следует идентификатор приложения AIR (определенный в файле дескриптора приложения), вместо обозначения супердомена. Например, <codeph>connectionName</codeph> для приложения с идентификатором <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> преобразуется в <codeph>app#com.example.air.MyApp:connectionName</codeph>.</p>
	 
	 <p>Вдобавок, по умолчанию проигрыватель Flash Player позволяет принимающему объекту LocalConnection принимать команды только от отправляющих объектов LocalConnection, имя подключения которых также преобразовывается в значение <codeph>"</codeph><codeph><i>superdomain</i></codeph><codeph>:connectionName"</codeph>. Таким образом файлам, размещенным в одном домене, становится проще взаимодействовать друг с другом.</p>
	 
	 <p>Если вы реализуете механизм взаимодействия только между файлами в рамках одного домена, укажите строку для <codeph>connectionName</codeph>, которая не будет начинаться с символа подчеркивания (_) и не будет определять имя домена (например, <codeph>myDomain:connectionName</codeph>). Используйте ту же самую строку в методе <codeph>connect(connectionName)</codeph>.</p>
	 
	 <p>При реализации механизма взаимодействия файлов в разных доменах определение строки для параметра <codeph>connectionName</codeph>, в начале которой стоит символ подчеркивания (_), обеспечивает большую междоменную мобильность файла с принимающим объектом LocalConnection. Далее представлены два возможных варианта:</p>
	 
	 <ul>
	 
	   <li>Если строка для <codeph>connectionName</codeph> не начинается с символа подчеркивания (_), добавляется префикс с супердоменом и двоеточием (например, <codeph>myDomain:connectionName</codeph>). Несмотря на то, что это гарантирует отсутствие конфликтов вашего подключения с подключениями под тем же именем, но из других доменов, любые отправляющие объекты LocalConnection должны указывать данный супердомен (например, <codeph>myDomain:connectionName</codeph>). Если файл с принимающим объектом LocalConnection перемещается в другой домен, то проигрыватель изменяет префикс, чтобы отразить наличие нового супердомена (например, <codeph>anotherDomain:connectionName</codeph>). Может потребоваться вручную отредактировать все отправляющие объекты LocalConnection так, чтобы они указывали на новый супердомен.</li>
	 
	   <li>Если строка для <codeph>connectionName</codeph> начинается с символа подчеркивания (например, <codeph>_connectionName</codeph>), префикс к строке не добавляется. Это означает, что принимающий и отправляющий объекты LocalConnection используют идентичные строки для параметра <codeph>connectionName</codeph>. Если с помощью <codeph>allowDomain()</codeph> принимающий объект указывает, что будут приниматься подключения с любого домена, то файл с принимающим объектом LocalConnection может быть перемещен в другой домен без изменения каких-либо отправляющих объектов LocalConnection.</li>
	 </ul>
	 
	 <p>Дополнительные сведения см. в обзоре класса и обсуждении параметра <codeph>connectionName</codeph> в методе<codeph>send()</codeph>, а также в материалах по <codeph>allowDomain()</codeph> и <codeph>domain</codeph>.</p>
	 
	 <p><b>Примечание. </b>Двоеточие используется как специальный символ для отделения супердомена от строки <codeph>connectionName</codeph>. Строка для параметра <codeph>connectionName</codeph>, содержащая двоеточие, является недопустимой.</p>
	 
	 <p>При использовании этого метода <ph platform="javascript">в содержимом, находящемся в защищенных изолированных средах, отличных от защищенной изолированной среды приложения</ph>, необходимо учитывать модель безопасности <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR </ph>. По умолчанию объект LocalConnection связан с изолированной программной средой создавшего его файла, при этом вызовы объектов LocalConnection между доменов запрещены, если только вы не вызываете метод <codeph>LocalConnection.allowDomain()</codeph> в принимающем файле. <ph platform="actionscript"> Можно запретить использование файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое. </ph>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
	 
	 <p>Дополнительные сведения см. в следующих источниках.</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/send()"><linktext>flash.net.LocalConnection.send()</linktext></link><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links></apiOperation><apiOperation id="flash.net:LocalConnection:send"><apiName>send</apiName><shortdesc>
	 Вызывает метод с именем methodName для подключения, открытого методом connect (connectionName) (принимающий объект LocalConnection).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.send, send
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Значение <codeph>connectionName</codeph> или <codeph>methodName</codeph> равно null. Установите для данных параметров значения, отличные от null.
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка может возникнуть по одной из следующих причин: 1) В качестве значения <codeph>connectionName</codeph> или <codeph>methodName</codeph> выступает пустая строка. Передайте для этих параметров допустимые строки. 2) Метод, указанный в параметре <codeph>methodName</codeph>, является ограниченным. 3) Слишком большой размер отправленного сериализованного сообщения (свыше 40 КБ).
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>connectionName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Соответствует имени подключения, указанному в команде <codeph>connect()</codeph>, которой требуется взаимодействие с отправляющим объектом LocalConnection. 	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>methodName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя метода, вызываемого в принимающем объекте LocalConnection. Следующие имена методов приводят к сбою команды: <codeph>send</codeph>, <codeph>connect</codeph>, <codeph>close</codeph>, <codeph>allowDomain</codeph>, <codeph>allowInsecureDomain</codeph>, <codeph>client</codeph> и <codeph>domain</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Дополнительные необязательные параметры, передаваемые указанному методу. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Вызывает метод с именем <codeph>methodName</codeph> для подключения, открытого методом <codeph>connect (</codeph><codeph>connectionName</codeph><codeph>)</codeph> (принимающий объект LocalConnection). Используемый с данной программой объект называется <i>sending LocalConnection</i>. SWF-файлы, содержащие отправляющие и принимающие объекты, должны запускаться на одном и том же клиентском компьютере.
	 
	 <p>Объем данных, которые можно передать как параметры для этой команды, ограничен 40 килобайтами. Если при наличии правильного синтаксиса метод <codeph>send()</codeph> отображает ошибку <codeph>ArgumentError</codeph>, попробуйте разделить запросы <codeph>send()</codeph> на несколько команд (объем каждой не должен превышать 40 КБ).</p>
	 
	 <p>Как уже было сказано в описании метода <codeph>connect()</codeph>, текущий супердомен добавляется к строке <codeph>connectionName</codeph> по умолчанию. При реализации механизма обмена данными между разными доменами необходимо определить параметр <codeph>connectionName</codeph> как в отправляющем, так и в принимающем объекте LocalConnection так, чтобы к строке <codeph>connectionName</codeph> не добавлялся текущий супердомен. Это можно выполнить одним из следующих способов:</p>
	 
	 <ul>
	   <li>Используйте символ подчеркивания (_) в начале параметра <codeph>connectionName</codeph> отправляющих и принимающих объектов LocalConnection. С помощью метода <codeph>LocalConnection.allowDomain()</codeph> укажите в файле, содержащем принимающий объект, что будут приниматься подключения с любого домена. Данная реализация позволяет хранить отправляющие и принимающие файлы в любом домене.</li>
	 
	   <li>Добавьте супердомен в параметр <codeph>connectionName</codeph> в отправляющем объекте LocalConnection – например <codeph>myDomain.com:myConnectionName</codeph>. В принимающем объекте с помощью метода <codeph>LocalConnection.allowDomain()</codeph> укажите, что подключения из указанного супердомена будут приняты (в данном случае, myDomain.com) или что будут приняты подключения из любого домена.</li>
	 </ul>
	 
	 <p><b>Примечание. </b>Не следует указывать супердомен в параметре <codeph>connectionName</codeph> принимающего объекта LocalConnection – это можно делать только в отправляющем объекте LocalConnection.</p>
	 
	 <p>При использовании этого метода <ph platform="javascript">в содержимом, находящемся в защищенных изолированных средах, отличных от защищенной изолированной среды приложения</ph>, необходимо учитывать модель безопасности <ph platform="actionscript">Flash Player</ph> <ph platform="javascript">AIR </ph>. По умолчанию объект LocalConnection связан с изолированной программной средой создавшего его файла, при этом вызовы объектов LocalConnection между доменов запрещены, если только вы не вызываете метод <codeph>LocalConnection.allowDomain()</codeph> в принимающем файле. В случае с SWF-содержимым, выполняющимся в обозревателе, можно запретить файлу использовать этот метод, задав параметр <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> HTML-страницы с SWF-содержимым. Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p> 
	 
	 <p>Дополнительные сведения см. в следующих источниках.</p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link><link href="flash.net.xml#LocalConnection/domain"><linktext>flash.net.LocalConnection.domain</linktext></link></related-links><adobeApiEvent id="flash.net:LocalConnection:send_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc><codeph>LocalConnection.send()</codeph> произвел попытку взаимодействия с SWF-файлом из защищенной изолированной среды, доступа к которой вызывающий код не имеет. Эту проблему можно решить в реализации <codeph>LocalConnection.allowDomain()</codeph> на принимающей стороне.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Метод LocalConnection.send() произвел попытку взаимодействия с SWF-файлом из изолированной программной среды, доступ к которой вызывающий код не имеет.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:LocalConnection:send_status"><apiName>status</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:StatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Если значением свойства <codeph>level</codeph> является <codeph>status</codeph>, вызов успешно выполнен. Если значением является <codeph>error</codeph>, вызов не выполнен. Возможен сбой вызова, если принимающий SWF-файл отвергнет подключение.
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>Если свойство уровня имеет значение status, то вызов был успешным. Значение error свидетельствует о сбое вызова.</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.net:LocalConnection:client:get"><apiName>client</apiName><shortdesc>
	 Указывает объект, для которого вызываются методы ответного вызова.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>В качестве свойства <codeph>client</codeph> должен быть указан объект, имеющий значение, отличное от null. 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Указывает объект, для которого вызываются методы ответного вызова. Объект по умолчанию: <codeph>this</codeph> (создаваемое локальное подключение). Если в свойстве <codeph>client</codeph> указать другой объект, методы обратного вызова будут вызываться на этом другом объекте.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:LocalConnection:domain:get"><apiName>domain</apiName><shortdesc>
	 Строка, представляющая домен расположения текущего файла.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>LocalConnection, LocalConnection.domain, domain
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка, представляющая домен расположения текущего файла. 
	 
	 <p>В содержимом, выполняющемся в изолированной программной среде безопасности <codeph>application</codeph> в Adobe AIR (содержимое, установленное с приложением AIR), среда выполнения использует строку <codeph>app#</codeph>, за которой следует идентификатор приложения AIR (определенный в файле дескриптора приложения), вместо обозначения супердомена. Например, <codeph>connectionName</codeph> для приложения с идентификатором <codeph>com.example.air.MyApp</codeph> <codeph>connectionName</codeph> преобразуется в <codeph>app#com.example.air.MyApp:connectionName</codeph>.</p>
	 
	 <p>В возвращенной строке SWF-файлов, опубликованных для проигрывателя Flash Player 9 или более поздних версий, в точности указывается домен файла, включая субдомены. Например, если файл размещен на сайте www.adobe.com, то данная команда возвращает значение <codeph>www.adobe.com</codeph>. </p>
	 
	 <p>Если текущим файлом является локальный файл, размещенный на клиентском компьютере и выполняющийся в проигрывателе Flash Player, то данная команда возвращает значение <codeph>localhost</codeph>.</p>
	 
	 <p>Самые распространенные способы применения этого свойства: включить имя домена отправляющего объекта LocalConnection в качестве параметра метода, который будет вызываться в принимающем объекте LocalConnection, или использовать его с <codeph>LocalConnection.allowDomain()</codeph> для принятия команд с указанного домена. Вполне возможно, что вам и не потребуется использовать данное свойство, если речь идет об установке взаимодействия только между объектами LocalConnection, которые размещены в одном домене.</p>
	 
 	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#LocalConnection/allowDomain()"><linktext>flash.net.LocalConnection.allowDomain()</linktext></link><link href="flash.net.xml#LocalConnection/connect()"><linktext>flash.net.LocalConnection.connect()</linktext></link></related-links></apiValue><apiValue id="flash.net:LocalConnection:isPerUser:get"><apiName>isPerUser</apiName><shortdesc>  
     Указывает, определен ли объект LocalConnection только для текущего пользователя (true) или глобально доступен для всех пользователей компьютера (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
     </apiDefaultValue></apiValueDef><apiDesc>  
     Указывает, определен ли объект LocalConnection только для текущего пользователя (<codeph>true</codeph>) или глобально доступен для всех пользователей компьютера (<codeph>false</codeph>). Это свойство влияет на содержимое, выполняемое в ОС Mac OS X; другие платформы игнорируют этот параметр. Подключения в ОС Windows и операционных системах Linux всегда устанавливаются для одного пользователя. В Flash Player 10.0.22 и более ранних версиях, а также в AIR 1.5.1 и более ранних версиях все объекты LocalConnection в ОС Mac OS X имеют глобальную область действия. Всегда устанавливайте этому свойству значение <codeph>true</codeph>, если не требуется обеспечить совместимость с более ранними версиями. В будущих версиях значение по умолчанию для данного свойства может измениться на <codeph>true</codeph>.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
 
 Класс NetStreamInfo предоставляет различную статистику по качеству обслуживания Quality of Service (QOS), связанную с объектом NetStream и используемым буфером потокового воспроизведения аудио, видео и данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Класс NetStreamInfo предоставляет различную статистику по качеству обслуживания Quality of Service (QOS), связанную с объектом NetStream и используемым буфером потокового воспроизведения аудио, видео и данных. Объект NetStreamInfo возвращается в ответ на вызов <codeph>NetStream.info</codeph>, который делает снимок текущего состояния QOS и предоставляет статистику QOS через свойства NetStreamInfo.
 
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.net:NetStreamInfo:NetStreamInfo"><apiName>NetStreamInfo</apiName><shortdesc>
    Только для внутреннего использования, не рекомендуется для общего применения.</shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>curBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>byteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>maxBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataByteCount</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>playbackBPS</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>droppedFrames</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferByteLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>videoBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>dataBufferLength</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>srtt</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>audioLossRate</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef><apiDesc>
    Только для внутреннего использования, не рекомендуется для общего применения. Объекты NetStreamInfo могут создаваться только средой выполнения.
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.net:NetStreamInfo:toString"><apiName>toString</apiName><shortdesc>
     Возвращает текстовое значение, содержащее список свойств объекта NetStreamInfo.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, содержащая значения свойств объекта NetStreamInfo
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>Возвращает текстовое значение, содержащее список свойств этого объекта NetStreamInfo.
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     Возвращает текстовое значение, содержащее список свойств объекта NetStreamInfo.
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:NetStreamInfo:SRTT:get"><apiName>SRTT</apiName><shortdesc>
	 Указывает сглаженное оцененное время обращения (Smooth Round Trip Time) для сеанса NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает сглаженное оцененное время обращения (Smooth Round Trip Time) для сеанса NetStream. Это значение возвращает допустимое значение только для потоков RTMFP. Для потоков RTMP оно возвращает значение 0. Дополнительные сведения см. в документации по Flash Media Server.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferByteLength:get"><apiName>audioBufferByteLength</apiName><shortdesc>
	 Представляет размер буфера аудиоданных NetStream (в байтах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Представляет размер буфера аудиоданных NetStream (в байтах). Задает размер буфера для аудиоданных при потоковой передаче как в записи, так и в реальном времени. Это свойство похоже на <codeph>Netstream.bytesLoaded</codeph>, которое используется при последовательной загрузке. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioBufferLength:get"><apiName>audioBufferLength</apiName><shortdesc>
	 Представляет информацию о размере буфера для аудиоданных NetStream (в секундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Представляет информацию о размере буфера для аудиоданных NetStream (в секундах). Данное свойство расширяет свойство <codeph>NetStream.bufferLength</codeph> и предоставляет длину буфера (по времени) специально для аудиоданных. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioByteCount:get"><apiName>audioByteCount</apiName><shortdesc>
	 Указывает общее число байтов аудио, поступивших в очередь независимо от того, сколько было воспроизведено или очищено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает общее число байтов аудио, поступивших в очередь независимо от того, сколько было воспроизведено или очищено. Это значение можно использовать для расчета скорости входящих аудиоданных с использованием показателя по своему выбору путем создания таймера и вычисления разности значений в последовательных вызовах таймера. Также можно использовать <codeph>audioBytesPerSecond</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/audioBytesPerSecond"><linktext>audioBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:audioBytesPerSecond:get"><apiName>audioBytesPerSecond</apiName><shortdesc>
	 Указывает скорость заполнения аудиобуфера NetStream (в байтах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает скорость заполнения аудиобуфера NetStream (в байтах в секунду). Значение рассчитывается как среднее значение сглаживания для аудиоданных, полученных за последнюю секунду.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:audioLossRate:get"><apiName>audioLossRate</apiName><shortdesc>
	 Задает уровень потери аудио для сеанса NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Задает уровень потери аудио для сеанса NetStream. Это значение возвращает допустимое значение только для потоков RTMFP. Для потоков RTMP оно возвращает значение 0. Коэффициент потери определяется как отношение потерянных сообщений к общему числу сообщений.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:byteCount:get"><apiName>byteCount</apiName><shortdesc>
	 Указывает общее число байтов, поступивших в очередь независимо от того, сколько было воспроизведено или очищено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает общее число байтов, поступивших в очередь независимо от того, сколько было воспроизведено или очищено. Это значение можно использовать для расчета скорости входящих данных с использованием показателя по своему выбору путем создания таймера и вычисления разности значений в последовательных вызовах таймера. Также можно использовать <codeph>currentBytesPerSecond</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/currentBytesPerSecond"><linktext>currentBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:currentBytesPerSecond:get"><apiName>currentBytesPerSecond</apiName><shortdesc>
	 Указывает скорость заполнения буфера NetStream (в байтах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает скорость заполнения буфера NetStream (в байтах в секунду). Значение рассчитывается как среднее значение сглаживания для совокупных данных, полученных за последнюю секунду.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferByteLength:get"><apiName>dataBufferByteLength</apiName><shortdesc>
	 Представляет размер буфера данных NetStream (в байтах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Представляет размер буфера данных NetStream (в байтах). Задает размер буфера для сообщений с данными при потоковой передаче как в записи, так и в реальном времени. Это свойство похоже на <codeph>Netstream.bytesLoaded</codeph>, которое используется при последовательной загрузке. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataBufferLength:get"><apiName>dataBufferLength</apiName><shortdesc>
	 Представляет информацию о размере буфера для данных NetStream (в секундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Представляет информацию о размере буфера для данных NetStream (в секундах). Данное свойство расширяет свойство <codeph>NetStream.bufferLength</codeph> и предоставляет длину буфера (по времени) специально для сообщений с данными.  
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:dataByteCount:get"><apiName>dataByteCount</apiName><shortdesc>
	 Указывает общее число байтов сообщений с данными, поступивших в очередь независимо от того, сколько было воспроизведено или очищено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает общее число байтов сообщений с данными, поступивших в очередь независимо от того, сколько было воспроизведено или очищено. Это значение можно использовать для расчета скорости входящих сообщений с данными с использованием показателя по своему выбору путем создания таймера и вычисления разности значений в последовательных вызовах таймера. Также можно использовать <codeph>dataBytesPerSecond</codeph>. 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/dataBytesPerSecond"><linktext>dataBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:dataBytesPerSecond:get"><apiName>dataBytesPerSecond</apiName><shortdesc>
	 Указывает скорость заполнения буфера данных NetStream (в байтах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает скорость заполнения буфера данных NetStream (в байтах в секунду). Значение рассчитывается как сглаженное среднее значение для сообщений с данными, полученных за последнюю секунду.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:droppedFrames:get"><apiName>droppedFrames</apiName><shortdesc>
	 Возвращает количество видеокадров, потерянных в текущем сеансе воспроизведения NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Возвращает количество видеокадров, потерянных в текущем сеансе воспроизведения NetStream. 
	 <p>При работе с записями потоков или последовательными загрузками, в которых используется видео высокого качества или разрешения, декодер может запаздывать с декодированием требуемого числа кадров в секунду, если ему будет не хватать системных вычислительных ресурсов. При потоковой передаче в реальном времени буфер опускает кадры при возникновении чрезмерно большой задержки. Это свойство указывает число кадров, которые были опущены и не представлены в обычном порядке.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:maxBytesPerSecond:get"><apiName>maxBytesPerSecond</apiName><shortdesc>
	 Указывает максимальную скорость заполнения буфера NetStream (в байтах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает максимальную скорость заполнения буфера NetStream (в байтах в секунду). Это значение передает сведения о пропускной способности клиентской сети на основе последних сообщений, полученных объектом <codeph>NetStream</codeph>. В зависимости от размера буфера, заданного в <codeph>NetStream.bufferTime</codeph> и клиентской полосы пропускания, Flash Media Server заполняет буфер, разбивая данные на пакеты. Это свойство передает максимальную скорость заполнения клиентского буфера.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:playbackBytesPerSecond:get"><apiName>playbackBytesPerSecond</apiName><shortdesc>
	 Возвращает скорость воспроизведения потока (кол-во байтов в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Возвращает скорость воспроизведения потока (кол-во байтов в секунду). Буфер воспроизведения может включать содержимое разных списков воспроизведения. Это свойство передает скорость воспроизведения, которая ближе всего к скорости текущего воспроизводимого потока.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferByteLength:get"><apiName>videoBufferByteLength</apiName><shortdesc>
	 Представляет размер видеобуфера NetStream (в байтах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Представляет размер видеобуфера NetStream (в байтах). Задает размер буфера для видеоданных при потоковой передаче как в записи, так и в реальном времени. Это свойство похоже на <codeph>Netstream.bytesLoaded</codeph>, которое используется при последовательной загрузке. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoBufferLength:get"><apiName>videoBufferLength</apiName><shortdesc>
	 Представляет информацию о размере буфера для видеоданных NetStream (в секундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Представляет информацию о размере буфера для видеоданных NetStream (в секундах). Данное свойство расширяет свойство <codeph>NetStream.bufferLength</codeph> и предоставляет длину буфера (по времени) специально для видеоданных. 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamInfo:videoByteCount:get"><apiName>videoByteCount</apiName><shortdesc>
	 Указывает общее число байтов видео, поступивших в очередь независимо от того, сколько было воспроизведено или очищено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает общее число байтов видео, поступивших в очередь независимо от того, сколько было воспроизведено или очищено. Это значение можно использовать для расчета скорости входящих видеоданных с использованием показателя по своему выбору путем создания таймера и вычисления разности значений в последовательных вызовах таймера. Также можно использовать <codeph>videoBytesPerSecond</codeph>, 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStreamInfo/videoBytesPerSecond"><linktext>videoBytesPerSecond</linktext></link></related-links></apiValue><apiValue id="flash.net:NetStreamInfo:videoBytesPerSecond:get"><apiName>videoBytesPerSecond</apiName><shortdesc>
	 Указывает скорость заполнения видеобуфера NetStream (в байтах в секунду).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает скорость заполнения видеобуфера NetStream (в байтах в секунду). Значение рассчитывается как сглаженное среднее значение для видеоданных, полученных за последнюю секунду.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLStream"><apiName>URLStream</apiName><shortdesc>
 Класс URLStream обеспечивает низкоуровневый доступ к загружаемым URL-адресам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс URLStream обеспечивает низкоуровневый доступ к загружаемым URL-адресам. Данные становятся доступными для кода приложения сразу во время загрузки. В отличие от URLLoader, нет необходимости ждать окончания загрузки всего файла. Класс URLStream также позволяет закрывать поток до того, как будет завершена его загрузка. Содержимое загруженного файла доступно в качестве необработанных двоичных данных.
 
 <p>Операции чтения в URLStream не являются блокирующими. Это означает, что перед тем как считать данные, необходимо с помощью свойства <codeph>bytesAvailable</codeph> определить, доступен ли необходимый объем этих данных. Исключение <codeph>EOFError</codeph> создается при наличии неполных данных.</p>
 
 <p>По умолчанию все двоичные данные кодируются в формате обратного порядка файлов (сначала передается наиболее значимый байт).</p>
 
 <p>Правила безопасности, применяемые к загрузке URL-адресов с классом URLStream, идентичны правилам, применяемым в отношении объектов URLLoader. При необходимости можно загрузить файлы правил. Применяются локальные правила безопасности файлов, предупреждения о нарушении безопасности появляются по мере необходимости.</p>

 
 </apiDesc><example conref="examples\URLStreamExample.as"> В следующем примере загружается SWF-файл, начало заголовка которого затем анализируется для получения информации о сжатии и номере версии. 
 <p>Чтобы запустить пример, поместите файл URLStreamExample.swf в тот каталог, где находится рассматриваемый SWF-файл.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.*;
    import flash.events.*;
    import flash.net.URLRequest;
    import flash.net.URLStream;

    public class URLStreamExample extends Sprite {
        private static const ZLIB_CODE:String = "CWS";
        private var stream:URLStream;

        public function URLStreamExample() {
            stream = new URLStream();
            var request:URLRequest = new URLRequest("URLStreamExample.swf");
            configureListeners(stream);
            try {
                stream.load(request);
            } catch (error:Error) {
                trace("Unable to load requested URL.");
            }
        }

        private function configureListeners(dispatcher:EventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
        }

        private function parseHeader():void {
            trace("parseHeader");
            trace("isCompressed: " + isCompressed());
            trace("version: " + stream.readByte());
        }

        private function isCompressed():Boolean {
            return (stream.readUTFBytes(3) == ZLIB_CODE);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
            parseHeader();
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:Event):void {
            trace("progressHandler: " + event);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#URLLoader"><linktext>URLLoader</linktext></link><link href="flash.net.xml#URLRequest"><linktext>URLRequest</linktext></link></related-links><adobeApiEvent id="flash.net:URLStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 Отправляется в случае получения данных в ходе операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется в случае получения данных в ходе операции загрузки. Полученные данные можно сразу же прочитать с помощью методов класса URLStream.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 Отправляется при запуске операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется при запуске операции загрузки.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою операции загрузки. 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS_httpResponseStatus"><apiName>httpResponseStatus</apiName><shortdesc>
 Отправляется, если вызов метода URLStream.load() пытается обратиться к данным через HTTP и Adobe AIR может обнаружить и вернуть код состояния для запроса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_RESPONSE_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>URLStream.load()</codeph> пытается обратиться к данным через HTTP и Adobe AIR может обнаружить и вернуть код состояния для запроса. 
 
 <p>Если объект URLStream регистрирует событие <codeph>httpStatusEvent</codeph> ответы с ошибкой доставляются так, будто это содержимое. Поэтому при загрузке ошибки объект URLStream отправляет события <codeph>progress</codeph> и <codeph>complete</codeph> вместо отправки события <codeph>ioError</codeph>.</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 Отправляется, если вызов метода URLStream.load() пытается обратиться к данным по протоколу HTTP, а Flash Player или приложение Adobe AIR может определить и вернуть код состояния для запроса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если вызов метода <codeph>URLStream.load()</codeph> пытается обратиться к данным по протоколу HTTP, а <ph platform="actionscript">Flash Player или</ph> приложение Adobe AIR может определить и вернуть код состояния для запроса. (В среде некоторых обозревателей данная информация не предоставляется.) Обратите внимание на то, что <codeph>httpStatus</codeph> (при наличии такового) будет отправляться до (как дополнение) любого события <codeph>complete</codeph> или <codeph>error</codeph>.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Отправляется, если путем вызова метода URLStream.load() предпринимается попытка загрузить данные с сервера, расположенного за пределами изолированной среды.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если путем вызова метода <codeph>URLStream.load()</codeph> предпринимается попытка загрузить данные с сервера, расположенного за пределами изолированной среды.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#URLStream/load()"><linktext>URLStream.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:URLStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 Отправляется после успешной загрузки данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после успешной загрузки данных. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:URLStream:close"><apiName>close</apiName><shortdesc>
     Немедленно закрывает поток и отменяет операцию загрузки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Не удалось закрыть поток или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Немедленно закрывает поток и отменяет операцию загрузки. После вызова метода <codeph>close()</codeph> данные из потока не считываются.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:load"><apiName>load</apiName><shortdesc>
     Начинает загрузку URL-адреса, указанного в параметре request.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Объекты <codeph>URLRequest.requestHeader</codeph> могут не содержать определенные запрещенные заголовки запроса HTTP. Дополнительную информацию см. в описании класса URLRequestHeader.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Данная ошибка может возникнуть по следующим причинам:
     
     <ol>
     
     <li>Проигрыватель Flash Player или приложение Adobe AIR не может преобразовать значение параметра <codeph>URLRequest.data</codeph> из UTF8 в MBCS. Данная ошибка применяется, если объект URLRequest, переданный методу <codeph>load()</codeph>, настроен на выполнение операции <codeph>GET</codeph>, а параметр <codeph>System.useCodePage</codeph> имеет значение <codeph>true</codeph>.</li>
     
     <li>Проигрыватель Flash Player или приложение Adobe AIR не может выделить память для данных <codeph>POST</codeph>. Данная ошибка применима, если переданный к загрузке объект URLRequest настроен на выполнение операции <codeph>POST</codeph>.</li></ol>
     
     </apiDesc><apiItemName>MemoryError</apiItemName><apiOperationClassifier>flash.errors:MemoryError</apiOperationClassifier></apiException><apiException><apiDesc>Локальные ненадежные SWF-файлы могут быть изолированы от Интернета. Чтобы обойти эту проблему, можно переклассифицировать данный SWF-файл как локальный с сетевым подключением или доверенный.
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc>Объект URLRequest, определяющий URL-адрес для загрузки. Если значение данного параметра или свойства <codeph>URLRequest.url</codeph> переданного объекта URLRequest равно <codeph>null</codeph>, приложение выдает ошибку пустого указателя.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Начинает загрузку URL-адреса, указанного в параметре <codeph>request</codeph>.
     
     <p><b>Примечание</b>. Если загружаемый файл содержит символы, не принадлежащие коду ASCII (например, во многих языках, кроме английского), рекомендуется сохранить файл в кодировке UTF-8 или UTF-16, как противоположных стандарту ASCII.</p>
     
     <p>Если мгновенно происходит сбой операции загрузки, создается исключение IOError или SecurityError (включая сообщение о нарушении безопасности локального файла) с описанием данного сбоя. В противном случае событие <codeph>open</codeph> отправляется, если успешно начинается загрузка URL-адреса. При возникновении ошибки отправляется событие ошибки.</p>
     
     <p>По умолчанию вызывающий SWF-файл и загружаемый URL-адрес должны находиться в одном и том же домене. Например, SWF-файл на www.adobe.com может загружать данные только из источников, которые также размещены на сайте www.adobe.com. Чтобы загрузить данные с другого домена, разместите файл политик URL-адресов на сервере, где расположены эти данные.</p>
     
      <p platform="actionscript">В проигрывателе Flash Player нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава «Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
     
     <p platform="actionscript">Для того чтобы при работе с проигрывателем Flash Player SWF-файл не использовал этот метод, задайте параметр <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> HTML-страницы с SWF-содержимым.</p>
     
     <p platform="actionscript"> В приложении Flash Player 10 и более поздних версий и в AIR 1.5 и более поздних версий при использовании типа содержимого multipart (например, multipart/form-data), в котором содержатся загружаемые данные (обозначена параметром filename в заголовке content-disposition в теле оператора POST), к операции POST применяются правила безопасности для загрузок:</p>
	 <ul platform="actionscript">
	 <li>Операция POST должна быть выполнена в ответ на действие, инициированное пользователем, такое как щелчок мыши или нажатие клавиши.</li>
	 <li>Если операция POST является междоменной (назначением операции POST не является сервер, на котором содержится SWF-файл, отправляющий запрос POST), целевой сервер должен предоставить файл политик URL, в котором разрешен междоменный доступ.</li>
	 </ul>
     <p platform="actionscript">Кроме того, все объекты multipart Content-Type должны иметь допустимый синтаксис (в соответствии со стандартами RFC2046). Если синтаксис является недопустимым, к операции POST применяются правила безопасности, действующие для загрузок.</p>
     
     <p platform="actionscript">Эти правила также применяются к содержимому AIR в изолированных программных средах, отличных от среды приложения. Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде приложения (содержимое, установленное с приложением AIR).</p>
     
     <p platform="actionscript">Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     <ul platform="actionscript">
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     <li>Раздел «Understanding AIR Security» (Сведения о безопасности AIR) главы «Getting started with Adobe AIR» (Начало работы с Adobe AIR) книги <i>Developing AIR Applications</i> (Разработка приложений AIR).</li>
     
     </ul>
     
     <p>В AIR объект URLRequest можно зарегистрировать для события состояния <codeph>httpResponse</codeph>. В отличии от события <codeph>httpStatus</codeph>, событие <codeph>httpResponseStatus</codeph> доставляется до получения данных ответа. Таким образом, в событие <codeph>httpResponseStatus</codeph> входят значения свойств <codeph>responseHeaders</codeph> и <codeph>responseURL</codeph> (которые для события <codeph>httpStatus</codeph> имеют значение undefined.) Обратите внимание на то, что <codeph>httpResponseStatus</codeph> (при наличии такового) будет отправляться до (как дополнение) любого события <codeph>complete</codeph> или <codeph>error</codeph>. 
     </p>
     
     
     <p>При <i>наличии</i> прослушивателя событий <codeph>httpResponseStatus</codeph> тело сообщения ответа <i>всегда</i> отправляется; а ответы с кодами состояния HTTP всегда приводят к событию <codeph>complete</codeph>. Это правило соблюдается независимо от того, обозначает код состояния HTTP в ответе успешное выполнение или ошибку.</p> 
     
     <p><ph platform="actionscript">In AIR </ph><ph platform="javascript">При</ph> <i>отсутствии</i> прослушивателя событий <codeph>httpResponseStatus</codeph> поведение отличается в зависимости от версии <ph platform="actionscript">SWF</ph><ph platform="javascript">AIR</ph>:</p>
     
     <ul>
     
         <li><ph platform="actionscript">Для содержимого SWF 9</ph><ph platform="javascript">В файле AIR, в котором дескриптор приложения определяет AIR 1.0 или 1.1 в качестве версии среды выполнения </ph>, тело сообщения с ответом HTTP отправляется <i>только если</i> код состояния ответа HTTP указывает на успешное выполнение. В противном случае (если возникла ошибка) тело сообщения не отправляется, а объект URLRequest отправляет событие IOError.</li>
     
         <li><ph platform="actionscript">Для содержимого SWF 10</ph><ph platform="javascript">В файле AIR, в котором дескриптор приложения определяет AIR 1.5 в качестве версии среды выполнения</ph>, тело сообщения c ответом HTTP отправляется <i>всегда</i>. Если возникла ошибка, объект URLRequest отправляет событие IOError.</li>
     
     </ul>
     
     
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.net:URLStream:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется после успешной загрузки данных. При наличии прослушивателя событий <codeph>httpResponseStatus</codeph> объект URLRequest также отправляет событие <codeph>complete</codeph> независимо от того, что означает код состояния в ответе HTTP, успешное выполнение <i>или</i> ошибку.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Отправляется после успешной загрузки данных.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Если доступ осуществляется по протоколу HTTP и <ph platform="actionscript">текущая среда поддерживает получение кодов состояния</ph>, можно получить эти события в дополнение к событию <codeph>complete</codeph> или <codeph>error</codeph>.
     
	 </apiDesc></adobeApiEventDetail><shortdesc>Если доступ осуществляется по протоколу HTTP и текущая среда Flash Player поддерживает получение кодов состояния, то в дополнение к любым событиям complete или error могут возникнуть следующие события.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_httpResponseStatus"><apiName>httpResponseStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется, если путем вызова метода <codeph>load()</codeph> выполняется попытка доступа к данным через HTTP, и Adobe AIR может обнаружить и вернуть код статуса для запроса. 
	 
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется, если вызов метода load() пытается обратиться к данным через HTTP и Adobe AIR может обнаружить и вернуть код состояния для запроса.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Не удается завершить операцию загрузки.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Не удается завершить операцию загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Отправляется при запуске операции загрузки.
     
     </apiDesc></adobeApiEventDetail><shortdesc>Отправляется при запуске операции загрузки.</shortdesc></adobeApiEvent><adobeApiEvent id="flash.net:URLStream:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>В рамках операции загрузки была произведена попытка извлечь данные с сервера, расположенного за пределами изолированной среды вызывающего объекта. Для решения этой проблемы можно использовать файл политики на сервере.
     </apiDesc></adobeApiEventDetail><shortdesc>В рамках операции загрузки была произведена попытка извлечь данные с сервера, расположенного за пределами изолированной среды вызывающего объекта.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:URLStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
     Считывает из потока логическое значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>При получении ненулевого байта возвращается значение <codeph>True</codeph>, в противном случае <codeph>false</codeph>.
     
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока логическое значение. Считывается один байт. Если этот байт ненулевой, то возвращается значение <codeph>true</codeph>. В противном случае возвращается значение <codeph>false</codeph>.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readByte"><apiName>readByte</apiName><shortdesc>
     Считывает из потока байт со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от -128 до 127.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока байт со знаком.
     <p>Возвращенное значение находится в диапазоне от -128 до 127.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readBytes"><apiName>readBytes</apiName><shortdesc>
     Считывает из потока число байт данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, в который считываются данные.
     </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Смещение в параметре <codeph>bytes</codeph>, с которого должно начинаться считывание данных. Значение по умолчанию равно 0.
     </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Число байт для считывания. Если значение по умолчанию равно 0, будут считываться все доступные данные.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Считывает из потока число <codeph>байт</codeph> данных. Байты считываются в объект ByteArray, указанный параметром <codeph>bytes</codeph>, начиная с байтов <codeph>offset</codeph> в объекте ByteArray.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readDouble"><apiName>readDouble</apiName><shortdesc>
     Считывает из потока число IEEE 754 с двойной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Взятое из потока число IEEE 754 с двойной точностью и плавающей запятой.
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока число IEEE 754 с двойной точностью и плавающей запятой.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readFloat"><apiName>readFloat</apiName><shortdesc>
     Считывает из потока число IEEE 754 с одинарной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Взятое из потока число IEEE 754 с одинарной точностью и плавающей запятой.
     
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока число IEEE 754 с одинарной точностью и плавающей запятой.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readInt"><apiName>readInt</apiName><shortdesc>
     Считывает из потока 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от -2147483648 до 2147483647.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока 32-разрядное целое число со знаком.
     <p>Возвращенное значение находится в диапазоне от -2147483648 до 2147483647.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
     Считывает из потока байт многобайтовую строку заданной длины с использованием заданного набора знаков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>URLStream, URLStream.readMultiByte, readMultiByte
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8.
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число считываемых из потока байтов.
     </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, обозначающая набор символов, которые используются для интерпретации байтов. Возможные строки наборов символов: <codeph>shift_jis</codeph>, <codeph>"CN-GB"</codeph>, <codeph>iso-8859-1</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>.    
	 
     <p><b>Примечание.</b> Если текущая система не распознает значение параметра <codeph>charSet</codeph>, то в качестве набора символов приложение будет использовать кодовую страницу по умолчанию. Например, значение параметра <codeph>charSet</codeph>, например в <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph>, которое использует <codeph>01</codeph> вместо <codeph>1</codeph> может работать на вашем компьютере, но привести к сбою на другой рабочей станции. На другом компьютере приложение будет использовать кодовую страницу, заданную по умолчанию в системе.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     Считывает из потока байт многобайтовую строку заданной длины с использованием заданного набора знаков.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readObject"><apiName>readObject</apiName><shortdesc>
     Считывает объект из сокета, зашифрованного в формат AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Десериализованный объект.
     </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
     Считывает объект из сокета, зашифрованного в формат AMF.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link></related-links></apiOperation><apiOperation id="flash.net:URLStream:readShort"><apiName>readShort</apiName><shortdesc>
     Считывает из потока 16-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от -32768 до 32767.
     
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока 16-разрядное целое число со знаком.
     <p>Возвращенное значение находится в диапазоне от -32768 до 32767.</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTF"><apiName>readUTF</apiName><shortdesc>
     Считывает из потока строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка UTF-8.
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока строку UTF-8. Предполагается, что в строку вставляется префикс с неподписанным значением, указывающим длину в байтах.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
     Считывает из потока последовательность байт UTF-8 и возвращает строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8, являющаяся байтовым представлением символов указанной длины.
     
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Последовательность байтов UTF-8.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Считывает из потока последовательность <codeph>байтов</codeph> UTF-8 и возвращает строку.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
     Считывает из потока байтов без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>

     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от 0 до 255.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока байтов без знака.
     <p>Возвращенное значение находится в диапазоне от 0 до 255. </p>     
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
     Считывает из потока 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от 0 до 4294967295.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока 32-разрядное целое число без знака.
     <p>Возвращенное значение находится в диапазоне от 0 до 4294967295. </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:URLStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
     Считывает из потока 16-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><ph platform="actionscript">Недостаточно данных, доступных для чтения. Если локальный SWF-файл запускает предупреждение системы безопасности, то проигрыватель Flash Player закрывает для ActionScript доступ к данным URLStream. При этом свойство <codeph>bytesAvailable</codeph> возвращает значение 0 даже в случае получения данных, а любой из методов считывания создает исключение EOFError. </ph> <ph platform="javascript">Эта ошибка относится к содержимому SWF; она не встречается в коде JavaScript, выполняемом в приложении AIR.</ph>
	 
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>В потоке возникла ошибка ввода-вывода или поток не был открыт.
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение в диапазоне от 0 до 65535.
     
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     Считывает из потока 16-разрядное целое число без знака.
     <p>Возвращенное значение находится в диапазоне от 0 до 65535. </p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.net:URLStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
     Возвращает число байтов данных, доступных для чтения во входном буфере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает число байтов данных, доступных для чтения во входном буфере. В вашем коде должен быть вызов свойства <codeph>bytesAvailable</codeph>, проверяющий доступность необходимого объема данных до того, как вы попытаетесь сосчитать их с помощью одного из методов <codeph>read</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:connected:get"><apiName>connected</apiName><shortdesc>
     Определяет, подключен ли в настоящий момент данный объект URLStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, подключен ли в настоящий момент данный объект URLStream. Вызов этого свойства возвращает значение <codeph>true</codeph>, если объект URLStream подключен, или значение <codeph>false</codeph>, если объект не подключен.     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLStream:endian:get"><apiName>endian</apiName><shortdesc>
     Указывает порядок байтов для данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>Endian.BIG_ENDIAN
     </apiDefaultValue></apiValueDef><apiDesc>
     Указывает порядок байтов для данных. Возможные значения: <codeph>Endian.BIG_ENDIAN</codeph> или <codeph>Endian.LITTLE_ENDIAN</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>flash.utils.Endian</linktext></link></related-links></apiValue><apiValue id="flash.net:URLStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Управляет версией AMF, используемой при записи или чтении объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Управляет версией AMF, используемой при записи или чтении объекта.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#URLStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.net:SharedObject"><apiName>SharedObject</apiName><shortdesc>
 Класс SharedObject используется для чтения и хранения ограниченных объемов данных на пользовательском компьютере или на сервере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, shared object, constructor
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SharedObject используется для чтения и хранения ограниченных объемов данных на пользовательском компьютере или на сервере. Общие объекты обеспечивают обмен данными в режиме реального времени между несколькими клиентскими SWF-файлами и объектами, которые находятся постоянно на локальном компьютере или удаленном сервере. Локальные общие объекты схожи с файлами cookie в браузерах, а удаленные общие объекты имеют сходство с устройствами передачи данных в режиме реального времени. Для использования удаленных общих объектов требуется Adobe Flash Media Server.
 
 <p>Используйте общие объекты для следующего:</p>
 
 <ul>
 
 <li><b>Поддержка локального постоянства</b>. Это самый простой способ применения общего объекта, не требующий Flash Media Server. Например, вызов <codeph>SharedObject.getLocal()</codeph> поможет создать общий объект в приложении, предположим, калькулятор с памятью. Когда пользователь закрывает калькулятор, проигрыватель Flash Player сохраняет последнее значение в общем объекте на компьютере пользователя. При следующем запуске калькулятор будет содержать полученные ранее значения. В качестве альтернативы, если перед закрытием калькулятора вы установите для свойств общего объекта значение <codeph>null</codeph>, то при последующем запуске приложение откроется без каких-либо значений. Еще одним примером поддержки локальной устойчивости служит отслеживание предпочтений пользователя или других данных для крупного web-сайта, (например, какие статьи пользователь прочитал на новостном сайте). Отслеживание этой информации позволяет отображать прочитанные ранее статьи не так, как новые непрочитанные. Хранение этой информации на компьютере пользователя снижает нагрузку на сервер.</li>
 
 <li><b>Хранение и совместное использование данных на сервере Flash Media Server</b>. Общий объект может хранить данные на сервере, откуда их смогут извлекать другие клиенты. Например, вызовите <codeph>SharedObject.getRemote()</codeph>, чтобы создать удаленный общий объект, постоянно находящийся на сервере (например, список телефонов). Каждый раз, когда клиент вносит изменения в общий объект, исправленные данные становятся доступными всем клиентам, которые в данный момент подключены к объекту или которые подключаются к нему позднее. Если объект также имеет локальное постоянство, а клиент изменяет данные, но при этом не подключен к серверу, данные копируются в удаленный общий объект при последующем подключении пользователя к объекту.</li>
 
 <li><b>Совместное использование данных в режиме реального времени</b>. Общий объект может предоставить нескольким разным клиентам доступ к данным в режиме реального времени. Например, можно открыть удаленный общий объект, на котором хранится список пользователей, подключенных к дискуссионной группе, которую могут видеть все клиенты, подключенные к данному объекту. Когда пользователь входит или покидает дискуссионную группу, объект обновляется и все клиенты, подключенные к данному объекту, видят исправленный список пользователей дискуссионной группы.</li>
 
 </ul>
 
 <p> Для создания локального общего объекта вызовите <codeph>SharedObject.getLocal()</codeph>. Для создания удаленного общего объекта вызовите <codeph>SharedObject.getRemote()</codeph>.</p> 
 
 <p> При закрытии приложения общие объекты <i>стираются</i> или записываются на диск. Для явной записи данных на диск можно также вызвать метод <codeph>flush()</codeph>.</p>
 
 <p><b>Примечания по локальному дисковому пространству. </b> Локальные общие объекты имеют определенные ограничения, которые следует обязательно учитывать при проектировании приложений. В некоторых случаях SWF-файлам запрещено записывать локальные общие объекты. Иногда данные, хранящиеся в локальных общих объектах, могут быть стерты без вашего ведома. Пользователи Flash Player могут управлять дисковым пространством, доступным отдельным доменам или всем доменам. Когда пользователи уменьшают объем доступного дискового пространства, некоторые локальные общие объекты могут быть удалены. Пользователи Flash Player также снабжены элементами управления конфиденциальностью, которые могут запретить сторонним доменам (другим доменам, отличным от домена, указанного в текущий момент в адресной строке обозревателя) чтение или запись локальных общих объектов.</p>
 
 <p><b>Примечание</b>. SWF-файлы, хранящиеся и запускаемые не на удаленном сервера, а на локальном компьютере, всегда могут записывать на диск сторонние общие объекты. Дополнительные сведения о сторонних общих объектах см. на <xref href="http://www.macromedia.com/support/documentation/ru/flashplayer/help/settings_manager03.html" scope="external">панели Global Storage Settings</xref> в справочной системе Flash Player.</p>
 
 <p>Рекомендуется проверять наличие сбоев, связанных с объемом дискового пространства и настройками конфиденциальности пользователей. Выполняйте данные проверки при вызове <codeph>getLocal()</codeph> и <codeph>flush()</codeph>:
 
 <ul>
 <li><codeph>SharedObject.getLocal()</codeph> – если вызов этого метода приводит к сбою, проигрыватель Flash Player создает исключение. Сбой может произойти, если пользователь отключил сторонние общие объекты, а домен SWF-файла не совпадает с доменом в адресной строке обозревателя.</li>
 
 <li><codeph>SharedObject.flush()</codeph> – при неудачном вызове данного метода проигрыватель Flash Player создает исключение. При успешном вызове он возвращает <codeph>SharedObjectFlushStatus.FLUSHED</codeph>. Если требуется дополнительное дисковое пространство, он возвращает значение <codeph>SharedObjectFlushStatus.PENDING</codeph>. Пользователь Flash Player получает предупреждение о необходимости увеличить доступное пространство для локально сохраняемой информации. Соответственно, событие <codeph>netStatus</codeph> отправляется с информационным объектом, указывающим на сбой или успех проведенной очистки.</li>
 </ul></p>
 
 <p>При попытке SWF-файла создать или модифицировать локальные общие объекты следует убедиться в том, что ширина этого SWF-файла составляет не менее 215 пикселей, а высота – не менее 138 пикселей (это минимальные размеры для отображения диалогового окна, предупреждающего пользователя о необходимости увеличить место для хранения локальных общих объектов). Если данный SWF-файл меньше указанных размеров, но при этом увеличение пространства для хранения все же требуется, происходит сбой <codeph>SharedObject.flush()</codeph>, после которого возвращается значение <codeph>SharedObjectFlushedStatus.PENDING</codeph> и отправляется событие <codeph>netStatus</codeph>.</p>
 
 <p>
 <b>Удаленные общие объекты. </b> При работе с Flash Media Server можно создавать и применять удаленные общие объекты, которые совместно используются в режиме реального времени всеми клиентами, подключенными к вашему приложению. Если какой-либо клиент изменяет свойство удаленного общего объекта, то данное свойство меняется для всех подключенных клиентов. Удаленные общие объекты можно использовать для синхронизации клиентов (например, игроков в многопользовательской игре).
 </p>
 
 <p>
 Каждый удаленный общий объект имеет свойство <codeph>data</codeph>, которое представляет собой объект со свойствами, в которых хранятся данные. Чтобы изменить свойство объекта данных, вызовите <codeph>setProperty()</codeph>. Сервер обновляет свойства, создает событие <codeph>sync</codeph> и отправляет свойства обратно подключенным клиентам. 
 </p>
 
 <p>
 Удаленным общим объектам можно задать постоянство: на клиенте, на сервере или сразу на обоих объектах. По умолчанию проигрыватель Flash Player сохраняет постоянные локальные общие объекты удаленного типа, размер которых не превышает 100 килобайт. При сохранении более крупного объекта Flash Player отображает диалоговое окно «Локальное хранение», в котором пользователь может разрешить или запретить локальное хранение общего объекта. Убедитесь в том, что габаритные размеры используемой рабочей области составляют не менее 215х138 пикселей. Это минимальный размер, необходимый Flash для отображения диалогового окна.
 </p>
 <p>
 Если пользователь выбирает параметр Allow, сервер сохраняет общий объект и отправляет событие <codeph>netStatus</codeph> со свойством <codeph>code</codeph>, имеющим значение <codeph>SharedObject.Flush.Success</codeph>. Если пользователь выбирает параметр Deny, сервер сохраняет общий объект и отправляет событие <codeph>netStatus</codeph> со свойством <codeph>code</codeph>, имеющим значение <codeph>SharedObject.Flush.Failed</codeph>.
 </p>
 
 </apiDesc><example conref="examples\SharedObjectExample.as"> В следующем коде создается (и при последующих выполнениях извлекается) общий объект с идентификатором <codeph>application-name</codeph>. Когда пользователь нажимает кнопку «Сохранить», метод <codeph>saveValue()</codeph> пытается сохранить свойство <codeph>savedValue</codeph> в свойстве <codeph>data</codeph> объекта SharedObject. Если Flash Player должен запросить разрешение на сохранение данных, то в тот момент, когда пользователь дает или не дает разрешение, вызывается метод <codeph>onFlushStatus()</codeph>. Когда нажимается кнопка «Очистить», метод <codeph>clearValue()</codeph> удаляет значение, сохраненное в параметре <codeph>savedValue</codeph>. При последующей загрузке SWF-файла извлекается значение <codeph>undefined</codeph>.
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.events.NetStatusEvent;
    import flash.net.SharedObject;
    import flash.net.SharedObjectFlushStatus;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFieldType;
    
    public class SharedObjectExample extends Sprite {
        
        private var mySo:SharedObject;
        
        public function SharedObjectExample() {
            buildUI();
            saveBtn.addEventListener(MouseEvent.CLICK, saveValue);
            clearBtn.addEventListener(MouseEvent.CLICK, clearValue);
            
            mySo = SharedObject.getLocal("application-name");
            output.appendText("SharedObject loaded...\n");
            output.appendText("loaded value: " + mySo.data.savedValue + "\n\n");
        }

         private function saveValue(event:MouseEvent):void {
            output.appendText("saving value...\n");
            mySo.data.savedValue = input.text;
            
            var flushStatus:String = null;
            try {
                flushStatus = mySo.flush(10000);
            } catch (error:Error) {
                output.appendText("Error...Could not write SharedObject to disk\n");
            }
            if (flushStatus != null) {
                switch (flushStatus) {
                    case SharedObjectFlushStatus.PENDING:
                        output.appendText("Requesting permission to save object...\n");
                        mySo.addEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
                        break;
                    case SharedObjectFlushStatus.FLUSHED:
                        output.appendText("Value flushed to disk.\n");
                        break;
                }
            }
            output.appendText("\n");
        }
        
        private function clearValue(event:MouseEvent):void {
            output.appendText("Cleared saved value...Reload SWF and the value should be \"undefined\".\n\n");
            delete mySo.data.savedValue;
        }
        
        private function onFlushStatus(event:NetStatusEvent):void {
            output.appendText("User closed permission dialog...\n");
            switch (event.info.code) {
                case "SharedObject.Flush.Success":
                    output.appendText("User granted permission -- value saved.\n");
                    break;
                case "SharedObject.Flush.Failed":
                    output.appendText("User denied permission -- value not saved.\n");
                    break;
            }
            output.appendText("\n");

            mySo.removeEventListener(NetStatusEvent.NET_STATUS, onFlushStatus);
        }
        
        // UI elements
        private var inputLbl:TextField;
        private var input:TextField;
        private var output:TextField;
        private var saveBtn:Sprite;
        private var clearBtn:Sprite;
    
        private function buildUI():void {
            // input label
            inputLbl = new TextField();
            addChild(inputLbl);
            inputLbl.x = 10;
            inputLbl.y = 10;
            inputLbl.text = "Value to save:";
            
            // input TextField
            input = new TextField();
            addChild(input);
            input.x = 80;
            input.y = 10;
            input.width = 100;
            input.height = 20;
            input.border = true;
            input.background = true;
            input.type = TextFieldType.INPUT;
            
            // output TextField
            output = new TextField();
            addChild(output);
            output.x = 10;
            output.y = 35;
            output.width = 250;
            output.height = 250;
            output.multiline = true;
            output.wordWrap = true;
            output.border = true;
            output.background = true;
            
            // Save button
            saveBtn = new Sprite();
            addChild(saveBtn);
            saveBtn.x = 190;
            saveBtn.y = 10;
            saveBtn.useHandCursor = true;
            saveBtn.graphics.lineStyle(1);
            saveBtn.graphics.beginFill(0xcccccc);
            saveBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var saveLbl:TextField = new TextField();
            saveBtn.addChild(saveLbl);
            saveLbl.text = "Save";
            saveLbl.selectable = false;
            
            // Clear button
            clearBtn = new Sprite();
            addChild(clearBtn);
            clearBtn.x = 230;
            clearBtn.y = 10;
            clearBtn.useHandCursor = true;
            clearBtn.graphics.lineStyle(1);
            clearBtn.graphics.beginFill(0xcccccc);
            clearBtn.graphics.drawRoundRect(0, 0, 30, 20, 5, 5);
            var clearLbl:TextField = new TextField();
            clearBtn.addChild(clearLbl);
            clearLbl.text = "Clear";
            clearLbl.selectable = false;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#SharedObject/flush()"><linktext>flush()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link><link href="flash.net.xml#SharedObject/event:netStatus"><linktext>netStatus</linktext></link></related-links><adobeApiEvent id="flash.net:SharedObject_flash.events.SyncEvent.SYNC_sync"><apiName>sync</apiName><shortdesc>
 Отправляется, когда удаленный общий объект обновляется сервером.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SyncEvent.SYNC</apiEventType><adobeApiEventClassifier>flash.events.SyncEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда удаленный общий объект обновляется сервером.
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Отправляется, когда экземпляр SharedObject сообщает о своем состоянии или о случившейся ошибке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда экземпляр SharedObject сообщает о своем состоянии или о случившейся ошибке. Событие <codeph>netStatus</codeph> содержит свойство <codeph>info</codeph>, представляющее собой информационный объект, в котором размещаются специфические сведения о событии: успешность попытки подключения или успешность записи общего объекта на локальный диск. 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:SharedObject_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Отправляется, когда исключение создается асинхронным образом &amp;#x2014; то есть в коде, изначально имеющем асинхронную природу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда исключение создается асинхронным образом, то есть в коде, изначально имеющем асинхронную природу. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.net:SharedObject:clear"><apiName>clear</apiName><shortdesc>
     Удаляет все данные и удаляет общий объект с диска для локальных общих объектов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.clear, clear
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Удаляет все данные и удаляет общий объект с диска для локальных общих объектов. Ссылка на общий объект все еще активна, однако его свойства data удалены.
     
     <p>
     Для удаленных общих объектов, используемых при работе с Flash Media Server, метод <codeph>clear()</codeph> отключает объект и стирает все его данные. Если общий объект характеризуется локальным постоянством, данный метод также удаляет этот объект с диска. Ссылка на общий объект все еще активна, однако его свойства data удалены.
     </p>
      
     
     </apiDesc><example conref="examples\SharedObject_clear.as"> С помощью следующего кода создается (и при повторном выполнении – извлекается) объект SharedObject, идентификатор которого имеет значение <codeph>hostName</codeph>. Свойство <codeph>username</codeph> добавляется в свойство данных объекта SharedObject. Наконец вызывается метод <codeph>clear()</codeph>, который стирает всю информацию, добавленную в объект данных (в данном случае было только одно свойство <codeph>username</codeph>).
<codeblock>

package {
    import flash.net.SharedObject;

    public class SharedObject_clear {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_clear() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            if(mySo.data.username == null) {
                mySo.data.username = username;
                trace("set: " + mySo.data.username); // yourUsername
            }
            else {
                mySo.clear();
                trace("cleared: " + mySo.data.username); // undefined
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:close"><apiName>close</apiName><shortdesc>
     Закрывает подключение между удаленным общим объектом и сервером.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Закрывает подключение между удаленным общим объектом и сервером. Если удаленный общий объект имеет локальное постоянство, то после вызова данного метода пользователь сможет вносить изменения в локальную копию объекта. Любые изменения, внесенные в локальный объект, отправляются на сервер при следующем подключении пользователя к удаленному общему объекту.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:connect"><apiName>connect</apiName><shortdesc>
     Подключается к удаленному общему объекту на сервере с помощью указанного объекта NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: On FMS, can connect to a shared object, but cannot pass a message as a second param.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Проигрыватель Flash Player не смог подключиться к указанному удаленному общему объекту. Убедитесь в том, что экземпляр NetConnection действует и подключен, а также что на сервере был успешно создан удаленный общий объект.
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>myConnection</apiItemName><apiOperationClassifier>flash.net:NetConnection</apiOperationClassifier><apiDesc>Объект NetConnection, использующий протокол RTMP (например, объект NetConnection, применяемый для обмена данными с сервером Flash Media Server).
     
     </apiDesc></apiParam><apiParam><apiItemName>params</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Строка, определяющая сообщение, которое необходимо передать удаленному общему объекту на сервере. Не используется с Flash Media Server.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Подключается к удаленному общему объекту на сервере с помощью указанного объекта NetConnection. Используйте данный метод после вызова <codeph>getRemote()</codeph>. При успешном подключении отправляется событие <codeph>sync</codeph>.
     
     <p>Перед тем как перейти к работе с удаленным общим объектом, прежде всего проверьте его на наличие ошибок с помощью оператора <codeph>try.. catch.. finally</codeph>. Перед тем как вносить какие-либо изменения в общий объект, необходимо прослушать и обработать событие <codeph>sync</codeph>. Любые изменения, внесенные локально до отправки события <codeph>sync</codeph>, могут быть потеряны.
     </p>
     
     <p>
     Чтобы подключиться к удаленному общему объекту, вызовите метод <codeph>connect()</codeph>, например:
     </p>
     
	 <codeblock platform="actionscript">
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", myNC.uri, false);
     myRemoteSO.connect(myNC);
     </codeblock>
     
	 <codeblock platform="javascript">
	 var myRemoteSO = air.SharedObject.getRemote("mo", myNC.uri, false);
	 myRemoteSO.connect(myNC);
	 </codeblock>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/getRemote()"><linktext>getRemote()</linktext></link><link href="flash.net.xml#SharedObject/event:sync"><linktext>sync</linktext></link><link href="../../statements.html#try..catch..finally"><linktext>try.. catch.. finally</linktext></link><link href="flash.net.xml#NetConnection"><linktext>NetConnection</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:flush"><apiName>flush</apiName><shortdesc>
     Немедленно записывает постоянный локальный общий объект в локальный файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.flush, flush
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Проигрыватель Flash Player не может записать общий объект на диске. Эта ошибка может возникнуть, если пользователь навсегда запретил локальное хранение информации для объектов из этого домена.
      
     
     <p><b>Примечание.</b> Локальное содержимое всегда может записывать на диск общие объекты из сторонних доменов (доменов, отличных от домена, указанного в данный момент в адресной строке обозревателя), даже если запись сторонних общих объектов на диск запрещена.</p>
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Одно из следующих значений:
     <ul>
     <li><codeph>SharedObjectFlushStatus.PENDING</codeph>: Пользователь разрешил локальное хранение информации для объектов из этого домена, но выделенного объема пространства недостаточно для хранения объекта. Проигрыватель Flash Player предупреждает пользователя о необходимости увеличить свободное дисковое пространство. Для того чтобы обеспечить необходимое при сохранении общего объекта место, тем самым избегая возврата значения <codeph>SharedObjectFlushStatus.PENDING</codeph>, следует указать значение для <codeph>minDiskSpace</codeph>.
     </li>
     
     <li><codeph>SharedObjectFlushStatus.FLUSHED</codeph>: Общий объект был успешно записан как файл на локальном диске.</li>
     </ul>
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>minDiskSpace</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Минимальный объем дискового пространства (в байтах), который должен быть выделен для данного объекта.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Немедленно записывает постоянный локальный общий объект в локальный файл. Если вы не используете данный метод, проигрыватель Flash Player записывает общий объект в файл по окончании соответствующего сеанса: когда SWF-файл закрывается, когда общий объект попадает в мусор, так как на него больше ничто не ссылается, а также когда вы вызываете <codeph>SharedObject.clear()</codeph> или <codeph>SharedObject.close()</codeph>. 
     
     <p>Если данный метод возвращает значение <codeph>SharedObjectFlushStatus.PENDING</codeph>, проигрыватель Flash Player отображает диалоговое окно, предлагающее пользователю увеличить объем дискового пространства, доступный для объектов из этого домена. Чтобы открыть пространство для роста общего объекта при его сохранении в будущем, что позволит избежать возвращенных значений <codeph>PENDING</codeph>, передайте значение для параметра <codeph>minDiskSpace</codeph>. При попытке записать файл проигрыватель Flash Player не проверяет наличие достаточного места для сохранения общего объекта в его текущем размере, а выясняет число байтов, переданных <codeph>minDiskSpace</codeph>. </p>
     
     <p>Например, если вы предполагаете, что при росте максимальный размер общего объекта составит 500 байтов (хотя в начале он будет намного меньшим), установите для <codeph>minDiskSpace</codeph> значение 500. Когда Flash запрашивает у пользователя возможность выделить дисковое пространство для общего объекта, объем запроса составляет 500 байт. После того как пользователь выделяет требуемый объем пространства, Flash больше не запрашивает дополнительное пространство в последующих попытках очистки объекта (его размер при этом не должен превышать 500 байт). </p>
     
     <p>Данный метод вызывается снова после того, как пользователь отреагирует на диалоговое окно. Событие <codeph>netStatus</codeph> отправляется со свойством <codeph>code</codeph>, имеющим значение <codeph>SharedObject.Flush.Success</codeph> или <codeph>SharedObject.Flush.Failed</codeph>.
     </p>
     
     </apiDesc><example conref="examples\SharedObject_flush.as"> С помощью следующего кода создается (и при повторном выполнении – извлекается) объект SharedObject, идентификатор которого имеет значение <codeph>hostName</codeph>. Свойство <codeph>username</codeph> добавляется в свойство данных объекта SharedObject. Затем вызывается метод <codeph>flush()</codeph>, сопровождаемый проверкой того, был ли возврат строки <codeph>pending</codeph> или логического значения <codeph>true</codeph> или <codeph>false</codeph>. Необходимо помнить, что все открытые экземпляры SharedObject будут автоматически стерты при закрытии текущего экземпляра проигрывателя Flash Player.
<codeblock>
package {
    import flash.net.SharedObject;

    public class SharedObject_flush {
        private var hostName:String = "yourDomain";
        private var username:String = "yourUsername";

        public function SharedObject_flush() {
            var mySo:SharedObject = SharedObject.getLocal(hostName);
            mySo.data.username = username;
            var flushResult:Object = mySo.flush();
            trace("flushResult: " + flushResult);
            trace(mySo.data.username); // yourUsername
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/clear()"><linktext>clear()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:getLocal"><apiName>getLocal</apiName><shortdesc>
  Возвращает ссылку на постоянный локальный общий объект, доступный только для текущего клиента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, constructor, SharedObject.getLocal, getLocal, get
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Проигрыватель Flash Player не может создавать общие объекты без какой-либо причины. Данная ошибка может возникнуть, если запрещено создание и хранение постоянных общих объектов содержимым Flash сторонних разработчиков (это не относится к локальному содержимому). Пользователи могут запретить использование постоянных общих объектов сторонних разработчиков на панели Global Storage Settings в диспетчере настроек по адресу <xref href="http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html" scope="external">http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html</xref>.
  
  </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Ссылка на локальный постоянный общий объект, доступный только для текущего клиента. Если проигрыватель Flash Player не может создать или найти общий объект (например, если <codeph>localPath</codeph> указывает на несуществующий каталог), данный метод создает исключение.
  
  </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя объекта. Имена могут содержать косые черты (<codeph>/</codeph>); например, <codeph>work/addresses</codeph> является допустимым именем. Имя общего объекта не может содержать пробелы или следующие символы:   
  <pre>
  ~ % &amp; \ ; : " ' , &lt; > ? # 
  </pre>
  
  </apiDesc></apiParam><apiParam><apiItemName>localPath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Полный или частичный путь к SWF-файлу, который создал общий объект (определяет, где будет сохранен общий объект локально). Если данный параметр не указан, используется полный путь. 
   
  </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, имеют ли доступ к данному общему объекту только те SWF-файлы, которые были доставлены посредством подключения по протоколу HTTPS. Если SWF-файл доставляется по протоколу HTTPS, значение данного параметра оказывает следующее воздействие:
  <ul>
  <li>Если данный параметр имеет значение <codeph>true</codeph>, проигрыватель Flash Player создает новый защищенный общий объект или получает ссылку на существующий защищенный общий объект. Данный защищенный общий объект может считываться или записываться только теми SWF-файлами, доставленными по протоколу HTTPS, которые вызывают метод <codeph>SharedObject.getLocal()</codeph> с параметром <codeph>secure</codeph>, имеющим значение <codeph>true</codeph>.</li>
  <li>Если данный параметр имеет значение <codeph>false</codeph>, проигрыватель Flash Player создает новый общий объект или получает ссылку на существующий общий объект, который может быть считан или записан SWF-файлами, доставленными посредством подключения по другому протоколу (не HTTPS).</li>
  </ul>
  <p>Если ваш SWF-файл доставляется через подключение, не использующее протокол HTTPS, и вы пытаетесь установить для данного параметра значение <codeph>true</codeph>, то создание нового общего объекта (или доступ к ранее созданному защищенному общему объекту) завершится сбоем и возвратом значения <codeph>null</codeph>. Независимо от значения данного параметра созданные общие объекты добавляются к общему объему дискового пространства, доступного для домена.</p>
  
  <p>На следующей схеме показано, как используется параметр <codeph>secure</codeph>:</p>
  <p><adobeimage alt="диаграмма защищенных общих объектов" href="../../images/secureParam.jpg"/></p>
  
  </apiDesc></apiParam></apiOperationDef><apiDesc>
  Возвращает ссылку на постоянный локальный общий объект, доступный только для текущего клиента. Данный метод создает общий объект, если таковой не существовал ранее. Если любые значения, переданные методу <codeph>getLocal()</codeph>, являются недопустимыми или вызов завершился сбоем, Flash Player создает соответствующее исключение.
  
  <p>В представленном коде показано, как присвоить переменной возвращенную ссылку на общий объект:</p>
  <p><codeph>var so:SharedObject = SharedObject.getLocal("savedData");</codeph></p>
  
  <p><b>Примечание.</b> Если пользователь запретил локальное хранение для данного домена, объект не будет сохраняться локально, даже если определено значение для параметра <codeph>localPath</codeph>. Исключением для данного правила является локальное содержимое. Локальное содержимое всегда может записывать на диск общие объекты из сторонних доменов (доменов, отличающихся от домена, указанного в данный момент в адресной строке обозревателя), даже если запись сторонних общих объектов на диск запрещена.
  </p>
  
  <p>Чтобы избежать конфликта имен, проигрыватель Flash отслеживает место размещения SWF-файла, создающего общий объект. Например, если SWF-файл на сайте www.myCompany.com/apps/stockwatcher.swf создает общий объект <codeph>portfolio</codeph>, то данный общий объект не конфликтует с другим объектом <codeph>portfolio</codeph>, который был создан SWF-файлом на сайте www.yourCompany.com/photoshoot.swf, так как эти SWF-файлы находятся в разных каталогах. </p>
  
  <p>Несмотря на то, что параметр <codeph>localPath</codeph> не является обязательным, ему можно найти применение, особенно в тех случаях, когда доступ к общему объекту требуется и другим SWF-файлам. Если данные в общем объекте специфичны для одного SWF-файла, который не будет перемещен в другое место, то целесообразнее использовать значение по умолчанию. Если доступ к общему объекту нужен другим SWF-файлам или если SWF-файл, создающий общий объект, будет впоследствии перемещен, то значение этого параметра определенно влияет на доступность общего объекта. Например, если вы создадите общий объект, у которого параметр <codeph>localPath</codeph> будет иметь значение по умолчанию (полный путь к SWF-файлу), то данный общий объект будет недоступен каким-либо другим SWF-файлам. Если вы позднее переместите исходный SWF-файл в другое место, то даже этому SWF-файлу не будут доступны данные, которые уже были сохранены в общем объекте.</p>
  
  <p>Чтобы избежать непреднамеренного ограничения доступа к общему объекту, используйте параметр <codeph>localpath</codeph>. Наиболее демократичный подход заключается в установке <codeph>localPath</codeph> со значением <codeph>/</codeph> (косая черта). В этом случае общий объект становится доступным всем SWF-файлам в домене, но при этом увеличивается вероятность возникновения конфликтов имен с другими общими объектами в домене. При подходе ограничивающего характера в <codeph>localPath</codeph> добавляются имена папок, представляющих полный путь к SWF-файлу. Например, для общего объекта <codeph>portfolio</codeph>, созданного SWF-файлом по адресу www.myCompany.com/apps/stockwatcher.swf, можно установить параметр <codeph>localPath</codeph> со значением <codeph>/</codeph>, <codeph>/apps</codeph> или <codeph>/apps/stockwatcher.swf</codeph>. Следует определить, какой подход обеспечивает оптимальную гибкость для вашего приложения.</p>
  
  <p platform="actionscript">При использовании данного метода необходимо учесть следующую модель безопасности:
  
  <ul>
  
    <li>Доступ к общим объектам через границы изолированных программных сред запрещен.</li>
    <li>Пользователи могут ограничить доступ к общим объектам с помощью диалогового окна Flash Player Settings или диспетчера настроек. По умолчанию приложение может создавать общие объекты размером до 100 килобайт данных на один домен. Администраторы и пользователи также могут устанавливать ограничения на возможность записи данных в файловой системе.</li>
  </ul></p>
  
  <p platform="actionscript">Предположим, вы публикуете содержимое SWF-файла, которое должно воспроизводиться как локальные файлы (локально установленные SWF-файлы или EXE-файлы). При этом вам необходимо, чтобы определенный общий объект был доступен для нескольких локальных SWF-файлов. В этой ситуации не забудьте, что для хранения локальных общих объектов могут использоваться два разных места. Выбор используемого домена зависит от разрешений безопасности, предоставленных локальному файлу, который создал общий объект. Локальные файлы могут иметь три разных уровня полномочий (разрешений):
  
  <ol>
    <li>Предоставлен доступ только к локальной файловой системе.</li>
    <li>Предоставлен доступ только к сети.</li>
    <li>Предоставлен доступ как к сети, так и локальной файловой системе.</li>
  </ol></p>
  
  <p platform="actionscript">Локальные файлы, имеющие доступ к локальной файловой системе (уровень 1 или 3), хранят свои общие объекты в одном месте. Локальные файлы, не имеющие доступа к локальной файловой системе (2 уровень), хранят свои общие объекты в другом месте.</p>
  
  <p platform="actionscript">Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</p>
  
  <p platform="actionscript">Дополнительные сведения см. в следующих источниках:
  
  <ul>
    <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
    <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
    <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
  </ul></p>
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:getRemote"><apiName>getRemote</apiName><shortdesc>
     Возвращает ссылку на общий объект на сервере Flash Media Server, доступный нескольким клиентам.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: This info is relevant for Flash Media Server, but not Flex Data Services.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Проигрыватель Flash Player не может создать или найти общий объект. Это могло произойти, если для параметров <codeph>remotePath</codeph> и <codeph>persistence</codeph> были указаны несуществующие пути.
     
     
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiDesc>Ссылка на объект, который может совместно использоваться разными клиентами.
     
     </apiDesc><apiOperationClassifier>flash.net:SharedObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя удаленного общего объекта. Имена могут содержать косую черту (/); например, work/addresses является допустимым именем. Имя общего объекта не может содержать пробелы или следующие символы:
     <pre>    ~ % &amp; \ ; :  " ' , > ? ? #</pre>
     
     </apiDesc></apiParam><apiParam><apiItemName>remotePath</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>URI-идентификатор сервера, на котором будет храниться общий объект. Данный URI-адрес должен быть идентичен URI-адресу объекта NetConnection, переданному методу <codeph>connect()</codeph>. 
     
     </apiDesc></apiParam><apiParam><apiItemName>persistence</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, какое постоянство существования имеют атрибуты свойства data общего объекта: локальное, удаленное или оба варианта. Данный параметр также указывает, где будет храниться общий объект локально. Допустимы следующие значения:
     <ul><li>Значение <codeph>false</codeph> указывает на то, что данный общий объект не имеет постоянства на клиентском компьютере или сервере.</li>
     <li>Значение <codeph>true</codeph> указывает на то, что общий объект постоянен только на данном сервере.</li>
     <li>Наличие полного или частичного локального пути к общему объекту свидетельствует о том, что общий объект имеет постоянство на клиентском компьютере и на сервере. На клиентском компьютере он хранится по указанному пути, на сервере он хранится в подкаталоге внутри каталога приложения.</li>
     </ul>
     
     <p><b>Примечание.</b> Если пользователь запретил локальное хранение для данного домена, объект не будет сохраняться локально, даже если будет указан постоянный локальный путь. Дополнительную информацию см. в описании класса.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>secure</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Определяет, имеют ли доступ к данному общему объекту только те SWF-файлы, которые были доставлены посредством подключения по протоколу HTTPS. Дополнительные сведения представлены в описании параметра <codeph>secure</codeph> в записи метода <codeph>getLocal</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Возвращает ссылку на общий объект на сервере Flash Media Server, доступный нескольким клиентам. Данный метод создает удаленный общий объект, если таковой не существовал ранее. 
     
     <p>
     Чтобы создать удаленный общий объект, вызовите <codeph>getRemote()</codeph>, а затем <codeph>connect()</codeph> для подключения удаленного объекта к серверу, как в следующем примере:</p>
     
	 <codeblock platform="actionscript">
     var nc:NetConnection = new NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
     
	 <codeblock platform="javascript">
     var nc = new air.NetConnection();
     nc.connect("rtmp://somedomain.com/applicationName");
     var myRemoteSO:SharedObject = SharedObject.getRemote("mo", nc.uri, false);
     myRemoteSO.connect(nc);
     </codeblock>
	 
     <p>
     Чтобы убедиться в том, что локальная и удаленная копии общего объекта синхронизированы, следует прослушать и обработать событие <codeph>sync</codeph>. Все клиенты, которые хотят совместно использовать этот объект, должны передать одинаковые значения для параметров <codeph>name</codeph> и <codeph>remotePath</codeph>. 
     </p> 
     
     <p>Чтобы создать общий объект, который будет доступен только текущему клиенту, используйте метод <codeph>SharedObject.getLocal()</codeph>.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:send"><apiName>send</apiName><shortdesc>
     Транслирует сообщение всем клиентам, подключенным к удаленному общему объекту (включая клиента, отправляющего сообщение).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Needs better documentation, examples.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Один или несколько аргументов: строка, определяющая сообщение, имя одной или нескольких функций обработчика, прикрепляемых к общему объекту, а также необязательные параметры любого типа. Имя обработчика должно быть исключительно одноуровневым (то есть форма «вышестоящий/нижестоящий элемент» не используется) и связанным с общим объектом. Аргументы сериализуются и отправляются посредством подключения, при этом принимающий обработчик получает их в том же самом порядке. Если параметр представляет собой объект круглой формы (например, связанный в круглую форму список), сериализатор обрабатывает ссылки надлежащим образом.
     
     <p><b>Примечание</b>. Не используйте в качестве имени функции какой-либо зарезервированный термин. Например, использование <codeph>myRemoteSO.send("close")</codeph> приведет к сбою.</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Транслирует сообщение всем клиентам, подключенным к удаленному общему объекту (включая клиента, отправляющего сообщение). Чтобы обработать и отреагировать на данное сообщение, вызовите функцию обратного вызова, прикрепленную к общему объекту.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:SharedObject:setDirty"><apiName>setDirty</apiName><shortdesc>
     Указывает серверу, что значение свойства в общем объекте было изменено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The AS2 player automatically marks properties dirty as they are changed.
          The FMS server, however, requires an explicit setProperty() call to indicate when a property
          of data has changed.
     
          AS3 does not support auto-dirtying the properties, so we are introducing setDirty() to explicitly
          indicate when a property has changed, and setProperty() to match the method provided with the server.
     
          It's probably best to read the FMS Actionscript reference (search for SharedObject.setProperty at
          www.adobe.com) before writing this documentation, as the details should be similar.
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя изменившегося свойства.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Указывает серверу, что значение свойства в общем объекте было изменено. Данный метод помечает свойства флагом изменения <i>dirty</i>.
     
     <p>
     Вызовите <codeph>SharedObject.setProperty()</codeph>, чтобы создать свойства общего объекта. 
     </p>
      
     <p>
     Метод <codeph>SharedObject.setProperty()</codeph> реализует <codeph>setDirty()</codeph>. В большинстве случаев, например, когда значение свойства представлено примитивным типом (строка или число), вместо <codeph>setDirty()</codeph> можно вызвать <codeph>setProperty()</codeph>. Однако если значением свойства является объект, содержащий свои собственные свойства, вызовите <codeph>setDirty()</codeph>, чтобы указать, когда значение изменяется в рамках объекта.
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (свойство на стороне клиента)</linktext></link><link href="flash.net.xml#SharedObject/setProperty()"><linktext>setProperty()</linktext></link></related-links></apiOperation><apiOperation id="flash.net:SharedObject:setProperty"><apiName>setProperty</apiName><shortdesc>
     Обновляет значение свойства в общем объекте и указывает серверу, что значение свойства было изменено.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя свойства в общем объекте.
     </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Значение свойства (объект ActionScript) или значение <codeph>null</codeph>, чтобы удалить свойство. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Обновляет значение свойства в общем объекте и указывает серверу, что значение свойства было изменено. Метод <codeph>setProperty()</codeph> явно отмечает свойства как измененные или имеющие не сохраненные данные.
     
     <p>Дополнительную информацию об удаленных общих объектах см. в документации <xref href="http://www.adobe.com/go/learn_fms_docs_en"> Flash Media Server</xref>.</p>
     
     <p><b>Примечание.</b> Метод <codeph>SharedObject.setProperty()</codeph> реализует метод <codeph>setDirty()</codeph>. В большинстве случаев, например, когда значение свойства представлено примитивным типом (строка или число), вместо <codeph>setDirty()</codeph> можно вызвать <codeph>setProperty()</codeph>. Однако если значением свойства является объект, содержащий свои собственные свойства, используйте <codeph>setDirty()</codeph>, чтобы указать, когда значение изменяется в рамках объекта. Вообще, рекомендуется вместо <codeph>setDirty()</codeph> вызывать <codeph>setProperty()</codeph>, так как <codeph>setProperty()</codeph> обновляет значение свойства только при изменении этого значения, в то время как <codeph>setDirty()</codeph> принудительно выполняет синхронизацию на всех подписанных клиентах.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#SharedObject/data"><linktext>SharedObject.data (свойство на стороне клиента)</linktext></link></related-links></apiOperation><apiValue id="flash.net:SharedObject:client:get"><apiName>client</apiName><shortdesc>
     Указывает объект, для которого вызываются методы ответного вызова.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>В качестве свойства <codeph>client</codeph> должен быть указан объект, имеющий значение, отличное от null.
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Указывает объект, для которого вызываются методы ответного вызова. Объект по умолчанию: <codeph>this</codeph>. Если в свойстве client указать другой объект, методы обратного вызова будут вызываться на этом другом объекте.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:data:get"><apiName>data</apiName><shortdesc>
     Сборник атрибутов, связанных со свойством data объекта. Эти атрибуты можно совместно использовать и сохранять.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.data, data
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Сборник атрибутов, связанных со свойством <codeph>data</codeph> объекта. Эти атрибуты можно совместно использовать и сохранять. Каждый атрибут может быть объектом любого типа ActionScript или JavaScript – массивом, числом, логическим значением, ByteArray, XML и т.п. Например, в следующих строках присваиваются значения различным аспектам общего объекта:
     
	 <codeblock platform="actionscript">
     var items_array:Array = new Array(101, 346, 483);
     var currentUserIsAdmin:Boolean = true;
     var currentUserName:String = "Ramona";
     
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.data.itemNumbers = items_array;
     my_so.data.adminPrivileges = currentUserIsAdmin;
     my_so.data.userName = currentUserName;
     
     for (var prop in my_so.data) {
       trace(prop+": "+my_so.data[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var items_array = new Array(101, 346, 483);
	 var currentUserIsAdmin = true;
	 var currentUserName = "Ramona";
	 
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.data.itemNumbers = items_array;
	 my_so.data.adminPrivileges = currentUserIsAdmin;
	 my_so.data.userName = currentUserName;
	 
	 for (var prop in my_so.data) {
	   trace(prop+": "+my_so.data[prop]);
	 }
	 </codeblock>
     
     <p>Все атрибуты свойства <codeph>data</codeph> общего объекта сохраняются, если объект обладает постоянством, при этом данный общий объект содержит следующую информацию:</p>
     
     <codeblock>
     userName: Ramona
     adminPrivileges: true
     itemNumbers: 101,346,483
     </codeblock>
     
     <p><b>Примечание.</b> Не следует присваивать значения непосредственно свойству <codeph>data</codeph> общего объекта, например <codeph>so.data = someValue</codeph>, так как проигрыватель Flash Player игнорирует подобное присвоение.</p>
     
     <p>Чтобы удалить атрибуты для локальных общих объектов, используйте код <codeph>delete so.data.attributeName</codeph>, так как установка значения <codeph>null</codeph> или <codeph>undefined</codeph> для атрибута локального общего объекта не приводит к удалению самого атрибута.</p>
     
     <p>Чтобы создать значения <i>private</i> (значения, доступные только экземпляру клиента в процессе использования объекта и не сохраняемые при закрытии объекта) для общего объекта, создайте свойства, не называя их <codeph>data</codeph>, и сохраните их, как показано в следующем примере:</p>
     
	 <codeblock platform="actionscript">
     var my_so:SharedObject = SharedObject.getLocal("superfoo");
     my_so.favoriteColor = "blue";
     my_so.favoriteNightClub = "The Bluenote Tavern";
     my_so.favoriteSong = "My World is Blue";
     
     for (var prop in my_so) {
       trace(prop+": "+my_so[prop]);
     }
     </codeblock>
     
	 <codeblock platform="javascript">
	 var my_so = air.SharedObject.getLocal("superfoo");
	 my_so.favoriteColor = "blue";
	 my_so.favoriteNightClub = "The Bluenote Tavern";
	 my_so.favoriteSong = "My World is Blue";
	 
	 for (var prop in my_so) {
	   trace(prop+": "+my_so[prop]);
	 }
	 </codeblock>
     
     <p>Общий объект содержит следующие данные:</p>
     <codeblock>
     favoriteSong: My World is Blue
     favoriteNightClub: The Bluenote Tavern
     favoriteColor: blue
     data: [object Object]
     </codeblock>
     
     <p>
     Для удаленных общих объектов, используемых при работе с сервером, все атрибуты свойства <codeph>data</codeph> доступны всем клиентам, подключенным к общему объекту. При этом все атрибуты сохраняются, если объект обладает постоянством. Если один из клиентов изменит значение атрибута, то новое значение будет видно всем клиентам.
     </p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/getLocal()"><linktext>getLocal()</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
     Кодировка объекта по умолчанию (версия AMF) для всех локальных общих объектов, созданных в SWF-файле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Кодировка объекта по умолчанию (версия AMF) для всех локальных общих объектов, созданных в SWF-файле. Когда локальные общие объекты записываются на диск, свойство <codeph>SharedObject.defaultObjectEncoding</codeph> указывает необходимую версию формата Action Message Format: ActionScript 3.0 (AMF3), ActionScript 1.0 или 2.0 (AMF0).
     
     <p>Дополнительные сведения о кодировке объекта, включая различие между кодировкой в локальных и удаленных общих объектах, см. в описании свойства <codeph>objectEncoding</codeph>.</p>
     
     <p>Значение <codeph>SharedObject.defaultObjectEncoding</codeph> по умолчанию: использование формата ActionScript 3.0 (AMF3). При необходимости записать локальные общие объекты, которые смогут быть прочитаны SWF-файлами ActionScript 2.0 или 1.0, настройте <codeph>SharedObject.defaultObjectEncoding</codeph> на использование формата ActionScript 1.0 или ActionScript 2.0, <codeph>flash.net.ObjectEncoding.AMF0</codeph> (в начале сценария) до непосредственного создания таких объектов. Все локальные общие объекты, созданные после этого, будут использовать кодировку AMF0 и смогут взаимодействовать с более старым содержимым. После создания локальных общих объектов вы не сможете изменить значение <codeph>objectEncoding</codeph> существующих локальных общих объектов путем задания параметра <codeph>SharedObject.defaultObjectEncoding</codeph>.</p>
     
     <p>Чтобы установить кодировку не для всех общих объектов, созданных SWF-файлов, а для отдельных объектов, установите свойство <codeph>objectEncoding</codeph> локального общего объекта.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/objectEncoding"><linktext>Свойство objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Кодировка объекта (версия AMF) для данного общего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Произведена попытка установить значение свойства <codeph>objectEncoding</codeph> на удаленном общему объекте. Для удаленных общих объектов это свойство доступно только для чтения, так как его значение определяется соответствующим экземпляром NetConnection.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Кодировка объекта (версия AMF) для данного общего объекта. Когда локальный общий объект записывается на диск, свойство <codeph>objectEncoding</codeph> указывает необходимую версию формата Action Message Format: ActionScript 3.0 (AMF3), ActionScript 1.0 или 2.0 (AMF0). 
     
     <p>Кодировка объекта обрабатывается в зависимости от типа общего объекта (локальный или удаленный).</p>
     <ul>
     <li><b>Локальные общие объекты</b>. Вы можете получить или установить значение свойства <codeph>objectEncoding</codeph> для локальных общих объектов. Значение <codeph>objectEncoding</codeph> влияет на то, какое форматирование используется для <i>записи</i> данного локального общего объекта. Если этот локальный общий объект должен считываться SWF-файлами ActionScript 2.0 или 1.0, установите для <codeph>objectEncoding</codeph> значение <codeph>ObjectEncoding.AMF0</codeph>. Даже если запись должна вестись в кодировке объекта AMF3, проигрыватель Flash Player все равно способен считывать локальные общие объекты в кодировке AMF0. Другими словами, если используется значение данного свойства по умолчанию (<codeph>ObjectEncoding.AMF3</codeph>), SWF-файл все равно сможет считывать общие объекты, созданные SWF-файлами в формате ActionScript 2.0 или 1.0.
     </li>
     
     <li><b>Удаленные общие объекты</b>. При подключении к серверу удаленный общий объект наследует его параметр <codeph>objectEncoding</codeph> от связанного экземпляра NetConnection (экземпляра, используемого для подключения к удаленному общему объекту). При отсутствии подключения к серверу удаленный общий объект наследует параметр <codeph>defaultObjectEncoding</codeph> от соответствующего экземпляра NetConnection. Поскольку значение свойства <codeph>objectEncoding</codeph> удаленного общего объекта определяется экземпляром NetConnection, для удаленных общих объектов это свойство является доступным только для чтения.
     </li>
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#SharedObject/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:SharedObject:size:get"><apiName>size</apiName><shortdesc>
     Текущий размер общего объекта (в байтах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>SharedObject, SharedObject.getSize, getSize
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Текущий размер общего объекта (в байтах).
     
     <p>Flash вычисляет размер общего объекта, просматривая свойства всех его данных. Чем больше свойств данных содержит объект, тем больше времени требуется для вычисления размера. Анализ размера объекта может занять существенный объем ресурсов, поэтому этот метод следует использовать только в случае особой необходимости.</p>
     
     </apiDesc><example conref="examples\SharedObject.size.1.as"> Следующий код создает объект SharedObject с помощью идентификатора <codeph>thehobbit</codeph>. Свойство <codeph>username</codeph> добавляется в свойство данных объекта SharedObject. Затем отслеживается свойство <codeph>size</codeph>, в результате чего возвращается указанное значение.
<codeblock>

import flash.net.SharedObject;

// if these get copied or not
var mySo:SharedObject = SharedObject.getLocal("thehobbit");
mySo.data.username = "bilbobaggins";
trace(mySo.size); // 55
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.net:SharedObject:fps:set"><apiName>fps</apiName><shortdesc>
     Определяет, сколько раз в секунду изменения общего объекта, внесенные клиентом, отправляются на сервер.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: The info is relevant for Flash Media Server, but not Flex.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Определяет, сколько раз в секунду изменения общего объекта, внесенные клиентом, отправляются на сервер. 
     
     <p>Используйте этот метод при необходимости управлять объемом данных, перемещаемых между клиентом и сервером. Например, если соединение между клиентом и сервером характеризуется относительно медленной скоростью, может потребоваться установить для параметра <codeph>fps</codeph> более низкое значение. И наоборот, если клиент подключен к многопользовательскому приложению, в котором важен расчет времени, можно установить для <codeph>fps</codeph> относительно высокое значение.</p>
     
     <p>Настройка параметра <codeph>fps</codeph> приведет к появлению события <codeph>sync</codeph> и обновит все изменения на сервере. Если только требуется вручную обновить сервер, установите для <codeph>fps</codeph> значение 0.</p>
     
     <p>Изменения не отправляются на сервер до тех пор, пока не будет отправлено событие <codeph>sync</codeph>. Другими словами, если время реагирования сервера слишком мало, обновления могут отправляться на сервер с меньшей частотой, чем значение, указанное в данном свойстве. </p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:URLLoaderDataFormat"><apiName>URLLoaderDataFormat</apiName><shortdesc>
 Класс URLLoaderDataFormat обеспечивает значения, указывающие, каким образом получаются загружаемые данные.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс URLLoaderDataFormat обеспечивает значения, указывающие, каким образом получаются загружаемые данные.
 
 </apiDesc><example conref="examples\URLLoaderDataFormatExample.as"> В следующем примере класс URLLoaderDataFormatExample используется для отображения формата данных и информации о состоянии файла, загруженного при выполнении кода. Это можно сделать, выполнив следующие действия:
 <ol>
  <li>Класс конструктора создает экземпляр URLLoader под именем <codeph>loader</codeph> и экземпляр URLRequest под именем <codeph>request</codeph>, в котором указывается место размещения и имя загружаемого файла.</li>
  <li>Объект <codeph>loader</codeph> передается методу <codeph>configureListeners()</codeph>, который добавляет прослушивателей для каждого из поддерживаемых событий URLLoader:
  <ul>
      <li><codeph>completeHandler()</codeph>: находится в ожидании события <codeph>complete</codeph>, которое отправляется после успешной загрузки TextFile.txt.</li>
      <li><codeph>openHandler()</codeph>: прослушивает событие <codeph>open</codeph>, которое отправляется после начала загрузки (в проигрыватель) файла TextFile.txt.</li>
      <li><codeph>progressHandler()</codeph>: находится в ожидании событий <codeph>progress</codeph>, отправляется при получении данных по мере выполнения операции загрузки.</li>
      <li><codeph>securityErrorHandler()</codeph>: находится в ожидании событий <codeph>securityError</codeph>, которые отправляются, если была совершена попытка обращения к текстовому файлу с применением недопустимой настройки безопасности локального воспроизведения.</li>  
      <li><codeph>httpStatusHandler()</codeph>: находится в ожидании событий <codeph>httpStatusHandler</codeph>, которые в данном случае не будут отправлены, так как TextFile.txt является локальным файлом.</li>
      <li><codeph>ioErrorHandler()</codeph>: находится в ожидании событий <codeph>ioError</codeph>, которые могут произойти только при возникновении серьезной проблемы (например, при отсутствии нужного файла).</li>  
  </ul></li>
  <li>Затем объект <codeph>request</codeph> передается методу <codeph>loader.load()</codeph>, который загружает текстовый файл в память с помощью объекта <codeph>DisplayObject</codeph>.</li>
 </ol>
 <p> <b>Примечания.</b>
 <ul>
  <li>SWF-файл потребуется откомпилировать с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к локальным файлам».
  </li>
  <li>Данный пример требует, чтобы файл с именем TextFile.txt находился в том же каталоге, что и SWF-файл. Если необходимо, чтобы данный пример идентифицировал двоичные файлы или файлы данных в кодировке URL-адреса, вам следует предоставить файл в надлежащем формате данных и изменить TextFile.txt на имя и месторасположение нового файла.</li>
  </ul>
 </p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.*;

    public class URLLoaderDataFormatExample extends Sprite {
        private var source:String = "TextFile.txt";
        private var dataFormat:String = URLLoaderDataFormat.TEXT;
        
        public function URLLoaderDataFormatExample () {
            var loader:URLLoader = new URLLoader();
            loader.dataFormat = dataFormat;
            configureListeners(loader);
            var request:URLRequest = new URLRequest(source);
            try {
                loader.load(request);
            } catch (error:Error) {
                trace("Error loading requested document: " + source);
            }
        }

        private function configureListeners(dispatcher:URLLoader):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function completeHandler(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            switch(loader.dataFormat) {
                case URLLoaderDataFormat.TEXT :
                    trace("completeHandler (text): " + loader.data);
                    break;
                case URLLoaderDataFormat.BINARY :
                    trace("completeHandler (binary): " + loader.data);
                    break;
                case URLLoaderDataFormat.VARIABLES :
                    trace("completeHandler (variables): " + loader.data);
                    break;
            }
        }

        private function httpStatusHandler(event:Event):void {
            trace("httpStatusHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.net:URLLoaderDataFormat:BINARY"><apiName>BINARY</apiName><shortdesc>
	 Указывает, что загружаемые данные получаются в виде необработанных двоичных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>binary</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что загружаемые данные получаются в виде необработанных двоичных данных.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:TEXT"><apiName>TEXT</apiName><shortdesc>
	 Указывает, что загружаемые данные получаются в виде текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>text</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что загружаемые данные получаются в виде текста.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:URLLoaderDataFormat:VARIABLES"><apiName>VARIABLES</apiName><shortdesc>
	 Указывает, что загружаемые данные получаются в виде переменных в кодировке URL-адреса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>variables</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, что загружаемые данные получаются в виде переменных в кодировке URL-адреса.
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetStreamPlayTransitions"><apiName>NetStreamPlayTransitions</apiName><shortdesc>
 
 Класс NetStreamPlayTransitions определяет допустимые строки, которые могут быть использованы со свойством NetStreamPlayOptions.transition.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 
 Класс NetStreamPlayTransitions определяет допустимые строки, которые могут быть использованы со свойством NetStreamPlayOptions.transition. Эти строки управляют поведением, используемым для перехода к новому потоку или для воспроизведения потока в зависимости от выбранного режима перехода.
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#NetStreamPlayOptions"><linktext>NetStreamPlayOptions</linktext></link><link href="flash.net.xml#NetStream/play()"><linktext>NetStream.play()</linktext></link><link href="flash.net.xml#NetStream/play2()"><linktext>NetStream.play2()</linktext></link></related-links><apiValue id="flash.net:NetStreamPlayTransitions:APPEND"><apiName>APPEND</apiName><shortdesc>
	 
	 Добавляет поток в список воспроизведения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Добавляет поток в список воспроизведения. Этот режим выполняет ту же функцию, что и метод <codeph>NetStream.play()</codeph> с флагом <codeph>reset</codeph> в значении <codeph>false</codeph>.
	 
	 <p>В этом режиме Flash Media Server добавляет поток, заданный в <codeph>NetStreamPlayOptions.streamName</codeph>, в конец списка воспроизведения и игнорирует параметр <codeph>NetStreamPlayOptions.oldStreamName</codeph>.</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:RESET"><apiName>RESET</apiName><shortdesc>
	 
	 Удаляет предыдущие вызовы play и немедленно воспроизводит указанный поток.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reset</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Удаляет предыдущие вызовы play и немедленно воспроизводит указанный поток. Этот режим выполняет ту же функцию, что и метод <codeph>NetStream.play()</codeph> с флагом <codeph>reset</codeph> в значении <codeph>true</codeph> (значение по умолчанию для <codeph>NetStream.play()</codeph>).
	 
	 <p>В этом режиме воспроизводимый в данный момент поток очищается, и начинается воспроизведение потока, заданного в <codeph>NetStreamPlayOptions.streamName</codeph>. Параметр <codeph>NetStreamPlayOptions.oldStreamName</codeph> игнорируется.</p> 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:STOP"><apiName>STOP</apiName><shortdesc>
	 
	 Останавливает воспроизведение потоков в списке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>stop</apiData><apiType value=""/></apiValueDef><apiDesc>
	 
	 Останавливает воспроизведение потоков в списке. Этот режим выполняет ту же функцию, что и метод <codeph>NetStream.play(false)</codeph>. Он останавливает и сбрасывает список воспроизведения.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWAP"><apiName>SWAP</apiName><shortdesc>
	 Заменяет один поток на поток с другим содержимым, сохраняя остальные элементы списка воспроизведения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>swap</apiData><apiType value=""/></apiValueDef><apiDesc>
	 Заменяет один поток на поток с другим содержимым, сохраняя остальные элементы списка воспроизведения.
	 
	 <p>Как и <codeph>SWITCH</codeph>, этот режим меняет поток, заданный в <codeph>NetStreamPlayOptions.oldStreamName</codeph> на поток, заданный в <codeph>NetStreamPlayOptions.streamName</codeph>. Остальные элементы списка воспроизведения остаются без изменений. В этом режиме сервер Flash Media Server не делает каких-либо предположений о содержимом потоков и обращается с ними как с разным содержимым. Если свойство <codeph>oldStreamName</codeph> еще не отправлено, сервер выполняет переключение на границе потока и отправляет биты для <codeph>streamName</codeph> с самого начала. Если сервер уже начал отправку битов для <codeph>oldStreamName</codeph>, он не переключается на <codeph>streamName</codeph> и отправляет событие <codeph>NetStream.Play.Failed</codeph>.</p>
	 
	 <p>Используйте этот режим, если потоки, между которыми выполняется переключение, не связаны между собой и имеют разное содержимое или продолжительность. Например, можно заменить один рекламный ролик на другой на основе отслеживания пользователей и прошлой статистики по просмотру рекламы.</p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetStreamPlayTransitions:SWITCH"><apiName>SWITCH</apiName><shortdesc>
	 Переключается с воспроизведения одного канала на другой, как правило, это каналы с одинаковым содержимым.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>switch</apiData><apiType value=""/></apiValueDef><apiDesc>
	 Переключается с воспроизведения одного канала на другой, как правило, это каналы с одинаковым содержимым. Задайте каналы для переключения в <codeph>NetStreamPlayOptions.oldStreamName</codeph> и <codeph>NetStreamPlayOptions.streamName</codeph>. 
	 
	 <p>Используйте этот режим, когда требуется переключиться на канал с тем же содержимым, но закодированным с другим разрешением или скоростью потока. Например, используйте этот режим, когда приложение добавляет потоки в список воспроизведения или воспроизводит один поток с определенной скоростью потока, а затем рассчитывает, что доступная полоса пропускания или мощность ЦП ниже или выше необходимой для потока. Тогда приложение может обновить потоки, заменив их на их версии с более высокой или низкой скоростью потока.</p>
	 
	 <p>В этом режиме Flash Media Server делает определенные предположения об отношении между потоками <codeph>oldStreamName</codeph> и <codeph>streamName</codeph>. Сервер предполагает, что потоки содержат одно и то же содержимое и одинаковый интервал ключевых кадров, но разное разрешение или скорость потока.</p>
	 
	 <p>Когда список воспроизведения добавляется в очередь и <codeph>oldStreamName</codeph> является одним из потоков в списке или воспроизводится в данный момент, <codeph>oldStreamName</codeph> меняется на <codeph>streamName</codeph>.</p>
	 
	 <p>Если свойство <codeph>oldStreamName</codeph> имеет значение null или undefined, либо если его нет в списке воспроизведение, сервер переключается на <codeph>streamName</codeph> в следующей логически обоснованной точке, чтобы обеспечить плавный переход.</p>
	 
	 <p>Чтобы переключиться с одного потока на поток с другим содержимым, необходимо использовать режим <codeph>RESET</codeph>.</p>
	 
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.net:NetConnection"><apiName>NetConnection</apiName><shortdesc>
 Класс NetConnection создает двунаправленное соединение между приложением Flash Player или AIR и приложением Flash Media Server, или между приложением Flash Player или AIR и сервером приложений, на котором запущен компонент Flash Remoting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection, Video, Responder
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс NetConnection создает двунаправленное соединение между приложением <ph platform="actionscript">Flash Player или AIR</ph> <ph platform="javascript">AIR</ph> и Flash Media Server или между приложением <ph platform="actionscript">Flash Player или AIR</ph> <ph platform="javascript">AIR</ph> и сервером приложений, на котором запущен компонент Flash Remoting. Объект NetConnection представляет собой определенный канал (трубу) между клиентом и сервером. Используйте объекты NetStream для отправки потоков по каналу. 
 <p>Создайте объект Responder и передайте его в качестве параметра для <codeph>NetConnection.call()</codeph>, чтобы обработать возвращаемые с сервера значения, связанные с успешным или неуспешным выполнением определенных операций.</p>  
 <p>
 При отсутствии Flash Media Server класс NetConnection можно использовать для воспроизведения видео и MP3-файлов из локальной файловой системы или с web-сервера.
 </p>
 
 <p>
 Информация о поддерживаемых кодеках и форматах файлов представлена по адресу <xref href="http://www.adobe.com/go/hardware_scaling_ru" scope="external">http://www.adobe.com/go/hardware_scaling_ru</xref> и в <xref href="http://www.adobe.com/support/documentation" scope="external">документации по серверу Flash Media Server</xref>.
 </p>
 
 <p>При использовании класса NetConnection необходимо учесть следующую модель безопасности.</p>
 
 <ul>
 <li>Загрузка и воспроизведение аудио- или видеофайла запрещены, если вызывающий файл находится в изолированной программной среде сети, а файл для загрузки – на локальном компьютере.</li>
 
 	<li>По умолчанию загрузка и воспроизведение аудио- или видеофайла запрещены, если вызывающий файл размещается локально, но пытается загрузить и воспроизвести удаленный файл. Для этого пользователь должен предоставить разрешение.</li>
 </ul>
 
 <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленное с приложением AIR).</p>
 
 <p>Дополнительные сведения см. в следующих источниках.</p>
 
 <ul>
 
 <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li> 
 </ul>
 
 
 <p platform="actionscript"><b>Примечание</b>. В ActionScript 2.0 данный класс считался динамическим, но сейчас он стал нединамическим. Для того чтобы записать методы обратного вызова для данного класса, можно расширить класс и определить методы обратного вызова в вашем подклассе, или с помощью свойства <codeph>client</codeph> сделать ссылку на объект, а затем определить методы обратного вызова в отношении данного объекта.</p>
 
 </apiDesc><example conref="examples\NetConnectionExample.as"> В следующем примере объект Video с классами NetConnection и NetStream используется для загрузки и воспроизведения FLV-файла. Чтобы запустить данный пример, вам потребуется FLV-файл, имя и место расположения которого совпадают с переменной, переданной <codeph>videoURL</codeph>. В данном случае, FLV-файл Video.flv находится в том же каталоге, где размещается SWF-файл.
 <p>В данном примере код, создающий объекты Video и NetStream, а также вызывающий методы <codeph>Video.attachNetStream()</codeph> и <codeph>NetStream.play()</codeph>, размещен в функции обработчика. Обработчик вызывается только при успешном подключении к объекту NetConnection (другими словами, когда событие <codeph>netStatus</codeph> возвращает объект <codeph>info</codeph> со свойством <codeph>code</codeph>, что свидетельствует об успешном выполнении задачи). Рекомендуется перед вызовом <codeph>NetStream.play()</codeph> дождаться успешного подключения. </p>
 <codeblock>

package {
    import flash.display.Sprite;
    import flash.events.NetStatusEvent;
    import flash.events.SecurityErrorEvent;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.Event;

    public class NetConnectionExample extends Sprite {
        private var videoURL:String = "Video.flv";
        private var connection:NetConnection;
        private var stream:NetStream;

        public function NetConnectionExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
        }

        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Stream not found: " + videoURL);
                    break;
            }
        }

        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }

        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.client = new CustomClient();
            var video:Video = new Video();
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
    }
}

class CustomClient {
    public function onMetaData(info:Object):void {
        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);
    }
    public function onCuePoint(info:Object):void {
        trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.net.xml#NetConnection/client"><linktext>client</linktext></link><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.net.xml#NetConnection/connect()"><linktext>connect()</linktext></link><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection_flash.events.NetStatusEvent.NET_STATUS_netStatus"><apiName>netStatus</apiName><shortdesc>
 Отправляется, когда объект NetConnection сообщает о своем состоянии или о случившейся ошибке.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NetStatusEvent.NET_STATUS</apiEventType><adobeApiEventClassifier>flash.events.NetStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда объект NetConnection сообщает о своем состоянии или о случившейся ошибке. Событие <codeph>netStatus</codeph> содержит свойство <codeph>info</codeph>, представляющее собой информационный объект, который содержит определенные сведения о событии (например, количество успешных и неудачных попыток подключения). 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 Отправляется, если путем вызова метода NetConnection.call() предпринимается попытка подключения к серверу, расположенному за пределами изолированной среды вызывающего объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, если путем вызова метода <codeph>NetConnection.call()</codeph> предпринимается попытка подключения к серверу, расположенному за пределами изолированной среды вызывающего объекта.
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.net.xml#NetConnection/call()"><linktext>NetConnection.call()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою сетевой операции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда происходит ошибка ввода-вывода, приводящая к сбою сетевой операции. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.net:NetConnection_flash.events.AsyncErrorEvent.ASYNC_ERROR_asyncError"><apiName>asyncError</apiName><shortdesc>
 Отправляется, когда исключение создается асинхронным образом &amp;#x2014; то есть в коде, изначально имеющем асинхронную природу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.AsyncErrorEvent.ASYNC_ERROR</apiEventType><adobeApiEventClassifier>flash.events.AsyncErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда исключение создается асинхронным образом, то есть в коде, изначально имеющем асинхронную природу. 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.net:NetConnection:NetConnection"><apiName>NetConnection</apiName><shortdesc>
     Создает объект NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>See the example for <code>connect()</code>.
     
     </oldexample></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     Создает объект NetConnection. Чтобы установить подключение, вызовите <codeph>connect()</codeph>.
     
	 <p>Если приложению требуется обмен данными с серверами, выпущенными до выхода Flash Player 9, может потребоваться установить свойство <codeph>objectEncoding</codeph> объекта NetConnection.</p>
     
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.net.xml#NetConnection/connect()"><linktext>flash.net.NetConnection.connect()</linktext></link><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>objectEncoding</linktext></link></related-links></apiConstructor><apiOperation id="flash.net:NetConnection:addHeader"><apiName>addHeader</apiName><shortdesc>
     Добавляет заголовок контекста в структуру пакета Action Message Format (AMF).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>IMD: This method can be used in the client Flash Player for Flash Remoting
     and Flex apps. It is also a server side method used by Flash Media Server apps.
     
     
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Определяет заголовок и связанные с ним данные объекта ActionScript.
     
     </apiDesc></apiParam><apiParam><apiItemName>mustUnderstand</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Значение <codeph>true</codeph> указывает на то, что сервер должен принять и обработать данный заголовок, прежде чем он будет обрабатывать любой из следующих заголовков или сообщений.
     </apiDesc></apiParam><apiParam><apiItemName>param</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Любой объект ActionScript.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Добавляет заголовок контекста в структуру пакета Action Message Format (AMF). Этот заголовок отправляется с каждым последующим пакетом AMF. При вызове <codeph>NetConnection.addHeader()</codeph> с использованием того же самого имени новый заголовок заменяет существующий заголовок, при этом новый заголовок остается на всем протяжении существования объекта NetConnection. Для удаления заголовка, вызовите <codeph>NetConnection.addHeader()</codeph> с указанием имени заголовка для удаления объекта со значением undefined.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.net:NetConnection:call"><apiName>call</apiName><shortdesc>
     Вызывает команду или метод на сервере Flash Media Server или на сервере приложений, на котором запущен компонент Flash Remoting.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Метод, указанный в формате <codeph>[objectPath/]method</codeph>. Например, при выполнении команды <codeph>someObject/doSomething</codeph> удаленный сервер вызывает метод <codeph>clientObject.someObject.doSomething()</codeph> со всеми необязательными параметрами <codeph>... arguments</codeph>. При отсутствии пути к объекту на удаленном сервере вызывается <codeph>clientObject.doSomething()</codeph>.
     <p>
     При работе с Flash Media Server <codeph>command</codeph> – это имя функции, определенной в сценарии приложения на стороне сервера. Нет необходимости использовать путь к объекту перед <codeph>command</codeph>, если сценарий со стороны сервера размещен на корневом уровне каталога приложения.
     </p>
     
     </apiDesc></apiParam><apiParam><apiItemName>responder</apiItemName><apiOperationClassifier>flash.net:Responder</apiOperationClassifier><apiDesc>Дополнительный объект, используемый для обработки получаемых с сервера значений. Объект Responder может обработать возвращенный результат с помощью двух определенных методов: <codeph>result</codeph> и <codeph>status</codeph>. Если в качестве результата возвращается ошибка, вызывается <codeph>status</codeph>. В противном случае, вызывается <codeph>result</codeph>. Объект Responder может обрабатывать ошибки, связанные с определенными операциями, в то время как объект NetConnection реагирует на ошибки, связанные с состоянием подключения.
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Необязательные аргументы любого типа ActionScript, включая ссылку на другой объект ActionScript. Эти аргументы передаются методу, указанному в параметре <codeph>command</codeph>, в момент выполнения метода на удаленном сервере приложений.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Вызывает команду или метод на сервере Flash Media Server или на сервере приложений, на котором запущен компонент Flash Remoting. Перед тем как вызвать <codeph>NetConnection.call()</codeph>, необходимо подключиться к серверу путем вызова метода <codeph>NetConnection.connect()</codeph>. Для передачи данному методу необходимо создать функцию на стороне сервера. 
     
      <p>Нельзя подключаться к общепринятым зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#Responder"><linktext>flash.net.Responder</linktext></link></related-links><adobeApiEvent id="flash.net:NetConnection:call_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>Вызов предпринял попытку обращения к серверу за пределами изолированной программной среды вызывающего объекта. Чтобы избежать этой проблемы, используйте на сервере файл политик.
     </apiDesc></adobeApiEventDetail><shortdesc>Вызов предпринял попытку обращения к серверу за пределами изолированной программной среды вызывающего объекта.</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.net:NetConnection:close"><apiName>close</apiName><shortdesc>
     Закрывает открытое локальное подключение или подключение на сервере и отправляет событие netStatus со значением NetConnection.Connect.Closed для свойства code.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Закрывает открытое локальное подключение или подключение на сервере и отправляет событие <codeph>netStatus</codeph> со значением <codeph>NetConnection.Connect.Closed</codeph> для свойства <codeph>code</codeph>.
     
     <p>
     Данный метод отсоединяет все объекты NetStream, функционирующие через это подключение. Любые неотправленные данные, помещенные в очередь, игнорируются. (Чтобы завершить локальные или серверные потоки, не закрывая при этом подключения, используйте <codeph>NetStream.close()</codeph>.) Если после закрытия подключения требуется создать новое подключение, следует сначала создать новый объект NetConnection, а затем снова вызвать метод <codeph>connect()</codeph>.
     </p>
     
     <p>Метод <codeph>close()</codeph> также отсоединяет все удаленные общие объекты, функционирующие через это подключение. Тем не менее, для повторного подключения не требуется вновь создавать общий объект. Вместо этого следует просто вызвать метод <codeph>SharedObject.connect()</codeph>, чтобы восстановить подключение к общему объекту. Вдобавок, любые данные в общем объекте, которые были поставлены в очередь при вызове <codeph>NetConnection.close()</codeph>, будут отправлены после того, как будет восстановлено подключение к общему объекту.</p>
     
     <p>
     При работе с сервером Flash Media Server наиболее оптимальным вариантом является вызов <codeph>close()</codeph> в тот момент, когда клиенту больше не требуется подключение к серверу. Вызов <codeph>close()</codeph> является самым быстрым способом очистки неиспользуемых подключений. Можно настроить сервер на автоматическое закрытие неиспользуемых подключений. Дополнительные сведения см. в <i><xref href="http://www.adobe.com/support/documentation" scope="external">Руководстве по настройке и администрированию Flash Media Server</xref></i>. 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiOperation id="flash.net:NetConnection:connect"><apiName>connect</apiName><shortdesc>
     Создает двунаправленное соединение между приложением Flash Player или AIR и приложением Flash Media Server.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>NetConnection.connect, connect
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>URI-адрес, переданный параметру <codeph>command</codeph>, сформатирован неправильно.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>Сбой подключения. Это может произойти, если вы вызываете <codeph>connect()</codeph> из обработчика событий <codeph>netStatus</codeph>, что является недопустимой операцией.
     
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>Локальные для файловой системы SWF-файлы изолированы от Интернета. Этой проблемы можно избежать, если переклассифицировать данный SWF-файл как локальный с сетевым подключением или доверенный.
	 
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>Если вы пытаетесь подключиться к обычно зарезервированному порту. Полный список заблокированных портов см. в разделе «Ограничение сетевых API-интерфейсов» в главе «Безопасность» книги <i>Программирование на ActionScript 3.0</i>.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Установите для этого параметра значение <codeph>null</codeph>, если вы подключаетесь к видеофайлу на локальном компьютере. При подключении к серверу установите для этого параметра URI-адрес приложения, в котором содержится видеофайл на сервере. Используйте следующий синтаксис (элементы в квадратных скобках не являются обязательными):
     
     <p><codeph>protocol:[//host][:port]/appname[/instanceName]</codeph></p>
     
     <p>Для подключения к серверу Flash Media Server используйте в качестве протокола <codeph>rtmp</codeph>, <codeph>rtmpe</codeph>, <codeph>rtmps</codeph>, <codeph>rtmpt</codeph>, <codeph>rtmpte</codeph> или <codeph>rtmfp</codeph>. При успешном подключении возвращается событие <codeph>netStatus</codeph>, в котором свойство <codeph>code</codeph> имеет значение <codeph>NetConnection.Connect.Success</codeph>. Список всех кодов событий, возвращаемых в ответ на вызов <codeph>connect()</codeph>, см. в свойстве <codeph>NetStatusEvent.info</codeph>.
     </p>
     
     <p>Если файл обслуживается с того же узла, на котором установлен сервер, параметр <codeph>host</codeph> можно опустить. Если опустить параметр <codeph>instanceName</codeph>, проигрыватель <ph platform="actionscript">Flash Player или</ph> AIR подключится к используемому по умолчанию экземпляру приложения.</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Необязательные параметры любого типа, которые должны быть переданы приложению, указанному в параметре <codeph>command</codeph>. При работе с Flash Media Server дополнительные аргументы передаются обработчику событий <codeph>application.onConnect()</codeph> в коде приложения на стороне сервера. Необходимо определить и обработать аргументы в <codeph>onConnect()</codeph>.
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Создает двунаправленное соединение между приложениями <ph platform="actionscript">Flash Player или AIR</ph> <ph platform="javascript">AIR</ph> и приложением Flash Media Server. Объект NetConnection представляет собой определенный канал, соединяющий клиент и сервер. Используйте объекты NetStream для отправки потоков по каналу. Информацию о кодеках и форматах видеофайлов, поддерживаемых Flash Media Server, см. в <xref href="http://www.adobe.com/support/documentation" scope="external">документации по серверу Flash Media Server</xref>.
     
     <p>
     При отсутствии Flash Media Server метод <codeph>NetConnection.connect()</codeph> можно использовать для воспроизведения видео и MP3-файлов из локальной файловой системы или с web-сервера. Информацию о поддерживаемых кодеках и форматах файлов см. по адресу <xref href="http://www.adobe.com/go/hardware_scaling_ru" scope="external">http://www.adobe.com/go/hardware_scaling_ru</xref>.
     </p>
     
     <p>
     Создает двунаправленное соединение между <ph platform="actionscript">Flash Player или AIR</ph> <ph platform="javascript">AIR</ph> и сервером приложений, на котором запущена служба Flash Remoting. Используйте класс NetServices для вызова функций и получения результатов от серверов приложений посредством объекта NetConnection. Дополнительные сведения см. в <xref href="http://www.adobe.com/support/documentation" scope="external">документации по Flash Remoting</xref>. 
     </p>
     
	 <p>При использовании данного метода необходимо учесть следующую модель безопасности:</p>
     
     <ul>
      <li>По умолчанию проигрыватель <ph platform="actionscript">Flash Player или</ph> AIR блокирует взаимодействие (доступ) между изолированными программными средами. Web-сайт может обеспечить доступ к ресурсу с помощью файла политики для URL. </li>
     
      <li>Ваше приложение может запретить доступ к какому-либо ресурсу на сервере. Чтобы запретить доступ, в приложении Flash Media Server необходимо добавить код на стороне сервера. Подробные сведения см. в документации по Flash Media Server. </li> 
     
      <li>Метод <codeph>NetConnection.connect()</codeph> нельзя использовать, если вызывающий файл размещен в локальной для файловой системы изолированной программной среде.</li>
     
      <li>Нельзя подключаться к общим зарезервированным портам. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>. </li>
     
     <li>Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</li>
     
     </ul>
     
	 <p>Однако в Adobe AIR эти ограничения по безопасности не распространяются на содержимое в изолированной программной среде безопасности <codeph>application</codeph> (содержимое, установленной с приложением AIR).</p>
	 
     <p>Дополнительные сведения см. в следующих источниках.</p>
     
     <ul>
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     </ul>
     
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.net.xml#NetStream"><linktext>flash.net.NetStream</linktext></link><link href="flash.events.xml#NetStatusEvent/info"><linktext>flash.events.NetStatusEvent.info</linktext></link></related-links></apiOperation><apiValue id="flash.net:NetConnection:client:get"><apiName>client</apiName><shortdesc>
     Указывает объект, для которого должны быть вызваны методы ответного вызова.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Property documented; needs review.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>В качестве свойства <codeph>client</codeph> должен быть указан объект, не имеющий значение null. 
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Указывает объект, для которого должны быть вызваны методы ответного вызова. По умолчанию используется данный экземпляр NetConnection. Если в свойстве <codeph>client</codeph> указать другой объект, методы обратного вызова будут вызываться на этом другом объекте.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connected:get"><apiName>connected</apiName><shortdesc>
	 Указывает, подключено приложение к серверу через постоянное подключение RTMP (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, подключено приложение к серверу через постоянное подключение RTMP (<codeph>true</codeph>) или нет (<codeph>false</codeph>). При подключении по протоколу HTTP данное свойство имеет значение <codeph>false</codeph>, за исключением случаев подключения к службам Flash Remoting на сервере приложений (значение <codeph>true</codeph>). 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:connectedProxyType:get"><apiName>connectedProxyType</apiName><shortdesc>
     Тип прокси, используемый для успешного вызова NetConnection.connect() в отношении сервера Flash Media Server: none, HTTP, HTTPS или CONNECT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Зарегистрирована попытка обращения к данному свойству, когда экземпляр NetConnection не был подключен. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Тип прокси, используемый для успешного вызова <codeph>NetConnection.connect()</codeph> в отношении сервера Flash Media Server: <codeph>none</codeph>, <codeph>HTTP</codeph>, <codeph>HTTPS</codeph> или <codeph>CONNECT</codeph>. Значение <codeph>none</codeph> используется при подключении без туннелирования, <codeph>HTTP</codeph> –при подключении посредством туннелирования по протоколу HTTP, <codeph>HTTPS</codeph> – при подключении посредством туннелирования по протоколу HTTPS, <codeph>CONNECT</codeph> – при подключении посредством туннелирования с использованием метода HTTP CONNECT.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 Кодировка объекта, используемая по умолчанию для объектов NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Кодировка объекта, используемая по умолчанию для объектов NetConnection. Когда объект записывается или считывается из двоичных данных, свойство <codeph>defaultObjectEncoding</codeph> указывает используемую для сериализации версию формата AMF: формат ActionScript 3.0 (<codeph>ObjectEncoding.AMF3</codeph>) или формат ActionScript 1.0 и ActionScript 2.0 (<codeph>ObjectEncoding.AMF0</codeph>). 
     
     <p>Значение по умолчанию: <codeph>ObjectEncoding.AMF3</codeph>. Изменение <codeph>NetConnection.defaultObjectEncoding</codeph> не влияет на существующие экземпляры NetConnection, а влияет только на экземпляры, которые будут созданы позднее.</p>
     
     <p>Чтобы установить кодировку для отдельного объекта (не для всего приложения), задайте свойство <codeph>objectEncoding</codeph> соответствующего объекта NetConnection.</p>
     
     <p>Более подробные сведения см. в описании свойства <codeph>objectEncoding</codeph>.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/objectEncoding"><linktext>NetConnection.objectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farID:get"><apiName>farID</apiName><shortdesc>
     Идентификатор экземпляра Flash Media Server, к которому подключен данных экземпляр Flash Player или Adobe AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Идентификатор экземпляра Flash Media Server, к которому подключен данных экземпляр Flash Player или Adobe AIR. Это свойство имеет значение только для подключений RTMFP. Значение этого свойства доступно только после установки подключения RTMFP.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/nearID"><linktext>nearID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:farNonce:get"><apiName>farNonce</apiName><shortdesc>
     Значение, выбираемое преимущественно этим сервером Flash Media Server (уникально для данного подключения).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение, выбираемое преимущественно этим сервером Flash Media Server (уникально для данного подключения). Это значение представляется серверу в качестве его значения <codeph>client.nearNonce</codeph>. Это свойство определяется только для подключений RTMFP, RTMPE или RTMPTE.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:maxPeerConnections:get"><apiName>maxPeerConnections</apiName><shortdesc>
     Общее количество входящих и исходящих одноранговых подключений, разрешенное данным экземпляром Flash Player или Adobe AIR.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Общее количество входящих и исходящих одноранговых подключений, разрешенное данным экземпляром Flash Player или Adobe AIR. Значением по умолчанию является 8. 
     <p>Это значение не различает подключения издателей и подписчиков. Если это значение уменьшить в момент, когда уже существуют одноранговые подключения, новое значение затрагивает только новые входящие подключения. Существующие подключения не прерываются.</p>
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:nearID:get"><apiName>nearID</apiName><shortdesc>
     Идентификатор данного экземпляра Flash Player или Adobe AIR для данного экземпляра NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Идентификатор данного экземпляра Flash Player или Adobe AIR для данного экземпляра NetConnection. Это свойство имеет значение только для подключений RTMFP.
     
     <p>Каждый экземпляр NetConnection имеет уникальное свойство <codeph>nearID</codeph>. Все экземпляры Flash Player, Adobe AIR и NetConnection имеют разные идентификаторы.</p>
     
     <p>Другие экземпляры Flash Player или Adobe AIR используют этот идентификатор в качестве <codeph>peerID</codeph> для новых подключений NetStream к этому клиенту. Впоследствии этот идентификатор становится <codeph>farID</codeph> в одноранговых NetStream, подключающихся к данному экземпляру.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/farID"><linktext>farID</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:nearNonce:get"><apiName>nearNonce</apiName><shortdesc>
     Значение, выбираемое преимущественно этим экземпляром Flash Player или Adobe AIR (уникально для данного подключения).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Значение, выбираемое преимущественно этим экземпляром Flash Player или Adobe AIR (уникально для данного подключения). Это значение представляется серверу в качестве его значения <codeph>client.farNonce</codeph>. Это свойство определяется только для подключений RTMFP, RTMPE или RTMPTE.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Кодировка объекта для данного экземпляра NetConnection.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>Была произведена попытка установить значение свойства <codeph>objectEncoding</codeph> в тот момент, когда экземпляр NetConnection был подключен.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiException><apiDesc>Данное свойство имело значение, отличное от <codeph>ObjectEncoding.AMF0</codeph> или <codeph>ObjectEncoding.AMF3</codeph>.
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Кодировка объекта для данного экземпляра NetConnection.
     
     <p>
     Когда объект записывается или считывается из двоичных данных, свойство <codeph>defaultObjectEncoding</codeph> указывает используемую для сериализации версию формата AMF: формат ActionScript 3.0 (<codeph>ObjectEncoding.AMF3</codeph>) или формат ActionScript 1.0 и ActionScript 2.0 (<codeph>ObjectEncoding.AMF0</codeph>). Чтобы установить версию AMF для экземпляра NetConnection, укажите значение для свойства <codeph>objectEncoding</codeph>.
     </p>
     
	 <p>Необходимо хорошо понимать назначение этого свойства, если приложению требуется обмен данными с серверами, выпущенными до выхода Flash Player версии 9. Возможны три следующих сценария действий:
     </p>
     
     <ul>
	 <li>Подключение к серверу, поддерживающему AMF3 (например, Flex Data Services 2 или Flash Media Server 3). Значение <codeph>defaultObjectEncoding</codeph> по умолчанию: <codeph>ObjectEncoding.AMF3</codeph>. Ко всем экземплярам NetConnection, созданным в данном файле, применяется сериализация формата AMF3, поэтому свойство <codeph>objectEncoding</codeph> задавать не требуется.</li>
       
     <li>Подключение к серверу, который не поддерживает AMF3 (например, Flash Media Server 2). В этом случае необходимо установить для статического свойства <codeph>NetConnection.defaultObjectEncoding</codeph> значение <codeph>ObjectEncoding.AMF0</codeph>. Все экземпляры NetConnection, созданные в данном SWF-файле, используют сериализацию AMF0. Нет необходимости устанавливать значение свойства <codeph>objectEncoding</codeph>. </li>
     
     <li>Подключение к нескольким серверам, на которых используются разные версии кодировки. Вместо того чтобы использовать <codeph>defaultObjectEncoding</codeph>, установите кодировку объекта для каждого подключения с помощью свойства <codeph>objectEncoding</codeph>. Установите значение <codeph>ObjectEncoding.AMF0</codeph>, чтобы подключаться к серверам, использующим кодировку AMF0 (например, Flash Media Server 2). Аналогично, установите значение <codeph>ObjectEncoding.AMF3</codeph> для подключения к серверам, которые используют кодировку AMF3 (например, Flex Data Services 2).</li>
     </ul>
     
     <p>Как только происходит подключение экземпляра NetConnection, его свойство <codeph>objectEncoding</codeph> становится доступным только для чтения.</p>
     
	 <p>Если при подключении к серверу используется неправильная кодировка, объект NetConnection отправляет событие <codeph>netStatus</codeph>. Свойство <codeph>NetStatusEvent.info</codeph> содержит информационный объект, в котором свойство <codeph>code</codeph> имеет значение <codeph>NetConnection.Connect.Failed</codeph>, и описание, объясняющее, что выбрана неправильная кодировка.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/defaultObjectEncoding"><linktext>defaultObjectEncoding</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:protocol:get"><apiName>protocol</apiName><shortdesc>
     Протокол, используемый для установки подключения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Зарегистрирована попытка обращения к данному свойству, когда экземпляр NetConnection не был подключен. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Протокол, используемый для установки подключения. Это свойство релевантно при использовании Flash Media Server. Возможны следующие значения:
     <ul>
     <li><codeph>rtmp</codeph>: протокол передачи сообщений в реальном времени (RTMP)</li>
     <li><codeph>rtmpe</codeph>: зашифрованный RTMP</li>
     <li><codeph>rtmpt</codeph>: RTMP с НТТР-туннелированием</li>
     <li><codeph>rtmpte</codeph>: зашифрованный RTMP с НТТР-туннелированием</li>
     <li><codeph>rtmps</codeph>: RTMP на базе HTTPS</li>
     <li><codeph>rtmfp</codeph>: протокол потоковой передачи медиаданных в реальном времени (RTMFP)</li>
     </ul>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:proxyType:get"><apiName>proxyType</apiName><shortdesc>
     Определяет применяемые методы восстановления в случае сбоя при первоначальной попытке подключения к серверу.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>This property is used in Breeze 5.5. In the Breeze Add-in, the default value is <code>"best"</code>; if this value
     is not changed, native SSL sockets are used by default, and a fallback
     to other methods is used if necessary. 
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Определяет применяемые методы восстановления в случае сбоя при первоначальной попытке подключения к серверу. Свойство <codeph>proxyType</codeph> необходимо установить до того, как будет вызываться метод <codeph>NetConnection.connect()</codeph>.
     
     <p>Допустимые значения: <codeph>none</codeph>, <codeph>HTTP</codeph>, <codeph>CONNECT</codeph> и <codeph>best</codeph>.</p>
     
	 <p>Значением по умолчанию для данного свойства является <codeph>none</codeph>. Если это значение не будет изменено, приложение будет использовать для RTMPS туннелирование по протоколу HTTPS. Если свойство имеет значение <codeph>best</codeph>, клиент предпринимает попытку подключиться с помощью собственного протокола SSL. После неудачного подключения проводятся попытки применения других способов подключения. Если свойство имеет значение <codeph>HTTP</codeph> и прямое подключение выполняется с ошибкой, используется туннелирование по протоколу HTTP. Если свойство имеет значение <codeph>CONNECT</codeph> и прямое подключение выполняется с ошибкой, используется метод туннелирования <codeph>CONNECT</codeph>. Если и это приведет к сбою, подключение не будет возвращаться к туннелированию по протоколу HTTP.</p>
     
     <p>Это свойство применяется только при использовании RTMP, RTMPS или RTMPT. Метод <codeph>CONNECT</codeph> применим только к тем пользователям, которые подключены к сети с помощью прокси-сервера.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:unconnectedPeerStreams:get"><apiName>unconnectedPeerStreams</apiName><shortdesc>
     
     Объект, содержащий все объекты NetStream одноранговых подписчиков, не связанные с публикующими объектами NetStream.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     
     Объект, содержащий все объекты NetStream одноранговых подписчиков, не связанные с публикующими объектами NetStream. Объекты-подписчики NetStream, связанные с публикующими объектами NetStream, перечислены в массиве <codeph>NetStream.peerStreams</codeph>.
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetStream/peerStreams"><linktext>NetStream.peerStreams</linktext></link></related-links></apiValue><apiValue id="flash.net:NetConnection:uri:get"><apiName>uri</apiName><shortdesc>
     URI-адрес, передаваемый методу NetConnection.connect().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>server-specific: Documented this method with server-specific info in span tags. The
     info is relevant for Flex servers, as well as Flash Media Server.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     URI-адрес, передаваемый методу <codeph>NetConnection.connect()</codeph>. Если метод <codeph>NetConnection.connect()</codeph> не был вызван или не был передан какой-либо URI-адрес, данное свойство имеет значение <codeph>undefined</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.net:NetConnection:usingTLS:get"><apiName>usingTLS</apiName><shortdesc>
     Определяет, создавалось ли защищенное подключение с применением собственного протокола Transport Layer Security (TLS) вместо HTTPS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Зарегистрирована попытка обращения к данному свойству, когда экземпляр NetConnection не был подключен. 
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Определяет, создавалось ли защищенное подключение с применением собственного протокола Transport Layer Security (TLS) вместо HTTPS. Это свойство действительно только тогда, когда подключен объект NetConnection.
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>