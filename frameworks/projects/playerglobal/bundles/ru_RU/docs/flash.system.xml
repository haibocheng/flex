<?xml version="1.0"?>
<apiPackage id="flash.system"><apiName>flash.system</apiName><apiDetail/><apiClassifier id="flash.system:Security"><apiName>Security</apiName><shortdesc>
 Класс Security позволяет задать способ взаимодействия содержимого в различных доменах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, XMLNode object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Security позволяет задать способ взаимодействия содержимого в различных доменах.
 
 </apiDesc><example conref="examples\SecurityExample.as"> В следующем примере показано, как событие <codeph>click</codeph> для объекта Sprite может использоваться для отображения панели параметров локального хранилища в окне параметров проигрывателя Flash Player. К рабочей области добавляется оранжевый прямоугольник с помощью метода<codeph>draw()</codeph>. В методе <codeph>draw()</codeph>, добавляется прослушиватель события <codeph>click</codeph> с именем <codeph>clickHandler()</codeph>, который драгирует на события <codeph>click</codeph>, вызывая открытие панели настроек локального хранилища в проигрывателе Flash Player.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.*;
    import flash.system.Security;
    import flash.system.SecurityPanel;

    public class SecurityExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 100;

        public function SecurityExample() {
            draw();
        }

        private function draw():void {
            var child:Sprite = new Sprite();
            child.graphics.beginFill(bgColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            child.buttonMode = true;

            var label:TextField = new TextField();
            label.text = "settings";
            label.selectable = false;
            label.mouseEnabled = false;
            child.addChild(label);

            child.addEventListener(MouseEvent.CLICK, clickHandler);
            addChild(child);
        }

        private function clickHandler(event:MouseEvent):void {
            Security.showSettings(SecurityPanel.LOCAL_STORAGE);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.system:Security:allowDomain"><apiName>allowDomain</apiName><shortdesc>
     Позволяет SWF-файлам в указанных доменах обращаться к объектам и переменным в SWF-файле, содержащем вызов allowDomain().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.allowDomain, allowDomain
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>При вызове этого метода из кода в изолированной среде безопасности приложения AIR порождается исключение SecurityError. Содержимое за пределами изолированной среды безопасности приложения не может выполнять перекрестные сценарии для находящегося в ней содержимого. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Одна или несколько строк, а также объектов URLRequest, указывающие на домены, из которых требуется разрешить доступ. Можно указать особый домен «~~», чтобы разрешить доступ из всех доменов.  
     
     <p product="flashonly">Указание домена «~~» является единственным способом разрешения доступа к нелокальным SWF-файлам из локальных SWF-файлов, опубликованных с помощью инструмента разработки Adobe Flash с установленным для параметра «Безопасность локального воспроизведения» режимом «Предоставлен доступ только к сети».</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Обеспечивает SWF- и HTML-файлам доступ к объектам и переменным в вызывающем SWF-файле.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <ph platform="actionscript">Обеспечивает файлам SWF в указанных доменах доступ к объектам и переменным в файле SWF, содержащем вызов<codeph>allowDomain()</codeph>. </ph>
     
     <p platform="javascript">Этот метод применяется к перекрестному выполнению сценариев кода ActionScript 3.0 (в SWF-содержимом). Не применяется к коду JavaScript, выполняемому в приложениях AIR на основе HTML.</p>
     
     <p platform="actionscript"><i>Примечание.</i> При вызове этого метода из кода в изолированной среде безопасности приложения AIR порождается исключение SecurityError. Содержимое за пределами домена защиты приложения не может выполнять перекрестные сценарии для находящегося в ней содержимого. Однако содержимое, находящееся за пределами изолированной программной среды приложения, может обращаться к содержимому в этой среде с помощью так называемого моста.</p>
     
     <p platform="actionscript">Если два SWF-файла размещаются на одном домене, например http://mysite.com/swfA.swf и http://mysite.com/swfB.swf, то swfA.swf может анализировать и модифицировать переменные, объекты, свойства, методы и прочее в swfB.swf и наоборот. Это называется <i>выполнением сценариев между роликами</i> или <i>выполнением перекрестных сценариев</i>.</p>
     
     <p platform="actionscript">Если два SWF-файла находятся в разных доменах, например http://siteA.com/swfA.swf и http://siteB.com/siteB.swf, то по умолчанию Flash Player не позволяет swfA.swf выполнять сценарии, связанные с swfB.swf, и наоборот. SWF-файл передает данные SWF-файлам из других доменов путем вызова <codeph>Security.allowDomain()</codeph>. Это называется <i>выполнением междоменных сценариев</i>. Вызывая <codeph>Security.allowDomain("siteA.com")</codeph>, siteB.swf дает siteA.swf разрешение на выполнение сценариев.</p>
     
     <p platform="actionscript">При междоменном вызове важно знать о двух участвующих сторонах. В этой документации сторона, осуществляющая перекрестное выполнение сценариев, называется <i>вызывающей стороной</i> (обычно вызывающий SWF-файл), а другая сторона называется <i>вызываемой стороной</i> (обычно вызываемый SWF-файл). Если файл siteA.swf создает сценарий для стороны siteB.swf, файл siteA.swf является вызывающей стороной, а файл siteB.swf – вызываемой стороной.</p>
     
     <p platform="actionscript"><adobeimage alt="Междоменная диаграмма" href="../../images/crossScript_load.jpg"/></p>
     
     <p platform="actionscript">Междоменные права доступа, которые задаются с использованием метода <codeph>allowDomain()</codeph>, являются несимметричными. В предыдущем сценарии файл siteA.swf может создавать сценарий для файла siteB.swf, но файл siteB.swf не может создавать сценарий для файла siteA.swf, поскольку в файле siteA.swf отсутствует обращение к методу <codeph>allowDomain()</codeph> для предоставления SWF-файлам в узле siteB.com разрешения на создания сценариев. Можно настроить симметричные права доступа путем создания обращения в обоих SWF-файлах к методу <codeph>allowDomain()</codeph>.</p>
     
     <p platform="actionscript">Кроме защиты SWF-файлов от междоменного создания сценариев другими SWF-файлами, в приложении Flash Player предусмотрена защита SWF-файлов от междоменного создания сценариев с использованием файлов HTML. Создание сценариев из файлов HTML в SWF-файлах может выполняться с использованием функций браузеров более ранних версий, например <codeph>SetVariable</codeph>, или обратных вызовов в функции <codeph>ExternalInterface.addCallback()</codeph>. Если создание сценариев из файлов HTML в SWF-файлах выполняется между доменами, вызываемый SWF-файл должен обращаться к методу <codeph>allowDomain()</codeph>, как и в том случае, если вызывающей стороной является SWF-файл, или произойдет сбой операции.</p>
     
     <p platform="actionscript">При указании IP-адреса в качестве параметра для <codeph>allowDomain()</codeph> доступ всем сторонам, расположенным по указанному IP-адресу, предоставлен не будет. Благодаря этому можно разрешить доступ только стороне, которая содержит указанный IP-адрес в своем URL-адресе, а не имя домена, указывающее на этот IP-адрес.</p> 
     
     <p platform="actionscript"><b>Различия, характерные для версий</b></p>
     <p platform="actionscript">Правила междоменной защиты Flash Player изменяются от версии к версии. В следующей таблице приводится сводная информация о различиях.</p>
     
     <adobetable class="innertable" platform="actionscript">
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Последние версии SWF участвуют в перекрестном выполнении сценариев</entry><entry>Необходимость <codeph>allowDomain()</codeph>?</entry><entry>Необходимость <codeph>allowInsecureDomain()</codeph>?</entry><entry>SWF-файл, который должен вызывать метод <codeph>allowDomain()</codeph> или <codeph>allowInsecureDomain()</codeph></entry><entry>Сведения, которые необходимо указать в <codeph>allowDomain()</codeph> или <codeph>allowInsecureDomain()</codeph></entry></row></thead><tbody><row>
       <entry align="center">5 или более ранняя</entry>
       <entry>Нет</entry>
       <entry align="center">Нет</entry>
       <entry align="center">нет</entry>
       <entry align="center">нет</entry>
     </row><row>
       <entry align="center">6</entry>
       <entry>Да, если сверхобласти не соответствуют</entry>
       <entry align="center">Нет</entry>
       <entry>Вызываемый SWF-файл или любой SWF-файл с такой же сверхобластью, как и у вызываемого SWF-файла</entry>
       <entry><ul>
         <li>Текстовый домен (mysite.com)</li>
         <li>IP-адрес (192.168.1.1)</li>
       </ul></entry>
     </row><row>
       <entry align="center">7</entry>
       <entry>Да, если отсутствует точное соответствие доменов</entry>
       <entry>Да, при выполнении доступа с HTTP к HTTPS (даже при точном соответствии доменов)</entry>
       <entry>Вызываемый SWF-файл или любой SWF-файл с доменом, точно соответствующим домену вызываемого SWF-файла</entry>
       <entry><ul>
         <li>Текстовый домен (mysite.com)</li>
         <li>IP-адрес (192.168.1.1)</li>
       </ul></entry>
     </row><row>
       <entry align="center">8 и более поздних версий</entry>
       <entry>Да, если отсутствует точное соответствие доменов</entry>
       <entry>Да, при выполнении доступа с HTTP к HTTPS (даже при точном соответствии доменов)</entry>
       <entry>Вызываемый SWF-файл</entry>
       <entry><ul>
         <li>Текстовый домен (mysite.com)</li>
         <li>IP-адрес (192.168.1.1)</li>
         <li>Подстановочный знак (~~)</li>
       </ul></entry>
     </row></tbody></tgroup></adobetable>
      
     <p platform="actionscript">Версиями, в которых можно управлять поведением Flash Player, являются <i>версии SWF</i> (опубликованные версии SWF-файла), но не версии приложения Flash Player. Например, когда в приложении Flash Player 8 воспроизводится SWF-файл, опубликованный для версии 7, применяется поведение, характерное для версии 7. Такой подход позволяет убедиться в том, что поведение <codeph>Security.allowDomain()</codeph> в развернутых SWF-файлах не изменится из-за обновлений проигрывателя.</p>
     
     <p platform="actionscript">В столбце с версиями в предыдущей таблице указана последняя версия SWF, которая задействована в операции перекрестного выполнения сценариев. Поведение Flash Player определяется в соответствии с версией вызывающего SWF-файла или вызываемого SWF-файла в зависимости от того, какая версия является новее.</p>
     
     <p platform="actionscript">В следующих параграфах приводятся дополнительные сведения об изменениях безопасности Flash Player, в которых задействован метод <codeph>Security.allowDomain()</codeph>.</p>
     
     <p platform="actionscript"><b>Версия 5</b>. Ограничения на междоменное выполнение сценариев не накладываются.</p>
     
     <p platform="actionscript"><b>Версия 6</b>. Вводится защита междоменного выполнения сценариев. По умолчанию в приложении Flash Player междоменное выполнение сценариев запрещено; его можно разрешить с помощью метода <codeph>Security.allowDomain()</codeph>. Чтобы определить, находятся ли оба файла в одном домене, в приложении Flash Player используется сверхобласть каждого файла, которая представляет собой точное имя узла из URL-адреса файла, за исключением первого сегмента, но состоит как минимум из двух сегментов. Например, сверхобластью узла www.mysite.com является mysite.com. SWF-файлы с узлов www.mysite.com и store.mysite.com могут осуществлять перекрестное выполнение сценариев без вызова метода <codeph>Security.allowDomain()</codeph>.</p>
     
     <p platform="actionscript"><b>Версия 7</b>. Соответствие сверхобластей заменено на точное соответствие доменов. Двум файлам разрешено перекрестное выполнение сценариев, только если имена узлов в их URL-адресах полностью идентичны; в противном случае необходимо вызвать метод <codeph>Security.allowDomain()</codeph>. По умолчанию файлам, загруженным с URL-адресов, отличных от HTTPS, запрещено выполнять сценарии в файлах, загруженных с URL-адресов HTTPS, даже если файлы загружены с полностью идентичного домена. Благодаря этому ограничению можно защитить файлы HTTPS, поскольку файл, отличный от HTTPS, подвержен изменениям при загрузке, а злоумышленно измененный файл, отличный от HTTPS, может повредить файл HTTPS, который в противном случае защищен от такого повреждения. Метод <codeph>Security.allowInsecureDomain()</codeph> используется, чтобы разрешить вызываемым SWF-файлам HTTPS свободно отключать это ограничение, но метод <codeph>Security.allowInsecureDomain()</codeph> использовать не рекомендуется.</p>
     
     <p platform="actionscript"><b>Версия 8</b>. Изменения представлены в двух основных областях:</p>
     
     <ul platform="actionscript">
       <li>Обращение к методу <codeph>Security.allowDomain()</codeph> теперь позволяет осуществлять операции междоменного выполнения сценариев, только если вызываемый SWF-файл является SWF-файлом, вызывающим метод <codeph>Security.allowDomain()</codeph>. Другими словами, доступ предоставляется только SWF-файлу, который вызывает метод <codeph>Security.allowDomain()</codeph>. В предыдущих версиях обращение к методу <codeph>Security.allowDomain()</codeph> позволяло разрешить перекрестное выполнение сценариев, в то время как вызываемый SWF-файл мог быть любым SWF-файлом в том же домене, что и SWF-файл, вызывающий метод <codeph>Security.allowDomain()</codeph>. Ранее обращение к методу <codeph>Security.allowDomain()</codeph> позволяло открыть весь домен вызывающего SWF-файла.</li>
     
       <li>Добавлена поддержка значений подстановочного символа в методах <codeph>Security.allowDomain("~~")</codeph> и <codeph>Security.allowInsecureDomain("~~")</codeph>. Использование значения подстановочного символа (~~) позволяет разрешить операции перекрестного выполнения сценариев, если вызываемый файл является любым файлом, загруженным с любого узла. Подстановочный символ можно рассматривать как глобальное предоставление прав. Права доступа, предоставленные с использованием подстановочного символа, необходимы для включения определенных операций в соответствии с правилами безопасности локального файла. В частности, чтобы локальный SWF-файл с правами сетевого доступа мог выполнять сценарий в SWF-файле в Интернете, вызываемый интернет-файл SWF должен обращаться к методу <codeph>Security.allowDomain("~~")</codeph>, в котором указано, что источник локального SWF-файла неизвестен. (Если Интернет-файл SWF загружен с использованием адреса URL HTTPS, вместо этого интернет-файл SWF должен обращаться к методу <codeph>Security.allowInsecureDomain("~~")</codeph>.)</li>
     </ul>
       
     <p platform="actionscript">Иногда возникает следующая ситуация: выполняется загрузка нижестоящий SWF-файла из другого домена, и необходимо разрешить нижестоящему SWF-файлу выполнять сценарий в вышестоящем SWF-файле, но при этом конечный домен нижестоящего SWF-файла неизвестен. Это может случиться, например, при использовании перенаправлений для балансировки нагрузки или серверов независимых производителей.</p>
     
     <p platform="actionscript">В этой ситуации можно использовать свойство <codeph>url</codeph> объекта URLRequest, переданного в метод <codeph>Loader.load()</codeph>. Например, если загружен нижестоящий SWF-файл в вышестоящий SWF-файл, можно получить доступ к свойству <codeph>contentLoaderInfo</codeph> объекта Loader для вышестоящего SWF-файла: </p>
     <codeblock platform="actionscript">Security.allowDomain(loader.contentLoaderInfo.url)</codeblock>
     
     <p platform="actionscript">Для получения правильного значения свойства <codeph>url</codeph> необходимо дождаться начала загрузки нижестоящего SWF-файла. Чтобы определить, когда началась загрузка нижестоящего SWF-файла, используйте событие <codeph>progress</codeph>.</p>
     
     <p platform="actionscript">Кроме того, может возникнуть противоположная ситуация; то есть можно создать нижестоящий SWF-файл, в котором необходимо разрешить выполнение сценария вышестоящим файлом, но при этом домен вышестоящего файла неизвестен. В этой ситуации можно получить доступ к свойству <codeph>loaderInfo</codeph> экранного объекта, который является корневым объектом SWF-файла. В нижестоящем SWF-файле необходимо вызвать <codeph> Security.allowDomain( this.root.loaderInfo.loaderURL)</codeph>. Нет необходимости ждать загрузки вышестоящего SWF-файла – он уже будет загружен к тому времени, когда будет проходить загрузка нижестоящего файла.</p>
     
     <p platform="actionscript">При публикации для Flash Player 8 или более поздней версии можно также решить эти ситуации, вызвав <codeph>Security.allowDomain("~~")</codeph>. Однако это решение может быть опасным, поскольку при этом доступ к вызывающему SWF-файлу разрешается любому SWF-файлу из любого домена. Использование свойства <codeph>_url</codeph> является более безопасным.</p> 
     
     <p platform="actionscript">Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul platform="actionscript">
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
     
     
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.external.xml#ExternalInterface/addCallback()"><linktext>ExternalInterface.addCallback()</linktext></link><link href="flash.events.xml#Event/COMPLETE"><linktext>flash.events.Event.COMPLETE</linktext></link><link href="flash.display.xml#DisplayObject/parent"><linktext>flash.display.DisplayObject.parent</linktext></link><link href="flash.net.xml#URLRequest/url"><linktext>flash.net.URLRequest.url</linktext></link><link href="flash.system.xml#Security/allowInsecureDomain()"><linktext>allowInsecureDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:Security:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
     Позволяет SWF- и HTML-файлам в определенных доменах обращаться к объектам и переменным в вызывающем SWF-файле, размещенном на сервере с использованием протокола HTTPS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.allowInsecureDomain, allowInsecureDomain
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>При вызове этого метода из кода в изолированной среде безопасности приложения AIR выдается исключение SecurityError. Содержимое за пределами изолированной среды безопасности приложения не может выполнять перекрестные сценарии для находящегося в ней содержимого. 
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/><apiDesc>Одна или несколько строк, а также объектов URLRequest, указывающие на домены, из которых требуется разрешить доступ. Можно указать особый домен «~~», чтобы разрешить доступ из всех доменов.  
     
     <p class="flashonly">Указание домена «~~» является единственным способом разрешения доступа к нелокальным SWF-файлам из локальных SWF-файлов, опубликованных с помощью инструмента разработки Adobe Flash с установленным для параметра «Безопасность локального воспроизведения» режимом «Предоставлен доступ только к сети» (Файл > Параметры публикации > вкладка Flash).</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>Обеспечивает SWF- и HTML-файлам, принимаемым с помощью протокола HTTPS, доступ к объектам и переменным в вызывающем SWF-файле.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     <ph platform="actionscript">Обеспечивает файлам SWF и HTML в указанных доменах доступ к объектам и переменным в вызывающем файле SWF, размещенном на сервере с использованием протокола HTTPS. </ph>
     
     <p platform="javascript">Этот метод применяется к перекрестному выполнению сценариев кода ActionScript 3.0 (в SWF-содержимом). Не применяется к коду JavaScript, выполняемому в приложениях AIR на основе HTML.</p>
     
     
     <p platform="actionscript">В проигрывателе Flash Player этот метод <codeph>allowInsecureDomain()</codeph> предусмотрен для увеличения гибкости, но вызывать его не рекомендуется. Размещение файлов с использованием HTTPS обеспечивает несколько факторов защиты для вас и ваших пользователей, а вызов метода <codeph>allowInsecureDomain</codeph> ослабляет один из этих факторов.</p>
     
     <p platform="actionscript"><i>Примечание.</i> При вызове этого метода из кода в изолированной среде безопасности приложения AIR порождается исключение SecurityError. Содержимое за пределами домена защиты приложения не может выполнять перекрестные сценарии для находящегося в ней содержимого. Однако содержимое, находящееся за пределами изолированной программной среды приложения, может обращаться к содержимому в этой среде с помощью так называемого моста.</p>
     
     <p platform="actionscript">Этот метод работает так же, как и <codeph>Security.allowDomain()</codeph>, но, помимо этого, он позволяет выполнять операции, в которых вызываемая сторона загружается через протокол HTTPS, а вызывающая – нет. В Flash Player 7 и более поздних версиях файлам, загружаемым не через HTTPS, не разрешается выполнение перекрестных сценариев с файлами, загружаемым через HTTPS. Метод <codeph>allowInsecureDomain()</codeph> снимает это ограничение, когда его использует вызываемый SWF-файл с HTTPS.</p>
     
     <p platform="actionscript">Используйте <codeph>allowInsecureDomain()</codeph> только для разрешения выполнения сценариев файлов без HTTPS для файлов с HTTPS. Используйте этот метод для разрешения сценариев, когда вызывающий файл без HTTPS и вызываемый файл с HTTPS находятся на одном домене, например, если SWF-файл с адресом http://mysite.com хочет выполнить сценарий для SWF-файла с адресом https://mysite.com. Не используйте этот метод для разрешения сценариев между файлами без HTTPS, между файлами с HTTPS, а также для выполнения сценариев файла с HTTPS для файла без HTTPS. В таких ситуациях следует использовать метод <codeph>allowDomain()</codeph>.</p>
     
     Следующий пример иллюстрирует, как метод <codeph>allowInsecureDomain()</codeph> может подвергнуть опасности защиту, если он используется без тщательного изучения.
     
     <p platform="actionscript">Обратите внимание, что следующая информация является одним из возможных сценариев и предназначена для облегчения понимания метода <codeph>allowInsecureDomain()</codeph> с помощью наглядного примера перекрестного выполнения сценариев. Она не охватывает все вопросы, связанные с архитектурой безопасности, ее необходимо использовать только для справки. В центре разработки Flash Player содержится обширная информация о приложении Flash Player и безопасности. Для получения дополнительной информации см. раздел центра разработки Flash Player <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref>.</p>
     
     <p platform="actionscript">Предположим, выполняется построение web-сайта электронной коммерции, состоящего из двух компонентов: каталога, защита которого не требуется, поскольку в нем содержится только общедоступная информация; и компонента корзины для покупок или оформления, который должен быть защищенным для обеспечения безопасности финансовой и личной пользовательской информации. Предположим, рассматривается возможность обслуживания каталога с узла http://mysite.com/catalog.swf, а корзины – с узла https://mysite.com/cart.swf. Единственным требованием для web-сайта является обеспечение защиты, чтобы третья сторона не могла украсть номера пользовательских кредитных карт, воспользовавшись уязвимыми местами в архитектуре защиты.</p>
     
     <p platform="actionscript">Предположим, злоумышленник вторгается в канал связи между серверами и пользователями, пытаясь украсть номера кредитных карт, которые пользователи указывают в приложении корзины для покупок. Злоумышленником может являться, например, недобросовестный пользователь, применяющий пакет программ, или нечестный администратор на пользовательском рабочем месте – любой человек, получающий возможность просматривать или изменять сетевые пакеты, переданные через Интернет по каналу между пользователем и сервером. Такая ситуация не является редкой.</p> 
     
     <p platform="actionscript">Если в файле cart.swf для передачи сведений о кредитной карте на сервер используется протокол HTTPS, злоумышленник не может украсть эту информацию непосредственно из сетевых пакетов, поскольку передача HTTPS является зашифрованной. Однако злоумышленник может воспользоваться другим способом: изменить содержимое одного из SWF-файлов, например, который предоставляется пользователю, заменив существующий SWF-файл измененной версией, в которой выполняется передача пользовательской информации на другой сервер, владельцем которого является злоумышленник.</p>
     
     <p platform="actionscript">Протокол HTTPS, помимо прочего, позволяет предотвратить подобное изменение, поскольку, кроме шифрования, передачи HTTPS защищены от несанкционированного доступа. Если злоумышленник изменяет пакет, получающая сторона обнаруживает изменение и отказывается от принятия пакета. Поэтому в данной ситуации злоумышленник не может изменить файл cart.swf, так как он доставляется по протоколу HTTPS.</p>
     
     <p platform="actionscript">Однако предположим, что необходимо разрешить кнопки в файле catalog.swf, обслуживаемом по протоколу HTTP, для добавления элементов в корзину для покупок в файле cart.swf, обслуживаемом по протоколу HTTPS. Для этого в файле cart.swf вызывается метод <codeph>allowInsecureDomain()</codeph>, который позволяет файлу catalog.swf выполнять сценарий в файле cart.swf. Результат этого действия может быть непредвиденным: теперь злоумышленник может изменить файл catalog.swf при его первоначальной загрузке пользователем, поскольку файл catalog.swf передается по протоколу HTTP и не защищен от атак. Теперь злоумышленник, изменивший файл catalog.swf, может выполнять сценарий в файле script cart.swf, поскольку в файле cart.swf содержится вызов метода <codeph>allowInsecureDomain()</codeph>. В измененном файле catalog.swf можно использовать код ActionScript для доступа к переменным в файле cart.swf, что позволяет считывать пользовательскую информацию о кредитных картах и другие конфиденциальные данные. Затем измененный файл catalog.swf может передавать эти данные на сервер злоумышленника.</p>
     
     <p platform="actionscript">Очевидно, что такая реализация является нежелательной, но пользователю по-прежнему необходимо разрешить перекрестное выполнение сценариев в двух SWF-файлах на web-сайте. Существует два способа доработки этого гипотетического сайта электронной коммерции без использования метода <codeph>allowInsecureDomain()</codeph>:</p>
     
     <ul platform="actionscript">
       <li>Обслуживание всех SWF-файлов необходимо выполнять в приложении по протоколу HTTPS. Это явно наиболее простое и надежное решение. В описанном сценарии оба файла – catalog.swf и cart.swf – необходимо обслуживать по протоколу HTTPS. Слегка может увеличиться использование полосы пропускания и нагрузка на ЦП сервера при переключении в файле, например catalog.swf, протокола HTTP на протокол HTTPS, а на компьютерах пользователей может слегка увеличиться время загрузки приложений. Необходимо провести испытания на реальных серверах, чтобы определить степень важности этих эффектов; обычно увеличения происходят не более чем на 10-20%, а иногда они вовсе отсутствуют. Повысить эффективность можно с использованием на сервере оборудования или программ для ускорения при передаче по протоколу HTTPS. Основным преимуществом обслуживания всех взаимосвязанных SWF-файлов по протоколу HTTPS является то, что можно использовать указатель URL HTTPS в качестве основного URL-адреса в браузере без получения предупреждений о смешанном содержимом в браузере. Кроме того, в браузере становится видимым значок висячего замка, предоставляющего пользователям общие и доверенные индикаторы защиты.</li>
     
      <li>Используйте выполнение сценариев из HTTPS в HTTP вместо из HTTP в HTTPS. В описанном сценарии содержимое пользовательской корзины для покупок можно сохранить в файле catalog.swf, а в файле cart.swf только управлять процессом расчета. Во время расчета файл cart.swf может получать содержимое корзины из переменных ActionScript в файле catalog.swf. Ограничением выполнения сценариев из HTTP в HTTPS является асимметричность; несмотря на то, что в файле catalog.swf, доставленном по протоколу HTTP, нельзя безопасно разрешить выполнение сценария в файле cart.swf, доставленном по протоколу HTTPS, файл cart.swf HTTPS может выполнять сценарии в файле catalog.swf HTTP. Этот подход является не настолько простым, как подход, при котором все файлы передаются по протоколу HTTPS; необходимо проявлять осторожность и не доверять всем SWF-файлам, полученным по протоколу HTTP, поскольку они подвержены несанкционированному доступу. Например, когда файл cart.swf получает переменную ActionScript, в которой описано содержимое корзины, код ActionScript в файле cart.swf не может доверять данному значению переменной, даже если она получена в ожидаемом формате. Необходимо убедиться, что в содержимом корзины отсутствуют недопустимые данные, которые приведут к тому, что в файле cart.swf будет предпринято нежелательное действие. Необходимо также учитывать риск, что злоумышленник, изменив файл catalog.swf, может предоставить действительные, но неточные данные в файле cart.swf (например путем замены элементов в пользовательской корзине). Принятый процесс оформления покупок в некоторой степени позволяет устранить риск путем отображения содержимого тележки и общей стоимости покупок для окончательного одобрения пользователем, но риск все равно существует.</li>
     </ul>
     
     <p platform="actionscript">В web-браузерах на протяжении многих лет вводится вынужденное разделение файлов HTTPS и отличных от HTTPS, и в приведенных сценариях описана одна из веских причин для такого ограничения. В приложении Flash Player доступна возможность устранения этого ограничения безопасности, но перед выполнением этого действия необходимо иметь полное понимание последствий.</p>
     
     <p platform="actionscript">Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul platform="actionscript">
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>allowDomain()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:Security:loadPolicyFile"><apiName>loadPolicyFile</apiName><shortdesc>  
     Поиск файла политик в каталоге, заданном параметром url.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>URL-адрес загружаемого файла политики.
     </apiDesc></apiParam><apiTipTexts><apiTipText>Поиск файла политик в каталоге, заданном параметром url.
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>  
     Поиск файла политик в каталоге, заданном параметром <codeph>url</codeph>. Приложение Adobe AIR и проигрыватель Flash Player используют файлы политик, чтобы определить, можно ли разрешать приложениям загружать данные с других серверов, кроме того, на котором они находятся. Обратите внимание, что несмотря на то, что метод называется <codeph> loadPolicyFile()</codeph>, фактическая загрузка файла обычно не выполняется до получения сетевого запроса, который должен быть передан файлом политик.
     
	 <p>С помощью метода <codeph>Security.loadPolicyFile()</codeph> проигрыватель Flash Player или приложение AIR может загружать файлы политик из произвольно выбранных местоположений, как это показано в следующем примере.</p>
     
     <codeblock platform="actionscript">
     Security.loadPolicyFile("http://www.example.com/sub/dir/pf.xml");
     </codeblock>
     
     <codeblock platform="javascript">
     air.Security.loadPolicyFile("http://www.example.com/sub/dir/pf.xml");
     </codeblock>
     
     <p>При этом проигрывателю Flash Player или приложению AIR предписывается извлечь файл политики по указанному URL-адресу. Любые разрешения, выдаваемые файлом политики, расположенном в определенном каталоге, будут действовать применительно ко всему содержимому, находящемуся на том же уровне или ниже в виртуальной иерархии каталогов данного сервера. </p>
     
     <p platform="actionscript">Например, в предыдущем коде не выдают исключение следующие строки:</p>
     
     <codeblock platform="actionscript"> import flash.net.~~;
     var request:URLRequest = new URLRequest("http://www.example.com/sub/dir/vars.txt");
     var loader:URLLoader = new URLLoader();
     loader.load(request);
     
     var loader2:URLLoader = new URLLoader();
     var request2:URLRequest = new URLRequest("http://www.example.com/sub/dir/deep/vars2.txt");
     loader2.load(request2);
     </codeblock>
     
     <p platform="actionscript">Однако следующий код выдает исключение по безопасности:</p>
     
     <codeblock platform="actionscript"> import flash.net.~~;
     var request3:URLRequest = new URLRequest("http://www.example.com/elsewhere/vars3.txt");
     var loader3:URLLoader = new URLLoader();
     loader3.load(request3);
     </codeblock>
     
     <p>Используя метод <codeph>loadPolicyFile()</codeph>, можно загрузить любое число файлов политик. Обрабатывая запрос, требующий использования файла политики, Flash Player или AIR всегда ждет завершения загрузок всех файлов политик, прежде чем отклонить этот запрос. В качестве последнего действия, если авторизующий запрос файл политики не указан с помощью метода <codeph>loadPolicyFile()</codeph>, проигрыватель Flash Player или приложение AIR обращается в исходные местоположения по умолчанию.</p>
     
     <p>Проверяя основной файл политики, проигрыватель Flash Player ожидает ответа сервера в течение трех секунд. Если ответ не получен, Flash Player делает вывод, что основной файл политики не существует. Однако для вызова метода <codeph>loadPolicyFile()</codeph> нет тайм-аута по умолчанию; проигрыватель Flash Player предполагает, что вызываемый файл существует и ожидает загрузки в течение неопределенного времени. Поэтому для гарантированной загрузки основного файла политики необходимо вызвать метод <codeph>loadPolicyFile()</codeph>.</p>
     
      <p>Нельзя загружать файлы политик, обслуживаемые через общепринятые зарезервированные порты. Полный список заблокированных портов см. в разделе «Ограничение API-интерфейсов сетевого подключения» в главе <ph product="flex"> <xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">«Безопасность»</xref> </ph> <ph product="flash"> <xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">«Безопасность»</xref> </ph> книги <i>Программирование на ActionScript 3.0</i>.</p>
     
     <p>Использование протокола <codeph>xmlsocket</codeph> вместе с определенным номером порта позволяет извлекать файл политики непосредственно с сервера XMLSocket, как показано в следующем примере. Описанное выше ограничение не распространяется на подключения через сокеты.</p>
     
     <codeblock platform="actionscript">
     Security.loadPolicyFile("xmlsocket://foo.com:414");
     </codeblock>
     
     <codeblock platform="javascript">
     air.Security.loadPolicyFile("xmlsocket://foo.com:414");
     </codeblock>
     
     <p>Это вызывает попытку проигрывателя Flash Player или приложения AIR получить файл политики из указанного хоста и порта. После того как соединение с указанным портом установлено, проигрыватель Flash Player или приложение AIR передает <codeph>&lt;policy-file-request /></codeph>, прерываемый байтом со значением <codeph>null</codeph>. Сервер должен отправить байт null, чтобы прервать передачу файла политики, а после этого может закрыть соединение; если сервер не закроет соединение, это сделает проигрыватель Flash Player или приложение AIR после получения прерывающего байта <codeph>null</codeph>.</p>
     
     <p platform="actionscript">Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое.</p>
     
     <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul>
     
     <li product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
       <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:Security:showSettings"><apiName>showSettings</apiName><shortdesc>
     Отображает панель параметров безопасности в проигрывателе Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.showSettings(), showSettings()
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>panel</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>default</apiData><apiDesc>Значение из класса SecurityPanel, указывающее, какую панель параметров конфиденциальности требуется отображать. Если этот параметр пропущен, используется <codeph>SecurityPanel.DEFAULT</codeph>. 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Отображает панель параметров безопасности в проигрывателе Flash Player. Этот метод не применяется к содержимому в Adobe AIR; его вызов в приложении AIR игнорируется.
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#SecurityPanel"><linktext>SecurityPanel</linktext></link></related-links></apiOperation><apiValue id="flash.system:Security:APPLICATION"><apiName>APPLICATION</apiName><shortdesc>
	 Файл работает в приложении AIR и был установлен с пакетом (файлом AIR) для этого приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>application</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Файл работает в приложении AIR и был установлен с пакетом (файлом AIR) для этого приложения. Это содержимое включено в каталог ресурсов приложения AIR (в котором установлено содержимое приложения).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:LOCAL_TRUSTED"><apiName>LOCAL_TRUSTED</apiName><shortdesc>
     Файл является локальным файлом, который указан в качестве доверенного с помощью диспетчера настроек проигрывателя Flash Player или файла конфигурации FlashPlayerTrust.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localTrusted</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Файл является локальным файлом, который указан в качестве доверенного с помощью диспетчера настроек проигрывателя Flash Player или файла конфигурации FlashPlayerTrust. Файл может считывать информацию из локальных источников данных и обмениваться данными через Интернет.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:LOCAL_WITH_FILE"><apiName>LOCAL_WITH_FILE</apiName><shortdesc>
     Файл является локальным файлом, не является доверенным для пользователя и не публиковался с сетевым наименованием.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localWithFile</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Файл является локальным файлом, не является доверенным для пользователя и не публиковался с сетевым наименованием. В Adobe AIR локальный файл <i>не</i> находится в каталоге ресурсов приложения. Такие файлы помещаются в изолированную программную среду безопасности приложения. Файл может считывать информацию из локальных источников данных, но не может обмениваться данными через Интернет.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:LOCAL_WITH_NETWORK"><apiName>LOCAL_WITH_NETWORK</apiName><shortdesc>
	 Файл является локальным SWF-файлом, не является доверенным для пользователя и публиковался с сетевым наименованием.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localWithNetwork</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Файл является локальным SWF-файлом, не является доверенным для пользователя и публиковался с сетевым наименованием. Файл может обмениваться данными через Интернет, но не может считывать информацию из локальных источников данных.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:REMOTE"><apiName>REMOTE</apiName><shortdesc>
     Файл взят с URL-адреса в Интернете и работает в соответствии с правилами изолированной программной среды на основе домена.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><refpath>
     </refpath></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>remote</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Файл взят с URL-адреса в Интернете и работает в соответствии с правилами изолированной программной среды на основе домена.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/sandboxType"><linktext>sandboxType</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue><apiValue id="flash.system:Security:exactSettings:get"><apiName>exactSettings</apiName><shortdesc>
     Определяет, каким образом проигрыватель Flash Player или приложение AIR выбирает домен для работы с такими параметрами Flash Player, как разрешения на доступ к камере и микрофону, квоты хранилища, а также параметры хранения постоянных общих объектов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.exactSettings, exactSettings
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Проигрыватель Flash Player или приложение AIR уже использовало значение <codeph>exactSettings</codeph>, по крайней мере однажды, когда принималось решение о параметрах проигрывателя.
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Определяет, каким образом проигрыватель Flash Player или приложение AIR выбирает домен для работы с такими параметрами Flash Player, как разрешения на доступ к камере и микрофону, квоты хранилища, а также параметры хранения постоянных общих объектов. Чтобы в SWF-файле использовались настройки, аналогичные тем, которые использовались в приложении Flash Player 6, задайте для <codeph>exactSettings</codeph> значение <codeph>false</codeph>.
     
     <p platform="javascript">Это свойство не используется в содержимом SWF и коде JavaScript в приложениях AIR.</p>
     
     <p platform="actionscript">В Flash Player 6 домен, используемый для этих параметров проигрывателя, выбирался исходя из конечной порции домена SWF-файла. Если домен SWF-файла включает больше двух сегментов, например www.example.com, первый сегмент домена (www) удаляется, и используется оставшаяся часть домена: example.com. Так, в Flash Player 6 и www.example.com и store.example.com используют example.com в качестве домена для этих параметров. Подобным образом, и www.example.co.uk и store.example.co.uk используют example.co.uk в качестве домена для параметров. В Flash Player 7 и более поздних версиях параметры проигрывателя по умолчанию выбираются в соответствии с точным доменом SWF- файла. Например SWF-файл с www.example.com будет использовать параметры проигрывателя для www.example.com, а SWF-файл с store.example.com – отдельные параметры для store.example.com.</p>
     
     <p platform="actionscript">Когда <codeph>Security.exactSettings</codeph> имеет значение <codeph>true</codeph>, Flash Player использует точные домены для параметров проигрывателя. Если задать значение <codeph>false</codeph>, Flash Player использует параметры домена, как в Flash Player 6. По умолчанию <codeph>exactSettings</codeph> имеет значение <codeph>true</codeph>. Изменение значения по умолчанию свойства <codeph>exactSettings</codeph> необходимо выполнить до появления событий, требующих выбора параметров проигрывателя Flash Player, таких как использование камеры или микрофона или получение постоянного общего объекта.</p>
     
     <p platform="actionscript">Если ранее был опубликован SWF-файл версии 6, из которого были созданы постоянные общие объекты, и теперь эти объекты необходимо получить из этого SWF-файла после перехода к версии 7 или более поздней или из другого SWF-версии 7 или более поздней, необходимо задать для <codeph>Security.exactSettings</codeph> значение <codeph>false</codeph> перед вызовом метода <codeph>SharedObject.getLocal()</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Security:sandboxType:get"><apiName>sandboxType</apiName><shortdesc>
     Показывает тип изолированной программной среды безопасности, в которой работает вызывающий файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Показывает тип изолированной программной среды безопасности, в которой работает вызывающий файл.
     
     <p>Для <codeph>Security.sandboxType</codeph> можно устанавливать одно из следующих значений.</p>
     
     <ul>
     <li><codeph>remote</codeph> (<codeph>Security.REMOTE</codeph>): этот файл загружается с URL-адреса в Интернете и используется в соответствии с правилами изолированной программной среды на основе домена.</li>
     <li><codeph>localWithFile</codeph> (<codeph>Security.LOCAL_WITH_FILE</codeph>): этот файл является локальным файлом, не является доверенным для пользователя и не публиковался с сетевым наименованием. Файл может считывать информацию из локальных источников данных, но не может обмениваться данными через Интернет.</li>
     <li><codeph>localWithNetwork</codeph> (<codeph>Security.LOCAL_WITH_NETWORK</codeph>): этот SWF-файл является локальным файлом, не является доверенным для пользователя и публиковался с сетевым наименованием. SWF-файл может обмениваться данными через Интернет, но не может считывать информацию из локальных источников данных.</li>
     <li><codeph>localTrusted</codeph> (<codeph>Security.LOCAL_TRUSTED</codeph>): этот SWF-файл является локальным файлом, пользователь сделал его доверенным с помощью диспетчера настроек проигрывателя Flash Player или файла конфигурации FlashPlayerTrust. Файл может считывать информацию из локальных источников данных и обмениваться данными через Интернет.</li>
     <li><codeph>application</codeph> (<codeph>Security.APPLICATION</codeph>): файл работает в приложении AIR и был установлен с пакетом (файлом AIR) для этого приложения. По умолчанию файлы в изолированной программной среде безопасности приложения AIR могут выполнять перекрестные сценарии с любым файлом из любого домена (в то время как файлы за ее пределами могут не иметь разрешения на выполнение перекрестных сценариев с файлом AIR). По умолчанию файлы в изолированной программной среде безопасности приложения AIR могут загружать содержимое и данные из любого домена. </li>
     
     </ul>
     
     <p>Дополнительные сведения о безопасности см. в следующих ресурсах.</p>
     
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     <li product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
     
    <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
     
     </ul>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/REMOTE"><linktext>REMOTE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_FILE"><linktext>LOCAL_WITH_FILE</linktext></link><link href="flash.system.xml#Security/LOCAL_WITH_NETWORK"><linktext>LOCAL_WITH_NETWORK</linktext></link><link href="flash.system.xml#Security/LOCAL_TRUSTED"><linktext>LOCAL_TRUSTED</linktext></link><link href="flash.system.xml#Security/APPLICATION"><linktext>APPLICATION</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:LoaderContext"><apiName>LoaderContext</apiName><shortdesc>
 Класс LoaderContext передает параметры для загрузки SWF-файлов и другого мультимедийного содержимого с помощью класса Loader.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс LoaderContext передает параметры для загрузки SWF-файлов и другого мультимедийного содержимого с помощью класса Loader. Класс LoaderContext используется в качестве параметра <codeph>context</codeph> в методах <codeph>load()</codeph> и <codeph>loadBytes()</codeph> класса Loader.
 
 <p>Если SWF-файлы загружаются с помощью метода <codeph>Loader.load()</codeph>, необходимо принять два решения: в какой домен защиты должен быть помещен загружаемый SWF-файл, а также в какой домен приложения в этом домене защиты? Дополнительные сведения об этом см. в информации по свойствам <codeph>applicationDomain</codeph> и <codeph>securityDomain</codeph>.</p>
 
 <p>Если загружается SWF-файл с помощью метода <codeph>Loader.loadBytes()</codeph>, также необходимо выбрать домен приложения как и при использовании метода <codeph>Loader.load()</codeph>. Но нет необходимости указывать домен защиты, поскольку <codeph>Loader.loadBytes()</codeph> всегда помещает загруженный SWF-файл в предназначенный для него домен защиты.</p>
 
 <p>Если вместо SWF-файлов загружаются изображения (JPEG, GIF или PNG), то не требуется указывать ни домен защиты, ни домен безопасности, поскольку эти понятия имеют смысл только применительно к SWF-файлам. Необходимо принять всего одно решение: требуется ли программный доступ к растровому представлению загруженного изображения? Если да, см. свойство <codeph>checkPolicyFile</codeph>. Если при загрузке изображения необходимо применить подавление блочности, используйте класс JPEGLoaderContext вместо класса LoaderContext.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link><link href="flash.system.xml#LoaderContext/checkPolicyFile"><linktext>flash.system.LoaderContext.checkPolicyFile</linktext></link><link href="flash.system.xml#LoaderContext/securityDomain"><linktext>flash.system.LoaderContext.securityDomain</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links><apiConstructor id="flash.system:LoaderContext:LoaderContext"><apiName>LoaderContext</apiName><shortdesc>
     Создает новый объект LoaderContext с заданными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает необходимость проверки существования файла политики для URL-адреса перед загрузкой объекта.
     
     </apiDesc></apiParam><apiParam><apiItemName>applicationDomain</apiItemName><apiOperationClassifier>flash.system:ApplicationDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает, какой объект ApplicationDomain следует использовать для объекта Loader.
     
     </apiDesc></apiParam><apiParam><apiItemName>securityDomain</apiItemName><apiOperationClassifier>flash.system:SecurityDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает, какой объект SecurityDomain следует использовать для объекта Loader.
     
	 <p><i>Примечание.</i> Содержимое в изолированной среде безопасности приложения AIR не может загружать содержимое из других изолированных программных сред в свой SecurityDomain.</p>
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект LoaderContext с заданными параметрами. Подробные сведения об этих параметрах см. в описаниях свойств этого класса.
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links></apiConstructor><apiValue id="flash.system:LoaderContext:allowLoadBytesCodeExecution"><apiName>allowLoadBytesCodeExecution</apiName><shortdesc>
	 Указывает, можно ли использовать метод loadBytes() объекта Loader для загрузки содержимого с исполняемым кодом, например SWF-файла.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, можно ли использовать метод <codeph>loadBytes()</codeph> объекта Loader для загрузки содержимого с исполняемым кодом, например SWF-файла. Если это свойство имеет значение <codeph>false</codeph> (по умолчанию), метод <codeph>loadBytes()</codeph> ограничен безопасными операциями, такими как загрузка изображений.
 	 
	 <p>Для содержимого в изолированной программной среде приложения AIR значением по умолчанию является <codeph>false</codeph>. Для содержимого вне изолированной программной среды приложения значением по умолчанию является <codeph>true</codeph>.</p>
	 
	 <p><b>Примечание.</b> Данный API-интерфейс, вероятно, будет заменен в будущем выпуске AIR. В этом случае потребуется изменить код в соответствии с новым API-интерфейсом и выполнить повторную компиляцию перед распространением приложения для новой версии AIR.</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link></related-links></apiValue><apiValue id="flash.system:LoaderContext:applicationDomain"><apiName>applicationDomain</apiName><shortdesc>
	 Указывает домен приложения для использования в методе Loader.load() или Loader.loadBytes().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>null</apiData><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает домен приложения для использования в методе <codeph>Loader.load()</codeph> или <codeph>Loader.loadBytes()</codeph>. Используйте это свойство только при загрузке SWF-файлов, записанных на ActionScript 3.0 (но не изображений и не SWF-файлов, записанных на ActionScript 1.0 или ActionScript 2.0).
	 
	 <p>Каждый домен защиты содержит один или несколько доменов приложений, представленных объектами ApplicationDomain. Домены приложений создаются не в целях защиты; они предназначены для совместного использования объектов программного кода ActionScript. Если загрузка SWF-файла выполняется из другого домена, и его разрешено размещать в отдельном домене защиты, то управлять выбором домена приложений для размещения загружаемого SWF-файла нельзя; и даже если указать какой-либо домен приложений, это будет игнорироваться. Однако, если выполняется загрузка SWF-файла в собственный домен защиты (либо потому, что SWF-файл получен из собственного домена, либо потому, что в него выполняется импорт), то можно управлять выбором домена приложений для загружаемого SWF-файла.</p>
	 
	 <p>В <codeph>LoaderContext.applicationDomain</codeph> можно указывать домен приложения только из собственного домена защиты. Попытка указать домен приложения из какого-либо другого домена защиты приводит к исключению <codeph>SecurityError</codeph>.</p>
	 
	 <p>Существует четыре возможных варианта для выбора свойства <codeph>ApplicationDomain</codeph>.</p>
	 
	 <ul>
	 <li><b>Нижестоящий домен по отношению к ApplicationDomain объекта Loader. </b> По умолчанию. Можно явным образом сделать этот выбор, используя синтаксис <codeph>new ApplicationDomain(ApplicationDomain.currentDomain)</codeph>. Это позволяет загружаемому SWF-файлу напрямую использовать классы вышестоящего домена, например, используя синтаксис <codeph>new MyClassDefinedInParent()</codeph>. Родительский домен, однако, не может использовать этот синтаксис; если ему требуется использовать классы нижестоящего домена, необходимо вызывать <codeph>ApplicationDomain.getDefinition()</codeph> для их извлечения. Преимущество такого выбора состоит в том, что если в нижестоящем домене определяется класс с тем же именем, что у класса, уже определенного в вышестоящем домене, то ошибок не происходит; нижестоящий домен просто наследует определение такого класса из вышестоящего домена, а конфликтное определение нижестоящего домена не используется до тех пор, пока либо нижестоящий, либо вышестоящий домен не вызовет метод <codeph>ApplicationDomain.getDefinition()</codeph> для его извлечения.</li>
	 
	 <li><b>ApplicationDomain принадлежит объекту Loader. </b> Этот домен приложения используется при выполнении <codeph>ApplicationDomain.currentDomain</codeph>. Когда загрузка завершена, вышестоящий и нижестоящий домены могут использовать классы друг друга напрямую. Если выполняется попытка определить в нижестоящем объекте класс с тем же именем, что и класс, уже определенный в вышестоящем домене, то используется класс вышестоящего домена, а класс нижестоящего домена игнорируется.</li>
	 
	 <li><b>Нижестоящий домен системного ApplicationDomain. </b> Этот домен приложения используется при выполнении <codeph>new ApplicationDomain(null)</codeph>. Это полностью разделяет загружающий и загружаемый домены, позволяя им определять отдельные версии классов с одинаковым именем без конфликтов и пересечений. Единственным способом, которым каждая из сторон может видеть классы другой стороны, является вызов метода <codeph>ApplicationDomain.getDefinition()</codeph>.</li>
	 
	 <li><b>Нижестоящий домен какого-то другого ApplicationDomain. </b> Иногда могут возникать более сложные иерархии доменов приложений. Можно загружать SWF-файл в любой домен приложения своего собственного домена защиты. Например, при выполнении <codeph>new ApplicationDomain(ApplicationDomain.currentDomain.parentDomain.parentDomain)</codeph> SWF-файл загружается в новый нижестоящий домен по отношению к вышестоящему домену вышестоящего домена текущего домена.</li>
	 </ul>
	 
	 <p>Когда загрузка завершается, каждой из сторон (загружающей и загружаемой) может потребоваться выполнить поиск собственного ApplicationDomain или ApplicationDomain другой стороны, чтобы вызвать <codeph>ApplicationDomain.getDefinition()</codeph>. Каждая из сторон может извлечь ссылку на собственный домен приложения, используя <codeph>ApplicationDomain.currentDomain</codeph>. Загружающий SWF-файл может извлекать ссылку на домен приложения загружаемого SWF-файла с помощью <codeph>Loader.contentLoaderInfo.applicationDomain</codeph>. Если для загруженного SWF-файла известен способ его загрузки, можно определить путь к объекту ApplicationDomain загружающего SWF-файла. Например, если нижестоящий объект был загружен принятым по умолчанию способом, он может найти домен приложения, загружающего SWF-файла, используя <codeph>ApplicationDomain.currentDomain.parentDomain</codeph>.</p>
	 
	 <p>Дополнительные сведения см. в разделе «Класс ApplicationDomain» главы «Системная среда клиента» в руководстве <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.system:LoaderContext:checkPolicyFile"><apiName>checkPolicyFile</apiName><shortdesc>
	 Указывает, должно ли приложение пытаться загрузить файл политики для URL-адреса с сервера загружаемого объекта перед началом загрузки самого объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>false</apiData><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, должно ли приложение пытаться загрузить файл политики для URL-адреса с сервера загружаемого объекта перед началом загрузки самого объекта. Этот флаг применим к методу <codeph>Loader.load()</codeph>, но не работает для метода<codeph>Loader.loadBytes()</codeph>.
	 
	 <p>Установите для этого флага значение <codeph>true</codeph>, если изображение (JPEG, GIF или PNG) загружается извне домена вызывающего SWF-файла и предполагается доступ к содержимому этого изображения из ActionScript. В число примеров обращения к содержимому изображений входят обращение к свойству <codeph>Loader.content</codeph> для получения объекта Bitmap, а также вызов метода <codeph>BitmapData.draw()</codeph> для получения копии растрового представления загруженного изображения. Если попытаться выполнить одну из этих операций, не указав <codeph>checkPolicyFile</codeph> во время загрузки, можно получить исключение <codeph>SecurityError</codeph>, поскольку необходимый файл политики еще не был загружен.</p>
	 
	 <p>При вызове метода <codeph>Loader.load()</codeph> с установленным для <codeph>LoaderContext.checkPolicyFile</codeph> значением <codeph>true</codeph>, приложение не начнет загрузку указанного в <codeph>URLRequest.url</codeph> объекта до тех пор, пока успешно не загрузит соответствующий файл политики для URL-адреса или не обнаружит отсутствие такого файла. Приложение Flash Player или AIR в первую очередь учитывает файлы политик, которые уже загружены, затем пытается загрузить ожидающие файлы политик, указанные в вызовах метода <codeph>Security.loadPolicyFile()</codeph>, затем пытается загрузить файл политики из местоположения по умолчанию, соответствующему <codeph>URLRequest.url</codeph> (это файл <codeph>/crossdomain.xml</codeph> на том же сервере, что и <codeph>URLRequest.url</codeph>). Во всех случаях требуется, чтобы по адресу <codeph>URLRequest.url</codeph> существовал соответствующий файл политики на основе места размещения файла политики, а также, чтобы он обеспечивал доступ посредством одного или нескольких тегов <codeph>&lt;allow-access-from></codeph>.</p>
	 
	 <p>Если для свойства <codeph>checkPolicyFile</codeph> задать значение <codeph>true</codeph>, основная загрузка, указанная в методе <codeph>Loader.load()</codeph>, не будет выполнена до полного завершения обработки файла политики. Поэтому, пока необходимый файл политики существует, как только будет получено любое из событий <codeph>ProgressEvent.PROGRESS</codeph> или <codeph>Event.COMPLETE</codeph> для свойства <codeph>contentLoaderInfo</codeph> объекта Loader, загрузка файла политики завершается и можно безопасно начинать выполнение операций, требующих этот файл политики.</p>
	 
	 <p>Если для <codeph>checkPolicyFile</codeph> установлено значение <codeph>true</codeph>, а соответствующий файл политики не найден, сообщение об ошибке не будет отправляться до тех пор, пока не будет предпринята попытка выполнить операцию, создающую исключение <codeph>SecurityError</codeph>. Однако как только объект LoaderInfo передаст событие <codeph>ProgressEvent.PROGRESS</codeph> или <codeph>Event.COMPLETE</codeph>, можно убедиться, найден ли соответствующий файл политики, проверив значение свойства <codeph>LoaderInfo.childAllowsParent</codeph>.</p>
	 
	 <p>Если необходим доступ к загружаемому изображению на уровне растрового представления, не следует устанавливать для свойства <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>. Проверка файла политики в этом случае бесполезна, поскольку это может задержать запуск загрузки, а также нерационально израсходовать дополнительные ресурсы полосы пропускания.</p>
	 
	 <p>Также постарайтесь избегать установки для <codeph>checkPolicyFile</codeph> значения <codeph>true</codeph>, если для загрузки SWF-файла используется метод <codeph>Loader.load()</codeph>. Причина этого в том, что разрешения на взаимные обращения между SWF-файлами не контролируются файлами политик, а только с помощью метода <codeph>Security.allowDomain()</codeph>, поэтому вызов <codeph>checkPolicyFile</codeph> никак не влияет на загрузку SWF-файла. Проверка файла политики в этом случае бесполезна, поскольку это может задержать загрузку SWF-файла, а также нерационально израсходовать дополнительные ресурсы полосы пропускания. (Приложение Flash Player или AIR не может определить, будет ли основная загрузка выполняться для SWF-файла или изображения, поскольку загрузка файла политики произошла перед основной загрузкой.)</p>
	 
	 <p>Будьте осторожны с <codeph>checkPolicyFile</codeph>, если выполняется загрузка объекта из URL-адреса, который может использовать HTTP-перенаправления на стороне сервера. Файлы политик всегда извлекаются по исходному URL-адресу, указанному в <codeph>URLRequest.url</codeph>. Если окончательный объект передается с другого URL-адреса из-за HTTP-перенаправлений, то изначально загруженные файлы политик могут быть не применимы к окончательному URL-адресу объекта, который и следует учитывать при принятии мер безопасности. В случае возникновения подобной ситуации можно проверить значение <codeph>LoaderInfo.url</codeph> после получения события <codeph>ProgressEvent.PROGRESS</codeph> или <codeph>Event.COMPLETE</codeph>, в котором сообщается окончательный URL-адрес объекта. Затем вызовите метод <codeph>Security.loadPolicyFile()</codeph> с файлом политики на основе URL-адресов, где учитывается окончательный URL-адрес объекта. Затем опрашивайте значение <codeph>LoaderInfo.childAllowsParent</codeph> до тех пор, пока оно не изменится на<codeph>true</codeph>.</p>
	 
     	 <p>Нет необходимости задавать это свойство для содержимого AIR, выполняющегося в изолированной программной среде приложения. Содержимое в изолированной программной среде приложения AIR может вызывать метод <codeph>BitmapData.draw()</codeph>, используя в качестве источника любое загруженное содержимое изображения. </p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo/childAllowsParent"><linktext>flash.display.LoaderInfo.childAllowsParent</linktext></link><link href="flash.display.xml#LoaderInfo/url"><linktext>flash.display.LoaderInfo.url</linktext></link><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.system.xml#Security/loadPolicyFile()"><linktext>flash.system.Security.loadPolicyFile()</linktext></link></related-links></apiValue><apiValue id="flash.system:LoaderContext:securityDomain"><apiName>securityDomain</apiName><shortdesc>
	 Указывает домен защиты для использования в операции Loader.load().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>null</apiData><apiValueClassifier>flash.system:SecurityDomain</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает домен защиты для использования в операции <codeph>Loader.load()</codeph>. Используйте это свойство только при загрузке SWF-файлов (но не изображений).
	 
 	 <p>Выбор домена безопасности имеет смысл только в том случае, если загружается SWF-файл, который мог быть получен из другого домена (другой сервер), отличающегося от загружающего SWF-файла. Если SWF-файл загружается из собственного домена, он всегда помещается в собственный домен защиты. Но если SWF-файл загружается из другого домена, есть два варианта действий. Можно разрешить загружаемому SWF-файлу быть помещенным в «обычный» домен защиты, который отличается от домена защиты загружающего SWF-файла; это вариант по умолчанию. Другим вариантом является указание того, что загружаемый SWF-файл требуется поместить в тот же домен защиты, что и загружающий SWF-файл, установив для <codeph>myLoaderContext.securityDomain</codeph> значение равное <codeph>SecurityDomain.currentDomain</codeph>. Это называется <i>загрузка импортом</i>, что с точки зрения обеспечения безопасности, эквивалентно копированию загружаемого SWF-файла на собственный сервер и загрузки его оттуда. Чтобы загрузка импортом завершилась успешно, загруженный SWF-файл должен иметь файл политики, определяющий в качестве доверенного домен загружающего SWF-файла.</p>
	 
	 <p>Указывать собственный домен защиты можно только в <codeph>LoaderContext.securityDomain</codeph>. Попытка указать какой-либо другой домен защиты приводит к исключению <codeph>SecurityError</codeph>.</p>
	 
	 <p>Содержимое в изолированной среде безопасности приложения AIR не может загружать содержимое из других изолированных программных сред в свой SecurityDomain.</p>
     
	 <p>Дополнительные сведения см. в главе «Безопасность» в руководстве <i>Программирование на ActionScript 3.0</i>.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:IMEConversionMode"><apiName>IMEConversionMode</apiName><shortdesc>
 Этот класс содержит постоянные для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс содержит постоянные для использования со свойством <codeph>IME.conversionMode</codeph>. Установка для свойства <codeph>conversionMode</codeph> значений <codeph>ALPHANUMERIC_FULL</codeph> или <codeph>JAPANESE_KATAKANA_FULL</codeph> заставляет проигрыватель использовать шрифт полной ширины, а значений <codeph>ALPHANUMERIC_HALF</codeph> или <codeph>JAPANESE_KATAKANA_HALF</codeph> – шрифт половинной ширины.
 </apiDesc></apiClassifierDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links><apiValue id="flash.system:IMEConversionMode:ALPHANUMERIC_FULL"><apiName>ALPHANUMERIC_FULL</apiName><shortdesc>
	 Строка ALPHANUMERIC_FULL для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ALPHANUMERIC_FULL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>ALPHANUMERIC_FULL</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется со всеми редакторами IME. Используйте синтаксис <codeph>IMEConversionMode.ALPHANUMERIC_FULL</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:ALPHANUMERIC_HALF"><apiName>ALPHANUMERIC_HALF</apiName><shortdesc>
	 Строка ALPHANUMERIC_HALF для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>ALPHANUMERIC_HALF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>ALPHANUMERIC_HALF</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется со всеми редакторами IME. Используйте синтаксис <codeph>IMEConversionMode.ALPHANUMERIC_HALF</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:CHINESE"><apiName>CHINESE</apiName><shortdesc>
	 Строка CHINESE для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>CHINESE</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>CHINESE</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется с редакторами IME для упрощенного и традиционного китайского языков. Используйте синтаксис <codeph>IMEConversionMode.CHINESE</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:JAPANESE_HIRAGANA"><apiName>JAPANESE_HIRAGANA</apiName><shortdesc>
	 Строка JAPANESE_HIRAGANA для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>JAPANESE_HIRAGANA</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>JAPANESE_HIRAGANA</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется со всеми редакторами IME для японского языка. Используйте синтаксис <codeph>IMEConversionMode.JAPANESE_HIRAGANA</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:JAPANESE_KATAKANA_FULL"><apiName>JAPANESE_KATAKANA_FULL</apiName><shortdesc>
	 Строка JAPANESE_KATAKANA_FULL для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>JAPANESE_KATAKANA_FULL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>JAPANESE_KATAKANA_FULL</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется со всеми редакторами IME для японского языка. Используйте синтаксис <codeph>IMEConversionMode.JAPANESE_KATAKANA_FULL</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:JAPANESE_KATAKANA_HALF"><apiName>JAPANESE_KATAKANA_HALF</apiName><shortdesc>
	 СтрокаJAPANESE_KATAKANA_HALF для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>JAPANESE_KATAKANA_HALF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка<codeph>JAPANESE_KATAKANA_HALF</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется со всеми редакторами IME для японского языка. Используйте синтаксис <codeph>IMEConversionMode.JAPANESE_KATAKANA_HALF</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:KOREAN"><apiName>KOREAN</apiName><shortdesc>
	 Строка KOREAN для использования со свойством IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>KOREAN</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>KOREAN</codeph> для использования со свойством <codeph>IME.conversionMode</codeph>. Эта константа используется со всеми редакторами IME для корейского языка. Используйте синтаксис <codeph>IMEConversionMode.KOREAN</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:IMEConversionMode:UNKNOWN"><apiName>UNKNOWN</apiName><shortdesc>
	 Строка UNKNOWN, которая может возвращаться при вызове свойства IME.conversionMode.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>UNKNOWN</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Строка <codeph>UNKNOWN</codeph>, которая может возвращаться при вызове свойства <codeph>IME.conversionMode</codeph>. Это значение не может быть установлено и возвращается только в том случае, если проигрыватель не может идентифицировать текущий активный редактор IME. Используйте синтаксис <codeph>IMEConversionMode.UNKNOWN</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME/conversionMode"><linktext>flash.system.IME.conversionMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:SecurityPanel"><apiName>SecurityPanel</apiName><shortdesc>
 Класс SecurityPanel передает значения, задающие отображение одной из панелей параметров защиты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс SecurityPanel передает значения, задающие отображение одной из панелей параметров защиты.
 
 <p>Этот класс содержит статические переменные, используемые с методом <codeph>Security.showSettings()</codeph>. Нельзя создать новые экземпляры класса SecurityPanel.</p>
 
 </apiDesc><example conref="examples\SecurityExample.as"> В следующем примере показано, как событие <codeph>click</codeph> для объекта Sprite может использоваться для отображения панели параметров локального хранилища в окне параметров проигрывателя Flash Player. К рабочей области добавляется оранжевый прямоугольник с помощью метода<codeph>draw()</codeph>. В методе <codeph>draw()</codeph>, добавляется прослушиватель события <codeph>click</codeph> с именем <codeph>clickHandler()</codeph>, который драгирует на события <codeph>click</codeph>, вызывая открытие панели настроек локального хранилища в проигрывателе Flash Player.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.*;
    import flash.system.Security;
    import flash.system.SecurityPanel;

    public class SecurityExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 100;

        public function SecurityExample() {
            draw();
        }

        private function draw():void {
            var child:Sprite = new Sprite();
            child.graphics.beginFill(bgColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            child.buttonMode = true;

            var label:TextField = new TextField();
            label.text = "settings";
            label.selectable = false;
            label.mouseEnabled = false;
            child.addChild(label);

            child.addEventListener(MouseEvent.CLICK, clickHandler);
            addChild(child);
        }

        private function clickHandler(event:MouseEvent):void {
            Security.showSettings(SecurityPanel.LOCAL_STORAGE);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.system:SecurityPanel:CAMERA"><apiName>CAMERA</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает панель камеры в окне параметров проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.CAMERA, CAMERA
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>camera</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает панель камеры в окне параметров проигрывателя Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает панель, которая была открыта при последнем закрытии окна параметров проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.DEFAULT, DEFAULT
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает панель, которая была открыта при последнем закрытии окна параметров проигрывателя Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:DISPLAY"><apiName>DISPLAY</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает панель отображения в окне параметров проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.DISPLAY, DISPLAY
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>display</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает панель отображения в окне параметров проигрывателя Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:LOCAL_STORAGE"><apiName>LOCAL_STORAGE</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает панель параметров локального хранилища в окне параметров проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.LOCAL_STORAGE, LOCAL_STORAGE
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>localStorage</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает панель параметров локального хранилища в окне параметров проигрывателя Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:MICROPHONE"><apiName>MICROPHONE</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает панель микрофона в окне параметров проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.MICROPHONE, MICROPHONE
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>microphone</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает панель микрофона в окне параметров проигрывателя Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:PRIVACY"><apiName>PRIVACY</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает панель параметров конфиденциальности в окне параметров проигрывателя Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.PRIVACY, PRIVACY
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>privacy</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает панель параметров конфиденциальности в окне параметров проигрывателя Flash Player.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:SecurityPanel:SETTINGS_MANAGER"><apiName>SETTINGS_MANAGER</apiName><shortdesc>
	 При переходе к Security.showSettings() отображает диспетчер параметров (в отдельном окне браузера).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Security, Security.SETTINGS_MANAGER, SETTINGS_MANAGER
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>settingsManager</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 При переходе к <codeph>Security.showSettings()</codeph> отображает диспетчер параметров (в отдельном окне браузера).
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:JPEGLoaderContext"><apiName>JPEGLoaderContext</apiName><shortdesc>
 Класс JPEGLoaderContext содержит свойство для инициализации фильтра подавления блочности при загрузке изображения JPEG.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.system:LoaderContext</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс JPEGLoaderContext содержит свойство для инициализации фильтра подавления блочности при загрузке изображения JPEG. Фильтр подавления блочности повышает качество изображения при более высокой степени сжатия путем сглаживания соседних пикселей. Чтобы применить подавление блочности при загрузке изображения JPEG, создайте объект JPEGLoaderContext и задайте его свойство <codeph>deblockingFilter</codeph>. Затем укажите имя объекта JPEGLoaderContext в качестве значения параметра <codeph>context</codeph> метода <codeph>load()</codeph> объекта Loader, используемого для загрузки изображения.
 
 <p>Класс JPEGLoaderContext является расширением класса LoaderContext. Установите для свойства <codeph>checkPolicyFile</codeph> значение <codeph>true</codeph>, если требуется программный доступ к растровому представлению загруженного изображения (например, при использовании метода <codeph>BitmapData.draw()</codeph>). Для содержимого AIR, выполняющегося в изолированной программной среде приложения, задавать свойство <codeph>checkPolicyFile</codeph> не требуется.</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiConstructor id="flash.system:JPEGLoaderContext:JPEGLoaderContext"><apiName>JPEGLoaderContext</apiName><shortdesc>
     Создает новый объект JPEGLoaderContext с указанными параметрами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>deblockingFilter</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0.0</apiData><apiDesc>Задает интенсивность фильтра подавления блочности. Значение 1,0 задает полную интенсивность фильтра подавления блочности, а значение 0,0 отключает этот фильтр.
     
     </apiDesc></apiParam><apiParam><apiItemName>checkPolicyFile</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, должен ли проигрыватель Flash Player проверять существование файла политики для URL-адреса перед загрузкой объекта.
     
     </apiDesc></apiParam><apiParam><apiItemName>applicationDomain</apiItemName><apiOperationClassifier>flash.system:ApplicationDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает, какой объект ApplicationDomain следует использовать для объекта Loader.
     
     </apiDesc></apiParam><apiParam><apiItemName>securityDomain</apiItemName><apiOperationClassifier>flash.system:SecurityDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает, какой объект SecurityDomain следует использовать для объекта Loader.
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый объект JPEGLoaderContext с указанными параметрами. 
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="flash.system.xml#SecurityDomain"><linktext>flash.system.SecurityDomain</linktext></link></related-links></apiConstructor><apiValue id="flash.system:JPEGLoaderContext:deblockingFilter"><apiName>deblockingFilter</apiName><shortdesc> 
	 Задает интенсивность фильтра подавления блочности.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
	 Задает интенсивность фильтра подавления блочности. Значение 1,0 задает полную интенсивность фильтра подавления блочности, а значение 0,0 отключает этот фильтр.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.system:ApplicationDomain"><apiName>ApplicationDomain</apiName><shortdesc>
 Класс ApplicationDomain является контейнером для дискретных групп определений классов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Security considerations for application domains are discussed in the 
 applicationDomain property entries of URLRequest and LoaderInfo. 
 
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс ApplicationDomain является контейнером для дискретных групп определений классов. Домены приложения используются для разделения классов в одном домене безопасности. Они обеспечивают возможность наличия нескольких определений одного класса и позволяют нижестоящим элементам многократно использовать определения вышестоящих элементов.
 
 <p>Домены приложений используются, если внешний SWF-файл загружается с помощью класса Loader. Все определения ActionScript 3.0 в загруженном SWF-файле хранятся в домене приложения, который указывается свойством <codeph>applicationDomain</codeph> объекта LoaderContext, передаваемого в параметре <codeph>context</codeph> объекта <codeph>load()</codeph> класса Loader или метода <codeph>loadBytes()</codeph>. Объект LoaderInfo также содержит свойство <codeph>applicationDomain</codeph>, доступное только для чтения.</p>
 
 <p>Все программные коды в SWF-файле определены для существования в домене приложения. Текущим доменом приложения является домен, где выполняется основное приложение. Системный домен содержит все домены приложений, включая текущий домен, и это означает, что он содержит все классы проигрывателя Flash Player.</p>
 
 <p>Каждый домен приложения, исключая системный домен, обладает связанным вышестоящим доменом. Вышестоящий домен домена главного приложения является системным доменом. Загруженные классы определяются только в том случае, если они уже не определены в своих вышестоящих классах. Нельзя перезаписать определение загруженного класса новым определением.</p>
 
 <p>Примеры использования доменов приложений см. в книге <i>Программирование на ActionScript 3.0</i>.</p>
 
 <p>Функция конструктора <codeph>ApplicationDomain()</codeph> позволяет создавать объект ApplicationDomain.</p>
 
 </apiDesc><example conref="examples\ApplicationDomainExample.as"> В следующем примере демонстрируется загрузка выполняемого класса, а также показано, как вызывать общедоступные методы класса, находящегося в другом SWF-файле.
 <p><b>Примечания.</b></p>
 <ul>
    <li>Поскольку класс ClassLoader загружает SWF-файл, необходимо обеспечивать локальную безопасность на уровне файловой системы.</li>
    <li>Для выполнения этого примера необходимо наличие SWF-файла с именем RuntimeClasses.swf в той же папке, что и файл ApplicationDomainExample.swf.</li>
 </ul>
 
 <p>Начните создавать файл RuntimeClasses.swf с помощью следующего программного кода:</p>
 <codeblock platform="actionscript">
 package {
   import flash.display.Sprite;
   public class RuntimeClasses extends Sprite
   {
     public function RuntimeClasses()
     {}
      
     public function greet():String {
       return("Hello World");
     }
   }
 }
 </codeblock>
 
 <p>Затем выполните следующий программный код:</p>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.errors.IllegalOperationError;
    import flash.events.Event;
    import flash.text.TextField;

    public class ApplicationDomainExample extends Sprite {
        private var loader:ClassLoader;
        private var tf:TextField = new TextField();

        public function ApplicationDomainExample() {
            addChild(tf);

            loader = new ClassLoader();
            loader.addEventListener(ClassLoader.LOAD_ERROR,loadErrorHandler);
            loader.addEventListener(ClassLoader.CLASS_LOADED,classLoadedHandler);
            loader.load("RuntimeClasses.swf");
        }

        private function loadErrorHandler(e:Event):void {
            tf.text = "Load failed";
            throw new IllegalOperationError("Cannot load the specified file.");
        }

        private function classLoadedHandler(e:Event):void {
            var runtimeClassRef:Class = loader.getClass("RuntimeClasses");
            var greeter:Object = new runtimeClassRef();

            tf.text = greeter.greet();
        }
    }
}

import flash.display.Loader;
import flash.errors.IllegalOperationError;
import flash.events.Event;
import flash.events.EventDispatcher;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.net.URLRequest;
import flash.system.ApplicationDomain;
import flash.system.LoaderContext;

class ClassLoader extends EventDispatcher {
    public static var CLASS_LOADED:String = "classLoaded";
    public static var LOAD_ERROR:String = "loadError";
    private var loader:Loader;
    private var swfLib:String;
    private var request:URLRequest;
    private var loadedClass:Class;

    public function ClassLoader() {

        loader = new Loader();
        loader.contentLoaderInfo.addEventListener(Event.COMPLETE,completeHandler);
        loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,ioErrorHandler);
        loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR,securityErrorHandler);
    }

    public function load(lib:String):void {
        swfLib = lib;
        request = new URLRequest(swfLib);
        var context:LoaderContext = new LoaderContext();
        context.applicationDomain=ApplicationDomain.currentDomain;
        loader.load(request,context);
    }

    public function getClass(className:String):Class {
        try {
            return loader.contentLoaderInfo.applicationDomain.getDefinition(className)  as  Class;
        } catch (e:Error) {
            throw new IllegalOperationError(className + " definition not found in " + swfLib);
        }
        return null;
    }

    private function completeHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.CLASS_LOADED));
    }

    private function ioErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }

    private function securityErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }
}
</codeblock></example><example conref="examples\ApplicationDomainExample.2.as"> Если в нескольких SWF-файлах содержатся откомпилированные классы с одним и тем же именем, но по-разному реализованные, можно отделить классы загруженных извне SWF-файлов от классов каждого последующего примера. Ранее нижестоящему SWF-файлу предписывалось использовать <codeph>ApplicationDomain.currentDomain</codeph>. В этом случае новый домен приложения <codeph>ApplicationDomain</codeph> создается таким образом, что свойства и методы класса <codeph>Greeter</codeph> любого SWF-файла, загружаемого вторым, не будут замещать свойства и методы первого класса <codeph>Greeter</codeph>. Это можно проверить изменив свойство <codeph>context.applicationDomain</codeph> в методе <codeph>load</codeph> для <codeph>ClassLoader</codeph>.
 <p><b>Примечания.</b></p>
 <ul>
    <li>Поскольку класс ClassLoader загружает SWF-файл, необходимо обеспечивать локальную безопасность на уровне файловой системы.</li>
    <li>Для выполнения этого примера необходимо иметь два SWF-файла с названиями Greeter.swf, расположенными в папках en и es соответственно.</li>
 </ul>
 
 <p>Создайте файл Greeter.as в каталоге en, используя следующий программный код:</p>
 <codeblock platform="actionscript">
 package {
    import flash.display.Sprite;
    public class Greeter extends Sprite
    {
        public function Greeter()
        {
        }
        
        public function greet():String {
            return("Good Morning");
        }
    }
 }
 </codeblock>
 <p>Затем создайте аналогичный файл Greeter.as в каталоге es:</p>
 
 <codeblock platform="actionscript">
 package {
    import flash.display.Sprite;
    public class Greeter extends Sprite
    {
        public function Greeter()
        {
        }
        
        public function greet():String {
            return("Buenos Dias");
        }
    }
}
 </codeblock>
 
 <p>Скомпилируйте SWF-файлы для обоих случаев и затем выполните следующий программный код:</p>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.errors.IllegalOperationError;
    import flash.events.Event;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class ApplicationDomainExample2 extends Sprite {
        private var spanishGreeterLoader:ClassLoader;
        private var englishGreeterLoader:ClassLoader;
        private var tf:TextField = new TextField();
        private var greetersLoaded:uint = 0;

        public function ApplicationDomainExample2() {
            tf.autoSize = TextFieldAutoSize.LEFT;
            addChild(tf);

            spanishGreeterLoader = new ClassLoader();
            spanishGreeterLoader.addEventListener(ClassLoader.LOAD_ERROR,loadErrorHandler);
            spanishGreeterLoader.addEventListener(ClassLoader.CLASS_LOADED,classLoadedHandler);
            spanishGreeterLoader.load("es/Greeter.swf");
            
            englishGreeterLoader = new ClassLoader();
            englishGreeterLoader.addEventListener(ClassLoader.LOAD_ERROR,loadErrorHandler);
            englishGreeterLoader.addEventListener(ClassLoader.CLASS_LOADED,classLoadedHandler);
            englishGreeterLoader.load("en/Greeter.swf");
        }

        private function loadErrorHandler(e:Event):void {
            tf.text = "Load failed";
            throw new IllegalOperationError("Cannot load the specified file.");
        }

        private function classLoadedHandler(e:Event):void {
            greetersLoaded++;
            if(greetersLoaded == 2) {
                greet();    
            }
        }
        
        private function greet():void {
            var spanishGreeter:Class = spanishGreeterLoader.getClass("Greeter");
            var englishGreeter:Class = englishGreeterLoader.getClass("Greeter");
            var greeter1 = new spanishGreeter();
            var greeter2 = new englishGreeter();
            
            tf.text = greeter1.greet() + "\n" + greeter2.greet();
        }
    }
}

import flash.display.Loader;
import flash.errors.IllegalOperationError;
import flash.events.Event;
import flash.events.EventDispatcher;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.net.URLRequest;
import flash.system.ApplicationDomain;
import flash.system.LoaderContext;

class ClassLoader extends EventDispatcher {
    public static var CLASS_LOADED:String = "classLoaded";
    public static var LOAD_ERROR:String = "loadError";
    private var loader:Loader;
    private var swfLib:String;
    private var request:URLRequest;
    private var loadedClass:Class;

    public function ClassLoader() {

        loader = new Loader();
        loader.contentLoaderInfo.addEventListener(Event.COMPLETE,completeHandler);
        loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,ioErrorHandler);
        loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR,securityErrorHandler);
    }

    public function load(lib:String):void {
        swfLib = lib;
        request = new URLRequest(swfLib);
        var context:LoaderContext = new LoaderContext();
//        context.applicationDomain = ApplicationDomain.currentDomain;
        context.applicationDomain = new ApplicationDomain();
        loader.load(request,context);
    }

    public function getClass(className:String):Class {
        try {
            return loader.contentLoaderInfo.applicationDomain.getDefinition(className)  as  Class;
        } catch (e:Error) {
            throw new IllegalOperationError(className + " definition not found in " + swfLib);
        }
        return null;
    }

    private function completeHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.CLASS_LOADED));
    }

    private function ioErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }

    private function securityErrorHandler(e:Event):void {
        dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><apiConstructor id="flash.system:ApplicationDomain:ApplicationDomain"><apiName>ApplicationDomain</apiName><shortdesc>
     Создает новый домен приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>parentDomain</apiItemName><apiOperationClassifier>flash.system:ApplicationDomain</apiOperationClassifier><apiData>null</apiData><apiDesc>Если не указан вышестоящий домен, вышестоящим доменом для этого домена приложения становится системный домен.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает новый домен приложения.
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.system:ApplicationDomain:getDefinition"><apiName>getDefinition</apiName><shortdesc>
     Получает общедоступное определение от указанного домена приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>throws SecurityError The definition belongs to a domain to which
     the calling code does not have access.
     
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Общедоступного определения с указанным именем не существует.
     
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект связан с определением.
     
     </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя определения.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Получает общедоступное определение от указанного домена приложения. Это определение может быть определением класса, пространства имен или функции.
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:ApplicationDomain:hasDefinition"><apiName>hasDefinition</apiName><shortdesc>
     Проверяет существование общедоступного определения в указанном домене приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Устанавливается значение<codeph>true</codeph>, если указанное определение существует; в противном случае устанавливается значение <codeph>false</codeph>.
     
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя определения.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Проверяет существование общедоступного определения в указанном домене приложения. Это определение может быть определением класса, пространства имен или функции.
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.system:ApplicationDomain:MIN_DOMAIN_MEMORY_LENGTH:get"><apiName>MIN_DOMAIN_MEMORY_LENGTH</apiName><shortdesc>
	 Определяет минимальную длину объекта памяти, необходимую для использования в качестве ApplicationDomain.domainMemory.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiTipTexts><apiTipText>
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет минимальную длину объекта памяти, необходимую для использования в качестве ApplicationDomain.domainMemory.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:ApplicationDomain:currentDomain:get"><apiName>currentDomain</apiName><shortdesc>
     Определяет текущий домен приложения, в котором выполняется код пользователя.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Question: Do you call System.currentDomain? or Loader.currentDomain or request.currentDomain?
     
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier></apiValueDef><apiDesc>
     Определяет текущий домен приложения, в котором выполняется код пользователя.
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:ApplicationDomain:domainMemory:get"><apiName>domainMemory</apiName><shortdesc>
	 Определяет и задает объект, на котором будут выполняться операции глобальной памяти домена в рамках данного ApplicationDomain.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiTipTexts><apiTipText>
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет и задает объект, на котором будут выполняться операции глобальной памяти домена в рамках данного ApplicationDomain.
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:ApplicationDomain:parentDomain:get"><apiName>parentDomain</apiName><shortdesc>
     Определяет вышестоящий домен данного домена приложения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier></apiValueDef><apiDesc>
     Определяет вышестоящий домен данного домена приложения.
     
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.system:Capabilities"><apiName>Capabilities</apiName><shortdesc>
 Класс Capabilities содержит свойства, которые описывают систему и проигрыватель, в которых воспроизводится SWF-файл.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 <ph platform="actionscript">Класс Capabilities содержит свойства, которые описывают систему и проигрыватель, в которых воспроизводится SWF-файл. Например, экран мобильного телефона может содержать 100 квадратных пикселей (черно-белых), в то время как экран ПК будет 1000 иметь квадратных пикселей (цветных). Используя объект Capabilities для определения типа устройства пользователя, можно предоставлять соответствующее содержимое максимально возможному количеству пользователей. Если известны возможности устройства, можно указать серверу подходящие SWF-файлы для отправки или задать смену презентации для SWF-файла. </ph> <ph platform="javascript">Класс Capabilities предоставляет свойства, описывающие систему и среду выполнения, в которых находится содержимое HTML (и SWF). Используя объект Capabilities для определения типа компьютера пользователя, можно предоставлять соответствующее содержимое максимально возможному количеству пользователей. Если известны возможности компьютера, можно загружать соответствующее содержимое или использовать код для изменения его представления.</ph>
 
 <p>Однако некоторые возможности Adobe AIR не обеспечиваются свойствами класса Capabilities. Они являются свойствами других классов:</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry>Свойство</entry><entry>Описание</entry></row></thead><tbody><row>
 <entry><codeph>NativeApplication.supportsDockIcon</codeph></entry>
 <entry>Наличие в операционной системе поддержки значков панелей.</entry>
 </row><row>
 <entry><codeph>NativeApplication.supportsMenu</codeph></entry>
 <entry>Наличие в операционной системе поддержки глобальных строк меню приложений.</entry>
 </row><row>
 <entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry>
 <entry>Наличие в операционной системе поддержки значков на панели задач.</entry>
 </row><row>
 <entry><codeph>NativeWindow.supportsMenu</codeph></entry>
 <entry>Наличие в операционной системе поддержки оконных меню.</entry>
 </row><row>
 <entry><codeph>NativeWindow.supportsTransparency</codeph></entry>
 <entry>Наличие в операционной системе поддержки прозрачных окон.</entry>
 </row></tbody></tgroup></adobetable>
 
 <p><i>Не</i> используйте <codeph>Capabilities.os</codeph> или <codeph>Capabilities.manufacturer</codeph> для определения возможности на основе операционной системы. Создание функций на основе одной операционной системы не рекомендуется, так как это может привести к проблемам, если в приложении не рассмотрены все потенциальные целевые операционные системы. Вместо этого используйте свойство, соответствующее функции, для которой выполняется тестирование.</p>
 
 <p>Информацию о возможностях, которая хранится в свойстве <codeph>Capabilities.serverString</codeph> в виде URL-строки, можно отправить с помощью HTTP-методов <codeph>GET</codeph> или <codeph>POST</codeph>. В следующем примере показана строка сервера для компьютера с поддержкой MP3 и разрешением экрана 1600 x 1200 пикселей, который работает под управлением Windows XP с установленным редактором методов ввода (IME).</p>
 
 <pre>A=t&amp;SA=t&amp;SV=t&amp;EV=t&amp;MP3=t&amp;AE=t&amp;VE=t&amp;ACC=f&amp;PR=t&amp;SP=t&amp;
     SB=f&amp;DEB=t&amp;V=WIN%209%2C0%2C0%2C0&amp;M=Adobe%20Windows&amp;
     R=1600x1200&amp;DP=72&amp;COL=color&amp;AR=1.0&amp;OS=Windows%20XP&amp;
     L=en&amp;PT=External&amp;AVD=f&amp;LFD=f&amp;WD=f&amp;IME=t</pre>
 
 <p>В следующей таблице перечислены свойства класса Capabilities и соответствующие строки сервера.
 <adobetable class="innertable">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   
  
  
  
  
  
  
  
  
 <tgroup cols="2"><thead><row><entry align="left">Свойство класса Capabilities</entry><entry align="left">Строка сервера</entry></row></thead><tbody><row>
      <entry><codeph>avHardwareDisable</codeph></entry>
      <entry><codeph>AVD</codeph></entry>
  </row><row>
      <entry><codeph>hasAccessibility</codeph></entry>
      <entry><codeph>ACC</codeph></entry>
  </row><row>
      <entry><codeph>hasAudio</codeph></entry>
      <entry><codeph>A</codeph></entry>
  </row><row>
      <entry><codeph>hasAudioEncoder</codeph></entry>
      <entry><codeph>AE</codeph></entry>
  </row><row>
      <entry><codeph>hasEmbeddedVideo</codeph></entry>
      <entry><codeph>EV</codeph></entry>
  </row><row>
      <entry><codeph>hasIME</codeph></entry>
      <entry><codeph>IME</codeph></entry>
  </row><row>
      <entry><codeph>hasMP3</codeph></entry>
      <entry><codeph>MP3</codeph></entry>
  </row><row>
      <entry><codeph>hasPrinting</codeph></entry>
      <entry><codeph>PR</codeph></entry>
  </row><row>
      <entry><codeph>hasScreenBroadcast</codeph></entry>
      <entry><codeph>SB</codeph></entry>
  </row><row>
      <entry><codeph>hasScreenPlayback</codeph></entry>
      <entry><codeph>SP</codeph></entry>
  </row><row>
      <entry><codeph>hasStreamingAudio</codeph></entry>
      <entry><codeph>SA</codeph></entry>
  </row><row>
      <entry><codeph>hasStreamingVideo</codeph></entry>
      <entry><codeph>SV</codeph></entry>
  </row><row>
      <entry><codeph>hasTLS</codeph></entry>
      <entry><codeph>TLS</codeph></entry>
  </row><row>
      <entry><codeph>hasVideoEncoder</codeph></entry>
      <entry><codeph>VE</codeph></entry>
  </row><row>
      <entry><codeph>isDebugger</codeph></entry>
      <entry><codeph>DEB</codeph></entry>
  </row><row>
      <entry><codeph>language</codeph></entry>
      <entry><codeph>L</codeph></entry>
  </row><row>
      <entry><codeph>localFileReadDisable</codeph></entry>
      <entry><codeph>LFD</codeph></entry>
  </row><row>
      <entry><codeph>manufacturer</codeph></entry>
      <entry><codeph>M</codeph></entry>
  </row><row>
      <entry><codeph>maxLevelIDC</codeph></entry>
      <entry><codeph>ML</codeph></entry>
  </row><row>
      <entry><codeph>os</codeph></entry>
      <entry><codeph>OS</codeph></entry>
  </row><row>
      <entry><codeph>pixelAspectRatio</codeph></entry>
      <entry><codeph>AR</codeph></entry>
  </row><row>
      <entry><codeph>playerType</codeph></entry>
      <entry><codeph>PT</codeph></entry>
  </row><row>
      <entry><codeph>screenColor</codeph></entry>
      <entry><codeph>COL</codeph></entry>
  </row><row>
      <entry><codeph>screenDPI</codeph></entry>
      <entry><codeph>DP</codeph></entry>
  </row><row>
      <entry><codeph>screenResolutionX</codeph></entry>
      <entry><codeph>R</codeph></entry>
  </row><row>
      <entry><codeph>screenResolutionY</codeph></entry>
      <entry><codeph>R</codeph></entry>
  </row><row>
      <entry><codeph>version</codeph></entry>
      <entry><codeph>V</codeph></entry>
  </row></tbody></tgroup></adobetable>
 </p>
  
 <p>Существует также строка сервера <codeph>WD</codeph>, указывающая, отключен ли безоконный режим. Безоконный режим может быть отключен в Flash Player вследствие несовместимости с web-браузером или из-за пользовательской настройки в файле mms.cfg. Соответствующее значение свойства Capabilities отсутствует.</p>
  
 <p>Все свойства класса Capabilities доступны только для чтения.</p>
 
 </apiDesc><example conref="examples\CapabilitiesExample.as"> В следующем примере просто приведены значения, обнаруженные в объекте flash.system.Capabilities с помощью нескольких вызовов <codeph>trace()</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.system.Capabilities;

    public class CapabilitiesExample extends Sprite {
        public function CapabilitiesExample() {
            showCapabilities();
        }
        
        private function showCapabilities():void {
            trace("avHardwareDisable: " + Capabilities.avHardwareDisable);
            trace("hasAccessibility: " + Capabilities.hasAccessibility);
            trace("hasAudio: " + Capabilities.hasAudio);
            trace("hasAudioEncoder: " + Capabilities.hasAudioEncoder);
            trace("hasEmbeddedVideo: " + Capabilities.hasEmbeddedVideo);
            trace("hasMP3: " + Capabilities.hasMP3);
            trace("hasPrinting: " + Capabilities.hasPrinting);
            trace("hasScreenBroadcast: " + Capabilities.hasScreenBroadcast);
            trace("hasScreenPlayback: " + Capabilities.hasScreenPlayback);
            trace("hasStreamingAudio: " + Capabilities.hasStreamingAudio);
            trace("hasVideoEncoder: " + Capabilities.hasVideoEncoder);
            trace("isDebugger: " + Capabilities.isDebugger);
            trace("language: " + Capabilities.language);
            trace("localFileReadDisable: " + Capabilities.localFileReadDisable);
            trace("manufacturer: " + Capabilities.manufacturer);
            trace("os: " + Capabilities.os);
            trace("pixelAspectRatio: " + Capabilities.pixelAspectRatio);
            trace("playerType: " + Capabilities.playerType);
            trace("screenColor: " + Capabilities.screenColor);
            trace("screenDPI: " + Capabilities.screenDPI);
            trace("screenResolutionX: " + Capabilities.screenResolutionX);
            trace("screenResolutionY: " + Capabilities.screenResolutionY);
            trace("serverString: " + Capabilities.serverString);
            trace("version: " + Capabilities.version);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiValue id="flash.system:Capabilities:avHardwareDisable:get"><apiName>avHardwareDisable</apiName><shortdesc>
     Показывает, был ли запрещен администратором доступ к камере и микрофону пользователя (значение true) или нет (значение false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.avHardwareDisable, avHardwareDisable
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Показывает, был ли запрещен администратором доступ к камере и микрофону пользователя (значение <codeph>true</codeph>) или нет (значение <codeph>false</codeph>). Строка сервера <codeph>AVD</codeph>.
     
	 <p>В Adobe AIR™ это свойство применяется только к содержимому, находящемуся за пределами изолированной программной среды приложения. Содержимое, находящееся в изолированной программной среде приложения, может всегда обращаться к камере и микрофону пользователя.</p>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#Camera/getCamera()"><linktext>flash.media.Camera.getCamera()</linktext></link><link href="flash.media.xml#Microphone/getMicrophone()"><linktext>flash.media.Microphone.getMicrophone()</linktext></link><link href="flash.system.xml#Security/showSettings()"><linktext>Security.showSettings()</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:cpuArchitecture:get"><apiName>cpuArchitecture</apiName><shortdesc>
	 Указывает текущую архитектуру ЦП на компьютере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5.1"/></apiVersion></asMetadata><asCustoms><oldexample>The following example traces the value of this read-only property:
	 <pre>
	 trace(Capabilities.cpuArchitecture);
	 </pre>
	 </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает текущую архитектуру ЦП на компьютере. Свойство <codeph>cpuArchitecture</codeph> может возвратить следующие строки: <codeph>PowerPC</codeph>, <codeph>x86</codeph>, <codeph>SPARC</codeph> и <codeph>ARM</codeph>. Строка сервера <codeph>ARCH</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasAccessibility:get"><apiName>hasAccessibility</apiName><shortdesc>
	 Указывает, поддерживает ли система связь со средствами для обеспечения специальных возможностей (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasAccessibility, hasAccessibility,
     accessibility
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, поддерживает ли система связь со средствами для обеспечения специальных возможностей (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>ACC</codeph>. 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/active"><linktext>flash.accessibility.Accessibility.active</linktext></link><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:hasAudio:get"><apiName>hasAudio</apiName><shortdesc>
	 Указывает, поддерживает ли система воспроизведение аудио.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasAudio, hasAudio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, поддерживает ли система воспроизведение аудио. Для этого свойства всегда установлено значение<codeph>true</codeph>. Строка сервера <codeph>A</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasAudioEncoder:get"><apiName>hasAudioEncoder</apiName><shortdesc>
	 Показывает, может ли система кодировать аудиопотоки, например данные с микрофона (true), или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasAudioEncoder, hasAudioEncoder 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, может ли система кодировать аудиопотоки, например данные с микрофона (<codeph>true</codeph>), или нет (<codeph>false</codeph>). Строка сервера <codeph>AE</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasEmbeddedVideo:get"><apiName>hasEmbeddedVideo</apiName><shortdesc>
	 Указывает, поддерживает ли система внедренное видео (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasEmbeddedVideo, hasEmbeddedVideo, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, поддерживает ли система внедренное видео (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>EV</codeph>. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasIME:get"><apiName>hasIME</apiName><shortdesc>
	 Указывает, установлен ли в системе редактор метода ввода (IME) (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasIME, hasIME, IME 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, установлен ли в системе редактор метода ввода (IME) (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>IME</codeph>. 
     
     </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IME"><linktext>flash.system.IME</linktext></link><link href="flash.system.xml#System/ime"><linktext>flash.system.System.ime</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:hasMP3:get"><apiName>hasMP3</apiName><shortdesc>
	 Указывает, имеет ли система декодер МР3 (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasMP3, hasMP3, MP3, audio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, имеет ли система декодер МР3 (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>MP3</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasPrinting:get"><apiName>hasPrinting</apiName><shortdesc>
	 Указывает, поддерживает ли система печать (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasPrinting, hasPrinting, printing 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает, поддерживает ли система печать (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>PR</codeph>. 
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasScreenBroadcast:get"><apiName>hasScreenBroadcast</apiName><shortdesc>
	 Показывает, поддерживает ли система разработку приложений видеотрансляции для работы через Flash Media Server (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasScreenBroadcast, hasScreenBroadcast
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, поддерживает ли система разработку приложений видеотрансляции для работы через Flash Media Server (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>SB</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasScreenPlayback:get"><apiName>hasScreenPlayback</apiName><shortdesc>
	 Показывает, поддерживает ли система воспроизведение приложений видеотрансляции, выполняемых через Flash Media Server (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasScreenPlayback, hasScreenPlayback
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, поддерживает ли система воспроизведение приложений видеотрансляции, выполняемых через Flash Media Server (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>SP</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasStreamingAudio:get"><apiName>hasStreamingAudio</apiName><shortdesc>
	 Показывает, поддерживает ли система воспроизведение потокового аудио (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasStreamingAudio, hasStreamingAudio, audio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, поддерживает ли система воспроизведение потокового аудио (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>SA</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasStreamingVideo:get"><apiName>hasStreamingVideo</apiName><shortdesc>
	 Показывает, поддерживает ли система воспроизведение потокового видео (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasStreamingVideo, hasStreamingVideo, video
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, поддерживает ли система воспроизведение потокового видео (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>SV</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:hasTLS:get"><apiName>hasTLS</apiName><shortdesc>
	 Показывает, поддерживает ли система собственные сокеты SSL через NetConnection (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasTLS, hasTLS, TLS 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, поддерживает ли система собственные сокеты SSL через NetConnection (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Строка сервера <codeph>TLS</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#NetConnection/connectedProxyType"><linktext>flash.net.NetConnection.connectedProxyType</linktext></link><link href="flash.net.xml#NetConnection/proxyType"><linktext>flash.net.NetConnection.proxyType</linktext></link><link href="flash.net.xml#NetConnection/usingTLS"><linktext>flash.net.NetConnection.usingTLS</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:hasVideoEncoder:get"><apiName>hasVideoEncoder</apiName><shortdesc>
	 Показывает, способна ли система кодировать видеопотоки, например данные с web-камеры (true), или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.hasVideoEncoder, hasVideoEncoder
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, способна ли система кодировать видеопотоки, например данные с web-камеры (<codeph>true</codeph>), или нет (<codeph>false</codeph>). Строка сервера <codeph>VE</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:isDebugger:get"><apiName>isDebugger</apiName><shortdesc> 
	 Показывает, является ли система специальной отладочной версией (true) или официально выпущенной версией (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.isDebugger, isDebugger, debugging 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 Показывает, является ли система специальной отладочной версией (<codeph>true</codeph>) или официально выпущенной версией (<codeph>false</codeph>). Строка сервера <codeph>DEB</codeph>. Это свойство имеет значение <codeph>true</codeph>, когда работает <ph platform="actionscript">отладочная версия Flash Player или</ph> AIR Debug Launcher (ADL).
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:isEmbeddedInAcrobat:get"><apiName>isEmbeddedInAcrobat</apiName><shortdesc>
     Указывает, в какой версии Acrobat открывается PDF-файл, в который встроен проигрыватель в PDF-файл: в Acrobat 9.0 или более поздней (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.127.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.isEmbeddedInAcrobat, isEmbeddedInAcrobat, Acrobat
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, в какой версии Acrobat открывается PDF-файл, в который встроен проигрыватель в PDF-файл: в Acrobat 9.0 или более поздней (<codeph>true</codeph>) или нет (<codeph>false</codeph>).
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:language:get"><apiName>language</apiName><shortdesc>
	 Указывает код языка системы, в которой запущено содержимое.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.language, language
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает код языка системы, в которой запущено содержимое. Язык указан как строчная двухсимвольная кодировка ISO 639-1. Для китайского языка предусмотрена дополнительная двухсимвольная национальная кодировка верхнего регистра из ISO 3166, различающая упрощенный и традиционный китайский языки. Обозначения кодировок основаны на английских названиях соответствующих языков, например: <codeph>hu</codeph> обозначает венгерский язык (Hungarian).
     
     <p>В системах на английском языке это свойство возвращает только код языка (<codeph>en</codeph>), но не код страны. В системах Microsoft Windows это свойство возвращает значение для языка интерфейса пользователя (UI), указывающее, какой язык используется во всех меню, диалоговых окнах, сообщениях об ошибках и файлах справки. В следующей таблице перечислены возможные значения.
     
     <adobetable class="innertable">
     
     
     
     
     
         
         
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry align="left">Язык</entry><entry align="left">Значение</entry></row></thead><tbody><row>
      <entry>Чешский</entry>
      <entry><codeph>cs</codeph></entry>
     </row><row>
      <entry>Датский</entry>
      <entry><codeph>da</codeph></entry>
     </row><row>
      <entry>Голландский</entry>
      <entry><codeph>nl</codeph></entry>
     </row><row>
      <entry>English</entry>
      <entry><codeph>en</codeph></entry>
     </row><row>
      <entry>Финский</entry>
      <entry><codeph>fi</codeph></entry>
     </row><row>
      <entry>Французский</entry>
      <entry><codeph>fr</codeph></entry>
     </row><row>
      <entry>Немецкий</entry>
      <entry><codeph>de</codeph></entry>
     </row><row>
      <entry>Венгерский</entry>
      <entry><codeph>hu</codeph></entry>
     </row><row>
      <entry>Итальянский</entry>
      <entry><codeph>it</codeph></entry>
     </row><row>
      <entry>Японский</entry>
      <entry><codeph>ja</codeph></entry>
     </row><row>
      <entry>Корейский</entry>
      <entry><codeph>ko</codeph></entry>
     </row><row>
      <entry>Норвежский</entry>
      <entry><codeph>Нет</codeph></entry>
     </row><row>
      <entry>Другой/неизвестен</entry>
      <entry><codeph>xu</codeph></entry>
     </row><row>
      <entry>Польский</entry>
      <entry><codeph>pl</codeph></entry>
     </row><row>
      <entry>Португальский</entry>
      <entry><codeph>pt</codeph></entry>
     </row><row>
      <entry>Русский</entry>
      <entry><codeph>ru</codeph></entry>
     </row><row>
      <entry>Китайский (упрощенный)</entry>
      <entry><codeph>zh-CN</codeph></entry>
     </row><row>
      <entry>Испанский</entry>
      <entry><codeph>es</codeph></entry>
     </row><row>
      <entry>Шведский</entry>
      <entry><codeph>sv</codeph></entry>
     </row><row>
      <entry>Китайский (традиционный)</entry>
      <entry><codeph>zh-TW</codeph></entry>
     </row><row>
      <entry>Турецкий</entry>
      <entry><codeph>tr</codeph></entry>
     </row></tbody></tgroup></adobetable>
     </p>
	 
	 <p><i>Примечание.</i> Свойство <codeph>Capabilities.language</codeph> может иметь только те значения, которые перечислены в списке. Вследствие этого ограничения приложения Adobe AIR должны использовать первый элемент в массиве <codeph>Capabilities.languages</codeph> для определения основного языка пользовательского интерфейса в системе. </p>
	 
     <p>Строка сервера <codeph>L</codeph>.</p>
     
     </apiDesc><example conref="examples\Capabilities_languageExample.as"> В следующем примере отображаемое содержимое зависит от языка операционной системы пользователя.
 
 <p>В свойстве <codeph>Capabilities.language</codeph> возвращается код языка по стандарту ISO 639-1 (например, «en» для английского). Инструкция <codeph>switch</codeph> проверяет код языка и устанавливает в качестве содержимого текстового поля <codeph>myTextField</codeph> приветствие, характерное для данного языка. Если код этого языка в данном примере не поддерживается, возвращается строка ошибки по умолчанию.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.system.Capabilities;

    public class Capabilities_languageExample extends Sprite {

        public function Capabilities_languageExample()  {
            var myTextField:TextField = new TextField();         
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            var greetingEnglish:String = "Hello World";
            var greetingGerman:String = "Hallo Welt";
            var greetingFrench:String = "Bonjour Monde";
            var greetingSpanish:String = "Hola Mundo";

            var lang:String = Capabilities.language;
                         
            switch (lang) {
                case "en":
                    myTextField.text = greetingEnglish;
                    break;
                case "de":
                    myTextField.text = greetingGerman;
                    break;
                case "fr":
                    myTextField.text = greetingFrench;
                    break;
                case "es":
                    myTextField.text = greetingSpanish;
                    break;
                default:
                    myTextField.text = "Sorry your system's language is not supported at this time.";               
            }
             
            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.system.xml#Capabilities/languages"><linktext>languages</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:languages:get"><apiName>languages</apiName><shortdesc>
	 Массив строк, содержащий сведения о предпочитаемых языках пользовательского интерфейса, заданных в операционной системе.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Массив строк, содержащий сведения о предпочитаемых языках пользовательского интерфейса, заданных в операционной системе. Строки будут содержать теги языков (а также, где это применимо, сведения о сценарии и регионе), определенные в RFC4646 (<xref href="http://www.ietf.org/rfc/rfc4646.txt" scope="external">http://www.ietf.org/rfc/rfc4646.txt</xref>), и будут использовать дефисы в качестве разделителей (например, <codeph>"en-US"</codeph> или <codeph>"ja-JP"</codeph>). Языки перечисляются в массиве в порядке предпочтения, в соответствии с параметрами операционной системы. 
	 
	 <p>Операционные системы отличаются сведениями о регионе, возвращенными строками языковых стандартов. Одна операционная система может возвратить <codeph>en-us</codeph>, а другая – <codeph>en</codeph>.</p>
	 
	 <p>Первая запись в возвращенном массиве, как правило, имеет тот же идентификатор основного языка, что и свойство <codeph>Capabilities.language</codeph>. Например, если <codeph>Capabilities.languages[0]</codeph> имеет значение <codeph>en-US</codeph>, то свойство <codeph>language</codeph> имеет значение <codeph>en</codeph>. Однако, если свойство <codeph>Capabilities.language</codeph> имеет значение <codeph>xu</codeph> (указывающее неизвестный язык), то первый элемент в этом массиве будет другим. В связи с этим <codeph>Capabilities.languages[0]</codeph> может указывать более точную информацию, чем <codeph>Capabilities.language</codeph>.</p>
	 
	 <p>Строка сервера <codeph>LS</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:localFileReadDisable:get"><apiName>localFileReadDisable</apiName><shortdesc>
     Показывает, был ли запрещен администратором доступ к жесткому диску пользователя (значение true) или нет (значение false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.localFileReadDisable, localFileReadDisable
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Показывает, был ли запрещен администратором доступ к жесткому диску пользователя (значение <codeph>true</codeph>) или нет (значение <codeph>false</codeph>). В Adobe AIR это свойство применяется только к содержимому, находящемуся за пределами изолированной программной среды приложения. (Содержимое в изолированной программной среде приложения всегда может считывать данные в файловой системе.) <ph platform="actionscript">Если для этого свойства установлено значение <codeph>true</codeph>, проигрыватель Flash Player не может читать файлы (включая первый файл, с которым запускается проигрыватель Flash Player) с жесткого диска пользователя. </ph> Если это свойство имеет значение <codeph>true</codeph>, содержимое AIR, находящееся за пределами изолированной программной среды приложения, не может считывать файлы с локального жесткого диска. Например, попытки прочитать файл на жестком диске пользователя с помощью методов загрузки завершаться ошибкой, если для этого свойства задано значение <codeph>true</codeph>.
	 
	 <p platform="actionscript">Чтение общих во время выполнения библиотек также блокируется, если для этого свойства установлено значение <codeph>true</codeph>, но чтение локальных общих библиотек разрешено независимо от значения этого свойства.</p>
	 
	 <p>Строка сервера <codeph>LFD</codeph>.</p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.system:Capabilities:manufacturer:get"><apiName>manufacturer</apiName><shortdesc>
	 Указывает производителя работающей версии Flash Player или среды выполнения AIR в формате «Adobe OSName».</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.manufacturer, manufacturer
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает производителя <ph platform="actionscript">работающей версии Flash Player</ph> или среды выполнения AIR в формате <codeph>«Adobe</codeph> <codeph><i>OSName</i>»</codeph>. Значением для <codeph><i>OSName</i></codeph> могут быть <codeph>Windows</codeph>, <codeph>Macintosh</codeph>, <codeph>Linux</codeph> или название другой операционной системы. Строка сервера <codeph>M</codeph>.
     
	 <p><i>Не</i> используйте <codeph>Capabilities.manufacturer</codeph> для определения возможности на основе операционной системы, если существует более конкретное свойство, соответствующее возможности. Создание функций на основе одной операционной системы не рекомендуется, так как это может привести к проблемам, если в приложении не рассмотрены все потенциальные целевые операционные системы. Вместо этого используйте свойство, соответствующее функции, для которой выполняется тестирование. Для получения дополнительных сведений см. описание класса Capabilities.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:maxLevelIDC:get"><apiName>maxLevelIDC</apiName><shortdesc>
     Извлечение самого высокого уровня IDC H.264, поддерживаемого оборудованием клиента.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.maxLevelIDC, maxLevelIDC
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Извлечение самого высокого уровня IDC H.264, поддерживаемого оборудованием клиента. На этом уровне носитель будет гарантированно запущен; однако носитель, запущенный на более высоком уровне, может выполняться с более низким качеством. Это свойство необходимо для серверов, на которых предпринимается попытка получения сведений о возможностях клиента. С помощью этого свойства сервер может определить уровень видео, переданного клиенту.
     
     <p>Серверной строкой является <codeph>ML</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:os:get"><apiName>os</apiName><shortdesc>
     Указывает текущую операционную систему.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.os, os
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Указывает текущую операционную систему. Свойство <codeph>os</codeph> может возвращать следующие строки: <codeph>Windows XP</codeph>, <codeph>Windows 2000</codeph>, <codeph>Windows NT</codeph>, <codeph>Windows 98/ME</codeph>, <codeph>Windows 95</codeph>, <codeph>Windows CE</codeph> (доступно только в Flash Player SDK, а в версии для ПК – нет), <codeph>Linux</codeph> и <codeph>Mac OS X.Y.Z</codeph> (где X.Y.Z – это номер версии, например <codeph>Mac OS 10.5.2</codeph>). Строка сервера <codeph>OS</codeph>.
     
	 <p><i>Не</i> используйте <codeph>Capabilities.os</codeph> для определения возможности на основе операционной системы, если существует более конкретное свойство, соответствующее функции. Создание функций на основе одной операционной системы не рекомендуется, так как это может привести к проблемам, если в приложении не рассмотрены все потенциальные целевые операционные системы. Вместо этого используйте свойство, соответствующее функции, для которой выполняется тестирование. Для получения дополнительных сведений см. описание класса Capabilities.</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:pixelAspectRatio:get"><apiName>pixelAspectRatio</apiName><shortdesc> 
     Задает пропорции экрана в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.pixelAspectRatio, pixelAspectRatio
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
     Задает пропорции экрана в пикселях. Строка сервера <codeph>AR</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:playerType:get"><apiName>playerType</apiName><shortdesc>
	 Указывает тип среды выполнения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.playerType, playerType
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает тип среды выполнения. Это свойство может иметь одно из следующих значений.
	 
     <ul>
	   <li><codeph>ActiveX</codeph> для управляющего элемента ActiveX с проигрывателем Flash Player, используемого в Microsoft Internet Explorer</li>
	   <li><codeph>Desktop</codeph> для среды выполнения Adobe AIR (за исключением SWF-содержимого, загруженного HTML-страницей, со свойством <codeph>Capabilities.playerType</codeph> в значении <codeph>PlugIn</codeph>)</li>
	   <li><codeph>External</codeph> для внешнего проигрывателя Flash Player<ph outputclass="flashonly"> или для работы в режиме тестирования</ph></li>
	   <li><codeph>PlugIn</codeph> для внешнего модуля браузера Flash Player (и для SWF-содержимого, загруженного HTML-страницей в приложении AIR)</li>
       <li><codeph>StandAlone</codeph> для автономного проигрывателя Flash Player</li>
     </ul>
     <p>Строка сервера <codeph>PT</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenColor:get"><apiName>screenColor</apiName><shortdesc>
     Задает цвет экрана.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenColor, screenColor
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Задает цвет экрана. Это свойство может иметь значение <codeph>color</codeph>, <codeph>gray</codeph> (для изображения в оттенках серого) или <codeph>bw</codeph> (для черно-белого изображения). Строка сервера <codeph>COL</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenDPI:get"><apiName>screenDPI</apiName><shortdesc>
     Задает разрешение dpi (точек на дюйм) экрана в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenDPI, screenDPI
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Задает разрешение dpi (точек на дюйм) экрана в пикселях. Строка сервера <codeph>DP</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenResolutionX:get"><apiName>screenResolutionX</apiName><shortdesc>
     Задает максимальное разрешение экрана по горизонтали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenResolutionX, screenResolutionY
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     Задает максимальное разрешение экрана по горизонтали. Строка сервера <codeph>R</codeph> (возвращает значения как для ширины, так и для высоты экрана). Это свойство не обновляется пользовательским значением разрешения экрана, а только показывает разрешение в момент запуска проигрывателя <ph platform="actionscript">Flash Player или</ph> приложения Adobe AIR. Кроме того, это значение указывает характеристики только для основного монитора.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:screenResolutionY:get"><apiName>screenResolutionY</apiName><shortdesc> 
     Задает максимальное разрешение экрана по вертикали.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.screenResolutionY, screenResolutionY
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc> 
     Задает максимальное разрешение экрана по вертикали. Строка сервера <codeph>R</codeph> (возвращает значения как для ширины, так и для высоты экрана). Это свойство не обновляется пользовательским значением разрешения экрана, а только показывает разрешение в момент запуска проигрывателя <ph platform="actionscript">Flash Player или</ph> приложения Adobe AIR. Кроме того, это значение указывает характеристики только для основного монитора.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:serverString:get"><apiName>serverString</apiName><shortdesc> 
     Строка в кодировке URL, задающая значения для каждого свойства Capabilities.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.serverString, serverString
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
     Строка в кодировке URL, задающая значения для каждого свойства Capabilities.
	 
     <p>В следующем примере показана закодированная в URL строка:
     <pre>A=t&amp;SA=t&amp;SV=t&amp;EV=t&amp;MP3=t&amp;AE=t&amp;VE=t&amp;ACC=f&amp;PR=t&amp;SP=t&amp;
     SB=f&amp;DEB=t&amp;V=WIN%208%2C5%2C0%2C208&amp;M=Adobe%20Windows&amp;
     R=1600x1200&amp;DP=72&amp;COL=color&amp;AR=1.0&amp;OS=Windows%20XP&amp;
     L=en&amp;PT=External&amp;AVD=f&amp;LFD=f&amp;WD=f</pre></p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:supports32BitProcesses:get"><apiName>supports32BitProcesses</apiName><shortdesc>
     Показывает, поддерживает ли система выполнение 32-разрядных процессов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata><asCustoms><oldexample>The following example traces the value of this read-only property:
     <pre>
     trace(Capabilities.supports32BitProcesses);
     </pre>
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Показывает, поддерживает ли система выполнение 32-разрядных процессов. Строка сервера <codeph>PR32</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:supports64BitProcesses:get"><apiName>supports64BitProcesses</apiName><shortdesc>
     Показывает, поддерживает ли система выполнение 64-разрядных процессов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata><asCustoms><oldexample>The following example traces the value of this read-only property:
     <pre>
     trace(Capabilities.supports64BitProcesses);
     </pre>
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Показывает, поддерживает ли система выполнение 64-разрядных процессов. Строка сервера <codeph>PR64</codeph>.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:Capabilities:version:get"><apiName>version</apiName><shortdesc> 
	 Показывает сведения о платформе и версии Flash Player или Adobe&amp;#xAE; AIR&amp;#xAE;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Capabilities, Capabilities.version, version
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	 Показывает сведения о платформе и версии Flash Player или Adobe<sup>®</sup> AIR<sup>®</sup>. Номер версии имеет следующий формат: <i>platform majorVersion, minorVersion, buildNumber, internalBuildNumber</i>. Возможными значениями для <i>platform</i> являются <codeph>WIN</codeph>, ` <codeph>MAC</codeph> и <codeph>LNX</codeph>. Вот несколько примеров информации о версии.
	 
     <pre>
     WIN 9,0,0,0  // Flash Player 9 for Windows
     MAC 7,0,25,0   // Flash Player 7 for Macintosh
	 LNX 9,0,115,0  // Flash Player 9 for Linux
     </pre>
	 
	 <p><i>Не</i> используйте <codeph>Capabilities.version</codeph> для определения возможности на основе операционной системы, если существует более конкретное свойство, соответствующее возможности. Создание функций на основе одной операционной системы не рекомендуется, так как это может привести к проблемам, если в приложении не рассмотрены все потенциальные целевые операционные системы. Вместо этого используйте свойство, соответствующее функции, для которой выполняется тестирование. Для получения дополнительных сведений см. описание класса Capabilities.</p>
	 
     <p>Строка сервера <codeph>V</codeph>.</p>
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiOperation id="globalOperation:flash.system:fscommand"><apiName>fscommand</apiName><shortdesc>
 Обеспечивает взаимодействие SWF-файла с проигрывателем Flash Player или программой, содержащей Flash Player, например web-браузером.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample><p>In the following example, the <code>fscommand()</code> function sets Flash Player to 
 scale the SWF file to the full monitor screen size when the <code>fullscreen_btn</code> button or 
 <code>unfullscreen_btn</code> is released:</p>
 
 <pre>this.fullscreen_btn.onRelease = function() {
   fscommand("fullscreen", true);
 };
 this.unfullscreen_btn.onRelease = function() {
   fscommand("fullscreen", false);
 };
 </pre>
 
 <p>The following example uses the <code>fscommand()</code> function applied to a button in Flash to 
 open a JavaScript message box in an HTML page. The message itself is sent to JavaScript as the 
 <code>fscommand</code> parameter. </p>
 
 <p>You must add a function to the HTML page that contains the SWF file. This function, 
 <code><i>myDocument</i></code><code>_DoFSCommand</code>, sits in the HTML page and waits for an 
 <code>fscommand()</code> function in Flash. When an <code>fscommand</code> is triggered in Flash 
 (for example, when a user presses the button), the <code>command</code> and <code>args</code> strings 
 are passed to the <code><i>myDocument</i></code><code>_DoFSCommand </code>function. You can use the 
 passed strings in your JavaScript or VBScript code in any way you like. In this example, the function 
 contains a conditional <code>if</code> statement that checks to see if the command string is 
 "<code>messagebox</code>". If it is, a JavaScript alert box (or "message box") opens 
 and displays the contents of the <code>args</code> string.</p>
 
 <pre>function myDocument_DoFSCommand(command, args) {
   if (command == "messagebox") {
      alert(args);
   }
 
 </pre>
 
 <p>In the Flash document, add the <code>fscommand()</code> function to a button:</p>
 
 <pre>fscommand("messagebox", "This is a message box called from within Flash.")
 </pre>
 
 <p>You can also use expressions for the <code>fscommand()</code> function and parameters, as in the 
 following example:</p>
 
 <pre>fscommand("messagebox", "Hello, " + name + ", welcome to our website!")
 </pre>
 
 <p>To test the SWF file, select File > Publish Preview > HTML.</p>
 
 <p><strong>Note: </strong>If you publish your SWF file using the Flash with FSCommand template in the 
 HTML 
 tab of the Publish Settings dialog box, the <code>myDocument_DoFSCommand</code> function is inserted 
 automatically. The SWF file's <code>NAME</code> and <code>ID</code> attributes will be the filename. 
 For example, for the file myDocument.fla, the attributes would be set to <code>myDocument</code>.</p>
 
  
  </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если вызов функции не выполняется в ответ на действие пользователя, например событие мыши или нажатие клавиши.
 
 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>command</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, переданная главному приложению в различных целях, или команда, переданная проигрывателю Flash Player.
 
 </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>Строка, переданная главному приложению в различных целях, или значение, переданное проигрывателю Flash Player.
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Обеспечивает взаимодействие SWF-файла с проигрывателем Flash Player или программой, содержащей Flash Player, например web-браузером. Чтобы передавать сообщения в Director или в Visual Basic, Visual C++ и другие программы, способные вмещать управляющие элементы ActiveX, можно также использовать функцию <codeph>fscommand()</codeph>.
 
  
 <p>Функция <codeph>fscommand()</codeph> обеспечивает взаимодействие SWF-файла со сценарием на web-странице. Но доступ к сценариям контролируется параметрами <codeph>allowScriptAccess</codeph> для web-страниц. (Этот атрибут устанавливается в коде HTML, встроенном в SWF-файл. Например, в тег <codeph>PARAM</codeph> для Internet Explorer или тег <codeph>EMBED</codeph> для Netscape.) </p>
  <ul>
  
  <li> Если свойство <codeph>allowScriptAccess</codeph> имеет значение <codeph>sameDomain</codeph> (по умолчанию), работа со сценариями разрешена только для SWF-файлов, находящихся в том же домене, что и web-страница. </li> 
  <li> Если свойство <codeph>allowScriptAccess</codeph> имеет значение <codeph>always</codeph>, SWF-может обращаться к HTML-странице, в которую он встроен, даже если он находится на другом домене. </li>
  <li>Если свойство <codeph>allowScriptAccess</codeph> имеет значение <codeph>never</codeph>, SWF-файл не может обращаться ни к каким HTML-страницам. Обратите внимание, что использование этого значения не рекомендуется. Оно не требуется, если в вашем собственном домене не обслуживаются недоверенные SWF-файлы. В случае необходимости обслуживать недоверенный SWF-файлы Adobe рекомендует создать отдельный субдомен, на который следует помещать все недоверенное содержимое. </li>
 </ul>
 
 <p>Можно запретить использование SWF-файлом этого метода путем установки параметра <codeph>allowNetworking</codeph> для тегов <codeph>object</codeph> и <codeph>embed</codeph> на странице HTML, содержащей SWF-содержимое. </p>
 
 <p>Функция <codeph>fscommand()</codeph> не разрешена, если вызывающий SWF-файл находится вне локальной файловой системы или изолированной сетевой среды, а содержащая его страница HTML находится не в доверенной изолированной среде.</p>
 
 <p>Дополнительные сведения по обеспечению безопасности см. в следующих источниках.</p>
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 <li class="flashonly"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_ru" scope="external">Глава о безопасности</xref> в книге <i>Программирование на ActionScript 3.0</i> и последние комментарии на странице LiveDocs.</li>
 
 <li>Раздел центра разработки Flash Player: <xref href="http://www.adobe.com/go/devnet_security_ru" scope="external">Безопасность</xref></li>
 </ul>
 
 <p>Применение 1: чтобы использовать функцию <codeph>fscommand()</codeph> для отправки сообщения проигрывателю Flash Player, необходимо использовать предварительно определенные команды и параметры. В следующей таблице показаны значения, которые можно указать для передаваемых с функцией <codeph>fscommand()</codeph> параметров <codeph>command</codeph> и <codeph>args</codeph>. Эти значения управляют SWF-файлам, воспроизводимыми в проигрывателе Flash Player, включая проекторы. (<i>Проектором</i> называют SWF-файл, сохраненный в формате, который позволяет выполнять его в автономном приложении, то есть, не используя проигрыватель Flash Player.)</p>
 
              <adobetable class="innertable">
                  
                  
                  
                  
                  
                  
                  
                  
              <tgroup cols="3"><thead><row><entry>Команда</entry><entry>Параметр (args)</entry><entry>Цель</entry></row></thead><tbody><row>
                      <entry><codeph>quit</codeph></entry>
                      <entry>Не задан</entry>
                      <entry>Закрывает проектор.</entry>
                  </row><row>
                      <entry><codeph>fullscreen</codeph></entry>
                      <entry><codeph>true</codeph> или <codeph>false</codeph></entry>
                      <entry>Установка значения <codeph>true</codeph> переводит проигрыватель Flash Player в полноэкранный режим работы. Установка значения <codeph>false</codeph>возвращает проигрыватель в обычный режим работы с отображением меню.</entry>
                  </row><row>
                      <entry><codeph>allowscale</codeph></entry> 
                      <entry><codeph>true</codeph> или <codeph>false</codeph></entry>
                      <entry>Установка значения <codeph>false</codeph> задает режим проигрывателя, в котором SWF-файл всегда воспроизводится в окне исходного размера и никогда не масштабируется. Установка значения <codeph>true</codeph> заставляет SWF-файл масштабироваться в проигрывателе до 100%.</entry>
                  </row><row>
                      <entry><codeph>showmenu</codeph></entry>
                      <entry><codeph>true</codeph> или <codeph>false</codeph></entry>
                      <entry>Установка значения <codeph>true</codeph> включает полный набор команд в контекстное меню. Установка значения <codeph>false</codeph> скрывает все команды контекстного меню, за исключением пунктов «О Flash Player» и «Параметры».</entry>
                  </row><row>
                      <entry><codeph>exec</codeph></entry>
                      <entry>Путь к приложению </entry>
                      <entry>Выполняет приложение из проектора.</entry>
                  </row><row>
                      <entry><codeph>trapallkeys</codeph></entry>
                      <entry><codeph>true</codeph> или <codeph>false</codeph></entry>
                      <entry>Установка значения <codeph>true</codeph> отправляет все связанные с клавишами события, включая клавиши быстрого вызова, обработчику <codeph>onClipEvent(keyDown/keyUp)</codeph> в проигрывателе Flash Player. </entry>
                  </row></tbody></tgroup></adobetable>
 <p>Не все из перечисленных в таблице команд доступны во всех приложениях. 
 <ul>
     <li>Ни одна из этих команд не доступна в веб-проигрывателях.</li> 
     <li>Все эти команды доступны в автономных приложениях, таких как проекторы.</li>
     <li>Только команды <codeph>allowscale</codeph> и <codeph>exec</codeph> доступны в проигрывателях тестовых роликов.</li>
 </ul>
 </p>
 
 <p>Команда <codeph>exec</codeph> может содержать только символы A-Z, a-z, 0-9, точку (.) и подчеркивание (_). Команда <codeph>exec</codeph> выполняется только в подкаталоге fscommand. Другими словами, если для вызова приложения используется команда <codeph>exec</codeph>, это приложение должно находиться в подкаталоге с названием fscommand. Команда <codeph>exec</codeph> работает только из файла проектора Adobe Flash.</p>
 
 <p>Применение 2: чтобы использовать функцию <codeph>fscommand()</codeph> для отправки сообщения с использованием языка сценариев, например JavaScript в web-браузере, можно передать любые два параметра с помощью параметров <codeph>command</codeph> и <codeph>args</codeph>. Эти параметры могут быть строками или выражениями, они используются в функции JavaScript, которая обрабатывает или <i>перехватывает</i> функцию <codeph>fscommand()</codeph>. </p>
 
 <p>В web-браузере функция <codeph>fscommand()</codeph> вызывает функцию JavaScript <codeph>moviename_DoFScommand</codeph>, которая находится на web-странице, содержащей SWF-файл. Для <codeph>moviename</codeph> укажите имя объекта Adobe Flash, используемого в качестве атрибута <codeph>NAME</codeph> для тега <codeph>EMBED</codeph> или свойства ID тега <codeph>OBJECT</codeph>. Если SWF-файлу назначается имя myMovie, вызывается функция JavaScript <codeph>myMovie_DoFScommand</codeph>. </p>
 
 <p>На web-странице, содержащей SWF-файл, установите атрибут <codeph>allowScriptAccess</codeph>, разрешив или запретив возможность доступа к web-странице из этого SWF-файла, как описано выше. (Этот атрибут устанавливается в коде HTML, встроенном в SWF-файл. Например, в тег <codeph>PARAM</codeph> для Internet Explorer или тег <codeph>EMBED</codeph> для Netscape.) </p>
 
 <p>В приложении Flash Player 10 и более поздней версии, запущенном в браузере, при использовании этого метода в программных средствах открытие всплывающего окна может не выполняться. Различные браузеры (и конфигурации браузеров) могут блокировать всплывающие окна в любое время; невозможно гарантировать, что какое-либо всплывающее окно будет отображаться. Однако для повышения вероятности открытия всплывающего окна используйте этот метод только в коде, который выполняется в качестве непосредственного результата действия пользователя (например, в обработчике событий для события щелчка мышью или нажатия клавиши).</p>
 
 <p>Применение 3: функция <codeph>fscommand()</codeph> может отправлять сообщения в программу Director (Adobe Macromedia Director). Эти сообщения интерпретируются в Lingo (языке сценариев, используемом в Director) как строки, события или выполняемый код Lingo. Если сообщение является строкой или событием, необходимо написать код Lingo для получения сообщения из функции <codeph>fscommand()</codeph> и выполнить это действие в Director. Дополнительные сведения см. в центре поддержки Director по адресу <xref href="http://www.adobe.com/support/director/" scope="external">www.adobe.com/support/director/</xref>.</p>
 
 <p>Применение 4: в VisualBasic, Visual C++ и других программах, в которых можно размещать управляющие элементы ActiveX, функция <codeph>fscommand()</codeph> отправляет событие VB с двумя строками, которые могут обрабатываться языком программирования, используемом в среде. Дополнительные сведения можно найти по ключевым словам «Flash method» в центре поддержки Adobe Flash по адресу <xref href="http://www.adobe.com/support/flash/" scope="external">www.adobe.com/support/flash/</xref>.</p>
 <p><b>Примечание.</b> Класс ExternalInterface обеспечивает лучшую функциональность для взаимодействия между JavaScript и ActionScript (применение 2), а также между ActionScript и VisualBasic, Visual C++ или другими программами, которые могут содержать управляющие элементы ActiveX (применение 4). Необходимо продолжать использовать функцию <codeph>fscommand()</codeph> для отправки сообщений в проигрыватель Flash Player (применение 1) и программу Director (применение 3).</p>
 
 </apiDesc><example conref="examples\FSCommandExample.as"> В следующем примере показано, как функция <codeph>fscommand()</codeph> может использоваться для перевода проигрывателя Flash Player в полноэкранный режим работы и разрешения масштабирования. Затем к рабочей области добавляется оранжевый прямоугольник с помощью метода<codeph>draw()</codeph>. В методе <codeph>draw()</codeph>, добавляется прослушиватель события <codeph>click</codeph> с именем <codeph>clickHandler()</codeph>, который реагирует на события <codeph>click</codeph>, вызывая завершение работы Flash Player с помощью другого обращения к функции <codeph>fscommand().</codeph>
 
 <p><b>Примечание. </b> Этот пример должен выполняться в автономном проигрывателе Flash Player, но не в web-браузере.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.system.fscommand;
    import flash.events.MouseEvent;

    public class FSCommandExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 100;

        public function FSCommandExample() {
            fscommand("fullscreen", "true");
            fscommand("allowscale", "false");
            draw();
        }

        private function clickHandler(event:MouseEvent):void {
            fscommand("quit");
            trace("clickHandler");
        }

        private function draw():void {
            var child:Sprite = new Sprite();
            child.graphics.beginFill(bgColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            child.buttonMode = true;
            addEventListener(MouseEvent.CLICK, clickHandler);

            var label:TextField = new TextField();
            label.text = "quit";
            label.selectable = false;
            label.mouseEnabled = false;
            child.addChild(label);

            addChild(child);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiClassifier id="flash.system:IME"><apiName>IME</apiName><shortdesc>
 Класс IME позволяет непосредственно управлять редактором методов ввода (IME) операционной системы в приложении Flash Player, работающем на клиентском компьютере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Позволяет непосредственно управлять редактором методов ввода (IME) операционной системы.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс IME позволяет непосредственно управлять редактором методов ввода (IME) операционной системы в приложении Flash Player, работающем на клиентском компьютере. Можно определить, был ли установлен редактор IME, был или нет этот IME включен в данный момент, а также какой редактор IME включен. Можно включить или выключить редактор IME в приложении Flash Player, а также выполнить другие ограниченные функции, зависящие от операционной системы.
 
 <p>Редакторы IME позволяют пользователям вводить тексты с символами, отличными от ASCII, используя многобайтовые языки, такие как китайский, японский и корейский. Дополнительные сведения о работе с редактором IME см. в документации по операционной системе, для которой разрабатывается приложение. Дополнительные ресурсы доступны на следующих web-сайтах:
 <ul>
   <li><xref href="http://www.microsoft.com/globaldev/default.mspx" scope="external">http://www.microsoft.com/globaldev/default.mspx</xref></li>
   <li><xref href="http://developer.apple.com/documentation/" scope="external">http://developer.apple.com/documentation/</xref></li>
   <li><xref href="http://java.sun.com" scope="external">http://java.sun.com</xref></li>
  </ul>
  </p>
 
 <p>Если редактор IME не активен на компьютере пользователя, то обращения к методам или свойствам IME, отличным от <codeph>Capabilities.hasIME</codeph>, будут завершаться ошибками. Как только редактор IME будет активирован вручную, последующие обращения ActionScript к методам и свойствам IME будут срабатывать ожидаемым образом. Например, если используется японский редактор IME, он должен быть активирован до того, как вызывается любой метод или свойство IME.</p>
 
 <p>В следующей таблице показаны платформы, поддерживаемые данным классом:</p>
 
 
 <adobetable class="innertable">
  
 
 
 
  
  
 
  
  
 
 <tgroup cols="4"><thead><row><entry>Возможность</entry><entry>Windows</entry><entry>Mac OSX</entry><entry>Linux</entry></row></thead><tbody><row>
    <entry>Определяет, установлен ли редактор IME: <codeph>Capabilities.hasIME</codeph></entry>
    <entry>Да</entry>
    <entry>Да</entry>
    <entry>Да</entry>
  </row><row>
    <entry>Переключает редактор IME в активное или неактивное состояние: <codeph>IME.enabled</codeph></entry>
    <entry>Да</entry>
    <entry>Да</entry>
    <entry>Да</entry>
  </row><row>
    <entry>Определяет, активен ли редактор IME или нет: <codeph>IME.enabled</codeph></entry>
    <entry>Да</entry>
    <entry>Да</entry>
    <entry>Да</entry>
  </row><row>
    <entry>Получает или устанавливает режим преобразования IME: <codeph>IME.conversionMode</codeph></entry>
    <entry>Да</entry>
    <entry>Да ~~~~</entry>
    <entry>Нет</entry>
  </row><row>
    <entry>Посылает редактору IME строку для преобразования: <codeph>IME.setCompositionString()</codeph></entry>
    <entry>Да ~~</entry>
    <entry>Нет</entry>
    <entry>Нет</entry>
  </row><row>
    <entry>Получает из редактора IME исходную строку до преобразования: <codeph>System.ime.addEventListener()</codeph></entry>
    <entry>Да ~~</entry>
    <entry>Нет</entry>
    <entry>Нет</entry>
  </row><row>
    <entry>Отправляет запрос на преобразование в редактор IME: <codeph>IME.doConversion()</codeph></entry>
    <entry>Да ~~</entry>
    <entry>Нет</entry>
    <entry>Нет</entry>
  </row></tbody></tgroup></adobetable>
 
 <p>~~ Не все редакторы IME в Windows поддерживают эти операции в полном объеме. Единственный редактор IME, который поддерживает их все, это японский редактор IME.</p>
 
 <p>~~~~ На платформе Macintosh только японский редактор IME поддерживает эти методы, а редакторы IME независимых поставщиков не поддерживают их.</p>
 <p>Версия этого класса в ActionScript 3.0 не поддерживает Macintosh Classic.</p>
 
 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.system:IME_flash.events.IMEEvent.IME_COMPOSITION_imeComposition"><apiName>imeComposition</apiName><shortdesc>
 Отправляется, когда пользователь завершил работу в редакторе методов ввода (IME), и доступна строка чтения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IMEEvent.IME_COMPOSITION</apiEventType><adobeApiEventClassifier>flash.events.IMEEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется, когда пользователь завершил работу в редакторе методов ввода (IME), и доступна строка чтения. Обычно редакторы IME применяются для ввода текста на языках, в которых используются иероглифы, а не буквы. Это такие языки как японский, корейский и китайский.
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.system:IME:compositionAbandoned"><apiName>compositionAbandoned</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="flash.system:IME:compositionSelectionChanged"><apiName>compositionSelectionChanged</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>start</apiItemName><apiOperationClassifier>int</apiOperationClassifier></apiParam><apiParam><apiItemName>end</apiItemName><apiOperationClassifier>int</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="flash.system:IME:doConversion"><apiName>doConversion</apiName><shortdesc>
	 Предписывает IME выбрать первого кандидата для текущей строки композиции.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Вызов завершился с ошибкой.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Предписывает IME выбрать первого кандидата для текущей строки композиции.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:IME:setCompositionString"><apiName>setCompositionString</apiName><shortdesc>
	 Задает строку композиции IME.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need some examples of valid values for the param composition.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Неудачный вызов.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>composition</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка для отправки редактору IME.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает строку композиции IME. Если строка задана, пользователь может выбирать варианты в редакторе IME перед тем, как отправить результаты в активное текстовое поле.
	 <p>Если нет активного текстового поля, этот метод завершается с ошибкой.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.system:IME:conversionMode:get"><apiName>conversionMode</apiName><shortdesc>
	 Режим преобразования текущего IME.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Попытка установки завершилась неудачно.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Режим преобразования текущего IME. Возможными значениями являются строковые константы режима IME, указывающие режим преобразования:
	 <ul>
	 	<li><codeph>ALPHANUMERIC_FULL</codeph></li>
	 	<li><codeph>ALPHANUMERIC_HALF</codeph></li>
 	 	<li><codeph>CHINESE</codeph></li>
	 	<li><codeph>JAPANESE_HIRAGANA</codeph></li>
	 	<li><codeph>JAPANESE_KATAKANA_FULL</codeph></li>
	 	<li><codeph>JAPANESE_KATAKANA_HALF</codeph></li>
 	 	<li><codeph>KOREAN</codeph></li>
	  <li><codeph>UNKNOWN</codeph> (значение доступно только для чтения; не может быть установлено вручную)</li>
	 </ul>
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IMEConversionMode/ALPHANUMERIC_FULL"><linktext>flash.system.IMEConversionMode.ALPHANUMERIC_FULL</linktext></link><link href="flash.system.xml#IMEConversionMode/ALPHANUMERIC_HALF"><linktext>flash.system.IMEConversionMode.ALPHANUMERIC_HALF</linktext></link><link href="flash.system.xml#IMEConversionMode/CHINESE"><linktext>flash.system.IMEConversionMode.CHINESE</linktext></link><link href="flash.system.xml#IMEConversionMode/JAPANESE_HIRAGANA"><linktext>flash.system.IMEConversionMode.JAPANESE_HIRAGANA</linktext></link><link href="flash.system.xml#IMEConversionMode/JAPANESE_KATAKANA_FULL"><linktext>flash.system.IMEConversionMode.JAPANESE_KATAKANA_FULL</linktext></link><link href="flash.system.xml#IMEConversionMode/JAPANESE_KATAKANA_HALF"><linktext>flash.system.IMEConversionMode.JAPANESE_KATAKANA_HALF</linktext></link><link href="flash.system.xml#IMEConversionMode/KOREAN"><linktext>flash.system.IMEConversionMode.KOREAN</linktext></link><link href="flash.system.xml#IMEConversionMode/UNKNOWN"><linktext>flash.system.IMEConversionMode.UNKNOWN</linktext></link></related-links></apiValue><apiValue id="flash.system:IME:enabled:get"><apiName>enabled</apiName><shortdesc>
	 Указывает, включен ли системный редактор IME (значение true) или выключен (значение false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>Попытка установки завершилась неудачно.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Указывает, включен ли системный редактор IME (значение <codeph>true</codeph>) или выключен (значение <codeph>false</codeph>). Если редактор IME включен, можно выполнять ввод в многобайтовой кодировке; а если выключен – только буквенно-символьный ввод. 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.system:System"><apiName>System</apiName><shortdesc>
 Класс System содержит свойства, связанные с определенными действиями, происходящими на компьютере пользователя, например операциями с общими объектами, локальными параметрами для камер и микрофонов, а также связанные с использованием буфера обмена.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>System, System object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс System содержит свойства, связанные с определенными действиями, происходящими на компьютере пользователя, например <ph platform="actionscript">операциями с общими объектами, локальными параметрами для камер и микрофонов, а</ph> также связанные с использованием буфера обмена.
 
 <p>Дополнительные свойства и методы находятся в других классах пакета flash.system: класс Capabilities, <ph platform="actionscript">класс IME</ph> и класс Security.</p>
 
 <p>Этот класс содержит только статические методы и свойства. Невозможно создать новые экземпляры класса System.</p>
 
 </apiDesc><example conref="examples\SystemExample.as"> В следующем примере показано, как информация об общем объеме памяти системы копируется в буфер обмена системы путем обращения к <codeph>System.totalMemory</codeph> при вызове метода <codeph>System.setClipboard()</codeph>.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.system.System;

    public class SystemExample extends Sprite {
        public function SystemExample() {
            System.setClipboard("System.totalMemory: " + System.totalMemory);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.system.xml#Security"><linktext>flash.system.Security</linktext></link><link href="flash.events.xml#IMEEvent"><linktext>flash.events.IMEEvent</linktext></link></related-links><apiOperation id="flash.system:System:disposeXML"><apiName>disposeXML</apiName><shortdesc>
	 Объект XML сразу же становится доступным для сборки мусора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>node</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>Ссылка XML, которую необходимо сделать доступной для сборки мусора.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Объект XML сразу же становится доступным для сборки мусора. С помощью этого метода удаляются вышестоящие и нижестоящие соединения всех узлов указанного узла XML.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:System:exit"><apiName>exit</apiName><shortdesc> 
     Закрывает проигрыватель Flash Player.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata><asCustoms><keyword>System, System.exit(), exit()             
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Значение, передаваемое в операционную систему. Обычно, если процесс нормально завершается, это значение равно 0.
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc> 
     Закрывает проигрыватель Flash Player.
	 
     <p><i>Только для отладочной версии проигрывателя Flash Player.</i></p> 
	 
     <p>Чтобы выйти из приложения, приложения AIR должны вызвать метод <codeph>NativeApplication.exit()</codeph>.</p> 
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#NativeApplication/exit()"><linktext>flash.desktop.NativeApplication.exit()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:System:gc"><apiName>gc</apiName><shortdesc>
     Запускает процесс очистки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     Запускает процесс очистки.
	 
     <p><ph platform="actionscript"> <i>Только для отладочной версии Flash Player и приложений AIR. </i> </ph> В приложении AIR метод <codeph>System.gc()</codeph> работает только в содержимом, выполняющемся в AIR Debug Launcher (ADL), или, в случае с установленным приложением, в содержимом в изолированной программной среде безопасности приложения.</p>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.system:System:pause"><apiName>pause</apiName><shortdesc> 
     Устанавливает паузу в работе Flash Player или AIR Debug Launcher (ADL).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata><asCustoms><keyword>System, System.pause(), pause()   
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
     Устанавливает паузу в работе <ph platform="actionscript">Flash Player или</ph> AIR Debug Launcher (ADL). После вызова этого метода все операции приложения прекращаются, за исключением доставки событий Socket.
	 
     <p platform="actionscript"><i>Только для отладочной версии Flash Player или AIR Debug Launcher (ADL).</i></p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#System/resume()"><linktext>resume()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:System:resume"><apiName>resume</apiName><shortdesc> 
     Возобновляет работу приложения после вызова метода System.pause().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata><asCustoms><keyword>System, System.resume(), resume()        
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
     Возобновляет работу приложения после вызова метода <codeph>System.pause()</codeph>.
	 
     <p platform="actionscript"><i>Только для отладочной версии Flash Player или AIR Debug Launcher (ADL).</i></p>  
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.system.xml#System/pause()"><linktext>pause()</linktext></link></related-links></apiOperation><apiOperation id="flash.system:System:setClipboard"><apiName>setClipboard</apiName><shortdesc>
	 Заменяет содержимое буфера обмена заданной текстовой строкой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>System.setClipboard, setClipboard
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>string</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Состоящая из символов строка с обычным текстом для размещения в буфере обмена системы, замещая текущее содержимое (если есть).
	 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Заменяет содержимое буфера обмена заданной текстовой строкой.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Заменяет содержимое буфера обмена заданной текстовой строкой. Этот метод работает в любом контексте безопасности, если вызывается в результате пользовательского события (например, обработчика события клавиатуры или мыши).
	 
	 <p>Этот метод доступен для SWF-содержимого, выполняемого в Flash Player 9. Он позволяет добавлять в буфер обмена только содержимое типа String. Содержимое Flash Player 10 и содержимое в изолированной программной среде безопасности приложения AIR может вызывать метод <codeph>Clipboard.setData()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.desktop.xml#Clipboard"><linktext>flash.desktop.Clipboard</linktext></link></related-links></apiOperation><apiValue id="flash.system:System:ime:get"><apiName>ime</apiName><shortdesc>
	 Текущая установленная система IME.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:IME</apiValueClassifier></apiValueDef><apiDesc>
	 Текущая установленная система IME. Чтобы подписаться на события imeComposition, вызовите <codeph>addEventListener()</codeph> для этого экземпляра.
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#IMEConversionMode"><linktext>IMEConversionMode</linktext></link></related-links></apiValue><apiValue id="flash.system:System:totalMemory:get"><apiName>totalMemory</apiName><shortdesc>
     Объем памяти (в байтах), используемый в данный момент приложением Adobe&amp;#xAE; Flash&amp;#xAE; Player или Adobe&amp;#xAE; AIR&amp;#xAE;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Add better description and example, unless private, in which case mark as "at"private.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Объем памяти (в байтах), используемый в данный момент приложением <ph platform="actionscript"> Adobe<sup>®</sup> Flash<sup>®</sup> Player или </ph>Adobe<sup>®</sup> AIR<sup>®</sup>.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.system:System:useCodePage:get"><apiName>useCodePage</apiName><shortdesc>
	 Значение типа Boolean, указывающее кодовую страницу, которую следует использовать для интерпретации внешних текстовых файлов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>System.useCodepage, useCodepage, Unicode, code page
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Значение типа Boolean, указывающее кодовую страницу, которую следует использовать для интерпретации внешних текстовых файлов. Если это свойство имеет значение <codeph>false</codeph>, при интерпретации внешних текстовых файлов используется кодировка Юникод. (Эти файлы должны быть в кодировке Юникод при сохранении.) Если для этого свойства задано значение <codeph>true</codeph>, внешние текстовые файлы интерпретируются с помощью стандартной кодовой страницы операционной системы, в которой выполняется приложение. По умолчанию для свойства <codeph>useCodePage</codeph> задано значение <codeph>false</codeph>.
	 
	 <p>Текст, загружаемый как внешний файл (с помощью <codeph>Loader.load()</codeph>, класса URLLoader или класса URLStream), должен быть сохранен в кодировке Юникод, чтобы приложение правильно распознало его. Чтобы изменить кодировку внешних файлов на Юникод, сохраните их в приложении, поддерживающем эту кодировку, например с помощью программы блокнот в Windows.</p>
	 
	 <p>При загрузке внешних текстовых файлов, кодировка которых не Юникод, установите для свойства <codeph>useCodePage</codeph> значение <codeph>true</codeph>. Добавьте в программный код следующую первую строку к <ph product="flash">первому кадру</ph> файла, загружающего данные:</p>
	 
	 <pre><codeph>System.useCodePage = true;</codeph></pre>
	 
	 <p>Если имеется эта кодировка, приложение интерпретирует внешний текст с помощью стандартной кодовой страницы операционной системы. Обычно это кодировка CP1252 для английской версии операционной системы Windows и Shift-JIS для японской операционной системы. <ph platform="actionscript">Если для свойства <codeph>useCodePage</codeph> установить значение <codeph>true</codeph>, в проигрывателе Flash Player 6 и более поздних версиях обрабатывают текст также, как проигрыватель Flash Player 5. (Проигрыватель Flash Player 5 обрабатывает все тексты таким образом, как если бы они все были в стандартной кодировке операционной системы, в которой запущен проигрыватель.)</ph></p>
	 
	 <p>Если для свойства <codeph>useCodePage</codeph> установлено значение <codeph>true</codeph>, помните, что стандартная кодовая страница операционной системы, в которой выполняется приложение, должна включать символы, используемые во внешнем текстовом файле, чтобы можно было отобразить данный текст. Например, если загружается внешний текстовый файл, содержащий китайские символы, эти символы невозможно отобразить в системе, где используется кодовая страница CP1252, поскольку она не содержит символов для китайского языка.</p>
	 
	 <p>Чтобы обеспечить пользователям на всех платформах возможность просматривать внешние текстовые файлы, используемые в вашем приложении, необходимо использовать в этих текстовых файлах кодировку Юникод и оставить для свойства <codeph>useCodePage</codeph> значение <codeph>false</codeph>. Именно поэтому приложение <ph platform="actionscript">(Flash Player 6 и более поздних версий)</ph> интерпретирует текст как Юникод.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.system:SecurityDomain"><apiName>SecurityDomain</apiName><shortdesc>
	Класс SecurityDomain представляет текущую изолированную программную среду, безопасности, также называемую доменом защиты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Класс SecurityDomain представляет текущую изолированную программную среду, безопасности, также называемую доменом защиты. Передавая экземпляр этого класса в <codeph>Loader.load()</codeph>, можно запросить размещение загруженных мультимедийных данных в определенной изолированной среде.
	</apiDesc></apiClassifierDetail><apiValue id="flash.system:SecurityDomain:currentDomain:get"><apiName>currentDomain</apiName><shortdesc>
		Определяет текущий домен защиты.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:SecurityDomain</apiValueClassifier></apiValueDef><apiDesc>
		Определяет текущий домен защиты. 
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#Loader/loadBytes()"><linktext>flash.display.Loader.loadBytes()</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links></apiValue></apiClassifier></apiPackage>