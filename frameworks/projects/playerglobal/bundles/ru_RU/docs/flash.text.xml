<?xml version="1.0"?>
<apiPackage id="flash.text"><apiName>flash.text</apiName><apiDetail/><apiClassifier id="flash.text:TextExtent"><apiName>TextExtent</apiName><shortdesc>
 Класс TextExtent содержит информацию о размере текста в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextExtent содержит информацию о размере текста в текстовом поле. Объекты этого класса возвращаются методом <codeph>TextFormat.getTextExtent</codeph>.
 </apiDesc></apiClassifierDetail><apiConstructor id="flash.text:TextExtent:TextExtent"><apiName>TextExtent</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>textFieldHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextExtent:ascent"><apiName>ascent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:descent"><apiName>descent</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:height"><apiName>height</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldHeight"><apiName>textFieldHeight</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:textFieldWidth"><apiName>textFieldWidth</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue><apiValue id="flash.text:TextExtent:width"><apiName>width</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
	 Класс CSMSettings содержит свойства для применения с методом TextRenderer.setAdvancedAntiAliasingTable(), позволяющие обеспечить непрерывную модуляцию линий (CSM).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Not functioning correctly. Bug report 193833
	 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс CSMSettings содержит свойства для применения с методом <codeph>TextRenderer.setAdvancedAntiAliasingTable()</codeph>, позволяющие обеспечить непрерывную модуляцию линий (CSM). CSM включает непрерывную модуляцию веса линии и четкости краев.
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links><apiConstructor id="flash.text:CSMSettings:CSMSettings"><apiName>CSMSettings</apiName><shortdesc>
     Создает объект CSMSettings, в котором хранятся значения линий для пользовательских параметров сглаживания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>fontSize</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Размер в пикселах, для которого применяются параметры.
	 </apiDesc></apiParam><apiParam><apiItemName>insideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Значение внутренней отсечки, при превышении которого плотности присваивается максимальное значение (например, 255).
	 </apiDesc></apiParam><apiParam><apiItemName>outsideCutoff</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Значение внешней отсечки, ниже которого плотности присваивается значение 0.
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     Создает объект CSMSettings, в котором хранятся значения линий для пользовательских параметров сглаживания. 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.text:CSMSettings:fontSize"><apiName>fontSize</apiName><shortdesc>
		 Размер в пикселях, для которого применяются параметры.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Размер в пикселах, для которого применяются параметры.
		 
		 <p>Массив <codeph>advancedAntiAliasingTable</codeph>, передаваемый методу <codeph>setAdvancedAntiAliasingTable()</codeph>, может содержать несколько записей, задающих параметры CSM для разных размеров шрифта. С помощью этого свойства можно задавать размер шрифта, к которому применяются другие параметры.
		 </p>
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:insideCutoff"><apiName>insideCutoff</apiName><shortdesc>
		 Значение внутренней отсечки, при превышении которого плотности присваивается максимальное значение (например, 255).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Значение внутренней отсечки, при превышении которого плотности присваивается максимальное значение (например, 255).
         
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:CSMSettings:outsideCutoff"><apiName>outsideCutoff</apiName><shortdesc>
		 Значение внешней отсечки, ниже которого плотности присваивается значение 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 Значение внешней отсечки, ниже которого плотности присваивается значение 0.
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextColorType"><apiName>TextColorType</apiName><shortdesc>
Класс TextColorType обеспечивает значения цвета для класса flash.text.TextRenderer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс TextColorType обеспечивает значения цвета для класса flash.text.TextRenderer.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:TextColorType:DARK_COLOR"><apiName>DARK_COLOR</apiName><shortdesc>
    Используется параметром colorType метода setAdvancedAntiAliasingTable().</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dark</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Используется параметром <codeph>colorType</codeph> метода <codeph>setAdvancedAntiAliasingTable()</codeph>. Используйте синтаксис <codeph>TextColorType.DARK_COLOR</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextColorType:LIGHT_COLOR"><apiName>LIGHT_COLOR</apiName><shortdesc>
    Используется параметром colorType метода setAdvancedAntiAliasingTable().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>light</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Используется параметром <codeph>colorType</codeph> метода <codeph>setAdvancedAntiAliasingTable()</codeph>. Используйте синтаксис <codeph>TextColorType.LIGHT_COLOR</codeph>.	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:GridFitType"><apiName>GridFitType</apiName><shortdesc>
Класс GridFitType определяет значения для хинтования (подгонки к сетке) в классе TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс GridFitType определяет значения для хинтования (подгонки к сетке) в классе TextField.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:GridFitType:NONE"><apiName>NONE</apiName><shortdesc> 
	Не задавайте подгонку к сетке.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Не задавайте подгонку к сетке. Горизонтальные и вертикальные линии в глифах не подгоняются к пиксельной сетке. С помощью этой константы задается свойство <codeph>gridFitType</codeph> класса TextField. Как правило, этот параметр хорош для анимации и крупного шрифта. Используйте синтаксис <codeph>GridFitType.NONE</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:PIXEL"><apiName>PIXEL</apiName><shortdesc>
	Подгоняет жирные горизонтальные и вертикальные линии к пиксельной сетке.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Подгоняет жирные горизонтальные и вертикальные линии к пиксельной сетке. С помощью этой константы задается свойство <codeph>gridFitType</codeph> класса TextField. Этот параметр применяется только к текстовым полям с выравниванием по левому краю. Она имеет то же действие, что и константа <codeph>GridFitType.SUBPIXEL</codeph> в статическом тексте. Этот параметр, как правило, дает максимальную четкость для текста с выравниванием по левому краю. Используйте синтаксис <codeph>GridFitType.PIXEL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue><apiValue id="flash.text:GridFitType:SUBPIXEL"><apiName>SUBPIXEL</apiName><shortdesc>
	Подгоняет жирно горизонтальные и вертикальные линии к подпиксельной сетке на ЖК-мониторах.</shortdesc><prolog><author>Bob Pappas
	
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subpixel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Подгоняет жирно горизонтальные и вертикальные линии к подпиксельной сетке на ЖК-мониторах. (Красный, зеленый и синий являются фактическими пикселями на ЖК-экране.) Эту установку рекомендуется использовать для динамического текста с выравниванием по правому краю или по центру, а в некоторых случаях она позволяет найти оптимальный баланс качества анимации и качества текста. С помощью этой константы задается свойство <codeph>gridFitType</codeph> класса TextField. Используйте синтаксис <codeph>GridFitType.SUBPIXEL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/gridFitType"><linktext>flash.text.TextField.gridFitType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StaticText"><apiName>StaticText</apiName><shortdesc>
 Этот класс представляет объекты StaticText в списке отображения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Этот класс представляет объекты StaticText в списке отображения. Объект StaticText нельзя создать с помощью ActionScript. Создать объект StaticText можно только в инструменте разработке. При попытке создать новый объект StaticText выдается ошибка <codeph>ArgumentError</codeph>.
 
 <p>Чтобы создать ссылку на существующее статическое текстовое поле в ActionScript 3.0, можно повторять операцию для всех элементов списка отображения. Например, следующий фрагмент кода проверяет, содержит ли список отображения статическое текстовое поле и назначает его переменной.</p>
 
 <codeblock>
 var i:uint;
 for (i = 0; i &lt; this.numChildren; i++) {
     var displayitem:DisplayObject = this.getChildAt(i);
     if (displayitem instanceof StaticText) {
         trace("a static text field is item " + i + " on the display list");
         var myFieldLabel:StaticText = StaticText(displayitem);
         trace("and contains the text: " + myFieldLabel.text);
     }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><apiValue id="flash.text:StaticText:text:get"><apiName>text</apiName><shortdesc>
     Возвращает текущий текст статического текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     Возвращает текущий текст статического текстового поля. Инструмент разработки может экспортировать несколько объектов текстового поля, составляющих полный текст. Например, для вертикального текста инструмент разработки создаст по одному текстовому полю для каждого символа.
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextField"><apiName>TextField</apiName><shortdesc>
 Класс TextField используется для создания экранных объектов для отображения и ввода текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Класс TextField используется для создания экранных объектов для отображения и ввода текста.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextField используется для создания экранных объектов для отображения и ввода текста. Все динамические текстовые поля и поля ввода в SWF-файле являются экземплярами класса TextField. <ph outputclass="flexonly"> Класс TextField можно использовать для выполнения визуализации текста на низком уровне. Однако в Flex для обработки текста обычно используются элементы управления Label, Text, TextArea и TextInput. </ph> <ph outputclass="flashonly">Текстовому полю можно присвоить имя экземпляра в инспекторе свойств и использовать методы и свойства класса TextField для управления им с помощью ActionScript. Имена экземпляров TextField отображаются в обозревателе ролика Movie Explorer и в диалоговом окне «Целевой путь« на панели «Действия».</ph>
 
 <p>Для динамического создания текстового поля используется конструктор метода <codeph>TextField()</codeph>.</p>
 
 <p>Методы класса TextField позволяют задавать, выделять текст и выполнять манипуляции с ним в динамическом текстовом поле или поле ввода, создаваемом при разработке программы или при исполнении. </p>
 
 <p>ActionScript предусматривает несколько способов форматирования текста при исполнении. Класс TextFormat позволяет задавать форматирование символов и абзацев для объектов TextField. К текстовым полям можно применять стили CSS с помощью свойства <codeph>TextField.styleSheet</codeph> и класса StyleSheet. Можно использовать CSS для изменения стиля встроенных тегов HTML, определения новых тегов форматирования или применения стилей. Текстовому полю можно напрямую назначить текст с форматированием HTML, который также может использовать стили CSS. HTML-текст, назначаемый текстовому полю, может содержать встроенное мультимедийное содержимое (фрагменты роликов, SWF-файлы, GIF-файлы, PNG-файлы и JPEG-файлы). Текст «обтекает» встроенное в него мультимедийное содержимое так же, как в документе HTML в обозревателе. </p>
 
 <p>Проигрыватель Flash Player поддерживает подгруппу тегов HTML, которые можно использовать для форматирования текста. См. список поддерживаемых тегов HTML в описании свойства <xref href="flasht/text/TextField#htmlText">htmlText</xref>.</p>
 
 </apiDesc><example conref="examples\TextFieldExample.as"> В следующем примере класс <codeph>TextFieldExample</codeph> используется для отображения текстового сообщения. Для этого выполняются следующие действия.
 <ol>
  <li>Создается свойство <codeph>label</codeph> типа TextField.</li>
  <li>Конструктор класса вызывает функцию <codeph>configureLabel()</codeph>.</li>
  <li> Метод <codeph>configureLabel()</codeph> сначала создает новый объект TextField и назначает его свойству <codeph>label</codeph>, а затем задает для него следующие параметры:
  <ul>
      <li>Полная выключка текстового поля по левому краю.</li>
      <li>Включить заливку фона.</li>
      <li>Включить рамку</li>
  </ul>
  </li>
  <li>Метод <codeph>configureLabel()</codeph> создает переменную <codeph>format</codeph> и назначает ее новому экземпляру TextFormat, задав следующие параметры:
  <ul>
      <li>Font type = Verdana</li>
      <li>Font color = solid red</li>
      <li>Font size = 10</li>
      <li>Font underline = true</li>
  </ul>
  </li>
  <li>Свойство <codeph>defaultTextFormat</codeph> текстового поля <codeph>label</codeph> получает значение <codeph>format</codeph>, и экземпляр <codeph>label</codeph> добавляется в список отображения, который сначала показывает на монтажном столе текстовое поле без текста.</li>
 
  <li>Конструктор задает для текстового поля <codeph>label</codeph> текст <codeph>Hello world and welcome to the show. </codeph> (Здравствуйте все и добро пожаловать на представление), вызвав метод <codeph>setLabel()</codeph>.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFieldExample extends Sprite {
        private var label:TextField;
        private var labelText:String = "Hello world and welcome to the show.";

        public function TextFieldExample() {
            configureLabel();
            setLabel(labelText);
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 Flash Player отправляет событие textInput, когда пользователь вводит один или несколько символов текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Flash Player отправляет событие <codeph>textInput</codeph>, когда пользователь вводит один или несколько символов текста. Это событие может генерироваться различными методами ввода текста, включая стандартную клавиатуру, редакторы ввода текста (IME), системы распознавания голоса и речи и даже просто вставкой обычного текста без форматирования или информации о стилях.
 </apiDesc><example conref="examples\TextField_textInput.as"> В следующем примере определяются два объекта TextField: первый объект является полем ввода, а второй — динамическим текстовым полем. При вводе символом в первое поле отправляется событие <codeph>textInput</codeph>, вызывается обработчик <codeph>textInputHandler()</codeph>, и символы отображаются во втором текстовом поле. При вставке блока текста в поле ввода, обработчик события копирует весь блок во второе поле.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextInputExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();

        public function TextInputExample()
        {
            myTextBox1.type = TextFieldType.INPUT;
            myTextBox1.width = 200;
            myTextBox1.height = 20;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(TextEvent.TEXT_INPUT,textInputHandler);
        }

        public function textInputHandler(event:TextEvent):void
        {
           myTextBox2.text=event.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.SCROLL_scroll"><apiName>scroll</apiName><shortdesc>
 Отправляется объектом TextField, когда пользователь выполняет прокрутку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SCROLL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется объектом <i>TextField</i>, когда пользователь выполняет прокрутку. 
 </apiDesc><example conref="examples\TextField_scroll.as"> В следующем примере определяются два объекта TextField. С первым объектом TextField связано два обработчика событий. При щелчке мыши внутри первого текстового поля отправляется событие <codeph>mouseDown</codeph> и вызывается связанный с ним обработчик <codeph>mouseDownScroll</codeph>. Обработчик <codeph>mouseDownScroll()</codeph> инициирует прокручивание поля. Затем отправляется событие <codeph>scroll</codeph>, и связанный обработчик <codeph>scrollHandler()</codeph> обновляет второе текстовое поле, так чтобы в нем отображалась текущее положение прокрутки.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.*;
    import flash.events.Event;
    import flash.events.TextEvent;
    import flash.events.MouseEvent;

    public class TextScrollExample extends Sprite
    {
        private var myTextBox1:TextField = new TextField();
        private var myTextBox2:TextField = new TextField();
        private var myText:String = "Hello world and welcome to the show. It's really nice to meet you. Take your coat off and stay a while. OK, show is over. Hope you had fun. You can go home now. Don't forget to tip your waiter. There are mints in the bowl by the door. Thank you. Please come again.";

        public function TextScrollExample()
        {
            myTextBox1.text = myText;
            myTextBox1.width = 200;
            myTextBox1.height = 50;
            myTextBox1.multiline = true;
            myTextBox1.wordWrap = true;
            myTextBox1.background = true;
            myTextBox1.border = true;
            
            myTextBox2.x=220;
            myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;

            addChild(myTextBox1);
            addChild(myTextBox2);
            myTextBox1.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownScroll);
            myTextBox1.addEventListener(Event.SCROLL, scrollHandler);
        }

        public function mouseDownScroll(event:MouseEvent):void
        {
            myTextBox1.scrollV++;
        }
        public function scrollHandler(event:Event):void
        {
           myTextBox2.text="scrolled to line: " + myTextBox1.scrollV;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.TextEvent.LINK_link"><apiName>link</apiName><shortdesc>
 Передается, когда пользователь щелкает в текстовом поле с поддержкой HTML гиперссылку, в которой URL-адрес начинается с event:.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.LINK</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Передается, когда пользователь щелкает в текстовом поле с поддержкой HTML гиперссылку, в которой URL-адрес начинается с event:. Часть URL-адреса после event: помещается в свойство text события LINK.
 <p><b>Примечание.</b> Поведение по умолчанию (добавление текста в текстовое поле) происходит только тогда, когда проигрыватель Flash Player генерирует событие, что в данном случае имеет место, когда пользователь пытается ввести текст. Нельзя ввести текст в текстовое поле, отправляя ему события <codeph>textInput</codeph>.</p>
 </apiDesc><example conref="examples\TextField_event_link.as"> В следующем примере определяется функция <codeph>playMP3()</codeph>. Создается объект TextField с именем <codeph>list</codeph>, который заполняется HTML-текстом. Текст <codeph>Track 1</codeph> (Трек 1) и <codeph>Track 2</codeph> являются ссылками внутри текстового поля. Когда пользователь щелкает любую из ссылок, вызывается функция playMP3(). Имя файла MP3, которое идет после строки event: в атрибуте <codeph>href</codeph> тега HTML, передается методу <codeph>linkHandler()</codeph> в качестве свойства <codeph>text</codeph> объекта события <codeph>link</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.errors.IOError;
    import flash.events.IOErrorEvent;
    import flash.events.TextEvent;
    import flash.media.Sound;
    import flash.media.SoundChannel;
    import flash.net.URLRequest;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_event_link extends Sprite
    {
        private var myMP3:Sound;
        public function TextField_event_link() {
            myMP3 = new Sound();
            var list:TextField = new TextField();
            list.autoSize = TextFieldAutoSize.LEFT;
            list.multiline = true;
            list.htmlText = "&lt;a href=\"event:track1.mp3\">Track 1&lt;/a>&lt;br>";
            list.htmlText += "&lt;a href=\"event:track2.mp3\">Track 2&lt;/a>&lt;br>";
            addEventListener(TextEvent.LINK, linkHandler);
            addChild(list);
        }
        
        private function playMP3(mp3:String):void {
            try {    
                myMP3.load(new URLRequest(mp3));
                myMP3.play();
            }
            catch(err:Error) {
                trace(err.message);
            }
            myMP3.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
        }
        
        private function linkHandler(linkEvent:TextEvent):void {
            playMP3(linkEvent.text);
        }
        
        private function errorHandler(errorEvent:IOErrorEvent):void {
            trace(errorEvent.text);
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.text:TextField_flash.events.Event.CHANGE_change"><apiName>change</apiName><shortdesc>
 Отправляется после изменения значения элемента управления, в отличие от события textInput, которое отправляется перед изменением значения.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Отправляется после изменения значения элемента управления, в отличие от события <codeph>textInput</codeph>, которое отправляется перед изменением значения. В отличие от события <codeph>change</codeph> версии W3C DOM Event Model, которое отправляет событие только после перехода фокуса с элемента управления, событие <codeph>change</codeph> версии ActionScript 3.0 отправляется при каждом изменении элемента управления. Например, если пользователь вводит текст в текстовое поле, то событие <codeph>change</codeph> отправляется после каждого нажатия клавиши.
 </apiDesc><example conref="examples\TextField_Event_changeExample.as"> В следующем примере вводимый пользователем текст (пользовательский ввод)) немедленно копируется в другое текстовое поле с другим форматом. 
 
 <p>Создается два текстовых поля: одно для пользовательского ввода, а другое (<codeph>headingTextField</codeph>) для его копии. Также создается объект TextFormat, и текстовому полю <codeph>headingTextField</codeph> назначается формат текста по умолчанию. При изменении содержимого текстового поля вызывается метод <codeph>changeHandler()</codeph>, который назначает текст в поле<codeph>inputTextField</codeph> текстовому полю<codeph>headingTextField</codeph>. (Если метод был вызван для события <codeph>TextEvent.TEXT_INPUT</codeph>, а не для события <codeph>Event.CHANGE</codeph>, содержимое пользовательского ввода копируется только после того, как пользователь введет больше текста.)</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;
    import flash.events.Event;
    
    import flash.events.TextEvent;

    public class TextField_Event_changeExample extends Sprite {
        private var inputTextField:TextField = new TextField(); 
        private var headingTextField:TextField = new TextField(); 
        private var newFormat:TextFormat = new TextFormat();
         
        public function TextField_Event_changeExample() {
            headingTextField.x = 10;
            headingTextField.y = 10;
            headingTextField.height = 30;
            headingTextField.width = 400;
            headingTextField.background = true;
            headingTextField.backgroundColor = 0xF5F5DC;
            headingTextField.selectable = false;
 
            inputTextField.x = 10;
            inputTextField.y = 70;
            inputTextField.height = 20;
            inputTextField.width = 230;
            inputTextField.background = true;
            inputTextField.border = true;
            inputTextField.maxChars = 40;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            inputTextField.addEventListener(Event.CHANGE, changeHandler);

            newFormat.bold = true;
            newFormat.size = 18;
            newFormat.color = 0xFF0000;
            newFormat.align = TextFormatAlign.CENTER;

            headingTextField.defaultTextFormat = newFormat;

            this.addChild(inputTextField);
            this.addChild(headingTextField);
        }

        private function changeHandler(e:Event):void {
            headingTextField.text = inputTextField.text;
        }
    }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.text:TextField:TextField"><apiName>TextField</apiName><shortdesc>
	Создает новый экземпляр TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	Создает новый экземпляр TextField. После создания экземпляра TextField вызовите метод <codeph>addChild()</codeph> или <codeph>addChildAt()</codeph> вышестоящего объекта DisplayObjectContainer, чтобы добавить экземпляр в список отображения TextField.
     <p>Размер по умолчанию для текстового поля — 100 х 100 пикселей.</p>
	 
	 
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.text:TextField:appendText"><apiName>appendText</apiName><shortdesc>
	 Добавляет строку, указанную параметром newText, в конец текста в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, добавляемая к существующему тексту.
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>Добавляет текст к концу существующего текста в TextField.
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Добавляет строку, указанную параметром <codeph>newText</codeph>, в конец текста в текстовом поле. Этот метод более эффективен, чем присвоение сложения (<codeph>+=</codeph>) в свойстве <codeph>text</codeph> (например, <codeph>someTextField.text += moreText</codeph>), особенно для текстовых полей с большим объемом содержимого.
     
	 </apiDesc><example conref="examples\TextField_appendTextExample.as"> В следующем примере отображается время, если сейчас будний день, или текст «Сегодня выходной», если это выходной день. Также подсчитывается число символов до определенного положения и число строк в текстовом поле.
 
 <p>Текстовое поле <codeph>outputText</codeph> настроено так, чтобы автоматически соответствовать тексту и изменять размер с выравниванием текста по левому краю с помощью свойства <codeph>autoSize</codeph>. Свойство <codeph>outputText.text</codeph> записывает первую строку содержимого и метод <codeph>appendText()</codeph> добавляет оставшуюся часть текста. (Необязательно начинать со свойства <codeph>text</codeph>. Метод <codeph>appendText()</codeph> можно было использовать также для добавления текста с самого начала.) Повторное определение свойства <codeph>text</codeph> приведет к перезаписи исходного текста. Используйте оператор <codeph>+=</codeph>, чтобы добавлять содержимое с помощью свойства <codeph>text</codeph>.</p>
 
 <p>Инструкция <codeph>if</codeph> проверяет, выпадает ли дата на субботу (6) или воскресенье (0). Если нет, то метод <codeph>toLocaleTimeString()</codeph> возвращает местное время, которое добавляется к содержимому текстового поля.</p> 
 
 <p>Свойство <codeph>length</codeph> текстового поля используется для считывания количества символов вплоть до вызова функции, а свойство <codeph>numLines</codeph> используется для подсчета числа строк в текстовом поле. Обратите внимание, что пустые строки учитываются при подсчете строк, а пробелы или разрывы строки (\n) учитываются при определении длины содержимого.</p>   
 
<codeblock>
  package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
 
    public class TextField_appendTextExample extends Sprite {
         
        public function TextField_appendTextExample() {
            var outputText:TextField = new TextField();
            var today:Date = new Date();
                
            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
 
            outputText.text = "WHAT TIME IS IT?" + "\n\n";
 
            if((today.day == 0) || (today.day == 6)) {
                outputText.appendText("It's the weekend.");
                outputText.appendText("\n\n");
           
            } else {
                outputText.appendText("The time is: ");
                outputText.appendText(today.toLocaleTimeString() + ".\n\n");  
            }

            outputText.appendText("Number of characters including line breaks and spaces so far: ");
            outputText.appendText(outputText.length.toString() + "\n");
            outputText.appendText("Number of lines in the outputText: ");
            outputText.appendText(outputText.numLines.toString());   

            this.addChild(outputText);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getCharBoundaries"><apiName>getCharBoundaries</apiName><shortdesc>
	 Возвращает прямоугольник, который является ограничительным блоком символа.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Прямоугольник с минимальными и максимальными значениями по осям <codeph>x</codeph> и <codeph>y</codeph>, определяющий ограничительный блок символа.
	 
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для символа (например, первая позиция — 0, вторая позиция — 1 и т.д.)
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает прямоугольник, который является ограничительным блоком символа.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает прямоугольник, который является ограничительным блоком символа.
	 
	 </apiDesc><example conref="examples\TextField_getCharBoundariesExample.as"> В следующем примере метод <codeph>getCharBoundaries()</codeph> используется для пометки (подсветки) символа, выделенного пользователем.
 
 <p>Класс определяет объект Shape с именем <codeph>spotlight</codeph>, который будет использоваться для рисования прямоугольника вокруг каждого выделенного символа. Когда пользователь щелкает текстовое поле <codeph>myTextField</codeph>, вызывается метод <codeph>clickHandler()</codeph>.</p>
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getCharIndexAtPoint()</codeph> получает индекс выбранного символа на основе координат <codeph>localX</codeph> и <codeph>localY</codeph> щелчка мыши, которые определяются относительно содержащего объекта <codeph>Sprite</codeph>. Метод <codeph>getCharIndexAtPoint()</codeph> возвращает <codeph>-1</codeph>, если точка (щелчок мыши) не находится в области символов. Так как текстовое поле может быть больше текста, проверяется возвращенное целое число (<codeph>index</codeph>), чтобы убедиться, что пользователь щелкнул по символу. Целое число <codeph>index</codeph> также используется методом <codeph>getCharBoundaries()</codeph> для получения объекта <codeph>Rectangle</codeph>, содержащего ограничительный блок символа. Метод <codeph>clear()</codeph> все отображавшиеся ранее объекты Shape с именем <codeph>spotlight</codeph>. Новый прямоугольник с размерами ширины и высоты символа создается в местоположении символа (смещение с точки с координатами (10, 10)) с помощью возвращенных координат х и у прямоугольника <codeph>frame</codeph>. Чтобы сделать подсветку символа, объект Shape с именем <codeph>spotlight</codeph> заполняется желтым цветом с прозрачностью 35%, чтобы символ можно было увидеть. Обратите внимание, что пробелы также рассматриваются как символы.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    import flash.display.Shape;

    public class TextField_getCharBoundariesExample extends Sprite
    {
        private var myTextField:TextField = new TextField();    
        private var spotlight:Shape = new Shape();
        
        public function TextField_getCharBoundariesExample() {
            
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.selectable = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.text = "Selected a character from this text by clicking on it."

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);    
            this.addChild(spotlight);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
 
            if (index != -1) {
                 var frame:Rectangle = myTextField.getCharBoundaries(index);

                spotlight.graphics.clear();    
                spotlight.graphics.beginFill(0xFFFF00, .35);
                spotlight.graphics.drawRect((frame.x + 10), (frame.y + 10), frame.width, frame.height);            
                spotlight.graphics.endFill();
            }
        } 
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getCharIndexAtPoint"><apiName>getCharIndexAtPoint</apiName><shortdesc>
	 Возвращает значение индекса, отсчитываемое от нуля, для символа в точке, определенной параметрами x и y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Отсчитываемое от нуля значение индекса для символа (например, первая позиция — 0, вторая позиция — 1 и т.д.). Возвращает -1, если точка не находится в области символа.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>x</i> символа.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>y</i> символа.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает для символа значение индекса, отсчитываемое от нуля.
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает значение индекса, отсчитываемое от нуля, для символа в точке, определенной параметрами <codeph>x</codeph> и <codeph>y</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getCharIndexAtPointExample.as"> В следующем примере, когда пользователь щелкает по символу, он повторяется в другом текстовом поле, расположенном над текстом.
 
 <p>Первое текстовое поле содержит текст, который будет выбирать пользователь. Чтобы текст не выделялся при щелчке, свойству <codeph>selectable</codeph> задается значение false. Когда пользователь щелкает текстовое поле <codeph>firstTextField</codeph>, вызывается метод <codeph>clickHandler()</codeph>.</p>
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getCharIndexAtPoint()</codeph> возвращает индекс символа на основе координат <codeph>localX</codeph> и <codeph>localY</codeph> щелчка мыши. Так как текстовое поле может быть больше текста, проверяется возвращаемое целое число (<codeph>index</codeph>), чтобы убедиться, что пользователь щелкнул по символу. (Метод <codeph>getCharIndexAtPoint()</codeph> возвращает <codeph>-1</codeph>, если точка (щелчок мыши) не находится в области символа.) Координаты мыши используются для определения координат нового текстового поля, где будет повторяться выбранный символ. Задается красный цвет для символа во втором текстовом поле. В завершение, тексту во втором поле назначается выбранный символ, получаемый с помощью метода <codeph>charAt()</codeph>. Обратите внимание, что при использовании свойства <codeph>text</codeph> вместо метода <codeph>appendText()</codeph> приведет к перезаписи символа во втором текстовом поле, а не к его добавлению.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.geom.Rectangle;
    import flash.events.MouseEvent;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getCharIndexAtPointExample extends Sprite {
        private var firstTextField:TextField = new TextField();    
        private var secondTextField:TextField = new TextField();
        
        public function TextField_getCharIndexAtPointExample() {

            firstTextField.x = 100;
            firstTextField.y = 100; 
            firstTextField.width = 260;
            firstTextField.height = 20;
            firstTextField.border = true;
            firstTextField.background = true;
            firstTextField.selectable = false;
            
            firstTextField.text = "Selected a character from this text by clicking on it."

            firstTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            this.addChild(firstTextField);    
            this.addChild(secondTextField);
         }

        private function clickHandler (e:MouseEvent):void {
            var index:int = firstTextField.getCharIndexAtPoint(e.localX, e.localY);

            if (index != -1) {
                secondTextField.x = mouseX;
                secondTextField.y =  70;
                secondTextField.border = true;
                secondTextField.selectable = false;
                secondTextField.background = true;
                secondTextField.textColor = 0xFF0000;
                secondTextField.autoSize = TextFieldAutoSize.LEFT;
                secondTextField.text = firstTextField.text.charAt(index);    
            }
        } 
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getFirstCharInParagraph"><apiName>getFirstCharInParagraph</apiName><shortdesc>
	 Получив индекс символа, возвращает индекс первого символа в том же абзаце.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Указанный индекс символа находится за пределами диапазона.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Отсчитываемое от нуля значение индекса для первого символа в строке в том же абзаце.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для символа (например, первый символ — 0, второй символ — 1 и т.д.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Отсчитываемое от нуля значение индекса для символа.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Получив индекс символа, возвращает индекс первого символа в том же абзаце.
	 
	 </apiDesc><example conref="examples\TextField_getFirstCharInParagraphExample.as"> В следующем примере к содержимому текстового поля применяется форматирование абзаца. Когда пользователь щелкает по абзацу, его текст будет выравниваться по правому краю, а при повторном щелчке он возвращается к исходному формату (по умолчанию) с выравниванием по левому краю.
 
 <p>В конструкторе для текстового поля <codeph>myTextField</codeph> задается перенос текста. Метод <codeph>getTextFormat</codeph> возвращает исходный формат первого символа содержимого текстового поля, которое помещается в объект TextFormat с именем <codeph>originalFormat</codeph>. Также определяется новый объект TextFormat (<codeph>newFormat</codeph>) и его свойству <codeph>align</codeph> задается выравнивание по правому краю. Когда пользователь щелкает текстовое поле, вызывается метод <codeph>clickHandler()</codeph>.</p>
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getCharIndexAtPoint()</codeph> возвращает индекс символа на основе координат <codeph>localX</codeph> и <codeph>localY</codeph> щелчка мыши. Первая инструкция <codeph>if</codeph> проверяет, щелкнул ли пользователь по символу. С помощью целого числа <codeph>clickIndex</codeph>, возвращенного методом <codeph>getCharIndexAtPoint()</codeph>, метод <codeph>getFirstCharInParagraph()</codeph> возвращает индекс первого символа в абзаце, получившем щелчок пользователя. Индекс последнего символа в абзаце определяется путем добавления длины абзаца (с помощью метода <codeph>getParagraphLength()</codeph>) к индексу первого символа минут последний символ (<codeph>\n</codeph>). Второй оператор <codeph>if</codeph> проверяет формат первого символа в абзаце. Если значение свойства выравнивания совпадает с исходным форматом (по левому краю), новый формат применяется ко всем символам абзаца. В противном случае формат абзаца возвращается к исходному формату. Выравнивание, а также такие элементы форматирования, как отступ, маркер, табуляция, левое и правое поля, предназначены для абзацев. Обратите внимание, что при использовании переноса слов и разрыва строк, форматирование применяется только к верой строка абзаца, если не определен аргумент <codeph>endIndex</codeph> для метода <codeph>setTextFormat()</codeph>.</p>
     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFormatAlign;

    public class TextField_getFirstCharInParagraphExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        private var originalFormat:TextFormat = new TextFormat();
        private var newFormat:TextFormat = new TextFormat(); 
        
        public function TextField_getFirstCharInParagraphExample() {
            myTextField.x = 10;
            myTextField.y = 10; 
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 300; 
            myTextField.background = true;
             
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.\n\n");

            originalFormat = myTextField.getTextFormat(0);

            newFormat.align = TextFormatAlign.RIGHT;

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
  
            this.addChild(myTextField);
        }

        private function clickHandler(e:MouseEvent):void {
            var clickIndex:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
                  
            if(clickIndex != -1) {
                var paragraphFirstIndex:int = myTextField.getFirstCharInParagraph(clickIndex);
                var paragraphEndIndex:int = paragraphFirstIndex + ((myTextField.getParagraphLength(clickIndex) - 1));
            
                if (myTextField.getTextFormat(paragraphFirstIndex).align == originalFormat.align) {
                     myTextField.setTextFormat(newFormat, paragraphFirstIndex, paragraphEndIndex);
                }else {
                     myTextField.setTextFormat(originalFormat, paragraphFirstIndex, paragraphEndIndex);
                }
            } 
        }
    }
}
 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getImageReference"><apiName>getImageReference</apiName><shortdesc>
	 Возвращает ссылку DisplayObject для данного идентификатора, изображения или SWF-файла, добавленного в текстовое поле с форматированием HTML с помощью тега &amp;lt;img&amp;gt;.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Экранный объект, соответствующий изображению или SWF-файлу с соответствующим атрибутом <codeph>id</codeph> в теге <codeph>&lt;img></codeph> текстового поля. Для мультимедийного содержимого, загруженного из внешнего источника, этот объект является объектом Loader, и после загрузки мультимедийный объект становится нижестоящим по отношению к нему. Для мультимедийного содержимого, встроенного в SWF-файл, это загруженный объект Если не существует тега <codeph>&lt;img></codeph> с идентичным атрибутом <codeph>id</codeph>, метод возвращает значение <codeph>null</codeph>.
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Идентификатор <codeph>id</codeph> для сопоставления (в атрибуте <codeph>id</codeph> тега <codeph>&lt;img></codeph>). 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает ссылку DisplayObject по данному идентификатору <codeph>id</codeph> для изображения или SWF-файла, добавленного в текстовое поле с форматированием HTML с помощью тега <codeph>&lt;img></codeph>. Тег <codeph>&lt;img></codeph> имеет следующий формат:
	 
	 <p><pre><codeph>	&lt;img src = 'filename.jpg' id = 'instanceName' ></codeph></pre></p>
	 
	 </apiDesc><example conref="examples\TextField_getImageReferenceExample.as"> В следующем примере при щелчке по текстовому полю встроенное в него изображение становится прозрачным на 25 процентов и поворачивается на 90 градусов от исходного положения. Изображение продолжает поворачиваться при каждом последующем щелчке.
 
 <p>Изображение (<codeph>image.jpg</codeph>) добавлено с помощью HTML. (Предполагается, что файл изображения находится в том же каталоге, что и SWF-файл.) Необходимо определить атрибут <codeph>id</codeph> для тега <codeph>img</codeph>, чтобы получить изображение с помощью метода <codeph>getImageReference()</codeph>. Свойство <codeph>htmlText</codeph> используется для добавление строкового содержимого в формате HTML. Когда пользователь щелкает текстовое поле <codeph>myTextField</codeph>, вызывается метод <codeph>clickHandler()</codeph>.</p> 
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getImageReference()</codeph> возвращает ссылку на изображение в качестве <codeph>DisplayObject</codeph>. Эта ссылка может использовать для выполнения манипуляций с изображением, как с любым объектом <codeph>DisplayObject</codeph>. В данном примере заданы свойства <codeph>alpha</codeph> (прозрачность) и <codeph>rotation</codeph>. Также можно использовать свойство <codeph>transform</codeph> для получения матрицы экранного объекта, преобразования цвета и пиксельных границ. Также обратите внимание, что необходимо импортировать объект <codeph>flash.display.DisplayObject</codeph>.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.Event;
    import flash.events.MouseEvent;
    import flash.display.DisplayObject;
    
    import flash.text.TextFieldAutoSize;
    
    public class TextField_getImageReferenceExample extends Sprite
    {
        private var myTextField:TextField = new TextField();
        
        public function TextField_getImageReferenceExample()
        {
            var myText1:String = "&lt;p>Here is an image we want to mainpulate: &lt;img src='image.jpg' id='testimage'>&lt;/p>";

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 250;
            myTextField.height = 250;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.border = true;
            myTextField.multiline = true;

            myTextField.htmlText = myText1;
            
            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            this.addChild(myTextField);
        }
 
        private function clickHandler(e:MouseEvent):void {
            var imageRef:DisplayObject = myTextField.getImageReference("testimage");
 
            imageRef.rotation += 90;
            imageRef.x = 125;
            imageRef.y = 125;
            imageRef.alpha = 0.25;      
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>htmlText</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineIndexAtPoint"><apiName>getLineIndexAtPoint</apiName><shortdesc>
	 Возвращает значение индекса, отсчитываемое от нуля, для строки в точке с координатами x и y.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Отсчитываемое от нуля значение индекса для строки (например, первая строка — 0, вторая строка — 1 и т.д.). Возвращает -1, если точка не находится в области строки.
 	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>x</i> строки.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Координата <i>x</i> строки.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Значение индекса для строки в заданной точке, отсчитываемое от нуля.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает значение индекса, отсчитываемое от нуля, для строки в точке с координатами <codeph>x</codeph> и <codeph>y</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexAtPointExample.as"> В следующем примере, когда пользователь выбирает строку из сонета Шекспира, она копируется (добавляется) в новое текстовое поле.   
 
 <p>В конструкторе для текстового поля <codeph>poem</codeph> запрещается перенос, так как это стихотворение. Также используется свойство <codeph>autoSize</codeph> для автоматического соответствия поля тексту и для изменения размера с выравниванием по левому краю. Текстовое поле <codeph>poemCopy</codeph> располагается под полем <codeph>poem</codeph>. Когда пользователь щелкает по строке сонета, вызывается метод <codeph>clickHandler()</codeph>.</p>
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getLineIndexAtPoint()</codeph> возвращает индекс строки, по которой щелкнул пользователь, на основе координат <codeph>localX</codeph> и <codeph>localY</codeph> щелчка мыши. (Так как стихотворение укладывается в исходный размер текстового поля, нет необходимости отлеживать ошибку (<codeph>RangeError</codeph>), выдаваемую методом <codeph>getCharIndexAtPoint()</codeph>.) Затем индекс строки используется для получения ее содержимого в виде строкового значения с помощью метода <codeph>getLineText()</codeph>, которое после этого добавляется к содержимому текстового поля <codeph>poemCopy</codeph>. Копирование может продолжаться бесконечно вплоть до момента, когда текст выйдет за пределы видимого текстового поля <codeph>poemCopy</codeph>.</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexAtPointExample extends Sprite {
        private var poem:TextField = new TextField();
        private var poemCopy:TextField = new TextField();
        
        public function TextField_getLineIndexAtPointExample() {
            poem.border = true;
            poem.autoSize = TextFieldAutoSize.LEFT;
            poem.x = 10;
            poem.wordWrap = false;

            poemCopy.height = 250;
            poemCopy.width = 270;
            poemCopy.y = 230;
            poemCopy.x = 10;
            poemCopy.background = true;
            poemCopy.border = true;
            poemCopy.wordWrap = false;
            
            poem.appendText("Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.");

           poem.addEventListener(MouseEvent.CLICK, clickHandler); 

           this.addChild(poem); 
           this.addChild(poemCopy);
        }
    
        private function clickHandler(e:MouseEvent):void {
                var index:int = poem.getLineIndexAtPoint(e.localX, e.localY);
                var s:String;

                s = poem.getLineText(index);
                poemCopy.appendText(s + "\n");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineIndexOfChar"><apiName>getLineIndexOfChar</apiName><shortdesc>
	 Отсчитываемое от нуля значение индекса для строки, которая содержит символ, заданный параметром charIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Указанный индекс символа находится за пределами диапазона.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Отсчитываемое от нуля значение индекса для строки.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для символа (например, первый символ — 0, второй символ — 1 и т.д.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Отсчитываемое от нуля значение индекса для строки, которая содержит символ, заданный параметром <codeph>charIndex</codeph>.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Отсчитываемое от нуля значение индекса для строки, которая содержит символ, заданный параметром <codeph>charIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineIndexOfCharExample.as"> В следующем примере метод <codeph>getLineIndexOfChar()</codeph> возвращает номера строк для сотого и пятисотого символов в текстовом поле.
 
 <p>Для текстового поля <codeph>myTextField</codeph> задается перенос слов и изменение размера с выравниванием по левому краю. Метод <codeph>getLineIndexOfChar()</codeph> возвращает индекс строки для символов с указанными индексами (100 и 500). Затем эти сведения добавляются после абзаца. Обратите внимание, что индекс строки отсчитывается от нуля, и поэтому индекс строки (<codeph>index</codeph>) увеличивается на 1 для получения номера строки. Кроме того, если изменяется размер экрана, номер строки может измениться, но информация останется без изменений, так как метод вызывается только один раз.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class TextField_getLineIndexOfCharExample extends Sprite 
    {
        public function TextField_getLineIndexOfCharExample()
        {
            var myTextField:TextField = new TextField();
            
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 200;
            myTextField.background = true;  
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.autoSize = TextFieldAutoSize.LEFT;

            myTextField.appendText("The TextField class is used to create display objects for "
                + "text display and input. All dynamic and input text fields in a SWF file" 
                + "are instances of the TextField class. You can use the TextField class "
                + "to perform low-level text rendering. However, in Flex, you typically use "
                + "the Label, Text, TextArea, and TextInput controls to process text. "  
                + "You can give a text field an instance name in the Property inspector "
                + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                + "Target Path dialog box in the Actions panel.\n\n");

            var index:int = myTextField.getLineIndexOfChar(100);
            myTextField.appendText("100th character is in line: " +  (index + 1) + "\n");
            index = myTextField.getLineIndexOfChar(500);
            myTextField.appendText("500th character is in line: " + (index + 1));

            this.addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineLength"><apiName>getLineLength</apiName><shortdesc>
	 Возвращает число символов в заданной строке текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineLength, getLineLength
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Заданный номер строки находится за пределами диапазона.
	 
 	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Количество символов в строке.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Номер строки, длину которой требуется определить.
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает число символов в заданной строке текста.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает число символов в заданной строке текста.
	 
	 </apiDesc><example conref="examples\TextField_getLineLengthExample.as"> В следующем примере, когда пользователь выбирает строку, ее длина (количество символов) отображается в отдельном текстовом поле. 
 <p>В качестве иллюстрации, для текстового поля <codeph>myTextField</codeph>, отображающего текст, который будет подсчитываться, задается значение <codeph>INPUT</codeph>, благодаря чему пользователи смогут изменять строки или добавлять строки между строк или в конце текста. (Создается пустая строка с помощью разрыва строки (<codeph>\n</codeph>) в конце последней строки.) Текстовое поле <codeph>countLines</codeph>, в котором отображается результат подсчета длины строки, помещается под полем <codeph>myTextField</codeph>, и его содержимое не реагирует на выделение. Когда пользователь щелкает строку в текстовом поле <codeph>myTextField</codeph>, вызывается метод <codeph>clickHandler()</codeph>.</p>
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getLineIndexAtPoint()</codeph> возвращает индекс строки, по которой щелкнул пользователь, на основе координат <codeph>localX</codeph> и <codeph>localY</codeph> щелчка мыши. Первая инструкция <codeph>if</codeph> проверяет, щелкнул ли пользователь по символу. Если да, то метод <codeph>getLineLength()</codeph> возвращает число символов в строке на основе ее индекса. Обратите внимание, что пустые строки между строк содержат второй разрыв строки (<codeph>\n</codeph>), вследствие чего их длина составляет один символ, а пустая строка после последней строки не имеет символов. Пробел засчитывается как один символ. Пользователь может написать новую строку или изменить существующую и, щелкнув по ней, получить число символов. Если используется перенос текста и изменился размер экрана, то индекс строки может измениться.</p>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class TextField_getLineLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countLines:TextField = new TextField();  

        public function TextField_getLineLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 350;
            myTextField.height = 150;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.type = TextFieldType.INPUT;
            
            myTextField.appendText("Click on the lines to count its number of characters:\n\n");
            myTextField.appendText("This is a short line.\n");
            myTextField.appendText("This is a longer line than the last line.\n\n");
            myTextField.appendText("This one is even longer than the one before. It has two sentences.\n");

            this.addChild(myTextField);

            countLines.border = true;
            countLines.x = 10;
            countLines.y = 180;
            countLines.height = 30;
            countLines.width = 200;
            countLines.background = true;
            countLines.selectable = false;

           this.addChild(countLines);    

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getLineIndexAtPoint(e.localX, e.localY);
        
            if (index != -1) {
            var lenght:int = myTextField.getLineLength(index);

            countLines.text = "Number of characters in the line is: " + lenght.toString();
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineMetrics"><apiName>getLineMetrics</apiName><shortdesc>
	 Возвращает данные метрик для заданной строки текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getLineMetrics, getLineMetrics
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Заданный номер строки находится за пределами диапазона.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект TextLineMetrics.
	 </apiDesc><apiOperationClassifier>flash.text:TextLineMetrics</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Номер строки, для которой требуется получить данные метрик.
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает данные метрик для заданной строки текста.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает данные метрик для заданной строки текста.
	 
	 </apiDesc><example conref="examples\TextField_getLineMetricsExample.as"> В следующем примере отображаются некоторые значения метрик строки для двух строк текста с разным форматированием.
 
 <p>Добавляются две строки из стихотворения Уолта Уитмена <i>Песня о себе</i>. Новый объект TextFormat (<codeph>newFormat</codeph>) используется для указания формата второй строки. Первая строка сохраняет формат по умолчанию. Метод <codeph>getLineMetrics()</codeph> возвращает объект <codeph>TextLineMetrics</codeph> для конкретной строки. (Индекс строки отсчитывается от нуля.) С использованием объектов TextLineMetrics с именами <codeph>metrics1</codeph> и <codeph>metrics2</codeph> для строк 1 и 2 соответственно получаются и отображаются значения для подъема, спуска, высоты и веса строки. Полученные числа преобразуются в строковые значения, но не округляются. Обратите внимание, что это значение для строки, а не для отдельного символа. Оно отражает диапазон символов всей строки. Например, если в строке есть разные символы с разными форматами высоты, то это значение будет определяться символом с наибольшей высотой. Так же это значит, что при изменении формата одного из символов могут измениться и некоторые значения метрик.</p>
  
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.TextFormat;
 
    public class TextField_getLineMetricsExample extends Sprite {

        public function TextField_getLineMetricsExample() {
            var myTextField:TextField = new TextField();
            var newFormat:TextFormat = new TextFormat(); 

            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.wordWrap = false;
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            
            myTextField.appendText("A child said What is the grass? fetching it to me with full hands;\n");
            myTextField.appendText("How could I answer the child? I do not know what it is any more than he.\n\n");

            newFormat.size = 14;
            newFormat.font = "Arial";
            newFormat.italic = true;
            myTextField.setTextFormat(newFormat, 67, 139);
               
            var metrics1:TextLineMetrics = myTextField.getLineMetrics(0);
             
            myTextField.appendText("Metrics ascent for the line 1 is: " + metrics1.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics1.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics1.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics1.width.toString() + "\n\n");

            var metrics2:TextLineMetrics = myTextField.getLineMetrics(1);
             
            myTextField.appendText("Metrics ascent for the line 2 is: " + metrics2.ascent.toString() + "\n");
            myTextField.appendText("Metrics descent is: " + metrics2.descent.toString() + "\n");
            myTextField.appendText("Metrics height is: " + metrics2.height.toString() + "\n"); 
            myTextField.appendText("Metrics width is: " + metrics2.width.toString() + "\n");

            addChild(myTextField);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link><link href="flash.text.xml#TextLineMetrics"><linktext>flash.text.TextLineMetrics</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getLineOffset"><apiName>getLineOffset</apiName><shortdesc>
	 Возвращает индекс первого символа в строке, заданной параметром lineIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Заданный номер строки находится за пределами диапазона.
 	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Отсчитываемое от нуля значение индекса для первого символа в строке.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для строки (например, первая строка — 0, вторая строка — 1 и т.д.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Отсчитываемое от нуля значение индекса для первого символа в строке.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает индекс первого символа в строке, заданной параметром <codeph>lineIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineOffsetExample.as"> В следующем примере определяется индекс первого символа в строке 4, который изменится при изменении размеров экрана (и текстового поля).
 
 <p>Для текстового поля <codeph>myTextField</codeph> разрешается перенос слов. В текстовом поле <codeph>countField</codeph> будет отображаться первый символ строки 4. Когда пользователь щелкает текстовое поле <codeph>myTextField</codeph>, вызывается метод <codeph>clickHandler()</codeph>.</p>
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getLineOffset()</codeph> возвращает индекс первого символа в строке с индексом 3, которая является четвертой строкой текста. (Первая строка имеет индекс 0.) Метод <codeph>charAt()</codeph> используется для получения символа на основе индекса первого символа четвертой строки. Содержимое <codeph>countField</codeph> обновляется этой информацией с помощью свойства<codeph>text</codeph> текстового поля<codeph>countField</codeph>. Использование свойства <codeph>countField.text</codeph> означает, что после каждого щелчка мыши содержимое текстового поля <codeph>countField</codeph> будет переписываться. Если пользователь изменит размер экрана, содержимое будет перенесено, и первый символ строки 4 может измениться. При повторном щелчке по полю <codeph>myTextField</codeph> содержимое текстового поля <codeph>countField</codeph> обновляется, отображая новый первый символ четвертой строки.</p>    
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getLineOffsetExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();
        
        public function TextField_getLineOffsetExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.width = 150;
            myTextField.height = 300;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;

            countField.height = 20;
            countField.width = 200;
            countField.x = 10;
            countField.y = 320;
            countField.selectable = false;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file " 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
        
            this.addChild(myTextField);
            this.addChild(countField);
        }
    
            private function clickHandler(e:MouseEvent):void {
                var c:String;
                var index:int;
                
                index = myTextField.getLineOffset(3);
                c = myTextField.text.charAt(index);
                countField.text = "The first character of line 4 is: " + c;
            }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getLineText"><apiName>getLineText</apiName><shortdesc>
	 Возвращает текст строки, заданной параметром lineIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Заданный номер строки находится за пределами диапазона.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Текстовая строка, содержащаяся в заданной строке.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>lineIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для строки (например, первая строка — 0, вторая строка — 1 и т.д.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Текстовая строка, содержащаяся в заданной строке.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает текст строки, заданной параметром <codeph>lineIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_getLineTextExample.as"> В следующем примере определяются и отображаются номера строк всех случаев употребления слова love в тексте сонета Шекспира.
 
 <p>Для текстового поля <codeph>poem</codeph> задано автоматическое соответствие тексту и изменение размера с выравниванием по левому краю. Свойству <codeph>wordWrap</codeph> задано значение <codeph>false</codeph>, чтобы строки стихотворения не переносились, хотя обычно при использовании свойства <codeph>autoSize</codeph> это не вызывает проблем. Цикл <codeph>for</codeph> повторяет процедуру для всех строк сонета с использованием свойства <codeph>numLines</codeph> текстового поля. Метод <codeph>getLineText()</codeph> возвращает содержимое строки в виде строкового значения. (Обратите внимание, что свойство <codeph>numLines</codeph> возвращает количество строк, начиная со строки 1, а метод <codeph>getLineText()</codeph> начинает отсчет строк с 0.) С помощью регулярного выражения (<codeph>/love/i</codeph>) оператор <codeph>if</codeph> ищет любую подстроку слова, написанного заглавными и строчными буквами. Если слово обнаружено, метод <codeph>search</codeph> возвращает индекс первой соответствующей подстроки, в противном случае он возвращает значение <codeph>-1</codeph> (если соответствий не найдено). Строка, в которой найдено слово love (<codeph>(i + 1)</codeph>) помещается в строковое значение <codeph>lineResult</codeph>. Метод string преобразует аргумент номера (<codeph>(i + 1)</codeph>) в строковое значение, если присутствует другой строковый аргумент (" "). Результат поиска будет включать строки со словами loved или Love's. Если перед циклом <codeph>for</codeph> была добавлена строка «Слово love найдено в строках:», то слово Love в этой строке также будет включено в результат.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
 
    public class TextField_getLineTextExample extends Sprite {
           
        public function TextField_getLineTextExample() {
           var poem:TextField = new TextField();
           var lineResult:String = ""; 
           var pattern:RegExp = /love/i;

            poem.x = 10;
            poem.y = 10;
            poem.background = true;
            poem.wordWrap = false;
            poem.autoSize = TextFieldAutoSize.LEFT;
            
            poem.text = "Let me not to the marriage of true minds\n"
                              + "Admit impediments. love is not love\n"
                              + "Which alters when it alteration finds\n"
                              + "Or bends with the remover to remove:\n"
                              + "O no! it is an ever-fixed mark\n" 
                              + "That looks on tempests and is never shaken;\n"
                              + "It is the star to every wandering bark,\n"
                              + "Whose worth's unknown, although his height be taken.\n"
                              + "Love's not Time's fool, though rosy lips and cheeks\n"
                              + "Within his bending sickle's compass come:\n"
                              + "Love alters not with his brief hours and weeks,\n"
                              + "But bears it out even to the edge of doom.\n"
                              + "If this be error and upon me proved,\n"
                              + "I never writ, nor no man ever loved.\n\n";

            for (var i:int = 0; i &lt; poem.numLines; i++) {

                var s:String = poem.getLineText(i);
                        
                if(s.search(pattern) != -1) {
                    lineResult += (i + 1) + " ";
                }
            }

            poem.appendText("Love was found in lines: " + lineResult);
             
            this.addChild(poem);                      
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:getParagraphLength"><apiName>getParagraphLength</apiName><shortdesc>
	 Используя полученный индекс символа, возвращает длину абзаца, содержащего этот символ.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Указанный индекс символа находится за пределами диапазона.
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращает количество символов в абзаце.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>charIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для символа (например, первый символ — 0, второй символ — 1 и т.д.).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Отсчитываемое от нуля значение индекса для символа.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Используя полученный индекс символа, возвращает длину абзаца, содержащего этот символ. Длина отсчитывается от первого символа в абзаце (возвращенного методом <codeph>getFirstCharInParagraph()</codeph>), а не от переданного индекса символа.
	 
	 </apiDesc><example conref="examples\TextField_getParagraphLengthExample.as"> В следующем примере, когда пользователь выделяет абзац, в отдельном текстовом поле отображается его длина и количество символов s.
 
 <p>В текстовом поле <codeph>myTextField</codeph> отображаются абзацы, которые будет выбирать пользователь. При щелчке по текстовому полю отправляется событие <codeph>MouseEvent.CLICK</codeph>, и вызывается метод <codeph>clickHandler()</codeph>. Длина абзаца и количество символов s будут отображаться в текстовом поле <codeph>countField</codeph>, расположенном под полем <codeph>myTextField</codeph>.</p> 
 
 <p>В методе <codeph>clickHandler()</codeph> метод <codeph>getCharIndexAtPoint()</codeph> возвращает индекс символа на основе координат <codeph>localX</codeph> и <codeph>localY</codeph> щелчка мыши. Первая инструкция <codeph>if</codeph> проверяет, щелкнул ли пользователь по символу. Метод <codeph>getFirstCharInParagraph()</codeph> использует этот индекс, чтобы получить индекс первого символа в том же абзаце. Длина абзаца, возвращенная методом <codeph>getParagraphLength()</codeph>, используется вместе с индексом первого символа в абзаце для определения индекса последнего символа. Цикл <codeph>for</codeph> повторяет операцию поиска и подсчета символов s в абзаце.</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.events.MouseEvent;

    public class TextField_getParagraphLengthExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var countField:TextField = new TextField();

        public function TextField_getParagraphLengthExample() {
            myTextField.x = 10;
            myTextField.y = 10;
            myTextField.background = true;
            myTextField.border = true;
            myTextField.wordWrap = true;
            myTextField.width = 300;
            myTextField.height = 280;
            
            myTextField.appendText("The TextField class is used to create display objects for "
                        + "text display and input. All dynamic and input text fields in a SWF file" 
                        + "are instances of the TextField class. You can use the TextField class "
                        + "to perform low-level text rendering. However, in Flex, you typically use "
                        + "the Label, Text, TextArea, and TextInput controls to process text. "  
                        + "You can give a text field an instance name in the Property inspector "
                        + "and use the methods and properties of the TextField class to manipulate it with ActionScript. "
                        + "TextField instance names are displayed in the Movie Explorer and in the Insert "
                        + "Target Path dialog box in the Actions panel.\n\n"  
                        + "To create a text field dynamically, use the TextField() constructor.\n\n"
                        + "The methods of the TextField class let you set, select, and manipulate "  
                        + "text in a dynamic or input text field that you create during authoring or at runtime.");

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            
            countField.x = 10;
            countField.y = 300;
            countField.height = 50;
            countField.width = 250;
            countField.background = true;
            countField.selectable = false;

            this.addChild(myTextField);
            this.addChild(countField);
        }

        private function clickHandler(e:MouseEvent):void {
            var index:int = myTextField.getCharIndexAtPoint(e.localX, e.localY);
            
            if(index != -1) {
                var beginParag:int = myTextField.getFirstCharInParagraph(index);
                var paragLength:int = myTextField.getParagraphLength(index);
                var endParag:int = beginParag + paragLength;
                var sCount:uint = 0;

                for (var i:int = beginParag; i &lt;= endParag; i++) {
                    if ((myTextField.text.charAt(i) == "s") || (myTextField.text.charAt(i) == "S")) {
                        sCount++; 
                    }

                countField.text = "Paragraph length is: " + paragLength.toString() + "\n" 
                        + "Number of 's' characters in the paragraph: " + sCount.toString();
                }
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/getFirstCharInParagraph()"><linktext>flash.text.TextField.getFirstCharInParagraph()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:getTextFormat"><apiName>getTextFormat</apiName><shortdesc>
	 Возвращает объект TextFormat, содержащий данные о форматировании для фрагмента текста, заданного параметрами beginIndex и endIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.getTextFormat, getTextFormat
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Заданный параметр <codeph>beginIndex</codeph> или <codeph>endIndex</codeph> находится за пределами диапазона.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Объект TextFormat, представляющий свойства форматирования для указанного текста.
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Необязательно; целое число, указывающее начальное положение фрагмента текста в текстовом поле.
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Необязательно: целое число, указывающее положение первого символа после нужного фрагмента текста. В соответствии с дизайном, если задать значения <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>, считывается текст с <codeph>beginIndex</codeph> по <codeph>endIndex-1</codeph>. 
	 
 	 </apiDesc></apiParam><apiTipTexts><apiTipText>Возвращает объект TextFormat.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Возвращает объект TextFormat, содержащий данные о форматировании для фрагмента текста, заданного параметрами <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>. В полученном объекте TextFormat задаются только свойства, используемые для всего заданного текста. <i>Смешанные</i> свойства (те, которые имеют разные значения для разных участков текста) имеют значение <codeph>null</codeph>.
	 
	 <p>Если не задать значения для этих параметров, то метод применяется ко всему содержимому текстового поля.  </p>
	 
	 <p>В следующей таблице описываются три способа применения.</p>
	 
	 <adobetable class="innertable">
	   
	   
	 	 
	   
	 <tgroup cols="2"><thead><row><entry>Применение</entry><entry>Описание</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.getTextFormat()</codeph></entry>
	 	   <entry>Возвращает объект TextFormat, содержащий информацию о форматировании для всего содержимого текстового поля. В полученном объекте TextFormat задаются только свойства, используемые для всего текста в текстовом поле. <i>Смешанные</i> свойства (те, которые имеют разные значения для разных участков текста) имеют значение <codeph>null</codeph>.</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number)</codeph></entry>
	     <entry>Возвращает объект TextFormat, содержащий копию формата текста для символа в положении <codeph>beginIndex</codeph>.</entry>
	   </row><row>
	     <entry><codeph>my_textField.getTextFormat(beginIndex:Number,endIndex:Number)</codeph></entry>
	     <entry>Возвращает объект TextFormat, содержащий информацию о форматировании для фрагмента текста от <codeph>beginIndex</codeph> до <codeph>endIndex-1</codeph>. В полученном объекте TextFormat задаются только свойства, используемые для всего заданного текста. Смешанные свойства (те, которые имеют разные значения для разных участков выбранного текста) имеют значение <codeph>null</codeph>.</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example>См. примеры метода <xref href="TextField.html#getFirstCharInParagraph()">getFirstCharInParagraph()</xref> или <xref href="TextField.html#setTextFormat()">setTextFormat()</xref>, иллюстрирующие использование <codeph>getTextFormat()</codeph>. 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:isFontCompatible"><apiName>isFontCompatible</apiName><shortdesc>
	 Возвращает значение true, если доступен встроенный шрифт с указанными свойствами fontName и fontStyle, где Font.fontType – это flash.text.FontType.EMBEDDED.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>Заданное свойство <codeph>fontStyle</codeph> не является членом <codeph>flash.text.FontStyle</codeph>.
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>Значение <codeph>true</codeph>, если доступен совместимый встроенный шрифт, в противном случае, значение — <codeph>false</codeph>.
	 
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя проверяемого встроенного шрифта.
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Задает стиль шрифта для проверки. Используйте <codeph>flash.text.FontStyle</codeph>
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает значение true, если доступен встроенный шрифт с указанными свойствами <codeph>fontName</codeph> и <codeph>fontStyle</codeph>, где <codeph>Font.fontType</codeph> — это <codeph>flash.text.FontType.EMBEDDED</codeph>. Начиная с Flash Player 10, SWF-файле могут отображаться два вида встроенных шрифтов. Обычные встроенные шрифты используются только с объектами TextField. Встроенные шрифты CFF используются только с классами flash.text.engine. Два типа различаются свойством <codeph>fontType</codeph> класса <codeph>Font</codeph>, возвращенным функцией <codeph>enumerateFonts()</codeph>.
	 
	 <p>Объект TextField не может использовать шрифт типа <codeph>EMBEDDED_CFF</codeph>. Если свойство <codeph>embedFonts</codeph> имеет значение <codeph>true</codeph> и в среде выполнения единственным доступным шрифтом с заданным именем и стилем является шрифт типа <codeph>EMBEDDED_CFF</codeph>, Flash Player не визуализирует текст, как если бы встроенного шрифта с заданным именем и стилем не было.</p>
	 
	 <p>Если имеются шрифты <codeph>EMBEDDED</codeph> и <codeph>EMBEDDED_CFF</codeph> с одинаковым именем и стилем, выбирается шрифт типа <codeph>EMBEDDED</codeph> и используется для визуализации текста с помощью шрифта <codeph>EMBEDDED</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link><link href="flash.text.engine.xml#TextBlock/createTextLine"><linktext>flash.text.engine.TextBlock.createTextLine</linktext></link><link href="flash.text.xml#FontType/EMBEDDED_CFF"><linktext>flash.text.FontType.EMBEDDED_CFF</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceSelectedText"><apiName>replaceSelectedText</apiName><shortdesc>
	 Заменяет текущий выделенный фрагмент содержимым параметра value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.replaceSelectedText, replaceSelectedText
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Этот метод нельзя использовать для текстового поля с таблицей стилей.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка для замены текущего выделенного текста.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Заменяет текущий выделенный фрагмент содержимым параметра value.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Заменяет текущий выделенный фрагмент содержимым параметра <codeph>value</codeph>. Текст вставляется в положении текущего выделенного фрагмента с использованием текущих форматов символов и абзаца по умолчанию. Текст обрабатывается не как HTML.
	 
	 <p>Можно использовать метод <codeph>replaceSelectedText()</codeph> для вставки и удаления текста без нарушения форматирования символов и абзацев остальной части текста.</p>
     <p><b>Примечание.</b> Этот метод не работает, если к текстовому полю применена таблица стилей.</p>
     
	 
	 </apiDesc><example conref="examples\TextField_replaceSelectedTextExample.as"> В следующем примере пользователь удаляет часть текста из первого текстового поля путем выделения и заменяет выделенный текст во втором поле строкой NEW TEXT.
 
 <p>Создаются два разных объекта TextField, к которым добавляются два прослушивателя события <codeph>MouseEvent.MOUSE_UP</codeph>. Это событие (подъем мыши) происходит, когда пользователь отпускает кнопку мыши, что обычно бывает после выделения текста. Обратите внимание, что по умолчанию текстовое поле допускает выделение текста.</p>
 
 <p>Метод <codeph>mouseHandler1()</codeph> стирает выделенный текст, заменяя его пустой строкой, когда пользователь отпускает кнопку мыши в текстовом поле <codeph>myTextField1</codeph>. Это может продолжаться, пока не будет удален весь текст. Когда пользователь выделяет текст в текстовом поле <codeph>myTextField2</codeph>, метод <codeph>mouseHandler2()</codeph> проверяет свойства <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph>, чтобы определить, выделены ли символы. (Свойства <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> имеют разное значение при выделении текста.) После этого выделенный текст заменяется строкой «NEW TEXT». Это может продолжаться до тех пор, пока весь исходный текст во втором текстовом поле не будет заменен строкой NEW TEXT.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;    
    import flash.events.MouseEvent;

    public class TextField_replaceSelectedTextExample extends Sprite {
        private var myTextField1:TextField = new TextField();
        private var myTextField2:TextField = new TextField();
        
        public function TextField_replaceSelectedTextExample() {
            myTextField1.x = 10;
            myTextField1.width = 300;
            myTextField1.height = 50; 
            myTextField1.background = true; 
            myTextField1.border = true;
            myTextField1.text = "Select the text you want to remove from the line.";
            
            myTextField2.x = 10;
            myTextField2.y = 60;
            myTextField2.width = 300;
            myTextField2.height = 50;
            myTextField2.background = true;
            myTextField2.border = true;
            myTextField2.text = "Select the text you want to replace with NEW TEXT.";
            
            myTextField1.addEventListener(MouseEvent.MOUSE_UP, mouseHandler1);
            myTextField2.addEventListener(MouseEvent.MOUSE_UP, mouseHandler2);
            
            this.addChild(myTextField1);
            this.addChild(myTextField2);
        }
        
        private function mouseHandler1(e:MouseEvent):void {
            myTextField1.replaceSelectedText("");
        }

        private function mouseHandler2(e:MouseEvent):void {
            if(myTextField2.selectionBeginIndex != myTextField2.selectionEndIndex) {
                myTextField2.replaceSelectedText("NEW TEXT");    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:replaceText"><apiName>replaceText</apiName><shortdesc>
	 Заменяет диапазон символов, заданный параметрами beginIndex и endIndex, содержанием параметра newText.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Этот метод невозможно использовать для текстового поля с таблицей стилей.
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для начального положения диапазона замены.
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемая от нуля позиция индекса первого символа после требуемого фрагмента текста.
	 </apiDesc></apiParam><apiParam><apiItemName>newText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Текст для замены заданного диапазона символов.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Заменяет диапазон символов.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Заменяет диапазон символов, заданный параметрами <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>, содержанием параметра <codeph>newText</codeph>. Согласно плану, заменяется текст от <codeph>beginIndex</codeph> до <codeph>endIndex-1</codeph>.  
     <p><b>Примечание.</b> Этот метод не работает, если к текстовому полю применена таблица стилей.</p>
     
	 </apiDesc><example conref="examples\TextField_replaceTextExample.as"> В следующем примере используется метод <codeph>replaceText()</codeph> для удаления, замены и вставки текста в текстовое поле.
 
 <p>Для текстового поля <codeph>outputText</codeph> задано автоматическое соответствие размерам текста и изменение размера с выравниванием по левому краю. Первый вызов метода <codeph>replaceText()</codeph> заменяет первую строку (This is the wrong heading (Это неправильный заголовок)) текстом THIS IS THE HEADING FOR EVERYONE (ЭТО ЗАГОЛОВОК ДЛЯ ВСЕХ). Второй вызов метода вставляет слово CORRECT (ПРАВИЛЬНЫЙ) между THE и HEADING. Третий вызов метода удаляет слова FOR EVERYONE. Обратите внимание, что при каждом вызове метода<codeph>appendText()</codeph>изменяются текущие начальный и конечный индексы текста. Здесь будет отображаться только окончательный текст (после всех изменений).</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_replaceTextExample extends Sprite {

        public function TextField_replaceTextExample() {
            var outputText:TextField = new TextField();

            outputText.x = 10;
            outputText.y = 10;
            outputText.background = true;
            outputText.autoSize = TextFieldAutoSize.LEFT;
            
            outputText.appendText("This is the wrong heading");
            outputText.appendText("\n\n"); 
            outputText.appendText("This is the body of the text.");

            outputText.replaceText(0, 25, "THIS IS THE HEADING FOR EVERYONE");

            outputText.replaceText(12, 12, "CORRECT ");
            
            outputText.replaceText(27, 40, "");
            
           this.addChild(outputText);
         }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:TextField:setSelection"><apiName>setSelection</apiName><shortdesc>
	 Задает способ разметки текста с помощью индексов первого и последнего символов, которые указываются параметрами beginIndex и endIndex</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need to add an example.
	 
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для выделенного символа (например, первый символ – 0, второй символ – 1 и т.д.).
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для последнего символа в выделенном фрагменте.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Задает новый выделенный фрагмент текста.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Задает способ разметки текста с помощью индексов первого и последнего символов, которые указываются параметрами <codeph>beginIndex</codeph> и <codeph>endIndex</codeph> Если два параметра имеют одинаковые значения, этот метод задает точку вставки, как при использовании свойства <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_setSelectionExample.as"> В следующем примере, когда пользователь щелкает по любому месту текстового поля, выделяется предварительно заданный фрагмент текста (выделяются слова TEXT IN ALL CAPS (ТЕКСТ ЗАГЛАВНЫМИ БУКВАМИ)).
 
 <p>Два прослушивателя событий для текстового поля <codeph>myTextField</codeph> реагируют на щелчки и подъем мыши. Подъем мыши происходит, когда пользователь отпускает кнопку мыши, что обычно бывает после выделения текста. Обратите внимание, что по умолчанию текстовое поле допускает выделение текста. При щелчке по тексту вызывается метод <codeph>clickHandler()</codeph>. Когда мышь отпускается после выделения текста, вызывается метод <codeph>mouseUpHandler()</codeph>.</p>
 
 <p>И в <codeph>clickHandler()</codeph> и в <codeph>mouseUpHandler()</codeph> метод <codeph>setSelection()</codeph> задает для выделения только символы между индексами 54 и 70 (ТЕКСТ ЗАГЛАВНЫМИ БУКВАМИ).</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    
    public class TextField_setSelectionExample extends Sprite
    {
        private var myTextField:TextField = new TextField();

        public function TextField_setSelectionExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS is selected.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);
            myTextField.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);

            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

        private function mouseUpHandler(event:MouseEvent):void {
            myTextField.setSelection(54, 70);
        }

    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextField:setTextFormat"><apiName>setTextFormat</apiName><shortdesc>
	 Применяет форматирование текста, заданное параметром format, к указанному содержимому текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.setTextFormat, setTextFormat
 	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Этот метод невозможно использовать для текстового поля с таблицей стилей.
     </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>Заданный параметр <codeph>beginIndex</codeph> или <codeph>endIndex</codeph> находится за пределами диапазона.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>format</apiItemName><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier><apiDesc>Объект TextFormat, содержащий информацию о форматировании символов и абзацев.
	 
     </apiDesc></apiParam><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Необязательно; целое число, указывающее отсчитываемую от нуля позицию индекса, определяющую первый символ требуемого фрагмента текста.
	 
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>-1</apiData><apiDesc>Необязательно; целое число, указывающее первый символ после требуемого фрагмента текста. В соответствии с планом, если задать значения <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>, обновляется текст с <codeph>beginIndex</codeph> по <codeph>endIndex-1</codeph>.  
	 
	 <p>
	 <adobetable class="innertable">
	   
	   
	  
	   
	   
	 
	 <tgroup cols="2"><thead><row><entry>Применение</entry><entry>Описание</entry></row></thead><tbody><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat)</codeph></entry>
	 
	     <entry>Применяет свойства <codeph>textFormat</codeph> ко всему тексту в поле.</entry>
	   </row><row>
	 
	 <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int)</codeph></entry>
	 
	     <entry>Применяет свойства <codeph>textFormat</codeph> к тексту, начиная с положения <codeph>beginIndex</codeph>.</entry>
	   </row><row>
	     <entry><codeph>my_textField.setTextFormat(textFormat:TextFormat, beginIndex:int, endIndex:int)</codeph></entry>
	 	   <entry>Применяет свойства параметра <codeph>textFormat</codeph> к фрагменту текста с положения <codeph>beginIndex</codeph> до положения <codeph>endIndex-1</codeph>.</entry>
	   </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p>Обратите внимание, что текст, вставленный пользователем вручную или замененный методом <codeph>replaceSelectedText()</codeph>, получает форматирование текстового поля по умолчанию для нового текста, а не то, которое задано для точки вставки текста. Форматирование по умолчанию для нового текста в текстовом поле задается с помощью свойства <codeph>defaultTextFormat</codeph>.</p>
	 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Применяет форматирование текста.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Применяет форматирование текста, заданное параметром <codeph>format</codeph>, к указанному содержимому текстового поля. Значением параметра <codeph>format</codeph> должен быть объект TextFormat, определяющий необходимые изменения формата текста. К текстовому полю применяются только ненулевые свойства <codeph>format</codeph>. Свойства параметра <codeph>format</codeph>, имеющие значение <codeph>null</codeph>, не применяются. По умолчанию все свойства вновь созданного объекта TextFormat имеют значение <codeph>null</codeph>.
     <p><b>Примечание.</b> Этот метод не работает, если к текстовому полю применена таблица стилей.</p>
     
	 <p>Метод <codeph>setTextFormat()</codeph> изменяет форматирование текста, применяемое к диапазону символов или ко всему содержимому текстового поля. Чтобы применить свойства формата ко всему тексту в текстовом поле, не нужно задавать значения для <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>. Чтобы применить свойства формата к фрагменту текста, задайте значения для параметров <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>. Для определения значений индекса можно использовать свойство <codeph>length</codeph>.</p>
	 
	 <p>Объект TextFormat содержит два типа информации о форматировании: форматирование символов и форматирование абзацев. Каждый символ в текстовом поле может иметь собственные параметры формата символов, такие как имя и размер шрифта, полужирное или курсивное начертание.</p>
	 
	 <p>Для абзацев параметры форматирования всего абзаца определяются по его первому символу. В качестве примера можно назвать такие параметры форматирования, как левое, правое поле и отступ.</p>
	 
	 <p>Любой текст, вставленный пользователем вручную или замененный методом <codeph>replaceSelectedText()</codeph>, получает форматирование текстового поля по умолчанию для нового текста, а не то, которое задано для точки вставки текста. Форматирование по умолчанию для нового текста задается с помощью свойства <codeph>defaultTextFormat</codeph>.</p>
	 
	 </apiDesc><example conref="examples\TextField_setTextFormatExample.as"> В следующем примере, при щелчке по тексту для предварительно определенного фрагмента текста, TEXT IN ALL CAPS (ТЕКСТ ЗАГЛАВНЫМИ БУКВАМИ), происходит переключение с формата текста по умолчанию на новый формат и наоборот.
 
 <p>Добавляется прослушиватель событий для текстового поля <codeph>myTextField</codeph>, который реагирует на щелчки мышью, вызывая метод <codeph>clickHandler()</codeph>. В методе <codeph>clickHandler()</codeph> метод <codeph>getTextFormat()</codeph> возвращает текущий формат символа (индекс 55) из заданного фрагмента текста, который затем помещается в объект TextFormat с именем <codeph>currentTextFormat</codeph>. Инструкция <codeph>if</codeph> проверяет формат текста <codeph>currentTextFormat</codeph>, чтобы узнать, использует ли символ заданного диапазона новый формат (с размером шрифта 18). Если нет, новый формат изменяет размер на 18, задает красный цвет, а также применяет подчеркивание и курсив к диапазону символов 54-70 (ТЕКСТ ЗАГЛАВНЫМИ БУКВАМИ). Если символ в диапазоне использует новый формат, то формат диапазона возвращается к исходному формату по умолчанию для данного текстового поля.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;  
    import flash.text.TextFieldAutoSize;  
    import flash.events.MouseEvent;

    public class TextField_setTextFormatExample extends Sprite {
        private var myTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextField_setTextFormatExample() {
            myTextField.autoSize = TextFieldAutoSize.LEFT;
            myTextField.selectable = false;
            myTextField.background = true;
            myTextField.text = "No matter where you click on this text field only the TEXT IN ALL CAPS changes format.";

            myTextField.addEventListener(MouseEvent.CLICK, clickHandler);

            newFormat.color = 0xFF0000;
            newFormat.size = 18;
            newFormat.underline = true;
            newFormat.italic = true;
                
            this.addChild(myTextField);
        }

        private function clickHandler(event:MouseEvent):void {
            var currentTextFormat:TextFormat = myTextField.getTextFormat(55);
            
            if(currentTextFormat.size != 18) {
                myTextField.setTextFormat(newFormat, 54, 70);
            }
            else {
                myTextField.setTextFormat(myTextField.defaultTextFormat);
            }    
        }    
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextField:alwaysShowSelection:get"><apiName>alwaysShowSelection</apiName><shortdesc>
	При значении true и отсутствии фокуса на текстовом поле проигрыватель Flash Player выделяет фрагмент в текстовом поле серым цветом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField object, built-in class
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
    
	</apiDefaultValue></apiValueDef><apiDesc>
	При значении <codeph>true</codeph> и отсутствии фокуса на текстовом поле проигрыватель Flash Player выделяет фрагмент в текстовом поле серым цветом. При значении <codeph>false</codeph> и отсутствии фокуса на текстовом поле проигрыватель Flash Player не выделяет фрагмент в текстовом поле.
	
    </apiDesc><example conref="examples\TextField_alwaysShowSelection.as"> Скомпилируйте и запустите следующий файл. После запуска файла, выделите текст в каждом из двух текстовых полей, удерживая нажатой кнопку мыши, и обратите внимание на отличия выделения в этих полях (при изменении фокуса).
<codeblock>

    package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_alwaysShowSelection extends Sprite {
        public function TextField_alwaysShowSelection() {
            var label1:TextField = createCustomTextField(0, 20, 200, 20);
            label1.text = "This text is selected.";
            label1.setSelection(0, 9);
            label1.alwaysShowSelection = true;

            var label2:TextField = createCustomTextField(0, 50, 200, 20);
            label2.text = "Drag to select some of this text.";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x; result.y = y;
            result.width = width; result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:antiAliasType:get"><apiName>antiAliasType</apiName><shortdesc>
	 Тип сглаживания, применяемый для данного текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>This example creates two text fields and applies advanced anti-aliasing to the first one
	 only.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "This text uses advanced anti-aliasing.";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "This text uses normal anti-aliasing."
	 my_text2.antiAliasType = "normal";
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Используемый тип сглаживания.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Тип сглаживания, применяемый для данного текстового поля. Используйте константы <codeph>flash.text.AntiAliasType</codeph> для этого свойства. Этим параметром можно управлять, только если используется встроенный шрифт (свойство <codeph>embedFonts</codeph> имеет значение <codeph>true</codeph>). Параметр по умолчанию – <codeph>flash.text.AntiAliasType.NORMAL</codeph>.
	 
	 <p>В качестве значений этого свойства используйте следующие строковые значения:</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Строковое значение</entry><entry>Описание</entry></row></thead><tbody><row>
	 	<entry><codeph>flash.text.AntiAliasType.NORMAL</codeph></entry>
	 	<entry>Применяет обычное сглаживание текста. Значение соответствует типу сглаживания, который использовался в проигрывателе Flash Player 7 и более ранних версиях.</entry>
	   </row><row>
	   	<entry><codeph>flash.text.AntiAliasType.ADVANCED</codeph></entry>
	 	<entry>Применяет расширенное сглаживание, которое делает текст более четким. (Эта функция стала доступной в проигрывателе Flash Player 8.) Расширенное сглаживание обеспечивает высококачественную визуализацию шрифтов мелкого размера. Оно оптимально для приложений с большим объемом мелкого текста. Расширенное сглаживание не рекомендуется для шрифтов больше 48 размера.</entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link><link href="flash.text.xml#TextField/embedFonts"><linktext>flash.text.TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:autoSize:get"><apiName>autoSize</apiName><shortdesc>
	 Управляет автоматической настройкой размеров и выравниванием текстовых полей.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.autoSize, autoSize
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Заданный параметр <codeph>autoSize</codeph> не является элементом flash.text.TextFieldAutoSize.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Управляет автоматической настройкой размеров и выравниванием текстовых полей.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Управляет автоматической настройкой размеров и выравниванием текстовых полей. Допустимые значения констант <codeph>TextFieldAutoSize</codeph>: <codeph>TextFieldAutoSize.NONE</codeph> (по умолчанию), <codeph>TextFieldAutoSize.LEFT</codeph>, <codeph>TextFieldAutoSize.RIGHT</codeph> и <codeph>TextFieldAutoSize.CENTER</codeph>.
	 
	 <p>Если <codeph>autoSize</codeph> имеет значение <codeph>TextFieldAutoSize.NONE</codeph> (по умолчанию) размер не изменяется.</p>
	 
	 <p>Если <codeph>autoSize</codeph> имеет значение <codeph>TextFieldAutoSize.LEFT</codeph>, тексту задается выравнивание по левому краю, то есть левое поле текста остается неподвижным и изменение размера одной строки текстового поля осуществляется по правому полю. Если в тексте встречается разрыв строки (например, <codeph>\n</codeph> или <codeph>\r</codeph>), размер нижнего края также изменяется, чтобы вместить следующую строку текста. Если свойство <codeph>wordWrap</codeph> также имеет значение <codeph>true</codeph>, размер текстового поля изменяется только по нижнему краю, а правый край остается фиксированным.</p>
	 
	 <p>Если <codeph>autoSize</codeph> имеет значение <codeph>TextFieldAutoSize.RIGHT</codeph>, тексту задается выравнивание по правому краю, то есть правое поле текста остается неподвижным и изменение размера одной строки текстового поля осуществляется по левому полю. Если в тексте встречается разрыв строки (например, <codeph>\n или \r</codeph>), размер нижнего края также изменяется, чтобы вместить следующую строку текста. Если свойство <codeph>wordWrap</codeph> также имеет значение <codeph>true</codeph>, размер текстового поля изменяется только по нижнему краю, а левый край остается фиксированным.</p>
	 
	 <p>Если <codeph>autoSize</codeph> имеет значение <codeph>TextFieldAutoSize.CENTER</codeph>, текст обрабатывается с учетом выравнивания по центру, то есть изменение размера одной строки текстового поля равномерно распределяется по правому и левому полям. Если в тексте встречается разрыв строки (например, <codeph>\n</codeph> или <codeph>\r</codeph>), размер нижнего края также изменяется, чтобы вместить следующую строку текста. Если свойство <codeph>wordWrap</codeph> также имеет значение <codeph>true</codeph>, размер текстового поля изменяется только по нижнему краю, а левый и правый края остаются фиксированными.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFieldAutoSize"><linktext>flash.text.TextFieldAutoSize</linktext></link><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>flash.text.TextField.wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:background:get"><apiName>background</apiName><shortdesc>
	 Указывает, используется ли в текстовом поле фоновая заливка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.background, background
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Указывает, используется ли в текстовом поле фоновая заливка. При значении <codeph>true</codeph> фоновая заливка текстового поля используется. При значении <codeph>false</codeph> фоновая заливка текстового поля не используется. Цвет фона для текстового поля задается с помощью свойства <codeph>backgroundColor</codeph>.
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/backgroundColor"><linktext>flash.text.TextField.backgroundColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:backgroundColor:get"><apiName>backgroundColor</apiName><shortdesc>
	 Цвет фона текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.backgroundColor, backgroundColor, background Color
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Цвет фона текстового поля. Значение по умолчанию – <codeph>0xFFFFFF</codeph> (белый). Это свойство можно получить или задать, даже если в настоящее время фона нет, однако цвет будет видимым, только если свойству <codeph>background</codeph> текстового поля задано значение <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/background"><linktext>flash.text.TextField.background</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:border:get"><apiName>border</apiName><shortdesc>
	 Указывает, есть ли у текстового поля рамка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.border, border
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Указывает, есть ли у текстового поля рамка. При значении <codeph>true</codeph> текстовое поле имеет рамку. При значении <codeph>false</codeph> текстовое поле не имеет рамки. Цвет рамки задается с помощью свойства <codeph>borderColor</codeph>.
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/borderColor"><linktext>flash.text.TextField.borderColor</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:borderColor:get"><apiName>borderColor</apiName><shortdesc>
	 Цвет рамки текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.borderColor, borderColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Цвет рамки текстового поля. Значение по умолчанию – <codeph>0x000000</codeph> (черный). Это свойство можно получить или задать, даже если в настоящее время рамки нет, однако цвет будет видимым, только если свойству <codeph>border</codeph> текстового поля задано значение <codeph>true</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/border"><linktext>flash.text.TextField.border</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:bottomScrollV:get"><apiName>bottomScrollV</apiName><shortdesc>
	 Целое число (индекс, отсчитываемый от 1), соответствующее самой нижней строке, которую видно в заданном текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.bottomScrollV, bottomScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Целое число, указывающее самую нижнюю строку в текстовом поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Целое число (индекс, отсчитываемый от 1), соответствующее самой нижней строке, которую видно в заданном текстовом поле. Представьте, что текстовое поле – это окно на блоке текста. Свойство <codeph>scrollV</codeph> представляет собой отсчитываемый от единицы индекс самой верхней видимой строки в окне.
	 
	 <p>Весь текст между линиями, заданными параметрами <codeph>scrollV</codeph> и <codeph>bottomScrollV</codeph> в данный момент отображается в текстовом поле.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:caretIndex:get"><apiName>caretIndex</apiName><shortdesc>
	 Индекс точки вставки (каре).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Возвращает для мигающей точки вставки значение индекса, начинающегося с нуля.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Индекс точки вставки (каре). Если точка вставки не отображается, значением является положение, которое она бы занимала, если бы поле было в фокусе (обычно это последнее место вставки или 0, если поле не было в фокусе).
	 
	 <p>Индексы выделенного фрагмента отсчитываются от нуля (например, первая позиция – 0, вторая – 1 и т. д.).</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> В данном примере создается и заполняется текстом экземпляр TextField. Назначается прослушиватель событий, чтобы при щелчке по объекту TextField вызывался метод <codeph>printCursorPosition</codeph>. В данном случае значения свойств <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> выводятся на экран.
 
 <p>Запустите этот пример и попробуйте щелкнуть мышью в текстовом поле TextField, чтобы выделить текст. После этого щелкните поле, не выделяя текст. При щелчке по тексту без выделения, свойство <codeph>caretIndex</codeph> указывает местоположение точки вставки, а свойства <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> имеют то же значение, что <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:condenseWhite:get"><apiName>condenseWhite</apiName><shortdesc>
	 Логическое значение, определяющее, следует ли удалять лишние разделители (пробелы, разрывы строк и т.д.) в текстовом поле с текстом HTML.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>textfield, text, HTML
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Логическое значение, определяющее, удаляются ли лишние пробелы в текстовом поле с HTML-текстом.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Логическое значение, определяющее, следует ли удалять лишние разделители (пробелы, разрывы строк и т.д.) в текстовом поле с текстом HTML. Значение по умолчанию <codeph>false</codeph>. Свойство <codeph>condenseWhite</codeph> влияет только на текст, определенный с помощью свойства <codeph>htmlText</codeph>, а не с помощью свойства <codeph>text</codeph>. Если текст определен посредством свойства <codeph>text</codeph>, <codeph>condenseWhite</codeph> игнорируется.
	 
	 <p>Если свойству <codeph>condenseWhite</codeph> присваивается значение <codeph>true</codeph>, необходимо использовать стандартные команды HTML (например, <codeph>&lt;BR></codeph> и <codeph>&lt;P></codeph> ), чтобы поместить в текстовое поле разрывы строк.</p>
	 
	 <p>Свойство <codeph>condenseWhite</codeph> задается перед свойством <codeph>htmlText</codeph>.</p>
	 
	 
	 </apiDesc><example conref="examples\TextField_condenseWhite.as"> В следующем примере демонстрируется различие между использованием свойства <codeph>condenseWhite</codeph> в значении <codeph>false</codeph> и в значении <codeph>true</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_condenseWhite extends Sprite {
        public function TextField_condenseWhite() {
            var tf1:TextField = createCustomTextField(0, 0, 200, 50);
            tf1.condenseWhite = false;
            tf1.htmlText = "keep    on\n\ttruckin'";
            
            var tf2:TextField = createCustomTextField(0, 120, 200, 50);
            tf2.condenseWhite = true;
            tf2.htmlText = "keep    on\n\ttruckin'";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:defaultTextFormat:get"><apiName>defaultTextFormat</apiName><shortdesc>
	 Определяет формат, применяемый к новому вставленному тексту, такому как тексту, введенному пользователем, или тексту, вставленному с использованием метода replaceSelectedText().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.defaultTextFormat, defaultTextFormat
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:TextFormat</apiValueClassifier><apiException><apiDesc>Этот метод невозможно использовать для текстового поля с таблицей стилей.
	  
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>Задает формат для только что вставленного текста.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет формат, применяемый к новому вставленному тексту, такому как тексту, введенному пользователем, или тексту, вставленному с использованием метода <codeph>replaceSelectedText()</codeph>.
	 
	 <p><b>Примечание.</b> При выборе символов, которые будут заменены с помощью методов <codeph>setSelection()</codeph> и <codeph>replaceSelectedText()</codeph>, свойство <codeph>defaultTextFormat</codeph> будет применено, только если текст был выделен полностью, включая последний символ. Далее приводится пример:</p>
	 <pre>
	 var my_txt:TextField new TextField();
	 my_txt.text = "Flash Macintosh version";
	 var my_fmt:TextFormat = new TextFormat();
	 my_fmt.color = 0xFF0000;
	 my_txt.defaultTextFormat = my_fmt;
	 my_txt.setSelection(6,15); // partial text selected - defaultTextFormat not applied
	 my_txt.setSelection(6,23); // text selected to end - defaultTextFormat applied
	 my_txt.replaceSelectedText("Windows version");
	 </pre>
	 
	 <p>При обращении к свойству <codeph>defaultTextFormat</codeph> возвращается объект TextFormat, все свойства которого определены. Ни одно из свойств не имеет значения <codeph>null</codeph>.</p>
     <p><b>Примечание.</b> Это свойство невозможно задать, если к текстовому полю применена таблица стилей.</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/replaceSelectedText()"><linktext>flash.text.TextField.replaceSelectedText()</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:displayAsPassword:get"><apiName>displayAsPassword</apiName><shortdesc>
	 Показывает, является ли текстовое поле полем пароля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.password, password
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Указывает, являются ли вводимые символы скрытыми.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Показывает, является ли текстовое поле полем пароля. Если это свойство имеет значение <codeph>true</codeph>, текстовое поле обрабатывается как поле ввода пароля и скрывает вводимые символы, показывая звездочки вместо действительных символов. При значении <codeph>false</codeph> текстовое поле не обрабатывается как поле пароля. В режиме пароля команды «Вырезать» и «Копировать», а также соответствующие им комбинации клавиш не работают. Этот механизм защиты не позволяет недобросовестным пользователям использовать комбинации клавиш с целью получения пароля на компьютере, оставленном без присмотра.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:embedFonts:get"><apiName>embedFonts</apiName><shortdesc>
	 Определяет, должна ли выполняться визуализация с использованием структур встроенных шрифтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.embedFonts, embedFonts
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Выполняет визуализацию текстового поля с использованием встроенных шрифтов или шрифтов устройства.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет, должна ли выполняться визуализация с использованием структур встроенных шрифтов. При значении <codeph>false</codeph> проигрыватель Flash Player визуализирует текстовое поле с использованием шрифтов устройства.
	 
	 <p>Если свойству <codeph>embedFonts</codeph> текстового поля задано значение <codeph>true</codeph>, необходимо указать для текста шрифт с помощью свойства <codeph>font</codeph> объекта TextFormat, примененного к текстовому полю. Если указанный шрифт не встроен в SWF-файл, текст не отображается.</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#Font/enumerateFonts()"><linktext>Font.enumerateFonts()</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:gridFitType:get"><apiName>gridFitType</apiName><shortdesc>
	 Тип подгонки к сетке, применяемый для этого текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example shows three text fields that use the
	 different <code>flash.text.GridFitType</code> settings.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 9.5, 10, 400, 100);
	 my_text1.text = "this.gridFitType = none";
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "none";
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 9.5, 40, 400, 100);
	 my_text2.text = "this.gridFitType = advanced";
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 9.5, 70, 400, 100);
	 my_text3.text = "this.gridFitType = subpixel";
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "subpixel";
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>pixel
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Используемые тип подгонки к сетке.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Тип подгонки к сетке, применяемый для этого текстового поля. Это свойство применяется, только если свойство <codeph>flash.text.AntiAliasType</codeph> текстового поля имеет значение <codeph>flash.text.AntiAliasType.ADVANCED</codeph>.
	 
	 <p>Используемый тип подгонки к сетке определяет, подгоняет ли проигрыватель Flash Player жирные горизонтальные или вертикальные линии к пиксельной или субпиксельной сетке, или совсем не выполняет подгонку.</p>
	 
	 <p>Для свойства <codeph>flash.text.GridFitType</codeph> можно использовать следующие строковые значения.</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>Строковое значение</entry><entry>Описание</entry></row></thead><tbody><row>
	     <entry><codeph>flash.text.GridFitType.NONE</codeph></entry>
	     <entry>Задает отсутствие подгонки к сетке. Горизонтальные и вертикальные линии в глифах не подгоняются к пиксельной сетке. Этот параметр рекомендуется для анимации или для шрифтов большого размера.</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.PIXEL</codeph></entry>
	     <entry>Задает подгонку жирных горизонтальных и вертикальных линий к пиксельной сетке. Этот параметр применяется только к текстовым полям с выравниванием по левому краю. Для использования этого параметра свойство <codeph>flash.display.AntiAliasType</codeph> текстового поля должно иметь значение <codeph>flash.text.AntiAliasType.ADVANCED</codeph>. Этот параметр, как правило, дает максимальную четкость для текста с выравниванием по левому краю.</entry>
	   </row><row>
	     <entry><codeph>flash.text.GridFitType.SUBPIXEL</codeph></entry>
	     <entry>Задает подгонку горизонтальных и вертикальных линий к субпиксельной сетке на ЖК-мониторе. Для использования этого параметра свойство <codeph>flash.text.AntiAliasType</codeph> текстового поля должно иметь значение <codeph>flash.text.AntiAliasType.ADVANCED</codeph>. Параметр <codeph>flash.text.GridFitType.SUBPIXEL</codeph> обычно целесообразен для динамического текста с выравниванием по правому краю или по центру и в некоторых случаях позволяет найти оптимальный баланс качеством анимации и текста.</entry>
	   </row></tbody></tgroup></adobetable>
	 
     </apiDesc><example conref="examples\TextField_gridFitType.as"> В следующем примере показано три текстовых поля с разными параметрами свойства <codeph>gridFitType</codeph>. При тестировании этого примера, оцените разницу в четкости первых двух строк. Также обратите внимание на оптимальное использование <codeph>GridFitType.PIXEL</codeph> для текста с выравниванием по левому краю и <codeph>GridFitType.SUBPIXEL</codeph> для текста с выравниванием по правому краю.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;

    public class gridFitTypeExample extends Sprite
    {
        public function gridFitTypeExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=12;

    var tf1:TextField = createCustomTextField(0,0,format1,"NONE",TextFieldAutoSize.LEFT,GridFitType.NONE);
    
    var tf2:TextField = createCustomTextField(0,30,format1,"PIXEL",TextFieldAutoSize.LEFT,GridFitType.PIXEL);

    var tf3:TextField = createCustomTextField(300,60,format1,"SUBPIXEL",TextFieldAutoSize.RIGHT,GridFitType.SUBPIXEL);

        }
        private function createCustomTextField(x:Number,y:Number,fm:TextFormat,tl:String,tfs:String,gft:String):TextField 
        {
            var result:TextField = new TextField();
            result.x=x;
            result.y=y;
            result.embedFonts=true;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.text="This text uses a gridFitType of " + tl;
            result.autoSize=tfs;
        result.gridFitType=gft;
            result.setTextFormat(fm);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#GridFitType"><linktext>flash.text.GridFitType</linktext></link><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:htmlText:get"><apiName>htmlText</apiName><shortdesc>
	 Содержит HTML-представление содержимого текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.htmlText, htmlText
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>HTML-представление содержимого текстового поля.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Содержит HTML-представление содержимого текстового поля. 
	 
	 <p>Проигрыватель Flash Player поддерживает следующие теги HTML.</p>
	 
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 Тег
	 </entry><entry>
	 Описание
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 Тег привязки
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;a></codeph> создает гипертекстовую ссылку и поддерживает следующие атрибуты.
	 <ul>
	 
	 <li>
	 <codeph>target</codeph>: указывает имя целевого окна, где загружается страница. Возможные значения: <codeph>_self</codeph>, <codeph>_blank</codeph>, <codeph>_parent</codeph> и <codeph>_top</codeph>. Вариант <codeph>_self</codeph> задает текущий фрейм текущего окна, <codeph>_blank</codeph> задает новое окно, <codeph>_parent</codeph> задает вышестоящий элемент текущего фрейма, а <codeph>_top</codeph> задает фрейм верхнего уровня текущего окна. 
	 </li>
	 
	 <li>
	 <codeph>href</codeph>: задает URL-адрес или событие ActionScript <codeph>link</codeph>. URL-адрес может быть абсолютным или указанным относительно SWF-файла, загружающего страницу. Абсолютная ссылка на URL-адрес выглядит так: <codeph>http://www.adobe.com</codeph>. А вот пример относительной ссылки: <codeph>/index.html</codeph>. Абсолютные URL-адреса должны иметь префикс http://, иначе проигрыватель Flash Player или AIR воспримет их как относительные. Можно использовать событие <codeph>link</codeph>, чтобы ссылка выполняла функцию ActionScript в SWF-файле, а не открывала URL-адрес. Для определения события <codeph>link</codeph> используйте схему событий, а http в атрибуте <codeph>href</codeph>. То есть, <codeph>href="event:myText"</codeph> вместо <codeph>href="http://myURL"</codeph>. Когда пользователь щелкает гипертекстовую ссылку, содержащую схему события, текстовое поле отправляет объект TextEvent с именем <codeph>link</codeph>, свойство <codeph>text</codeph> которого имеет значение <codeph>myText</codeph>. После этого можно создать функцию ActionScript, которая будет выполняться при отправке события TextEvent с именем link. Также для тегов привязки можно определить стили <codeph>a:link</codeph>, <codeph>a:hover</codeph> и <codeph>a:active</codeph> с помощью таблиц стилей.
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег полужирного начертания
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;b></codeph> изменяет начертание текста на полужирное. Для используемого шрифта должно быть доступно полужирное написание.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег разрыва
	 </entry>
	 <entry>
	 Тег <codeph>&lt;br></codeph> создает разрыв строки в текстовом поле. Чтобы использовать этот тег, определите текстовое поле как многострочное.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег шрифта
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;font></codeph> задает шрифт или список шрифтов для отображения текста. Тег шрифта поддерживает следующие атрибуты.
	 <ul>
	 
	 <li>
	 <codeph>color</codeph>: поддерживаются только шестнадцатеричные значения цветов (<codeph>#FFFFFF</codeph>). 
	 </li>
	 
	 <li>
	 <codeph>face</codeph>: задает имя используемого шрифта. Как показано в следующем примере, можно задать список разделенных запятыми имен шрифтов, тогда проигрыватель Flash Player выбирает первый доступный шрифт. Если заданный шрифт не установлен в локальной компьютерной системе или не встроен в SWF-файл, проигрыватель выбирает подстановочный шрифт. 
	 </li>
	 
	 <li>
	 <codeph>size</codeph>: задает размер шрифта. Можно использовать абсолютные размеры в пикселях, такие как 16 или 18, либо относительные кегли, такие как +2 или -4. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег изображения
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;img></codeph> позволяет встраивать в текстовые поля внешние файлы изображений (JPEG, GIF, PNG), SWF-файлы и фрагменты роликов. Текст автоматически обтекает изображения, встроенные в текстовые поля. Необходимо определить текстовое поле как многострочное, чтобы текст обтекал изображение. 
	 
	  <p>Тег <codeph>&lt;img></codeph> поддерживает следующие атрибуты. </p>
	 
	 <ul>
	 
	 <li>
	 <codeph>src</codeph>: задает URL-адрес на изображение или SWF-файл, либо идентификатор связи для символа фрагмента ролика в библиотеке. Это обязательный атрибут, все остальные атрибуты – необязательные. Внешние файлы (JPEG, GIF, PNG и SWF) отображаются только после завершения загрузки. 
	 </li>
	 
	 <li>
	 <codeph>width</codeph>: ширина в пикселях вставляемого изображения, SWF-файла или фрагмента ролика. 
	 </li>
	 
	 <li>
	 <codeph>height</codeph>: высота в пикселях вставляемого изображения, SWF-файла или фрагмента ролика. 
	 </li>
	 
	 <li>
	 <codeph>align</codeph>: задает для встраиваемого изображения выравнивание по горизонтали в текстовом поле. Допускаются значения <codeph>left</codeph> (по левому краю) и <codeph>right</codeph> (по правому краю). Значение по умолчанию – <codeph>left</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>hspace</codeph>: задает величину пробела по горизонтали, окружающего изображение, где не отображается текст. Значением по умолчанию является 8. 
	 </li>
	 
	 <li>
	 <codeph>vspace</codeph>: задает величину пробела по вертикали, окружающего изображение, где не отображается текст. Значением по умолчанию является 8.  
	 </li>
	 
	 <li>
	 <codeph>id</codeph>: задает имя экземпляра фрагмента ролика (созданного проигрывателем Flash Player), который содержит встраиваемое изображение SWF-файл или фрагмент ролика. Этот подход используется для управления встроенным содержимым с помощью ActionScript. 
	 </li>
	 
	 <li>
	 <codeph>checkPolicyFile</codeph>: предписывает проигрывателю Flash Player проверять файл политик для URL-адресов на сервере, связанном с доменом изображения. Если файл политики существует, SWF-файлы в указанном в нем домене могут обращаться к данным загруженного изображения, например путем вызова метода <codeph>BitmapData.draw()</codeph> в котором данное изображение указано в качестве параметра <codeph>source</codeph>. Дополнительную информацию см. в главе «Безопасность Flash Player» руководства <i>Программирование на ActionScript 3.0</i>.
	 </li>
	 
	 </ul>
	  <p>В текстовом поле проигрыватель Flash Player отображает встроенное мультимедийное содержимое в полном размере. Чтобы задать размеры встраиваемого мультимедийного содержимого, используйте атрибуты <codeph>height</codeph> и <codeph>width</codeph> тега <codeph>&lt;img></codeph>. </p>
	 
	  <p>Как правило, изображение, встроенное в текстовое поле отображается на следующей строке после тега <codeph>&lt;img></codeph>. Однако когда тег<codeph>&lt;img></codeph> является первым символом в текстовом поле, изображение показывается на его первой строке. </p>
	 
	 <p>В отношении содержимого AIR в изолированной программной среде безопасности приложения AIR игнорирует теги <codeph>img</codeph> в HTML-содержимом объектов TextField в ActionScript. Это позволяет избежать фишинг-атак.</p>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег курсива
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;i></codeph> отображает заключенный в него текст курсивом. Для используемого шрифта должно быть доступно курсивное начертание.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег элемента списка
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;li></codeph> помещает маркер перед заключенным в него текстом. <b>Примечание.</b> Так как приложение Flash Player и AIR не распознают теги упорядоченного и неупорядоченного списка (<codeph>&lt;ol></codeph> и <codeph>&lt;ul></codeph>), они не модифицируют визуализацию списка. Все списки являются неупорядоченными, и для всех элементов списка используются маркеры.
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег абзаца
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;p></codeph> создает новый абзац. Чтобы использовать этот тег, необходимо определить текстовое поле как многострочное. Тег <codeph>&lt;p></codeph> поддерживает следующие атрибуты.
	 <ul>
	 
	 <li>
	 align: задает выравнивание текста в абзаце. Допускаются следующие значения: <codeph>left</codeph>, <codeph>right</codeph>, <codeph>justify</codeph> и <codeph>center</codeph>. 
	 </li>
	 
	 <li>
	 class: задает класс стиля CSS, определенный объектом flash.text.StyleSheet. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег диапазона
	 </entry>
	 
	 <entry>
	 
	 Тег <codeph>&lt;span></codeph> доступен только при использовании вместе со стилями текста CSS. Он поддерживает следующий атрибут.
	 
	 <ul>
	 
	 <li>
	 class: задает класс стиля CSS, определенный объектом flash.text.StyleSheet. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег формата текста
	 </entry>
	 
	 <entry>
	  <p>Тег <codeph>&lt;textformat></codeph> позволяет использовать в текстовых полях подгруппу свойств форматирования абзаца класса TextFormat, включая межстрочный интервал, отступы, поля и точки табуляции. Теги <codeph>&lt;textformat></codeph> комбинировать с встроенными тегами HTML. </p>
	 
	  <p>Тег <codeph>&lt;textformat></codeph> имеет следующие атрибуты. </p>
	 <ul>
	 
	 <li>
	 <codeph>blockindent</codeph>: задает отступ блока текста в точках; соответствует свойству <codeph>TextFormat.blockIndent</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>indent</codeph>: задает отступ от левого поля для первого символа абзаца; соответствует свойству <codeph>TextFormat.indent</codeph>. Допускаются как положительные, так и отрицательные числа. 
	 </li>
	 
	 <li>
	 <codeph>leading</codeph>: задает величину интервала (пробела по вертикали) между строками; соответствует свойству <codeph>TextFormat.leading</codeph>. Допускаются как положительные, так и отрицательные числа. 
	 </li>
	 
	 <li>
	 <codeph>leftmargin</codeph>: задает левое поле абзаца в точках; соответствует свойству <codeph>TextFormat.leftMargin</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>rightmargin</codeph>: задает правое поле абзаца в точках; соответствует свойству <codeph>TextFormat.rightMargin</codeph>. 
	 </li>
	 
	 <li>
	 <codeph>tabstops</codeph>: задает пользовательские точки табуляции в качестве массива неотрицательных целых чисел; соответствует свойству <codeph>TextFormat.tabStops</codeph>. 
	 </li>
	 
	 </ul>
	 
	 </entry>
	 </row><row>
	 
	 <entry>
	 Тег подчеркивания
	 </entry>
	 
	 <entry>
	 Тег <codeph>&lt;u></codeph> подчеркивает заключенный в него текст.
	 </entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>Flash Player и AIR поддерживают следующие HTML-сущности:</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry>
	 Сущность
	 </entry><entry>
	 Описание
	 </entry></row></thead><tbody><row>
	 
	 <entry>
	 
	 &amp;amp;lt;	
	 
	 </entry>
	 
	 <entry>
	 
	 &lt; (знак меньше)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;gt;	
	 
	 </entry>
	 
	 <entry>
	 
	 > (знак больше)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;amp;	
	 
	 </entry>
	 
	 <entry>
	 
	 &amp; (ampersand)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 &amp;amp;quot;	
	 
	 </entry>
	 
	 <entry>
	 
	 " (двойные кавычки)
	 
	 </entry>
	 
	 </row><row>
	 
	 <entry>
	 
	 &amp;amp;apos;	
	 
	 </entry>
	 
	 <entry>
	 
	 ' (апостроф, одинарная кавычка)
	 
	 </entry>
	 
	 </row></tbody></tgroup></adobetable>
	  
	  <p>Flash Player и AIR поддерживают явные коды символов, например, &amp;#38 (амперсанд ASCII) и &amp;#x20AC (символ € в Юникод). </p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> В следующем примере создается объект TextField с именем <codeph>tf1</codeph>, свойству <codeph>text</codeph> которого назначается строка в формате HTML. Когда отслеживается его свойство <codeph>htmlText</codeph>, выводится строка в формате HTML, к которой проигрыватель Flash Player автоматически добавляет дополнительные теги, например &lt;P> и &lt;FONT>. Когда отслеживается значение свойства <codeph>text</codeph>, отображается неотформатированная строка без тегов HTML.
 
 <p>По аналогии, эти же действия выполняются с другим объектом TextField с именем <codeph>tf2</codeph>, но свойству <codeph>styleSheet</codeph> поля <codeph>tf2</codeph> назначается объект StyleSheet, прежде чем задается свойство <codeph>htmlText</codeph>. В этом случае, когда отслеживается свойство <codeph>htmlText</codeph>, оно включает только тот текст HTML, который был изначально назначен свойству <codeph>htmlText</codeph>, демонстрируя, что проигрыватель Flash Player не добавлял других тегов.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/text"><linktext>flash.text.TextField.text</linktext></link><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link><link href="flash.events.xml#TextEvent"><linktext>flash.events.TextEvent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:length:get"><apiName>length</apiName><shortdesc>
	 Число символов в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.length, length
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Число символов в текстовом поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Число символов в текстовом поле. Символы, такие как знаки табуляции (<codeph>\t</codeph>), учитываются как один символ.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxChars:get"><apiName>maxChars</apiName><shortdesc>
	 Введенное пользователем максимальное число символов, которое может содержать текстовое поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxChars, maxChars
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>0
	 
	 </apiDefaultValue><apiTipTexts><apiTipText>Максимальное количество символов, которое может содержать текстовое поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Введенное пользователем максимальное число символов, которое может содержать текстовое поле. Сценарий может вставить больше текста, чем допускает <codeph>maxChars</codeph>. Свойство <codeph>maxChars</codeph> указывает только количество символов, которые может ввести пользователь. Если это свойство имеет значение <codeph>0</codeph>, пользователь может ввести любое количество символов.
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:maxScrollH:get"><apiName>maxScrollH</apiName><shortdesc>
	 Максимальное значение scrollH.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollH, maxScrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Максимальное значение scrollH.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Максимальное значение <codeph>scrollH</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:maxScrollV:get"><apiName>maxScrollV</apiName><shortdesc>
	 Максимальное значение scrollV.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.maxScrollV, maxScrollV
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Максимальное значение <codeph>scrollV</codeph>.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Максимальное значение <codeph>scrollV</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:mouseWheelEnabled:get"><apiName>mouseWheelEnabled</apiName><shortdesc>
	 Логическое значение, определяющее, выполняет ли проигрыватель Flash Player автоматическую прокрутку многострочных текстовых полей, когда пользователь щелкает текстовое поле и вращает колесико мыши.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.mouseWheelEnabled, mouseWheelEnabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Показывает, выполняет ли проигрыватель Flash Player автоматическую прокрутку многострочных текстовых полей.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Логическое значение, определяющее, выполняет ли проигрыватель Flash Player автоматическую прокрутку многострочных текстовых полей, когда пользователь щелкает текстовое поле и вращает колесико мыши. Значение по умолчанию – <codeph>true</codeph>. Это свойство целесообразно, если требуется предотвратить прокрутку текстового поля с помощью колесика мыши или внедрить собственную функцию прокрутки текста.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:multiline:get"><apiName>multiline</apiName><shortdesc>
	 Показывает, является ли текстовое поле многострочным.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.multiline, multiline
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Показывает, является ли текстовое поле многострочным.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Показывает, является ли текстовое поле многострочным. Если значение – <codeph>true</codeph>, текстовое поле многострочное, а если значение – <codeph>false</codeph>, то однострочное. В поле типа <codeph>TextFieldType.INPUT</codeph> значение <codeph>multiline</codeph> определяет, создает ли клавиша <codeph>Enter</codeph> новую строку (при значении <codeph>false</codeph> нажатие клавиши <codeph>Enter</codeph> игнорируется). Если вставить текст в поле <codeph>TextField</codeph> со свойством <codeph>multiline</codeph> в значении <codeph>false</codeph>, новые строки опускаются.

	 
     </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/numLines"><linktext>numLines</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:numLines:get"><apiName>numLines</apiName><shortdesc>
	 Определяет число строк текста в многострочном текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.numLines, numLines
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Определяет число строк текста в многострочном текстовом поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет число строк текста в многострочном текстовом поле. Если свойство <codeph>wordWrap</codeph> имеет значение <codeph>true</codeph>, то при переносе текста количество строк увеличивается.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/multiline"><linktext>multiline</linktext></link><link href="flash.text.xml#TextField/wordWrap"><linktext>wordWrap</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:restrict:get"><apiName>restrict</apiName><shortdesc>
	 Определяет набор символов, которые могут быть введены пользователем в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.restrict, restrict
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>null
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Набор символов, которые пользователь может вводить в текстовом поле.
	 

	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Определяет набор символов, которые могут быть введены пользователем в текстовом поле. Если свойству <codeph>restrict</codeph> присвоено значение <codeph>null</codeph>, можно ввести любой символ. Если в качестве значения свойства <codeph>restrict</codeph> установлена пустая строка, ввод символов невозможен. Если значение <codeph>restrict</codeph> – это строка, состоящая из символов, в текстовое поле можно вводить только символы из этой строки. Строка сканируется слева направо. Диапазон определяется с помощью символа (-). Ограничивается только взаимодействие пользователей; с помощью сценариев в текстовом поле можно ввести любой текст. <ph outputclass="flashonly">Это свойство не синхронизируется с параметрами встраивания шрифтов в инспекторе свойств.</ph>
	 
	 <p>Если строка начинается с символа вставки (^), все символы изначально поддерживаются, а последующие символы в строке исключаются из набора поддерживаемых символов. Если строка не начинается с символа вставки (^), символы изначально не поддерживаются, а последующие символы в строке включаются в набор поддерживаемых символов.</p>
	 
	 <p>В следующем примере в текстовое поле можно вводить только заглавные буквы, пробелы и цифры.</p>
	 <pre>
	 my_txt.restrict = "A-Z 0-9";
	 </pre>
	 <p>В следующем примере включены все символы, но исключены строчные буквы.</p>
	 <pre>
	 my_txt.restrict = "^a-z";
	 </pre>
	 <p>Можно использовать обратную косую черту для ввода символа ^ или -. Допускаются следующие последовательности с обратной косой чертой: \-, \^ или \\. Обратная косая черта должна быть фактическим символом в строке, потому, когда она задана в коде ActionScript, необходимо использовать двойную обратную косую черту. Например, следующий код включает только дефис (-) и символ вставки (^).</p>
	 <pre>
	 my_txt.restrict = "\\-\\^";
	 </pre>
	 <p>Символ ^ может использоваться в любом месте строки для переключения между включенными и исключенными символами. Следующий код включает только заглавные буквы, но исключает заглавную букву Q.</p>
	 <pre>
	 my_txt.restrict = "A-Z^Q";
	 </pre>
	 <p>Для создания строк <codeph>restrict</codeph> можно использовать управляющую последовательность <codeph>\u</codeph>. Следующий код включает только символы с ASCII 32 (пробел) до ASCII 126 (тильда).</p>
	 <pre>
     my_txt.restrict = "\u0020-\u007E";
	 </pre>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextField:scrollH:get"><apiName>scrollH</apiName><shortdesc>
	 Текущее положение горизонтальной прокрутки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollH, scrollH
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Текущее положение горизонтальной прокрутки.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Текущее положение горизонтальной прокрутки. Если свойство <codeph>scrollH</codeph> имеет значение 0, текст не прокручивается по горизонтали. Значением этого свойства является целое число, представляющее положение по горизонтали в пикселях.
	 
	 
	 <p>Единицей измерения горизонтальной прокрутки являются пиксели, а вертикальной – строки. Горизонтальная прокрутка измеряется в пикселях, так как большинство распространенных шрифтов расставляются пропорционально, то есть символы могут иметь разную ширину. Проигрыватель Flash Player выполняет вертикальную прокрутку по строкам, так как пользователи обычно хотят видеть строку текста целиком, а не частично. Даже если в строке используются разные шрифты, ее высота регулируется в соответствии с самым большим используемым шрифтом.</p>
	 
	 <p><b>Примечание. </b>Значение свойства <codeph>scrollH</codeph> отсчитывается от нуля, а значение свойства <codeph>scrollV</codeph> (для вертикальной прокрутки) – от единицы.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/maxScrollH"><linktext>flash.text.TextField.maxScrollH</linktext></link><link href="flash.text.xml#TextField/scrollV"><linktext>flash.text.TextField.scrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:scrollV:get"><apiName>scrollV</apiName><shortdesc>
	 Вертикальное положение текста в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.scrollV, scroll
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Вертикальное положение текста в текстовом поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Вертикальное положение текста в текстовом поле. Свойство <codeph>scrollV</codeph> целесообразно для направления пользователей к определенному абзацу в длинном тексте или для создания прокручиваемых текстовых полей.
	 
	 <p>Единицей измерения вертикальной прокрутки являются строки, а горизонтальной – пиксели. Если первая отображаемая строка является первой строкой в текстовом поле, то свойство scrollV имеет значение 1 (не 0). Горизонтальная прокрутка измеряется в пикселях, так как большинство шрифтов расставляются пропорционально, то есть символы могут иметь разную ширину. Flash выполняет вертикальную прокрутку по строкам, так как пользователи обычно хотят видеть строку текста целиком, а не частично. Даже если строка содержит разные шрифты, ее высота регулируется в соответствии с самым большим используемым шрифтом.</p>
	 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/scrollH"><linktext>flash.text.TextField.scrollH</linktext></link><link href="flash.text.xml#TextField/maxScrollV"><linktext>flash.text.TextField.maxScrollV</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectable:get"><apiName>selectable</apiName><shortdesc>
	 Логическое значение, определяющее, можно ли выбрать текстовое поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.selectable, selectable
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
     
         </apiDefaultValue><apiTipTexts><apiTipText>Указывает, можно ли выбирать текстовое поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Логическое значение, определяющее, можно ли выбрать текстовое поле. Значение <codeph>true</codeph> указывает на то, что текст можно выделить. Свойство <codeph>selectable</codeph> управляет возможностью выделения содержимого текстового поля, а не возможностью его редактирования. Динамическое текстовое поле может поддерживать выделение даже при отсутствии возможности редактирования. Если динамическое текстовое поле не поддерживает выделения, пользователь не может выделять его содержимое.
	 
	 <p>Если свойство <codeph>selectable</codeph> имеет значение <codeph>false</codeph>, содержимое текстового поля не реагирует на команды выделения мыши и клавиатуры, и его нельзя копировать с использованием команды «Копировать». Если свойство <codeph>selectable</codeph> имеет значение <codeph>true</codeph>, содержимое текстового поля можно выделить с помощью мыши и клавиатуры, и его можно копировать с использованием команды «Копировать». Таким образом можно выделить текст, даже если текстовое поле является динамическим, а не полем ввода. </p>
	 
     </apiDesc><example conref="examples\TextField_selectable.as"> В следующем примере создаются два динамических текстовых поля: одно со свойством <codeph>selectable</codeph> в значении <codeph>true</codeph>, а другое со свойством <codeph>selectable</codeph> в значении <codeph>false</codeph>. Выполняя этот пример, попробуйте выделить текст в этих полях с помощью мыши или клавиатуры.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class selectableExample extends Sprite
    {
        public function selectableExample()
        {
    var tf1:TextField = createCustomTextField(10, 10);
    tf1.text="This text can be selected";
    tf1.selectable=true;

    var tf2:TextField = createCustomTextField(10, 30);
    tf2.text="This text cannot be selected";
    tf2.selectable=false;
        }

        private function createCustomTextField(x:Number, y:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.autoSize=TextFieldAutoSize.LEFT;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionBeginIndex:get"><apiName>selectionBeginIndex</apiName><shortdesc>
	 Отсчитываемое от нуля значение индекса для первого символа в текущем выделенном фрагменте.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Отсчитываемое от нуля значение индекса для первого символа в выделенном фрагменте. 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Отсчитываемое от нуля значение индекса для первого символа в текущем выделенном фрагменте. Например, первый символ имеет индекс 0, второй – индекс 1 и т. д. Если текст не выделен, это свойство является значением <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> В данном примере создается и заполняется текстом экземпляр TextField. Назначается прослушиватель событий, чтобы при щелчке по объекту TextField вызывался метод <codeph>printCursorPosition</codeph>. В данном случае значения свойств <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> выводятся на экран.
 
 <p>Запустите этот пример и попробуйте щелкнуть мышью в текстовом поле TextField, чтобы выделить текст. После этого щелкните поле, не выделяя текст. При щелчке по тексту без выделения, свойство <codeph>caretIndex</codeph> указывает местоположение точки вставки, а свойства <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> имеют то же значение, что <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionEndIndex"><linktext>selectionEndIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:selectionEndIndex:get"><apiName>selectionEndIndex</apiName><shortdesc>
	 Отсчитываемое от нуля значение индекса для последнего символа в текущем выделенном фрагменте.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>Отсчитываемое от нуля значение индекса для последнего символа в выделенном фрагменте.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Отсчитываемое от нуля значение индекса для последнего символа в текущем выделенном фрагменте. Например, первый символ имеет индекс 0, второй – индекс 1 и т. д. Если текст не выделен, это свойство является значением <codeph>caretIndex</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_caretIndex.as"> В данном примере создается и заполняется текстом экземпляр TextField. Назначается прослушиватель событий, чтобы при щелчке по объекту TextField вызывался метод <codeph>printCursorPosition</codeph>. В данном случае значения свойств <codeph>caretIndex</codeph>, <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> выводятся на экран.
 
 <p>Запустите этот пример и попробуйте щелкнуть мышью в текстовом поле TextField, чтобы выделить текст. После этого щелкните поле, не выделяя текст. При щелчке по тексту без выделения, свойство <codeph>caretIndex</codeph> указывает местоположение точки вставки, а свойства <codeph>selectionBeginIndex</codeph> и <codeph>selectionEndIndex</codeph> имеют то же значение, что <codeph>caretIndex</codeph>.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_caretIndex extends Sprite {
        public function TextField_caretIndex() {
            var tf:TextField = createCustomTextField(10, 10, 100, 100);
            tf.wordWrap = true;
            tf.type = TextFieldType.INPUT;
            tf.text = "Click in this text field. Compare the difference between clicking without selecting versus clicking and selecting text.";
            tf.addEventListener(MouseEvent.CLICK, printCursorPosition);
        }

        private function printCursorPosition(event:MouseEvent):void {
            var tf:TextField = TextField(event.target);
            trace("caretIndex:", tf.caretIndex);
            trace("selectionBeginIndex:", tf.selectionBeginIndex);
            trace("selectionEndIndex:", tf.selectionEndIndex);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/selectable"><linktext>selectable</linktext></link><link href="flash.text.xml#TextField/selectionBeginIndex"><linktext>selectionBeginIndex</linktext></link><link href="flash.text.xml#TextField/setSelection()"><linktext>setSelection()</linktext></link><link href="flash.text.xml#TextField/caretIndex"><linktext>caretIndex</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:sharpness:get"><apiName>sharpness</apiName><shortdesc>
	 Четкость контуров символов в этом текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates three text fields with
	 <code>sharpness</code> set to <code>400</code>, <code>0</code>, and <code>-400</code>.
	 It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 400, 100);
	 my_text1.text = "This text has sharpness set to 400."
	 my_text1.embedFonts = true;
	 my_text1.antiAliasType = "advanced";
	 my_text1.gridFitType = "pixel";
	 my_text1.sharpness = 400;
	 my_text1.setTextFormat(my_format);
         
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 40, 400, 100);
	 my_text2.text = "This text has sharpness set to 0."
	 my_text2.embedFonts = true;
	 my_text2.antiAliasType = "advanced";
	 my_text2.gridFitType = "pixel";
	 my_text2.sharpness = 0;
	 my_text2.setTextFormat(my_format);
	 
	 var my_text3:TextField = this.createTextField("my_text3", this.getNextHighestDepth(), 10, 70, 400, 100);
	 my_text3.text = "This text has sharpness set to -400."
	 my_text3.embedFonts = true;
	 my_text3.antiAliasType = "advanced";
	 my_text3.gridFitType = "pixel";
	 my_text3.sharpness = -400;
	 my_text3.setTextFormat(my_format);
	 </listing>
	 
     </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
         </apiDefaultValue><apiTipTexts><apiTipText>Резкость границ глифа.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Четкость контуров символов в этом текстовом поле. Это свойство применяется, только если свойство <codeph>flash.text.AntiAliasType</codeph> текстового поля имеет значение <codeph>flash.text.AntiAliasType.ADVANCED</codeph>. Допустимый диапазон значений свойства <codeph>sharpness</codeph>: числа от -400 до 400. При попытке задать свойству <codeph>sharpness</codeph> значение, находящееся за пределами этого диапазона, проигрыватель Flash Player назначает ему ближайшее значение в диапазоне (-400 или 400).
	 
	 </apiDesc><example conref="examples\TextField_sharpness.as"> В следующем примере показан результат изменения свойства <codeph>sharpness</codeph> для объекта TextField. Необходимо встроить шрифт и задать свойству <codeph>antiAliasType</codeph> значение <codeph>ADVANCED</codeph>.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class sharpnessExample extends Sprite
    {
        public function sharpnessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-400);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,400);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldSharpness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.sharpness=fldSharpness;
            result..setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:styleSheet:get"><apiName>styleSheet</apiName><shortdesc>
	 Присоединяет таблицу стилей к текстовому полю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet, style sheet, stylesheet
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.text:StyleSheet</apiValueClassifier><apiTipTexts><apiTipText>Присоединяет таблицу стилей к текстовому полю.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Присоединяет таблицу стилей к текстовому полю. Сведения о создании таблиц стилей, см. описание класса StyleSheet и руководство <i>Программирование на ActionScript 3.0</i>.
	 
	 <p>Таблицу стилей, связанную с текстовым полем, можно изменить в любое время. При изменении текущей таблицы стилей текстовое поле перерисовывается с использованием новой таблицы стилей. Чтобы удалить таблицу стилей, нужно задать значение <codeph>null</codeph> или <codeph>undefined</codeph>. Если текущая таблица стилей удаляется, текстовое поле перерисовывается без нее. </p>
     <p><b>Примечание.</b> Если таблица стилей удаляется, содержимое<codeph>TextField.text</codeph> и <codeph> TextField.htmlText</codeph> изменяется для внедрения форматирования, которое раньше применялось с помощью таблицы стилей. Чтобы сохранить исходное содержимое <codeph>TextField.htmlText</codeph> без форматирования, нужно сохранить значение в переменной, прежде чем удалять таблицу стилей.</p>
	 
     </apiDesc><example conref="examples\TextField_styleSheet.as"> В следующем примере определяется простой объект StyleSheet, который присваивается текстовому полю с содержимым в формате HTML. Перед определением содержимого задайте свойство <codeph>stylesheet</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.StyleSheet;

    public class TextStylesheetExample extends Sprite {
        var myLabel:TextField = new TextField();
        var labelText:String = "Hello world.";
        var newStyle:StyleSheet = new StyleSheet();

        public function TextStylesheetExample()
       {
            var styleObj:Object = new Object();
            styleObj.fontWeight = "bold";
            styleObj.color = "#660066";
            newStyle.setStyle(".defStyle", styleObj);

            myLabel.styleSheet=newStyle;
            myLabel.htmlText=labelText;
            addChild(myLabel);
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#StyleSheet"><linktext>flash.text.StyleSheet</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:text:get"><apiName>text</apiName><shortdesc>
	 Строка, представляющая текущий текст в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.text, text
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Строка, представляющая текущий текст в текстовом поле.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Строка, представляющая текущий текст в текстовом поле. Строки разделяются символом возврата каретки (<codeph>\r</codeph>, ASCII 13). Это свойство содержит неформатированный текст в текстовом поле без тегов HTML.
	 
	 <p>Чтобы получить текст в виде HTML, используйте свойство <codeph>htmlText</codeph>.</p>
	 
	 </apiDesc><example conref="examples\TextField_text.as"> В следующем примере создается объект TextField с именем <codeph>tf1</codeph>, свойству <codeph>text</codeph> которого назначается строка в формате HTML. Когда отслеживается его свойство <codeph>htmlText</codeph>, выводится строка в формате HTML, к которой проигрыватель Flash Player автоматически добавляет дополнительные теги, например &lt;P> и &lt;FONT>. Когда отслеживается значение свойства <codeph>text</codeph>, отображается неотформатированная строка без тегов HTML.
 
 <p>По аналогии, эти же действия выполняются с другим объектом TextField с именем <codeph>tf2</codeph>, но свойству <codeph>styleSheet</codeph> поля <codeph>tf2</codeph> назначается объект StyleSheet, прежде чем задается свойство <codeph>htmlText</codeph>. В этом случае, когда отслеживается свойство <codeph>htmlText</codeph>, оно включает только тот текст HTML, который был изначально назначен свойству <codeph>htmlText</codeph>, демонстрируя, что проигрыватель Flash Player не добавлял других тегов.</p>
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;

    public class TextField_text extends Sprite {
        public function TextField_text() {
            var tf1:TextField = createCustomTextField(10, 10, 400, 22);
            tf1.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";

            // htmlText: &lt;P ALIGN="LEFT">&lt;FONT FACE="Times New Roman" SIZE="12" COLOR="#000000" LETTERSPACING="0" KERNING="0">&amp;lt;b&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/b&amp;gt;&lt;/FONT>&lt;/P>
            trace("htmlText: " + tf1.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf1.text);
            
            var tf2:TextField = createCustomTextField(10, 50, 400, 22);
            tf2.styleSheet = new StyleSheet();
            tf2.htmlText = "&lt;b>Lorem ipsum dolor sit amet.&lt;/b>";
            // htmlText: &lt;b>Lorem ipsum dolor sit amet.&lt;/b>
            trace("htmlText: " + tf2.htmlText);
            // text: Lorem ipsum dolor sit amet.
            trace("text: " + tf2.text);
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textColor:get"><apiName>textColor</apiName><shortdesc>
	 Цвет текста в текстовом поле (в шестнадцатеричном формате).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textColor, textColor
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiDefaultValue>0 (0x000000)
	 </apiDefaultValue><apiTipTexts><apiTipText>Цвет текста в текстовом поле (в шестнадцатеричном формате).
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Цвет текста в текстовом поле (в шестнадцатеричном формате). Шестнадцатеричная система цвета использует шесть знаков для представления цветовых значений. Каждый знак имеет 16 возможных значений или символов. Символы находятся в диапазоне 0 – 9 и затем A – F. Например, черный цвет – это <codeph>0x000000</codeph>, а белый – <codeph>0xFFFFFF</codeph>.
	 
     </apiDesc><example conref="examples\TextField_textColor.as"> Следующий код ActionScript создает объект TextField и меняет его свойство <codeph>textColor</codeph> на красный (<codeph>0xFF0000</codeph>).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textColor extends Sprite {
        public function TextField_textColor() {
            var tf:TextField = createCustomTextField(10, 10, 100, 300);
            tf.text = "This will be red text";
            tf.textColor = 0xFF0000;            
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:textHeight:get"><apiName>textHeight</apiName><shortdesc>
	 Высота текста в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textHeight, textHeight
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Высота текста в пикселях.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Высота текста в пикселях.
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> В следующем примере создается объект TextField, которому назначается текст. Инструкции <codeph>trace</codeph> отображают значения свойств <codeph>textWidth</codeph> и <codeph>textHeight</codeph>. Для сравнения также отображаются свойства <codeph>width</codeph> и <codeph>height</codeph>. (Обратите внимание, что значения, отображаемые для свойств <codeph>textHeight</codeph> и <codeph>textWidth</codeph>, могут варьироваться в зависимости от шрифта, используемого на компьютере).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textWidth"><linktext>flash.text.TextField.textWidth</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:textWidth:get"><apiName>textWidth</apiName><shortdesc>
	 Ширина текста в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.textWidth, textWidth
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>Ширина текста в пикселях.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Ширина текста в пикселях.
	 
	 </apiDesc><example conref="examples\TextField_textHeight.as"> В следующем примере создается объект TextField, которому назначается текст. Инструкции <codeph>trace</codeph> отображают значения свойств <codeph>textWidth</codeph> и <codeph>textHeight</codeph>. Для сравнения также отображаются свойства <codeph>width</codeph> и <codeph>height</codeph>. (Обратите внимание, что значения, отображаемые для свойств <codeph>textHeight</codeph> и <codeph>textWidth</codeph>, могут варьироваться в зависимости от шрифта, используемого на компьютере).
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_textHeight extends Sprite {
        public function TextField_textHeight() {
            var tf:TextField = createCustomTextField(10, 10, 100, 150);
            tf.text = "Sample text";
            
            trace("textWidth: " + tf.textWidth); // textWidth: 55.75
            trace("textHeight: " + tf.textHeight); // textHeight: 13.450000000000001
            trace("width: " + tf.width); // width: 100
            trace("height: " + tf.height); // height: 150
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.border = true;
            result.background = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/textHeight"><linktext>flash.text.TextField.textHeight</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:thickness:get"><apiName>thickness</apiName><shortdesc>
	 Толщина контуров символов в данном текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>This example creates two text fields and applies a <code>thickness</code> of -200 to one
	 and 200 to the other.  It assumes that you have a font
	 embedded in the Library with the linkage identifier set to <code>"Times-12"</code>.
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library</li>
	 <li>Click the Library options menu in the upper right corner of the Library</li>
	 <li>Select "New Font" from the dropdown list</li>
	 <li>Name the font "Times-12"</li>
	 <li>Select "Times New Roman" from the font dropdown list</li>
	 <li>Press the "OK" button</li>
	 <li>Right-click on the newly created font and select "Linkage..."</li>
	 <li>Check the "Export for ActionScript" box</li>
	 <li>Accept the default identifier "Times-12" by pressing the "OK" button</li>
	 </ol>
	 
	 <listing version="2.0">
	 var my_format:TextFormat = new TextFormat();
	 my_format.font = "Times-12";
	 
	 var my_text1:TextField = this.createTextField("my_text1", this.getNextHighestDepth(), 10, 10, 300, 30);
	 my_text1.text = "thickness = 200";
	 my_text1.antiAliasType = "advanced";
	 my_text1.border = true;
	 my_text1.thickness = 200;
	 my_text1.embedFonts = true;
	 my_text1.setTextFormat(my_format);
	 
	 var my_text2:TextField = this.createTextField("my_text2", this.getNextHighestDepth(), 10, 50, 300, 30);
	 my_text2.text = "thickness = -200."
	 my_text2.antiAliasType = "advanced";
	 my_text2.thickness = -200;
	 my_text2.border = true;
	 my_text2.embedFonts = true;
	 my_text2.setTextFormat(my_format);
	 </listing>
     
         </oldexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Толщина границ глифа.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Толщина контуров символов в данном текстовом поле. Это свойство применяется, только когда параметр <codeph>flash.text.AntiAliasType</codeph> имеет значение <codeph>flash.text.AntiAliasType.ADVANCED</codeph>.
	 
	 <p>Допустимый диапазон значений свойства <codeph>thickness</codeph>: числа от -200 до 200. При попытке задать свойству <codeph>thickness</codeph> значение, находящееся за пределами этого диапазона, проигрыватель Flash Player назначает ему ближайшее значение в диапазоне (-200 или 200).</p>
	 
     </apiDesc><example conref="examples\TextField_thickness.as"> В следующем примере показан результат изменения свойства <codeph>thickness</codeph> для объекта TextField. Необходимо встроить шрифт и задать свойству <codeph>antiAliasType</codeph> значение <codeph>ADVANCED</codeph>.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.AntiAliasType;
    import flash.text.GridFitType;
    import flash.text.TextFormat;

    public class thicknessExample extends Sprite
    {
        public function thicknessExample()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Arial";
    format1.size=24;
    var lTxt:String = "The quick brown fox";

    var tf1:TextField=createCustomTextField(0,lTxt,format1,-200);
    var tf2:TextField=createCustomTextField(30,lTxt,format1,0);
    var tf3:TextField=createCustomTextField(60,lTxt,format1,200);
        }

        private function createCustomTextField(y:Number,fldTxt:String,format:TextFormat,fldThickness:Number):TextField 
       {
            var result:TextField = new TextField();
            result.y=y;
            result.text=fldTxt;
            result.embedFonts=true;
            result.autoSize=TextFieldAutoSize.LEFT;
            result.antiAliasType=AntiAliasType.ADVANCED;
            result.gridFitType=GridFitType.PIXEL;
            result.thickness=fldThickness;
            result.setTextFormat(format);
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link><link href="flash.text.xml#AntiAliasType"><linktext>flash.text.AntiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:type:get"><apiName>type</apiName><shortdesc>
	 Тип текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.type, type
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Заданный параметр <codeph>type</codeph> не является элементом flash.text.TextFieldType.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>dynamic
     
	 </apiDefaultValue><apiTipTexts><apiTipText>Тип текстового поля.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Тип текстового поля. Одна из следующих констант класса TextFieldType: <codeph>TextFieldType.DYNAMIC</codeph>, задающая динамическое текстовое поле, которое не может редактироваться пользователем, или <codeph>TextFieldType.INPUT</codeph>, задающая текстовое поле ввода, которое может редактироваться пользователем.
	 
     </apiDesc><example conref="examples\TextField_type.as"> В следующем примере создаются два текстовых поля: <codeph>tfDynamic</codeph> и <codeph>tfInput</codeph>. Текст вводится в оба текстовых поля. Однако для <codeph>tfDynamic</codeph> свойство <codeph>type</codeph> имеет значение <codeph>TextFieldType.DYNAMIC</codeph>, а для <codeph>tfInput</codeph> свойство <codeph>type</codeph> имеет значение <codeph>TextFieldType.INPUT</codeph>, чтобы пользователь мог модифицировать текст в поле <codeph>tfInput</codeph>, а в поле <codeph>tfDynamic</codeph> – только просматривать.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;

    public class TextField_type extends Sprite {
        public function TextField_type() {
            var tfDynamic:TextField = createCustomTextField(10, 10, 100, 20);
            tfDynamic.type = TextFieldType.DYNAMIC;
            tfDynamic.text = "hello";

            var tfInput:TextField = createCustomTextField(10, 45, 100, 20);
            tfInput.type = TextFieldType.INPUT;
            tfInput.text = "world";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextFieldType"><linktext>flash.text.TextFieldType</linktext></link></related-links></apiValue><apiValue id="flash.text:TextField:useRichTextClipboard:set"><apiName>useRichTextClipboard</apiName><shortdesc>
	 Определяет, будет ли форматирование текста копироваться и вставляться вместе с самим текстом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, будет ли форматирование текста копироваться и вставляться вместе с самим текстом. Если задано значение <codeph>true</codeph>, при копировании и вставке текста из одного текстового поля в другое проигрыватель Flash Player также копирует и вставляет форматирование (например, выравнивание, полужирное и курсивное начертание). Для обоих текстовых полей, участвующих в операции копирования и вставки свойство <codeph>useRichTextClipboard</codeph> должно иметь значение <codeph>true</codeph>. Значение по умолчанию <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_useRichTextClipboard.as"> В данном примере создается текстовое поле ввода (<codeph>tf1</codeph>) и два динамических текстовых поля (<codeph>tf2</codeph> и <codeph>tf3</codeph>). Код назначает каждому динамическому текстовому полю объект TextFormat (полужирный шрифт Courier). Для текстового поля <codeph>tf2</codeph> свойство <codeph>useRichTextClipboard</codeph> имеет значение <codeph>false</codeph>. Для текстового поля <codeph>tf3</codeph> свойство <codeph>useRichTextClipboard</codeph> имеет значение <codeph>true</codeph>. Когда текст копируется из поля <codeph>tf2</codeph> и вставляется в текстовое поле <codeph>tf1</codeph>, вставленный фрагмент не сохраняет форматирование. Когда текст копируется из поля <codeph>tf3</codeph> (у которого свойство <codeph>useRichTextClipboard</codeph> имеет значение <codeph>true</codeph>) и вставляется в текстовое поле <codeph>tf1</codeph>, вставленный фрагмент сохраняет форматирование.
<codeblock>

package
{
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFormat;

    public class useRichTextClipboard extends Sprite
    {
        public function useRichTextClipboard()
        {
    var format1:TextFormat = new TextFormat();
    format1.font="Courier";
    format1.bold=true;

    var tf1:TextField = createCustomTextField(10, 10, 200, 20);
    tf1.type=TextFieldType.INPUT;
    tf1.useRichTextClipboard=true;

    var tf2:TextField = createCustomTextField(220, 10, 200, 20);
    tf2.text="1.Text loses format";
    tf2.setTextFormat(format1);
    tf2.useRichTextClipboard=false;

    var tf3:TextField = createCustomTextField(220, 50, 200, 20);
    tf3.text="2.Text includes format";
    tf3.setTextFormat(format1);
    tf3.useRichTextClipboard=true;
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField 
       {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.text:TextField:wordWrap:get"><apiName>wordWrap</apiName><shortdesc>
	 Логическое значение, определяющее применение переноса по словам к текстовому полю.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, TextField.wordWrap, wordWrap
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>Указывает, действует ли в текстовом поле перенос по словам.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Логическое значение, определяющее применение переноса по словам к текстовому полю. Если свойство <codeph>wordWrap</codeph> имеет значение <codeph>true</codeph>, текстовое поле поддерживает перенос слов, а если оно имеет значение <codeph>false</codeph>, то перенос слов запрещен. Значение по умолчанию <codeph>false</codeph>.
	 
	 </apiDesc><example conref="examples\TextField_wordWrap.as"> В данном примере демонстрируется разница между параметрами <codeph>true</codeph> и <codeph>false</codeph> для свойства <codeph>wordWrap</codeph>. Создаются два экземпляра TextField, содержимое которых превышает ширину текстового поля. Для первого поля с именем <codeph>tfWrap</codeph> свойство <codeph>wordWrap</codeph> имеет значение <codeph>true</codeph>; а для второго (<codeph>tfNoWrap</codeph>) -<codeph>false</codeph>.
<codeblock>

package {
    import flash.display.Sprite;
    import flash.text.TextField;

    public class TextField_wordWrap extends Sprite {
        public function TextField_wordWrap() {
            var tfWrap:TextField = createCustomTextField(10, 10, 100, 100);
            tfWrap.wordWrap = true;
            tfWrap.text = "(wordWrap = true):\nThis is very long text that will certainly extend beyond the width of this text field";

            var tfNoWrap:TextField = createCustomTextField(10, 150, 100, 100);
            tfNoWrap.wordWrap = false;
            tfNoWrap.text = "(wordWrap = false):\nThis is very long text that will certainly extend beyond the width of this text field";
        }

        private function createCustomTextField(x:Number, y:Number, width:Number, height:Number):TextField {
            var result:TextField = new TextField();
            result.x = x;
            result.y = y;
            result.width = width;
            result.height = height;
            result.background = true;
            result.border = true;
            addChild(result);
            return result;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 Класс TextFormat представляет данные форматирования символов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Insure the above example is correct and meets example standards
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Создает форматирование для текстовых полей.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextFormat представляет данные форматирования символов. Используйте класс TextFormat для создания специфического форматирования текста для текстовых полей. Форматирование текста можно применять и к статическим и к динамическим текстовым полям. Свойства класса TextFormat применяются к шрифтам устройства и встроенным шрифтам. Однако при использовании встроенных шрифтов для полужирного и курсивного текста на самом деле могут потребоваться отдельные шрифты. Если требуется отобразить полужирный или курсивный текст с встроенным шрифтом, необходимо встроить варианты его полужирного и курсивного начертания.
 
 <p> Прежде чем задавать эти свойства, необходимо вызвать конструктор <codeph>new TextFormat()</codeph> для создания объекта TextFormat. Когда объект TextFormat применяется к текстовому полю с помощью свойства <codeph>TextField.defaultTextFormat</codeph> или метода <codeph>TextField.setTextFormat()</codeph>, применяются только определенные для него свойства. Используйте свойство <codeph>TextField.defaultTextFormat</codeph>, чтобы применить форматирование ПЕРЕД добавлением текста в <codeph>TextField</codeph>, а метод <codeph>setTextFormat()</codeph>, чтобы добавить форматирование ПОСЛЕ добавления текста в <codeph>TextField</codeph>. Свойства объекта TextFormat по умолчанию имеют значения <codeph>null</codeph>, так как если они не определены, проигрыватель Flash Player использует собственное форматирование по умолчанию. Проигрыватель Flash Player использует следующее форматирование для каждого свойства (если его значение – <codeph>null</codeph>).</p>
 
 <adobetable class="innertable">
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="1"><tbody><row><entry>align = "left</entry></row><row><entry>blockIndent = 0</entry></row><row><entry>bold = false</entry></row><row><entry>bullet = false</entry></row><row><entry>color = 0x000000</entry></row><row><entry>font = "Times New Roman" (в Mac OS X шрифт по умолчанию – Times)</entry></row><row><entry>indent = 0</entry></row><row><entry>italic = false</entry></row><row><entry>kerning = false</entry></row><row><entry>leading = 0</entry></row><row><entry>leftMargin = 0</entry></row><row><entry>letterSpacing = 0</entry></row><row><entry>rightMargin = 0</entry></row><row><entry>size = 12</entry></row><row><entry>tabStops = [] (пустой массив)</entry></row><row><entry>target = "" (пустая строка)</entry></row><row><entry>underline = false</entry></row><row><entry>url = "" (пустая строка)</entry></row></tbody></tgroup></adobetable>
 
 <p>Форматирование по умолчанию для каждого свойства также приводится в его подробном описании.</p>
 
 </apiDesc><example conref="examples\TextFormatExample.as"> В следующем примере создается класс TextFieldExample для отображения текстового сообщения в местоположении по умолчанию (x = 0, y = 0). Это можно сделать, выполнив следующие действия:
 <ol>
  <li>Создается свойство <codeph>label</codeph> типа TextField.</li>
  <li>Конструктор класса вызывает функцию <codeph>configureLabel()</codeph>.</li>
  <li>Метод <codeph>configureLabel()</codeph> сначала создает новый объект TextField и назначает его свойству <codeph>label</codeph>, а затем задает для него следующие параметры
  <ul>
      <li>Полная выключка текстового поля по левому краю</li>
      <li>Включить заливку фона</li>
      <li>Включить рамку</li>
  </ul>
  </li>
  <li>Затем метод <codeph>configureLable()</codeph> создает локальную переменную, <codeph>format</codeph>, назначает ее новому экземпляру TextFormat и задает для нее следующие параметры:
  <ul>
      <li>Font type = Verdana</li>
      <li>Font Color = solid red</li>
      <li>Font size = 10</li>
      <li>Font underline = true.</li>
  </ul>
  </li>
  <li>Свойству <codeph>defaultTextFormat</codeph> свойства label задается значение <codeph>format</codeph>, и экземпляр <codeph>label</codeph> добавляется в список отображения, который сначала показывает на монтажном столе текстовое поле без текста (крошечное поле с белым фоном).</li>
  <li>В завершение, метод конструктора <codeph>setLabel()</codeph> передает для отображения текст объекта label – Hello World and welcome to the show (Здравствуйте все, и добро пожаловать на представление) – в точке с координатами x = 0, y = 0.</li>
 </ol>
<codeblock>
 package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.text.TextFormat;


    public class TextFormatExample extends Sprite {
        private var label:TextField;

        public function TextFormatExample() {
            configureLabel();
            setLabel("Hello World and welcome to the show");
        }

        public function setLabel(str:String):void {
            label.text = str;
        }

        private function configureLabel():void {
            label = new TextField();
            label.autoSize = TextFieldAutoSize.LEFT;
            label.background = true;
            label.border = true;

            var format:TextFormat = new TextFormat();
            format.font = "Verdana";
            format.color = 0xFF0000;
            format.size = 10;
            format.underline = true;

            label.defaultTextFormat = format;
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/setTextFormat()"><linktext>flash.text.TextField.setTextFormat()</linktext></link><link href="flash.text.xml#TextField/defaultTextFormat"><linktext>flash.text.TextField.defaultTextFormat</linktext></link><link href="flash.text.xml#TextField/getTextFormat()"><linktext>flash.text.TextField.getTextFormat()</linktext></link></related-links><apiConstructor id="flash.text:TextFormat:TextFormat"><apiName>TextFormat</apiName><shortdesc>
 	 Создает объект TextFormat с заданными свойствами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat
 	 
 	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Имя шрифта для текста в виде строки.
 	 </apiDesc></apiParam><apiParam><apiItemName>size</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Целое число, которое обозначает размер в пикселях.
 	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Цвет текста, использующего данный формат. Число, содержащее три 8-разрядных компонента RGB; например, 0xFF0000 – красный, 0x00FF00 – зеленый.
 	 </apiDesc></apiParam><apiParam><apiItemName>bold</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Логическое значение, указывающее, является ли текст полужирным.
 	 </apiDesc></apiParam><apiParam><apiItemName>italic</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Логическое значение, указывающее, является ли текст курсивным.
 	 </apiDesc></apiParam><apiParam><apiItemName>underline</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Логическое значение, указывающее, является ли текст подчеркнутым.
 	 </apiDesc></apiParam><apiParam><apiItemName>url</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>URL-адрес, на который ссылается текст с этим форматом. Если <codeph>url</codeph> представлен пустой строкой, текст не имеет гиперссылки.
 	 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Целевое окно, где отображается гиперссылка. Если целевое окно представлено пустой строкой, текст отображается в целевом окне по умолчанию, <codeph>_self</codeph>. Если параметр <codeph>url</codeph> представлен пустой строкой или значением <codeph>null</codeph>, это свойство можно получить или задать, но оно не будет иметь силы.
 	 </apiDesc></apiParam><apiParam><apiItemName>align</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>Выравнивание абзаца в виде значения TextFormatAlign.
 	 </apiDesc></apiParam><apiParam><apiItemName>leftMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает левое поле абзаца (в пикселях).
 	 </apiDesc></apiParam><apiParam><apiItemName>rightMargin</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Указывает правое поле абзаца (в пикселях).
 	 </apiDesc></apiParam><apiParam><apiItemName>indent</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Целое число, указывающее отступ от левого поля до первого символа в абзаце.
 	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>Число, указывающее величину вертикального интервала между строками.
 	 
   	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 Создает объект TextFormat с заданными свойствами. Затем можно изменить свойства объекта TextFormat, чтобы изменить форматирование текстовых полей.
	 
 	 <p>Любому параметру можно задать значение <codeph>null</codeph>, чтобы указать, что он не определен. Все параметры являются необязательными, опущенные параметры имеют значение <codeph>null</codeph>.</p>
  	 
 	 </apiDesc><example conref="examples\TextFormat_constructorExample.as"> В следующем примере пользователь может выбирать разные варианты форматирования текста из списка, примененного к содержимому другого текстового поля. Если пользователь щелкает по содержимому текстового поля, возвращается формат по умолчанию (исходный).
 
 <p>В текстовом поле <codeph>formatTextField</codeph> перечисляются все варианты свойств класса TextField (за исключением <codeph>kerning</codeph>), каждое в отдельной строке. Когда пользователь щелкает строку в текстовом поле <codeph>formatTextField</codeph>, запускается метод <codeph>formatTextFieldClickHandler()</codeph>.</p> 
 
 <p>Метод <codeph>formatTextFieldClickHandler()</codeph> сначала вызывает метод <codeph>TextField.getLineIndexAtPoint()</codeph> для получения индекса выбранной строки, а затем метод <codeph>TextField.getLineText()</codeph> для получения содержания строки. Инструкция switch проверяет содержимое строки и соответствующим образом задает свойство объекта TextFormat с именем <codeph>newformat</codeph>. После этого метод <codeph>setTextFormat()</codeph> задает текстовому полю <codeph>contentTextField</codeph> новый формат. Выбирая разные строки в поле <codeph>formatTextField</codeph> пользователь может применять разное форматирование к текстовому полю <codeph>contentTextField</codeph>. (Этот параметр табуляции представляет собой массив, определяющий отдельную точку табуляции для каждого табулятора в строке.) Если выбрана строка <codeph>url</codeph> или <codeph>target</codeph>, пользователь должен щелкнуть текстовое поле <codeph>contentTextField</codeph>, чтобы активировать ссылку и отобразить содержимое целевого URL-адрес (главная страница Flex). По умолчанию свойство <codeph>target</codeph> имеет значение _self, которое означает, что если пользователь выберет строку <codeph>url</codeph>, содержимое отображается в текущем окне. Чтобы свойство <codeph>target</codeph> работало, URL-адрес уже должен быть задан в свойстве <codeph>url</codeph>.</p>
 
 <p>Если пользователь щелкает по текстовому полю <codeph>contentTextField</codeph>, запускается метод <codeph>contentTextFieldClickHandler()</codeph>, который возвращает формат поля и объект TextFormat с именем <codeph>newFormat</codeph> к формату по умолчанию (исходному) для текстового поля. При этом отменяются все изменения форматирования, внесенные пользователем.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldAutoSize;
    import flash.events.MouseEvent;
    import flash.text.TextFormatAlign;
    
    public class TextFormat_constructorExample extends Sprite {
        private var contentTextField:TextField = new TextField();
        private var formatTextField:TextField = new TextField();
        private var newFormat:TextFormat = new TextFormat();
        
        public function TextFormat_constructorExample() {
            contentTextField.x = 10;
            contentTextField.y = 10;
            contentTextField.background = true;
            contentTextField.border = true;
            contentTextField.multiline = true;
            contentTextField.wordWrap = true;
            contentTextField.selectable = false;
            contentTextField.width = 250;
            contentTextField.height = 120; 
  
            contentTextField.htmlText = "&lt;p>The TextFormat class represents character formatting "
                + "information. Use the TextFormat class to create specific text formatting "
                + "for text fields." + 
                " &lt;/p>&lt;br>" + "\tTab One" + "\tTab Two&lt;br>";
              
            formatTextField.x = 10;
            formatTextField.y = 140;
            formatTextField.background = true;
            formatTextField.border = true;
            formatTextField.autoSize = TextFieldAutoSize.LEFT;
            
            formatTextField.text = "align: right\n" + "blockIndent: 10 pixels\n" + "bold:\n" + "bullet:\n" + "color: red\n"
                                + "font: Arial\n" + "indent: 20 pixels\n" + "italic:\n" + "leading: 5 spaces\n" 
                                + "leftMargin: 20 pixels\n" + "letterSpacing: 4 pixels\n" + "rightMargin: 20 pixels\n" 
                                + "size: 16 point\n" + "target: new window\n" + "tabStops: 50 and 150 pixel\n" 
                                + "underline:\n" + "url: Adobe Flex page\n";

            formatTextField.addEventListener(MouseEvent.CLICK, formatTextFieldClickHandler);
            
            contentTextField.addEventListener(MouseEvent.CLICK, contentTextFieldClickHandler);
            
            this.addChild(contentTextField);
            this.addChild(formatTextField);
        }

        private function formatTextFieldClickHandler(e:MouseEvent):void {
                var value:String= "";
                var i:uint = 0;
                var index:int = formatTextField.getLineIndexAtPoint(e.localX, e.localY);
                var line:String = formatTextField.getLineText(index);;

                line = line.substr(0, (line.indexOf(":")));

                switch(line) {
                    case "align":
                        newFormat.align = TextFormatAlign.RIGHT;
                        break;
                    case "blockIndent":
                        newFormat.blockIndent = 10;
                        break;
                    case "bold":
                        newFormat.bold = true;
                        break;
                    case "bullet":
                        newFormat.bullet = true;
                        break;
                    case "color":
                        newFormat.color = 0xFF0000;        
                        break;
                    case "font":
                        newFormat.font = "Arial";
                        break;
                    case "indent":
                        newFormat.indent = 20;
                        break;
                    case "italic":
                        newFormat.italic = true;
                        break;
                    case "leading":
                        newFormat.leading = 5;
                        break;
                    case "leftMargin":
                        newFormat.leftMargin = 20;
                        break;
                    case "letterSpacing":
                        newFormat.letterSpacing = 4;
                        break;
                    case "rightMargin":
                        newFormat.rightMargin = 20;
                        break;
                    case "size":
                        newFormat.size = 16;
                        break;
                    case "tabStops":                
                        newFormat.tabStops = [50, 150];
                        break;
                    case "target":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        newFormat.target = "_blank";
                        break;    
                    case "underline":
                        newFormat.underline = true;
                        break;
                    case "url":
                        newFormat.url = "http://www.adobe.com/products/flex/";    
                        break;
                }    

                contentTextField.setTextFormat(newFormat);
        }

        private function contentTextFieldClickHandler(e:MouseEvent):void {
            contentTextField.setTextFormat(contentTextField.defaultTextFormat);
            newFormat = contentTextField.defaultTextFormat;
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiValue id="flash.text:TextFormat:align:get"><apiName>align</apiName><shortdesc>
	 Обозначает выравнивание абзаца.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.align, align
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>Заданный параметр <codeph>align</codeph> не является элементом flash.text.TextFormatAlign.
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiDefaultValue>TextFormatAlign.LEFT
	 
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Обозначает выравнивание абзаца. Допустимыми значениями являются константы TextFormatAlign.
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormatAlign"><linktext>flash.text.TextFormatAlign</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:blockIndent:get"><apiName>blockIndent</apiName><shortdesc>
	 Указывает отступ блока в пикселях.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.blockIndent, blockIndent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает отступ блока в пикселях. Отступ блока применяется ко всему блоку текста, то есть, ко всем его строкам текста. Обычный отступ (<codeph>TextFormat.indent</codeph>), напротив, применяется только к первой строке каждого абзаца. Если это свойство имеет значение <codeph>null</codeph>, объект TextFormat не задает отступ блока (он равен 0).
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
 	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bold:get"><apiName>bold</apiName><shortdesc>
	 Определяет, является ли текст полужирным.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bold, bold
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет, является ли текст полужирным. Значение по умолчанию – <codeph>null</codeph>, т.е. полужирное начертание не используется. Если значение – <codeph>true</codeph>, тогда отображается полужирный текст.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:bullet:get"><apiName>bullet</apiName><shortdesc>
	 Показывает, что текст является частью маркированного списка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.bullet, bullet
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, что текст является частью маркированного списка. В маркированном списке отступ применяется к каждому абзацу. Слева от первой строки каждого абзаца отображается маркер списка. Значение по умолчанию – <codeph>null</codeph>, т.е. маркированный список не используется.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:color:get"><apiName>color</apiName><shortdesc>
	 Указывает цвет текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.color, color
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает цвет текста. Число, содержащее три 8-разрядных компонента RGB; например, 0xFF0000 – красный, 0x00FF00 – зеленый. Значение по умолчанию – <codeph>null</codeph>, т.е. проигрыватель Flash Player использует черный цвет (0x000000).
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:font:get"><apiName>font</apiName><shortdesc>
	 Имя шрифта для текста в данном текстовом формате (в виде строки).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.font, font
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Имя шрифта для текста в данном текстовом формате (в виде строки). Значение по умолчанию – <codeph>null</codeph>, т.е. проигрыватель Flash Player использует для текста шрифт Times New Roman.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:indent:get"><apiName>indent</apiName><shortdesc>
	 Указывает отступ от левого поля до первого символа в абзаце.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.indent, indent
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает отступ от левого поля до первого символа в абзаце. Значение по умолчанию – <codeph>null</codeph>, т.е. отступ не используется.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/blockIndent"><linktext>flash.text.TextFormat.blockIndent</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:italic:get"><apiName>italic</apiName><shortdesc>
	 Показывает, выделен ли текст в данном текстовом формате курсивом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.italic, italic
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, выделен ли текст в данном текстовом формате курсивом. Значение по умолчанию – <codeph>null</codeph>, т.е. курсивное начертание не используется.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:kerning:get"><apiName>kerning</apiName><shortdesc>
	 Логическое значение, указывающее использование кернинга (true – включено и false – отключено).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Логическое значение, указывающее использование кернинга (<codeph>true</codeph> – включено и <codeph>false</codeph> – отключено). Функция кернинга позволяет регулировать число пикселей между определенными символьными парами в целях упрощения восприятия. Эту функцию рекомендуется применять только в случае необходимости, например, в отношении заголовков при использовании крупных шрифтов. Кернинг поддерживается только для встроенных шрифтов.
	 
	 <p>Определенные шрифты, такие как Verdana, и моноширинные шрифты, такие как Courier New, не поддерживают кернинг.</p>
	 
	 <p>Значение по умолчанию – <codeph>null</codeph>, т.е. кернинг выключен.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leading:get"><apiName>leading</apiName><shortdesc>
	 Целое число, представляющее величину промежутка между строками по вертикали (так называемый междустрочный интервал).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leading, leading
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Целое число, представляющее величину промежутка между строками по вертикали (так называемый <i>междустрочный интервал</i>). Значение по умолчанию – <codeph>null</codeph>, т.е. величина междустрочного интервала равна 0.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:leftMargin:get"><apiName>leftMargin</apiName><shortdesc>
	 Левое поле абзаца (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.leftMargin, leftMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Левое поле абзаца (в пикселях). Значение по умолчанию – <codeph>null</codeph>, т.е. левое поле равно 0 пикселей.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:letterSpacing:get"><apiName>letterSpacing</apiName><shortdesc>
     Число, представляющее величину пространства, равномерно распределяемого между всеми символами.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><internal>Add better description and example.
     </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     Число, представляющее величину пространства, равномерно распределяемого между всеми символами. Это значение задает количество пикселей, добавляемых после каждого символа. Значение по умолчанию – <codeph>null</codeph>, т.е. используется нулевой интервал между буквами. Можно использовать дробные значения, например <codeph>1,75</codeph>.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:rightMargin:get"><apiName>rightMargin</apiName><shortdesc>
	 Правое поле абзаца (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.rightMargin, rightMargin
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Правое поле абзаца (в пикселях). Значение по умолчанию – <codeph>null</codeph>, т.е. правое поле равно 0 пикселей.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:size:get"><apiName>size</apiName><shortdesc>
	 Размер текста в пикселях в данном текстовом формате.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.size, size
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Размер текста в пикселях в данном текстовом формате. Значением по умолчанию является <codeph>null</codeph>, которое обозначает использование кегля 12.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:tabStops:get"><apiName>tabStops</apiName><shortdesc>
	 Задает пользовательские позиции табуляции в виде массива неотрицательных целых чисел.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.tabStops, tabStops
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 Задает пользовательские позиции табуляции в виде массива неотрицательных целых чисел. Каждая точка табуляции задается в пикселях. Если не заданы пользовательские точки табуляции (<codeph>null</codeph>), по умолчанию используется значение 4 (средняя ширина символа).
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:target:get"><apiName>target</apiName><shortdesc>
	 Указывает целевое окно, где отображается гиперссылка.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.target, target
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает целевое окно, где отображается гиперссылка. Если целевое окно представлено пустой строкой, текст отображается в целевом окне по умолчанию, <codeph>_self</codeph>. Можно выбрать пользовательское имя или один из следующих четырех вариантов: <codeph>_self</codeph> задает текущий фрейм в текущем окне, <codeph>_blank</codeph> задает новое окно, <codeph>_parent</codeph> задает вышестоящий элемент текущего фрейма, и <codeph>_top</codeph> задает фрейм верхнего уровня в текущем окне. Если параметр <codeph>TextFormat.url</codeph> представлен пустой строкой или значением <codeph>null</codeph>, это свойство можно получить или задать, но оно не будет иметь силы.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/url"><linktext>flash.text.TextFormat.url</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormat:underline:get"><apiName>underline</apiName><shortdesc>
	 Показывает, является ли текст в этом текстовом формате подчеркнутым: да (true) или нет (false).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.underline, underline
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, является ли текст в этом текстовом формате подчеркнутым: да (<codeph>true</codeph>) или нет (<codeph>false</codeph>). Это подчеркивание похоже на подчеркивание с помощью тега <codeph>&lt;U></codeph>, но последнее не является истинным подчеркиванием, так как не пропускает буквы с нижним выносным элементом. Значение по умолчанию – <codeph>null</codeph>, т.е. подчеркивание не используется.
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail></apiValue><apiValue id="flash.text:TextFormat:url:get"><apiName>url</apiName><shortdesc>
	 Указывает целевой URL-адрес для текста в данном текстовом формате.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextFormat, TextFormat.url, url
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Указывает целевой URL-адрес для текста в данном текстовом формате. Если свойство <codeph>url</codeph> представлено пустой строкой, текст не имеет гиперссылки. Значение по умолчанию – <codeph>null</codeph>, т.е. текст не имеет гиперссылки.
	 <p><b>Примечание.</b> Чтобы гиперссылка работала, для текста с назначенным форматом должно быть задано свойство <codeph>htmlText</codeph>.</p>
	 
	 </apiDesc><example>Пример использования этого свойства см. в примере для конструктора <xref href="TextFormat.html#TextFormat()">TextFormat()</xref>. 
	 </example></apiValueDetail><related-links><link href="flash.text.xml#TextField/htmlText"><linktext>flash.text.TextField.htmlText</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextDisplayMode"><apiName>TextDisplayMode</apiName><shortdesc>
 Класс TextDisplayMode содержит значения, определяющие дополнительное субпиксельное сглаживание.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextDisplayMode содержит значения, определяющие дополнительное субпиксельное сглаживание. 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer/displayMode"><linktext>flash.text.TextRenderer.displayMode</linktext></link></related-links><apiValue id="flash.text:TextDisplayMode:CRT"><apiName>CRT</apiName><shortdesc>
	 Предписывает проигрывателю Flash Player отображать полутоновое сглаживание.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>crt</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Предписывает проигрывателю Flash Player отображать полутоновое сглаживание. Хотя этот параметр предотвращает окрашивание текста, некоторым пользователям он кажется размытым.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
	 Позволяет проигрывателю Flash Player выбирать режим LCD или CRT.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Позволяет проигрывателю Flash Player выбирать режим LCD или CRT.	
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextDisplayMode:LCD"><apiName>LCD</apiName><shortdesc> 
	 Предписывает проигрывателю Flash Player применять субпиксельное сглаживание LCD.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lcd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	 Предписывает проигрывателю Flash Player применять субпиксельное сглаживание LCD. В зависимости от шрифта и аппаратных средств этот параметр может привести к повышению разрешения текста или к его окраске.
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:AntiAliasType"><apiName>AntiAliasType</apiName><shortdesc>
Класс AntiAliasType передает значения для сглаживания в классе flash.text.TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс AntiAliasType передает значения для сглаживания в классе flash.text.TextField.
</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiValue id="flash.text:AntiAliasType:ADVANCED"><apiName>ADVANCED</apiName><shortdesc>
	Задает использование расширенных возможностей сглаживания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>advanced</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает использование расширенных возможностей сглаживания. Расширенное сглаживание позволяет высококачественно визуализировать шрифты небольшого размера. Оно оптимально для приложений, в которых используется много мелкого текста. Расширенное сглаживание не рекомендуется для шрифтов больше 48 размера. Эта константа используется для свойства <codeph>antiAliasType</codeph> в классе TextField. Используйте синтаксис <codeph>AntiAliasType.ADVANCED</codeph>.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue><apiValue id="flash.text:AntiAliasType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	Задает использование сглаживания в Flash Player 7 и более ранних версий.</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Задает использование сглаживания в Flash Player 7 и более ранних версий. Этот параметр рекомендуется для приложений с небольшим объемом текста. Эта константа используется для свойства <codeph>antiAliasType</codeph> в классе TextField. Используйте синтаксис <codeph>AntiAliasType.NORMAL</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:FontType"><apiName>FontType</apiName><shortdesc>
	 Класс FontType содержит перечисляемые константы embedded и device для свойства fontType класса Font.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Класс FontType содержит перечисляемые константы <codeph>embedded</codeph> и <codeph>device</codeph> для свойства <codeph>fontType</codeph> класса Font. 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#Font/fontType"><linktext>flash.text.Font.fontType</linktext></link></related-links><apiValue id="flash.text:FontType:DEVICE"><apiName>DEVICE</apiName><shortdesc>
		 Показывает, что данный шрифт является шрифтом устройства.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>device</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Показывает, что данный шрифт является шрифтом устройства. SWF-файл выполняет визуализацию с помощью шрифтов системы.
		 
		 <p>Использование шрифтов устройства сокращает размер ролика, так как в файл не включаются данные шрифтов. Шрифты устройства обычно оптимально подходят для отображения мелкого текста, так как при использовании малых кеглей сглаженный текст может выглядеть нечетко. Шрифты устройства так же хороши для больших блоков текста, например текста с прокруткой.</p>
		 
		 <p>Текстовые поля, использующие шрифты устройства, могут отображаться неодинаково в разных системах и на разных платформах, так как при их визуализации используются шрифты, установленные в системе. По этой же причине шрифты устройства не сглаживаются и при использовании больших кеглей могут выглядеть зазубренными.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED"><apiName>EMBEDDED</apiName><shortdesc>
		 Показывает, что данный шрифт является встроенным.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embedded</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Показывает, что данный шрифт является встроенным. Контуры шрифта встраиваются в публикуемый SWF-файл.
		 
		 <p>Текстовые поля, использующие встроенные шрифты, всегда отображаются с выбранным шрифтом, независимо от того, установлен он в воспроизводящей системе или нет. Кроме того, текстовые поля, использующие встроенные шрифты, всегда сглаживаются (смягчаются). Необходимый уровень сглаживания можно задать с помощью свойства <codeph>TextField.antiAliasType</codeph>.</p>
		 
		 <p>Недостатком встроенных шрифтов является то, что они увеличивают размер SWF-файла.</p>
		 
		 <p>Шрифты типа <codeph>EMBEDDED</codeph> могут использоваться только объектом TextField. Если классы flash.text.engine получают предписание использовать такой шрифт, они будут использовать шрифты устройства.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextField/embedFonts"><linktext>TextField.embedFonts</linktext></link></related-links></apiValue><apiValue id="flash.text:FontType:EMBEDDED_CFF"><apiName>EMBEDDED_CFF</apiName><shortdesc>
		 Показывает, что данный шрифт является встроенным шрифтом CFF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>embeddedCFF</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 Показывает, что данный шрифт является встроенным шрифтом CFF. Контуры шрифтов и подгруппа таблиц OpenType встраиваются в публикуемый SWF-файл.
		 
		 <p>Текст, использующий встроенные шрифты CFF, всегда отображаются с выбранным шрифтом, независимо от того, установлен он в воспроизводящей системе или нет. Кроме того, текст, использующий встроенные шрифты CFF, всегда сглаживается (смягчается) проигрывателем Flash Player. Для встроенного шрифта CFF можно выбрать режим визуализации и хинтинга CFF с помощью свойств <codeph>flash.text.engine.FontDescription.renderingMode</codeph> и <codeph>flash.text.engine.FontDescription.cffHinting</codeph>.</p>
		 
		 <p>Недостатком встроенных шрифтов CFF является то, что они увеличивают размер SWF-файла. Однако они обычно на 20-30% меньше обычных встроенных шрифтов.</p>
		 
		 <p>Шрифты типа <codeph>EMBEDDED_CFF</codeph> могут использоваться только классами flash.text.engine. Объект TextField, получивший предписание использовать такой шрифт, не сможет визуализировать текст.</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.text.engine.xml#FontDescription/fontLookup"><linktext>flash.text.engine.FontDescription.fontLookup</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFormatAlign"><apiName>TextFormatAlign</apiName><shortdesc>
 Класс TextFormatAlign передает значения для выравнивания текста в классе TextFormat.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextFormatAlign передает значения для выравнивания текста в классе TextFormat.
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links><apiValue id="flash.text:TextFormatAlign:CENTER"><apiName>CENTER</apiName><shortdesc>
	 Константа, которая задает выравнивание текста по центру в текстовом поле.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Константа, которая задает выравнивание текста по центру в текстовом поле. Используйте синтаксис <codeph>TextFormatAlign.CENTER</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:JUSTIFY"><apiName>JUSTIFY</apiName><shortdesc>
	 Константа, которая задает выравнивание текста по ширине в пределах текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>justify</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Константа, которая задает выравнивание текста по ширине в пределах текстового поля. Используйте синтаксис <codeph>TextFormatAlign.JUSTIFY</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
	 Константа, которая задает выравнивание текста по левому краю в пределах текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Константа, которая задает выравнивание текста по левому краю в пределах текстового поля. Используйте синтаксис <codeph>TextFormatAlign.LEFT</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue><apiValue id="flash.text:TextFormatAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
	 Константа, которая задает выравнивание текста по правому краю в пределах текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Константа, которая задает выравнивание текста по правому краю в пределах текстового поля. Используйте синтаксис <codeph>TextFormatAlign.RIGHT</codeph>.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextFormat/align"><linktext>flash.text.TextFormat.align</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:Font"><apiName>Font</apiName><shortdesc>
 Класс Font используется для управления встроенными шрифтами в SWF-файлах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Font используется для управления встроенными шрифтами в SWF-файлах. Встроенные шрифты представлены в виде подкласса класса Font. В этом случае класс Font используется только для получения информации о встроенных шрифтах. С его помощью нельзя изменить шрифт. Класс Font нельзя использовать для загрузки внешних шрифтов или для создания своего экземпляра Font. Класс Font следует использовать как абстрактный базовый класс.
 
 </apiDesc></apiClassifierDetail><apiOperation id="flash.text:Font:enumerateFonts"><apiName>enumerateFonts</apiName><shortdesc> 
    Определяет, должен ли предоставляться список текущих доступных встроенных шрифтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>Список доступных шрифтов в виде массива объектов Font.
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>enumerateDeviceFonts</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Указывает, требуется ли ограничить список только доступными на данный момент встроенными шрифтами. При значении <codeph>true</codeph> возвращается список всех шрифтов, включая шрифты устройства и встроенные шрифты. При значении <codeph>false</codeph> возвращается только список встроенных шрифтов.
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
    Определяет, должен ли предоставляться список текущих доступных встроенных шрифтов.
        </apiDesc><example conref="examples\Font.enumerateFonts.1.as"> В данном примере сначала вызывается статический метод <codeph>Font.enumerateFonts()</codeph> для получения списка всех шрифтов устройства и встроенных шрифтов. Затем полученный массив объектов Font сортируется по свойству <codeph>fontName</codeph>.
 
 <p>После этого показывается результат вызова метода <codeph>Font.enumerateFonts()</codeph> с параметром <codeph>enumerateDeviceFonts</codeph> в значении false. Полученный массив включает только встроенный объекты Font. (Если выполнить этот код в приложении, не содержащем встроенных шрифтов, то массив <codeph>embeddedFonts</codeph> будет пустым.)</p>
<codeblock>
 
import flash.text.Font;

var allFonts:Array = Font.enumerateFonts(true);
allFonts.sortOn("fontName", Array.CASEINSENSITIVE);

var embeddedFonts:Array = Font.enumerateFonts(false);
embeddedFonts.sortOn("fontName", Array.CASEINSENSITIVE);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:hasGlyphs"><apiName>hasGlyphs</apiName><shortdesc> 
        Показывает, может ли заданная строка отображаться с использованием текущего назначенного шрифта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Имеет значение <codeph>true</codeph>, если заданная строка может быть полностью отображена с использованием данного шрифта.
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, тестируемая с использованием текущего шрифта.
        </apiDesc></apiParam></apiOperationDef><apiDesc> 
        Показывает, может ли заданная строка отображаться с использованием текущего назначенного шрифта.
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:Font:registerFont"><apiName>registerFont</apiName><shortdesc> 
	Регистрирует класс шрифта в глобальном списке шрифтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>font</apiItemName><apiOperationClassifier>Class</apiOperationClassifier><apiDesc>Класс, который требуется добавить в глобальный список шрифтов.
	</apiDesc></apiParam></apiOperationDef><apiDesc> 
	Регистрирует класс шрифта в глобальном списке шрифтов.
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.text:Font:fontName:get"><apiName>fontName</apiName><shortdesc> 
	Имя встроенного шрифта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Имя встроенного шрифта. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:Font:fontStyle:get"><apiName>fontStyle</apiName><shortdesc> 
	Стиль шрифта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Стиль шрифта. Это может быть одно из значений, определенных в классе FontStyle.
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link></related-links></apiValue><apiValue id="flash.text:Font:fontType:get"><apiName>fontType</apiName><shortdesc> 
	Тип шрифта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Тип шрифта. Это может быть одна из констант, определенных в классе FontType.
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#FontType"><linktext>flash.text.FontType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextRenderer"><apiName>TextRenderer</apiName><shortdesc>
 Класс TextRenderer обеспечивает поддержку расширенных возможностей сглаживания встроенных шрифтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>-- Class sample changed due to bug 193833
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Управляет сглаживанием встроенных шрифтов.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextRenderer обеспечивает поддержку расширенных возможностей сглаживания встроенных шрифтов. Расширенное сглаживание позволяет высококачественно визуализировать шрифты небольшого размера. Используйте расширенное сглаживание при работе с приложениями, в которых много мелкого текста. Adobe не рекомендует использовать расширенное сглаживание для очень больших шрифтов (больше 48). Расширенное сглаживание доступно только в Flash Player версии 8 и более поздних.
 
 <p>Чтобы задать расширенное сглаживание для текстового поля, определите свойство <codeph>antiAliasType</codeph> экземпляра TextField.</p>
 
 <p>Расширенное сглаживание обеспечивает непрерывную модуляцию линий (CSM), которая включает непрерывную модуляцию веса линии и четкости краев. В качестве расширенной функции можно использовать метод <codeph>setAdvancedAntiAliasingTable()</codeph> для определения параметров для конкретных гарнитур и размеров шрифта.</p>
 
 </apiDesc><example conref="examples\TextRendererExample2.as"> В следующем примере создается класс TextRendererExample для демонстрации наглядных примеров параметров расширенного сглаживания для мелкого и крупного шрифта. Перед тестированием этого примера потребуется встроить шрифт. Если используется Flex, шрифт встраивается следующим образом.
 <ol>
    <li>Поместите шрифт Georgia (файл с именем georgia.ttf) в тот же каталог, что и данный файл AS.</li>
    <li>Добавьте следующие строки непосредственно под определение класса.</li>
    <li><codeph>[Embed(source="georgia.ttf", fontFamily="Georgia")]</codeph></li>
    <li><codeph>private var embeddedFont:String;</codeph></li>
 </ol>
 Если используется Flash, шрифт встраивается следующим образом.
 <ol>
     <li>Поместите текстовое поле в рабочую область и выделите его.</li>
     <li>В инспекторе свойств выберите для текстового поля шрифт Georgia.</li>
     <li>В инспекторе свойств нажмите «Встроить...» и выберите «Все».</li>
 </ol>
 <p> <b>Примечания.</b>
  <ul>
     <li>SWF-файл потребуется откомпилировать с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к локальным файлам».</li>
    </ul>
 </p>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.text.*;
    
    public class TextRendererExample2 extends Sprite {

        private var gutter:int = 10;

        public function TextRendererExample2() {
            createTextField(8,AntiAliasType.NORMAL);
            createTextField(8,AntiAliasType.ADVANCED);
            createTextField(24,AntiAliasType.NORMAL);
            createTextField(24,AntiAliasType.ADVANCED);
        }
            
        private function createTextField(fontSize:Number,antiAliasType:String):TextField {
            var tf:TextField = new TextField();
            tf.embedFonts = true;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.antiAliasType = antiAliasType;
            tf.defaultTextFormat = getTextFormat(fontSize);
            tf.selectable = false;
            tf.mouseEnabled = true;
            tf.text = "The quick brown fox jumped over the lazy dog.";
            if(numChildren > 0) {
                var sibling:DisplayObject = getChildAt(numChildren - 1);
                tf.y = sibling.y + sibling.height + gutter;
            }
            addChild(tf);
            return tf;
        }
        
        private function getTextFormat(fontSize:Number):TextFormat {
            var format:TextFormat = new TextFormat();
            format.size = fontSize;
            format.font = "Georgia";
            return format;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/antiAliasType"><linktext>flash.text.TextField.antiAliasType</linktext></link></related-links><apiOperation id="flash.text:TextRenderer:setAdvancedAntiAliasingTable"><apiName>setAdvancedAntiAliasingTable</apiName><shortdesc>
	 Задает пользовательскую справочную таблицу непрерывной модуляции линий (CSM) для шрифта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates two anti-alias entries and two text fields to 
	 illustrate them. For this example to work, the SWF file must have a shared font embedded with a linkage identifier of <code>
	 "myArial"</code>. 
	 To embed the font, follow these steps:
	 <ol>
	 <li>Open your Library.</li>
	 <li>Click the Library options menu in the upper-right corner of the Library.</li>
	 <li>Select New Font from the pop-up menu.</li>
	 <li>Name the font <b>myArial</b>.</li>
	 <li>Select Arial from the font pop-up menu.</li>
	 <li>Click OK.</li>
	 <li>Right-click the newly created font, and select Linkage.</li>
	 <li>Select the Export for ActionScript check box.</li>
	 <li>Click OK to accept the default identifier, myArial.</li>
	 </ol>
	 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 
	 var antiAliasEntry_1 = {fontSize:24, insideCutoff:1.61, outsideCutoff:-3.43};
	 var antiAliasEntry_2 = {fontSize:48, insideCutoff:0.8, outsideCutoff:-0.8};
	 var arialTable:Array = new Array(antiAliasEntry_1, antiAliasEntry_2);
	 
	 var lbl_1:TextField = createLabel(0, 0, 300, 100, 24);
	 var lbl_2:TextField = createLabel(0, 100, 300, 100, 48);
	 
	 TextRenderer.setAdvancedAntiAliasingTable("Arial", "none", "dark", arialTable);
	 
	 function createLabel(x:Number, y:Number, width:Number, height:Number, fontSize:Number):TextField {
	 var depth:Number = this.getNextHighestDepth();
	 
	 var tmpTxt = this.createTextField("txt_" + depth, depth, x, y, width, height);
	 tmpTxt.antiAliasType = "advanced";
	 tmpTxt.gridFitType = "pixel";
	 tmpTxt.border = true;
	 tmpTxt.text = "Hello World";
	 tmpTxt.embedFonts = true;
	 tmpTxt.setTextFormat(getTextFormat(fontSize));
	 return tmpTxt;
	 }
	 
	 function getTextFormat(fontSize:Number):TextFormat {
	 	var tf:TextFormat = new TextFormat();
	 	tf.align = "center";
	 	tf.size = fontSize;
	 	tf.font = "myArial";
	 	return tf;
	 }
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>fontName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя шрифта, для которого применяются параметры.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fontStyle</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Стиль шрифта, указанный с помощью одного из значений класса flash.text.FontStyle.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorType</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Это значение определяет, будет линия темной или светлой. Используйте одно из значений класса flash.text.TextColorType. 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>advancedAntiAliasingTable</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>Массив одного или нескольких объектов CSMSettings для заданного шрифта. Каждый объект содержит следующие свойства:
	 
	 <ul>
	 
	   <li><codeph>fontSize</codeph></li>
	   <li><codeph>insideCutOff</codeph></li>
	   <li><codeph>outsideCutOff</codeph></li>
	 
	 </ul>
	 
	 <p>Массив <codeph>advancedAntiAliasingTable</codeph> может содержать несколько записей, задающих параметры CSM для разных размеров шрифта.</p>
	 
	 <p>Свойство <codeph>fontSize</codeph> – это размер (в пикселях), для которого применяются параметры.</p>
	 
	 <p>Расширенное сглаживание использует адаптивно выбираемые поля расстояния (ADF) для представления контуров, определяющих глиф. Проигрыватель Flash Player использует значение внешнего среза (<codeph>outsideCutOff</codeph>), под которым все плотности поучают значение 0, и значение внутреннего среза (<codeph>insideCutOff</codeph>), над которым плотности получают максимальное значение (например, 255). С учетом этих двух значений среза функция наложения представляет собой линейную кривую в диапазоне от нуля по внешнему срезу до максимальной плотности по внутреннему.</p>
	 
	 <p>Регулировка значений внешнего и внутреннего срезов влияет на вес линии и четкость краев. Интервал между этими двумя параметрами сопоставим с удвоенным радиусом фильтра классических методов сглаживания. Небольшой интервал дает более резкие края, а более широкий делает края более плавными или сглаженными. Когда интервал равен нулю, изображение с полученной плотностью является двухуровневым растровым изображением. Когда интервал очень большой, изображение с полученной плотностью имеет размытые края, напоминающие акварель.</p>
	 
	 <p>Как правило, пользователи отдают предпочтение резким, контрастным краям при использовании малых кеглей и более мягкие края для анимированного текста и более крупных кеглей. </p>
	 
	 <p>Внешний срез обычно имеет отрицательное значение, а внутренний – положительное, а средняя точка, как правило, находится около нуля. Регулировка этих параметров для смещения средней точки к отрицательному множеству увеличивает вес линии. Смещение средней точки к положительному множеству уменьшает вес линии. Необходимо следить, чтобы значение внешнего среза всегда было меньше или равно значению внутреннего среза.</p>
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает пользовательскую справочную таблицу непрерывной модуляции линий (CSM) для шрифта. Проигрыватель Flash Player пытается найти оптимальную модуляцию CSM для выбранного шрифта. Если Вас не устраивает модуляция CSM, предлагаемая проигрывателем, можно создавать собственную CSM с помощью метода <codeph>setAdvancedAntiAliasingTable()</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#FontStyle"><linktext>flash.text.FontStyle</linktext></link><link href="flash.text.xml#TextColorType"><linktext>flash.text.TextColorType</linktext></link><link href="flash.text.xml#CSMSettings"><linktext>CSMSettings</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextRenderer:displayMode:get"><apiName>displayMode</apiName><shortdesc> 
	 Управляет визуализацией текста с дополнительным сглаживанием.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>"default"
	 </apiDefaultValue></apiValueDef><apiDesc> 
	 Управляет визуализацией текста с дополнительным сглаживанием. Визуальное качество текста в значительной мере субъективно, и хотя проигрыватель Flash Player пытается использовать оптимальные параметры для различных условий, дизайнеры могут выбрать другой вид для своего текста. Кроме того, метод <codeph>displayMode</codeph> позволяет дизайнерам переопределять субпиксельные значения проигрывателя Flash Player и создавать визуальную согласованность независимо от аппаратных средств пользователя. Для определения этого свойства используются значения класса TextDisplayMode.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextDisplayMode"><linktext>Класс TextDisplayMode</linktext></link></related-links></apiValue><apiValue id="flash.text:TextRenderer:maxLevel:get"><apiName>maxLevel</apiName><shortdesc>
	 Уровень качества полей ADF для расширенных возможностей сглаживания.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example specifies the <code>maxLevel</code> value for the entire
	 SWF file, and then displays a text field with the value set. For the 
	 text in this example to display correctly, there must be a font symbol available with
	 a linkage identifier of <code>"CustomFont"</code>. 
	 <listing version="2.0">
	 import flash.text.TextRenderer;
	 TextRenderer.maxLevel = 3;
	 
	 var txtFormat:TextFormat = new TextFormat();
	 txtFormat.font = "CustomFont";
	 txtFormat.size = 64;
	 
	 var label:TextField = this.createTextField("label", this.getNextHighestDepth(), 10, 10, 500, 100);
	 label.setNewTextFormat(txtFormat);
	 label.text = "Hello World";
	 label.embedFonts = true;
	 trace("TextRenderer.maxLevel: " + TextRenderer.maxLevel);
	 </listing>
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiDefaultValue>4
	 </apiDefaultValue></apiValueDef><apiDesc>
	 Уровень качества полей ADF для расширенных возможностей сглаживания. Допускаются только значения 3, 4 и 7. 
	 
	 <p>Расширенное сглаживание использует поля (ADF) для представления контуров, определяющих глиф. Чем выше качество, тем больше кэша требуют структуры ADF. При значении <codeph>3</codeph> потребляется меньше всего памяти и обеспечивается самое низкое качество. Для более крупных шрифтов требуется больше кэша. Для шрифта размером 64 пикселя уровень качества увеличивается с <codeph>3</codeph> до <codeph>4</codeph> или с <codeph>4</codeph> до <codeph>7</codeph>, если еще не выбран уровень <codeph>7</codeph>.</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
 Класс TextLineMetrics содержит данные о положении текста и размерах строки текста в пределах текстового поля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>Содержит данные о расположении текста и размерах строки текста в текстовом поле.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс TextLineMetrics содержит данные о положении текста и размерах <i>строки текста</i> в пределах текстового поля. Все размеры измеряются в пикселях. Объекты этого класса возвращаются методом <codeph>flash.text.TextField.getLineMetrics()</codeph>.
 <p>Размеры, связанные с текстовым полем, содержащим строку текста (например, «Высота текстового поля» на рисунке) см. в описании flash.text.TextField. </p>
 
 <p>На следующем рисунке представлены точки и размеры текстового поля и содержащейся в нем строки текста.</p>
 <p>
 <adobeimage alt="Изображение, иллюстрирующее показатели текста" href="../../images/text-metrics.jpg"/></p>
 
 </apiDesc><example conref="examples\TextLineMetricsExample.as"> В следующем примере создаются классы TextLineMetricsExample и LineMetricsReader для вывода сообщения в проигрывателе Flash Player посредством объекта XML. Это можно сделать, выполнив следующие действия:
 <ol>
  <li>Создайте свойство типа TextField с именем <codeph>label</codeph>.</li>
  <li>Конструктор вызывает метод <codeph>configureAssets()</codeph>, который выполняет следующие задачи:
  <ul>
      <li>задает выравнивание монтажного стола по верхнему и левому краям и запрещает масштабирование;</li>
      <li>создает новый объект TextField с именем <codeph>label</codeph>;</li>
      <li>включает фон для <codeph>label</codeph> и задает ему белый цвет;</li>
      <li>разрешает тексту объекта <codeph>label</codeph> занимать несколько линий с автоматическим переносом слов;</li>
      <li>назначает результат вызова метода <codeph>getLabelText()</codeph> свойству <codeph>text</codeph> объекта <codeph>label</codeph>; метод <codeph>getLabelText()</codeph> создает переменную типа XML и назначает ее узлу XML с именем<codeph>body</codeph>, который заполняется длинными предложением;</li>
      <li>добавляет объект <codeph>label</codeph> в список отображения с помощью метода <codeph>addChild()</codeph>.</li>
  </ul>
  </li>
  <li>Затем добавляется метод, который прослушивает события <codeph>resize</codeph>, происходящие на монтажном столе, и называется <codeph>resizeHandler()</codeph>. Каждый раз, когда изменяется размер окна проигрывателя Flash Player, отправляется событие <codeph>RESIZE</codeph>, затем происходит следующее. 
  <ul>
      <li>Вызывается метод <codeph>draw()</codeph>, чтобы объект <codeph>label</codeph> находился в центре рабочей области и был окружен буфером с шириной, равной десяти пикселям.</li>
      <li>Затем метод <codeph>setTimeout()</codeph> вызывает <codeph>showMetrics()</codeph> после короткой задержки. Задержка добавляется, так как показатели линии обновляются только после завершения события <codeph>RESIZE</codeph> и повторной отрисовки монтажного стола.</li>
      <li>Метод <codeph>showMetrics()</codeph> назначает переменную TextLineMetrics с именем <codeph>metrics</codeph> результату вызова <codeph>getLineMetrics()</codeph>, после чего эта переменная передается новому экземпляру LineMetricsReader с именем <codeph>reader</codeph>. Затем эти две переменные используются в вызовах метода <codeph>trace()</codeph> для вывода первой (и единственной) строки объекта <codeph>label</codeph> и сведений, переданных экземпляром LineMetricsReader с помощью метода <codeph>toString()</codeph>.</li>
  </ul>
  </li>
  <li>Конструктор инициирует одну отправку события <codeph>resize</codeph> чтобы обеспечить правильную отрисовку объекта <codeph>label</codeph> при первой загрузке SWF-файла.</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.*;
    import flash.text.TextField;
    import flash.text.TextLineMetrics;
    import flash.utils.setTimeout;

    public class TextLineMetricsExample extends Sprite {
        private var gutter:int = 10;
        private var label:TextField;

        public function TextLineMetricsExample() {
            configureAssets();
            configureListeners();
            resizeHandler(new Event(Event.RESIZE));
        }

        private function showMetrics():void {
            var metrics:TextLineMetrics = label.getLineMetrics(0);
            var reader:LineMetricsReader = new LineMetricsReader(metrics);
            trace("lineText: " + label.getLineText(0));
            trace("metrics: " + reader);
        }

        private function configureAssets():void {
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;

            label = new TextField();
            label.background = true;
            label.backgroundColor = 0xFFFFFF;
            label.multiline = true;
            label.wordWrap = true;
            label.text = getLabelText();
            addChild(label);
        }

        private function configureListeners():void {
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function resizeHandler(event:Event):void {
            draw();
            setTimeout(showMetrics, 100);
        }

        private function draw():void {
            label.x = gutter;
            label.y = gutter;
            label.width = stage.stageWidth - (gutter * 2);
            label.height = stage.stageHeight - (gutter * 2);
        }

        private function getLabelText():String {
            var text:XML = &lt;body>The Flex product line enables developers to build rich Internet applications that blend the responsiveness of desktop software, the cross-platform reach of the web, and the expressiveness of the Flash Platform.&lt;/body>
            return text.toString();
        }
    }
}

import flash.text.TextLineMetrics;

class LineMetricsReader {
    private var metrics:TextLineMetrics;

    public function LineMetricsReader(metrics:TextLineMetrics) {
        this.metrics = metrics;
    }

    public function toString():String {
        return "[TextLineMetrics ascent:" + metrics.ascent
            + ", descent:" + metrics.descent
            + ", leading:" + metrics.leading
            + ", width:" + metrics.width
            + ", height:" + metrics.height
            + ", x:" + metrics.x
            + "]";
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:TextLineMetrics:TextLineMetrics"><apiName>TextLineMetrics</apiName><shortdesc>
	 Создает объект TextLineMetrics.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Положение первого символа с левого края (в пикселях).
	 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Ширина в пикселях для текста выбранных строк (необязательно всего текста).
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Высота в пикселях для текста выбранных строк (необязательно всего текста).
	 </apiDesc></apiParam><apiParam><apiItemName>ascent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Длина в пикселях от основной линии до верхней точки строки.
	 </apiDesc></apiParam><apiParam><apiItemName>descent</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Длина в пикселях от основной линии до нижней точки строки.
	 </apiDesc></apiParam><apiParam><apiItemName>leading</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Расстояние между строками текста по вертикали.
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Содержит данные о расположении текста и размерах строки текста в текстовом поле.
  	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 Создает объект TextLineMetrics. Объект TextLineMetrics содержит данные о размерах строки текста в пределах текстового поля. Объекты этого класса возвращаются методом <codeph>flash.text.TextField.getLineMetrics()</codeph>.
	 <p>См. рисунок в описании этого класса, где данные свойства представлены в контексте.</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link><link href="flash.text.xml#TextField/getLineMetrics()"><linktext>flash.text.TextField.getLineMetrics()</linktext></link></related-links></apiConstructor><apiValue id="flash.text:TextLineMetrics:ascent"><apiName>ascent</apiName><shortdesc>
	 Значение ascent соответствует расстоянию в пикселях от базовой линии до верхнего края строки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>including accents? is it really the line or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение ascent соответствует расстоянию в пикселях от базовой линии до верхнего края строки. См. «Подъем» в обзорном рисунке для данного класса.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:descent"><apiName>descent</apiName><shortdesc>
	 Значение descent соответствует расстоянию в пикселях от базовой линии до нижнего края строки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>is it really the line? or the font itself?
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение descent соответствует расстоянию в пикселях от базовой линии до нижнего края строки. См. «Спуск» в обзорном рисунке для данного класса.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:height"><apiName>height</apiName><shortdesc>
	 Значение height соответствует высоте в пикселях для текста выбранных строк (необязательно всего текста).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение height соответствует высоте в пикселях для текста выбранных строк (необязательно всего текста). Высота строки текста не включает высоту промежуточного поля. См. «Высота строки» в обзорном рисунке для данного класса.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:leading"><apiName>leading</apiName><shortdesc>
	 Значение leading соответствует расстоянию между строками текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение leading соответствует расстоянию между строками текста. См. «Интервал» в обзорном рисунке для данного класса.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:width"><apiName>width</apiName><shortdesc>
	 Значение width соответствует ширине в пикселях для текста выбранных строк (необязательно всего текста).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение width соответствует ширине в пикселях для текста выбранных строк (необязательно всего текста). Ширина строки текста не равна ширине текстового поля. Ширина строки текста определяется относительно ширины текстового поля минус ширина промежуточного поля, равного 4 пикселям (по 2 пикселя с каждой стороны). См. «Ширина строки текста» в обзорном рисунке для данного класса.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link></related-links></apiValue><apiValue id="flash.text:TextLineMetrics:x"><apiName>x</apiName><shortdesc>
	 Значение x соответствует положению первого символа слева (в пикселях).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 Значение x соответствует положению первого символа слева (в пикселях). Это значение включает значения ширины полей, отступов (если они есть) и промежуточного поля. См. «Положение строки текста по оси х» в обзорном рисунке для данного класса.
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextLineMetrics"><linktext>Описание класса TextLineMetrics</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
 Класс StyleSheet позволяет создать объект StyleSheet, содержащий правила форматирования текста для размера, цвета текста и других стилей.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextField, StyleSheet class, built-in class, style sheet, stylesheet
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Позволяет создавать объект StyleSheet.
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс StyleSheet позволяет создать объект StyleSheet, содержащий правила форматирования текста для размера, цвета текста и других стилей. После этого можно применять стили, определенные в таблице стилей, к объекту TextField, содержащему текст в формате HTML или XML. Текст в объекте TextField автоматически форматируется в соответствии со стилями тегов, определенными объектом StyleSheet. Стили текста можно использовать для определения новых тегов форматирования, переопределения встроенных тегов HTML или создания классов стилей, которые можно применять к определенным тегам HTML.
 
 <p>Чтобы применить стили к объекту TextField, назначьте объект StyleSheet его свойству <codeph>styleSheet</codeph>.</p>
 <p><b>Примечание.</b> Текстовое поле с таблицей стилей не подлежит редактированию. Другими словами, текстовое поле со свойством <codeph>type</codeph> в значении <codeph>TextFieldType.INPUT</codeph> применяет объект StyleSheet к тексту по умолчанию для поля, но его содержимое больше не будет доступно для редактирования. Для назначения стилей текстовым полям ввода можно использовать класс TextFormat.</p> 
 
 <p>Проигрыватель Flash Player поддерживает подгруппу свойств в исходной спецификации CSS1 (<xref href="http://www.w3.org/TR/REC-CSS1" scope="external">www.w3.org/TR/REC-CSS1</xref>). В следующей таблице перечислены поддерживаемые свойства и значения CSS, а также имена соответствующих им свойств ActionScript. (Каждое имя свойства ActionScript является производным от соответствующего имени свойства CSS. Если имя содержит дефис, он опускается, а следующая за ним буква становится заглавной.)</p>
 
 <adobetable class="innertable">
 
   
 
   
 
   
 
   
 
   
 
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
   
 
 <tgroup cols="3"><thead><row><entry>Свойство CSS</entry><entry>Свойство ActionScript</entry><entry>Применение и поддерживаемые значения</entry></row></thead><tbody><row>
     <entry><codeph>color</codeph></entry>
     <entry><codeph>color</codeph></entry>
     <entry>Поддерживаются только шестнадцатеричные значения цвета. Именованные цвета (например, <codeph>blue</codeph> – синий) не поддерживаются. Цвета записываются в следующем формате: <codeph>#FF0000</codeph>.</entry>
   </row><row>
     <entry><codeph>display</codeph></entry>
     <entry><codeph>display</codeph></entry>
     <entry>Поддерживаются следующие значения: <codeph>inline</codeph>, <codeph>block</codeph> и <codeph>none</codeph>.</entry>
   </row><row>
     <entry><codeph>font-family</codeph></entry>
     <entry><codeph>fontFamily</codeph></entry>
     <entry>Разделенный запятыми список шрифтов для использования, перечисленных в порядке убывания по предпочтению. Может использоваться любое имя гарнитуры шрифтов. При указании общего имени шрифта оно преобразовывается в соответствующий шрифт устройства. Поддерживаются следующие преобразования шрифтов: <codeph>mono</codeph> преобразуется в <codeph>_typewriter</codeph>, <codeph>sans-serif</codeph> – в <codeph>_sans</codeph>, а <codeph>serif</codeph> – в <codeph>_serif</codeph>.</entry>
   </row><row>
     <entry><codeph>font-size</codeph></entry>
     <entry><codeph>fontSize</codeph> </entry>
     <entry>Используется только числовая часть значения. Единицы (пиксели, точки) не анализируются. Пиксели эквивалентны точкам.</entry>
   </row><row>
     <entry><codeph>font-style</codeph></entry>
     <entry><codeph>fontStyle</codeph></entry>
     <entry>Распознаются значения <codeph>normal</codeph> (обычный) и <codeph>italic</codeph> (курсив).</entry>
   </row><row>
     <entry><codeph>font-weight</codeph></entry>
     <entry><codeph>fontWeight</codeph></entry>
     <entry>Допустимыми значениями являются <codeph>normal</codeph> и <codeph> bold</codeph>.</entry>
   </row><row>
     <entry><codeph>кернинг</codeph></entry>
     <entry><codeph>кернинг</codeph></entry>
     <entry>Распознаются значения <codeph>true</codeph> и <codeph>false</codeph>. Кернинг поддерживается только для встроенных шрифтов. Некоторые шрифты, такие как Courier New, не поддерживают кернинг. Свойство kerning поддерживается только в SWF-файлах, созданных в ОС Windows, а в созданных в ОС Macintosh – нет. Однако эти SWF-файлы могут воспроизводиться с применением кернинга и в версиях проигрывателя Flash Player, не предназначенных не для Windows.</entry>
   </row><row>
     <entry><codeph>leading</codeph></entry>
     <entry><codeph>leading</codeph></entry>
     <entry>Пространство, равномерно распределяемое между строками. Это значение задает количество пикселей, добавляемых после каждой строки. Отрицательное значение уплотняет межстрочное пространство. Используется только числовая часть значения. Единицы (пиксели, точки) не анализируются. Пиксели эквивалентны точкам.</entry>
   </row><row>
     <entry><codeph>letter-spacing</codeph></entry>
     <entry><codeph>letterSpacing</codeph></entry>
     <entry>Пространство, равномерно распределяемое между символами. Это значение задает количество пикселей, добавляемых после каждого символа. Отрицательное значение уплотняет пространство между символами. Используется только числовая часть значения. Единицы (пиксели, точки) не анализируются. Пиксели эквивалентны точкам.</entry>
   </row><row>
     <entry><codeph>margin-left</codeph></entry>
     <entry><codeph>marginLeft</codeph></entry>
     <entry>Используется только числовая часть значения. Единицы (пиксели, точки) не анализируются. Пиксели эквивалентны точкам. </entry>
   </row><row>
     <entry><codeph>margin-right</codeph></entry>
     <entry><codeph>marginRight</codeph></entry>
     <entry>Используется только числовая часть значения. Единицы (пиксели, точки) не анализируются. Пиксели эквивалентны точкам.</entry>
   </row><row>
     <entry><codeph>text-align</codeph></entry>
     <entry><codeph>textAlign</codeph></entry>
     <entry>Распознаются значения <codeph>left</codeph>, <codeph>center</codeph>, <codeph>right</codeph> и <codeph>justify</codeph>.</entry>
   </row><row>
     <entry><codeph>text-decoration</codeph></entry>
     <entry><codeph>textDecoration</codeph></entry>
     <entry>Распознаются значения <codeph>none</codeph> и <codeph>underline</codeph>.</entry>
   </row><row>
     <entry><codeph>text-indent</codeph></entry>
     <entry><codeph>textIndent</codeph></entry>
     <entry>Используется только числовая часть значения. Единицы (пиксели, точки) не анализируются. Пиксели эквивалентны точкам. </entry>
   </row></tbody></tgroup></adobetable> 
 
 <p><ph outputclass="flexonly"> Класс StyleSheet можно использовать для выполнения визуализации текста на низком уровне. Однако в Flex для обработки текста обычно используются элементы управления Label, Text, TextArea и TextInput.</ph></p>
 
 
 </apiDesc><example conref="examples\StyleSheetExample.as"> В следующем примере создается новая таблица стилей, стилю заголовка присваивается полужирный красный шрифт.
<codeblock>
 
package {
    import flash.display.Sprite;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;

    public class StyleSheetExample extends Sprite {

        public function StyleSheetExample() {
            var style:StyleSheet = new StyleSheet();

            var heading:Object = new Object();
            heading.fontWeight = "bold";
            heading.color = "#FF0000";

            var body:Object = new Object();
            body.fontStyle = "italic";

            style.setStyle(".heading", heading);
            style.setStyle("body", body);

            var label:TextField = new TextField();
            label.styleSheet = style;
            label.htmlText = "&lt;body>&lt;span class='heading'>Hello &lt;/span>World...&lt;/body>";
            addChild(label);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.text.xml#TextField"><linktext>flash.text.TextField</linktext></link></related-links><apiConstructor id="flash.text:StyleSheet:StyleSheet"><apiName>StyleSheet</apiName><shortdesc>
	 Создает новый объект StyleSheet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet, constructor
	 </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 Создает новый объект StyleSheet.
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.text.xml#StyleSheet/getStyle()"><linktext>flash.text.StyleSheet.getStyle()</linktext></link></related-links></apiConstructor><apiOperation id="flash.text:StyleSheet:clear"><apiName>clear</apiName><shortdesc>
	 Удаляет все стили из объекта StyleSheet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.clear, clear
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Удаляет все стили из объекта StyleSheet.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:getStyle"><apiName>getStyle</apiName><shortdesc> 
	 Возвращает копию объекта стиля, связанного со стилем с именем styleName.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyle, getStyle
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, задающая имя стиля, который нужно получить.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc> 
	 Возвращает копию объекта стиля, связанного со стилем с именем <codeph>styleName</codeph>. Если с <codeph>styleName</codeph> не связан объект стиля, возвращается значение <codeph>null</codeph>.
	 
	 </apiDesc><example>См. примеры метода <xref href="StyleSheet.html#parseCSS()">parseCSS()</xref> или <xref href="StyleSheet.html#transform()">transform()</xref>, иллюстрирующие использование <codeph>getStyle()</codeph>. 
	 </example></apiOperationDetail><related-links><link href="flash.text.xml#StyleSheet/setStyle()"><linktext>flash.text.StyleSheet.setStyle()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:StyleSheet:parseCSS"><apiName>parseCSS</apiName><shortdesc>
	 Выполняет синтаксический анализ CSS в параметре CSSText и заполняет таблицу стилей полученными данными.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.parseCSS, parseCSS
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>CSSText</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Текст CSS для анализа (строка).
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>Выполняет лексический анализ CSS в параметре cssText и загружает StyleSheet.
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 Выполняет синтаксический анализ CSS в параметре <codeph>CSSText</codeph> и заполняет таблицу стилей полученными данными. Если стиль из <codeph>CSSText</codeph> уже занесен в <codeph>styleSheet</codeph>, свойства в <codeph>styleSheet</codeph> сохраняются, и в <codeph>styleSheet</codeph> добавляются или изменяются только те свойства, которые перечислены в <codeph>CSSText</codeph>.
	 
	 <p>Чтобы расширить собственные возможности синтаксического анализа CSS, можно переопределить этот метод путем создания подкласса StyleSheet.</p>
	 
	 </apiDesc><example conref="examples\StyleSheet_parseCSSExample.as"> В следующем примере, когда пользователь щелкает по файлу текста, к содержимому применяются стили CSS, загруженные из файла.
 
 <p>В конструкторе создается многострочное текстовое поле, его содержимое форматируется в виде HTML-строки. (HTML-теги заголовка и диапазона не визуализируются до применения стиля CSS.) Для определения местоположения CSS-файла создается объект <codeph>URLRequest</codeph>. В данном примере он CSS-файл находится в том же каталоге, что и SWF-файл. Файл загружается с помощью объекта <codeph>URLLoader</codeph>. Для объекта URLLoader с именем <codeph>loader</codeph> добавляется два прослушивателя событий. При возникновении ошибки ввода-вывода вызывается метод <codeph>errorHandler()</codeph>, отображающий сообщение об ошибке в текстовом поле. Когда все данные будут получены и помещены в свойство data объекта URLLoader с именем <codeph>loader</codeph>, вызывается метод <codeph>loaderCompleteHandler()</codeph>. Этот метод выделяет стили CSS из данных, загруженных из файла, и заполняет объект StyleSheet с именем <codeph>sheet</codeph> определениями стилей.</p>
 
 <p>Когда пользователь щелкает текстовое поле, запускается метод <codeph>clickHandler()</codeph>. Инструкция if в методе <codeph>clickHandler()</codeph> проверяет, завершена ли загрузка файла, перед применением таблицы стилей к текстовому полю. Чтобы таблица стилей вступила в силу, необходимо повторно назначить содержимое свойству <codeph>htmlText</codeph> после того, как текстовому полю будет назначена таблица стилей. Значения свойств CSS <codeph>font-family</codeph> и <codeph>color</codeph> для тега заголовка также добавляются к содержимому текстового поля. (Эти свойства будут иметь значение undefined, если значения таблицы стилей не вступили в силу.)</p> 
 
 <p>В следующем примере демонстрируется содержимое CSS-файла, которое может использоваться в этом случае. Перед выполнением этого примера создайте текстовый файл, скопируйте в него следующее содержимое CSS, а затем сохраните его с именем <codeph>test.css</codeph> в том же каталоге, что и SWF-файл.</p>
 
 <pre>
   p {
      font-family: Times New Roman, Times, _serif;
      font-size: 14;
       font-Style: italic;
        margin-left: 10;  
   }
   h1 {
      font-family: Arial, Helvetica, _sans;
      font-size: 20;
      font-weight: bold;
   }
   .bluetext {
      color: #0000CC;
   }
 </pre>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFieldAutoSize;
    import flash.events.IOErrorEvent;
    import flash.events.Event;
    import flash.events.MouseEvent;

    public class StyleSheet_parseCSSExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var field:TextField = new TextField();
        private var exampleText:String = "&lt;h1>This is a headline&lt;/h1>"
                    + "&lt;p>This is a line of text. &lt;span class='bluetext'>" 
                    + "This line of text is colored blue.&lt;/span>&lt;/p>";
        private var sheet:StyleSheet = new StyleSheet();
        private var cssReady:Boolean = false;

        public function StyleSheet_parseCSSExample() {
            field.x = 10;
            field.y = 10;
            field.background = true;
            field.multiline = true;
            field.autoSize = TextFieldAutoSize.LEFT;
            field.htmlText = exampleText;

            field.addEventListener(MouseEvent.CLICK, clickHandler);
            
            addChild(field);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            field.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            sheet.parseCSS(loader.data);
            cssReady = true;
        }

        public function clickHandler(e:MouseEvent):void {

            if (cssReady) {
                field.styleSheet = sheet;
                field.htmlText = exampleText;
                
                var style:Object = sheet.getStyle("h1");
                field.htmlText += "&lt;p>Headline font-family is: " + style.fontFamily + "&lt;/p>";
                field.htmlText += "&lt;p>Headline color is: " + style.color + "&lt;/p>";  

            } else {
                field.htmlText = "Couldn't apply the CSS styles.";
            }
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:setStyle"><apiName>setStyle</apiName><shortdesc>
	 Добавляет новый стиль с заданным именем в объект StyleSheet.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example adds a style named <code>emphasized</code> to the 
	 StyleSheet <code>myStyleSheet</code>. The style includes two style properties: <code>color</code> 
	 and <code>fontWeight</code>. The style object is defined with the <code>{}</code> operator.
	 <pre><code>
	 myStyleSheet.setStyle("emphasized", {color:'#000000',fontWeight:'bold'});
	 </code></pre>
	 
	 <p>You could also create a style object using an instance of the Object class, and 
	 then pass that object (<code>styleObj</code>) as 
	 the <code>style</code> parameter, as the next example shows:</p>
	 <listing version="2.0">
	 import TextField.StyleSheet;
	 var my_styleSheet:StyleSheet = new StyleSheet();
	 
	 var styleObj:Object = new Object();
	 styleObj.color = "#000000";
	 styleObj.fontWeight = "bold";
	 my_styleSheet.setStyle("emphasized", styleObj);
	 delete styleObj;
	 
	 var styleNames_array:Array = my_styleSheet.getStyleNames();
	 for (var i=0;i&lt;styleNames_array.length;i++) {
	 	var styleName:String = styleNames_array[i];
	 	var thisStyle:Object = my_styleSheet.getStyle(styleName);
	 	trace(styleName);
	 	for (var prop in thisStyle) {
	 		trace("\t"+prop+": "+thisStyle[prop]);
	 	}
	 	trace("");
	 }
	 </listing>
	 <p><span class="flashonly">The following information appears in the Output 
	 panel:</span><span class="flexonly">The following information writes to the 
	 log file:</span></p>
	 <pre><code>
	 emphasized
	   fontWeight: bold
	   color: #000000
	 </code></pre>
	 
	 <p><strong>Note: </strong>Because Flash Player creates a copy of the style object
	 you pass to <code>setStyle()</code>, the <code> delete styleObj</code> command in the 
	 code example reduces memory usage by deleting the original style object passed to 
	 <code>setStyle()</code>.</p>
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>styleName</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, задающая имя стиля для добавления в таблицу стилей.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>styleObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект, описывающий стиль, или <codeph>null</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Добавляет новый стиль с заданным именем в объект StyleSheet. Если названный стиль еще не существует в таблице стилей, он добавляется в нее. Если названный стиль уже существует в таблице стилей, он заменяется новым. Если параметр <codeph>styleObject</codeph> имеет значение <codeph>null</codeph>, названный стиль удаляется.
	 
	 <p>Проигрыватель Flash Player создает копию объекта стиля, передаваемого этому методу.</p>
	 
	 <p>Поддерживаемые стили перечислены в таблице в описании класса StyleSheet.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.text:StyleSheet:transform"><apiName>transform</apiName><shortdesc>
	 Расширяет возможности лексического анализа CSS.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.transform, transform
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект TextFormat, содержащий результат наложения правил CSS на свойства форматирования текста.
	 
	 </apiDesc><apiOperationClassifier>flash.text:TextFormat</apiOperationClassifier></apiReturn><apiParam><apiItemName>formatObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>Объект, описывающий стиль, содержащий правила стилей в виде свойств объекта, или <codeph>null</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Расширяет возможности лексического анализа CSS. Опытные разработчики могут переопределить этот метод путем расширения класса StyleSheet. 
	 
	 </apiDesc><example conref="examples\StyleSheet_transformExample.as"> В данном примере метод <codeph>transform()</codeph> используется для применения стиля из CSS-файла к объекту TextFormat для текстового поля.
 
 <p>Стили CSS обычно используются для форматирования HTML-содержимого. Однако с помощью метода <codeph>transform()</codeph> объекта StyleSheet конкретные стили CSS можно назначить объекту TextFormat, а затем применить к любому текстовому полю.</p> 
 
 <p>Для загрузки CSS-файла используются объекты <codeph>URLRequest</codeph> и <codeph>URLLoader</codeph>. Добавляется прослушиватель для события <codeph>Event.COMPLETE</codeph>, которое происходит после получения всех данных и их помещения в свойство data объекта URLLoader с именем <codeph>loader</codeph>. После этого метод <codeph>loaderCompleteHandler()</codeph> выполняет разбор данных, загруженных из CSS- файла и заполняет стилями объект StyleSheet с именем <codeph>sheet</codeph>. Метод <codeph>getStyle()</codeph> таблицы стилей получает стили абзацев HTML, которые назначаются объекту TextFormat с именем <codeph>cssFormat</codeph> с помощью метода <codeph>transform()</codeph> таблицы стилей. В завершение, для текстового поля <codeph>inputField</codeph> назначается новый формат текста по умолчанию – <codeph>cssFormat</codeph>.</p> 
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.text.StyleSheet;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.text.TextFieldType;
    import flash.events.IOErrorEvent;
    import flash.events.Event;

    public class StyleSheet_transformExample extends Sprite {
        private var loader:URLLoader = new URLLoader();
        private var inputField:TextField = new TextField();
        private var sheet:StyleSheet = new StyleSheet();

        public function StyleSheet_transformExample() {
            inputField.x = 10;
            inputField.y = 10;
            inputField.background = true;
            inputField.width = 300;
            inputField.height = 200;
            inputField.wordWrap = true;
            inputField.multiline = true;    
            inputField.type = TextFieldType.INPUT;

            addChild(inputField);
            
            var req:URLRequest = new URLRequest("test.css");
            loader.load(req);

            loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
            loader.addEventListener(Event.COMPLETE, loaderCompleteHandler);
        }

        public function errorHandler(e:IOErrorEvent):void {
            inputField.htmlText = "Couldn't load the style sheet file.";
        }

        public function loaderCompleteHandler(event:Event):void {
            var cssFormat:TextFormat = new TextFormat();
            sheet.parseCSS(loader.data);
            var style:Object = sheet.getStyle("p");
            cssFormat = sheet.transform(style);
            inputField.defaultTextFormat = cssFormat;
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.text.xml#TextFormat"><linktext>flash.text.TextFormat</linktext></link></related-links></apiOperation><apiValue id="flash.text:StyleSheet:styleNames:get"><apiName>styleNames</apiName><shortdesc>
	 Массив, содержащий имена (в виде строк) всех стилей, зарегистрированных в этой таблице стилей.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>StyleSheet.getStyleNames, getStyleNames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier><apiTipTexts><apiTipText>Возвращает имена всех стилей, зарегистрированных в этом объекте StyleSheet.
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 Массив, содержащий имена (в виде строк) всех стилей, зарегистрированных в этой таблице стилей.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:TextSnapshot"><apiName>TextSnapshot</apiName><shortdesc> 
 Объекты TextSnapshot позволяют работать со статическим текстом во фрагменте ролика.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc> 
 Объекты TextSnapshot позволяют работать со статическим текстом во фрагменте ролика. Их можно использовать, например, для более точной раскладки текста, чем позволяет динамический текст, не отменяя доступа к нему «только для чтения».
 
 <p>Не создавайте объект TextSnapshot с помощью конструктора. Он возвращается свойством <codeph>flash.display.DisplayObjectContainer.textSnapshot</codeph>.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/textSnapshot"><linktext>flash.display.DisplayObjectContainer.textSnapshot</linktext></link></related-links><apiOperation id="flash.text:TextSnapshot:findText"><apiName>findText</apiName><shortdesc>
	 Выполняет поиск по объекту TextSnapshot и возвращает положение первого вхождения textToFind, обнаруженного в положении beginIndex или после него.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.findText, findText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Отсчитываемая от нуля позиция индекса первого вхождения заданного текста или -1.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Задает начальную точку для поиска заданного текста.	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>textToFind</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Задает искомый текст. Если вместо переменной типа String задается литерал строки, то строку необходимо заключить в кавычки.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>caseSensitive</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Указывает, должен ли при поиске учитываться регистр текста строки в <codeph>textToFind</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Выполняет поиск по объекту TextSnapshot и возвращает положение первого вхождения <codeph>textToFind</codeph>, обнаруженного в положении <codeph>beginIndex</codeph> или после него. Если значение <codeph>textToFind</codeph> не найдено, метод возвращает <codeph>-1</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelected"><apiName>getSelected</apiName><shortdesc>
	 Возвращает логическое значение, показывающее, содержит ли объект TextSnapshot выделенный текст в заданном диапазоне.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelected, getSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Логическое значение, показывающее, выделен ли хотя бы один символ в данном диапазоне соответствующим методом <codeph>setSelected()</codeph> (<codeph>true</codeph>); если нет, значение - <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Указывает позицию первого рассматриваемого символа. Допустимые значения <codeph>beginIndex</codeph> находятся в диапазоне от <codeph>0</codeph> до <codeph>TextSnapshot.charCount - 1</codeph>. Если в качестве <codeph>beginIndex</codeph> выбрано отрицательное значение, используется <codeph>0 </codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение, которое на одну единицу больше индекса последнего рассматриваемого символа. Действительные значения параметра <codeph>endIndex</codeph> лежат в диапазоне от <codeph>0</codeph> до <codeph>charCount</codeph>. Символ, индексированный параметром <codeph>endIndex</codeph>, не включен в извлеченную строку. Если этот параметр пропустить, используется параметр <codeph>charCount</codeph>. Если это значение меньше или равно значению <codeph>beginIndex</codeph>, используется <codeph>beginIndex + 1</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает логическое значение, показывающее, содержит ли объект TextSnapshot выделенный текст в заданном диапазоне. 
	 
	 <p>Чтобы выполнить поиск по всем символам, передайте значение <codeph>0</codeph> для <codeph>start</codeph> и <codeph>charCount</codeph> (или любое очень большое число) для <codeph>end</codeph>. Чтобы выполнить поиск по одному символу, передайте параметру <codeph>end</codeph> значение, которое на одну единицу больше параметра <codeph>start</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getSelectedText"><apiName>getSelectedText</apiName><shortdesc>
	 Возвращает строку, содержащую все символы, заданные соответствующим методом setSelected().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getSelectedText, getSelectedText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, содержащая все символы, заданные соответствующим методом <codeph>setSelected()</codeph>.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Необязательное логическое значение, указывающее, вставляются ли символы новой строки в возвращенную строку, где это уместно. Значение по умолчанию <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строку, содержащую все символы, заданные соответствующим методом <codeph>setSelected()</codeph>. Если символы не заданы (методом <codeph>setSelected()</codeph>), возвращается пустая строка.
	 
	 <p>Если параметр <codeph>includeLineEndings</codeph> имеет значение <codeph>true</codeph>, символы новой строки вставляются в возвращаемую строку, которая может оказаться длиннее, чем введенный диапазон. Если параметр <codeph>includeLineEndings</codeph> имеет значение <codeph>false</codeph> или опущен, метод возвращает выделенный текст, не добавляя никаких символов.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/getSelected()"><linktext>flash.text.TextSnapshot.getSelected()</linktext></link><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getText"><apiName>getText</apiName><shortdesc>
	 Возвращает строку, содержащую все символы, заданные параметрами beginIndex и endIndex.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.getText, getText
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, содержащая символы заданного диапазона, или пустая строка, если в этом диапазоне нет символов.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Указывает позицию первого символа, который должен быть включен в возвращаемую строку. Действительные значения параметра <codeph>beginIndex</codeph> лежат в диапазоне от <codeph>0</codeph> до <codeph>charCount - 1</codeph>. Если в качестве <codeph>beginIndex</codeph> выбрано отрицательное значение, используется <codeph>0 </codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение, которое на одну единицу больше индекса последнего рассматриваемого символа. Действительные значения параметра <codeph>endIndex</codeph> лежат в диапазоне от <codeph>0</codeph> до <codeph>charCount</codeph>. Символ, индексированный параметром <codeph>endIndex</codeph>, не включен в извлеченную строку. Если этот параметр пропустить, используется параметр <codeph>charCount</codeph>. Если это значение меньше или равно значению <codeph>beginIndex</codeph>, используется <codeph>beginIndex + 1</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>includeLineEndings</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Необязательное логическое значение, которое указывает, вставляются символы новой строки (<codeph>true</codeph>) или нет (<codeph>false</codeph>) в возвращаемую строку. Значение по умолчанию <codeph>false</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает строку, содержащую все символы, заданные параметрами <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>. Если нет выделенных символов, возвращается пустая строка. 
	 
	 <p>Чтобы метод вернул все символы, передайте значение <codeph>0</codeph> для <codeph>beginIndex</codeph> и <codeph>charCount</codeph> (или любое очень большое число) для <codeph>endIndex</codeph>. Чтобы метод вернул один символ, передайте значение <codeph>beginIndex + 1</codeph> для параметра <codeph>endIndex</codeph>. </p>
	 
	 <p>Если передать значение <codeph>true</codeph> параметру <codeph>includeLineEndings</codeph>, в возвращаемую строку вставляются символы новой строки, где это требуется. В данном случае возвращенная строка может быть длиннее введенного диапазона. Если параметр <codeph>includeLineEndings</codeph> имеет значение <codeph>false</codeph> или опущен, выделенный текст возвращается без дополнительных символов.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/getSelectedText()"><linktext>flash.text.TextSnapshot.getSelectedText()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:getTextRunInfo"><apiName>getTextRunInfo</apiName><shortdesc>
	 Возвращает массив объектов, содержащий сведения о непрерывной последовательности текста.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Массив объектов, каждый из которых содержит сведения о конкретном символе в диапазоне, заданном параметрами <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>. Каждый объект содержит следующие одиннадцать свойств.
	 <ul>
	 
	  	<li>Свойство <codeph>indexInRun</codeph> – отсчитываемый от нуля индекс символа, представленный целым числом (определяется относительно всей строки, а не выделенного фрагмента текста).</li>
	 
	  	<li>Свойство <codeph>selected</codeph> – логическое значение, указывающее на то, что символ выделен <codeph>true</codeph> или не выделен <codeph>false</codeph>.</li>
	 
	  	<li>Свойство <codeph>font</codeph> – имя шрифта символа.</li>
	 
	  	<li>Свойство <codeph>color</codeph> – комбинированное значение прозрачности и цвета для символа. Первые две шестнадцатеричные цифры представляют альфа-значение, а остальные - цвет.</li>
	 
	  	<li>Свойство <codeph>height</codeph> – высота символа (в пикселях).</li>
	 
	  	<li>Свойства <codeph>matrix_a</codeph>, <codeph>matrix_b</codeph>, <codeph>matrix_c</codeph>, <codeph>matrix_d</codeph>, <codeph>matrix_tx</codeph> и <codeph>matrix_ty</codeph> – значения матрицы, определяющие геометрическое преобразование символа. Обычный вертикальный текст всегда имеет матрицу вида <codeph>[1 0 0 1 x y]</codeph>, где <codeph>x</codeph> и <codeph>y</codeph> - это позиция символа в вышестоящем фрагменте ролика независимо от высоты текста. Матрица находится в системе координат родительского фрагмента ролика и не включает преобразований, которые может иметь сам фрагмент ролика (или его вышестоящий элемент). </li>
	 
	 	<li>Свойства <codeph>corner0x</codeph>, <codeph>corner0y</codeph>, <codeph>corner1x</codeph>, <codeph>corner1y</codeph>, <codeph>corner2x</codeph>, <codeph>corner2y</codeph>, <codeph>corner3x</codeph> и <codeph>corner3y</codeph> – углы ограничительного блока символа на основе системы координат вышестоящего фрагмента ролика. Эти значения доступны, только если используемый символом шрифт встроен в SWF-файл.</li>
	 
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение индекса первого символа в диапазоне в объекте TextSnapshot.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение индекса последнего символа в диапазоне в объекте TextSnapshot.
	 
 	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает массив объектов, содержащий сведения о непрерывной последовательности текста. Каждый объект соответствует одному символу из диапазона, заданного двумя параметрами метода. 
	 
	 <p><b>Примечание. </b> При использовании метода <codeph>getTextRunInfo()</codeph> для большого диапазона текста может быть возвращен большой объект. Adobe рекомендует ограничивать диапазон текста параметрами <codeph>beginIndex</codeph> и <codeph>endIndex</codeph>. </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>Класс Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:hitTestTextNearPos"><apiName>hitTestTextNearPos</apiName><shortdesc>
	 Позволяет определить, какой символ в пределах объекта TextSnapshot находится в точке с заданными координатами x, y или рядом с ней во фрагменте ролика, содержащем текст в объекте TextSnapshot.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.hitTestTextNearPos, hitTestTextNearPos
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Число, представляющее значение индекса символа, который находится ближе остальных к заданной точке с координатами <codeph>x</codeph>, <codeph>y</codeph>. Возвращает <codeph>-1</codeph>, если такой символ не найден, либо если шрифт не содержит информации о метриках символа.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, представляющее координату <codeph>x</codeph> фрагмента ролика, содержащего текст.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число, представляющее координату <codeph>y</codeph> фрагмента ролика, содержащего текст.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>maxDistance</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>(Необязательно) число, представляющее максимальное расстояние от точки с координатами <codeph>x</codeph>, <codeph>y</codeph>на котором может выполняться поиск текста. Расстояние отмеряется от центральной точки каждого символа. По умолчанию используется значение <codeph>0</codeph>.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Позволяет определить, какой символ в пределах объекта TextSnapshot находится в точке с заданными координатами <codeph>x</codeph>, <codeph>y</codeph> или рядом с ней во фрагменте ролика, содержащем текст в объекте TextSnapshot.
	 
	 <p>Если опустить свойство <codeph>maxDistance</codeph> или передать ему значение <codeph>0</codeph>, место, заданное координатами <codeph>x</codeph>, <codeph>y</codeph>, может находится внутри ограничительного блока объекта TextSnapshot. 
	 </p>
	 
	 <p>Этот метод работает правильно только с шрифтами, включающими информацию о метриках символа. Однако по умолчанию инструмент разработки Flash не включает эту информацию для статически текстовых полей. <ph outputclass="flashonly">По этой причине метод может вернуть <codeph>-1</codeph> вместо значения индекса. Чтобы гарантировать возврат значения индекса, можно заставить инструмент разработки Flash включать для шрифта информацию о метриках символов. Для этого нужно добавить динамическое текстовое поле, использующее данный шрифт, выбрать параметры символа для этого поля и затем указать, что контуры шрифта, должны быть встроены хотя бы для одного символа. (Не имеет значения, какие заданы символы и используются ли они в статическом текстовом поле.)</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/x"><linktext>flash.display.DisplayObject.x</linktext></link><link href="flash.display.xml#DisplayObject/y"><linktext>flash.display.DisplayObject.y</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelectColor"><apiName>setSelectColor</apiName><shortdesc>
	 Задает цвет для выделения символов, выбранных с помощью метода setSelected().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelectColor, setSelectColor
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>hexColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFF00</apiData><apiDesc>Шестнадцатеричное значение цвета, используемый для рамки вокруг символов, выбранных соответствующей командой <codeph>setSelected()</codeph> (0x<i>RRGGBB</i>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает цвет для выделения символов, выбранных с помощью метода <codeph>setSelected()</codeph>. Цвет всегда непрозрачный. Значение прозрачности задать нельзя.
	 
	 <p>Этот метод работает правильно только с шрифтами, включающими информацию о метриках символа. Однако по умолчанию инструмент разработки Flash не включает эту информацию для статически текстовых полей. По этой причине метод может вернуть <codeph>-1</codeph> вместо значения индекса. <ph outputclass="flashonly">Чтобы гарантировать возврат значения индекса, можно заставить инструмент разработки Flash включать для шрифта информацию о метриках символов. Для этого нужно добавить динамическое текстовое поле, использующее данный шрифт, выбрать параметры символа для этого поля и затем указать, что контуры шрифта, должны быть встроены хотя бы для одного символа. (Не имеет значения, какие заданы символы и используются ли они в статическом текстовом поле.)</ph></p>	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/setSelected()"><linktext>flash.text.TextSnapshot.setSelected()</linktext></link></related-links></apiOperation><apiOperation id="flash.text:TextSnapshot:setSelected"><apiName>setSelected</apiName><shortdesc>
	 Задает диапазон символов в объекте TextSnapshot для выбора или отмены выбора.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9."/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.setSelected, setSelected
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>beginIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Указывает позицию первого символа для выделения. Действительные значения параметра <codeph>beginIndex</codeph> лежат в диапазоне от <codeph>0</codeph> до <codeph>charCount - 1</codeph>. Если в качестве <codeph>beginIndex</codeph> выбрано отрицательное значение, используется <codeph>0 </codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Целое число, которое на одну единицу больше индекса последнего рассматриваемого символа. Действительные значения параметра <codeph>end</codeph> лежат в диапазоне от <codeph>0</codeph> до <codeph>charCount</codeph>. Символ, индексированный параметром <codeph>end</codeph>, не включен в извлеченную строку. Если этот параметр пропущен, используется <codeph>TextSnapshot.charCount</codeph>. Если значение <codeph>endIndex</codeph> меньше или равно значению <codeph>beginIndex</codeph>, используется <codeph>beginIndex + 1</codeph>.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>select</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение, указывающее, должен текст выделяться (<codeph>true</codeph>) или нет (<codeph>false</codeph>).
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Задает диапазон символов в объекте TextSnapshot для выбора или отмены выбора. Выделенные символы помечаются цветным фоном по размеру их ограничительного блока. Цвет ограничительного блока определяется методом <codeph>setSelectColor()</codeph>.
	 
	 <p>Чтобы метод выделил все символы или отменил выделение всех символом, передайте значение <codeph>0</codeph> для <codeph>beginIndex</codeph> и <codeph>charCount</codeph> (или любое очень большое число) для <codeph>endIndex</codeph>. Чтобы задать один символ, передайте значение <codeph>beginIndex + 1</codeph> для параметра <codeph>endIndex</codeph>. </p>
	 
	 <p>Так как символы помечаются или выделяются по отдельности, этот метод можно вызывать несколько раз для выделения нескольких символов. Другими словами, этот метод не отменяет выделение с других, уже обработанных им символов.</p>
	 
	 <p>Цветной прямоугольник, обозначающий выделение, отображается только для шрифтов, содержащих информацию о метриках символов. По умолчанию Flash не включает эту информацию для статических текстовых полей. В некоторых случаях такое поведение приводит к тому, что выбранный текст не имеет признаков выделения на экране. <ph outputclass="flashonly">Чтобы весь выбранный текст был соответствующим образом выделен, необходимо заставить инструмент разработки Flash включать для шрифта информацию о метриках символов. Для этого нужно добавить динамическое текстовое поле, использующее данный шрифт, выбрать параметры символа для этого поля и затем указать, что контуры шрифта, должны быть встроены хотя бы для одного символа. Не имеет значения, какие заданы символы и используются ли они в статическом текстовом поле.</ph></p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.text.xml#TextSnapshot/charCount"><linktext>flash.text.TextSnapshot.charCount</linktext></link><link href="flash.text.xml#TextSnapshot/setSelectColor()"><linktext>flash.text.TextSnapshot.setSelectColor()</linktext></link></related-links></apiOperation><apiValue id="flash.text:TextSnapshot:charCount:get"><apiName>charCount</apiName><shortdesc>
	 Число знаков в объекте TextSnapshot.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>TextSnapshot.charCount, charCount, count
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Число знаков в объекте TextSnapshot.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot/getText()"><linktext>flash.text.TextSnapshot.getText()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldAutoSize"><apiName>TextFieldAutoSize</apiName><shortdesc>
Класс TextFieldAutoSize является перечислением значений констант, с помощью которых задается свойство autoSize класса TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс TextFieldAutoSize является перечислением значений констант, с помощью которых задается свойство <codeph>autoSize</codeph> класса TextField. 

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/autoSize"><linktext>flash.text.TextField.autoSize</linktext></link></related-links><apiValue id="flash.text:TextFieldAutoSize:CENTER"><apiName>CENTER</apiName><shortdesc> 
	Показывает, что текст должен обрабатываться как текст с выравниванием по центру.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>center</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Показывает, что текст должен обрабатываться как текст с выравниванием по центру. Изменение размера единственной строки в текстовом поле равномерно распределяется влево и вправо. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:LEFT"><apiName>LEFT</apiName><shortdesc> 
	Показывает, что текст должен обрабатываться как текст с выравниванием по левому краю, т.е. с фиксацией левой стороны текстового поля и изменением размеров одинарной строки только по правой стороне.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>left</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Показывает, что текст должен обрабатываться как текст с выравниванием по левому краю, т.е. с фиксацией левой стороны текстового поля и изменением размеров одинарной строки только по правой стороне. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:NONE"><apiName>NONE</apiName><shortdesc> 
	
	Показывает, что размеры не изменяются.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	
	Показывает, что размеры не изменяются.
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldAutoSize:RIGHT"><apiName>RIGHT</apiName><shortdesc> 
	Показывает, что текст должен обрабатываться как текст с выравниванием по правому краю, т.е. с фиксацией правой стороны текстового поля и изменением размеров одинарной строки только по правой стороне.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>right</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Показывает, что текст должен обрабатываться как текст с выравниванием по правому краю, т.е. с фиксацией правой стороны текстового поля и изменением размеров одинарной строки только по правой стороне. 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.text:FontStyle"><apiName>FontStyle</apiName><shortdesc>
Класс FontStyle передает значения для класса TextRenderer.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс FontStyle передает значения для класса TextRenderer.

</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextRenderer"><linktext>flash.text.TextRenderer</linktext></link></related-links><apiValue id="flash.text:FontStyle:BOLD"><apiName>BOLD</apiName><shortdesc>
    Задает полужирный стиль шрифта для параметра fontStyle метода setAdvancedAntiAliasingTable().</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bold</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Задает полужирный стиль шрифта для параметра <codeph>fontStyle</codeph> метода <codeph>setAdvancedAntiAliasingTable()</codeph>. Используйте синтаксис <codeph>FontStyle.BOLD</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:BOLD_ITALIC"><apiName>BOLD_ITALIC</apiName><shortdesc>
    Задает комбинированный (полужирный и курсивный) стиль шрифта для параметра fontStyle метода setAdvancedAntiAliasingTable().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>boldItalic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Задает комбинированный (полужирный и курсивный) стиль шрифта для параметра <codeph>fontStyle</codeph> метода <codeph>setAdvancedAntiAliasingTable()</codeph>. Используйте синтаксис <codeph>FontStyle.BOLD_ITALIC</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:ITALIC"><apiName>ITALIC</apiName><shortdesc>
    Задает курсив для значения параметра fontStyle метода setAdvancedAntiAliasingTable().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>italic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Задает курсив для значения параметра <codeph>fontStyle</codeph> метода <codeph>setAdvancedAntiAliasingTable()</codeph>. Используйте синтаксис <codeph>FontStyle.ITALIC</codeph>.
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue><apiValue id="flash.text:FontStyle:REGULAR"><apiName>REGULAR</apiName><shortdesc>
    Задает простой стиль шрифта для параметра fontStyle метода setAdvancedAntiAliasingTable().</shortdesc><prolog><author>Bob Pappas
	</author><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>regular</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    Задает простой стиль шрифта для параметра <codeph>fontStyle</codeph> метода <codeph>setAdvancedAntiAliasingTable()</codeph>. Используйте синтаксис <codeph>FontStyle.REGULAR</codeph>. 
	</apiDesc></apiValueDetail><related-links><link href="flash.text.xml#TextRenderer/setAdvancedAntiAliasingTable()"><linktext>flash.text.TextRenderer.setAdvancedAntiAliasingTable()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.text:TextFieldType"><apiName>TextFieldType</apiName><shortdesc>
Класс TextFieldType является перечислением значений констант, с помощью которых задается свойство type класса TextField.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Класс TextFieldType является перечислением значений констант, с помощью которых задается свойство <codeph>type</codeph> класса TextField. 


</apiDesc></apiClassifierDetail><related-links><link href="flash.text.xml#TextField/type"><linktext>flash.text.TextField.type</linktext></link></related-links><apiValue id="flash.text:TextFieldType:DYNAMIC"><apiName>DYNAMIC</apiName><shortdesc> 
	Используется для задания объекта TextField dynamic.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>dynamic</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для задания объекта TextField <codeph>dynamic</codeph>. 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.text:TextFieldType:INPUT"><apiName>INPUT</apiName><shortdesc> 
	Используется для задания TextField input.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>input</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	Используется для задания TextField <codeph>input</codeph>. 
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>