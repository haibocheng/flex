<?xml version="1.0"?>
<apiPackage id="flash.utils"><apiName>flash.utils</apiName><apiDetail/><apiClassifier id="flash.utils:Proxy"><apiName>Proxy</apiName><shortdesc>
 Класс Proxy позволяет переопределять поведение по умолчанию для операций ActionScript (например, для получения и модификации свойств) над объектом.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Proxy позволяет переопределять поведение по умолчанию для операций ActionScript (например, для получения и модификации свойств) над объектом.
 
 <p>Класс Proxy не имеет конструктора, поэтому не следует пытаться создать экземпляр этого класса. Вместо этого сделайте класс Proxy подклассом для переопределения методов (например, <codeph>getProperty</codeph>) и обеспечения необходимого поведения. При попытке использовать метод класса Proxy без переопределения метода возникает исключение.</p>
 <p>Следует помнить о том, что код, переопределяющий методы класса Proxy, может непреднамеренно вызывать исключения. Возникновение исключений при использовании этих методов приводит к проблемам, поскольку вызывающий код (в котором используются такие операторы, как <codeph>in</codeph>, <codeph>is</codeph>, <codeph>delete</codeph> и другие) не предполагает исключений. В том случае, если переопределяющий метод может вызывать исключения, Adobe рекомендует помещать реализацию класса Proxy между операторами <codeph>try.. catch</codeph>, которые помогут избежать критических ошибок в случае вызова методов инструкциями. Например: </p> 
 <codeblock>
 dynamic class MyProxy extends Proxy {
     flash_proxy override function callProperty(name:~~, ...rest):~~ {
       try {
         // custom code here
       }
       catch (e:Error) {
         // respond to error here
       }
 }   
 </codeblock>
 
 <p>Класс Proxy заменяет функции ActionScript 2.0 <codeph>Object__resolve</codeph> и <codeph>Object.addProperty</codeph>, уже недоступные в ActionScript 3.0. Функция <codeph>Object.addProperty()</codeph> позволяла динамически создавать методы получения и установки в ActionScript 2.0. Несмотря на то, что ActionScript 3.0 предоставляет методы получения и установки в процессе компиляции, у них отсутствует возможность динамического присвоения объекту без использования класса Proxy.</p>
 
 <p>Во избежание конфликтов с пространством имен <codeph>public</codeph> методы класса Proxy находятся в пространстве имен <codeph>flash_proxy</codeph>.</p>
 
 <p>Когда методам класса Proxy передается аргумент <codeph>name</codeph>, <codeph>name</codeph> может быть объектом String или QName (если используются пространства имен).</p>
 
 </apiDesc><example conref="examples\ProxyExample.as"><codeblock>
package {
    import flash.display.Sprite;

    public class ProxyExample extends Sprite {
        public function ProxyExample() {
            var arr:ProxyArray = new ProxyArray();
            arr.push(1);
            arr.push(-2);
            arr.push(3);
            arr.push(4);
            arr.push("five");
            
            trace(arr.length); // 5
            trace(arr[0]);     // 1
            trace(arr[1]);     // -2
            trace(arr[2]);     // 3
            trace(arr[3]);     // 4

            trace(arr.sum());  // 6

            arr.clear();
            trace(arr); // (empty string)
            
            arr[0] = "zero";
            trace(arr); // zero
        }
    }
}

import flash.utils.Proxy;
import flash.utils.flash_proxy;

dynamic class ProxyArray extends Proxy {
    private var _item:Array;

    public function ProxyArray() {
        _item = new Array();
    }

    override flash_proxy function callProperty(methodName:*, ... args):* {
        var res:*;
        switch (methodName.toString()) {
            case 'clear':
                _item = new Array();
                break;
            case 'sum':
                var sum:Number = 0;
                for each (var i:* in _item) {
                    // ignore non-numeric values
                    if (!isNaN(i)) {
                        sum += i;
                    }
                }
                res = sum;
                break;
            default:
                res = _item[methodName].apply(_item, args);
                break;
        }
        return res;
    }

    override flash_proxy function getProperty(name:*):* {
        return _item[name];
    }

    override flash_proxy function setProperty(name:*, value:*):void {
        _item[name] = value;
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.utils:Proxy:flash_proxy:callProperty"><apiName>callProperty</apiName><shortdesc>
	 Переопределяет поведение свойства объекта, которое может быть вызвано как функция.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Значение, которое возвращает вызываемый метод.
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя вызываемого метода.
	 </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>Массив аргументов вызываемого метода.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переопределяет поведение свойства объекта, которое может быть вызвано как функция. Этот метод вызывается при вызове методов объектов. Некоторые объекты можно вызывать как функции. Некоторые свойства объекта также можно вызывать как функции. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Спецификация языка ECMA-262, 3-е издание, раздел 15</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:deleteProperty"><apiName>deleteProperty</apiName><shortdesc>
	 Переопределяет запрос на удаление свойства.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Если свойство удалено, указывается значение <codeph>true</codeph>; в противном случае выбирается значение <codeph>false</codeph>.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя удаляемого свойства
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переопределяет запрос на удаление свойства. Когда свойство удаляется с помощью оператора <codeph>delete</codeph>, для удаления вызывается этот метод. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../operators.html#delete"><linktext>оператор delete</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Спецификация языка ECMA-262, 3-е издание, раздел 8.6.2.5</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:getDescendants"><apiName>getDescendants</apiName><shortdesc>
	 Переопределяет использование оператора descendant.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Результаты оператора <codeph>descendant</codeph>.
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя искомого свойства в объекте.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переопределяет использование оператора <codeph>descendant</codeph>. Этот метод вызывается при использовании оператора <codeph>descendant</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../operators.html#descendant_accessor"><linktext>оператор descendant</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>Спецификация E4X</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:getProperty"><apiName>getProperty</apiName><shortdesc>
     Переопределяет любой запрос значения свойства.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Указанное свойство или <codeph>undefined</codeph>, если свойство не найдено.
     </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя получаемого свойства
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     Переопределяет любой запрос значения свойства. Если свойство не удается найти, метод возвращает значение <codeph>undefined</codeph>. Дополнительные сведения об этом поведении см. в спецификации языка ECMA-262, 3-е издание, раздел 8.6.2.1.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../statements.html#get"><linktext>инструкция get</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Спецификация языка ECMA-262, 3-е издание, раздел 8.6.2.1</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:hasProperty"><apiName>hasProperty</apiName><shortdesc>
	 Переопределяет запрос на проверку наличия у объекта конкретного свойства по имени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Если свойство существует, указывается значение <codeph>true</codeph>; в противном случае выбирается значение <codeph>false</codeph>.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя проверяемого свойства.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переопределяет запрос на проверку наличия у объекта конкретного свойства по имени. 
     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/hasOwnProperty()"><linktext>Object.hasOwnProperty()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Спецификация языка ECMA-262, 3-е издание, раздел 8.6.2.4</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:isAttribute"><apiName>isAttribute</apiName><shortdesc>
	 Проверяет, помечен ли предоставленный QName также как атрибут.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Возвращает <codeph>true</codeph>, если аргумент для <codeph>name</codeph> имеет тип QName, который также помечен, как атрибут.
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя проверяемого свойства.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Проверяет, помечен ли предоставленный QName также как атрибут. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#QName"><linktext>Класс QName</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextName"><apiName>nextName</apiName><shortdesc>
	 Разрешает перечисление свойств объекта с прокси по номеру позиции индекса для получения имен свойств.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Имя свойства.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для свойства объекта.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Разрешает перечисление свойств объекта с прокси по номеру позиции индекса для получения имен свойств. При этом свойства самого класса Proxy перечислять не следует. Эта функция поддерживает реализацию циклов <codeph>for...in</codeph> и <codeph>for each.. in</codeph> в объекте для получения нужных имен.
	 <p>Например, (с кодом из <codeph>Proxy.nextNameIndex()</codeph>):</p>
     <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
     </codeblock>
 	 
 	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextNameIndex()"><linktext>Proxy.nextNameIndex()</linktext></link><link href="flash.utils.xml#Proxy/nextValue()"><linktext>Proxy.nextValue()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextNameIndex"><apiName>nextNameIndex</apiName><shortdesc>
	 Разрешает перечисление свойств объекта с прокси по номеру позиции индекса.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Значение индекса свойства.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса, с которого начинается перечисление.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Разрешает перечисление свойств объекта с прокси по номеру позиции индекса. При этом свойства самого класса Proxy перечислять нельзя. Эта функция поддерживает реализацию циклов <codeph>for...in</codeph> и <codeph>for each.. in</codeph> в объекте для получения значений индекса свойства.
	 <p>Например:</p>
	 <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
	 </codeblock>
     
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextName()"><linktext>Proxy.nextName()</linktext></link><link href="flash.utils.xml#Proxy/nextValue()"><linktext>Proxy.nextValue()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:nextValue"><apiName>nextValue</apiName><shortdesc>
 	 Разрешает перечисление свойств объекта с прокси по номеру позиции индекса для получения значений свойств.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiDesc>Значение свойства.
	 </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Отсчитываемое от нуля значение индекса для свойства объекта.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
 	 Разрешает перечисление свойств объекта с прокси по номеру позиции индекса для получения значений свойств. При этом свойства самого класса Proxy перечислять нельзя. Эта функция поддерживает реализацию циклов <codeph>for...in</codeph> и <codeph>for each.. in</codeph> в объекте для получения нужных значений.
	 
	 <p>Например, (с кодом из <codeph>Proxy.nextNameIndex()</codeph>):</p>
     <codeblock>
     protected var _item:Array; // array of object's properties
     override flash_proxy function nextNameIndex (index:int):int {
         // initial call
         if (index == 0) {
             _item = new Array();
             for (var x:~~ in _target) {
                _item.push(x);
             }
         }
     
         if (index &lt; _item.length) {
             return index + 1;
         } else {
             return 0;
         }
     }
     override flash_proxy function nextName(index:int):String {
         return _item[index - 1];
     }
     </codeblock>   
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Proxy/nextNameIndex()"><linktext>Proxy.nextNameIndex()</linktext></link><link href="flash.utils.xml#Proxy/nextName()"><linktext>Proxy.nextName()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Proxy:flash_proxy:setProperty"><apiName>setProperty</apiName><shortdesc>
	 Переопределяет вызов для изменения значения свойства.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value=""/><apiDesc>Имя модифицируемого свойства
	 </apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Значение, которое присваивается свойству.
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Переопределяет вызов для изменения значения свойства. Если свойство не удается найти, этот метод создает свойство с указанным именем и значением. 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../statements.html#set"><linktext>инструкция set</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"><linktext>Спецификация языка ECMA-262, 3-е издание, раздел 8.6.2.2</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="flash.utils:ByteArray"><apiName>ByteArray</apiName><shortdesc>
 В классе ByteArray предусмотрены методы и свойства для оптимизации чтения и записи двоичных данных, а также работы с ними.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 В классе ByteArray предусмотрены методы и свойства для оптимизации чтения и записи двоичных данных, а также работы с ними.
 
 <p><i>Примечание.</i> Класс ByteArray предназначен для опытных разработчиков, которым требуется доступ к данным на уровне байтов.</p>
 
 <p>Данные в памяти представляют собой упакованный массив байтов (наиболее компактное представление типа данных), но с экземпляром класса ByteArray можно работать с использованием стандартных операторов <codeph>[]</codeph> (доступа к массивам). Чтение из него и запись в него можно осуществлять как в файл в памяти, с использованием методов, похожих на методы классов URLStream и Socket.</p>
 
 <p>Кроме того, поддерживается сжатие и распаковка zlib, а также сериализация объекта Action Message Format (AMF).</p>
 
 <p>Среди возможных вариантов использования класса ByteArray следующие:
 
 <ul>
 
  <li>создание собственного протокола для подключения к серверу;</li>
 
  <li>написание собственных средств кодирования и раскодирования URL-адресов;</li>
 
  <li platform="actionscript">написание собственного пакета AMF/Remoting;</li>
 
  <li>оптимизация размера данных с использованием типов данных;</li>
 
 	 <li>работа с двоичными данными, загруженными из файла в Adobe<sup>®</sup> AIR<sup>®</sup>.</li>
 
 </ul>
 </p>
 
 </apiDesc><example conref="examples\ByteArrayExample.as"> В следующем примере класс <codeph>ByteArrayExample</codeph> используется для записи в массив байтов логического значения и представления числа «пи» с двойной точностью и плавающей запятой. Это можно сделать, выполнив следующие действия:
 <ol>
     <li>Объявляется новый экземпляр объекта ByteArray <codeph>byteArr</codeph>.</li>
     <li>Записывается эквивалент байтового логического значения <codeph>false</codeph>, затем проверяется его длина, и оно считывается.</li>
     <li>Записывается эквивалент числа «пи» с двойной точностью и плавающей запятой.</li>
     <li>Все эти девять байтов, записанных в массив байтов, считываются.</li>
 </ol>
 
 <p><b>Примечание.</b> Когда <codeph>trace()</codeph> вызывается для байта, то выводится десятичный эквивалент байтов, хранящихся в байтовом массиве.</p>
 
 <p>Обратите внимание на то, что в конце добавляется сегмент кода для проверки ошибок конца файла. Это позволяет прекратить считывание потока байтов по достижении его окончания.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class ByteArrayExample extends Sprite {        
        public function ByteArrayExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            trace(byteArr.length);            // 1
            trace(byteArr[0]);            // 0

            byteArr.writeDouble(Math.PI);
            trace(byteArr.length);            // 9
            trace(byteArr[0]);            // 0
            trace(byteArr[1]);            // 64
            trace(byteArr[2]);            // 9
            trace(byteArr[3]);            // 33
            trace(byteArr[4]);            // 251
            trace(byteArr[5]);            // 84
            trace(byteArr[6]);            // 68
            trace(byteArr[7]);            // 45
            trace(byteArr[8]);            // 24
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean() == false); // true
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());        // 3.141592653589793
            }
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);            // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="../../operators.html#array_access"><linktext>[] (array access)</linktext></link><link href="flash.net.xml#Socket"><linktext>Класс Socket</linktext></link><link href="flash.net.xml#URLStream"><linktext>Класс URLStream</linktext></link></related-links><apiConstructor id="flash.utils:ByteArray:ByteArray"><apiName>ByteArray</apiName><shortdesc>
 Создает экземпляр ByteArray, представляющий упакованный массив байтов. С помощью методов и свойств данного класса можно оптимизировать хранилище и поток данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 Создает экземпляр ByteArray, представляющий упакованный массив байтов. С помощью методов и свойств данного класса можно оптимизировать хранилище и поток данных.
 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.utils:ByteArray:clear"><apiName>clear</apiName><shortdesc> 
	 Удаляет содержимое массива байтов и сбрасывает значения length и position в значение 0.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
	 Удаляет содержимое массива байтов и сбрасывает значения <codeph>length</codeph> и <codeph>position</codeph> в значение 0. При явном вызове этого метода высвобождается память, используемая экземпляром ByteArray.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:compress"><apiName>compress</apiName><shortdesc>
	 Упаковывает массив байтов.</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.compress, compress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>algorithm</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Алгоритм сжатия, используемый при упаковке. Доступные значения определены в виде констант в классе CompressionAlgorithm. Формат по умолчанию – zlib. <ph platform="actionscript">Этот параметр распознается только для содержимого, выполняемого в Adobe AIR. Flash Player поддерживает только алгоритм по умолчанию zlib, и при попытке передать значение для этого параметра выдает исключение. </ph> Вызов <codeph>compress(<ph platform="javascript">air. </ph>CompressionAlgorithm.DEFLATE)</codeph> имеет тот же результат, что и вызов метода <codeph>deflate()</codeph>. 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Упаковывает массив байтов. Упаковывается весь массив байтов. Для содержимого, выполняемого в Adobe AIR, в качестве параметра <codeph>algorithm</codeph>можно указать алгоритм упаковки посредством передачи значения (определенного в классе CompressionAlgorithm). <ph platform="actionscript">Flash Player поддерживает только алгоритм по умолчанию, zlib.</ph>
	 
	 <p>После вызова свойству <codeph>length</codeph> объекта ByteArray присваивается новая длина. Свойство <codeph>position</codeph> устанавливается на конец байтового массива.</p>
	 
	 <p>Формат упакованных данных zlib описан в документе <xref href="http://www.ietf.org/rfc/rfc1950.txt" scope="external">http://www.ietf.org/rfc/rfc1950.txt</xref>.</p>
	 
	 <p>Алгоритм упаковки данных deflate описан в документе <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>Алгоритм упаковки deflate используется в различных форматах упаковки (например, zlib, gzip, некоторых реализациях zip и в других). Когда данные упаковываются с использованием одного из этих форматов упаковки, помимо хранения упакованной версии исходных данных данные формата упаковки (например, ZIP-файл) также содержат метаданные. Далее приводится несколько примеров типов метаданных, включаемых в различные форматы файлов: имя файла, дата и время изменения файла, исходный размер файла, необязательные комментарии, контрольная сумма и другие данные.</p>
	 
	 <p>Например, когда объект ByteArray сжимается с помощью алгоритма zlib, результирующий объект ByteArray получает структуру определенного формата. Определенные байты содержат метаданные об упакованных данных, а другие байты содержат сжатую версию исходных данных объекта ByteArray. Как определено спецификацией формата упакованных данных zlib, эти байты (то есть та часть, которая содержит упакованную версию исходных данных) сжимаются с использованием алгоритма deflate. Следовательно, в результате получаются байты, идентичные результату вызова <codeph> compress( <ph outputclass="javascript">air. </ph> CompressionAlgorithm.DEFLATE) </codeph> в отношении исходного ByteArray. Однако результат вызова <codeph>compress(<ph outputclass="javascript">air</ph>CompressionAlgorithm.ZLIB)</codeph> включает дополнительные метаданные, в то время как результат <codeph>compress(<ph platform="javascript">air</ph>CompressionAlgorithm.DEFLATE)</codeph> включает лишь сжатую версию первоначальных данных ByteArray.</p>
	 
	 <p>Недостаточно просто вызвать <codeph>compress(<ph platform="javascript">air с целью использования формата deflate для сжатия данных экземпляра ByteArray в определенный формат (например, gzip или zip). </ph>CompressionAlgorithm.DEFLATE)</codeph>. Необходимо создать объект ByteArray со структурой, соответствующей спецификации формата упаковки, включающий соответствующие метаданные, а также упакованные данные, полученные с использованием формата deflate. Для раскодирования данных, сжатых в такой формат, как gzip или zip, также недостаточно просто вызвать метод <codeph>uncompress(<ph platform="javascript">air</ph>CompressionAlgorithm.DEFLATE)</codeph> для этих данных. Сначала необходимо отделить метаданные от упакованных данных, а затем использовать формат deflate для распаковки упакованных данных.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/uncompress()"><linktext>uncompress()</linktext></link><link href="flash.utils.xml#CompressionAlgorithm"><linktext>flash.utils.CompressionAlgorithm</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:deflate"><apiName>deflate</apiName><shortdesc>
	 Сжимает массив байтов с использованием алгоритма сжатия DEFLATE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Сжимает массив байтов с использованием алгоритма сжатия DEFLATE. Сжимается весь массив байтов.
	 
	 <p>После вызова свойству <codeph>length</codeph> объекта ByteArray присваивается новая длина. Свойство <codeph>position</codeph> устанавливается в конец массива байтов.</p>
	 
	 <p>Алгоритм упаковки данных deflate описан в документе <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>Чтобы формат deflate можно было использовать для сжатия данных экземпляра ByteArray в определенный формат (например, gzip или zip), недостаточно просто вызвать <codeph>deflate()</codeph>. Необходимо создать объект ByteArray со структурой, соответствующей спецификации формата упаковки, включающий соответствующие метаданные, а также упакованные данные, полученные с использованием формата deflate. Чтобы раскодировать данные, сжатые в такой формат, как gzip или zip, также нельзя просто вызвать метод <codeph>inflate()</codeph> по отношению к этим данным. Сначала необходимо отделить метаданные от упакованных данных, а затем использовать формат deflate для распаковки упакованных данных.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/inflate()"><linktext>inflate()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:inflate"><apiName>inflate</apiName><shortdesc>
	 Распаковывает массив байтов с использованием алгоритма сжатия DEFLATE.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.uncompress, uncompress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Данные не являются допустимыми упакованными данными, они не были сжаты с использованием указанного алгоритма упаковки.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Распаковывает массив байтов с использованием алгоритма сжатия DEFLATE. Массив байтов должен быть сжат с использованием этого же алгоритма. 
	 
	 <p>После вызова свойству <codeph>length</codeph> объекта ByteArray присваивается новая длина. Свойству <codeph>position</codeph> присваивается значение 0.</p>
	 
	 <p>Алгоритм упаковки данных deflate описан в документе <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>При раскодировании данных, сжатых в формат, использующий алгоритм сжатия DEFLATE (например, формат gzip или zip), вызов метода <codeph>inflate()</codeph> не сработает для объекта ByteArray, содержащего данные о сжатии. Сначала необходимо отделить метаданные, которые входят в состав упакованного формата данных, от самих сжатых данных. Дополнительную информацию см. в описании метода <codeph>compress()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/deflate()"><linktext>deflate()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	 Считывает из потока байтов логическое значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readBoolean, readBoolean
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращает значение <codeph>true</codeph>, если считывается ненулевой байт, в противном случае используется значение <codeph>false</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов логическое значение. Считывается один байт. Если этот байт ненулевой, то возвращается значение <codeph>true</codeph>. В противном случае возвращается значение <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readByte"><apiName>readByte</apiName><shortdesc>
	 Считывает из потока байтов байт со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readByte, readByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Целое число между -128 и 127.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов байт со знаком.
	 <p>Возвращенное значение находится в диапазоне от -128 до 127.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readBytes"><apiName>readBytes</apiName><shortdesc>
	 Считывает из потока байтов число байтов данных, заданное параметром length.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readBytes, readBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
     </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray, в который считываются данные.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Смещение (положение) в массиве <codeph>bytes</codeph>, начиная с которого должны быть прочитаны данные.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Число байтов для считывания. Если значение по умолчанию равно 0, считываются все доступные данные.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Считывает из потока байтов число байтов данных, заданное параметром <codeph>length</codeph>. Байты считываются в объект ByteArray, определяемый параметром <codeph>bytes</codeph>, при этом байты записываются в целевой массив ByteArray, начиная с позиции, определяемой параметром <codeph>offset</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readDouble"><apiName>readDouble</apiName><shortdesc>
	 Считывает из потока байтов число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readDouble, readDouble
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число с двойной точностью (64-разрядное) и плавающей запятой.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readFloat"><apiName>readFloat</apiName><shortdesc>
	 Считывает из потока байтов число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readFloat, readFloat
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число с одинарной точностью (32-разрядное) и плавающей запятой.
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readInt"><apiName>readInt</apiName><shortdesc>
	 Считывает из потока байтов 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readInt, readInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>32-разрядное целое число со знаком между -2147483648 и 2147483647.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов 32-разрядное целое число со знаком.
	 
         <p>Возвращенное значение находится в диапазоне от -2147483648 до 2147483647.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	 Считывает из потока байтов многобайтовую строку заданной длины с использованием заданного набора знаков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readMultiByte, readMultiByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число считываемых из потока байтов.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, обозначающая набор символов, которые используются для интерпретации байтов. Возможные строки наборов символов: <codeph>"shift_jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
     <p><b>Примечание.</b> Если текущая система не распознает значение параметра <codeph>charSet</codeph>, то в качестве набора символов приложение будет использовать кодовую страницу по умолчанию. Например, значение параметра <codeph>charSet</codeph>, например в <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph>, которое использует <codeph>01</codeph> вместо <codeph>1</codeph> может работать на вашем компьютере, но привести к сбою на другой рабочей станции. На другом компьютере приложение будет использовать кодовую страницу, заданную по умолчанию в системе.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Считывает из потока байтов многобайтовую строку заданной длины с использованием заданного набора знаков.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readObject"><apiName>readObject</apiName><shortdesc>
	 Считывает объект из массива байтов, зашифрованного в сериализованный формат AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readObject, readObject
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.	 
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Десериализованный объект.
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Считывает объект из массива байтов, зашифрованного в сериализованный формат AMF.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readShort"><apiName>readShort</apiName><shortdesc>
	 Считывает из потока байтов 16-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readShort, readShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>16-разрядное целое число со знаком между -32768 и 32767.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов 16-разрядное целое число со знаком.
	 
	 <p>Возвращенное значение находится в диапазоне от -32768 до 32767.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUTF"><apiName>readUTF</apiName><shortdesc>
	 Считывает из потока байтов строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUTF, readUTF
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов строку UTF-8. Предполагается, что в строку вставляется префикс с неподписанным значением, указывающим длину в байтах.
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataInput/readUTF()"><linktext>flash.utils.IDataInput.readUTF()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	 Считывает последовательность байтов UTF-8, заданную параметром length, из потока байтов и возвращает строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUTFBytes, readUTFBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка заданной длины, состоящая из байтов UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Беззнаковое короткое целое число, указывающее длину в байтах UTF-8.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Считывает последовательность байтов UTF-8, заданную параметром <codeph>length</codeph>, из потока байтов и возвращает строку.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	 Считывает из потока байтов байт без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedByte, readUnsignedByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>32-разрядное беззнаковое целое число между 0 и 255.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов байт без знака.
	 
	 <p>Возвращенное значение находится в диапазоне от 0 до 255. </p>	
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	 Считывает из потока байтов 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedInt, readUnsignedInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>32-разрядное беззнаковое целое число между 0 и 4294967295.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байт 32-разрядное целое число без знака.
	 
	 <p>Возвращенное значение находится в диапазоне от 0 до 4294967295. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	 Считывает из потока байтов 16-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.readUnsignedShort, readUnsignedShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>16-разрядное беззнаковое целое число между 0 и 65535.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока байтов 16-разрядное целое число без знака.
	 
	 <p>Возвращенное значение находится в диапазоне от 0 до 65535. </p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:toString"><apiName>toString</apiName><shortdesc>
	 Преобразует массив байтов в строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строковое представление массива байтов.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Преобразует массив байтов в строку. Если данные массива начинаются маркером порядка байтов Unicode, во время преобразования данных в строку приложение учтет этот маркер. Если параметр <codeph>System.useCodePage</codeph> установлен в значение <codeph>true</codeph>, приложение будет обрабатывать данные массива во время преобразования как данные в текущей системной кодировке.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:uncompress"><apiName>uncompress</apiName><shortdesc>
	 Распаковывает массив байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.uncompress, uncompress
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Данные не являются допустимыми упакованными данными, они не были сжаты с использованием указанного алгоритма упаковки.
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>algorithm</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>Алгоритм сжатия, используемый при распаковке. Это должен быть тот же алгоритм сжатия, который использовался для упаковки данных. Доступные значения определены в виде констант в классе CompressionAlgorithm. Формат по умолчанию – zlib. Этот параметр распознается только для содержимого, выполняемого в Adobe AIR. <ph platform="actionscript">Flash Player поддерживает только алгоритм по умолчанию, zlib, и выдает исключение при попытке передать значение для этого параметра.</ph>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Распаковывает массив байтов. Для содержимого, которое выполняется в Adobe AIR, можно указать алгоритм упаковки посредством передачи значения (определенного в классе CompressionAlgorithm) в качестве параметра <codeph>algorithm</codeph>. Массив байтов должен быть сжат с использованием этого же алгоритма. <ph platform="actionscript">Flash Player поддерживает только алгоритм по умолчанию zlib.</ph>
	 
	 <p>После вызова свойству <codeph>length</codeph> объекта ByteArray присваивается новая длина. Свойству <codeph>position</codeph> присваивается значение 0.</p>
	 
	 <p>Формат упакованных данных zlib описан в документе <xref href="http://www.ietf.org/rfc/rfc1950.txt" scope="external">http://www.ietf.org/rfc/rfc1950.txt</xref>.</p>
	 
	 <p>Алгоритм упаковки данных deflate описан в документе <xref href="http://www.ietf.org/rfc/rfc1951.txt" scope="external">http://www.ietf.org/rfc/rfc1951.txt</xref>.</p>
	 
	 <p>При раскодировании данных, упакованных в формат, использующий алгоритм сжатия deflate (например, формат gzip или zip), вызов метода <codeph>uncompress(CompressionAlgorithm.DEFLATE)</codeph> не сработает для объекта ByteArray, содержащего метаданные. Сначала необходимо отделить метаданные, которые входят в состав упакованного формата данных, от самих сжатых данных. Дополнительную информацию см. в описании метода <codeph>compress()</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/compress()"><linktext>compress()</linktext></link><link href="flash.utils.xml#CompressionAlgorithm"><linktext>flash.utils.CompressionAlgorithm</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	 Записывает логическое значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeBoolean, writeBoolean
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение, показывающее, какой байт записывается. Если параметр содержит значение <codeph>true</codeph>, метод записывает 1. В случае значения <codeph>false</codeph> записывается 0.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает логическое значение. Записывается один байт, соответствующий параметру <codeph>value</codeph>, 1 в случае значения <codeph>true</codeph> и 0 в случае значения <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeByte"><apiName>writeByte</apiName><shortdesc>
	 Записывает байт в поток байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeByte, writeByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>32-разрядное целое число. В поток байтов записываются младшие 8 бит.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает байт в поток байтов. 
	 <p>Используется 8 младших битов параметра. 24 старших битов игнорируются. </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	 Записывает в поток байт последовательность байт длиной length из заданного массива байтов (bytes), начиная со смещения offset (индекс отсчитывается от нуля).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeBytes, writeBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект ByteArray.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Отсчитываемое от нуля значение индекса, определяющее положение начала записи в массив.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число без знака, определяющее глубину буфера для записи.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток байт последовательность байт длиной <codeph>length</codeph> из заданного массива байт (<codeph>bytes</codeph>), начиная со смещения <codeph>offset</codeph> (индекс отсчитывается от нуля).
	 
	 <p>Если параметр <codeph>length</codeph> опущен, применение длины по умолчанию, равной 0, приведет к тому, что метод будет записывать весь буфер, начиная со смещения <codeph>offset</codeph>. Если также опустить параметр <codeph>offset</codeph>, будет записываться весь буфер. </p> <p>Если параметры <codeph>offset</codeph> или <codeph>length</codeph> находятся за пределами диапазона, то они корректируются так, чтобы совпасть с началом и концом массива <codeph>bytes</codeph>.</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	 Записывает в поток байтов число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeDouble, writeDouble
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число с двойной точностью (64-разрядное) и плавающей запятой.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток байтов число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	 Записывает в поток байтов число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeFloat, writeFloat
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число с одинарной точностью (32-разрядное) и плавающей запятой.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток байтов число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeInt"><apiName>writeInt</apiName><shortdesc>
	 Записывает в поток байтов 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeInt, writeInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Целое число, записываемое в поток байтов.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток байтов 32-разрядное целое число со знаком.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	 Записывает многобайтовую строку в поток байтов с использованием заданного набора знаков.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeMultiByte, writeMultiByte
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, определяющая используемый набор символов. Возможные строки наборов символов: <codeph>"shift_jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает многобайтовую строку в поток байтов с использованием заданного набора знаков. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeObject"><apiName>writeObject</apiName><shortdesc>
	 Записывает объект в массив байтов в сериализованном формате AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeObject, writeObject
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Сериализуемый объект.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает объект в массив байтов в сериализованном формате AMF.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:ByteArray:writeShort"><apiName>writeShort</apiName><shortdesc>
	 Записывает в поток байтов 16-разрядное целое число.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeShort, writeShort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>32-разрядное целое число, из которого в поток байтов записывается 16 младших бит.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток байтов 16-разрядное целое число. Используется 16 младших битов параметра. 16 старших битов игнорируются.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	 Записывает строку UTF-8 в поток байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUTF, writeUTF
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если длина превышает 65535.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает строку UTF-8 в поток байтов. Сначала записывается длина строки UTF-8 в байтах (в виде 16-разрядного целого числа), за которой следуют байты символов строки.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	 Записывает строку UTF-8 в поток байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUTFBytes, writeUTFBytes
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает строку UTF-8 в поток байтов. Аналогично <codeph>writeUTF()</codeph>, с тем различием, что <codeph>writeUTFBytes()</codeph> не вставляет перед строкой 16-разрядное слово, указывающее длину.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:ByteArray:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	 Записывает в поток байтов 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.writeUnsignedInt, writeUnsignedInt
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Беззнаковое целое число, записываемое в поток байтов.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток байтов 32-разрядное целое число без знака.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:ByteArray:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	 Число байтов данных, доступных для чтения от текущей позиции в массиве байтов до конца массива.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>available, bytes, position 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Число байтов данных, доступных для чтения от текущей позиции в массиве байтов до конца массива.
	 
	 <p>Каждый раз, когда выполняется доступ к объекту ByteArray, в сочетании с методами чтения следует использовать свойство <codeph>bytesAvailable</codeph>. Это позволит обеспечить чтение действительных данных.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:ByteArray:defaultObjectEncoding:get"><apiName>defaultObjectEncoding</apiName><shortdesc>
	 Обозначает кодировку объекта по умолчанию класса ByteArray для использования в новом экземпляре ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.defaultObjectEncoding, defaultObjectEncoding
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Обозначает кодировку объекта по умолчанию класса ByteArray для использования в новом экземпляре ByteArray. При создании экземпляра ByteArray используется значение кодировки <codeph>defaultObjectEncoding</codeph>. Свойство <codeph>defaultObjectEncoding</codeph> инициализируется в <codeph>ObjectEncoding.AMF3</codeph>.
	 
	 
	 <p>Когда объект записывается или считывается из двоичных данных, свойство <codeph>objectEncoding</codeph> указывает используемую версию формата: формат ActionScript 3.0, ActionScript 2.0 или ActionScript 1.0. Значение представлено константой из класса ObjectEncoding.</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link><link href="flash.utils.xml#ByteArray/objectEncoding"><linktext>flash.utils.ByteArray.objectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:endian:get"><apiName>endian</apiName><shortdesc>
	 Изменяет или считывает порядок байтов данных: Endian.BIG_ENDIAN или Endian.LITTLE_ENDIAN.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Изменяет или считывает порядок байтов данных: <codeph>Endian.BIG_ENDIAN</codeph> или <codeph>Endian.LITTLE_ENDIAN</codeph>.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Класс Endian</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:length:get"><apiName>length</apiName><shortdesc>
	 Длина объекта ByteArray в байтах.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Длина объекта ByteArray в байтах.
	 
	 <p>Если длина установлена в значение, превышающее текущую длину, правая часть массива байтов заполняется нулями.</p>
	 
	 <p>Если длина установлена в значение, меньшее текущей длины, выполняется усечение массива байтов.</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:ByteArray:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
	 Позволяет определить, какой формат — ActionScript 3.0, ActionScript 2.0 или ActionScript 1.0, — должен применяться при записи или чтении из экземпляра ByteArray.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.objectEncoding, objectEncoding
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Позволяет определить, какой формат — ActionScript 3.0, ActionScript 2.0 или ActionScript 1.0, — должен применяться при записи или чтении из экземпляра ByteArray. Значение представлено константой из класса ObjectEncoding.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link><link href="flash.utils.xml#ByteArray/defaultObjectEncoding"><linktext>flash.utils.ByteArray.defaultObjectEncoding</linktext></link></related-links></apiValue><apiValue id="flash.utils:ByteArray:position:get"><apiName>position</apiName><shortdesc>
	 Перемещает или возвращает текущую позицию указателя файла в объекте ByteArray (в байтах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>ByteArray, ByteArray.getFilePointer, 
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Перемещает или возвращает текущую позицию указателя файла в объекте ByteArray (в байтах). При следующем вызове метода чтения с этого положения начинается чтение, а при вызове метода записи начинается запись.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IDataOutput"><apiName>IDataOutput</apiName><shortdesc>
В интерфейсе IDataOutput предусмотрен набор методов для записи двоичных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
В интерфейсе IDataOutput предусмотрен набор методов для записи двоичных данных. В операциях ввода-вывода этот интерфейс дополняет интерфейс IDataInput, который считывает двоичные данные. Интерфейс IDataOutput реализован в классах FileStream, Socket и ByteArray.
<p>По умолчанию все операции IDataInput и IDataOutput используют порядок bigEndian (у старшего байта последовательности меньший адрес), и являются неблокирующими. </p>
<p>Расширение знака имеет значение только при чтении данных, но не при их записи. Поэтому для работы с <codeph>IDataInput.readUnsignedByte()</codeph> и <codeph>IDataInput.readUnsignedShort()</codeph> не требуется создавать отдельные методы записи. Другими словами:</p>
<ul>
  <li><codeph>IDataOutput.writeByte()</codeph> используется с <codeph>IDataInput.readUnsignedByte()</codeph> и <codeph>IDataInput.readByte()</codeph>.</li>
  <li><codeph>IDataOutput.writeShort()</codeph> используется с <codeph>IDataInput.readUnsignedShort()</codeph> и <codeph>IDataInput.readShort()</codeph>.</li>
</ul>

</apiDesc><example conref="examples\DataOutputExample.as"> В следующем примере класс <codeph>DataOutputExample</codeph> используется для записи в массив байтов логического значения и представления числа «пи» с двойной точностью и плавающей запятой. Это можно сделать, выполнив следующие действия:
 <ol>
     <li>Объявляется новый экземпляр объекта ByteArray <codeph>byteArr</codeph>.</li>
     <li>Записывается эквивалент байтового логического значения <codeph>false</codeph> и эквивалент числа «пи» с двойной точностью и плавающей запятой.</li>
     <li>Считывается логическое значение и число двойной точности с плавающей запятой.</li>
 </ol>
 
 <p>Обратите внимание на то, что в конце добавляется сегмент кода для проверки ошибок конца файла. Это позволяет прекратить считывание потока байтов по достижении его окончания.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class DataOutputExample extends Sprite {        
        public function DataOutputExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            byteArr.writeDouble(Math.PI);
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean()); // false
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
                        
            try {
                trace(byteArr.readDouble());    // 3.141592653589793
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);        // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#IDataInput"><linktext>Интерфейс IDataInput</linktext></link><link href="flash.utils.xml#IDataOutput/endian"><linktext>endian</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>Класс FileStream</linktext></link><link href="flash.net.xml#Socket"><linktext>Класс Socket</linktext></link><link href="flash.net.xml#URLStream"><linktext>Класс URLStream</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>Класс ByteArray</linktext></link></related-links><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	 Записывает логическое значение.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>Логическое значение, показывающее, какой байт записывается. Если параметр имеет значение <codeph>true</codeph>, записывается 1; если <codeph>false</codeph>, записывается 0.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает логическое значение. Записывается один байт, соответствующий параметру <codeph>value</codeph>, 1 в случае значения <codeph>true</codeph> и 0 в случае значения <codeph>false</codeph>.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeByte"><apiName>writeByte</apiName><shortdesc>
	 Записывает байт.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение байта в виде целого числа.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает байт. Используются 8 младших битов параметра, а 24 старших битов игнорируются.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	 Записывает последовательность байтов из заданного массива байт bytes, начиная с байта, заданного параметром offset (используя индекс с нулевой базой), длиной, заданной параметром length, в поток файлов, байтов или массив байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Массив байтов для записи.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Индекс с нулевой базой, определяющий положение в массиве для начала записи.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Целое число без знака, определяющее глубину буфера для записи.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает последовательность байтов из заданного массива байтов <codeph>bytes</codeph>, начиная с байта, заданного параметром <codeph>offset</codeph> (используя индекс с нулевой базой), длиной, заданной параметром <codeph>length</codeph>, в поток файлов, байтов или массив байтов.
	 
	 <p>Если параметр <codeph>length</codeph> опущен, применение длины по умолчанию, равной 0, приведет к тому, что будет записан весь буфер, начиная со значения параметра <codeph>offset</codeph>. Если также опустить параметр <codeph>offset</codeph>, будет записываться весь буфер. </p>
	 
	 <p>Если параметры <codeph>offset</codeph> или <codeph>length</codeph> находятся за пределами диапазона, то они корректируются так, чтобы совпасть с началом и концом массива <codeph>bytes</codeph>.</p>
 	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	 Записывает число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число с двойной точностью (64-разрядное) и плавающей запятой.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает число IEEE 754 с двойной точностью (64-разрядное) и плавающей запятой.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	 Записывает число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Число с одинарной точностью (32-разрядное) и плавающей запятой.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает число IEEE 754 с одинарной точностью (32-разрядное) и плавающей запятой.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeInt"><apiName>writeInt</apiName><shortdesc>
	 Записывает 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение байта в виде целого числа со знаком.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает 32-разрядное целое число со знаком.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	 Записывает в поток файлов, байтов или массив байтов многобайтовую строку заданной длины с использованием заданного набора символов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>IDataOutput, IDataOutput.writeMultiByte, writeMultiByte
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, определяющая используемый набор символов. Возможные строки наборов символов: <codeph>"shift_jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток файлов, байтов или массив байтов многобайтовую строку заданной длины с использованием заданного набора символов. 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeObject"><apiName>writeObject</apiName><shortdesc>
	 Записывает объект в поток файлов, байтов или массив байтов в сериализованном формате AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>Объект для сериализации.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает объект в поток файлов, байтов или массив байтов в сериализованном формате AMF.
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataOutput/objectEncoding"><linktext>objectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeShort"><apiName>writeShort</apiName><shortdesc>
	 Записывает 16-разрядное целое число.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>Значение байта в виде целого числа.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает 16-разрядное целое число. Используются 16 младших битов параметра, а 16 старших битов игнорируются.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	 Записывает в поток файлов, байтов или массив байтов строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Если длина превышает 65535.
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает в поток файлов, байтов или массив байтов строку UTF-8. Сначала записывается длина строки UTF-8 в байтах (в виде 16-разрядного целого числа), за которой следуют байты символов строки.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	 Записывает строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Записываемое значение строки.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает строку UTF-8. Аналогично <codeph>writeUTF()</codeph>, но строке не предшествует 16-разрядное слово, указывающее длину.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataOutput:flash.utils:IDataOutput:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	 Записывает 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>throws IOError An I/O error occurred?
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Значение байта в виде целого числа без знака.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Записывает 32-разрядное целое число без знака.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:IDataOutput:flash.utils:IDataOutput:endian:get"><apiName>endian</apiName><shortdesc>
	 Порядок байтов данных, константа BIG_ENDIAN или LITTLE_ENDIAN класса Endian.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Порядок байтов данных, константа <codeph>BIG_ENDIAN</codeph> или <codeph>LITTLE_ENDIAN</codeph> класса Endian.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Класс Endian</linktext></link></related-links></apiValue><apiValue id="flash.utils:IDataOutput:flash.utils:IDataOutput:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Указывает, какой формат, AMF3 или AMF0, используется для записи или чтения двоичных данных с помощью метода writeObject().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, какой формат, AMF3 или AMF0, используется для записи или чтения двоичных данных с помощью метода <codeph>writeObject()</codeph>. Значение представлено константой из класса ObjectEncoding.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#IDataInput/readObject()"><linktext>IDataInput.readObject()</linktext></link><link href="flash.utils.xml#IDataOutput/writeObject()"><linktext>writeObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.utils:Endian"><apiName>Endian</apiName><shortdesc>
 Класс Endian содержит значения, указывающие порядок байтов, применяемый для представления многобайтовых чисел.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Endian содержит значения, указывающие порядок байтов, применяемый для представления многобайтовых чисел. Порядок бывает bigEndian (первым идет старший байт) или littleEndian (первым идет младший байт).
 
 <p>Содержимое в <ph platform="actionscript">Flash Player или</ph> Adobe<sup>®</sup> AIR™ может взаимодействовать с сервером с помощью двоичного протокола этого сервера напрямую. Некоторые серверы используют порядок следования байтов bigEndian, а некоторые – littleEndian. Большинство серверов в Интернете использует порядок следования байтов bigEndian, поскольку он является «порядком следования байтов в сети». Порядок следования байтов littleEndian популярен потому, что используется в архитектуре Intel x86. Необходимо использовать тот порядок следования байтов, который соответствует протоколу сервера, отправляющего и получающего данные.</p>
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.utils.xml#ByteArray/endian"><linktext>flash.utils.ByteArray.endian</linktext></link><link href="flash.filesystem.xml#FileStream/endian"><linktext>flash.filesystem.FileStream.endian</linktext></link><link href="flash.utils.xml#IDataInput/endian"><linktext>flash.utils.IDataInput.endian</linktext></link><link href="flash.utils.xml#IDataOutput/endian"><linktext>flash.utils.IDataOutput.endian</linktext></link><link href="flash.net.xml#Socket/endian"><linktext>flash.net.Socket.endian</linktext></link><link href="flash.net.xml#URLStream/endian"><linktext>flash.net.URLStream.endian</linktext></link></related-links><apiValue id="flash.utils:Endian:BIG_ENDIAN"><apiName>BIG_ENDIAN</apiName><shortdesc>
	 Показывает, что наиболее значимый байт многобайтового числа располагается первым в последовательности байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bigEndian</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, что наиболее значимый байт многобайтового числа располагается первым в последовательности байтов.
	 <p>Шестнадцатеричное число 0x12345678 состоит из 4 байтов (2 шестнадцатеричных разряда на байт). Старшим байтом является 0x12. Младшим – 0x78. (Для эквивалентного десятеричного числа 305419896 старшим разрядом является 3, а младшим – 6.)</p>
	 <p>Поток, в котором используется порядок следования байтов bigEndian (первым идет старший байт), выдает следующее:</p>
	 <pre>
	 12 34 56 78
	 </pre>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Endian:LITTLE_ENDIAN"><apiName>LITTLE_ENDIAN</apiName><shortdesc>
	 Показывает, что наименее значимый байт многобайтового числа располагается первым в последовательности байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>littleEndian</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Показывает, что наименее значимый байт многобайтового числа располагается первым в последовательности байтов.
	 <p>Шестнадцатеричное число 0x12345678 состоит из 4 байтов (2 шестнадцатеричных разряда на байт). Старшим байтом является 0x12. Младшим – 0x78. (Для эквивалентного десятеричного числа 305419896 старшим разрядом является 3, а младшим – 6.)</p>
	 <p>Поток, в котором используется порядок следования байтов littleEndian (первым идет младший байт), выдает следующее:</p>
	 <pre>
	 78 56 34 12
	 </pre>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IExternalizable"><apiName>IExternalizable</apiName><shortdesc>
 Интерфейс IExternalizable обеспечивает управление сериализацией класса по мере его шифрования в поток данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
 Интерфейс IExternalizable обеспечивает управление сериализацией класса по мере его шифрования в поток данных. Методы <codeph>writeExternal()</codeph> и <codeph>readExternal()</codeph> интерфейса IExternalizable реализуются классом, что позволяет осуществлять настройку содержимого и формата потока данных (но не имя класса или тип) для объекта и его супертипов. Каждый класс должен сериализовать и восстанавливать состояние своих экземпляров. Чтобы состояние можно было сохранять, эти методы должны быть симметричными супертипу. Эти методы заменяют исходное поведение сериализации Action Message Format (AMF). 
 <p>Если в классе не реализован интерфейс IExternalizable, или если класс не наследует этот интерфейс у класса, в котором он реализован, то экземпляр класса будет сериализован только с помощью стандартного механизма общедоступных элементов. В результате закрытые, внутренние и защищенные элементы класса будут недоступны.</p>
 <p>Для сериализации закрытых элементов класс должен использовать интерфейс IExternalizable. Например, следующий класс не сериализует ни один из своих элементов, поскольку они являются закрытыми:</p>
 <codeblock>
 class Example {
 
       private var one:int;
       private var two:int;
 }
 </codeblock>
 <p>Однако при реализации интерфейса IExternalizable появляется возможность записи закрытых элементов класса в поток данных и их чтения из этого потока, как показано ниже:</p>
 <codeblock>
 class Example implement IExternalizable {
 
       private var one:int;
       private var two:int;
 
       public function writeExternal(output:IDataOutput) {
 
            output.writeInt(one);
            output.writeInt(two);
       }
 
       public function readExternal(input:IDataInput) {
 
            one = input.readInt();
            two = input.readInt();
       }
 }
 </codeblock>
 <p><b>Примечание.</b> Если в классе реализован интерфейс IExternalizable, к экземплярам этого класса стандартная сериализация не применяется. Если этот класс наследует у суперкласса общедоступные элементы, ими следует управлять с осторожностью.</p>
 <p>Когда у подкласса класса, в котором реализован интерфейс IExternalizable, есть собственные закрытые элементы, в подклассе необходимо переопределить методы этого интерфейса, как указано ниже:</p>
 <codeblock>
 public class Base implements IExternalizable {
  
      private var one:Boolean;
  
      public function writeExternal(output:IDataOutput):void {
  
          output.writeBoolean(one);
      }
  
      public function readExternal(input:IDataInput):void {
  
          one = input.readBoolean();
      }
 }
  
 public class Example extends Base {
  
      private var one:String;
  
  
      public override function writeExternal(output:IDataOutput):void {
  
          super.writeExternal(output);
          output.writeUTF(one);
      }
  
      public override function readExternal(input:IDataInput):void {
      
          super.readExternal(input);
          one = input.readUTF();
      }
 }
 </codeblock>
 <p>Интерфейс IExternalizable также можно использовать для сжатия данных перед их записью в поток данных. Например:</p>
 <codeblock>
 class Example implements IExternalizable {
  
      public var one:Boolean;
      public var two:Boolean;
      public var three:Boolean;
      public var four:Boolean;
      public var five:Boolean;
      public var six:Boolean;
      public var seven:Boolean;
      public var eight:Boolean;
 
      public function writeExternal(output:IDataOutput) {
 
          var flag:int = 0;
 
          if (one) flag |= 1;
          if (two) flag |= 2;
          if (three) flag |= 4;
          if (four) flag |= 8;
          if (five) flag |= 16;
          if (six) flag |= 32;
          if (seven) flag |= 64;
          if (eight) flag |= 128;
 
          output.writeByte(flag);
      }
 
      public function readExternal(input:IDataInput) {
 
          var flag:int = input.readByte();
 
          one = (flag &amp; 1) != 0;
          two = (flag &amp; 2) != 0;
          three = (flag &amp; 4) != 0;
          four = (flag &amp; 8) != 0;
          five = (flag &amp; 16) != 0;
          six = (flag &amp; 32) != 0;
          seven = (flag &amp; 64) != 0;
          eight = (flag &amp; 128) != 0;
      }
 }
 </codeblock>
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>flash.net.ObjectEncoding</linktext></link></related-links><apiOperation id="flash.utils:IExternalizable:flash.utils:IExternalizable:readExternal"><apiName>readExternal</apiName><shortdesc>
	 Путем реализации данного метода класс расшифровывает сам себя из потока данных с помощью методов интерфейса IDataInput.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>input</apiItemName><apiOperationClassifier>flash.utils:IDataInput</apiOperationClassifier><apiDesc>Имя класса, в котором реализован интерфейс IDataInput.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Путем реализации данного метода класс расшифровывает сам себя из потока данных с помощью методов интерфейса IDataInput. Этот метод должен считывать значения в той же последовательности и с теми же типами, как было записано методом <codeph>writeExternal()</codeph>.
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IExternalizable:flash.utils:IExternalizable:writeExternal"><apiName>writeExternal</apiName><shortdesc>
	 Путем реализации данного метода класс шифрует сам себя для потока данных с помощью методов интерфейса IDataOutput.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>output</apiItemName><apiOperationClassifier>flash.utils:IDataOutput</apiOperationClassifier><apiDesc>Имя класса, в котором реализован интерфейс IDataOutput.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Путем реализации данного метода класс шифрует сам себя для потока данных с помощью методов интерфейса IDataOutput.
     </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiOperation id="globalOperation:flash.utils:describeType"><apiName>describeType</apiName><shortdesc>
	 Создает объект XML, описывающий объект ActionScript, который именуется как параметр метода.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Объект XML, содержащий сведения об объекте, переданном в качестве параметра. В нем содержатся следующие сведения об объекте:
	 
	 <ul>
	  <li>класс объекта;</li> 
	 	 <li>атрибуты класса;</li> 
	 	 <li>дерево наследования от класса к его базовым классам;</li> 
	 	 <li>интерфейсы, унаследованные классом;</li> 
	 	 <li>объявленные свойства экземпляра класса;</li> 
	 	 <li>объявленные статические свойства класса;</li> 
	 	 <li>методы экземпляра класса;</li>
	 	 <li>статические методы класса; </li>
	 	 <li>для каждого метода класса – имя, количество параметров, тип возвращаемого значения и типы параметров. </li>
	 </ul>
     <p><b>Примечание.</b> <codeph>describeType()</codeph> показывает только общедоступные свойства и методы, и не показывает методы, которые являются закрытыми, внутренними для пакета или находятся в собственных пространствах имен. </p>
	 
 	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Объект, для которого требуется описание типа. Этому методу можно передать любое значение ActionScript, включая любые доступные типы, экземпляры объектов, примитивные типы (например, uint) и объекты классов ActionScript.
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Создает объект XML, описывающий объект ActionScript, который именуется как параметр метода. В этом методе реализована концепция программирования <i>отражение</i> для языка ActionScript.
	 <p>Если параметр <codeph>value</codeph> является экземпляром типа, возвращаемый объект XML содержит все свойства экземпляра, имеющие этот тип, но не содержит статических свойств. Это условие можно проверить при анализе объекта XML посредством исследования значения атрибута <codeph>isStatic</codeph> тега <codeph>&lt;type></codeph>, который содержит значение <codeph>false</codeph>, если параметр <codeph>value</codeph> является экземпляром типа.</p>
	 <p>Чтобы получить статические свойства типа, передайте для параметра <codeph>value</codeph> сам тип. Возвращаемый объект XML содержит не только статические свойства типа, но также все свойства его экземпляра. Свойства экземпляра вложены в тег под именем <codeph>&lt;factory></codeph>, что позволяет отличить их от статических свойств. В этом случае атрибут <codeph>isStatic</codeph> тега <codeph>&lt;type></codeph> содержит значение <codeph>true</codeph>.</p>
	 <p><b>Примечание.</b> Если требуется только пройти по иерархии наследования объекта, а остальные сведения, предоставляемые функцией <codeph>describeType()</codeph> не требуются, вместо последней используйте функции <codeph>getQualifiedClassName()</codeph> и <codeph>getQualifiedSuperclassName()</codeph>.</p>
	 <p>В следующей таблице описываются некоторые теги и атрибуты объекта XML, создаваемого методом <codeph>describeType()</codeph> (все возвращенные имена классов и интерфейсов имеют полностью определенный формат).</p>
	 <adobetable class="innertable">
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	     
	 <tgroup cols="3"><thead><row><entry>Тег</entry><entry>Атрибут</entry><entry>Описание</entry></row></thead><tbody><row><entry><codeph>&lt;type></codeph></entry><entry> </entry><entry>Корневой тег объекта XML.</entry></row><row><entry> </entry><entry>name</entry><entry>Имя типа данных объекта ActionScript.</entry></row><row><entry> </entry><entry>base</entry><entry>Непосредственный суперкласс класса, определяющего объект ActionScript. Если объект ActionScript является объектом класса, значение равно <codeph>Class</codeph>.</entry></row><row><entry> </entry><entry>isDynamic</entry><entry><codeph>true</codeph>, если класс, определяющий объект ActionScript, является динамическим. В противном случае содержит значение <codeph>false</codeph>. Если объект ActionScript является объектом класса, значение равно <codeph>true</codeph>, поскольку класс Class является динамическим.</entry></row><row><entry> </entry><entry>isFinal</entry><entry><codeph>true</codeph>, если класс, определяющий объект ActionScript, является последним. В противном случае содержит значение <codeph>false</codeph>.</entry></row><row><entry> </entry><entry>isStatic</entry><entry><codeph>true</codeph>, если объект ActionScript является объектом класса или функцией конструктора. В противном случае содержит значение <codeph>false</codeph>. Этот атрибут называется <codeph>isStatic</codeph>, потому что если он содержит значение <codeph>true</codeph>, любые теги, не вложенные в тег <codeph>factory</codeph> являются статическими.</entry></row><row><entry><codeph>&lt;extendsClass></codeph></entry><entry> </entry><entry>Для каждого суперкласса класса, определяющего объект ActionScript, существует отдельный тег <codeph>extendsClass</codeph>.</entry></row><row><entry> </entry><entry>type</entry><entry>Имя суперкласса, который расширяется классом, определяющим объект ActionScript.</entry></row><row><entry><codeph>&lt;implementsInterface></codeph></entry><entry> </entry><entry>Для каждого интерфейса, который реализован классом, определяющим объект ActionScript, или любым из его суперклассов, существует отдельный тег <codeph>implementsInterface</codeph>.</entry></row><row><entry> </entry><entry>type</entry><entry>Имя интерфейса, который реализуется классом, определяющим объект ActionScript.</entry></row><row><entry><codeph>&lt;accessor></codeph></entry><entry> </entry><entry>Accessor – это свойство, определяемое функциями getter и setter.</entry></row><row><entry> </entry><entry>name</entry><entry>Имя средства доступа.</entry></row><row><entry> </entry><entry>access</entry><entry>Права доступа к свойству. Возможные значения: <codeph>readonly</codeph>, <codeph>writeonly</codeph> и <codeph>readwrite</codeph>.</entry></row><row><entry> </entry><entry>type</entry><entry>Тип данных свойства.</entry></row><row><entry> </entry><entry>declaredBy</entry><entry>Класс, содержащий связанные функции getter или setter.</entry></row><row><entry><codeph>&lt;constant></codeph></entry><entry> </entry><entry>Константа – это свойство, определяемое с помощью инструкции <codeph>const</codeph>.</entry></row><row><entry> </entry><entry>name</entry><entry>Имя константы.</entry></row><row><entry> </entry><entry>type</entry><entry>Тип данных константы.</entry></row><row><entry><codeph>&lt;метод></codeph></entry><entry> </entry><entry>Фиксированное свойство – это переменная, константа или метод, объявленный как часть определения класса.</entry></row><row><entry> </entry><entry>name</entry><entry>Имя метода.</entry></row><row><entry> </entry><entry>declaredBy</entry><entry>Класс, содержащий определение метода.</entry></row><row><entry> </entry><entry>returnType</entry><entry>Тип данных значения, возвращаемого методом.</entry></row><row><entry><codeph>&lt;parameter></codeph></entry><entry> </entry><entry>Для каждого параметра, определяемого методом, существует отдельный тег <codeph>parameter</codeph>. Этот тег всегда является вложенным в тег <codeph>&lt;method></codeph>.</entry></row><row><entry> </entry><entry>index</entry><entry>Число, соответствующее положению параметра в списке параметров метода. Первый параметр имеет номер 1.</entry></row><row><entry> </entry><entry>type</entry><entry>Тип данных параметра.</entry></row><row><entry> </entry><entry>optional</entry><entry><codeph>true</codeph>, если параметр является необязательным, в противном случае – <codeph>false</codeph>.</entry></row><row><entry><codeph>&lt;variable></codeph></entry><entry> </entry><entry>Переменная – это свойство, определенное с помощью инструкции <codeph>var</codeph>.</entry></row><row><entry> </entry><entry>name</entry><entry>Имя переменной.</entry></row><row><entry> </entry><entry>type</entry><entry>Тип данных переменной.</entry></row><row><entry><codeph>&lt;factory></codeph></entry><entry> </entry><entry>Если объект ActionScript является объектом класса или функцией конструктора, все свойства и методы экземпляра являются вложенными в этот тег. Если атрибут <codeph>isStatic</codeph> тега <codeph>&lt;type></codeph> содержит значение <codeph>true</codeph>, все свойства и методы, не вложенные в тег <codeph>&lt;factory></codeph>, являются статическими. Этот тег присутствует только в случае, если объект ActionScript является объектом класса или функцией конструктора.</entry></row></tbody></tgroup></adobetable>
	 
	 
	 </apiDesc><example conref="examples\DescribeTypeExample.as"><codeblock>package {
    import flash.display.Sprite;
    import flash.utils.describeType;
    
    public class DescribeTypeExample extends Sprite {
        public function DescribeTypeExample() {
            var child:Sprite = new Sprite();
            var description:XML = describeType(child);
            trace(description..accessor.@name.toXMLString());
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/getQualifiedClassName()"><linktext>getQualifiedClassName()</linktext></link><link href="flash.utils.xml#/getQualifiedSuperclassName()"><linktext>getQualifiedSuperclassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:escapeMultiByte"><apiName>escapeMultiByte</apiName><shortdesc>
	  Возвращает изолированную копию входной строки, зашифрованную с помощью UTF-8 или системной кодовой страницы, в зависимости от значения System.useCodePage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Копия входной строки с управляющими символами. Если параметр System.useCodePage содержит значение <codeph>true</codeph>, строка с управляющими символами кодируется в системной кодировке. Если параметр System.useCodePage содержит значение <codeph>false</codeph>, строка с управляющими символами кодируется в UTF-8. Например, если параметр System.useCodePage содержит значение <codeph>false</codeph>, то входная строка «CrA?e» будет передана как «Cr%C3%BCe» во всех системах. Если параметр system.useCodePage содержит значение <codeph>true</codeph>, и в системе используется кодовая страница Latin, «CrA?e» будет передано как «Cr%FCe». Если в системе используется кодировка, отличная от Latin, в которой отсутствует буква «A?», результатом, вероятно, будет строка «Cr?e».
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, которую необходимо преобразовать с использованием управляющих символов.
	  
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Возвращает изолированную копию входной строки, зашифрованную с помощью UTF-8 или системной кодовой страницы, в зависимости от значения System.useCodePage. Использование параметра System.useCodePage позволяет проигрывателю получать доступ к содержимому, использующему локальные кодировки, но только в системах, использующих такие кодировки. Например, данные на японском языке, закодированные как <codeph>Shift-JIS</codeph>, будут правильно преобразованы только в операционной системе, в которой по умолчанию используется японская кодировка.
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:getDefinitionByName"><apiName>getDefinitionByName</apiName><shortdesc>
	 Возвращает ссылку на объект класса, заданного параметром name.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Общедоступного определения с указанным именем не существует.
	 
     </apiDesc><apiItemName>ReferenceError</apiItemName><apiOperationClassifier>ReferenceError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращает ссылку на объект класса, заданного параметром <codeph>name</codeph>.
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Имя класса.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Возвращает ссылку на объект класса, заданного параметром <codeph>name</codeph>.
	 </apiDesc><example conref="examples\GetDefinitionByNameExample.as"> В следующем примере для создания оранжевого квадрата в рабочей области используется класс <codeph>GetDefinitionByNameExample</codeph>. Для этого выполняются следующие действия:
 <ol>
     <li>Объявляются переменные для оранжевого цвета фона и размера в 80 пикселей, которые позже будут использованы при рисовании квадрата.</li>
     <li>В конструкторе классу Sprite назначается переменная <codeph>ClassReference</codeph> типа Class.</li>
     <li>Создается экземпляр объекта ClassReference с именем <codeph>instance</codeph>.</li>
     <li>Поскольку <codeph>instance</codeph> по ссылке является объектом Sprite, квадрат можно нарисовать и добавить в список отображения с помощью методов, доступных классу Sprite.</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;
    import flash.utils.getDefinitionByName;

    public class GetDefinitionByNameExample extends Sprite {
        private var bgColor:uint = 0xFFCC00;
        private var size:uint = 80;

        public function GetDefinitionByNameExample() {
            var ClassReference:Class = getDefinitionByName("flash.display.Sprite") as Class;
            var instance:Object = new ClassReference();
            instance.graphics.beginFill(bgColor);
            instance.graphics.drawRect(0, 0, size, size);
            instance.graphics.endFill();
            addChild(DisplayObject(instance));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:getQualifiedClassName"><apiName>getQualifiedClassName</apiName><shortdesc>
	  Возвращает полное имя класса для объекта.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Строка, в которой содержится полное имя класса.
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Объект, для которого требуется полное имя класса. Этому методу можно передать любое значение ActionScript, включая любые доступные типы, экземпляры объектов, примитивные типы (например, uint) и объекты классов ActionScript.
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Возвращает полное имя класса для объекта.
	  
	  </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#/describeType()"><linktext>describeType()</linktext></link><link href="flash.utils.xml#/getQualifiedSuperclassName()"><linktext>getQualifiedSuperclassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:getQualifiedSuperclassName"><apiName>getQualifiedSuperclassName</apiName><shortdesc>
	Возвращает полное имя класса для базового класса объекта, заданного параметром value.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Полное базовое имя класса или <codeph>null</codeph>, если такое имя отсутствует.
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value=""/><apiDesc>Любое значение.
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	Возвращает полное имя класса для базового класса объекта, заданного параметром <codeph>value</codeph>. Эта функция обеспечивает более быстрый способ получения имени базового класса по сравнению с <codeph>describeType()</codeph>, но она не предоставляет сведения, которые передает функция <codeph>describeType()</codeph>.
	<p>После получения имени класса с помощью этой функции имя класса можно преобразовать с помощью функции <codeph>getDefinitionByName()</codeph> в ссылку на класс.</p>
	<p><b>Примечание.</b> Эта функция ограничивается иерархиями экземпляра, а функция <codeph>describeType()</codeph> использует иерархии объекта класса, если параметр <codeph>value</codeph> является типом данных. Вызов функции <codeph>describeType()</codeph> по отношению к типу данных возвращает суперкласс на основе иерархии объекта класса, в которой все объекты класса унаследованы из класса Class. При этом функция <codeph>getQualifiedSuperclassName()</codeph> игнорирует иерархию объекта класса и возвращает суперкласс на основе более привычной иерархии экземпляра. Например, при вызове <codeph>getQualifiedSuperclassName(String)</codeph> возвращается <codeph>Object</codeph>, хотя технически объект класса String наследуется из класса Class. Другими словами, результаты совпадают независимо от использования экземпляра типа или самого типа.</p>
	</apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#/describeType()"><linktext>describeType()</linktext></link><link href="flash.utils.xml#/getDefinitionByName()"><linktext>getDefinitionByName()</linktext></link><link href="flash.utils.xml#/getQualifiedClassName()"><linktext>getQualifiedClassName()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:getTimer"><apiName>getTimer</apiName><shortdesc>
	 Используется для вычисления относительного времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Число миллисекунд, прошедшее с момента инициализации среды выполнения (при обработке ActionScript 2.0) или с момента запуска виртуальной машины (при обработке ActionScript 3.0). Если среда выполнения начинает воспроизведение одного SWF-файла, а после загружается другой SWF-файл, возвращается значение для момента загрузки первого SWF-файла.
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Используется для вычисления относительного времени. Когда среда выполнения Flash обрабатывает ActionScript 3.0, этот метод возвращает число миллисекунд, прошедшее с момента запуска виртуальной машины среды выполнения Flash для ActionScript 3.0 (AVM2). Когда среда выполнения Flash обрабатывает ActionScript 2.0, этот метод возвращает число миллисекунд, прошедшее с момента инициализации среды выполнения Flash. Среды выполнения Flash использует две виртуальных машины для обработки ActionScript. AVM1 — это виртуальная машина ActionScript, используем для обработки ActionScript 1.0 и 2.0. AVM2 — это виртуальная машина ActionScript, используемая для обработки ActionScript 3.0. Метод <codeph>getTimer()</codeph> ведет себя по-разному для AVM1 и AVM2.
	 <p>Дату календаря (метку времени) см. в объекте Date.</p> 	 
	 
	 </apiDesc><example conref="examples\getTimerExample.as"> В следующем примере для получения и вывода количества миллисекунд, которое прошло с момента начала воспроизведения проигрывателем Flash Player, используется класс <codeph>GetTimerExample</codeph>.
<codeblock>
package {
    import flash.utils.getTimer;
    import flash.display.Sprite;

    public class GetTimerExample extends Sprite {
        public function GetTimerExample() {
            var duration:uint = getTimer();
            trace("duration: " + duration);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#AVM1Movie"><linktext>flash.display.AVM1Movie</linktext></link><link href="#Date"><linktext>Класс Date</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:unescapeMultiByte"><apiName>unescapeMultiByte</apiName><shortdesc>
	  Возвращает неэкранированную копию входной строки, расшифрованную из системной кодовой страницы или UTF-8, в зависимости от значения System.useCodePage.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Копия входной строки с управляющими символами. Если параметр System.useCodePage содержит значение <codeph>true</codeph>, строка с управляющими символами кодируется в системной кодировке. Если параметр System.useCodePage содержит значение <codeph>false</codeph>, строка с управляющими символами кодируется в UTF-8. Например, если параметр System.useCodePage содержит значение <codeph>false</codeph>, входная строка "Crüe" будет передана как "Cr%C3%BCe" во всех системах. Если параметр system.useCodePage содержит значение <codeph>true</codeph>, и в системе используется кодовая страница "Latin", "Crüe" будет передано как "Cr%FCe". Если в системе используется кодировка, отличная от «Latin», в которой отсутствует буква «ü», результатом, вероятно, будет строка «Cr?e». В ходе преобразования управляющих символов строки «Cr%C3%BCe», когда параметр System.useCodePage содержит значение <codeph>true</codeph>, в различных системах будут получаться различные непредсказуемые результаты (например, «CrÃ¼e» в системе с кодировкой «Latin»). Аналогично, преобразование управляющих символов строки «Cr%FCe», когда параметр System.useCodePage содержит значение <codeph>false</codeph>, может привести к получению строки «Cre», «Cr?e» или других ее видов, в зависимости от кодировки системы.	
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, управляющие символы которой требуется преобразовать.
	  
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  Возвращает неизолированную копию входной строки, расшифрованную из системной кодовой страницы или UTF-8, в зависимости от значения System.useCodePage. Использование параметра System.useCodePage позволяет проигрывателю получать доступ к содержимому, использующему локальные кодировки, но только в системах, использующих такие кодировки. Например, данные на японском языке, закодированные как <codeph>Shift-JIS</codeph>, будут правильно преобразованы только в операционной системе, в которой по умолчанию используется японская кодировка.
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:flash.utils:clearInterval"><apiName>clearInterval</apiName><shortdesc>
 Отменяет указанный вызов метода setInterval().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Идентификатор вызова <codeph>setInterval()</codeph>, можно присвоить переменной, как показано ниже:
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Отменяет указанный вызов метода <codeph>setInterval()</codeph>.
 
 </apiDesc><example conref="examples\ClearIntervalExample.as"> В следующем примере используется метод <codeph>setInterval()</codeph> для создания интервала задержки, по истечении которого вызывается метод <codeph>myRepeatingFunction()</codeph> через повторяющиеся интервалы длительностью в одну секунду.
 <p>При каждом вызове метода <codeph>myRepeatingFunction</codeph> увеличивается значение свойства <codeph>counter</codeph>, и когда оно становится равным значению свойства <codeph>stopCount</codeph>, вызывается метод <codeph>clearInterval() </codeph> со свойством <codeph>intervalId</codeph>, представляющим собой идентификатор обращения к ранее созданному интервалу.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class ClearIntervalExample extends Sprite {
        private var intervalDuration:Number = 1000; // duration between intervals, in milliseconds
        private var intervalId:uint;
        private var counter:uint     = 0;
        private var stopCount:uint     = 3;
        
        public function ClearIntervalExample() {
            intervalId = setInterval(myRepeatingFunction, intervalDuration, "Hello", "World");
        }

        public function myRepeatingFunction():void {
            trace(arguments[0] + " " + arguments[1]);

            counter++;
            if(counter == stopCount) {
                trace("Clearing Interval");
                clearInterval(intervalId);    
            }
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/setInterval()"><linktext>setInterval()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:clearTimeout"><apiName>clearTimeout</apiName><shortdesc>
 Отменяет указанный вызов метода setTimeout().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Идентификатор вызова <codeph>setTimeout()</codeph>, присваиваемый переменной, как показано ниже:
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Отменяет указанный вызов метода <codeph>setTimeout()</codeph>.
 
 </apiDesc><example conref="examples\ClearTimeoutExample.as"> В приводимом примере метод <codeph>setTimeout()</codeph> используется для вызова другого метода через указанный промежуток времени.
 <p>Создается цикл до миллиона. Если компьютер может обработать этот запрос быстрее, чем за одну секунду, <codeph>clearTimeout()</codeph> удалит запрос <codeph>setTimeout()</codeph>, и метод <codeph>myDelayedFunction()</codeph> не будет вызван.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class ClearTimeoutExample extends Sprite {
        private var delay:Number = 1000; // delay before calling myDelayedFunction
        private var intervalId:uint;
        private var count:uint = 1000000;
        
        public function ClearTimeoutExample() {
            intervalId = setTimeout(myDelayedFunction, delay);
            startCounting();
        }

        public function startCounting():void {
            var i:uint = 0;
            do {
                if(i == count-1) {
                    clearTimeout(intervalId);
                    trace("Your computer can count to " + count + " in less than " + delay/1000 + " seconds.");    
                }
                i++;
            } while(i &lt; count)            
        }
        
        public function myDelayedFunction():void {
            trace("Time expired.");
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/setTimeout()"><linktext>setTimeout()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:setInterval"><apiName>setInterval</apiName><shortdesc>
 Выполняет функцию с заданным интервалом (в миллисекундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Уникальный числовой идентификатор отложенного процесса. Используйте этот идентификатор для отмены процесса, вызвав метод <codeph>clearInterval()</codeph>.
 
 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>closure</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Имя выполняемой функции. Не включайте кавычки или скобки, а также не указывайте параметры вызываемой функции. Например, следует использовать <codeph>functionName</codeph>, а не <codeph>functionName()</codeph> или <codeph>functionName(param)</codeph>.
 
 </apiDesc></apiParam><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Интервал в миллисекундах. 
 
 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Необязательный список аргументов, передаваемых выполняемой функции.
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Выполняет функцию с заданным интервалом (в миллисекундах).
 
 <p>Вместо использования метода <codeph>setInterval()</codeph> рекомендуется создавать объект Timer с заданным интервалом, в котором в качестве параметра <codeph>repeatCount</codeph> используется значение 0 (то есть таймер выполняется бесконечно).</p>
 
 <p>Если предполагается использование метода <codeph>clearInterval()</codeph> для отмены вызова <codeph>setInterval()</codeph>, метод <codeph>setInterval()</codeph> обязательно должен быть назначен переменной (к которой в последующем будет обращаться функция <codeph>clearInterval()</codeph>). Если не вызвать функцию <codeph>clearInterval()</codeph> для отмены вызова <codeph>setInterval()</codeph>, объект, содержащий функцию очистки заданного интервала, не будет удален. </p>
 
 </apiDesc><example conref="examples\SetIntervalExample.as"> В следующем примере используется метод <codeph>setInterval()</codeph> для создания интервала задержки, по истечении которого вызывается метод <codeph>myRepeatingFunction()</codeph> через повторяющиеся интервалы длительностью в одну секунду.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class SetIntervalExample extends Sprite {
        private var intervalDuration:Number = 1000; // duration between intervals, in milliseconds
        
        public function SetIntervalExample() {
            var intervalId:uint = setInterval(myRepeatingFunction, intervalDuration, "Hello", "World");
        }

        public function myRepeatingFunction():void {
            trace(arguments[0] + " " + arguments[1]);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/clearInterval()"><linktext>clearInterval()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:flash.utils:setTimeout"><apiName>setTimeout</apiName><shortdesc>
 Выполняет указанную функцию с заданной задержкой (в миллисекундах).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>Уникальный числовой идентификатор отложенного процесса. Используйте этот идентификатор для отмены процесса, вызвав метод <codeph>clearTimeout()</codeph>.
 
 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>closure</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>Имя выполняемой функции. Не включайте кавычки или скобки, а также не указывайте параметры вызываемой функции. Например, следует использовать <codeph>functionName</codeph>, а не <codeph>functionName()</codeph> или <codeph>functionName(param)</codeph>.
 
 </apiDesc></apiParam><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Задержка (в миллисекундах) до выполнения функции. 
 
 </apiDesc></apiParam><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>Необязательный список аргументов, передаваемых выполняемой функции.
 
 </apiDesc></apiParam></apiOperationDef><apiDesc>
 Выполняет указанную функцию с определенной задержкой (в миллисекундах).
 
 <p>Вместо использования этого метода рекомендуется создавать объект Timer с указанным интервалом, в котором в качестве параметра <codeph>repeatCount</codeph> используется значение 1 (то есть таймер запускается один раз).</p>
 
 <p>Если предполагается использование метода <codeph>clearTimeout()</codeph> для отмены вызова <codeph>setTimeout()</codeph>, метод <codeph>setTimeout()</codeph> обязательно должен быть присвоен переменной (к которой в последующем будет обращаться функция <codeph>clearTimeout()</codeph>). Если не вызвать функцию <codeph>clearTimeout()</codeph> для отмены вызова <codeph>setTimeout()</codeph>, объект, содержащий функцию очистки заданного интервала, не будет удален. </p>
 
 </apiDesc><example conref="examples\SetTimeoutExample.as"> В примере ниже метод <codeph>setTimeout()</codeph> используется для вызова другого метода через указанный промежуток времени.
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.*;

    public class SetTimeoutExample extends Sprite {
        private var delay:Number = 1000; // delay before calling myDelayedFunction
        
        public function SetTimeoutExample() {
            var intervalId:uint = setTimeout(myDelayedFunction, delay, "Hello", "World");
        }

        public function myDelayedFunction():void {
            trace(arguments[0] + " " + arguments[1]);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#/clearTimeout()"><linktext>clearTimeout()</linktext></link></related-links></apiOperation><apiClassifier id="flash.utils:Timer"><apiName>Timer</apiName><shortdesc>
 Класс Timer является интерфейсом для таймеров, позволяющих выполнять код в заданные интервалы времени.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Timer является интерфейсом для таймеров, позволяющих выполнять код в заданные интервалы времени. Для запуска таймера служит метод <codeph>start()</codeph>. Для настройки кода на выполнение через интервал таймера добавьте прослушиватель события <codeph>timer</codeph>.
 
 <p>Объекты Timer можно создавать для однократного запуска или повторяющегося выполнения кода по расписанию. <ph platform="actionscript">В зависимости от частоты кадров в SWF-файле или среды проигрывателя Flash Player (от доступной памяти и других факторов) Flash Player или Adobe AIR может запускать события с небольшим сдвигом во времени. Например, если SWF-файл настроен на проигрывание с частотой 10 кадров в секунду, т.е. с интервалом в 100 миллисекунд, а таймер настроен на запуск события через 80 миллисекунд, то событие будет запускаться примерно через 100-миллисекундный интервал. </ph> <ph platform="javascript">Приложения могут передавать события с несколько смещенными интервалами, основанными на внутренней частоте кадров приложения. </ph> Сценарии, требующие большого объема памяти, также могут приводить к сдвигу времени отправки событий.</p>
 
 </apiDesc><example conref="examples\TimerExample.as"> В следующем примере используется класс <codeph>TimerExample</codeph> для демонстрации настройки метода прослушивателя <codeph>timerHandler()</codeph> на прослушивание передачи нового события TimerEvent. Таймер запускается при вызове метода <codeph>start()</codeph>, а события начинают передаваться, начиная с этого момента.  
<codeblock>
package {
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.display.Sprite;

    public class TimerExample extends Sprite {

        public function TimerExample() {
            var myTimer:Timer = new Timer(1000, 2);
            myTimer.addEventListener("timer", timerHandler);
            myTimer.start();
        }

        public function timerHandler(event:TimerEvent):void {
            trace("timerHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.utils:Timer_flash.events.TimerEvent.TIMER_COMPLETE_timerComplete"><apiName>timerComplete</apiName><shortdesc>
 Передается каждый раз при выполнении количества запросов, указанного свойством Timer.repeatCount.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TimerEvent.TIMER_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.TimerEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Передается каждый раз при выполнении количества запросов, указанного свойством <codeph>Timer.repeatCount</codeph>. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.utils:Timer_flash.events.TimerEvent.TIMER_timer"><apiName>timer</apiName><shortdesc>
 Передается каждый раз при достижении объектом Timer интервала, указанного в свойстве Timer.delay.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TimerEvent.TIMER</apiEventType><adobeApiEventClassifier>flash.events.TimerEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 Передается каждый раз при достижении объектом Timer интервала, указанного в свойстве <codeph>Timer.delay</codeph>. 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.utils:Timer:Timer"><apiName>Timer</apiName><shortdesc>
	 Создает новый объект Timer с заданными состояниями delay и repeatCount.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>если указанная задержка является отрицательным числом или не является конечным числом
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiParam><apiItemName>delay</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>Задержка в миллисекундах между событиями таймера.
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeatCount</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>Определяет количество повторений. Если ноль, таймер повторяет действия бесконечно. Если не равно нулю, таймер запускается указанное количество раз, а затем останавливается.
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект Timer с заданными состояниями <codeph>delay</codeph> и <codeph>repeatCount</codeph>.
	 
	 <p>Таймер не запускается автоматически, для его запуска необходимо вызвать метод <codeph>start()</codeph>.</p>
	 
	 </apiDesc><example conref="examples\Timer_constructorExample.as"> В следующем примере пользователю дается 90 секунд на ввод ответа в текстовое поле. Кроме того, каждые 30 секунд сообщение состояния оповещает пользователя о количестве оставшихся секунд.
 
 <p>Создается объект Timer, который запускается через 30 секунд (установлена задержка в 30000 миллисекунд) и повторяется три раза, всего – 90 секунд. (После третьего раза таймер останавливается).</p>
 
 <p>Для таймера <codeph>myTimer</codeph> добавляется два прослушивателя событий. Первый срабатывает по событию <codeph>TimerEvent.TIMER</codeph>, которое происходит при каждом запуске таймера. Метод <codeph>timerHandler()</codeph> изменяет текст в текстовом поле <codeph>statusTextField</codeph>, выводя оставшееся количество секунд. </p>
 <p><b>Примечание.</b> Класс Timer отслеживает количество запусков (<codeph>repeats</codeph>), увеличивая число в свойстве <codeph>currentCount</codeph>.)</p> 
 
 <p>При последнем вызове таймера отправляется событие <codeph>TimerEvent.TIMER_COMPLETE</codeph> и вызывается метод <codeph>completeHandler()</codeph>. Метод <codeph>completeHandler()</codeph> изменяет тип текстового поля <codeph>inputTextField</codeph> с <codeph>INPUT</codeph> на <codeph>DYNAMIC</codeph>. Это означает, что пользователь больше не может вводить или изменять текст.</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.text.TextField;
    import flash.text.TextFieldType;
    import flash.text.TextFieldAutoSize;
    import flash.utils.Timer;
    import flash.events.TimerEvent;
    import flash.events.Event;

    public class Timer_constructorExample extends Sprite {
            private var statusTextField:TextField = new TextField();        
            private var inputTextField:TextField = new TextField();
            private var delay:uint = 30000;
            private var repeat:uint = 3;
            private var myTimer:Timer = new Timer(delay, repeat);
            
        public function Timer_constructorExample() {
            inputTextField.x = 10;
            inputTextField.y = 10;
            inputTextField.border = true;
            inputTextField.background = true;
            inputTextField.height = 200;
            inputTextField.width = 200;
            inputTextField.multiline = true;
            inputTextField.wordWrap = true;
            inputTextField.type = TextFieldType.INPUT;

            statusTextField.x = 10;
            statusTextField.y = 220;
            statusTextField.background = true;
            statusTextField.autoSize = TextFieldAutoSize.LEFT;   

            myTimer.start(); 
            statusTextField.text = "You have " + ((delay * repeat) / 1000) 
                                 + " seconds to write your response.";

            myTimer.addEventListener(TimerEvent.TIMER, timerHandler);
            myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, completeHandler);

            addChild(inputTextField);
            addChild(statusTextField);
        }

        private function timerHandler(e:TimerEvent):void{
            repeat--;
            statusTextField.text = ((delay * repeat) / 1000) + " seconds left.";
        }

        private function completeHandler(e:TimerEvent):void {
            statusTextField.text = "Times Up.";
            inputTextField.type = TextFieldType.DYNAMIC;    
        }
    }
}
</codeblock></example></apiConstructorDetail></apiConstructor><apiOperation id="flash.utils:Timer:reset"><apiName>reset</apiName><shortdesc>
   	 Останавливает таймер, если он выполняется, и заново присваивает свойству currentCount значение 0, аналогично кнопке сброса на секундомере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
   	 Останавливает таймер, если он выполняется, и заново присваивает свойству <codeph>currentCount</codeph> значение 0, аналогично кнопке сброса на секундомере. Затем, при вызове метода <codeph>start()</codeph> экземпляр выполняется количество раз, определяемое значением <codeph>repeatCount</codeph>.
   	 
   	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Timer/stop()"><linktext>Timer.stop()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:Timer:start"><apiName>start</apiName><shortdesc>
	 Запускает таймер, если он еще не выполняется.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Запускает таймер, если он еще не выполняется.
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:Timer:stop"><apiName>stop</apiName><shortdesc>
	 Останавливает таймер.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 Останавливает таймер. Когда метод <codeph>start()</codeph> вызывается после метода <codeph>stop()</codeph>, экземпляр таймера выполняется <i>оставшееся</i> количество раз, определяемое свойством <codeph>repeatCount</codeph>.
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#Timer/reset()"><linktext>Timer.reset()</linktext></link></related-links></apiOperation><apiValue id="flash.utils:Timer:currentCount:get"><apiName>currentCount</apiName><shortdesc>
	 Общее число срабатываний таймера с момента его запуска с нуля.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Общее число срабатываний таймера с момента его запуска с нуля. Если таймер сбрасывается, учитываются только срабатывания после сброса.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:delay:get"><apiName>delay</apiName><shortdesc>
	 Задержка в миллисекундах между событиями таймера.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>Вызывает исключение, если указанная задержка является отрицательным числом или не является конечным числом.
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 Задержка в миллисекундах между событиями таймера. Если установить интервал задержки во время работы таймера, таймер будет перезапущен на текущей итерации <codeph>repeatCount</codeph>.
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:repeatCount:get"><apiName>repeatCount</apiName><shortdesc>
	 Общее число запусков, на которое настроен таймер.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 Общее число запусков, на которое настроен таймер. Если количество повторений содержит значение 0, таймер продолжает работу бесконечно, либо до вызова метода <codeph>stop()</codeph>, либо до останова программы. Если количество повторений не равно нулю, таймер запускается указанное количество раз. Если значение количества повторений <codeph>repeatCount</codeph> совпадает со значением текущей итерации <codeph>currentCount</codeph> или меньше его, таймер останавливается и не запускается снова.
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:Timer:running:get"><apiName>running</apiName><shortdesc>
     Текущее состояние таймера: если таймер выполняется, то true, в противном случае - false.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     Текущее состояние таймера: если таймер выполняется, то <codeph>true</codeph>, в противном случае - <codeph>false</codeph>.
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:CompressionAlgorithm"><apiName>CompressionAlgorithm</apiName><shortdesc>
 Класс CompressionAlgorithm определяет строковые константы для имен параметров сжатия и распаковки.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс CompressionAlgorithm определяет строковые константы для имен параметров сжатия и распаковки. Эти константы предназначены для использования в качестве значений параметра <codeph>algorithm</codeph> методов <codeph>ByteArray.compress()</codeph> и <codeph>ByteArray.uncompress()</codeph>.
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.utils.xml#ByteArray/compress()"><linktext>flash.utils.ByteArray.compress()</linktext></link><link href="flash.utils.xml#ByteArray/uncompress()"><linktext>flash.utils.ByteArray.uncompress()</linktext></link></related-links><apiValue id="flash.utils:CompressionAlgorithm:DEFLATE"><apiName>DEFLATE</apiName><shortdesc>
	 Определяет строку, которая должна использоваться для алгоритма сжатия deflate.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>deflate</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Определяет строку, которая должна использоваться для алгоритма сжатия deflate.
	 
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:CompressionAlgorithm:ZLIB"><apiName>ZLIB</apiName><shortdesc>
	Определяет строку, которая должна использоваться для алгоритма сжатия zlib.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>zlib</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	Определяет строку, которая должна использоваться для алгоритма сжатия zlib.
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.utils:IDataInput"><apiName>IDataInput</apiName><shortdesc>
В интерфейсе IDataInput предусмотрен набор методов для чтения двоичных данных.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
В интерфейсе IDataInput предусмотрен набор методов для чтения двоичных данных. В операциях ввода-вывода этот интерфейс дополняет интерфейс IDataOutput, который записывает двоичные данные.
<p>По умолчанию все операции IDataInput и IDataOutput используют порядок bigEndian (у старшего байта последовательности меньший адрес), и являются неблокирующими. Если данных недостаточно, возникает исключение <codeph>EOFError</codeph>. Для определения количества байтов, доступных для чтения, используйте свойство <codeph>IDataInput.bytesAvailable</codeph>.</p>

<p>Расширение знака имеет значение только при чтении данных, но не при их записи. Поэтому для работы с <codeph>IDataInput.readUnsignedByte()</codeph> и <codeph>IDataInput.readUnsignedShort()</codeph> не требуется создавать отдельные методы записи. Другими словами:</p>
<ul><li><codeph>IDataOutput.writeByte()</codeph> используется с <codeph>IDataInput.readUnsignedByte()</codeph> и <codeph>IDataInput.readByte()</codeph>.</li>
<li><codeph>IDataOutput.writeShort()</codeph> используется с <codeph>IDataInput.readUnsignedShort()</codeph> и <codeph>IDataInput.readShort()</codeph>.</li></ul>

</apiDesc><example conref="examples\DataInputExample.as"> В следующем примере класс <codeph>DataInputExample</codeph> используется для записи в массив байтов логического значения и представления числа «пи» с двойной точностью и плавающей запятой. Это можно сделать, выполнив следующие действия:
 <ol>
     <li>Объявляется новый экземпляр объекта ByteArray <codeph>byteArr</codeph>.</li>
     <li>Записывается эквивалент байтового логического значения <codeph>false</codeph> и эквивалент числа «пи» с двойной точностью и плавающей запятой.</li>
     <li>Считывается логическое значение и число двойной точности с плавающей запятой.</li>
 </ol>
 
 <p>Обратите внимание на то, что в конце добавляется сегмент кода для проверки ошибок конца файла. Это позволяет прекратить считывание потока байтов по достижении его окончания.</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.utils.ByteArray;
    import flash.errors.EOFError;

    public class DataInputExample extends Sprite {        
        public function DataInputExample() {
            var byteArr:ByteArray = new ByteArray();

            byteArr.writeBoolean(false);
            byteArr.writeDouble(Math.PI);
            
            byteArr.position = 0;

            try {
                trace(byteArr.readBoolean()); // false
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());    // 3.141592653589793
            } 
            catch(e:EOFError) {
                trace(e);           // EOFError: Error #2030: End of file was encountered.
            }
            
            try {
                trace(byteArr.readDouble());
            } 
            catch(e:EOFError) {
                trace(e);        // EOFError: Error #2030: End of file was encountered.
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#IDataOutput"><linktext>Интерфейс IDataOutput</linktext></link><link href="flash.utils.xml#IDataInput/endian"><linktext>endian</linktext></link><link href="flash.filesystem.xml#FileStream"><linktext>Класс FileStream</linktext></link><link href="flash.net.xml#Socket"><linktext>Класс Socket</linktext></link><link href="flash.net.xml#URLStream"><linktext>Класс URLStream</linktext></link><link href="flash.utils.xml#ByteArray"><linktext>Класс ByteArray</linktext></link><link href="flash.errors.xml#EOFError"><linktext>Класс EOFError</linktext></link></related-links><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	 Считывает логическое значение из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Логическое значение будет <codeph>true</codeph>, если количество байтов не равно нулю, в остальных случаях оно будет <codeph>false</codeph>.
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает логическое значение из потока файлов, байтов или массива байтов. Считывается один байт. Если этот байт ненулевой, то возвращается значение <codeph>true</codeph>. В противном случае возвращается значение <codeph>false</codeph>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readByte"><apiName>readByte</apiName><shortdesc>
	 Считывает байт со знаком из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от -128 до 127.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает байт со знаком из потока файлов, байтов или массива байтов.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readBytes"><apiName>readBytes</apiName><shortdesc>
	 Считывает число байтов данных, заданное параметром length, из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>Объект <codeph>ByteArray</codeph>, в который считываются данные.
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Смещение в параметре <codeph>bytes</codeph>, с которого должно начинаться считывание данных.
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Число байтов для считывания. Если значение по умолчанию равно 0, считываются все доступные данные.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Считывает число байтов данных, заданное параметром <codeph>length</codeph>, из потока файлов, байтов или массива байтов. Байты считываются в объект ByteArray, определяемый параметром <codeph>bytes</codeph>, при этом начальная позиция определяется параметром <codeph>offset</codeph>.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readDouble"><apiName>readDouble</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с двойной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число IEEE 754 с двойной точностью и плавающей запятой.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с двойной точностью и плавающей запятой.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readFloat"><apiName>readFloat</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с одинарной точностью и плавающей запятой.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Число IEEE 754 с одинарной точностью и плавающей запятой.
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов число IEEE 754 с одинарной точностью и плавающей запятой.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readInt"><apiName>readInt</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращаемое значение находится в диапазоне от -2147483648 до 2147483647.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число со знаком.
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов многобайтовую строку заданной длины с использованием заданного набора символов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>IDataInput, IDataInput.readMultiByte, readMultiByte
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8.
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число считываемых из потока байтов.
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>Строка, обозначающая набор символов, которые используются для интерпретации байтов. Возможные строки наборов символов: <codeph>"shift_jis"</codeph>, <codeph>"cn-gb"</codeph>, <codeph>"iso-8859-1"</codeph> и другие. Полный список см. в разделе <xref href="../../charset-codes.html">Поддерживаемые наборы символов</xref>. 
	 
     <p><b>Примечание.</b> Если в текущей системе не распознается значение параметра <codeph>charSet</codeph>, то в качестве набора символов <ph platform="actionscript"> Adobe<sup>®</sup> Flash<sup>®</sup> Player или </ph> Adobe<sup>®</sup> AIR<sup>®</sup> будет использована кодовая страница по умолчанию. Например, значение параметра <codeph>charSet</codeph>, как в <codeph>myTest.readMultiByte(22, iso-8859-01)</codeph>, использующее <codeph>01</codeph>вместо <codeph>1</codeph>, может работать на компьютере данного пользователя, но привести к сбою на другой рабочей станции. На другом компьютере приложение <ph platform="actionscript">Flash Player или </ph> AIR будет использовать кодовую страницу, заданную по умолчанию в системе.</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов многобайтовую строку заданной длины с использованием указанного набора символов.
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readObject"><apiName>readObject</apiName><shortdesc>
	 Считывает объект из потока файлов, байтов или массива байтов зашифрованный в сериализованном формате AMF.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Десериализованный объект
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 Считывает объект из потока файлов, байтов или массива байтов зашифрованный в сериализованном формате AMF.
	 </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#IDataInput/objectEncoding"><linktext>objectEncoding</linktext></link><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readShort"><apiName>readShort</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число со знаком.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращаемое значение находится в диапазоне от -32768 до 32767.
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число со знаком.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUTF"><apiName>readUTF</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов строку UTF-8.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8, являющаяся байтовым представлением символов.
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов строку UTF-8. Предполагается, что в строку вставляется префикс с неподписанным значением, указывающим длину в байтах.
	 
	 <p>Этот метод похож на метод <codeph>readUTF()</codeph> в интерфейсе Java<sup>®</sup> IDataInput.</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	 Считывает последовательность байтов UTF-8 из потока байтов или массива байтов и возвращает строку.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Строка в кодировке UTF-8, являющаяся байтовым представлением символов указанной длины.	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>Число байт для считывания.
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 Считывает последовательность байтов UTF-8 из потока байтов или массива байтов и возвращает строку.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	 Считывает байт без знака из потока файлов, байтов или массива байтов.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращаемое значение находится в диапазоне от 0 до 255. 	   
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает байт без знака из потока файлов, байтов или массива байтов.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от 0 до 4294967295.
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов 32-разрядное целое число без знака.
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.utils:IDataInput:flash.utils:IDataInput:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число без знака.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>Недостаточно данных, доступных для чтения.
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>Возвращенное значение находится в диапазоне от 0 до 65535. 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 Считывает из потока файлов, байтов или массива байтов 16-разрядное целое число без знака.
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	 Возвращает число байтов данных, доступных для чтения во входном буфере.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 Возвращает число байтов данных, доступных для чтения во входном буфере. В коде должен быть вызов свойства <codeph>bytesAvailable</codeph>, проверяющий доступность необходимого объема данных до того, как будет выполнена попытка их считывания с помощью одного из методов чтения.
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:endian:get"><apiName>endian</apiName><shortdesc>
	 Порядок байтов данных, константа BIG_ENDIAN или LITTLE_ENDIAN класса Endian.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 Порядок байтов данных, константа <codeph>BIG_ENDIAN</codeph> или <codeph>LITTLE_ENDIAN</codeph> класса Endian.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#Endian"><linktext>Класс Endian</linktext></link></related-links></apiValue><apiValue id="flash.utils:IDataInput:flash.utils:IDataInput:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     Указывает, какой формат, AMF3 или AMF0, используется для записи или чтения двоичных данных с помощью метода readObject().</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     Указывает, какой формат, AMF3 или AMF0, используется для записи или чтения двоичных данных с помощью метода <codeph>readObject()</codeph>. Значение представлено константой из класса ObjectEncoding.
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.utils.xml#IDataInput/readObject()"><linktext>readObject()</linktext></link><link href="flash.utils.xml#IDataOutput/writeObject()"><linktext>IDataOutput.writeObject()</linktext></link><link href="flash.net.xml#ObjectEncoding"><linktext>Класс ObjectEncoding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.utils:Dictionary"><apiName>Dictionary</apiName><shortdesc>
 Класс Dictionary позволяет создавать динамический сборник свойств, использующий для сравнения ключей строгое равенство (===).</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Класс Dictionary позволяет создавать динамический сборник свойств, использующий для сравнения ключей строгое равенство (<codeph>===</codeph>). Когда в качестве ключа используется объект, для поиска объекта используется его имя, а не значение, возвращаемое при вызове <codeph>toString()</codeph> для него. Примитивные (встроенные) объекты, например Numbers, в коллекции Dictionary ведут себя так же, как когда они являются свойством обычного объекта.
 
 <p platform="actionscript">Следующие инструкции показывают связь между объектом Dictionary и объектом key:</p>
 
 <codeblock platform="actionscript">
 var dict:Dictionary = new Dictionary();
 var obj:Object = new Object();
 var key:Object = new Object();
 key.toString = function() { return "key" }
  
 dict[key] = "Letters";
 obj["key"] = "Letters";
  
 dict[key] == "Letters"; // true
 obj["key"] == "Letters"; // true 
 obj[key] == "Letters"; // true because key == "key" is true because key.toString == "key"
 dict["key"] == "Letters"; // false because "key" === key is false
 delete dict[key]; //removes the key
 </codeblock>
 
 <p><b>Важно!</b> Класс Dictionary доступен только для кода ActionScript 3.0 (выполняемого в SWF-содержимом). Он недоступен для кода JavaScript (выполняемого в Adobe<sup>®</sup> AIR™).</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="../../operators.html#strict_equality"><linktext>=== (строгое равенство)</linktext></link></related-links><apiConstructor id="flash.utils:Dictionary:Dictionary"><apiName>Dictionary</apiName><shortdesc>
	 Создает новый объект Dictionary.</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>weakKeys</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Предписывает объекту Dictionary использовать в ключах объектов «слабые» ссылки. Если единственная ссылка на объект находится в указанном объекте Dictionary, ключ подходит для очистки и при удалении объекта удаляется из таблицы.
  	 
  	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 Создает новый объект Dictionary. Чтобы удалить ключ из объекта Dictionary, воспользуйтесь оператором <codeph>delete</codeph>.
  	 
  	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier></apiPackage>