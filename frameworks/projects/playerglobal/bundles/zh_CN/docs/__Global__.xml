<?xml version="1.0"?>
<apiPackage id="__Global__"><apiName>__Global__</apiName><apiDetail/><apiClassifier id="globalClassifier:VerifyError"><apiName>VerifyError</apiName><shortdesc>
 VerifyError 类表示一种错误，如果遇到格式不正确或损坏的 SWF 文件，则会出现该错误。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>如果遇到格式不正确或损坏的 SWF 文件，则会引发 VerifyError。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 VerifyError 类表示一种错误，如果遇到格式不正确或损坏的 SWF 文件，则会出现该错误。 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>Loader 类</linktext></link></related-links><apiConstructor id="VerifyError:VerifyError"><apiName>VerifyError</apiName><shortdesc>
	 创建一个新的 VerifyError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>包含与 VerifyError 对象关联的消息。      
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 VerifyError 对象。
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
 ArgumentError 类表示一种错误，如果函数提供的参数与为该函数定义的参数不一致，则会出现该错误。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>如果函数调用期间提供的参数值与为该函数定义的参数不匹配，则会引发 ArgumentError。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 ArgumentError 类表示一种错误，如果函数提供的参数与为该函数定义的参数不一致，则会出现该错误。例如，如果在调用函数时使用了错误的参数数目、不正确的参数类型或无效参数，则会发生此错误。
 
 </apiDesc><example conref="examples\ArgumentErrorExample.as"> 下面的示例演示 <codeph>ArgumentError</codeph> 错误是如何生成的，以及如何在 <codeph>try..catch</codeph> 语句中进行处理。<codeph>println()</codeph> 函数采用一个参数（单个字符串），但由于提供了两个字符串，因而引发该错误。通常，编译器可能会捕捉到此类错误，但 <codeph>this[]</codeph> 语法（<codeph>try</codeph> 语句中）可跳过编译器对该函数的语法检查。
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentErrorExample extends Sprite {
        public function ArgumentErrorExample() {
                println("Hello World");
                
                try {
                    this["println"]("Hello", "World");
                }
                catch(e:ArgumentError) {
                    trace(e);
                }
        }
        
        public function println(str:String):void {
            trace(str);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="ArgumentError:ArgumentError"><apiName>ArgumentError</apiName><shortdesc>
	 创建一个 ArgumentError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>与该错误关联的字符串。
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个 ArgumentError 对象。
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:QName"><apiName>QName</apiName><shortdesc>

QName 对象表示 XML 元素和属性的限定名。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>QName
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

QName 对象表示 XML 元素和属性的限定名。每个 QName 对象都具有一个本地名称和一个命名空间统一资源标识符 (URI)。命名空间 URI 的值为 <codeph>null</codeph> 时，QName 对象可与任意命名空间匹配。使用 QName 构造函数创建新的 QName 对象，该对象可以是另一个 QName 对象的副本，也可以是带有来自 Namespace 对象的 <codeph>uri</codeph> 和来自 QName 对象的 <codeph>localName</codeph> 的新 QName 对象。 
 

<p>特定于 E4X 的方法可以交替使用 QName 对象和字符串。E4X 方法位于 QName、Namespace、XML 和 XMLList 类中。这些 E4X 方法，既可以使用字符串，也可以使用 QName 对象。这种互换性说明了命名空间如何支持诸如 <codeph>XML.child()</codeph> 方法的使用。 </p>

<p>QName 类（与 XML、XMLList 和 Namespace 类一起）可实现强大的 XML 处理标准，该标准在 ECMAScript for XML (E4X) 规范（ECMA-357 第 2 版）中定义。</p>

<p>限定标识符的计算结果为 QName 对象。如果指定了 XML 元素的 QName 对象而未标识命名空间，则将关联的 QName 对象的 <codeph>uri</codeph> 属性设置为全局默认命名空间。如果指定了 XML 属性的 QName 对象而未标识命名空间，则将 <codeph>uri</codeph> 属性设置为空字符串。</p>

</apiDesc><example conref="examples\QNameExample.as"> 下面的示例说明如何创建 QName 实例，并使用它选择 XML 元素。下面说明了创建 QName 的两种方法：
 <ol>
    <li>创建 Namespace 实例，然后将其用作 QName 构造函数的输入。如果稍后要将 <codeph>Namespace.prefix</codeph> 属性用作其它目的，则此方法是最佳方法。</li>
  <li>使用 QName 构造函数中 <codeph>uri</codeph> 参数的简单字符串值创建 QName 实例。</li>
 </ol>
 <p>
 此代码将执行以下操作：
 </p>
 <ol>
  <li>定义一个 XML 变量，名为 <codeph>rssXML</codeph>。</li>
    <li>创建一个新 Namespace 对象，其前缀为 <codeph>dc</codeph>。</li>
  <li>创建新的 QName 对象，方法是使用 Namespace 对象和本地名称 <codeph>creator</codeph>。</li>
  <li>调用 <codeph>showDescendants()</codeph> 方法，该方法使用 <codeph>XML.descendants()</codeph> 方法获取一个 XMLList 实例，其中包含限定名称与给定的 QName 实例相匹配的所有后代元素。</li>
    <li>显示列表中每个元素的限定名称和文本值（使用 <codeph>for each</codeph> 循环）。</li>
  <li>使用 <codeph>uri</codeph> 参数的字符串值和局部名称 <codeph>date</codeph> 创建另一个 QName 对象。</li>
  <li>再次调用 <codeph>showDescendants()</codeph> 方法以显示后代元素的名称和文本值。</li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    
    public class QNameExample extends Sprite
    {
        public function QNameExample()
        {
            var rssXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/">
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            var dcNamespace:Namespace = new Namespace("dc", "http://purl.org/dc/elements/1.1/");
            var creatorQName:QName = new QName(dcNamespace, "creator");
            trace(creatorQName.uri); // http://purl.org/dc/elements/1.1/
            trace(creatorQName.localName); // creator
            
            showDescendants(rssXML, creatorQName);
            
            var dateQName:QName = new QName("http://purl.org/dc/elements/1.1/", "date");
            trace(dateQName.uri); // http://purl.org/dc/elements/1.1/
            trace(dateQName.localName); // date
            
            showDescendants(rssXML, dateQName);
        }
        
        public function showDescendants(xmlData:XML, qualifiedName:QName):void
        {
            var decendantList:XMLList = xmlData.descendants(qualifiedName);
            
            for each (var element:XML in decendantList)
            {
                trace(element.name()); // the fully qualified name, 
                                       // like "http://purl.org/dc/elements/1.1/::creator"
                trace(element); // the simple text value of each element, like "Adobe"
            }                
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>ECMAScript for XML (E4X) 规范（ECMA-357 第 2 版）</linktext></link></related-links><apiConstructor id="QName:QName_0"><apiName>QName</apiName><shortdesc> 
    使用 Namespace 对象中的 URI 对象和 QName 对象中的 localName 创建一个 QName 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName
    </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>将从其复制 <codeph>uri</codeph> 值的 Namespace 对象。任何其它类型的参数将转换为字符串。
    </apiDesc></apiParam><apiParam><apiItemName>localName</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>将从其复制 <codeph>localName</codeph> 值的 QName 对象。任何其它类型的参数将转换为字符串。
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    使用 Namespace 对象中的 URI 对象和 QName 对象中的 <codeph>localName</codeph> 创建一个 QName 对象。如果任一参数不是预期的数据类型，则该参数将转换为字符串并分配给新 QName 对象的相应属性。例如，如果两个参数均为字符串，则将返回 <codeph>uri</codeph> 属性设置为第一参数且 <codeph>localName</codeph> 属性设置为第二参数的新 QName 对象。换言之，使用以下数据类型以及其它数据类型的 uri 和 localName 参数组合都是构造函数的有效形式：
<pre>
QName (uri:Namespace, localName:String);
QName (uri:String, localName: QName);
QName (uri:String, localName: String);
</pre>
    <p>如果将 <codeph>null</codeph> 传递给 <codeph>uri</codeph> 参数，则新 QName 对象的 <codeph>uri</codeph> 属性将设置为 <codeph>null</codeph>。
    </p>
    <p><b>注意：</b>因为每种形式接受不同的参数，所以此类显示两个构造函数项。根据传递的参数类型和数量的不同（由每一项详细定义），此构造函数具有不同的行为。ActionScript 3.0 不支持方法或构造函数重载。</p>
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="QName:QName_1"><apiName>QName</apiName><shortdesc> 
    创建一个 QName 对象，该对象是另一个 QName 对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>(pdehaan) i changed first param from "name" to "uri" as the previous naming was very confusing
    </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>qname</apiItemName><apiOperationClassifier>QName</apiOperationClassifier><apiDesc>要复制的 QName 对象。任何其它类型的对象都将转换为指定给新 QName 对象的属性 <codeph>localName</codeph> 的字符串。
    
    </apiDesc></apiParam></apiConstructorDef><apiDesc> 
    创建一个 QName 对象，该对象是另一个 QName 对象的副本。如果传递给构造函数的参数是 QName 对象，则将创建 QName 对象的一个副本。如果该参数不是 QName 对象，则将其转换为字符串并分配给新 QName 实例的 <codeph>localName</codeph> 属性。如果参数是 <codeph>undefined</codeph> 或未指定，则将创建 <codeph>localName</codeph> 属性设置为空字符串的新 QName 对象。
    <p><b>注意：</b>因为每种形式接受不同的参数，所以此类显示两个构造函数项。根据传递的参数类型和数量的不同（由每一项详细定义），此构造函数具有不同的行为。ActionScript 3.0 不支持方法或构造函数重载。</p>
    
    
    </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="QName:AS3:toString"><apiName>toString</apiName><shortdesc>
	返回一个包含 URI 的字符串和 QName 对象的局部名称（用“::”分隔）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>限定名称为字符串。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回一个包含 URI 的字符串和 QName 对象的局部名称（用“::”分隔）。
	
	<p>格式取决于 QName 对象的 <codeph>uri</codeph> 属性：</p>
	<pre>If <codeph>uri</codeph> == "" 
		<codeph>toString</codeph> returns <codeph>localName</codeph>
	else if <codeph>uri</codeph> == null
		<codeph>toString</codeph> returns ~~::<codeph>localName</codeph> 
	else
		<codeph>toString</codeph> returns <codeph>uri</codeph>::<codeph>localName</codeph></pre>
	
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="QName:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    返回 QName 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>QName 实例的原始值。
    
    </apiDesc><apiOperationClassifier>QName</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
    返回 QName 对象。
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="QName:localName:get"><apiName>localName</apiName><shortdesc>
	QName 对象的局部名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.localName, localName
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	QName 对象的局部名称。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="QName:uri:get"><apiName>uri</apiName><shortdesc>
	QName 对象的统一资源标识符 (URI)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>QName, QName.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	QName 对象的统一资源标识符 (URI)。
 	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:EvalError"><apiName>EvalError</apiName><shortdesc>
 EvalError 类表示一种错误，如果用户代码调用 eval() 函数或试图将 new 运算符用于 Function 对象，则会出现该错误。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>如果代码试图调用 eval() 或将 new 用于 Function 对象，则会引发 EvalError。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 EvalError 类表示一种错误，如果用户代码调用 <codeph>eval()</codeph> 函数或试图将 <codeph>new</codeph> 运算符用于 Function 对象，则会出现该错误。不支持调用 <codeph>eval()</codeph> 和使用 Function 对象调用 <codeph>new</codeph>。
 
 </apiDesc></apiClassifierDetail><apiConstructor id="EvalError:EvalError"><apiName>EvalError</apiName><shortdesc>
	 创建一个新的 EvalError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>与该错误关联的字符串。     
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 EvalError 对象。
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Math"><apiName>Math</apiName><shortdesc>
 Math 类包含表示常用数学函数和值的方法和常数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math, math object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Math 类是顶级类，它包含定义常见的数学常数和函数的静态属性和方法。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Math 类包含表示常用数学函数和值的方法和常数。 
 <p>使用此类的方法和属性可以访问和处理数学常数和函数。Math 类的所有属性和方法都是静态的，而且必须使用 <codeph>Math.method(</codeph><codeph><i>parameter</i></codeph><codeph>)</codeph> 或 <codeph>Math.constant</codeph> 语法才能调用。在 ActionScript 中，使用双精度 IEEE-754 浮点数的最高精度定义常数。</p>
 <p>若干 Math 类方法使用以弧度为单位的角度测量值作为参数。在调用此方法之前，您可以使用以下等式计算弧度值，并使用计算得出的值作为参数，您还可以将等式右侧的整个部分（用以度为单位的角度测量值代替 <codeph>degrees</codeph>）作为弧度参数。</p>
 <p>要计算弧度值，请使用以下公式：</p>
 <pre>
 radians = degrees ~~ Math.PI/180
 </pre>
 <p>要由弧度计算出度，请使用以下公式：</p>
 <pre>
 degrees = radians ~~ 180/Math.PI
 </pre>
 <p>下面是将等式作为参数进行传递以计算 45° 角的正弦值的示例：</p>
 <p><codeph>Math.sin(45 ~~ Math.PI/180)</codeph> 等同于 <codeph>Math.sin(.7854)</codeph></p>
 <p><b>注意：</b>由于 CPU 或操作系统所使用的算法不同，Math 函数 acos、asin、atan、atan2、cos、exp、log、pow、sin 和 sqrt 得出的值可能会稍有不同。执行上述函数的计算时，Flash Player 将调用 CPU（或操作系统，如果 CPU 不支持浮点计算），则根据所使用的 CPU 或操作系统，其显示结果会稍有不同。
 </p>
 
 
 </apiDesc></apiClassifierDetail><apiOperation id="Math:abs"><apiName>abs</apiName><shortdesc>
  计算并返回由参数 val 指定的数字的绝对值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.abs, abs, absolute
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>指定参数的绝对值。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>已返回绝对值的数字。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回指定数字的绝对值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  计算并返回由参数 <codeph>val</codeph> 指定的数字的绝对值。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:acos"><apiName>acos</apiName><shortdesc>
  以弧度为单位计算并返回由参数 val 指定的数字的反余弦值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.acos, acos, arc cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>参数 <codeph>val</codeph> 的反余弦值。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>-1.0 到 1.0 之间的一个数字。  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>以弧度为单位返回指定数字的反余弦值。 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  以弧度为单位计算并返回由参数 <codeph>val</codeph> 指定的数字的反余弦值。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:asin"><apiName>asin</apiName><shortdesc>
  以弧度为单位计算并返回由参数 val 指定的数字的反正弦值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.asin, asin, arc sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>介于负二分之 pi 和正二分之 pi 之间的一个数字。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>-1.0 到 1.0 之间的一个数字。  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>以弧度为单位返回指定的 Number 参数的反正弦值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  以弧度为单位计算并返回由参数 <codeph>val</codeph> 指定的数字的反正弦值。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan"><apiName>atan</apiName><shortdesc>
  以弧度为单位计算并返回角度值，该角度的正切值已在参数 val 中指定。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan, atan, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>介于负二分之 pi 和正二分之 pi 之间的一个数字。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>表示角的正切值的一个数字。  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>以弧度为单位返回角度值，其正切值已由参数 val 指定。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  以弧度为单位计算并返回角度值，该角度的正切值已由参数 <codeph>val</codeph> 指定。返回值介于负二分之 pi 和正二分之 pi 之间。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:atan2"><apiName>atan2</apiName><shortdesc>
  以弧度为单位计算并返回点 y/x 的角度值，该角度从圆的 x 轴（其中，0,0 表示圆心）沿逆时针方向测量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.atan2, atan2, arc tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>一个数字。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>该点的 <i>y</i> 坐标。
  </apiDesc></apiParam><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>该点的 <i>x</i> 坐标。  
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>以弧度为单位返回点 y/x 的角度值，该角度从圆的 x 轴沿逆时针方向测量。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  以弧度为单位计算并返回点 <codeph>y</codeph>/<codeph>x</codeph> 的角度，该角度从圆的 <i>x</i> 轴（0 点在其上，0 表示圆心）沿逆时针方向测量。返回值介于正 pi 和负 pi 之间。请注意，atan2 的第一个参数始终是 <i>y</i> 坐标。
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:ceil"><apiName>ceil</apiName><shortdesc>
  返回指定数字或表达式的上限值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ceil, ceil, ceiling
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>最接近且大于等于参数 <codeph>val</codeph> 的整数。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字或表达式。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回指定数字或表达式的上限值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  返回指定数字或表达式的上限值。数字的上限值是大于等于该数字的最接近的整数。
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/floor()"><linktext>Math.floor()</linktext></link><link href="#Math/round()"><linktext>Math.round()</linktext></link></related-links></apiOperation><apiOperation id="Math:cos"><apiName>cos</apiName><shortdesc>
  以弧度为单位计算并返回指定角度的余弦值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.cos, cos, cosine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>-1.0 到 1.0 之间的一个数字。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，它表示一个以弧度为单位的角度。 
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回指定角度的余弦值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  以弧度为单位计算并返回指定角度的余弦值。要计算弧度，请参阅 Math 类的概述。
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:exp"><apiName>exp</apiName><shortdesc>
  返回自然对数的底 (e) 的 x 次幂的值，x 由参数 x 指定。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.exp, exp, exponent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc><i>e</i> 的 x 次幂，x 由参数 <codeph>val</codeph> 指定。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>指数；一个数字或表达式。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回自然对数的底 (e) 的 x 次幂的值，x 由参数 val 指定。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  返回自然对数的底 (<i>e</i>) 的 x 次幂的值，x 由参数 <codeph>x</codeph> 指定。常量 <codeph>Math.E</codeph> 可以提供 <i>e</i> 的值。
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/E"><linktext>Math.E</linktext></link></related-links></apiOperation><apiOperation id="Math:floor"><apiName>floor</apiName><shortdesc>
  返回由参数 val 指定的数字或表达式的下限值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.floor, floor
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>最接近且小于等于参数 <codeph>val</codeph> 的整数。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字或表达式。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回由参数 val 指定的数字或表达式的下限值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  返回由参数 <codeph>val</codeph> 指定的数字或表达式的下限值。下限值是小于等于指定数字或表达式的最接近的整数。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:log"><apiName>log</apiName><shortdesc>
  返回参数 val 的自然对数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log, log, logarithm
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>参数 <codeph>val</codeph> 的自然对数。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>其值大于 0 的数字或表达式。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回参数 val 的自然对数。 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  返回参数 <codeph>val</codeph> 的自然对数。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:max"><apiName>max</apiName><shortdesc>
  计算 val1 和 val2（或更多的值）并返回最大值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.max, max, maximum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>参数 <codeph>val1</codeph> 和 <codeph>val2</codeph>（或更多值）的最大值。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字或表达式。
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字或表达式。
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>一个数字或表达式。<codeph>Math.max()</codeph> 可以接受多个参数。
  </apiDesc></apiParam><apiTipTexts><apiTipText>计算参数 val1 和 val2 并返回较大值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  计算 <codeph>val1</codeph> 和 <codeph>val2</codeph>（或更多的值）并返回最大值。
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/min()"><linktext>Math.min()</linktext></link></related-links></apiOperation><apiOperation id="Math:min"><apiName>min</apiName><shortdesc>
  计算 val1 和 val2（或更多的值）并返回最小值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.min, min, minimum
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>参数 <codeph>val1</codeph> 和 <codeph>val2</codeph>（或更多值）的最小值。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val1</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字或表达式。
  </apiDesc></apiParam><apiParam><apiItemName>val2</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字或表达式。
  </apiDesc></apiParam><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>一个数字或表达式。<codeph>Math.min()</codeph> 可以接受多个参数。
  </apiDesc></apiParam><apiTipTexts><apiTipText>计算参数 val1 和 val2 并返回较小值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  计算 <codeph>val1</codeph> 和 <codeph>val2</codeph>（或更多的值）并返回最小值。
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/max()"><linktext>Math.max()</linktext></link></related-links></apiOperation><apiOperation id="Math:pow"><apiName>pow</apiName><shortdesc>
  计算并返回 base 的 pow 次幂。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pow, pow, power
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc><codeph>base</codeph> 的 <codeph>pow</codeph> 次幂的值。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>base</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>将自乘参数 <codeph>pow</codeph> 次的数字。
  </apiDesc></apiParam><apiParam><apiItemName>pow</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>指定参数 <codeph>base</codeph> 的自乘次数的数字。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回 val1 的 val2 次幂。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  计算并返回 <codeph>base</codeph> 的 <codeph>pow</codeph> 次幂。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:random"><apiName>random</apiName><shortdesc>
  返回一个伪随机数 n，其中 0 &amp;lt;= n &amp;lt; 1。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.random, random
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>一个伪随机数。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回一个伪随机数 n，其中 0 &lt;= n &lt; 1。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  返回一个伪随机数 n，其中 0 &lt;= n &lt; 1。因为该计算不可避免地包含某些非随机的成分，所以返回的数字以保密方式计算且为伪随机数。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:round"><apiName>round</apiName><shortdesc>
  将参数 val 的值向上或向下舍入为最接近的整数并返回该值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.round, round
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>参数 <codeph>val</codeph> 舍入为最近的整数。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要舍入的数字。
  </apiDesc></apiParam><apiTipTexts><apiTipText>将参数 val 向上或向下舍入为最接近的整数并返回该值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  将参数 <codeph>val</codeph> 的值向上或向下舍入为最接近的整数并返回该值。如果 <codeph>val</codeph> 与最接近的两个整数等距离（即该数字以 .5 结尾），则该值向上舍入为下一个较大的整数。
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/ceil()"><linktext>Math.ceil()</linktext></link><link href="#Math/floor()"><linktext>Math.floor()</linktext></link></related-links></apiOperation><apiOperation id="Math:sin"><apiName>sin</apiName><shortdesc>
  以弧度为单位计算并返回指定角度的正弦值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sin, sin, sine
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>一个数字；指定角度的正弦值（介于 -1.0 和 1.0 之间）。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，它表示一个以弧度为单位的角度。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回指定角度的正弦值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  以弧度为单位计算并返回指定角度的正弦值。要计算弧度，请参阅 Math 类的概述。
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/tan()"><linktext>Math.tan()</linktext></link></related-links></apiOperation><apiOperation id="Math:sqrt"><apiName>sqrt</apiName><shortdesc>
  计算并返回指定数字的平方根。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt, sqrt, square root 
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>如果参数 <codeph>val</codeph> 大于等于 0，则为一个数字，否则为 <codeph>NaN</codeph>（非数字）。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个大于等于 0 的数字或表达式。 
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回指定数字的平方根。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  计算并返回指定数字的平方根。
  
  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Math:tan"><apiName>tan</apiName><shortdesc>
  计算并返回指定角度的正切值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.tan, tan, tangent
   
   </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>参数 <codeph>angleRadians</codeph> 的正切值。
  
  </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>angleRadians</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，它表示一个以弧度为单位的角度。
  </apiDesc></apiParam><apiTipTexts><apiTipText>返回指定角度的正切值。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  计算并返回指定角度的正切值。要计算弧度，请参阅 Math 类的概述。
  
  
  </apiDesc></apiOperationDetail><related-links><link href="#Math/acos()"><linktext>Math.acos()</linktext></link><link href="#Math/asin()"><linktext>Math.asin()</linktext></link><link href="#Math/atan()"><linktext>Math.atan()</linktext></link><link href="#Math/atan2()"><linktext>Math.atan2()</linktext></link><link href="#Math/cos()"><linktext>Math.cos()</linktext></link><link href="#Math/sin()"><linktext>Math.sin()</linktext></link></related-links></apiOperation><apiValue id="Math:E"><apiName>E</apiName><shortdesc>
  自然对数的底的数学常数，表示为 e。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.e, e
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.71828182845905</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>自然对数的底的数学常数，表示为 e。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  代表自然对数的底的数学常数，表示为 <i>e</i>。<i>e</i><codeph> </codeph> 的近似值为 2.71828182845905。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN10"><apiName>LN10</apiName><shortdesc>
  10 的自然对数的数学常数，表示为 loge10，其近似值为 2.302585092994046。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln10, ln10, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2.302585092994046</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>10 的自然对数的数学常数，表示为 loge10，其近似值为 2.302585092994046。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  10 的自然对数的数学常数，表示为 log<sub>e</sub>10，其近似值为 2.302585092994046。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LN2"><apiName>LN2</apiName><shortdesc>
  2 的自然对数的数学常数，表示为 loge2，其近似值为 0.6931471805599453。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.ln2, ln2, natural logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.6931471805599453</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>2 的自然对数的数学常数，表示为 loge2，其近似值为 0.6931471805599453。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  2 的自然对数的数学常数，表示为 log<sub>e</sub>2，其近似值为 0.6931471805599453。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG10E"><apiName>LOG10E</apiName><shortdesc>
  代表常数 e (Math.E) 以 10 为底的对数的数学常数，表示为 log10e，其近似值为 0.4342944819032518。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log10e, log10e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.4342944819032518</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>常数 e 以 10 为底的对数的数学常数，表示为 log10e，其近似值为 0.4342944819032518。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  常数 <i>e</i> (<codeph>Math.E</codeph>) 以 10 为底的对数的数学常数，表示为 log<sub>10</sub>e，其近似值为 0.4342944819032518。 
  <p><codeph>Math.log()</codeph> 方法计算数字的自然对数。将 <codeph>Math.log()</codeph> 的结果与 <codeph>Math.LOG10E</codeph> 相乘得到以 10 为底的对数。</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:LOG2E"><apiName>LOG2E</apiName><shortdesc>
  常数 e 以 2 为底的对数的数学常数，表示为 log2e，其近似值为 1.442695040888963387。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.log2e, log2e, logarithm
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.442695040888963387</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>常数 e 以 2 为底的对数的数学常数，表示为 log2e，其近似值为 1.442695040888963387。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  常数 <i>e</i> 以 2 为底的对数的数学常数，表示为 log2e，其近似值为 1.442695040888963387。
  
  <p><codeph>Math.log</codeph> 方法计算数字的自然对数。将 <codeph>Math.log()</codeph> 的结果与 <codeph>Math.LOG2E</codeph> 相乘得到以 2 为底的对数。</p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:PI"><apiName>PI</apiName><shortdesc>
  代表一个圆的周长与其直径的比值的数学常数，表示为 pi，其近似值为 3.141592653589793。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.pi, pi
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3.141592653589793</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>代表一个圆的周长与其直径的比值的数学常数，表示为 pi，其近似值为 3.141592653589793。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  代表一个圆的周长与其直径的比值的数学常数，表示为 pi，其近似值为 3.141592653589793。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT1_2"><apiName>SQRT1_2</apiName><shortdesc> 
  代表 1/2 的平方根的数学常数，其近似值为 0.7071067811865476。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt1_2, sqrt1_2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0.7071067811865476</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>代表 1/2 的平方根的数学常数，其近似值为 0.7071067811865476。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
  代表 1/2 的平方根的数学常数，其近似值为 0.7071067811865476。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Math:SQRT2"><apiName>SQRT2</apiName><shortdesc>
  代表 2 的平方根的数学常数，其近似值为 1.4142135623730951。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>math.sqrt2, sqrt2, square root
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1.4142135623730951</apiData><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>代表 2 的平方根的数学常数，其近似值为 1.4142135623730951。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  代表 2 的平方根的数学常数，其近似值为 1.4142135623730951。
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Array"><apiName>Array</apiName><shortdesc>
 使用 Array 类可以访问和操作数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Array, Array object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>使用该对象可以访问和操作索引数组。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 Array 类可以访问和操作数组。Array 索引从零开始，这意味着数组中的第一个元素为 <codeph>[0]</codeph>，第二个元素为 <codeph>[1]</codeph>，依此类推。要创建 Array 对象，可以使用 <codeph>new Array()</codeph> 构造函数。<codeph>Array()</codeph> 还可以作为函数调用。此外，还可以使用数组访问 (<codeph>[]</codeph>) 运算符初始化数组或访问数组元素。 
 <p>您可以在数组元素中存储各种各样的数据类型，包括数字、字符串、对象甚至是其它数组。您可以创建一个<i>多维</i> 数组，方法是创建一个索引数组，然后给它的每个元素分配不同的索引数组。这样的数组被视为是多维的，原因是它可用于表示表中的数据。</p>
 <p> 数组是<i>稀疏数组</i>，这意味着可能存在这样的情况：在索引 0 处有一个元素，在索引 5 处有另一个元素，而这两个元素之间的索引位置却是空的。在这种情况下，位置 1 至位置 4 的元素是未定义的，表示这些位置不存在元素，而不一定存在值为 <codeph>undefined</codeph> 的元素。</p>
 
 <p>数组赋值是通过引用而不是通过值进行的。如果将一个数组变量赋值给另一个数组变量，则这两个变量引用同一个数组：</p>
 <codeblock>
 var oneArray:Array = new Array("a", "b", "c");
 var twoArray:Array = oneArray; // Both array variables refer to the same array.
 twoArray[0] = "z";             
 trace(oneArray);               // Output: z,b,c.
 </codeblock>
 <p>请不要使用 Array 类创建<i>关联数组</i>（也称为<i>哈希</i>），关联数组是包含命名元素而不包含编号元素的数据结构。要创建关联数组，请使用 Object 类。虽然 ActionScript 允许使用 Array 类创建关联数组，但不能对关联数组使用 Array 类的任何方法或属性。 </p>
 <p>可以扩展 Array 类并覆盖或添加方法。但是，必须将子类指定为 <codeph>dynamic</codeph>，否则将无法在数组中存储数据。</p>
 
 </apiDesc><example conref="examples\ArrayExample.as"> 下面的示例创建一个新的 Array 对象 <codeph>myArr</codeph>，该对象没有参数且初始长度为 0：
<codeblock>
package {
    import flash.display.Sprite;

    public class ArrayExample extends Sprite {
        public function ArrayExample() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] (array access)</linktext></link><link href="#Object"><linktext>Object 类</linktext></link></related-links><apiConstructor id="Array:Array_0"><apiName>Array</apiName><shortdesc>
	 允许创建指定元素数量的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>该参数不是大于等于 0 的整数。	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>numElements</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>一个指定数组中元素数量的整数。
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 允许创建指定元素数量的数组。如果不指定任何参数，则创建包含 0 个元素的数组。如果指定多个元素，则创建包含 <codeph>numElements</codeph> 个元素的数组。 
     <p><b>注意：</b>此类显示了两个构造函数方法项，这是因为此构造函数接受的参数的类型和数量可变。根据传递的参数类型和数量的不同（由每一项详细定义），此构造函数具有不同的行为。ActionScript 3.0 不支持方法或构造函数重载。</p>
     
	 
	 </apiDesc><example conref="examples\Array_Array.as"> 下面的示例创建 Array 对象 <codeph>myArr</codeph>，该对象没有参数且初始长度为 0：
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array extends Sprite {

        public function Array_Array() {
            var myArr:Array = new Array();
            trace(myArr.length); // 0
        }
    }
}
</codeblock></example><example conref="examples\Array_Array_2.as"> 下例创建一个 Array 对象，该对象包含 5 个初始元素，长度为 5，并用字符串 <codeph>"one"</codeph> 填充第一个元素，然后将字符串元素 <codeph>"six"</codeph> 添加到数组的末尾（使用 <codeph>push()</codeph> 方法）：
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_2 extends Sprite {

        public function Array_Array_2() {
            var myArr:Array = new Array(5);
            trace(myArr.length); // 5
            myArr[0] = "one";
            myArr.push("six");
            trace(myArr);         // one,,,,,six
            trace(myArr.length); // 6
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[] array access</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiConstructor id="Array:Array_1"><apiName>Array</apiName><shortdesc>
	 允许创建包含指定元素的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>该参数不是大于等于 0 的整数。	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>一个以逗号分隔的列表，包含一个或多个任意值。 
	 <p><b>注意：</b>如果传递给 Array 构造函数的只有一个单数值参数，则认为该参数指定数组的 <codeph>length</codeph> 属性。</p>
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 允许创建包含指定元素的数组。您可以指定任何类型的值。数组中第一个元素的索引（或位置）始终为 0。
     <p><b>注意：</b>此类显示了两个构造函数项，这是因为此构造函数接受的参数的类型和数量可变。根据传递的参数类型和数量的不同（由每一项详细定义），此构造函数具有不同的行为。ActionScript 3.0 不支持方法或构造函数重载。</p>
	 </apiDesc><example conref="examples\Array_Array_3.as"> 下例创建一个新的 Array 对象，该对象初始长度为 3，并用字符串元素 <codeph>one</codeph>、<codeph>two</codeph> 和 <codeph>three</codeph> 填充数组，然后将这些元素转换为字符串。
<codeblock>
package {
    import flash.display.Sprite;

    public class Array_Array_3 extends Sprite {

        public function Array_Array_3() {
            var myArr:Array = new Array("one", "two", "three");
            trace(myArr.length); // 3
            trace(myArr);          // one,two,three
        }
    }
}
</codeblock></example></apiConstructorDetail><related-links><link href="operators.html#array_access"><linktext>[] array access</linktext></link><link href="#Array/length"><linktext>Array.length</linktext></link></related-links></apiConstructor><apiOperation id="Array:AS3:concat"><apiName>concat</apiName><shortdesc>
	 将参数中指定的元素与数组中的元素连接，并创建新的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个数组，其中包含此数组中的元素，后跟参数中的元素。
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>要连接到新数组中的任意数据类型的值（如数字、元素或字符串）。如果未传递任何值，则新数组将是原始数组的副本。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>连接参数中指定的元素。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将参数中指定的元素与数组中的元素连接，并创建新的数组。如果这些参数指定了一个数组，将连接该数组中的元素。 
 	 
 	 </apiDesc><example conref="examples\Array.concat.1.as"> 以下代码创建四个 Array 对象：
 <ul>
   <li>包含数字 <codeph>1</codeph>、<codeph>2</codeph> 和 <codeph>3</codeph> 的 <codeph>numbers</codeph> 数组。 </li>
   <li>包含字母 <codeph>a</codeph>、<codeph>b</codeph> 和 <codeph>c</codeph> 的 <codeph>letters</codeph> 数组。 </li>
   <li>调用 <codeph>concat()</codeph> 方法生成数组 <codeph>[1,2,3,a,b,c]</codeph> 的 <codeph>numbersAndLetters</codeph> 数组。 </li>
   <li>调用 <codeph>concat()</codeph> 方法生成数组 <codeph>[a,b,c,1,2,3]</codeph> 的 <codeph>lettersAndNumbers</codeph> 数组。 </li>
 </ul>
<codeblock>

var numbers:Array = new Array(1, 2, 3);
var letters:Array = new Array("a", "b", "c");
var numbersAndLetters:Array = numbers.concat(letters);
var lettersAndNumbers:Array = letters.concat(numbers);

trace(numbers);       // 1,2,3
trace(letters);       // a,b,c
trace(numbersAndLetters); // 1,2,3,a,b,c
trace(lettersAndNumbers); // a,b,c,1,2,3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:every"><apiName>every</apiName><shortdesc>
	 对数组中的每一项执行测试函数，直到获得对指定的函数返回 false 的项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果数组中的所有项对指定的函数都返回 <codeph>true</codeph>，则为布尔值 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对数组中的每一项运行的函数。该函数可以包含简单的比较操作（例如，<codeph>item &lt; 20</codeph>）或者更复杂的操作，并用三个参数来调用，即项值、项索引和 Array 对象：
     <pre>function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>用作函数的 <codeph>this</codeph> 的对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 对数组中的每一项执行测试函数，直到获得对指定的函数返回 <codeph>false</codeph> 的项。使用此方法可确定数组中的所有项是否满足某一条件，如具有的值小于某一特定数值。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。假设在影片剪辑中创建了一个名为 <codeph>me</codeph> 的函数：</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">假设对名为 <codeph>myArray</codeph> 的数组使用 <codeph>every()</codeph> 方法：</p>
     <pre product="flash">
     myArray.every(myFunction, me);
     </pre>
     <p product="flash">由于 <codeph>myFunction</codeph> 是 Timeline 类的成员，不能被 <codeph>me</codeph> 覆盖，因此 Flash Player 将引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
     };
     myArray.every(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array_every.as"> 下面的示例测试两个数组，以确定每个数组中的每一项是否都是数字。还输出了测试结果，说明对于第一个数组，<codeph>isNumeric</codeph> 是 <codeph>true</codeph>，对于第二个数组则是 <codeph>false</codeph>：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_every extends Sprite {
        public function Array_every() {
            var arr1:Array = new Array(1, 2, 4);
            var res1:Boolean = arr1.every(isNumeric);
            trace("isNumeric:", res1); // true
 
            var arr2:Array = new Array(1, 2, "ham");
            var res2:Boolean = arr2.every(isNumeric);
            trace("isNumeric:", res2); // false
        }
        private function isNumeric(element:*, index:int, arr:Array):Boolean {
            return (element is Number);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/some()"><linktext>Array.some()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:filter"><apiName>filter</apiName><shortdesc>
	 对数组中的每一项执行测试函数，并构造一个新数组，其中的所有项都对指定的函数返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个新数组，它包含原始数组中返回 <codeph>true</codeph> 的所有项。
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对数组中的每一项运行的函数。该函数可以包含简单的比较操作（例如，<codeph>item &lt; 20</codeph>）或者更复杂的操作，并用三个参数来调用，即项值、项索引和 Array 对象：
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>用作函数的 <codeph>this</codeph> 的对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 对数组中的每一项执行测试函数，并构造一个新数组，其中的所有项都对指定的函数返回 <codeph>true</codeph>。如果某项返回 <codeph>false</codeph>，则新数组中将不包含此项。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。假设在影片剪辑中创建了一个名为 <codeph>me</codeph> 的函数：</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">然后对名为 <codeph>myArray</codeph> 的数组使用 <codeph>filter()</codeph> 方法：</p>
     <pre product="flash"> 
     myArray.filter(myFunction, me);
     </pre>
     <p product="flash">由于 <codeph>myFunction</codeph> 是 Timeline 类的成员，不能被 <codeph>me</codeph> 覆盖，因此 Flash Player 将引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.filter(myFunction, me);
     </pre>
     
	 </apiDesc><example conref="examples\Array.filter.as"> 下面的示例创建一个数组，其中包括职务为经理的所有员工：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_filter extends Sprite {
        public function Array_filter() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace("Employees:");
            employees.forEach(traceEmployee);
            
            var managers:Array = employees.filter(isManager);
            trace("Managers:");
            managers.forEach(traceEmployee);
        }
        private function isManager(element:*, index:int, arr:Array):Boolean {
            return (element.manager == true);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace("\t" + element.name + ((element.manager) ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/map()"><linktext>Array.map()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:forEach"><apiName>forEach</apiName><shortdesc>
	 对数组中的每一项执行函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对数组中的每一项运行的函数。此函数可以包含简单的命令（如 <codeph>trace()</codeph> 语句）或者更复杂的操作，并用三个参数来调用，即项值、项索引和 Array 对象：
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>用作函数的 <codeph>this</codeph> 的对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 对数组中的每一项执行函数。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。假设在影片剪辑中创建了一个名为 <codeph>me</codeph> 的函数：</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">假设对名为 <codeph>myArray</codeph> 的数组使用 <codeph>forEach()</codeph> 方法：</p>
     <pre product="flash">
     myArray.forEach(myFunction, me);
     </pre>
     <p product="flash">由于 <codeph>myFunction</codeph> 是 Timeline 类的成员，不能被 <codeph>me</codeph> 覆盖，因此 Flash Player 将引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.forEach(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_forEach.as"> 下面的示例对数组中的每一项运行 <codeph>traceEmployee()</codeph> 函数中的 <codeph>trace()</codeph> 语句：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach extends Sprite {
        public function Array_forEach() {
            var employees:Array = new Array();
            employees.push({name:"Employee 1", manager:false});
            employees.push({name:"Employee 2", manager:true});
            employees.push({name:"Employee 3", manager:false});
            trace(employees);
            employees.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:int, arr:Array):void {
            trace(element.name + " (" + element.manager + ")");
        }
    }
}
</codeblock></example><example conref="examples\Array_forEach_2.as"> 下面的示例也对数组中的每一项运行略有变化的 <codeph>traceEmployee()</codeph> 函数中的 <codeph>trace()</codeph> 语句：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_forEach_2 extends Sprite {
        public function Array_forEach_2() {
            var employeeXML:XML = &lt;employees>
                    &lt;employee name="Steven" manager="false" />
                    &lt;employee name="Bruce" manager="true" />
                    &lt;employee name="Rob" manager="false" />
                &lt;/employees>;
            var employeesList:XMLList = employeeXML.employee;
            var employeesArray:Array = new Array();
            for each (var tempXML:XML in employeesList) {
                employeesArray.push(tempXML);
            }
            employeesArray.sortOn("@name");
            employeesArray.forEach(traceEmployee);
        }
        private function traceEmployee(element:*, index:Number, arr:Array):void {
            trace(element.@name + ((element.@manager == "true") ? " (manager)" : ""));
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 使用全等运算符 (===) 搜索数组中的项，并返回该项的索引位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>数组项的索引位置（从 0 开始）。如果未找到 <codeph>searchElement</codeph> 参数，则返回值为 -1。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>要在数组中查找的项。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>数组中的位置，从该位置开始搜索项。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用全等运算符 (<codeph>===</codeph>) 搜索数组中的项，并返回项的索引位置。
	 </apiDesc><example conref="examples\Array_indexOf.as"> 下面的示例显示指定数组的位置：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_indexOf extends Sprite {
        public function Array_indexOf() {
            var arr:Array = new Array(123,45,6789);
            arr.push("123-45-6789");
            arr.push("987-65-4321");
            
            var index:int = arr.indexOf("123");
            trace(index); // -1
            
            var index2:int = arr.indexOf(123);
            trace(index2); // 0
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/lastIndexOf()"><linktext>Array.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:join"><apiName>join</apiName><shortdesc>
	 将数组中的元素转换为字符串、在元素间插入指定的分隔符、连接这些元素然后返回结果字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.join, join
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个字符串，由转换为字符串并由指定参数分隔的数组元素组成。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>在返回字符串中分隔数组元素的字符或字符串。如果省略此参数，则使用逗号作为默认分隔符。 
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>将数组中的元素转换为字符串。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将数组中的元素转换为字符串、在元素间插入指定的分隔符、连接这些元素然后返回结果字符串。嵌套数组总是以逗号 (,) 分隔，而不使用传递给 <codeph>join()</codeph> 方法的分隔符分隔。
	 
	 </apiDesc><example conref="examples\Array.join.1.as"> 下面的代码创建一个 Array 对象 <codeph>myArr</codeph>，其中包含元素 <codeph>one</codeph>、<codeph>two</codeph> 和 <codeph>three</codeph>，然后创建一个包含 <codeph>one and two and three</codeph> 的字符串（使用 <codeph>join()</codeph> 方法）。
<codeblock>

var myArr:Array = new Array("one", "two", "three");
var myStr:String = myArr.join(" and ");
trace(myArr); // one,two,three
trace(myStr); // one and two and three
</codeblock></example><example conref="examples\Array.join.2.as"> 下面的代码创建一个 Array 对象 <codeph>specialChars</codeph>，其中包含元素 <codeph>(</codeph>、<codeph>)</codeph>、<codeph>-</codeph> 和一个空格，然后创建一个字符串，其中包含 <codeph>(888) 867-5309</codeph>。然后使用 <codeph>for</codeph> 循环，删除 <codeph>specialChars</codeph> 中列出的每种类型的特殊字符，以生成一个字符串 (<codeph>myStr</codeph>)，该字符串中仅包含剩余的电话号码数字：<codeph>888675309</codeph>。请注意，其它字符（如 <codeph>+</codeph>）可能已添加到 <codeph>specialChars</codeph> 中，然后此例程可处理国际电话号码格式。
<codeblock>

var phoneString:String = "(888) 867-5309";

var specialChars:Array = new Array("(", ")", "-", " ");
var myStr:String = phoneString;

var ln:uint = specialChars.length;
for(var i:uint; i &lt; ln; i++) {
    myStr = myStr.split(specialChars[i]).join("");
}

var phoneNumber:Number = new Number(myStr);

trace(phoneString); // (888) 867-5309
trace(phoneNumber); // 8888675309
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 使用全等运算符 (===) 搜索数组中的项（从最后一项开始向前搜索），并返回匹配项的索引位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>数组项的索引位置（从 0 开始）。如果未找到 <codeph>searchElement</codeph> 参数，则返回值为 -1。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value=""/><apiDesc>要在数组中查找的项。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>数组中的位置，从该位置开始搜索项。默认为允许的最大索引值。如果不指定 <codeph>fromIndex</codeph>，将从数组中的最后一项开始进行搜索。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 搜索数组中的项（从最后一项开始向前搜索），并使用全等运算符 (<codeph>===</codeph>) 返回匹配项的索引位置。
	 </apiDesc><example conref="examples\Array_lastIndexOf.as"> 下面的示例显示指定数组的位置：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_lastIndexOf extends Sprite {
        public function Array_lastIndexOf() {
            var arr:Array = new Array(123,45,6789,123,984,323,123,32);
            
            var index:int = arr.indexOf(123);
            trace(index); // 0
            
            var index2:int = arr.lastIndexOf(123);
            trace(index2); // 6
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/indexOf()"><linktext>Array.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>=== (strict equality)</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:map"><apiName>map</apiName><shortdesc>
     对数组中的每一项执行函数并构造一个新数组，其中包含与原始数组中的每一项的函数结果相对应的项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个新数组，其中包含此函数对原始数组中每一项的执行结果。
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对数组中的每一项运行的函数。此函数可以包含简单的命令（如更改字符串数组的大小写）或更复杂的操作，并用 3 个参数来调用，即项值、项索引和 Array 对象：
     <pre>    function callback(item:*, index:int, array:Array):void;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>用作函数的 <codeph>this</codeph> 的对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     对数组中的每一项执行函数并构造一个新数组，其中包含与原始数组中的每一项的函数结果相对应的项。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。假设在影片剪辑中创建了一个名为 <codeph>me</codeph> 的函数：</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">假设对名为 <codeph>myArray</codeph> 的数组使用 <codeph>map()</codeph> 方法：</p>
     <pre product="flash">
     myArray.map(myFunction, me);
     </pre>
     <p product="flash">由于 <codeph>myFunction</codeph> 是 Timeline 类的成员，不能被 <codeph>me</codeph> 覆盖，因此 Flash Player 将引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.map(myFunction, me);
     </pre>
	 </apiDesc><example conref="examples\Array_map.as"> 下面的示例将数组中的所有项更改为使用大写字母：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_map extends Sprite {
        public function Array_map() {
            var arr:Array = new Array("one", "two", "Three");
            trace(arr); // one,two,Three

            var upperArr:Array = arr.map(toUpper);
            trace(upperArr); // ONE,TWO,THREE
        }
        private function toUpper(element:*, index:int, arr:Array):String {
            return String(element).toUpperCase();
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/filter()"><linktext>Array.filter()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:pop"><apiName>pop</apiName><shortdesc>
	  删除数组中最后一个元素，并返回该元素的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.pop, pop
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>指定的数组中最后一个元素（可以为任意数据类型）的值。
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	  删除数组中最后一个元素，并返回该元素的值。
	 
	 </apiDesc><example conref="examples\Array.pop.1.as"> 下面的代码创建一个 Array 对象 <codeph>letters</codeph>，其中包含元素 <codeph>a</codeph>、<codeph>b</codeph> 和 <codeph>c</codeph>。然后使用 <codeph>pop()</codeph> 方法将最后一个元素 (<codeph>c</codeph>) 从数组中删除，并将该元素分配给 String 对象 <codeph>letter</codeph>。
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
var letter:String = letters.pop();
trace(letters); // a,b
trace(letter);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:push"><apiName>push</apiName><shortdesc>
	 将一个或多个元素添加到数组的结尾，并返回该数组的新长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.push, push
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个表示新数组长度的整数。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>要追加到数组中的一个或多个值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将一个或多个元素添加到数组的结尾，并返回该数组的新长度。
	 
	 </apiDesc><example conref="examples\Array.push.1.as"> 下面的代码创建一个空的 Array 对象 <codeph>letters</codeph>，然后用如下元素填充数组：<codeph>a</codeph>、<codeph>b</codeph> 和 <codeph>c</codeph>（使用 <codeph>push()</codeph> 方法）。
<codeblock>

var letters:Array = new Array();

letters.push("a");
letters.push("b");
letters.push("c");

trace(letters.toString()); // a,b,c
</codeblock></example><example conref="examples\Array.push.2.as"> 下面的代码创建一个 Array 对象 <codeph>letters</codeph>，最初用以下元素填充：<codeph>a</codeph>。然后，使用一次 <codeph>push()</codeph> 方法将元素 <codeph>b</codeph> 和 <codeph>c</codeph> 添加到数组的末尾，使用 push 方法后数组中就有了 3 个元素。
<codeblock>

var letters:Array = new Array("a");
var count:uint = letters.push("b", "c");

trace(letters); // a,b,c
trace(count);   // 3
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:reverse"><apiName>reverse</apiName><shortdesc>
	  在当前位置倒转数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.reverse, reverse
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新数组。
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  在当前位置倒转数组。
	 
	 </apiDesc><example conref="examples\Array.reverse.1.as"> 下面的代码创建一个 Array 对象 <codeph>letters</codeph>，其中包含元素 <codeph>a</codeph>、<codeph>b</codeph> 和 <codeph>c</codeph>。然后逆转数组元素的顺序（使用 <codeph>reverse()</codeph> 方法）以生成数组 <codeph>[c,b,a]</codeph>。
<codeblock>

var letters:Array = new Array("a", "b", "c");
trace(letters); // a,b,c
letters.reverse();
trace(letters); // c,b,a
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:shift"><apiName>shift</apiName><shortdesc>
	 删除数组中第一个元素，并返回该元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.shift, shift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>数组中的第一个元素（可以是任意数据类型）。
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	 删除数组中第一个元素，并返回该元素。其余数组元素将从其原始位置 i 移至 i-1。
	 
	 </apiDesc><example conref="examples\Array.shift.1.as"> 下面的代码创建 Array 对象 <codeph>letters</codeph>，其中包含元素 <codeph>a</codeph>、<codeph>b</codeph> 和 <codeph>c</codeph>。然后，使用 <codeph>shift()</codeph> 方法将第一个元素 (<codeph>a</codeph>) 从 <codeph>letters</codeph> 中删除，并将其分配给字符串 <codeph>firstLetter</codeph>。
<codeblock>

var letters:Array = new Array("a", "b", "c");
var firstLetter:String = letters.shift();
trace(letters);     // b,c
trace(firstLetter); // a
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/unshift()"><linktext>Array.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:slice"><apiName>slice</apiName><shortdesc>
	 返回由原始数组中某一范围的元素构成的新数组，而不修改原始数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个数组，由原始数组中某一范围的元素组成。
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>一个数字，指定片段起始点的索引。如果 <codeph>startIndex</codeph> 是负数，则起始点从数组的结尾开始，其中 -1 指的是最后一个元素。	
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>一个数字，指定片段终点的索引。如果省略此参数，则片段包括数组中从开头到结尾的所有元素。如果 <codeph>endIndex</codeph> 是负数，则终点从数组的结尾指定，其中 -1 指的是最后一个元素。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回一个新数组，其中包括原始数组中某一范围的元素。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回由原始数组中某一范围的元素构成的新数组，而不修改原始数组。返回的数组包括 <codeph>startIndex</codeph> 元素以及从其开始到 <codeph>endIndex</codeph> 元素（但不包括该元素）的所有元素。 
	 <p>如果您没有传递任何参数，则创建原始数组的一个副本。</p>
	 
	 </apiDesc><example conref="examples\Array.slice.1.as"> 下面的代码创建一个 Array 对象 <codeph>letters</codeph>，其中包含元素 <codeph>[a,b,c,d,e,f]</codeph>。然后创建数组 <codeph>someLetters</codeph>，方法是调用 <codeph>slice()</codeph> 方法（对元素 1 (<codeph>b</codeph>) 至元素 3 (<codeph>d</codeph>)），从而得到一个数组，其中包含元素 <codeph>b</codeph> 和 <codeph>c</codeph>。
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(1,3);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // b,c
</codeblock></example><example conref="examples\Array.slice.2.as"> 下面的代码创建一个 Array 对象 <codeph>letters</codeph>，其中包含元素 <codeph>[a,b,c,d,e,f]</codeph>。然后创建数组 <codeph>someLetters</codeph>，方法是调用 <codeph>slice()</codeph> 方法（对元素 2 (<codeph>c</codeph>)），从而得到一个数组，其中包含元素 <codeph>[c,d,e,f]</codeph>。
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // c,d,e,f
</codeblock></example><example conref="examples\Array.slice.3.as"> 下面的代码创建一个 Array 对象 <codeph>letters</codeph>，其中包含元素 <codeph>[a,b,c,d,e,f]</codeph>。然后创建数组 <codeph>someLetters</codeph>，方法是调用 <codeph>slice()</codeph> 方法（对倒数第二个元素 (<codeph>e</codeph>)），从而得到一个数组，其中包含元素 <codeph>e</codeph> 和 <codeph>f</codeph>。
<codeblock>

var letters:Array = new Array("a", "b", "c", "d", "e", "f");
var someLetters:Array = letters.slice(-2);

trace(letters);     // a,b,c,d,e,f
trace(someLetters); // e,f
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:AS3:some"><apiName>some</apiName><shortdesc>
     对数组中的每一项执行测试函数，直到获得返回 true 的项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果数组中的所有项对于指定的函数都返回 <codeph>true</codeph>，则为布尔值 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对数组中的每一项运行的函数。此函数可以包含简单的比较操作（如 <codeph>item &lt; 20</codeph>）或者更复杂的操作，并用三个参数来调用，即项值、项索引和 Array 对象：
     <pre>    function callback(item:*, index:int, array:Array):Boolean;</pre> 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiType value=""/><apiData>null</apiData><apiDesc>用作函数的 <codeph>this</codeph> 的对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     对数组中的每一项执行测试函数，直到获得返回 <codeph>true</codeph> 的项。使用此方法确定数组中的所有项是否满足条件，如具有小于某一特定数值的值。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。假设在影片剪辑中创建了一个名为 <codeph>me</codeph> 的函数：</p>
     <pre product="flash">
     function myFunction(obj:Object):void {
        //your code here
     }
     </pre>
     <p product="flash">假设对名为 <codeph>myArray</codeph> 的数组使用 <codeph>some()</codeph> 方法：</p>
     <pre product="flash">
     myArray.some(myFunction, me);
     </pre>
     <p product="flash">由于 <codeph>myFunction</codeph> 是 Timeline 类的成员，不能被 <codeph>me</codeph> 覆盖，因此 Flash Player 将引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
     <pre product="flash">
     var myFunction:Function = function(obj:Object):void {
         //your code here
         };
     myArray.some(myFunction, me);
     </pre>   
	 </apiDesc><example conref="examples\Array_some.as"> 下面的示例显示未定义的值：
<codeblock>
package {
    import flash.display.Sprite;
    public class Array_some extends Sprite {
        public function Array_some() {
            var arr:Array = new Array();
            arr[0] = "one";
            arr[1] = "two";
            arr[3] = "four";
            var isUndef:Boolean = arr.some(isUndefined);
            if (isUndef) {
                trace("array contains undefined values: " + arr);
            } else {
                trace("array contains no undefined values.");
            }
        }
        private function isUndefined(element:*, index:int, arr:Array):Boolean {
            return (element == undefined);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Array/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sort"><apiName>sort</apiName><shortdesc>
	 对数组中的元素进行排序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sort, sort
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>返回值取决于您是否传递任何参数，如以下列表中所述：
	 <ul>
	   <li>如果为 <codeph>...args</codeph> 参数的 <codeph>sortOptions</codeph> 变量指定值 4 或 <codeph>Array.UNIQUESORT</codeph>，并且所排序的两个或更多个元素具有相同的排序字段，则 Flash 返回值 0 并且不修改数组。 </li>
  	   <li>如果为 <codeph>...args</codeph> 参数的 <codeph>sortOptions</codeph> 变量指定值 8 或 <codeph>Array.RETURNINDEXEDARRAY</codeph>，则 Flash 返回排序后的索引数值数组以反映排序结果，并且不修改数组。 </li>
	   <li>否则，Flash 不返回任何内容并修改该数组以反映排序顺序。</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>指定一个比较函数和确定排序行为的一个或多个值的参数。
	 <p>此方法使用语法和参数顺序 <codeph>Array.sort(compareFunction, sortOptions)</codeph>，其参数定义如下：</p>
     <ul><li><codeph>compareFunction</codeph> - 一个用来确定数组元素排序顺序的比较函数。此参数是可选的。比较函数应该用两个参数进行比较。给定元素 A 和 B，<codeph>compareFunction</codeph> 的结果可以具有负值、0 或正值：
	 <ul>
	   <li>若返回值为负，则表示 A 在排序后的序列中出现在 B 之前。</li>
	   <li>若返回值为 0，则表示 A 和 B 具有相同的排序顺序。</li>
	   <li>若返回值为正，则表示 A 在排序后的序列中出现在 B 之后。</li>
	 </ul>
	 </li>
	 <li><codeph>sortOptions</codeph> - 一个或多个数字或定义的常数，相互之间由 <codeph>|</codeph>（按位 OR）运算符隔开，它们将排序的行为从默认行为更改为其它行为。此参数是可选的。下面是 <codeph>sortOptions</codeph> 可接受的值： 
	  <ul>
	   <li>1 或 <codeph>Array.CASEINSENSITIVE</codeph></li>
	   <li>2 或 <codeph>Array.DESCENDING</codeph></li>
	   <li>4 或 <codeph>Array.UNIQUESORT</codeph></li>
	   <li>8 或 <codeph>Array.RETURNINDEXEDARRAY</codeph> </li>
	   <li>16 或 <codeph>Array.NUMERIC</codeph></li>
	 </ul>
	 有关详细信息，请参阅 <codeph>Array.sortOn()</codeph> 方法。</li>
	 </ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 对数组中的元素进行排序。此方法按 Unicode 值排序。（ASCII 是 Unicode 的一个子集。）
	 <p>默认情况下，<codeph>Array</codeph>.<codeph>sort()</codeph> 按以下方式进行排序：</p>
	 <ul>
	   <li>排序区分大小写（<i>Z</i> 优先于 <i>a</i>）。</li>
	   <li>按升序排序（<i>a</i> 优先于 <i>b</i>）。 </li>
	   <li>修改该数组以反映排序顺序；在排序后的数组中不按任何特定顺序连续放置具有相同排序字段的多个元素。</li>
	   <li>元素无论属于何种数据类型，都作为字符串进行排序，所以 100 在 99 之前，这是因为 "1" 的字符串值小于 "9" 的字符串值。</li>
	 </ul>
	 <p>
	 如果要使用与默认设置不同的设置对数组进行排序，可以使用 <codeph>...args</codeph> 参数说明中 <codeph>sortOptions</codeph> 部分所描述的某种排序选项，也可以创建自定义函数来进行排序。如果创建自定义函数，请调用 <codeph>sort()</codeph> 方法，并将自定义函数的名称作为第一个参数 (<codeph>compareFunction</codeph>)。 
	 </p>
	 
	 </apiDesc><example conref="examples\Array.sort.1.as"> 下面的代码创建 Array 对象 <codeph>vegetables</codeph>，其中包含元素 <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph>。然后，通过 <codeph>sort()</codeph> 方法对该数组进行排序，调用该方法时不带参数。结果是 <codeph>vegetables</codeph> 按字母顺序排序 (<codeph>[avocado, cilantro, green pepper, onion, spinach]</codeph>)。
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

trace(vegetables); // spinach,green pepper,cilantro,onion,avocado
vegetables.sort();
trace(vegetables); // avocado,cilantro,green pepper,onion,spinach
</codeblock></example><example conref="examples\Array.sort.2.as"> 下面的代码创建 Array 对象 <codeph>vegetables</codeph>，其中包含元素 <codeph>[spinach, green pepper, Cilantro, Onion, and Avocado]</codeph>。然后，通过 <codeph>sort()</codeph> 方法对该数组进行排序，第一次调用该方法时不带参数，其结果是 <codeph>[Avocado,Cilantro,Onion,green pepper,spinach]</codeph>。然后再次调用 <codeph>sort()</codeph>（对 <codeph>vegetables</codeph>），调用时将 <codeph>CASEINSENSITIVE</codeph> 常量作为参数。结果是 <codeph>vegetables</codeph> 按字母顺序排序 (<codeph>[Avocado, Cilantro, green pepper, Onion, spinach]</codeph>)。
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "Cilantro",
                 "Onion",
                 "Avocado");

vegetables.sort();
trace(vegetables); // Avocado,Cilantro,Onion,green pepper,spinach
vegetables.sort(Array.CASEINSENSITIVE);
trace(vegetables); // Avocado,Cilantro,green pepper,Onion,spinach
</codeblock></example><example conref="examples\Array.sort.3.as"> 下面的代码创建空的 Array 对象 <codeph>vegetables</codeph>，然后通过五次调用如下方法来填充该数组：<codeph>push()</codeph>。每次调用 <codeph>push()</codeph> 时，都创建一个新的 <codeph>Vegetable</codeph> 对象（通过调用 <codeph>Vegetable()</codeph> 构造函数，该构造函数接受 String (<codeph>name</codeph>) 和 Number (<codeph>price</codeph>) 对象）。使用所显示的值调用 <codeph>push()</codeph> 五次，会生成下面的数组：<codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>。然后，使用 <codeph>sort()</codeph> 方法排序该数组，从而得到数组 <codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>。
<codeblock>
var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort();

trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

//The following code defines the Vegetable class
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.4.as"> 下例与前一个示例几乎完全相同，唯一不同的是将 <codeph>sort()</codeph> 方法与自定义排序函数 (<codeph>sortOnPrice</codeph>) 一起使用，该函数按 price 排序，而不是按字母顺序排序。请注意，新函数 <codeph>getPrice()</codeph> 将提取 price。
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sort(sortOnPrice);

trace(vegetables);
// celery:1.29, squash:1.44, lettuce:1.49, spinach:1.89, asparagus:3.99

function sortOnPrice(a:Vegetable, b:Vegetable):Number {
    var aPrice:Number = a.getPrice();
    var bPrice:Number = b.getPrice();

    if(aPrice > bPrice) {
        return 1;
    } else if(aPrice &lt; bPrice) {
        return -1;
    } else  {
        //aPrice == bPrice
        return 0;
    }
}

// The following code defines the Vegetable class and should be in a separate package.
class Vegetable {
    private var name:String;
    private var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function getPrice():Number {
        return price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sort.5.as"> 下面的代码创建 Array 对象 <codeph>numbers</codeph>，其中包含元素 <codeph>[3,5,100,34,10]</codeph>。调用 <codeph>sort()</codeph> 时如果不带任何参数，将按照字母顺序进行排序，生成不需要的结果 <codeph>[10,100,3,34,5]</codeph>。要对数值进行排序，必须将常量 <codeph>NUMERIC</codeph> 传递给 <codeph>sort()</codeph> 方法，该方法按以下方式对 <codeph>numbers</codeph> 进行排序：<codeph>[3,5,10,34,100]</codeph>。
 <p><b>注意：</b><codeph>sort()</codeph> 函数的默认行为是将每个实体作为字符串处理。<codeph>Array.NUMERIC</codeph> 参数实际上没有将其它数据类型转换为 Number 数据类型，它只是允许排序算法识别数字。</p>
<codeblock>

var numbers:Array = new Array(3,5,100,34,10);

trace(numbers); // 3,5,100,34,10
numbers.sort();
trace(numbers); // 10,100,3,34,5
numbers.sort(Array.NUMERIC);
trace(numbers); // 3,5,10,34,100
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (bitwise OR)</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:sortOn"><apiName>sortOn</apiName><shortdesc>
	 根据数组中的一个或多个字段对数组中的元素进行排序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.sortOn, sortOn
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>返回值取决于您是否传递任何参数：
	 <ul>
	   <li>如果您为 <codeph>options</codeph> 参数指定值 4 或 <codeph>Array.UNIQUESORT</codeph>，并且要排序的两个或多个元素具有相同的排序字段，则返回值 0 并且不修改数组。 </li>
  	   <li>如果为 <codeph>options</codeph> 参数指定值 8 或 <codeph>Array.RETURNINDEXEDARRAY</codeph>，则返回反映排序结果的数组并且不修改数组。</li>
  	   <li>否则，不返回任何结果并修改该数组以反映排序顺序。</li>
	 </ul>
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>fieldName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>一个字符串，它标识要用作排序值的字段，或一个数组，其中的第一个元素表示主排序字段，第二个元素表示第二排序字段，依此类推。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>options</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>所定义常数的一个或多个数字或名称，相互之间由 <codeph>bitwise OR (|)</codeph> 运算符隔开，它们可以更改排序行为。<codeph>options</codeph> 参数可接受以下值：
	 <ul>
	   <li><codeph>Array.CASEINSENSITIVE</codeph> 或 1</li>
	   <li><codeph>Array.DESCENDING</codeph> 或 2</li>
	   <li><codeph>Array.UNIQUESORT</codeph> 或 4</li>
	   <li><codeph>Array.RETURNINDEXEDARRAY</codeph> 或 8</li>
	   <li><codeph>Array.NUMERIC</codeph> 或 16</li>
	 </ul>
     <p product="flash">如果您使用标志的字符串形式（例如，<codeph>DESCENDING</codeph>），而不是数字形式 (2)，则启用代码提示。</p>
   	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 根据数组中的一个或多个字段对数组中的元素进行排序。数组应具有下列特性：
	 <ul>
	   <li>该数组是索引数组，不是关联数组。</li>
 	   <li>该数组的每个元素都包含一个具有一个或多个属性的对象。</li>
	   <li>所有这些对象都至少有一个公用属性，该属性的值可用于对该数组进行排序。这样的属性称为 <i>field</i>。</li>
	 </ul>
	 <p>如果您传递多个 <codeph>fieldName</codeph> 参数，则第一个字段表示主排序字段，第二个字段表示下一个排序字段，依此类推。Flash 根据 Unicode 值排序。（ASCII 是 Unicode 的一个子集。） 如果所比较的两个元素中均不包含 <codeph>fieldName</codeph> 参数中指定的字段，则认为将该字段设置为 <codeph>undefined</codeph>，在排序后的数组中将连续放置这些元素，不必遵循任何特定顺序。</p>
 	 <p>默认情况下，<codeph>Array</codeph>。<codeph>sortOn()</codeph> 按以下方式进行排序：</p>
	 <ul>
	   <li>排序区分大小写（<i>Z</i> 优先于 <i>a</i>）。</li>
	   <li>按升序排序（<i>a</i> 优先于 <i>b</i>）。 </li>
	   <li>修改该数组以反映排序顺序；在排序后的数组中不按任何特定顺序连续放置具有相同排序字段的多个元素。</li>
	   <li>数值字段按字符串方式进行排序，因此 100 优先于 99，因为 "1" 的字符串值比 "9" 的低。</li>
	 </ul>
	 <p>Flash Player 7 添加了 <codeph>options</codeph> 参数，您可以使用该参数覆盖默认排序行为。要对简单数组（例如，仅具有一个字段的数组）进行排序，或要指定一种 <codeph>options</codeph> 参数不支持的排序顺序，请使用 <codeph>Array.sort()</codeph>。</p>
 	 <p>要传递多个标志，请使用按位 OR (<codeph>|</codeph>) 运算符分隔它们：</p>
	 <codeblock>
	 my_array.sortOn(someFieldName, Array.DESCENDING | Array.NUMERIC);
	 </codeblock>
	 <p>Flash Player 8 添加了按多个字段进行排序时为每个字段指定不同的排序选项的功能。在 Flash Player 8 和更高版本中，<codeph>options</codeph> 参数接受排序选项的数组，以便每个排序选项对应于 <codeph>fieldName</codeph> 参数中的一个排序字段。下例使用降序排序对主排序字段 <codeph>a</codeph> 排序，使用数字排序对第二个排序字段 <codeph>b</codeph> 排序，使用不区分大小写的排序对第三个排序字段 <codeph>c</codeph> 排序：</p>
	 <codeblock>
	 Array.sortOn (["a", "b", "c"], [Array.DESCENDING, Array.NUMERIC, Array.CASEINSENSITIVE]);
	 </codeblock>
	 <p><b>注意：</b><codeph>fieldName</codeph> 和 <codeph>options</codeph> 数组必须具有相同数量的元素；否则，将忽略 <codeph>options</codeph> 数组。此外，<codeph>Array.UNIQUESORT</codeph> 和 <codeph>Array.RETURNINDEXEDARRAY</codeph> 选项只能用作数组中的第一个元素；否则，将忽略它们。</p>
	 
	 </apiDesc><example conref="examples\Array.sortOn.1.as"> 下面的代码创建一个空的 Array 对象 <codeph>vegetables</codeph>，然后通过五次调用如下方法来填充该数组：<codeph>push()</codeph>。每次调用 <codeph>push()</codeph> 时，都创建一个新的 <codeph>Vegetable</codeph> 对象（通过调用 <codeph>Vegetable()</codeph> 构造函数，该构造函数接受 String (<codeph>name</codeph>) 和 Number (<codeph>price</codeph>) 对象）。使用所显示的值调用 <codeph>push()</codeph> 五次，会生成下面的数组：<codeph>[lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44]</codeph>。然后，使用 <codeph>sortOn()</codeph> 方法（使用 <codeph>name</codeph> 参数）获得以下数组：<codeph>[asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44]</codeph>。然后，使用 price 参数及 NUMERIC 和 DESCENDING 常量再次调用 <codeph>sortOn()</codeph> 方法，以得到按数字降序排序的数组：<codeph>[asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29]</codeph>。
<codeblock>

var vegetables:Array = new Array();
vegetables.push(new Vegetable("lettuce", 1.49));
vegetables.push(new Vegetable("spinach", 1.89));
vegetables.push(new Vegetable("asparagus", 3.99));
vegetables.push(new Vegetable("celery", 1.29));
vegetables.push(new Vegetable("squash", 1.44));

trace(vegetables);
// lettuce:1.49, spinach:1.89, asparagus:3.99, celery:1.29, squash:1.44

vegetables.sortOn("name");
trace(vegetables);
// asparagus:3.99, celery:1.29, lettuce:1.49, spinach:1.89, squash:1.44

vegetables.sortOn("price", Array.NUMERIC | Array.DESCENDING);
trace(vegetables);
// asparagus:3.99, spinach:1.89, lettuce:1.49, squash:1.44, celery:1.29

class Vegetable {
    public var name:String;
    public var price:Number;

    public function Vegetable(name:String, price:Number) {
        this.name = name;
        this.price = price;
    }

    public function toString():String {
        return " " + name + ":" + price;
    }
}
</codeblock></example><example conref="examples\Array.sortOn.2.as"> 下面的代码创建一个空的 Array 对象 <codeph>records</codeph>，然后通过三次调用如下方法来填充该数组：<codeph>push()</codeph>。每次调用 <codeph>push()</codeph> 时，将字符串 <codeph>name</codeph> 和 <codeph>city</codeph> 以及 <codeph>zip</codeph> 数字添加到 <codeph>records</codeph>。使用三个 <codeph>for</codeph> 循环输出数组元素。第一个 <codeph>for</codeph> 循环将按元素的添加顺序输出元素。第二个 <codeph>for</codeph> 循环在先按名称后按城市对 <codeph>records</codeph> 进行排序后运行，排序时使用 <codeph>sortOn()</codeph> 方法。第三个 <codeph>for</codeph> 循环生成不同的输出，因为 <codeph>records</codeph> 先按城市，再按名称重新排序。
<codeblock>


var records:Array = new Array();
records.push({name:"john", city:"omaha", zip:68144});
records.push({name:"john", city:"kansas city", zip:72345});
records.push({name:"bob", city:"omaha", zip:94010});

for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, omaha
// john, kansas city
// bob, omaha

trace("records.sortOn('name', 'city');");
records.sortOn(["name", "city"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// bob, omaha
// john, kansas city
// john, omaha

trace("records.sortOn('city', 'name');");
records.sortOn(["city", "name"]);
for(var i:uint = 0; i &lt; records.length; i++) {
    trace(records[i].name + ", " + records[i].city);
}
// Results:
// john, kansas city
// bob, omaha
// john, omaha
</codeblock></example><example conref="examples\Array.sortOn.3.as"> 下面的代码创建一个空的 Array 对象 <codeph>users</codeph>，然后通过四次调用如下方法来填充该数组：<codeph>push()</codeph>。每次调用 <codeph>push()</codeph> 时，都创建一个 User 对象（使用 <codeph>User()</codeph> 构造函数），同时将 <codeph>name</codeph> 字符串和 <codeph>age</codeph> uint 添加到用户。生成的数组集为 <codeph>[Bob:3,barb:35,abcd:3,catchy:4]</codeph>。
 <p>然后按以下方式对数组进行排序：
 <ol>
   <li>仅按姓名排序，得到数组 <codeph>[Bob:3,abcd:3,barb:35,catchy:4]</codeph></li>
   <li>按姓名排序并使用 <codeph>CASEINSENSITIVE</codeph> 常量，得到数组 <codeph>[abcd:3,barb:35,Bob:3,catchy:4]</codeph></li>
   <li>按姓名排序并使用 <codeph>CASEINSENSITIVE</codeph> 和 <codeph>DESCENDING</codeph> 常量，得到数组 <codeph>[catchy:4,Bob:3,barb:35,abcd:3]</codeph></li>
   <li>仅按年龄排序，得到数组 <codeph>[abcd:3,Bob:3,barb:35,catchy:4]</codeph></li>
   <li>按年龄排序并使用 <codeph>NUMERIC</codeph> 常量，得到数组 <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph></li>
   <li>按年龄排序并使用 <codeph>DESCENDING</codeph> 和 <codeph>NUMERIC</codeph> 常量，得到数组 <codeph>[barb:35,catchy:4,Bob:3,abcd:3]</codeph></li>
 </ol>
 </p>
 <p>然后，创建一个名为 <codeph>indices</codeph> 的数组，并将按年龄排序并使用 <codeph>NUMERIC</codeph> 和 <codeph>RETURNINDEXEDARRAY</codeph> 常量的结果赋予该数组，从而得到数组 <codeph>[Bob:3,abcd:3,catchy:4,barb:35]</codeph>，然后使用 <codeph>for</codeph> 循环输出该数组。</p>
<codeblock>

class User {
    public var name:String;
    public var age:Number;
    public function User(name:String, age:uint) {
        this.name = name;
        this.age = age;
    }

    public function toString():String {
        return this.name + ":" + this.age;
    }
}

var users:Array = new Array();
users.push(new User("Bob", 3));
users.push(new User("barb", 35));
users.push(new User("abcd", 3));
users.push(new User("catchy", 4));

trace(users); // Bob:3,barb:35,abcd:3,catchy:4

users.sortOn("name");
trace(users); // Bob:3,abcd:3,barb:35,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE);
trace(users); // abcd:3,barb:35,Bob:3,catchy:4

users.sortOn("name", Array.CASEINSENSITIVE | Array.DESCENDING);
trace(users); // catchy:4,Bob:3,barb:35,abcd:3

users.sortOn("age");
trace(users); // abcd:3,Bob:3,barb:35,catchy:4

users.sortOn("age", Array.NUMERIC);
trace(users); // Bob:3,abcd:3,catchy:4,barb:35

users.sortOn("age", Array.DESCENDING | Array.NUMERIC);
trace(users); // barb:35,catchy:4,Bob:3,abcd:3

var indices:Array = users.sortOn("age", Array.NUMERIC | Array.RETURNINDEXEDARRAY);
var index:uint;
for(var i:uint = 0; i &lt; indices.length; i++) {
    index = indices[i];
    trace(users[index].name, ": " + users[index].age);
}

// Results:
// Bob : 3
// abcd : 3
// catchy : 4
// barb : 35
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#bitwise_OR"><linktext>| (bitwise OR)</linktext></link><link href="#Array/sort()"><linktext>Array.sort()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:splice"><apiName>splice</apiName><shortdesc>
	 给数组添加元素以及从数组中删除元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.splice, splice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个数组，包含从原始数组中删除的元素。
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整数，它指定数组中开始进行插入或删除的位置处的元素的索引。您可以用一个负整数来指定相对于数组结尾的位置（例如，-1 是数组的最后一个元素）。
	 </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个整数，它指定要删除的元素数量。该数量包括 <codeph>startIndex</codeph> 参数中指定的元素。如果没有为 <codeph>deleteCount</codeph> 参数指定值，则该方法将删除从 <codeph>startIndex</codeph> 元素到数组中最后一个元素的所有值。如果该参数的值为 0，则不删除任何元素。 	 
	 </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>用逗号分隔的一个或多个值的可选列表，此可选列表将插入 <codeph>startIndex</codeph> 参数中的指定位置处的数组中。如果插入的值是数组类型，则保持此数组的原样并将其作为单个元素插入。例如，如果您将长度为 3 的现有数组与另一长度为 3 的数组结合，则生成的数组将只包含 4 个元素。但是，其中的一个元素将是长度为 3 的一个数组。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 给数组添加元素以及从数组中删除元素。此方法会修改数组但不制作副本。
	 <p><b>注意：</b>要在 Array 的子类中覆盖此方法，请使用 <codeph>...args</codeph> 作为参数，如本例所示：</p>
	 <pre>
	 public override function splice(...args) {
	   // your statements here
	 }
	 </pre>
	 </apiDesc><example conref="examples\Array.splice.1.as"> 下面的代码创建 Array 对象 <codeph>vegetables</codeph>，其中包含元素 <codeph>[spinach, green pepper, cilantro, onion, avocado]</codeph>。然后，使用参数 2 和 2 调用 <codeph>splice()</codeph> 方法，以将 <codeph>cilantro</codeph> 和 <codeph>onion</codeph> 赋予 <codeph>spliced</codeph> 数组。<codeph>vegetables</codeph> 数组中就包含 <codeph>[spinach,green pepper,avocado]</codeph>。再次调用 <codeph>splice()</codeph> 方法（使用参数 1、0 和 <codeph>spliced</codeph> 数组），以将 <codeph>[cilantro,onion]</codeph> 作为以下数组中的第二个元素：<codeph>vegetables</codeph>。
<codeblock>

var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");

var spliced:Array = vegetables.splice(2, 2);
trace(vegetables); // spinach,green pepper,avocado
trace(spliced);    // cilantro,onion

vegetables.splice(1, 0, spliced);
trace(vegetables); // spinach,cilantro,onion,green pepper,avocado

</codeblock></example><example conref="examples\Array.splice.2.as"> 请注意，<codeph>cilantro</codeph> 和 <codeph>onion</codeph> 输出时好像 <codeph>vegetables</codeph> 有 5 个元素，但它实际上只有 4 个元素（其中第二个元素是一个包含两个元素的数组）。要单独添加 <codeph>cilantro</codeph> 和 <codeph>onion</codeph>，可使用：
<codeblock>
 
var vegetables:Array = new Array("spinach",
                 "green pepper",
                 "cilantro",
                 "onion",
                 "avocado");
 
 var spliced:Array = vegetables.splice(2, 2);
 trace(vegetables); // spinach,green pepper,avocado
 trace(spliced);    // cilantro,onion
 
 vegetables.splice(1, 0, "cilantro", "onion");
 trace(vegetables); // spinach,cilantro,onion,green pepper,avocado
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Array:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     返回一个字符串，它表示指定数组中的元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>数组元素的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     返回一个字符串，它表示指定数组中的元素。数组中的每一个元素（从索引 0 开始到最高索引结束）均会转换为一个连接字符串，并以逗号分隔。在 ActionScript 3.0 实现中，此方法与 <codeph>Array.toString()</codeph> 方法返回相同的值。
   	 
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/toString()"><linktext>Array.toString()</linktext></link></related-links></apiOperation><apiOperation id="Array:toString"><apiName>toString</apiName><shortdesc>
	 返回一个字符串，它表示指定数组中的元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>数组元素的字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回一个字符串，它表示指定数组中的元素。数组中的每一个元素（从索引 0 开始到最高索引结束）均会转换为一个连接字符串，并以逗号分隔。要指定自定义的分隔符，请使用 <codeph>Array.join()</codeph> 方法。
   	 
	 
	 </apiDesc><example conref="examples\Array.toString.1.as"> 以下代码创建一个 Array 对象，将值转换为字符串，并将它们存储到 String 数据类型的 <codeph>vegnums</codeph> 变量中。

<codeblock>

var vegetables:Array = new Array();
vegetables.push(1);
vegetables.push(2);
vegetables.push(3);
vegetables.push(4);
vegetables.push(5);
var vegnums:String = vegetables.toString();
trace(vegnums+",6");
// 1,2,3,4,5,6
</codeblock></example></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Array/join()"><linktext>Array.join()</linktext></link></related-links></apiOperation><apiOperation id="Array:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     将一个或多个元素添加到数组的开头，并返回该数组的新长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.unshift, unshift
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个整数，表示该数组的新长度。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>一个或多个要插入到数组开头的数字、元素或变量。  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个或多个元素添加到数组的开头，并返回该数组的新长度。数组中的其它元素从其原始位置 i 移到 i+1。
	 
	 </apiDesc><example conref="examples\Array.unshift.1.as"> 下面的代码创建空的 Array 对象 <codeph>names</codeph>。添加字符串 <codeph>Bill</codeph> 和 <codeph>Jeff</codeph>（通过 <codeph>push()</codeph> 方法），然后将字符串 <codeph>Alfred</codeph> 和 <codeph>Kyle</codeph> 添加到 <codeph>names</codeph> 的开头（通过两次调用 <codeph>unshift()</codeph> 方法）。
<codeblock>

var names:Array = new Array();
names.push("Bill");
names.push("Jeff");

trace(names); // Bill,Jeff

names.unshift("Alfred");
names.unshift("Kyle");

trace(names); // Kyle,Alfred,Bill,Jeff
</codeblock></example></apiOperationDetail><related-links><link href="#Array/pop()"><linktext>Array.pop()</linktext></link><link href="#Array/push()"><linktext>Array.push()</linktext></link><link href="#Array/shift()"><linktext>Array.shift()</linktext></link></related-links></apiOperation><apiValue id="Array:CASEINSENSITIVE"><apiName>CASEINSENSITIVE</apiName><shortdesc>
     指定 Array 类排序方法为不区分大小写的排序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F6
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     指定 Array 类排序方法为不区分大小写的排序。您可以对 <codeph>sort()</codeph> 方法或 <codeph>sortOn()</codeph> 方法中的 <codeph>options</codeph> 参数使用此常数。 
	 <p>此常数的值为 1。</p>
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:DESCENDING"><apiName>DESCENDING</apiName><shortdesc>
     指定 Array 类排序方法为降序排序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F7
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     指定 Array 类排序方法为降序排序。您可以对 <codeph>sort()</codeph> 方法或 <codeph>sortOn()</codeph> 方法中的 <codeph>options</codeph> 参数使用此常数。 
 	 <p>此常数的值为 2。</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:NUMERIC"><apiName>NUMERIC</apiName><shortdesc>
     指定 Array 类排序方法为数值（而不是字符串）排序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F8
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>16</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     指定 Array 类排序方法为数值（而不是字符串）排序。在 <codeph>options</codeph> 参数中包括此常数会导致 <codeph>sort()</codeph> 方法和 <codeph>sortOn()</codeph> 方法将数字作为数值排序，而不是作为数字字符的字符串排序。如果不使用 <codeph>NUMERIC</codeph> 常数，则排序将每个数组元素视为一个字符串，并且按照 Unicode 顺序生成结果。 
 	 
     <p>例如，以值为 <codeph>[2005, 7, 35]</codeph> 的数组为例，如果 <codeph>NUMERIC</codeph> 常数<b>未</b>包括在 <codeph>options</codeph> 参数中，则排序后的数组为 <codeph>[2005, 35, 7]</codeph>，但如果<b>包括</b>了 <codeph>NUMERIC</codeph> 常数，则排序后的数组为 <codeph>[7, 35, 2005]</codeph>。 </p>
 	 
 	 <p>此常数仅应用于数组中的数字；不应用于包含数值数据（如 <codeph>["23", "5"]</codeph>）的字符串。</p>
 	 
 	 <p>此常数的值为 16。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:RETURNINDEXEDARRAY"><apiName>RETURNINDEXEDARRAY</apiName><shortdesc>
	 指定排序返回的数组包含数组索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217F9
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指定排序返回的数组包含数组索引。可以将此常数用于 <codeph>sort()</codeph> 或 <codeph>sortOn()</codeph> 方法中的 <codeph>options</codeph> 参数，以便您能够访问数组元素的多个视图，同时又不修改原始数组。 
 	 <p>此常数的值为 8。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:UNIQUESORT"><apiName>UNIQUESORT</apiName><shortdesc>
     指定 Array 类排序方法的唯一排序要求。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>x217FA
	  
	  </helpid></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     指定 Array 类排序方法的唯一排序要求。您可以对 <codeph>sort()</codeph> 方法或 <codeph>sortOn()</codeph> 方法中的 <codeph>options</codeph> 参数使用此常数。如果任何两个要排序的元素或字段的值相同，唯一排序选项就会终止排序。 
	 <p>此常数的值为 4。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="#Array/sort()"><linktext>Array.sort()</linktext></link><link href="#Array/sortOn()"><linktext>Array.sortOn()</linktext></link></related-links></apiValue><apiValue id="Array:length:get"><apiName>length</apiName><shortdesc>
	 指定数组中元素数量的非负整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>array.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 指定数组中元素数量的非负整数。在向数组中添加新元素时，此属性会自动更新。当您给数组元素赋值（例如，<codeph>my_array[index] = value</codeph>）时，如果 <codeph>index</codeph> 是数字，而且 <codeph>index+1</codeph> 大于 <codeph>length</codeph> 属性，则 <codeph>length</codeph> 属性会更新为 <codeph>index+1</codeph>。
   	 <p><b>注意：</b>如果您为 <codeph>length</codeph> 属性所赋的值小于现有长度，会将数组截断。</p>
   	 
	 </apiDesc><example conref="examples\Array.length.1.as"> 下面的代码创建一个 Array 对象 <codeph>names</codeph>，其中包含字符串元素 <codeph>Bill</codeph>。然后它使用 <codeph>push()</codeph> 方法添加另外一个字符串元素 <codeph>Kyle</codeph>。数组的长度由 <codeph>length</codeph> 属性确定，在使用 <codeph>push()</codeph> 之前是一个元素，在调用 <codeph>push()</codeph> 之后是两个元素。添加另外一个字符串 <codeph>Jeff</codeph> 以使 <codeph>names</codeph> 的长度变为三个元素。然后，两次调用 <codeph>shift()</codeph> 方法以删除 <codeph>Bill</codeph> 和 <codeph>Kyle</codeph>，从而使最终数组的 <codeph>length</codeph> 变为一。
<codeblock>

var names:Array = new Array("Bill");
names.push("Kyle");
trace(names.length); // 2

names.push("Jeff");
trace(names.length); // 3

names.shift();
names.shift();
trace(names.length); // 1
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:RegExp"><apiName>RegExp</apiName><shortdesc>
     
     RegExp 类允许使用正则表达式（即可用于在字符串中执行搜索和替换文本的模式）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp
     </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     
     RegExp 类允许使用正则表达式（即可用于在字符串中执行搜索和替换文本的模式）。
     
     <p>可以使用 <codeph>new RegExp()</codeph> 构造函数或将 RegExp 文本分配给一个变量，从而创建新的 RegExp 对象：</p>
     
     <codeblock> var pattern1:RegExp = new RegExp("test-\\d", "i");
     var pattern2:RegExp = /test-\d/i;
     </codeblock>
     
     <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“使用正则表达式”。</p>
     
     </apiDesc><example conref="examples\RegExpExample.as"> 下例说明如何以传入的字符串为依据，使用正则表达式来分析字符串并返回一个新的字符串或布尔值。<codeph>informalizeGreeting()</codeph> 方法只是简单地将单词 <codeph>Hello</codeph> 替换为 <codeph>Hi</codeph>，而不管大小写。它还会去除字符串中姓名的姓（假设姓名符合指定的模式）。<codeph>validateEmail()</codeph> 和 <codeph>validatePhoneNumber()</codeph> 方法将检查所传递字符串的模式是否与有效的电子邮件地址或特定的电话号码模式相匹配，并根据结果返回布尔值。 
<codeblock>
package {
    import flash.display.Sprite;

    public class RegExpExample extends Sprite {        
        public function RegExpExample() {            
            var formalGreeting:String = "Hello, John Smith.";
            trace(informalizeGreeting(formalGreeting));    // Hi, John.

            var validEmail:String = "name@domain.com";
            trace(validateEmail(validEmail));        // true
            
            var invalidEmail:String = "foo";
            trace(validateEmail(invalidEmail));  // false
            
            var validPhoneNumber:String = "415-555-1212";
            trace(validatePhoneNumber(validPhoneNumber));    // true
            
            var invalidPhoneNumber:String = "312-867-530999";
            trace(validatePhoneNumber(invalidPhoneNumber));  // false
        }
        private function informalizeGreeting(str:String):String {
            var pattern:RegExp = new RegExp("hello, (\\w+) \\w+", "i");
            return str.replace(pattern, "Hi, $1");
        }
        private function validateEmail(str:String):Boolean {
            var pattern:RegExp = /(\w|[_.\-])+@((\w|-)+\.)+\w{2,4}+/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
        private function validatePhoneNumber(str:String):Boolean {
            var pattern:RegExp = /^\d{3}-\d{3}-\d{4}$/;
            var result:Object = pattern.exec(str);
            if(result == null) {
                return false;
            }
            return true;
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/replace()"><linktext>String.replace()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links><apiConstructor id="RegExp:RegExp"><apiName>RegExp</apiName><shortdesc>
        允许使用两个字符串来构造正则表达式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.attribute, attribute
        </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>re</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>正则表达式的模式（也称为<i>构造函数字符串</i>）。这是正则表达式的主要部分（“/”字符之间的部分）。 
        
        <p><b>注意：</b> </p>
        
        <ul>
        
        <li>不要包括首尾的“/”字符；这些字符仅用于不使用构造函数定义正则表达式文本的情况。例如，以下两个正则表达式是等效的：
        
        <codeblock> var re1:RegExp = new RegExp("bob", "i"); 
        var re2:RegExp = /bob/i;</codeblock>
        
        </li>
        
        <li>对于使用 <codeph>RegExp()</codeph> 构造函数方法定义的正则表达式，要使用以反斜杠 (\) 字符开头的元序列，例如 <codeph>\d</codeph>（匹配所有数字），请键入两个反斜杠字符。例如，以下两个正则表达式是等效的：
        
        <codeblock> var re1:RegExp = new RegExp("\\d+", ""); 
        var re2:RegExp = /\d/;</codeblock>
        
        <p>在第一个表达式中，您必须键入两个反斜杠字符，因为 <codeph>RegExp() </codeph> 构造函数方法的第一个参数是一个字符串；而在字符串文本中，必须键入两个反斜杠字符才能识别为一个单独的反斜杠字符。</p>
        
        </li>
        
        </ul>
        
        </apiDesc></apiParam><apiParam><apiItemName>flags</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>正则表达式的修饰符。其中包括：
        
        <ul>
        
           <li> <codeph>g</codeph> -- 使用 String 类的 <codeph>replace()</codeph> 方法时，指定此修饰符可替换所有匹配项，而不只替换第一个匹配项。此修饰符对应于 RegExp 实例的 <codeph>global</codeph> 属性。</li>
           <li> <codeph>i</codeph> -- 计算正则表达式时<i>不</i> 区分大小写。此修饰符对应于 RegExp 实例的 <codeph>ignoreCase</codeph> 属性。</li>
           <li> <codeph>s</codeph> -- 点 (<codeph>.</codeph>) 字符与换行符相匹配。请注意，此修饰符对应于 RegExp 实例的 <codeph>dotall</codeph> 属性。</li>
           <li> <codeph>m</codeph> -- 尖号 (<codeph>^</codeph>) 字符和美元符号 (<codeph>$</codeph>) 在换行符之前<i>和</i> 之后匹配。此修饰符对应于 RegExp 实例的 <codeph>multiline</codeph> 属性。</li>
           <li> <codeph>x</codeph> -- 忽略 <codeph>re</codeph> 字符串中的空白字符，所以您可以编写更加易读的构造函数。此修饰符对应于 RegExp 实例的 <codeph>extended</codeph> 属性。</li>
        
        </ul>
        
        <p>将忽略 <codeph>flags</codeph> 字符串中的所有其它字符。 </p>
        
        </apiDesc></apiParam></apiConstructorDef><apiDesc>
        允许使用两个字符串来构造正则表达式。一个字符串定义正则表达式的模式，另一个字符串定义正则表达式中使用的标志。 
        
        </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="RegExp:AS3:exec"><apiName>exec</apiName><shortdesc>
         在给定的字符串 str 中执行正则表达式搜索。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.exec, exec
         </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果没有匹配项，则返回 <codeph>null</codeph>；否则，将返回具有以下属性的对象： 
         
         <ul>
         
          <li>一个数组，其中元素 0 包含完全匹配的子字符串，其它元素（1 到 <i>n</i>）包含与正则表达式中的括号组相匹配的子字符串 </li>
         
          <li><codeph>index</codeph> -- 匹配的子字符串在字符串中的字符位置</li>
         
          <li><codeph>input</codeph> -- 字符串 (<codeph>str</codeph>)</li>
         
         </ul>
         
         
         </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要搜索的字符串。  
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         在给定的字符串 <codeph>str</codeph> 中执行正则表达式搜索。 
         
         <p>如果<i>没有</i> 为正则表达式设置 <codeph>g</codeph> (<codeph>global</codeph>) 标志，则从字符串的开头位置（索引位置 0）开始搜索；搜索将忽略正则表达式的 <codeph>lastIndex</codeph> 属性。</p>
         
         <p>如果为正则表达式<i>设置</i> 了 <codeph>g</codeph> (<codeph>global</codeph>) 标志，将从正则表达式的 <codeph>lastIndex</codeph> 属性指定的索引位置开始搜索。如果搜索与子字符串相匹配，<codeph>lastIndex</codeph> 属性将发生更改以与该匹配项的末尾位置相匹配。 </p>
         
         </apiDesc><example>如果<i>未</i> 在正则表达式中设置 <codeph>g</codeph> (<codeph>global</codeph>) 标志，则可以使用 <codeph>exec()</codeph> 找到字符串中的第一个匹配项： 
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;   
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         trace(result);
         </codeblock>
         
         <p> 对 <codeph>result</codeph> 对象进行如下设置：</p>
         
         <ul>
         
          <li> 将 <codeph>result[0]</codeph> 设置为 <codeph>"She"</codeph>（完全匹配）。 </li>
         
          <li> 将 <codeph>result[1]</codeph> 设置为空字符串（第一个匹配的括号组）。 </li>
         
          <li> 将 <codeph>result[2]</codeph> 设置为 <codeph>"e"</codeph>（第二个匹配的括号组）。 </li>
         
          <li> 将 <codeph>result.index</codeph> 设置为 0。</li>
         
          <li> 将 <codeph>result.input</codeph> 设置为输入字符串：<codeph>"She sells seashells by the seashore"</codeph>。</li>
         
         </ul> 
         
         
         
         <p> 在下例中，在正则表达式中<i>设置</i> 了 <codeph>g</codeph> (<codeph>global</codeph>) 标志，因此您可以重复使用 <codeph>exec()</codeph> 来查找多个匹配项：</p>
         
         <codeblock>
         var myPattern:RegExp = /(\w~~)sh(\w~~)/ig;  
         var str:String = "She sells seashells by the seashore";
         var result:Object = myPattern.exec(str);
         
         while (result != null) {
             trace ( result.index, "\t", result);
             result = myPattern.exec(str);
         }
         </codeblock>
         
         <p> 运行此代码将输出以下内容：</p>
         
         <pre><codeph>
            0      She,,e
            10     seashells,sea,ells
            27     seashore,sea,ore
         </codeph></pre>
         
         </example></apiOperationDetail><related-links><link href="#String/match()"><linktext>String.match()</linktext></link><link href="#String/search()"><linktext>String.search()</linktext></link></related-links></apiOperation><apiOperation id="RegExp:AS3:test"><apiName>test</apiName><shortdesc>
         在给定的字符串 str 中测试正则表达式是否匹配。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.test, test
          
          </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果有匹配项，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要测试的字符串。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         在给定的字符串 <codeph>str</codeph> 中测试正则表达式是否匹配。 
         
         <p>如果<i>没有</i> 为正则表达式设置 <codeph>g</codeph> (<codeph>global</codeph>) 标志，则从字符串的开头位置（索引位置 0）开始搜索；搜索将忽略正则表达式的 <codeph>lastIndex</codeph> 属性。</p>
         
         <p>如果为正则表达式<i>设置</i> 了 <codeph>g</codeph> (<codeph>global</codeph>) 标志，将从正则表达式的 <codeph>lastIndex</codeph> 属性指定的索引位置开始搜索。如果搜索与子字符串相匹配，<codeph>lastIndex</codeph> 属性将发生更改以与该匹配项的末尾位置相匹配。 </p>
         
         </apiDesc><example conref="examples\RegExp.test.1.as"> 下例说明正则表达式中 <codeph>test()</codeph> 方法的用法，在该正则表达式中设置了 <codeph>g</codeph> (<codeph>global</codeph>) 标志： 
<codeblock>
var re1:RegExp = /\w/g;
var str:String = "a b c";
trace (re1.lastIndex); // 0
trace (re1.test(str)); // true
trace (re1.lastIndex); // 1
trace (re1.test(str)); // true
trace (re1.lastIndex); // 3
trace (re1.test(str)); // true
trace (re1.lastIndex); // 5
trace (re1.test(str)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="RegExp:dotall:get"><apiName>dotall</apiName><shortdesc>
         指定正则表达式模式中的点字符 (.) 是否与换行符相匹配。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.dotall, dotall
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         指定正则表达式模式中的点字符 (.) 是否与换行符相匹配。构造正则表达式时使用 <codeph>s</codeph> 标志设置 <codeph>dotall = true</codeph>。
         
         </apiDesc><example conref="examples\RegExp.dotall.1.as"> 下例说明 <codeph>s</codeph> (<codeph>dotall</codeph>) 标志对正则表达式的影响： 
<codeblock>
var str:String = "&lt;p>Hello\n"
        + "again&lt;/p>"
        + "&lt;p>Hello&lt;/p>";

var pattern:RegExp = /&lt;p>.*?&lt;\/p>/;
trace(pattern.dotall) // false
trace(pattern.exec(str)); // &lt;p>Hello&lt;/p>

pattern = /&lt;p>.*?&lt;\/p>/s;
trace(pattern.dotall) // true
trace(pattern.exec(str)); 
   </codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:extended:get"><apiName>extended</apiName><shortdesc>
         指定是否为正则表达式使用扩展模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.extended, extended
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         指定是否为正则表达式使用扩展模式。如果 RegExp 对象处于扩展模式，将忽略构造函数字符串中的空白字符。这样可使构造函数的可读性更强。
         
         <p>构造正则表达式时使用 <codeph>x</codeph> 标志设置 <codeph>extended = true</codeph>。 </p>
         
         </apiDesc><example conref="examples\RegExp.extended.1.as"> 下面的示例说明构造同一正则表达式的不同方法。无论是哪种方法，正则表达式都需匹配 xxx-xxx-xxxx、(xxx) xxx-xxxx 或 (xxx)xxx-xxxx 电话号码模式。第二个正则表达式使用 <codeph>x</codeph> 标志，从而忽略了字符串中的空白。 
<codeblock>
var rePhonePattern1:RegExp = /\d{3}-\d{3}-\d{4}|\(\d{3}\)\s?\d{3}-\d{4}/; 
var str:String = "The phone number is (415)555-1212.";

trace(rePhonePattern1.extended) // false
trace(rePhonePattern1.exec(str)); // (415)555-1212

var rePhonePattern2:RegExp = / \d{3}-\d{3}-\d{4}  |   \( \d{3} \) \ ? \d{3}-\d{4}  /x; 
trace(rePhonePattern2.extended) // true
trace(rePhonePattern2.exec(str)); // (415)555-1212
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:global:get"><apiName>global</apiName><shortdesc>
         指定是否为正则表达式使用全局匹配。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.global, global
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         指定是否为正则表达式使用全局匹配。如果 <codeph>global == true</codeph>，找到一个匹配项后将设置 <codeph>lastIndex</codeph> 属性。下次请求查找匹配项时，此正则表达式引擎将从字符串中的 <codeph>lastIndex</codeph> 位置开始查找。构造正则表达式时，使用 <codeph>g</codeph> 标志将 <codeph>global</codeph> 设置为 <codeph>true</codeph>。 
         
         </apiDesc><example conref="examples\RegExp.global.1.as"> 下例说明在 <codeph>exec()</codeph> 方法中设置 <codeph>g</codeph> (<codeph>global</codeph>) 标志的影响：
<codeblock>
var pattern:RegExp = /foo\d/; 
var str:String = "foo1 foo2";
trace(pattern.global); // false
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 0
trace(pattern.exec(str)); // foo1

pattern = /foo\d/g;
trace(pattern.global); // true
trace(pattern.exec(str)); // foo1
trace(pattern.lastIndex); // 4
trace(pattern.exec(str)); // foo2
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:ignoreCase:get"><apiName>ignoreCase</apiName><shortdesc>
         指定正则表达式是否忽略大小写。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.ignoreCase, ignoreCase
         </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         指定正则表达式是否忽略大小写。构造正则表达式时使用 <codeph>i</codeph> 标志设置 <codeph>ignoreCase = true</codeph>。 
         
         </apiDesc><example conref="examples\RegExp.ignoreCase.1.as"> 下例说明设置 <codeph>i</codeph> (<codeph>ignoreCase</codeph>) 标志的影响：
<codeblock>
var pattern:RegExp = /bob/; 
var str:String = "Bob bob";
trace(pattern.ignoreCase); // false
trace(pattern.exec(str)); // bob

pattern = /bob/i;
trace(pattern.ignoreCase); // true
trace(pattern.exec(str)); // Bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:lastIndex:get"><apiName>lastIndex</apiName><shortdesc>
         指定字符串中开始进行下一次搜索的索引位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.lastIndex, lastIndex
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
         指定字符串中开始进行下一次搜索的索引位置。此属性影响 RegExp 类的 <codeph>exec()</codeph> 和 <codeph>test()</codeph> 方法。但是 String 类的 <codeph>match()</codeph>、<codeph>replace()</codeph> 和 <codeph>search()</codeph> 方法会忽略 <codeph>lastIndex</codeph> 属性，并从字符串的起始处开始进行所有搜索。
         
         <p>如果 <codeph>exec()</codeph> 或 <codeph>test()</codeph> 方法找到了一个匹配项，且正则表达式的 <codeph>g</codeph> (<codeph>global</codeph>) 标志设置为 <codeph>true</codeph>，此方法会自动将 <codeph>lastIndex</codeph> 属性设置为一个字符的索引位置，该字符位于上一匹配项的匹配子字符串的最后一个字符<i>之后</i>。如果将 <codeph>g</codeph> (<codeph>global</codeph>) 标志设置为 <codeph>false</codeph>，则此方法将不设置 <codeph>lastIndex</codeph> 属性。</p>
         
         <p>可以设置 <codeph>lastIndex</codeph> 属性来调整字符串中的起始位置以对正则表达式进行匹配。 </p>
         
         </apiDesc><example conref="examples\RegExp.lastIndex.1.as"> 下例说明设置 <codeph>lastIndex</codeph> 属性的影响，还说明对正则表达式调用 <codeph>exec()</codeph> 方法后如何更新该属性（其中正则表达式中设置了 <codeph>g</codeph> (<codeph>global</codeph>) 标志）：
<codeblock>
var pattern:RegExp = /\w\d/g; 
var str:String = "a1 b2 c3 d4";
pattern.lastIndex = 2; 
trace(pattern.exec(str)); // b2
trace(pattern.lastIndex); // 5
trace(pattern.exec(str)); // c3
trace(pattern.lastIndex); // 8
trace(pattern.exec(str)); // d4
trace(pattern.lastIndex); // 11
trace(pattern.exec(str)); // null
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:multiline:get"><apiName>multiline</apiName><shortdesc>
         指定是否设置了 m（多行）标志。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.multiline, multiline
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         指定是否设置了 <codeph>m</codeph> (<codeph>multiline</codeph>) 标志。如果设置了此标志，正则表达式中的尖号 (<codeph>^</codeph>) 和美元符号 (<codeph>$</codeph>) 将在换行的前后进行匹配。构造正则表达式时使用 <codeph>m</codeph> 标志设置 <codeph>multiline = true</codeph>。
         
         </apiDesc><example conref="examples\RegExp.multiline.1.as"> 下例说明设置 <codeph>m</codeph> (<codeph>multiline</codeph>) 标志的影响：
<codeblock>
var pattern:RegExp = /^bob/; 
var str:String = "foo\n"
                + "bob";
trace(pattern.multiline); // false
trace(pattern.exec(str)); // null

pattern = /^bob/m;
trace(pattern.multiline); // true
trace(pattern.exec(str)); // bob
</codeblock></example></apiValueDetail></apiValue><apiValue id="RegExp:source:get"><apiName>source</apiName><shortdesc>
         指定正则表达式的模式部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>RegExp, RegExp.source, source
          
          </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         指定正则表达式的模式部分。
         
         </apiDesc><example conref="examples\RegExp.source.1.as"> 以下代码输出两个正则表达式的 <codeph>source</codeph> 参数：
<codeblock>
var re1:RegExp = /aabb/gi;
trace (re1.source); // aabb

var re2:RegExp = new RegExp("x+y*", "i");
trace(re2.source); // x+y*
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Date"><apiName>Date</apiName><shortdesc>
 Date 类表示日期和时间信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Date object, built-in class, date 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Date 类表示日期和时间信息。Date 类的实例表示一个特定时间点，可以查询或修改该时间点的属性（如月、日、小时和秒）。Date 类用于检索相对于通用时间（格林尼治平均时，现称为通用时间或 UTC）或相对于本地时间（由运行 Flash Player 的操作系统上的本地时区设置决定）的日期和时间值。Date 类的方法不是静态方法，但仅应用于调用该方法时指定的单个 Date 对象。<codeph>Date.UTC()</codeph> 和 <codeph>Date.parse()</codeph> 方法为例外情况，它们属静态方法。
 <p product="flash">Date 类以不同的方式处理夏时制，具体方式取决于操作系统和 Flash Player 的版本。在以下操作系统中，Flash Player 6 及更高版本以这些方式处理夏时制：</p>
 <ul product="flash">
 <li>Windows - Date 对象自动调整其夏时制输出。Date 对象检测在当前区域设置内是否应用了夏时制，如果是，它将检测标准时到夏时制转换的日期和时间。然而，当前有效的转换日期会应用到以前和将来的日期，所以如果该区域设置具有不同的转换日期，则对于以前的日期，夏时制偏差的计算结果可能会不正确。</li>
 <li>Mac OS X - Date 对象自动调整其夏时制输出。Mac OS X 中的时区信息数据库用于确定现在或以前的任何日期或时间是否应该应用夏时制偏差。</li>
 <li>Mac OS 9 - 该操作系统只提供了足够的信息以确定当前日期和时间是否应该应用夏时制偏差。相应地，date 对象假定当前的夏时制偏差应用于以前或将来的所有日期和时间。</li>
 </ul>
 <p product="flash">在以下操作系统中，Flash Player 5 处理夏时制方式如下所示：</p>
 <ul product="flash">
 <li>Windows - 始终应用美国的夏时制规则，但对于那些应用夏时制，但却具有与美国不同的转换时间的欧洲和其它地区，这将导致转换错误。Flash 会正确地检测当前区域设置中是否使用了夏时制。</li>
 </ul>
 <p>为了使用 Date 类，需使用 <codeph>new</codeph> 运算符构造一个 Date 实例。</p>
 <p>ActionScript 3.0 增加了几个新的存取器属性，可用它们来替代用来访问或修改 Date 实例的许多 Date 类方法。ActionScript 3.0 中还包括 <codeph>toString()</codeph> 方法的几个新变种，其目的是遵从 ECMA-262 第三版，其中包括：<codeph>Date.toLocaleString()</codeph>、<codeph>Date.toTimeString()</codeph>、<codeph>Date.toLocaleTimeString()</codeph>、<codeph>Date.toDateString()</codeph> 和 <codeph>Date.toLocaleDateString()</codeph>。</p>
 <p>要计算相对时间或经过的时间，请参阅 flash.utils 包中的 <codeph>getTimer()</codeph> 方法。</p>
 
 </apiDesc><example conref="examples\DateExample.as"> 下面的示例演示 <codeph>Date()</codeph> 函数的各种用法，可为下列变量赋值：
 <ul>
   <li><codeph>myDate1</codeph> 调用 <codeph>Date()</codeph>，调用时不带参数，这将 <codeph>myDate1</codeph> 设置为当前日期和时间（根据当前系统日期和时间）。 </li>
   <li><codeph>myDate2</codeph> 调用 <codeph>Date()</codeph>，调用时将 <codeph>year</codeph> (<codeph>2000</codeph>)、month (<codeph>0</codeph> = January) 和 <codeph>day</codeph> (<codeph>1</codeph>) 参数传递给该方法。</li>
   <li><codeph>myDate3</codeph> 调用 <codeph>Date()</codeph>，调用时将 <codeph>year</codeph> (<codeph>65</codeph> = 1965)、<codeph>month</codeph> (<codeph>2</codeph> = March)、<codeph>day</codeph> (<codeph>6</codeph>)、<codeph>hour</codeph> (<codeph>9</codeph>)、<codeph>minute</codeph> (<codeph>30</codeph>)、<codeph>second</codeph> (<codeph>15</codeph>) 和 <codeph>millisecond</codeph> -+ (<codeph>0</codeph>) 作为参数传递。</li>
   <li><codeph>myDate4</codeph> 调用 <codeph>Date()</codeph>，后者带有表示 GMT 时间 1970 年 1 月 1 日 0:00:00 <b>之前</b>（因该值为负）的毫秒数的时间值。</li>
 </ul>
<codeblock>

package {
    import flash.display.Sprite;
    
    public class DateExample extends Sprite{
        public function DateExample() {
            var myDate1:Date = new Date();
            trace(myDate1); // [NOW]

            var myDate2:Date = new Date(2000, 0, 1);
            trace(myDate2); // Sat Jan 1 00:00:00 GMT-0800 2000

            var myDate3:Date = new Date(65, 2, 6, 9, 30, 15, 0);
            trace(myDate3); // Sat Mar 6 09:30:15 GMT-0800 1965

            var myDate4:Date = new Date(-14159025000);
            trace(myDate4); // Sun Jul 20 19:56:15 GMT-0700 1969
        }        
    }    
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.utils.xml#/getTimer()"><linktext>flash.utils.getTimer()</linktext></link></related-links><apiConstructor id="Date:Date"><apiName>Date</apiName><shortdesc>
	 构造一个新的 Date 对象，该对象将保存指定的日期和时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new Date, constructor, date
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>yearOrTimevalue</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>如果指定了其它参数，则此数字表示年份（如 1965）；否则，表示时间值。如果该数字表示年份，则 0 至 99 之间的值表示 1900 年至 1999 年；否则，必须指定表示年份的所有 4 位数字。如果该数字表示时间值（未指定任何其它参数），则为 GMT 时间 1970 年 1 月 1 日 0:00:00 之前或之后的毫秒数；负值表示 GMT 时间 1970 年 1 月 1 日 0:00:00 <i>之前</i> 的某个时间，而正值表示该时间之后的某个时间。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（一月）到 11（十二月）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>1 到 31 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0（午夜）到 23（晚上 11 点）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0 到 999 之间的一个整数（毫秒）。 
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 构造一个新的 Date 对象，该对象将保存指定的日期和时间。  
	 
	 <p><codeph>Date()</codeph> 构造函数使用最多七个参数（year、month、... millisecond）将日期和时间指定为毫秒。新构造的 Date 对象包含的日期取决于传递的参数的数目和数据类型。 </p>
	 <ul>
	   <li>如果未传递参数，则赋予 Date 对象当前日期和时间。</li>
	   <li>如果传递一个 Number 数据类型的参数，则基于自 GMT 时间 1970 年 1 月 1 日 0:00:000 以来的毫秒数赋予 Date 对象一个时间值，如独立参数所指定的。</li>
	   <li>如果传递一个 String 数据类型的参数，并且该字符串包含一个有效日期，则 Date 对象包含基于该日期的时间值。</li>
	   <li>如果传递两个或更多个参数，则基于传递的参数值赋予 Date 对象一个时间值，该时间值表示日期的年、月、日、小时、分钟、秒和毫秒。</li>
	 </ul>
	 <p>如果传递一个字符串给 Date 类构造函数，则日期可以有多种格式，但必须至少包括月、日和年。例如，<codeph>Feb 1 2005</codeph> 是有效的，而 <codeph>Feb 2005</codeph> 则是无效的。下表列出了一些有效格式：</p>
	 <ul>
	   <li>Day Month Date Hours:Minutes:Seconds GMT Year（例如，“Tue Feb 1 00:00:00 GMT-0800 2005”，这与 <codeph>toString()</codeph> 一致）</li>
	   <li>Day Month Date Year Hours:Minutes:Seconds AM/PM（例如，“Tue Feb 1 2005 12:00:00 AM”，这与 <codeph>toLocaleString()</codeph> 一致）</li>
	   <li>Day Month Date Year（例如，“Tue Feb 1 2005”，这与 <codeph>toDateString()</codeph> 一致）</li>
	   <li>Month/Day/Year（例如，“02/01/2005”）</li>
	   <li>Month/Year（例如，“02/2005”）</li>
	 </ul>
	 </apiDesc></apiConstructorDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiConstructor><apiOperation id="Date:UTC"><apiName>UTC</apiName><shortdesc>
	 返回 1970 年 1 月 1 日午夜（通用时间）与参数中指定的时间之间相差的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.utc, utc, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>自 1970 年 1 月 1 日起的毫秒数以及指定日期和时间。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>表示年份的四位数整数（例如，2000）。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（一月）到 11（十二月）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1</apiData><apiDesc>1 到 31 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0（午夜）到 23（晚上 11 点）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>0 到 999 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回 1970 年 1 月 1 日午夜（通用时间）与参数中指定的时间之间相差的毫秒数。该方法使用通用时间，而 <codeph>Date</codeph> 构造函数使用本地时间。
	 <p>如果要将一个 UTC 日期传递给 Date 类构造函数，则该方法很有用。因为 Date 类构造函数接受参数形式的毫秒偏移，所以可以使用 Date.UTC() 方法将 UTC 日期转换成相应的毫秒偏移，然后将该偏移作为参数发送给 Date 类构造函数：</p>
	 
	 </apiDesc><example conref="examples\Date.UTC.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)，这些参数使用本地时间。然后，调用 <codeph>UTC()</codeph>（在 <codeph>setTime()</codeph> 方法中），以将上述参数重置为通用时间。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);
trace(someBirthday.toString());

someBirthday.setTime(Date.UTC(1974, 10, 30, 15, 20));
trace(someBirthday.toString());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getDate"><apiName>getDate</apiName><shortdesc>
	 按照本地时间返回 Date 对象指定的月中某天的值（1 到 31 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getdate, getdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的月中某天的值 (1 - 31)。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象指定的月中某天的值（1 到 31 之间的一个整数）。本地时间由运行 Flash Player 的操作系统确定。
	 
 	 </apiDesc><example conref="examples\Date.getDate.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getDate()</codeph> 方法，以检索月中某天的值。
<codeblock>
package {
    import flash.display.Sprite;

    public class DateExample extends Sprite {

        public function DateExample() {
            var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
            trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
            trace(someBirthday.getDate()); // 30
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getDay"><apiName>getDay</apiName><shortdesc>
	 按照本地时间返回该 Date 所指定的星期值（0 代表星期日，1 代表星期一，依此类推）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getday, getday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的星期值的数字版本 (0 - 6)。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回该 <codeph>Date</codeph> 所指定的星期值（0 代表星期日，1 代表星期一，依此类推）。本地时间由运行 Flash Player 的操作系统确定。
	 
 	 </apiDesc><example conref="examples\Date.getDay.1.as"> 下例创建一个新的 Array 对象 <codeph>weekDayLabels</codeph>，包含元素 <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph>，并创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，两次调用 <codeph>getDay()</codeph> 方法，先将月中某天的值显示为 6，然后显示星期值（使用 <codeph>weekDayLabels</codeph>）。
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                       // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDay());            // 6
trace(weekDayLabels[someBirthday.getDay()]); // Saturday
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getFullYear"><apiName>getFullYear</apiName><shortdesc>
	 按照本地时间返回 Date 对象中的完整年份值（一个 4 位数，如 2000）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getfullyear, getfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的完整年份值。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的完整年份值（一个 4 位数，如 2000）。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.getFullYear.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getFullYear()</codeph> 方法，以检索四位数年份值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getHours"><apiName>getHours</apiName><shortdesc>
	 按照本地时间返回 Date 对象中一天的小时值（0 到 23 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gethours, gethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的一天中的小时值 (0 - 23)。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中一天的小时值（0 到 23 之间的一个整数）。本地时间由运行 Flash Player 的操作系统确定。 
	 
	 </apiDesc><example conref="examples\Date.getHours.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getHours()</codeph> 和 <codeph>getMinutes()</codeph> 方法，以按 24 小时格式检索小时和分钟值。最后，创建一个字符串 <codeph>localTime</codeph>，并赋予其调用函数 <codeph>getUSClockTime()</codeph> 的结果，后者可依次重新调用 <codeph>getHours()</codeph> 和 <codeph>getMinutes()</codeph>，从而获得时间 <codeph>03:05 PM</codeph>。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMilliseconds"><apiName>getMilliseconds</apiName><shortdesc>
	 按照本地时间返回 Date 对象中的毫秒值（0 到 999 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmilliseconds, getmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的毫秒值部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的毫秒值（0 到 999 之间的一个整数）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.getMilliseconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getMilliseconds()</codeph> 方法，以检索 Date 对象 <codeph>now</codeph> 创建时的毫秒值。
<codeblock>

var now:Date = new Date();
trace(now.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMinutes"><apiName>getMinutes</apiName><shortdesc>
	 按照本地时间返回 Date 对象中的分钟值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getminutes, getminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的分钟值部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的分钟值（0 到 59 之间的一个整数）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.getMinutes.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getMinutes()</codeph> 方法，以检索 Date 对象 <codeph>now</codeph> 创建时的分钟值。
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getMonth"><apiName>getMonth</apiName><shortdesc>
	 按照本地时间返回该 Date 中的月份值（0 代表一月，1 代表二月，依此类推）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getmonth, getmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的月份值 (0 - 11) 部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回该 <codeph> Date</codeph> 中的月份值（0 代表一月，1 代表二月，依此类推）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.getMonth.1.as"> 下例创建一个新的 Array 对象 <codeph>monthLabels</codeph>，包含元素 <codeph>January</codeph> 到 <codeph>December</codeph>，并创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，两次调用 <codeph>getMonth()</codeph> 方法，先返回 Date 对象 <codeph>now</codeph> 创建之月的月份，再返回月份名称。
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getSeconds"><apiName>getSeconds</apiName><shortdesc>
	 按照本地时间返回 Date 对象中的秒值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getseconds, getseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的秒值（0 到 59）部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的秒值（0 到 59 之间的一个整数）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.getSeconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getSeconds()</codeph> 方法，以检索 Date 对象 <codeph>now</codeph> 创建时的秒值。
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTime"><apiName>getTime</apiName><shortdesc>
	 按照通用时间返回 Date 对象中自 1970 年 1 月 1 日午夜以来的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettime, gettime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的自 1970 年 1 月 1 日以来的毫秒数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间返回 <codeph>Date</codeph> 对象中自 1970 年 1 月 1 日午夜以来的毫秒数。在比较两个或更多个 <codeph>Date</codeph> 对象时，可使用此方法表示某一特定时刻。
	 
	 </apiDesc><example conref="examples\Date.getTime.1.as"> 下例创建一个新的 Date 对象 <codeph>mlk</codeph>，包含参数 <codeph>year</codeph> (<codeph>1929</codeph>)、<codeph>month</codeph> (<codeph>0</codeph> = January) 和 <codeph>day</codeph> (<codeph>15</codeph>)。然后，调用 <codeph>getTime()</codeph> 方法，检索自 1970 年 1 月 1 日午夜以来的毫秒值，由于年份设置为 1929，因此该值为负数。
<codeblock>

var mlk:Date = new Date(1929, 0, 15);
trace(mlk);           // Tue Jan 15 00:00:00 GMT-0800 1929
trace(mlk.getTime()); // -1292601600000
</codeblock></example><example conref="examples\Date.getTime.2.as"> 下面的示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>，然后使用以下 DateMath（将在下面创建）类方法从原始 Date 对象 <codeph>now</codeph> 创建之时起向其中添加时间：
 <ul>
   <li><codeph>addSeconds()</codeph>：向 <codeph>now</codeph> 中添加 30 秒。</li>
   <li><codeph>addMinutes()</codeph>：向 <codeph>now</codeph> 中添加 30 分钟。</li>
   <li><codeph>addHours()</codeph>：向 Date 对象 <codeph>now</codeph> 中添加 6 小时。</li>
   <li><codeph>addDays()</codeph>：向 Date 对象 <codeph>now</codeph> 中添加 30 天。</li>
   <li><codeph>addWeeks()</codeph>：向 <codeph>now</codeph> 中添加 4 周。</li>
 </ul>

<codeblock>

var now:Date = new Date();
trace(now);
trace(DateMath.addSeconds(now, 30));
trace(DateMath.addMinutes(now, 30));
trace(DateMath.addHours(now, 6));
trace(DateMath.addDays(now, 30));
trace(DateMath.addWeeks(now, 4));

class DateMath {
    public static function addWeeks(date:Date, weeks:Number):Date {
        return addDays(date, weeks*7);
    }

    public static function addDays(date:Date, days:Number):Date {
        return addHours(date, days*24);
    }

    public static function addHours(date:Date, hrs:Number):Date {
        return addMinutes(date, hrs*60);
    }

    public static function addMinutes(date:Date, mins:Number):Date {
        return addSeconds(date, mins*60);
    }

    public static function addSeconds(date:Date, secs:Number):Date {
        var mSecs:Number = secs * 1000;
        var sum:Number = mSecs + date.getTime();
        return new Date(sum);
    }
}
</codeblock> <b>注意</b>：在执行日期计算时务必使用 getTime，因为它在闰年仍可继续工作，而不需要类似以下伪代码一样使用一串 if 逻辑：
 <pre>
 function addMonths(num:Number):void {
     currentMonth = currentMonth + num;
     if(currentMonth > 12) {
         currentYear++;
         currentMonth = currentMonth - 12;
     }
 }
 </pre>
</example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getTimezoneOffset"><apiName>getTimezoneOffset</apiName><shortdesc>
     以分钟为单位，返回计算机的本地时间和通用时间 (UTC) 之间的差值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.gettimezoneoffset, gettimezoneoffset, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>需要添加到计算机本地时间值中以与 UTC 相等的分钟数。如果计算机时间设置晚于 UTC，则返回值将为负数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     以分钟为单位，返回计算机的本地时间和通用时间 (UTC) 之间的差值。 
	 
	 </apiDesc><example conref="examples\Date.getTimezoneOffset.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getTimezoneOffset()</codeph> 方法，以检索 <codeph>now</codeph> 创建时与通用时间之间的差值（以分钟为单位）。然后将结果除以 60，从而将时区偏移转换为小时。
<codeblock>

var date:Date = new Date();
trace(date.getTimezoneOffset() / 60);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCDate"><apiName>getUTCDate</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中表示月中某天的值（1 到 31 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcdate, getutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的 UTC 时间月中某天的值（1 到 31）。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中表示月中某天的值（1 到 31 之间的一个整数）。
	 
	 </apiDesc><example conref="examples\Date.getUTCDate.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getUTCDate()</codeph> 方法，以根据 UTC 检索月中某天的值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);             // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCDay"><apiName>getUTCDay</apiName><shortdesc>
	 按照通用时间 (UTC) 返回该 Date 中表示星期的值（0 代表星期日，1 代表星期一，依此类推）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcday, getutcday, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的 UTC 时间的星期值（0 到 6）。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回该 <codeph>Date </codeph> 中表示星期的值（0 代表星期日，1 代表星期一，依此类推）。
	 
	 </apiDesc><example conref="examples\Date.getUTCDay.1.as"> 下例创建一个新的 Array 对象 <codeph>weekDayLabels</codeph>，包含元素 <codeph>[Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday]</codeph>，并创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，两次调用 <codeph>getUTCDay()</codeph> 方法，按照 UTC 先将月中某天的值显示为 6，然后显示星期值（使用 <codeph>weekDayLabels</codeph>）。
<codeblock>

var weekDayLabels:Array = new Array("Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday");

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDay()); // 6
trace(weekDayLabels[someBirthday.getUTCDay()]); // Saturday
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCFullYear"><apiName>getUTCFullYear</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的四位数年份值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcfullyear, getutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的 UTC 时间的四位数年份值。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的四位数年份值。
	 
	 </apiDesc><example conref="examples\Date.getUTCFullYear.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getUTCFullYear()</codeph> 方法，以根据 UTC 检索四位数年份值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);                 // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCHours"><apiName>getUTCHours</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中一天的小时值（0 到 23 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutchours, getutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象代表的一天中的 UTC 小时值（0 到 23）。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中一天的小时值（0 到 23 之间的一个整数）。
	 
	 </apiDesc><example conref="examples\Date.getUTCHours.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getHours()</codeph> 和 <codeph>getMinutes()</codeph> 方法，以按 24 小时格式检索小时和分钟值。最后，创建一个字符串 <codeph>localTime</codeph>，并赋予其调用函数 <codeph>getUSClockTime()</codeph> 的结果，后者可依次重新调用 <codeph>getHours()</codeph> 和 <codeph>getMinutes()</codeph>，从而获得时间 <codeph>03:05 PM</codeph>。最终，采用与 <codeph>localTime</codeph> 相同的方式创建了一个字符串变量 <codeph>utcTime</codeph>，在这种情况下，获得的结果是一样的。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 5);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:5

var localTime:String = getUSClockTime(someBirthday.getHours(), someBirthday.getMinutes());
trace(localTime);    // 03:05 PM

var utcTime:String = getUSClockTime(someBirthday.getUTCHours(), someBirthday.getUTCMinutes());
trace(utcTime);      // 11:05 PM

function getUSClockTime(hrs:uint, mins:uint):String {
    var modifier:String = "PM";
    var minLabel:String = doubleDigitFormat(mins);

    if(hrs > 12) {
        hrs = hrs-12;
    } else if(hrs == 0) {
        modifier = "AM";
        hrs = 12;
    } else if(hrs &lt; 12) {
        modifier = "AM";
    }

    return (doubleDigitFormat(hrs) + ":" + minLabel + " " + modifier);
}

function doubleDigitFormat(num:uint):String {
    if(num &lt; 10) {
        return ("0" + num);
    }
    return num;
}
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCMilliseconds"><apiName>getUTCMilliseconds</apiName><shortdesc>
	  按照通用时间 (UTC) 返回 Date 对象中的毫秒值（0 到 999 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmilliseconds, getutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的 UTC 毫秒值部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的毫秒值（0 到 999 之间的一个整数）部分。
	 
	 </apiDesc><example conref="examples\Date.getUTCMilliseconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getUTCMilliseconds()</codeph> 方法，以按照 UTC 检索 Date 对象 <codeph>now</codeph> 创建时的毫秒值
<codeblock>

var now:Date = new Date();
trace(now.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMinutes"><apiName>getUTCMinutes</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的分钟值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcminutes, getutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的 UTC 分钟值部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的分钟值（0 到 59 之间的一个整数）部分。
	 
	 </apiDesc><example conref="examples\Date.getUTCMinutes.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getUTCMinutes()</codeph> 方法，以按照 UTC 检索 Date 对象 <codeph>now</codeph> 创建时的分钟值
<codeblock>

var now:Date = new Date();
trace(now.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:getUTCMonth"><apiName>getUTCMonth</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的月份值（0 [一月] 到 11 [十二月]）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcmonth, getutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的 UTC 月份值部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的月份值（0 [一月] 到 11 [十二月]）部分。
	 
	 </apiDesc><example conref="examples\Date.getUTCMonth.1.as"> 下例创建一个新的 Array 对象 <codeph>monthLabels</codeph>，包含元素 <codeph>January</codeph> 到 <codeph>December</codeph>，并创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，两次调用 <codeph>getUTCMonth()</codeph> 方法，按照 UTC 先返回 Date 对象 <codeph>now</codeph> 创建之月的月份，再返回月份名称
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(now.getUTCMonth());
trace(monthLabels[now.getUTCMonth()]);
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:getUTCSeconds"><apiName>getUTCSeconds</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的秒值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.getutcseconds, getutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象中的 UTC 秒值部分。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的秒值（0 到 59 之间的一个整数）部分。
	 
	 </apiDesc><example conref="examples\Date.getUTCSeconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getUTCSeconds()</codeph> 方法，以按照 UTC 检索 Date 对象 <codeph>now</codeph> 创建时的秒值
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:parse"><apiName>parse</apiName><shortdesc>
	 按照 UTC 将表示日期的字符串转换为一个数字，它等于自 1970 年 1 月 1 日起已经过的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>表示按 UTC 自 1970 年 1 月 1 日起已经过的毫秒数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>date</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>日期的字符串表示形式，符合 <codeph>Date.toString()</codeph> 的输出格式。<codeph>Date.toString()</codeph> 输出的日期格式为： 
     <pre>
     Day Mon DD HH:MM:SS TZD YYYY
     </pre>
     <p>例如： </p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
     <p>Time Zone Designation (TZD) 的形式始终为 <codeph>GMT-HHMM</codeph> 或 <codeph>UTC-HHMM</codeph>，这表明小时和分钟偏移相对于格林尼治平均时（GMT，现也称通用时间 (UTC)）。年月日之间可用正斜杠 (<codeph>/</codeph>) 或空格隔开，一定不要用短划线 (<codeph>-</codeph>) 隔开。下面是受支持的其它格式（可以包括这些格式的部分表示形式，即，只包括月、日和年）：</p>
     <pre>
     MM/DD/YYYY HH:MM:SS TZD
     HH:MM:SS TZD Day Mon/DD/YYYY 
     Mon DD YYYY HH:MM:SS TZD
     Day Mon DD HH:MM:SS TZD YYYY
     Day DD Mon HH:MM:SS TZD YYYY
     Mon/DD/YYYY HH:MM:SS TZD
     YYYY/MM/DD HH:MM:SS TZD
     </pre>
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照 UTC 将表示日期的字符串转换为一个数字，它等于自 1970 年 1 月 1 日起已经过的毫秒数。
	 
     </apiDesc><example conref="examples\Date.parse.1.as"> 以下示例将一个日期字符串赋予 <codeph>dateParsed</codeph> 以表示 1974 年 11 月 30 日。然后，调用 <codeph>Date.parse()</codeph> 方法，以便将该日期转换为自 1970 年 1 月 1 日起的毫秒数。
<codeblock>
var dateParsed:String = "Sat Nov 30 1974";

var milliseconds:Number = Date.parse(dateParsed);
trace(milliseconds); // 155030400000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>Date.toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setDate"><apiName>setDate</apiName><shortdesc>
	 按照本地时间设置月中的某天，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setdate, setdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>1 到 31 之间的一个整数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置月中的某天，并以毫秒为单位返回新时间。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.setDate.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getDate()</codeph> 方法，以检索月中某天的值。接着，调用 <codeph>setDate()</codeph>（其中的 <codeph>day</codeph> 参数设置为 <codeph>20</codeph>），然后再次调用 <codeph>getDate()</codeph>，以检索新设置的月中某天的值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);            // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getDate()); // 30

someBirthday.setDate(20);
trace(someBirthday.getDate()); // 20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setFullYear"><apiName>setFullYear</apiName><shortdesc>
	 按照本地时间设置年份值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setfullyear, setfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>指定年份的 4 位数。两位数的数字不代表四位数的年份；例如，99 不代表 1999 年，而是表示 99 年。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（一月）到 11（十二月）之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>1 到 31 之间的一个数字。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置年份值，并以毫秒为单位返回新时间。如果指定了 <codeph>month</codeph> 和 <codeph>day</codeph> 参数，则将它们设置为本地时间。本地时间由运行 Flash Player 的操作系统确定。
	 <p>
	 调用此方法不会修改 <codeph>Date</codeph> 的其它字段，但如果因调用该方法而导致星期值发生变化，则 <codeph>Date.getUTCDay()</codeph> 和 <codeph>Date.getDay()</codeph> 会报告一个新值。
	 </p>
	 
	 </apiDesc><example conref="examples\Date.setFullYear.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用 <codeph>getFullYear()</codeph> 方法，以检索四位数年份值。接着，调用 <codeph>setFullYear()</codeph>（其中的 <codeph>year</codeph> 参数设置为 <codeph>2000</codeph>），然后再次调用 <codeph>getFullYear()</codeph>，以检索新设置的年份值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday);           // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getFullYear()); // 1974

someBirthday.setFullYear(2000);
trace(someBirthday.getFullYear()); // 2000
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setHours"><apiName>setHours</apiName><shortdesc>
	 按照本地时间设置小时值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.sethours, sethours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（午夜）到 23（晚上 11 点）之间的一个整数。
     </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。 
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。 
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置小时值，并以毫秒为单位返回新时间。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.setHours.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用方法 <codeph>getHours()</codeph> 和 <codeph>getMinutes()</codeph>，以检索小时和分钟值。接着，调用 <codeph>setHours()</codeph>（其中的 <codeph>hour</codeph> 参数设置为 <codeph>12</codeph>），然后再次调用 <codeph>getHours()</codeph> 和 <codeph>getMinutes()</codeph>，以检索新设置的小时和分钟值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 15:20

someBirthday.setHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMilliseconds"><apiName>setMilliseconds</apiName><shortdesc>
	 按照本地时间设置毫秒值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmilliseconds, setmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置毫秒值，并以毫秒为单位返回新时间。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.setMilliseconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getMilliseconds()</codeph>，以检索 <codeph>now</codeph> 创建时的毫秒值。接下来，再创建一个新 Date 对象 <codeph>before</codeph>，再调用 <codeph>setMilliseconds()</codeph>（其中的 <codeph>millisecond</codeph> 参数设置为 <codeph>4</codeph>），并再次调用 <codeph>getMilliseconds()</codeph>，以检索新设置的毫秒值。
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMilliseconds());

var before:Date = new Date(now.setMilliseconds(4));
trace(before);
trace(before.getMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMinutes"><apiName>setMinutes</apiName><shortdesc>
	 按照本地时间设置分钟值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setminutes, setminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。
     </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置分钟值，并以毫秒为单位返回新时间。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.setMinutes.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getMinutes()</codeph>，以检索 <codeph>now</codeph> 创建时的分钟值。接下来，再创建一个新 Date 对象 <codeph>before</codeph>，再调用 <codeph>setMinutes()</codeph>（其中的 <codeph>minute</codeph> 参数设置为 <codeph>0</codeph>），并再次调用 <codeph>getMinutes()</codeph>，以检索新设置的分钟值。
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getMinutes());

var before:Date = new Date(now.setMinutes(0));
trace(before);
trace(before.getMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setMonth"><apiName>setMonth</apiName><shortdesc>
	 按照本地时间设置月份值以及（可选）日期值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setmonth, setmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（一月）到 11（十二月）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>1 到 31 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置月份值以及（可选）日期值，并以毫秒为单位返回新时间。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.setMonth.1.as"> 下例创建一个新的 Array 对象 <codeph>monthLabels</codeph>，包含元素 <codeph>January</codeph> 到 <codeph>December</codeph>，并创建一个不带参数的新月份对象 <codeph>now</codeph>。然后，调用方法 <codeph>getMonth()</codeph>，以检索 <codeph>now</codeph> 创建时的月份值。接着调用 <codeph>setMonth()</codeph>（其中的 <codeph>month</codeph> 参数设置为 <codeph>0</codeph>），然后再次调用 <codeph>getMonth()</codeph>，以检索新设置的月份值。
<codeblock>

var monthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getMonth());
trace(monthLabels[now.getMonth()]);

now.setMonth(0);
trace(now.getMonth());             // 0
trace(monthLabels[now.getMonth()]); // January
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setSeconds"><apiName>setSeconds</apiName><shortdesc>
	 按照本地时间设置秒值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setseconds, setseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。
     </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照本地时间设置秒值，并以毫秒为单位返回新时间。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc><example conref="examples\Date.setSeconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getseconds()</codeph>，以检索 <codeph>now</codeph> 创建时的秒值。然后，调用 <codeph>setSeconds()</codeph>（其中的 <codeph>second</codeph> 参数设置为 <codeph>0</codeph>），并再次调用 <codeph>getSeconds()</codeph>，以检索新设置的秒值。
<codeblock>

var now:Date = new Date();
trace(now.getSeconds());

now.setSeconds(0);
trace(now.getSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setTime"><apiName>setTime</apiName><shortdesc>
	 以毫秒为单位设置自 1970 年 1 月 1 日午夜以来的日期，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.settime, settime, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个整数值，其中 0 表示通用时间 (UTC) 1 月 1 日午夜。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 以毫秒为单位设置自 1970 年 1 月 1 日午夜以来的日期，并以毫秒为单位返回新时间。 
	 
	 </apiDesc><example conref="examples\Date.setTime.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>setTime()</codeph> 方法（其中的 <codeph>millisecond</codeph> 参数设置为 <codeph>-1292601600000</codeph>），以将时间设置为 <codeph>Tue Jan 15 00:00:00 GMT-0800 1929</codeph>。
<codeblock>

var now:Date = new Date();
trace(now);

now.setTime(-1292601600000);
trace(now); // Tue Jan 15 00:00:00 GMT-0800 1929
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCDate"><apiName>setUTCDate</apiName><shortdesc>
	 按照通用时间 (UTC) 设置日期值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcdate, setutcdate, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字；1 到 31 之间的一个整数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置日期值，并以毫秒为单位返回新时间。调用此方法不会修改 <codeph>Date </codeph> 对象的其它字段，但如果因调用该方法而导致星期值发生变化，则 <codeph>Date.getUTCDay()</codeph> 和 <codeph>Date.getDay()</codeph> 方法会报告一个新值。
	 
	 </apiDesc><example conref="examples\Date.setUTCDate.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。调用方法 <codeph>getUTCDate()</codeph> 并正确返回月中某天的值。接着，调用 <codeph>setUTCDate()</codeph>（其中的 <codeph>day</codeph> 参数设置为 <codeph>1</codeph>），并且 <codeph>trace()</codeph> 语句确认该日期的设置正确。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCDate()); // 30

someBirthday.setUTCDate(1);
trace(someBirthday); // Fri Nov 1 01:20:00 GMT-0800 1974
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCFullYear"><apiName>setUTCFullYear</apiName><shortdesc>
	 按照通用时间 (UTC) 设置年份值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcfullyear, setutcfullyear, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个整数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>year</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个整数，表示以完整的四位数年份形式指定的年份，如 2000。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（一月）到 11（十二月）之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>1 到 31 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置年份值，并以毫秒为单位返回新时间。 
	 <p>
	 另外，还可以使用该方法设置月份和月中的某一天。调用此方法不会修改其它字段，但如果因调用该方法而导致星期值发生变化，则 <codeph>Date.getUTCDay()</codeph> 和 <codeph>Date.getDay()</codeph> 方法会报告一个新值。 
	 </p>
	 
 	 </apiDesc><example conref="examples\Date.setUTCFullYear.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。调用方法 <codeph>getUTCFullYear()</codeph> 并正确返回四位数年份值。接着，调用 <codeph>setUTCFullYear()</codeph>（其中的 <codeph>year</codeph> 参数设置为 <codeph>1975</codeph>），并且 <codeph>trace()</codeph> 语句确认该年份的设置正确。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 1, 20);
trace(someBirthday); // Sat Nov 30 01:20:00 GMT-0800 1974
trace(someBirthday.getUTCFullYear()); // 1974

someBirthday.setUTCFullYear(1975);
trace(someBirthday); // Thu Nov 30 01:20:00 GMT-0800 1975
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCHours"><apiName>setUTCHours</apiName><shortdesc>
	 按照通用时间 (UTC) 设置小时值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutchours, setutchours, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>hour</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（午夜）到 23（晚上 11 点）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置小时值，并以毫秒为单位返回新时间。还可指定分钟值、秒值和毫秒值。
	 
	 </apiDesc><example conref="examples\Date.setUTCHours.1.as"> 下例创建一个新的 Date 对象 <codeph>someBirthday</codeph>，包含参数 <codeph>year</codeph> (<codeph>1974</codeph>)、<codeph>month</codeph> (<codeph>10</codeph> = November)、<codeph>day</codeph> (<codeph>30</codeph>)、<codeph>hour</codeph> (<codeph>1</codeph>) 和 <codeph>minute</codeph> (<codeph>20</codeph>)。然后，调用方法 <codeph>getHours()</codeph>、<codeph>getMinutes()</codeph>、<codeph>getUTCHours()</codeph> 和 <codeph>getUTCMinutes()</codeph>，以检索小时和分钟值。接着，调用 <codeph>setUTCHours()</codeph>（其中的 <codeph>hour</codeph> 参数设置为 <codeph>12</codeph>），然后再次调用方法 <codeph>getHours()</codeph>、<codeph>getMinutes()</codeph>、<codeph>getUTCHours()</codeph> 和 <codeph>getUTCMinutes()</codeph>，并正确显示更新的小时值。
<codeblock>

var someBirthday:Date = new Date(1974, 10, 30, 15, 20);

trace(someBirthday); // Sat Nov 30 15:20:00 GMT-0800 1974
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 15:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 23:20

someBirthday.setUTCHours(12);
trace(someBirthday.getHours() + ":" + someBirthday.getMinutes());     // 4:20
trace(someBirthday.getUTCHours() + ":" + someBirthday.getUTCMinutes()); // 12:20
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMilliseconds"><apiName>setUTCMilliseconds</apiName><shortdesc>
	 按照通用时间 (UTC) 设置毫秒值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmilliseconds, setutcmilliseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置毫秒值，并以毫秒为单位返回新时间。
	 
	 </apiDesc><example conref="examples\Date.setUTCMilliseconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getUTCMilliseconds()</codeph>，以检索 <codeph>now</codeph> 创建时的 UTC 毫秒值。接下来，再创建一个新 Date 对象 <codeph>before</codeph>，再调用 <codeph>setUTCMilliseconds()</codeph>（其中的 <codeph>millisecond</codeph> 参数设置为 <codeph>4</codeph>），并再次调用 <codeph>getUTCMilliseconds()</codeph>，以检索新设置的毫秒值。
<codeblock>


var now:Date = new Date();
trace(now);
trace(now.getUTCMilliseconds());

var before:Date = new Date(now.setUTCMilliseconds(4));
trace(before);
trace(before.getUTCMilliseconds());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMinutes"><apiName>setUTCMinutes</apiName><shortdesc>
	 按照通用时间 (UTC) 设置分钟值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcminutes, setutcminutes, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>minute</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置分钟值，并以毫秒为单位返回新时间。还可以指定秒值和毫秒值。
	 
	 </apiDesc><example conref="examples\Date.setUTCMinutes.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getUTCMinutes()</codeph>，以检索 <codeph>now</codeph> 创建时的 UTC 分钟值。接下来，再创建一个新 Date 对象 <codeph>before</codeph>，再调用 <codeph>setUTCMinutes()</codeph>（其中的 <codeph>minute</codeph> 参数设置为 <codeph>0</codeph>），并再次调用 <codeph>getUTCMinutes()</codeph>，以检索新设置的分钟值。
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.getUTCMinutes());

var before:Date = new Date(now.setUTCMinutes(0));
trace(before);
trace(before.getUTCMinutes());
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:setUTCMonth"><apiName>setUTCMonth</apiName><shortdesc>
	 按照通用时间 (UTC) 设置月份值及（可选）日期值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcmonth, setutcmonth, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>month</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0（一月）到 11（十二月）之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>day</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>1 到 31 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置月份值及（可选）日期值，并以毫秒为单位返回新时间。调用此方法不会修改其它字段，但如果因调用该方法而导致星期值发生变化，则 <codeph>Date.getUTCDay()</codeph> 和 <codeph>Date.getDay()</codeph> 方法可能会报告一个新值。
	 
	 </apiDesc><example conref="examples\Date.setUTCMonth.1.as"> 下例创建一个新的 Array 对象 <codeph>UTCMonthLabels</codeph>，包含元素 <codeph>January</codeph> 到 <codeph>December</codeph>，并创建一个不带参数的新 UTCMonth 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getUTCMonth()</codeph>，以检索 <codeph>now</codeph> 创建时的 UTC 月份值。接着调用 <codeph>setUTCMonth()</codeph>（其中的 <codeph>month</codeph> 参数设置为 <codeph>0</codeph>），然后再次调用 <codeph>getUTCMonth()</codeph>，以检索新设置的月份值。
<codeblock>

var UTCMonthLabels:Array = new Array("January",
                  "February",
                  "March",
                  "April",
                  "May",
                  "June",
                  "July",
                  "August",
                  "September",
                  "October",
                  "November",
                  "December");

var now:Date = new Date();
trace(now.getUTCMonth());
trace(UTCMonthLabels[now.getUTCMonth()]);

now.setUTCUTCMonth(0);
trace(now.getUTCMonth());              // 0
trace(UTCMonthLabels[now.getUTCMonth()]); // January
</codeblock></example></apiOperationDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:setUTCSeconds"><apiName>setUTCSeconds</apiName><shortdesc>
	 按照通用时间 (UTC) 设置秒值以及（可选）毫秒值，并以毫秒为单位返回新时间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.setutcseconds, setutcseconds, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>新时间，以毫秒为单位。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 59 之间的一个整数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>millisecond</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>0 到 999 之间的一个整数。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 设置秒值以及（可选）毫秒值，并以毫秒为单位返回新时间。
	 
	 </apiDesc><example conref="examples\Date.setUTCSeconds.1.as"> 以下示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用方法 <codeph>getUTCSeconds()</codeph>，以检索 <codeph>now</codeph> 创建时的秒值。然后，调用 <codeph>setUTCSeconds()</codeph>（其中的 <codeph>second</codeph> 参数设置为 <codeph>0</codeph>），并再次调用 <codeph>getUTCSeconds()</codeph>，以检索新设置的秒值。
<codeblock>

var now:Date = new Date();
trace(now.getUTCSeconds());

now.setUTCSeconds(0);
trace(now.getUTCSeconds()); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toDateString"><apiName>toDateString</apiName><shortdesc>
	 仅返回星期值和日期值的字符串表示形式，而不返回时间或时区。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>仅返回星期值和日期值的 String 表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 仅返回星期值和日期值的字符串表示形式，而不返回时间或时区。对比下列方法：
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph> 仅返回时间和时区</li>
	   <li><codeph>Date.toString()</codeph> 不仅返回星期值和日期值，还返回时间和时区。</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\Date.toDateString.1.as"> 下例创建一个不带参数的新 Date 对象 <codeph>now</codeph>，然后调用以下方法（在 <codeph>trace()</codeph> 语句中）
 <ul>
   <li><codeph>toString</codeph>：显示 <codeph>now</codeph> 创建之时 <codeph>now</codeph> 的所有参数。</li>
   <li><codeph>toDateString()</codeph>：显示 <codeph>now</codeph> 创建时的 <codeph>day</codeph>、<codeph>month</codeph> 和 <codeph>year</codeph> 参数。</li>
 </ul>
<codeblock>

var now:Date = new Date();
trace(now);
trace(now.toDateString());
</codeblock></example></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleDateString"><apiName>toLocaleDateString</apiName><shortdesc>
	 仅返回星期值和日期值的字符串表示形式，而不返回时间或时区。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>仅返回星期值和日期值的 <codeph>String</codeph> 表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 仅返回星期值和日期值的字符串表示形式，而不返回时间或时区。该方法返回与 <codeph>Date.toDateString</codeph> 相同的值。对比下列方法：
	 <ul>
	   <li><codeph>Date.toTimeString()</codeph> 仅返回时间和时区</li>
	   <li><codeph>Date.toString()</codeph> 不仅返回星期值和日期值，还返回时间和时区。</li>
	 </ul>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 按本地时间返回星期值、日期值以及时间的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象在本地时区中的字符串表示形式。
	 
	  
	  </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按本地时间返回星期值、日期值以及时间的字符串表示形式。对比 <codeph>Date.toString()</codeph> 方法，该方法返回相同的信息（包括时区），且年份值列在字符串的末尾。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toLocaleTimeString"><apiName>toLocaleTimeString</apiName><shortdesc>
	 仅返回时间的字符串表示形式，而不返回星期值、日期值、年份或时区。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>仅返回时间和时区的字符串表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 仅返回时间的字符串表示形式，而不返回星期值、日期值、年份或时区。对比 <codeph>Date.toTimeString()</codeph> 方法，该方法返回时间和时区。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toTimeString()"><linktext>toTimeString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toString"><apiName>toString</apiName><shortdesc>
	 返回星期值、日期值、时间和时区的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.tostring, tostring, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象的字符串表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回星期值、日期值、时间和时区的字符串表示形式。输出的日期格式为： 
     <pre>
     Day Mon Date HH:MM:SS TZD YYYY
     </pre>
     <p>例如：</p>
     <pre>
     Wed Apr 12 15:30:17 GMT-0700 2006
     </pre>
	 
	 </apiDesc><example conref="examples\Date.toString.1.as"> 下面的示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>，然后调用 <codeph>toString</codeph>（在 <codeph>trace()</codeph> 语句中），以显示 <codeph>now</codeph> 创建时 <codeph>now</codeph> 的所有参数。
<codeblock>


var now:Date = new Date();
trace(now);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Date:AS3:toTimeString"><apiName>toTimeString</apiName><shortdesc>
	 仅返回时间和时区的字符串表示形式，而不返回星期值和日期值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage name="ActionScript" version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>仅返回时间和时区的字符串表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 仅返回时间和时区的字符串表示形式，而不返回星期值和日期值。对比 <codeph>Date.toDateString()</codeph> 方法，该方法只返回星期值和日期值。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toDateString()"><linktext>toDateString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:toUTCString"><apiName>toUTCString</apiName><shortdesc>
	 按照通用时间 (UTC) 返回星期值、日期值以及时间的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象的字符串表示形式（采用 UTC 时间）。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间 (UTC) 返回星期值、日期值以及时间的字符串表示形式。例如，对于日期 2005 年 2 月 1 日，返回的字符串表示形式为 <codeph>Tue Feb 1 00:00:00 2005 UTC</codeph>。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Date/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="Date:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 按照通用时间返回 Date 对象中自 1970 年 1 月 1 日午夜以来的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>date.valueof, valueof, date
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc><codeph>Date</codeph> 对象表示的自 1970 年 1 月 1 日以来的毫秒数。
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 按照通用时间返回 <codeph>Date</codeph> 对象中自 1970 年 1 月 1 日午夜以来的毫秒数。
	 
	 </apiDesc><example conref="examples\Date.valueOf.1.as"> 下面的示例创建一个不带参数的新 Date 对象 <codeph>now</codeph>。然后，调用 <codeph>getTime()</codeph> 方法，以检索 <codeph>now</codeph> 创建时与 1970 年 1 月 1 日午夜之间的毫秒数，接着调用 <codeph>valueOf()</codeph>，以检索相同的内容。
<codeblock>


var now:Date = new Date();
trace(now.getTime());
trace(now.valueOf());
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="Date:AS3:date:get"><apiName>date</apiName><shortdesc>
	 按照本地时间返回 Date 对象所指定的表示月中某天的值（1 到 31 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象所指定的表示月中某天的值（1 到 31 之间的一个整数）。本地时间由运行 Flash Player 的操作系统确定。
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDate()"><linktext>getDate()</linktext></link><link href="#Date/setDate()"><linktext>setDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dateUTC:get"><apiName>dateUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的日期值（1 到 31 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的日期值（1 到 31 之间的一个整数）。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDate()"><linktext>getUTCDate()</linktext></link><link href="#Date/setUTCDate()"><linktext>setUTCDate()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:day:get"><apiName>day</apiName><shortdesc>
	 按照本地时间返回该 Date 所指定的星期值（0 代表星期日，1 代表星期一，依此类推）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回该 <codeph>Date</codeph> 所指定的星期值（0 代表星期日，1 代表星期一，依此类推）。本地时间由运行 Flash Player 的操作系统确定。
	 
 	 </apiDesc></apiValueDetail><related-links><link href="#Date/getDay()"><linktext>getDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:dayUTC:get"><apiName>dayUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回该 Date 中的星期值（0 代表星期日，1 代表星期一，依此类推）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回该 <codeph>Date </codeph> 中的星期值（0 代表星期日，1 代表星期一，依此类推）。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCDay()"><linktext>getUTCDay()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYear:get"><apiName>fullYear</apiName><shortdesc>
	 按照本地时间返回 Date 对象中的完整年份值（一个 4 位数，例如 2000）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的完整年份值（一个 4 位数，例如 2000）。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getFullYear()"><linktext>getFullYear()</linktext></link><link href="#Date/setFullYear()"><linktext>setFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:fullYearUTC:get"><apiName>fullYearUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的四位数年份值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的四位数年份值。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCFullYear()"><linktext>getUTCFullYear()</linktext></link><link href="#Date/setUTCFullYear()"><linktext>setUTCFullYear()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hours:get"><apiName>hours</apiName><shortdesc>
	 按照本地时间返回 Date 对象中一天的小时值（0 到 23 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中一天的小时值（0 到 23 之间的一个整数）。本地时间由运行 Flash Player 的操作系统确定。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getHours()"><linktext>getHours()</linktext></link><link href="#Date/setHours()"><linktext>setHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:hoursUTC:get"><apiName>hoursUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中一天的小时值（0 到 23 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中一天的小时值（0 到 23 之间的一个整数）。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCHours()"><linktext>getUTCHours()</linktext></link><link href="#Date/setUTCHours()"><linktext>setUTCHours()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:milliseconds:get"><apiName>milliseconds</apiName><shortdesc>
	 按照本地时间返回 Date 对象中的毫秒值（0 到 999 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的毫秒数（0 到 999 之间的一个整数）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMilliseconds()"><linktext>getMilliseconds()</linktext></link><link href="#Date/setMilliseconds()"><linktext>setMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:millisecondsUTC:get"><apiName>millisecondsUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回 Date 对象中的毫秒值（0 到 999 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的毫秒值（0 到 999 之间的一个整数）部分。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMilliseconds()"><linktext>getUTCMilliseconds()</linktext></link><link href="#Date/setUTCMilliseconds()"><linktext>setUTCMilliseconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutes:get"><apiName>minutes</apiName><shortdesc>
	 按照本地时间返回 Date 对象的分钟值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的分钟值（0 到 59 之间的一个整数）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMinutes()"><linktext>getMinutes()</linktext></link><link href="#Date/setMinutes()"><linktext>setMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:minutesUTC:get"><apiName>minutesUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回的 Date 对象的分钟值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的分钟值（0 到 59 之间的一个整数）部分。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMinutes()"><linktext>getUTCMinutes()</linktext></link><link href="#Date/setUTCMinutes()"><linktext>setUTCMinutes()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:month:get"><apiName>month</apiName><shortdesc>
	 按照本地时间返回 Date 对象的月份值（0 代表一月，1 代表二月，依此类推）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph> Date</codeph> 对象中的月份值（0 代表一月，1 代表二月，依此类推）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getMonth()"><linktext>getMonth()</linktext></link><link href="#Date/setMonth()"><linktext>setMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:monthUTC:get"><apiName>monthUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回的 Date 对象的月份值（0 [1 月] 到 11 [12 月]）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的月份值（0 [一月] 到 11 [十二月]）部分。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCMonth()"><linktext>getUTCMonth()</linktext></link><link href="#Date/setUTCMonth()"><linktext>setUTCMonth()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:seconds:get"><apiName>seconds</apiName><shortdesc>
	 按照本地时间返回 Date 对象的秒值（0 到 59 之间的一个整数）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照本地时间返回 <codeph>Date</codeph> 对象中的秒值（0 到 59 之间的一个整数）部分。本地时间由运行 Flash Player 的操作系统确定。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getSeconds()"><linktext>getSeconds()</linktext></link><link href="#Date/setSeconds()"><linktext>setSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:secondsUTC:get"><apiName>secondsUTC</apiName><shortdesc>
	 按照通用时间 (UTC) 返回的 Date 对象的秒值（0 到 59 之间的一个整数）部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 按照通用时间 (UTC) 返回 <codeph>Date</codeph> 对象中的秒值（0 到 59 之间的一个整数）部分。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getUTCSeconds()"><linktext>getUTCSeconds()</linktext></link><link href="#Date/setUTCSeconds()"><linktext>setUTCSeconds()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:time:get"><apiName>time</apiName><shortdesc>
	 Date 对象中自 1970 年 1 月 1 日午夜（通用时间）以来的毫秒数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 <codeph>Date</codeph> 对象中自 1970 年 1 月 1 日午夜（通用时间）以来的毫秒数。在比较两个或更多个 <codeph>Date</codeph> 对象时，可使用此方法表示某一特定时刻。
	 
	 </apiDesc></apiValueDetail><related-links><link href="#Date/getTime()"><linktext>getTime()</linktext></link><link href="#Date/setTime()"><linktext>setTime()</linktext></link></related-links></apiValue><apiValue id="Date:AS3:timezoneOffset:get"><apiName>timezoneOffset</apiName><shortdesc>
     计算机的本地时间和通用时间 (UTC) 之间的差值（以分钟为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="AS3"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     计算机的本地时间和通用时间 (UTC) 之间的差值（以分钟为单位）。具体而言，该值即需要添加到计算机本地时间值中以与 UTC 相等的分钟数。如果计算机时间设置晚于 UTC，则该值将为负数。
     </apiDesc></apiValueDetail><related-links><link href="#Date/getTimezoneOffset()"><linktext>getTimezoneOffset()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="globalClassifier:URIError"><apiName>URIError</apiName><shortdesc>
 如果采用与某个全局 URI 处理函数的定义相矛盾的方式使用该函数，则会引发 URIError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, URIError
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 如果采用与某个全局 URI 处理函数的定义相矛盾的方式使用该函数，则会引发 URIError 异常。如果为需要有效 URI（如 <codeph>Socket.connect()</codeph> 方法）的函数指定无效 URI，则会引发该异常。
 
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.net.xml#Socket/connect()"><linktext>flash.net.Socket.connect()</linktext></link></related-links><apiConstructor id="URIError:URIError"><apiName>URIError</apiName><shortdesc>
	 创建一个新的 URIError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>包含与 URIError 对象关联的消息。  
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 URIError 对象。
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Object"><apiName>Object</apiName><shortdesc>
 Object 类位于 ActionScript 运行时类层次结构的根处。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/></apiClassifierDef><apiDesc>
 Object 类位于 <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">运行时</ph>类层次结构的根处。Object 由构造函数使用 <codeph>new</codeph> 运算符语法创建，并且可以具有动态赋予其的属性。<ph platform="actionscript">也可通过赋予对象文字值来创建 Object，如下所示：</ph>
 
 <codeblock platform="actionscript">var obj:Object = {a:"foo", b:"bar"}</codeblock>
 
 <p platform="actionscript">不声明显式基类的所有类均可扩展内置 Object 类。</p>
 
 <p platform="javascript">Adobe Integrated Runtime 中的所有运行时类均可扩展 runtime.Object 类。</p>
 
 <p platform="actionscript">可以使用 Object 类创建<i>关联数组</i>。关键是，关联数组是 Object 类的实例，而每个键/值对由属性及属性的值表示。要将关联数组声明为 Object 数据类型还有另一个原因：您可以使用对象文本来填充关联数组（但只能在您声明它时）。下面的示例使用对象文本创建一个关联数组，使用点运算符和数组访问运算符访问项，然后通过创建一个新属性来添加新的键/值对：</p>
 
 <codeblock platform="actionscript">
 var myAssocArray:Object = {fname:"John", lname:"Public"};
 trace(myAssocArray.fname);     // John
 trace(myAssocArray["lname"]);  // Public
 myAssocArray.initial = "Q";
 trace(myAssocArray.initial);   // Q</codeblock> 
 
 <p platform="actionscript">ActionScript 3.0 包含两种继承类型：类继承和原型继承：</p>
 <ul platform="actionscript">
 <li>类继承 -- 是主要的继承机制，并支持固定属性的继承。固定属性是声明为类定义一部分的变量、常量或方法。现在，可通过存储相关类信息的特殊类对象表示每个类定义。 </li>
 <li>原型继承 -- 在以前版本的 ActionScript 中是唯一的继承机制，在 ActionScript 3.0 中作为继承的替代形式。每种类都有一个关联的原型对象，而原型对象的属性由该类的所有实例共享。在创建一个类实例时，它具有对其类的原型对象的引用，这将作为实例及与其关联的类原型对象间的链接。运行时，如果在类实例中找不到某属性，则会检查委托（该类的原型对象）中是否有该属性。如果原型对象中不包含该属性，该过程会继续在层次结构中连续的更高级别上对原型对象进行委托检查，直至 Flash Player 找到该属性为止。 </li>
 </ul>
 
 <p platform="actionscript">类继承和原型继承可同时存在，如下例所示：</p>
 
 <codeblock platform="actionscript">
 class A {
     var x = 1
     prototype.px = 2
 }
 dynamic class B extends A {
     var y = 3
     prototype.py = 4
 }
  
 var b = new B()
 b.x // 1 via class inheritance
 b.px // 2 via prototype inheritance from A.prototype
 b.y // 3
 b.py // 4 via prototype inheritance from B.prototype
  
 B.prototype.px = 5
 b.px // now 5 because B.prototype hides A.prototype
  
 b.px = 6
 b.px // now 6 because b hides B.prototype</codeblock>
 
 <p platform="actionscript">用函数替代类后，可以构造自定义原型继承树。利用类，原型继承树可镜像类继承树。但是，由于原型对象是动态的，因此可以在运行时添加和删除基于原型的属性。</p>
 
 </apiDesc><example conref="examples\ObjectExample.as"> 下面的示例使用类 <codeph>ObjectExample</codeph> 和 <codeph>Circle</codeph> 来证实 Object 类的动态性质，以及值对象如何转换为 Shape 对象，然后添加到舞台上指定的 x/y 坐标处。
 
 <p>该示例创建值对象 <codeph>firstInitObj</codeph> 和 <codeph>secondInitObj</codeph>。自定义类 <codeph>Circle</codeph> 可接受值对象并在该对象上循环，同时将其匹配的内部属性设置为值对象中所定义的值。</p>
<codeblock>
package {
    import flash.display.Sprite;

    public class ObjectExample extends Sprite {
        public function ObjectExample() {
            var firstInitObj:Object = new Object();
            firstInitObj.bgColor = 0xFF0000;
            firstInitObj.radius = 25;
            firstInitObj.xCenter = 25;
            firstInitObj.yCenter = 25;
                        
            var firstCircle:Circle = new Circle(firstInitObj);
            addChild(firstCircle);
            firstCircle.x = 50;
            firstCircle.y = 50;

            var secondInitObj:Object = {bgColor:0xCCCCCC, radius:50, xCenter:50, yCenter:50};

            var secondCircle:Circle = new Circle(secondInitObj);            
            addChild(secondCircle);
            secondCircle.x = 100;
            secondCircle.y = 100;
        }
        
    }
}

import flash.display.Shape;
    
class Circle extends Shape {
    public var bgColor:Number = 0xFFFFFF;
    public var radius:Number = 0;
    public var xCenter:Number = 0;
    public var yCenter:Number = 0;
        
    public function Circle(initObj:Object) {
        for(var i:String in initObj) {
            this[i] = initObj[i];
        }
        draw();
    }
        
    public function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawCircle(xCenter, yCenter, radius);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links><apiConstructor id="Object:Object"><apiName>Object</apiName><shortdesc>
	 创建 Object 对象，并将对该对象的构造函数方法的引用存储在该对象的 constructor 属性中。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 创建 Object 对象，并将对该对象的构造函数方法的引用存储在该对象的 <codeph>constructor</codeph> 属性中。
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Object:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	 指示对象是否已经定义了指定的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><category>Method
	 </category></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果目标对象具有 <codeph>name</codeph> 参数指定的属性，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对象的属性。	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指示对象是否已经定义了指定的属性。如果目标对象具有与 <codeph>name</codeph> 参数指定的字符串匹配的属性，则此方法返回 <codeph>true</codeph>；否则返回 <codeph>false</codeph>。以下类型的属性导致该方法对属于类实例的对象（而不是类对象）返回 <codeph>true</codeph>：
	 <ul>
	   <li>固定实例属性 — 对象类定义的非静态变量、常量或方法；</li>
	   <li>继承的固定实例属性 — 对象类继承的变量、常量或方法；</li>
	   <li>动态属性 — 对象实例化后添加到其中的属性（在其类定义之外）。要添加动态属性，必须用 <codeph>dynamic</codeph> 关键字声明对象的定义类。</li>
	 </ul>
	 <p>以下类型的属性导致该方法对属于类实例的对象返回 <codeph>false</codeph>：</p>
	 <ul>
	   <li>静态属性 -- 在对象的定义类或其任何超类中使用静态关键字定义的变量、常量或方法；</li>
	   <li>原型属性 -- 在原型对象上定义的属于对象原型链一部分的属性。在 ActionScript 3.0 中，虽然原型链不用于类继承，但仍可作为继承的一种替代形式存在。例如，Array 类的一个实例可以访问 <codeph>valueOf()</codeph> 方法，因为它位于属于 Array 类原型链一部分的 <codeph>Object.prototype</codeph> 上。虽然可以在 Array 实例中使用 <codeph>valueOf()</codeph>，但对该实例返回的 <codeph>hasOwnProperty("valueOf")</codeph> 值为 <codeph>false</codeph>。</li>
	 </ul>
	 
	 <p platform="actionscript">ActionScript 3.0 还包含类对象，它是类定义的直接表示形式。调用类对象时，仅当属性是该类对象中定义的静态属性时，<codeph>hasOwnProperty()</codeph> 方法才返回 <codeph>true</codeph>。例如，如果创建名为 CustomArray 的 Array 子类，并在 CustomArray 中定义一个名为 <codeph>foo</codeph> 的静态属性，对 <codeph>CustomArray.hasOwnProperty("foo")</codeph> 的调用则返回 <codeph>true</codeph>。然而，对于在 Array 类中定义的静态属性 <codeph>DESCENDING</codeph>，对 <codeph>CustomArray.hasOwnProperty("DESCENDING")</codeph> 的调用返回 <codeph>false</codeph>。</p>
	 
     <p platform="actionscript"><b>注意：</b>Object 类的方法是在 Object 的原型上动态创建的。要在 Object 的子类中重新定义该方法，请不要使用 <codeph>override</codeph> 关键字。例如，Object 的一个子类实现 <codeph>function hasOwnProperty():Boolean</codeph> 而不使用基类覆盖。</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:isPrototypeOf"><apiName>isPrototypeOf</apiName><shortdesc>
	 指示 Object 类的实例是否在指定为参数的对象的原型链中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果对象位于由 <codeph>theClass</codeph> 参数指定的对象的原型链中，则该值为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>theClass</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>指定对象可能引用的类。  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指示 Object 类的实例是否在指定为参数的对象的原型链中。如果该对象位于由 <codeph>theClass</codeph> 参数指定的对象的原型链中，则此方法返回 <codeph>true</codeph>。如果 <codeph>theClass</codeph> 对象的原型链中缺少目标对象，并且 <codeph>theClass</codeph> 参数不为对象，则该方法返回 <codeph>false</codeph>。
	 
     <p platform="actionscript"><b>注意：</b>Object 类的方法是在 Object 的原型上动态创建的。要在 Object 的子类中重新定义该方法，请不要使用 <codeph>override</codeph> 关键字。例如，Object 的一个子类实现 <codeph>function isPrototypeOf():Boolean</codeph> 而不使用基类覆盖。</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	 指示指定的属性是否存在、是否可枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a generic object, adds a property to the object, then checks whether the object is enumerable. By way of contrast, the example also shows that a built-in property, the <code>Array.length</code> property, is not enumerable.
	 <listing>
	 var myObj:Object = new Object();
	 myObj.prop1 = "hello";
	 trace(myObj.propertyIsEnumerable("prop1")); // true
	 
	 var myArray = new Array();
	 trace(myArray.propertyIsEnumerable("length")); // false
	 </listing> 
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 <codeph>name</codeph> 参数指定的属性可以枚举，则该值为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对象的属性。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指示指定的属性是否存在、是否可枚举。如果为 <codeph>true</codeph>，则该属性存在并且可以在 <codeph>for..in</codeph> 循环中枚举。该属性必须存在于目标对象上，原因是：该方法不检查目标对象的原型链。
	 
	 <p>您创建的属性是可枚举的，但是内置属性通常是不可枚举的。</p>
	 
     <p platform="actionscript"><b>注意：</b>Object 类的方法是在 Object 的原型上动态创建的。要在 Object 的子类中重新定义该方法，请不要使用 <codeph>override</codeph> 关键字。例如，Object 的一个子类实现 <codeph>function propertyIsEnumerable():Boolean</codeph> 而不使用基类覆盖。</p>
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:setPropertyIsEnumerable"><apiName>setPropertyIsEnumerable</apiName><shortdesc>
     设置循环操作动态属性的可用性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对象的属性。
     </apiDesc></apiParam><apiParam><apiItemName>isEnum</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc> 如果设置为 <codeph>false</codeph>，则动态属性不会显示在 <codeph>for..in</codeph> 循环中，且方法 <codeph>propertyIsEnumerable()</codeph> 返回 <codeph>false</codeph>。 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     设置循环操作动态属性的可用性。该属性必须存在于目标对象上，原因是：该方法不检查目标对象的原型链。
     </apiDesc></apiOperationDetail><related-links><link href="#Object/propertyIsEnumerable()"><linktext>propertyIsEnumerable()</linktext></link></related-links></apiOperation><apiOperation id="Object:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
	 返回此对象的字符串表示形式，其格式设置遵守区域设置特定的约定。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tolocalestring, tolocalestring
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>此对象的字符串表示形式，其格式设置遵守本地约定。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回此对象的字符串表示形式，其格式设置遵守区域设置特定的约定。
	 
	 <p>此方法的默认实现不执行区域设置特定的格式设置，并返回与 <codeph>toString()</codeph> 相同的字符串。子类应在适当时提供它们自己的识别区域设置的实现。</p>
	 
     <p platform="actionscript"><b>注意：</b>Object 类的方法是在 Object 的原型上动态创建的。要在 Object 的子类中重新定义该方法，请不要使用 <codeph>override</codeph> 关键字。例如，Object 的一个子类实现 <codeph>function toLocaleString():String</codeph>，而不使用基类覆盖。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiOperation id="Object:toString"><apiName>toString</apiName><shortdesc>
	 返回指定对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>对象的字符串表示形式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回指定对象的字符串表示形式。
	 
     <p platform="actionscript"><b>注意：</b>Object 类的方法是在 Object 的原型上动态创建的。要在 Object 的子类中重新定义该方法，请不要使用 <codeph>override</codeph> 关键字。例如，Object 的一个子类实现 <codeph>function toString():String</codeph> 而不使用基类覆盖。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Object:valueOf"><apiName>valueOf</apiName><shortdesc>
	 返回指定对象的原始值。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>object, object.valueof, valueof
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>该对象的原始值或对象本身。
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回指定对象的原始值。如果此对象没有原始值，则返回对象本身。
	 
     <p platform="actionscript"><b>注意：</b>Object 类的方法是在 Object 的原型上动态创建的。要在 Object 的子类中重新定义该方法，请不要使用 <codeph>override</codeph> 关键字。例如，Object 的一个子类实现 <codeph>function valueOf():Object</codeph> 而不使用基类覆盖。</p>
     
	 </apiDesc></apiOperationDetail><related-links><link href="#Object/toString()"><linktext>Object.toString()</linktext></link></related-links></apiOperation><apiValue id="Object:constructor"><apiName>constructor</apiName><shortdesc>
	 对类对象或给定对象实例的构造函数的引用。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Object, Object.constructor, constructor
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 对类对象或给定对象实例的构造函数的引用。如果某个对象是类的实例，则 <codeph>constructor</codeph> 属性具有对该类对象的引用。如果某个对象是使用构造函数创建的，则 <codeph>constructor</codeph> 属性具有对该构造函数的引用。切勿将构造函数与类的构造函数方法混同。构造函数是用来创建对象的一种 Function 对象，并且可以代替 <codeph>class</codeph> 关键字来定义类。
	 
	 <p platform="actionscript">如果使用 <codeph>class</codeph> 关键字定义一个类，则该类的原型对象被赋予名为 <codeph>constructor</codeph> 的属性，该属性具有对类对象的引用。该类的实例从原型对象继承该属性。例如，以下代码创建一个新类 <codeph>A</codeph>，以及一个名为 <codeph>myA</codeph> 的类实例：</p>
	 <codeblock platform="actionscript" rev="3.0">
	 dynamic class A {}
	 trace(A.prototype.constructor);      // [class A]
	 trace(A.prototype.constructor == A); // true
	 var myA:A = new A();
	 trace(myA.constructor == A);         // true</codeblock>
	 
	 <p platform="actionscript">高级用户可以选择使用 <codeph>function</codeph> 关键字来代替 <codeph>class</codeph> 关键字，以定义可用作创建对象的模板的 Function 对象。这种函数称为构造函数，因为将它与 <codeph>new</codeph> 运算符结合使用可创建对象。如果使用 <codeph>function</codeph> 关键字创建构造函数，其原型对象会被赋予名为 <codeph>constructor</codeph> 的属性，该属性具有对构造函数的引用。如果使用构造函数创建一个对象，该对象会从构造函数的原型对象继承 <codeph>constructor</codeph> 属性。例如，以下代码创建一个新构造函数 <codeph>f</codeph>，以及一个名为 <codeph>myF</codeph> 的对象：</p>
	 <codeblock platform="actionscript" rev="3.0">
	 function f() {}
	 trace(f.prototype.constructor);      // function Function() {}
	 trace(f.prototype.constructor == f); // true
	 var myF = new f();
	 trace(myF.constructor == f);         // true</codeblock>
	 
	 <p><b>注意</b>：<codeph>constructor</codeph> 属性是可写的，这意味着用户代码可以通过赋值语句更改其值。不建议更改 <codeph>constructor</codeph> 属性的值，但是如果编写的代码依赖 <codeph>constructor</codeph> 属性的值，则应确保不重置该值。仅在通过原型对象（例如 <codeph>className.prototype.constructor</codeph>）访问该属性时，才能更改该值。</p>
     <p>如果访问 <codeph>constructor</codeph> 属性，并以严格模式编译，那么编译时将出错，因为 constructor 属性依赖于原型对象，而原型对象是运行时实体。如果使用标准模式，或者类描述指定了“dynamic”，则代码运行时不会产生错误。</p>     
	 </apiDesc></apiValueDetail><related-links><link href="#Class"><linktext>Class</linktext></link><link href="#Function"><linktext>Function</linktext></link><link href="#Object/prototype"><linktext>prototype</linktext></link></related-links></apiValue><apiValue id="Object:prototype"><apiName>prototype</apiName><shortdesc>
	 对类或函数对象的原型对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a class named Shape and a subclass of Shape named Circle.
	 <listing version="2.0">
	 // Shape class defined in external file named Shape.as
	 class Shape {
	 	function Shape() {}
	 }
	 
	 // Circle class defined in external file named Circle.as
	 class Circle extends Shape{
	 	function Circle() {}
	 }
	 </listing>
	 The Circle class can be used to create two instances of Circle:
	 <listing version="2.0">
	 var oneCircle:Circle = new Circle();
	 var twoCircle:Circle = new Circle();
	 </listing>
	 The following trace statement shows that the <code>prototype</code> property of the Circle class points to its superclass Shape. The identifier <code>Shape</code> refers to the constructor function of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.constructor == Shape); // true
	 </listing>
	 The following trace statement shows how you can use the <code>prototype</code> property and the <code>__proto__</code> property together to move two levels up the inheritance hierarchy (or prototype chain). The <code>Circle.prototype.__proto__</code> property contains a reference to the superclass of the Shape class.
	 <listing version="2.0">
	 trace(Circle.prototype.__proto__ == Shape.prototype); // true
	 </listing>
	 
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 对类或函数对象的原型对象的引用。<codeph>prototype</codeph> 属性会自动创建并附加到您创建的任何类或函数对象。此属性是静态的，因为它特定于您所创建的类或函数。例如，如果创建了一个类，则 <codeph>prototype</codeph> 属性的值由该类的所有实例共享，并且只能将其作为类属性进行访问。该类的实例不能直接访问 <codeph>prototype</codeph> 属性。 
	 
     <p>类的原型对象是一种特殊的类实例，它提供一种在类的所有实例中共享状态的机制。运行时，如果在类实例中找不到某属性，则会检查委托（该类的原型对象）中是否有该属性。如果原型对象中不包含该属性，该过程会继续在层次结构中连续的更高级别上对原型对象进行委托检查，直至 <ph platform="actionscript">Flash Player 或</ph> Adobe Integrated Runtime 找到该属性为止。 </p>
	 
     <p platform="actionscript"><i>注意：</i>在 ActionScript 3.0 中，原型继承不是主要的继承机制。类继承可驱动类定义中固定属性的继承，它才是 ActionScript 3.0 中主要的继承机制。</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:SecurityError"><apiName>SecurityError</apiName><shortdesc>
 如果发生某种类型的安全侵犯，则会引发 SecurityError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SecurityError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 如果发生某种类型的安全侵犯，则会引发 <codeph>SecurityError</codeph> 异常。
 <p>
 安全错误示例：</p>
 <ul>
   <li>通过安全沙箱边界进行未经授权的属性访问或方法调用。</li>
   <li>尝试访问安全沙箱不允许的 URL。</li>
   <li>尝试与未经授权的端口号（如端口号大于 65535 的端口）进行套接字连接。</li>
   <li>尝试访问用户的摄像头或麦克风，而访问此类设备的请求已被用户拒绝。</li>
 </ul>
 
 </apiDesc><example conref="examples\SecurityErrorExample.as"> 下面的示例说明 <codeph>SecurityError</codeph> 错误是如何生成的，以及如何在 <codeph>try...catch</codeph> 语句中通过连接到端口号比最大允许值大 1 的端口来处理该错误。
<codeblock>
package {
    import flash.display.Sprite;
    import flash.net.Socket;

    public class SecurityErrorExample extends Sprite {

        public function SecurityErrorExample() {
            try {
                var host:String = "www.[yourDomain].com";
                var socket:Socket = new Socket();
                socket.connect(host, 65536);
            }
            catch(e:SecurityError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="SecurityError:SecurityError"><apiName>SecurityError</apiName><shortdesc>
	 创建一个新的 SecurityError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 SecurityError 对象。
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
 如果尝试对密封（非动态）对象使用未定义属性的引用，将引发 ReferenceError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, ReferenceError
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 如果尝试对密封（非动态）对象使用未定义属性的引用，将引发 ReferenceError 异常。引用未定义变量将导致 ReferenceError 异常，通知您潜在的错误并帮助您排除应用程序代码故障。
 <p>但是，引用动态类的未定义属性不会引发 ReferenceError 异常。有关详细信息，请参阅 <codeph>dynamic</codeph> 关键字。</p>
 
 </apiDesc><example conref="examples\ReferenceErrorExample.as"> 下面的示例演示 <codeph>ReferenceError</codeph> 异常是如何生成的，以及如何在 <codeph>try..catch</codeph> 语句中进行处理。 
<codeblock>
package {
    import flash.display.Sprite;

    public class ReferenceErrorExample extends Sprite {

        public function ReferenceErrorExample() {
            try {
                this["someMember"] = true;
            }
            catch(e:ReferenceError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#dynamic"><linktext>dynamic keyword</linktext></link></related-links><apiConstructor id="ReferenceError:ReferenceError"><apiName>ReferenceError</apiName><shortdesc>
	 创建一个新的 ReferenceError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>包含与 ReferenceError 对象关联的消息。
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 ReferenceError 对象。
	 </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:RangeError"><apiName>RangeError</apiName><shortdesc>
 如果数值不在可接受的范围内，则会引发 RangeError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, RangeError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 如果数值不在可接受的范围内，则会引发 RangeError 异常。使用数组时，引用不存在的数组项的索引位置将会引发 RangeError 异常。如果参数不在可接受的数字范围内，则使用 <codeph>Number.toExponential()</codeph>、<codeph>Number.toPrecision()</codeph> 和 <codeph>Number.toFixed()</codeph> 方法将引发 RangeError 异常。可以扩展 <codeph>Number.toExponential()</codeph>、<codeph>Number.toPrecision()</codeph> 和 <codeph>Number.toFixed()</codeph> 以避免引发 RangeError。
 <p product="flash">以下情况也可能引发此异常：
 <ul>
   <li>使用无效深度编号调用任意要求深度编号的 Flash Player API。</li>
   <li>使用无效帧编号调用任意要求帧编号的 Flash Player API。</li>
   <li>使用无效图层编号调用任意要求图层编号的 Flash Player API。</li>
 </ul>
 </p>
 </apiDesc><example conref="examples\RangeErrorExample.as"> 下面的示例演示 <codeph>RangeError</codeph> 异常是如何生成的，以及如何在 <codeph>try..catch</codeph> 语句中进行处理。 
<codeblock>
package {
    import flash.display.Sprite;

    public class RangeErrorExample extends Sprite {

        public function RangeErrorExample() {
            var child:Sprite = new Sprite();
            try {
                addChildAt(child, 1);
            }
            catch(e:RangeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Number/toExponential()"><linktext>Number.toExponential()</linktext></link><link href="#Number/toPrecision()"><linktext>Number.toPrecision()</linktext></link><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links><apiConstructor id="RangeError:RangeError"><apiName>RangeError</apiName><shortdesc>
	 创建一个新的 RangeError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>包含与 RangeError 对象关联的消息。
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 RangeError 对象。
	 </apiDesc></apiConstructorDetail><related-links><link href="#Number/toFixed()"><linktext>Number.toFixed()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:int"><apiName>int</apiName><shortdesc>
 通过 int 类可使用表示为 32 位带符号整数的数据类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int object, int, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 通过 int 类可使用表示为 32 位带符号整数的数据类型。int 类表示的值的范围是：-2,147,483,648 (-2^31) 到 2,147,483,647 (2^31-1)。
 <p>int 类的常数属性 <codeph>MAX_VALUE</codeph> 和 <codeph>MIN_VALUE</codeph> 为静态的，这意味着无需对象就可使用这些属性，因而不需要使用构造函数。而方法却不是静态的，这意味着需要对象才能使用它们。可以通过使用 int 类构造函数，或者声明一个 int 类型的变量并赋予该变量一个文字值来创建 int 对象。</p>
 <p>int 数据类型用于循环计数器和不需要浮点数的其它情况，且该数据类型类似于 Java 和 C++ 中的 int 数据类型。int 类型变量的默认值为 <codeph>0</codeph></p>
 <p>如果您正在处理超过 <codeph>int.MAX_VALUE</codeph> 的数值，可考虑使用 Number。  </p>
 <p>以下示例调用 int 类的 <codeph>toString()</codeph> 方法，以返回字符串 <codeph>1234</codeph>： </p>
 <codeblock rev="3.0">
 var myint:int = 1234;
 myint.toString();
 </codeblock>
 <p>以下示例将 <codeph>MIN_VALUE</codeph> 属性的值分配给一个无需使用构造函数进行声明的变量：</p>
 <pre>
 var smallest:int = int.MIN_VALUE;
 </pre> 
 
 </apiDesc><example conref="examples\IntExample.as"> 下面的示例使用 <codeph>IntExample</codeph> 类显示如何使用和检查 int 数据类型的有效性：
 <ol>
     <li>在构造函数中声明两个 int 变量 <codeph>a</codeph> 和 <codeph>b</codeph>。</li>
     <li>添加两个 int（使用方法 <codeph>addIntegers()</codeph>）。</li>
     <li>将 <codeph>parseInteger()</codeph>（它检查传递给它的字符串的有效性，并确保其为 int 数据类型可接受范围内的一个整数值，如果该字符串有效，则返回一个等于该字符串整数值的整数）的结果赋予第三个 int 变量 <codeph>c</codeph>。</li>
     <li>使用 <codeph>addIntegers()</codeph> 将 int 变量 <codeph>a</codeph> 和 <codeph>c</codeph> 相加。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class IntExample extends Sprite {    
        public function IntExample() {
            var a:int = 512;
            var b:int = -128;
            
            trace(addIntegers(a, b)); // 384

            var c:int = parseInteger("32");
            
            trace(addIntegers(a, c)); // 544
        }
            
        public function addIntegers(a:int, b:int):int {
            return a + b;
        }
        
        public function parseInteger(str:String):int {
            var num:Number = parseInt(str);
            if(!isNaN(num) &amp;&amp; num &lt;= int.MAX_VALUE &amp;&amp; num >= int.MIN_VALUE) {
                return int(num);
            }
            
            return 0;
        }
        
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="uint.html"><linktext>uint</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="int:int"><apiName>int</apiName><shortdesc>
	 构造函数；创建新的 int 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要创建的 int 对象的数值，或者要转换为数字的值。如果未提供 <codeph>value</codeph>，则默认值为 0。
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 构造函数；创建新的 int 对象。使用 <codeph>int.toString()</codeph> 和 <codeph>int.valueOf()</codeph> 时，必须使用 int 构造函数。使用 int 对象的属性时，不要使用构造函数。<codeph>new int</codeph> 构造函数主要用作占位符。int 对象与 <codeph>int()</codeph> 函数不同，后者将参数转换为原始值。
	 
 	 </apiDesc><example>以下代码构造新的 int 对象：
	 <pre>
	 var n1:int = new int(3.4);
	 var n2:int = new int(-10);
	 </pre>
	 
	 
	 </example></apiConstructorDetail><related-links><link href="#int/toString()"><linktext>int.toString()</linktext></link><link href="#int/valueOf()"><linktext>int.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="int:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      返回数字的字符串表示形式（采用指数表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fractionDigits</codeph> 参数不在 0 到 20 的范围内，则会引发异常。
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 0 和 20（含）之间的整数，表示所需的小数位数。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回数字的字符串表示形式（采用指数表示法）。字符串在小数点前面包含一位，在小数点后面最多包含 20 位（在 <codeph>fractionDigits</codeph> 参数中指定）。
      </apiDesc><example conref="examples\Number.toExponential.1.as"> 下面的示例演示 <codeph>toExponential(2)</codeph> 如何返回采用指数表示法的字符串。
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     返回数字的字符串表示形式（采用定点表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fractionDigits</codeph> 参数不在 0 到 20 的范围内，则会引发异常。
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 0 和 20（含）之间的整数，表示所需的小数位数。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回数字的字符串表示形式（采用定点表示法）。定点表示法是指字符串的小数点后面包含特定的位数（在 <codeph>fractionDigits</codeph> 参数中指定）。<codeph>fractionDigits</codeph> 参数的有效范围为 0 到 20。如果指定的值在此范围外，则会引发异常。
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> 下面的示例演示 <codeph>toFixed(3)</codeph> 如何返回舍入到小数点后三位的字符串。
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> 下面的示例演示 <codeph>toFixed(2)</codeph> 如何返回添加尾随 0 的字符串。
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      返回数字的字符串表示形式（采用指数表示法或定点表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>precision</codeph> 参数不在 1 到 21 的范围内，则会引发异常。
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 1 和 21（含）之间的整数，表示结果字符串中所需的位数。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回数字的字符串表示形式（采用指数表示法或定点表示法）。字符串将包含 <codeph>precision</codeph> 参数中指定的位数。
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> 下面的示例演示 <codeph>toPrecision(3)</codeph> 如何返回只包含三位数的字符串。由于不需要指数表示法，因此字符串使用定点表示法。
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> 下面的示例演示 <codeph>toPrecision(3)</codeph> 如何返回只包含三位数的字符串。由于结果数字中没有足够的位数来使用定点表示法，因此字符串使用指数表示法。
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:toString"><apiName>toString</apiName><shortdesc>
	 返回 int 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>指定要用于数字到字符串的转换的基数（从 2 到 36）。如果未指定 <codeph>radix</codeph> 参数，则默认值为 10。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回 <codeph>int</codeph> 对象的字符串表示形式。
	 
	 </apiDesc><example>下面的示例将 2 和 8 用于 <codeph>radix</codeph> 参数，并返回包含数字 9 的相应表示形式的字符串：
	 <pre>
	 var myint:int = new int(9);
	 trace(myint.toString(2)); // 1001
	 trace(myint.toString(8)); // 11
	 </pre>
	 <p>下面的示例生成十六进制值。</p>
	 <pre>
	 var r:int = new int(250);
	 var g:int = new int(128);
	 var b:int = new int(114);
	 var rgb:String = "0x"+ r.toString(16)+g.toString(16)+b.toString(16);
	 trace(rgb); // 0xfa8072
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="int:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 返回指定 int 对象的原始值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>int 值。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回指定 int 对象的原始值。
	 
 	 </apiDesc><example>下面的示例生成 <codeph>numSocks</codeph> 对象的原始值。
	 <pre>
	 var numSocks:int = new int(2);
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="int:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	可表示的最大 32 位带符号整数为 2,147,483,647。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2147483647</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc> 
	可表示的最大 32 位带符号整数为 2,147,483,647。
	
    </apiDesc><example>以下 ActionScript 在<ph outputclass="flashonly">输出面板</ph><ph outputclass="flexonly">日志文件</ph>中<ph outputclass="flashonly">显示</ph><ph outputclass="flexonly">写入</ph>可表示的最大和最小 int 对象：
	<pre>
	trace("int.MIN_VALUE = "+int.MIN_VALUE);
	trace("int.MAX_VALUE = "+int.MAX_VALUE);
	</pre>
	<p>此代码<ph outputclass="flexonly">记录</ph><ph outputclass="flashonly">显示</ph>下列值：</p>
	<pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
	</pre>
	
	
	</example></apiValueDetail></apiValue><apiValue id="int:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 可表示的最小 32 位带符号整数为 -2,147,483,648。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>int, int.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>-2147483648</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 可表示的最小 32 位带符号整数为 -2,147,483,648。
	 
 	 </apiDesc><example>以下 ActionScript 在<ph outputclass="flashonly">输出面板</ph><ph outputclass="flexonly">日志文件</ph>中<ph outputclass="flashonly">显示</ph><ph outputclass="flexonly">写入</ph>可表示的最大和最小 int 对象：
     <pre>
     trace("int.MIN_VALUE = "+int.MIN_VALUE);
     trace("int.MAX_VALUE = "+int.MAX_VALUE);
     </pre>
     <p>此代码<ph outputclass="flexonly">记录</ph><ph outputclass="flashonly">显示</ph>下列值：</p>
     <pre>
	int.MIN_VALUE = -2147483648
	int.MAX_VALUE = 2147483647
     </pre>
     
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Number"><apiName>Number</apiName><shortdesc>
 表示 IEEE-754 双精度浮点数的数据类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number object, number, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Number 类是 <codeph>Number</codeph> 数据类型的简单包装对象。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 表示 IEEE-754 双精度浮点数的数据类型。使用与 Number 类关联的方法和属性可以操作基元数值。此类与 JavaScript 的 Number 类完全相同。
 <p>但 Number 类的属性是静态属性，这意味着无需对象就可以使用这些属性，因此您不需要使用构造函数。</p>
 <p>Number 数据类型符合双精度 IEEE-754 标准。 </p>
 <p>需要使用浮点值时，Number 数据类型很有用。Flash Player 处理 int 和 uint 数据类型比处理 Number 数据类型更高效，但当所需值的范围超过 int 和 uint 数据类型的有效范围时，Number 数据类型很有用。Number 类可用于表示超出 int 和 uint 数据类型有效范围的整数值。Number 数据类型可使用多达 53 位来表示整数值，而 int 和 uint 则只能使用 32 位。Number 类型的变量的默认值为 <codeph>NaN</codeph>（非数字）。</p>
 
 </apiDesc><example conref="examples\NumberExample.as"> 下面的示例说明如何将一个具有六位小数的数字截断（使用舍入）为一个具有两位小数的数字。
<codeblock>

package {
    import flash.display.Sprite;

    public class NumberExample extends Sprite {
        public function NumberExample() {
            var num:Number = new Number(10.456345);
            var str:String = num.toFixed(2);
            trace(num); // 10.456345
            trace(str); // 10.46
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="uint.html"><linktext>uint</linktext></link></related-links><apiConstructor id="Number:Number"><apiName>Number</apiName><shortdesc>
  用指定值创建一个 Number 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>已创建的 Number 实例的数值，或者转换为 Number 的值。如果未指定 <codeph>num</codeph>，则默认值为 0。使用此构造函数时不指定 <codeph>num</codeph> 参数与声明 Number 类型的变量时不赋值（如 <codeph>var myNumber:Number</codeph>）不同，后者的默认值为 <codeph>NaN</codeph>。未赋值的数字是未定义的，与 <codeph>new Number(undefined)</codeph> 等效。
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>用指定的值创建一个 Number。
  
  </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
  用指定值创建一个 Number 对象。此构造函数与 <codeph>Number()</codeph> 公共本机函数效果相同，后者可将其它类型的对象转换为基元数值。
  
  </apiDesc></apiConstructorDetail><related-links><link href="#Number/toString()"><linktext>Number.toString()</linktext></link><link href="#Number/valueOf()"><linktext>Number.valueOf()</linktext></link></related-links></apiConstructor><apiOperation id="Number:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
	  返回数字的字符串表示形式（采用指数表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fractionDigits</codeph> 参数不在 0 到 20 的范围内，则会引发异常。
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 0 和 20（含）之间的整数，表示所需的小数位数。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  返回数字的字符串表示形式（采用指数表示法）。字符串在小数点前面包含一位，在小数点后面最多包含 20 位（在 <codeph>fractionDigits</codeph> 参数中指定）。
	  </apiDesc><example conref="examples\Number.toExponential.1.as"> 下面的示例演示 <codeph>toExponential(2)</codeph> 如何返回采用指数表示法的字符串。
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
	 返回数字的字符串表示形式（采用定点表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fractionDigits</codeph> 参数不在 0 到 20 的范围内，则会引发异常。
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 0 和 20（含）之间的整数，表示所需的小数位数。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回数字的字符串表示形式（采用定点表示法）。定点表示法是指字符串的小数点后面包含特定的位数（在 <codeph>fractionDigits</codeph> 参数中指定）。<codeph>fractionDigits</codeph> 参数的有效范围为 0 到 20。如果指定的值在此范围外，则会引发异常。
	 
	 </apiDesc><example conref="examples\Number.toFixed.1.as"> 下面的示例演示 <codeph>toFixed(3)</codeph> 如何返回舍入到小数点后三位的字符串。
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> 下面的示例演示 <codeph>toFixed(2)</codeph> 如何返回添加尾随 0 的字符串。
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
	  返回数字的字符串表示形式（采用指数表示法或定点表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>precision</codeph> 参数不在 1 到 21 的范围内，则会引发异常。
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 1 和 21（含）之间的整数，表示结果字符串中所需的位数。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
	  返回数字的字符串表示形式（采用指数表示法或定点表示法）。字符串将包含 <codeph>precision</codeph> 参数中指定的位数。
	  </apiDesc><example conref="examples\Number.toPrecision.1.as"> 下面的示例演示 <codeph>toPrecision(3)</codeph> 如何返回只包含三位数的字符串。由于不需要指数表示法，因此字符串使用定点表示法。
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> 下面的示例演示 <codeph>toPrecision(3)</codeph> 如何返回只包含三位数的字符串。由于结果数字中没有足够的位数来使用定点表示法，因此字符串使用指数表示法。
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:toString"><apiName>toString</apiName><shortdesc>
 返回指定的 Number 对象 (myNumber) 的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.tostring, tostring
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Number 对象作为字符串的数值表示形式。
 
 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>10</apiData><apiDesc>指定要用于数字到字符串的转换的基数（从 2 到 36）。如果未指定 <codeph>radix</codeph> 参数，则默认值为 10。
 
 </apiDesc></apiParam><apiTipTexts><apiTipText>以指定的 radix 参数作为基数，返回此 Number 的字符串表示形式。
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 返回指定的 Number 对象 (<codeph><i>myNumber</i></codeph>) 的字符串表示形式。如果 Number 对象的值是没有前导零的小数（如 <codeph>.4</codeph>），则 <codeph>Number.toString()</codeph> 将添加一个前导零 (<codeph>0.4</codeph>)。
 
 
 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Number:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
 返回指定的 Number 对象的基元值类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Number 对象的基元类型的值。
 
 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回指定的 Number 对象的基元值类型。
 
 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 返回指定的 Number 对象的基元值类型。
 
 </apiDesc></apiOperationDetail></apiOperation><apiValue id="Number:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc>
  最大可表示数（双精度 IEEE-754）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.max_value, max_value, max value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>最大可表示数（双精度 IEEE-754）。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  最大可表示数（双精度 IEEE-754）。此数字大约为 1.79e+308。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
  可表示的最小非负非零数（双精度 IEEE-754）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.min_value, min_value, min value
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>最小可表示数（双精度 IEEE-754）。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  可表示的最小非负非零数（双精度 IEEE-754）。此数字大约为 5e-324。可表示的全部数字中，最小数字实际为 <codeph>-Number.MAX_VALUE</codeph>。
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NEGATIVE_INFINITY"><apiName>NEGATIVE_INFINITY</apiName><shortdesc>
  指定表示负无穷大的 IEEE-754 值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.negative_infinity, negative_infinity, negative infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>指定表示负无穷大的 IEEE-754 值。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  指定表示负无穷大的 IEEE-754 值。此属性的值与常数 <codeph>-Infinity</codeph> 的值相同。
  <p>
  负无穷大是当数学运算或函数返回的值超过可表示的负值时，返回的一个特殊数值。
  </p>
  
  </apiDesc></apiValueDetail></apiValue><apiValue id="Number:NaN"><apiName>NaN</apiName><shortdesc>
  表示“非数字”(NaN) 的 IEEE-754 值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.nan, nan, not a number
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>表示“非数字”(NaN) 的 IEEE-754 值。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  表示“非数字”(<codeph>NaN</codeph>) 的 IEEE-754 值。
  
  </apiDesc></apiValueDetail><related-links><link href="package.html#isNaN()"><linktext>isNaN()</linktext></link></related-links></apiValue><apiValue id="Number:POSITIVE_INFINITY"><apiName>POSITIVE_INFINITY</apiName><shortdesc>
  指定表示正无穷大的 IEEE-754 值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.positive_infinity, positive_infinity, positive infinity, infinity
   
   </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>指定表示正无穷大的 IEEE-754 值。
  
  </apiTipText></apiTipTexts></apiValueDef><apiDesc>
  指定表示正无穷大的 IEEE-754 值。此属性的值与常数 <codeph>Infinity</codeph> 的值相同。
  <p>
  正无穷大是当数学运算或函数返回的值大于可表示的值时，返回的一个特殊数值。
  </p>
  
  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
 DefinitionError 类表示一种错误，如果用户代码试图定义已定义过的标识符，则会出现该错误。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><helpid>
  
  </helpid></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>如果代码试图重新定义类、接口或函数，则会引发 DefinitionError。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 DefinitionError 类表示一种错误，如果用户代码试图定义已定义过的标识符，则会出现该错误。该错误通常发生在重新定义类、接口和函数时。
 
 </apiDesc></apiClassifierDetail><apiConstructor id="DefinitionError:DefinitionError"><apiName>DefinitionError</apiName><shortdesc>
	 创建一个新的 DefinitionError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 DefinitionError 对象。
	  
	  </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Function"><apiName>Function</apiName><shortdesc>
 函数是可在 ActionScript 中调用的基本代码单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>Function 类用于表示内置或用户定义的函数。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 函数是可在 ActionScript 中调用的基本代码单位。ActionScript 中用户定义的函数和内置函数都由 Function 对象来表示，该对象是 Function 类的实例。
 <p>类的方法与 Function 对象略有不同。与普通函数对象不同，方法和与其关联的类对象紧密关联。因此，方法或属性具有在同一类的所有实例中共享的定义。可以从实例提取方法并将其处理为“绑定”方法（保留与原始实例的链接）。对于绑定方法，<codeph>this</codeph> 关键字指向实现该方法的原始对象。对于函数，<codeph>this</codeph> 在调用函数时指向关联对象。</p>
 
 
 </apiDesc><example conref="examples\FunctionExample.as"> 下例使用 <codeph>FunctionExample</codeph>、<codeph>SimpleCollection</codeph>、<codeph>EventBroadcaster</codeph> 和 <codeph>EventListener</codeph> 类显示 ActionScript 中函数的各种用法。这是由以下步骤完成的：
 <ol>
    <li><codeph>FunctionExample</codeph> 的构造函数创建一个名为 <codeph>simpleColl</codeph> 的局部变量，该变量用一个整数数组填充，其范围从 <codeph>1</codeph> 到 <codeph>8</codeph>。 </li>
    <li>使用 <codeph>trace()</codeph> 打印 <codeph>simpleColl</codeph> 对象。</li>
  <li>将 EventListener 对象 <codeph>listener</codeph> 添加到 <codeph>simpleColl</codeph> 中。</li>
  <li>调用 <codeph>insert()</codeph> 和 <codeph>remove()</codeph> 函数时，侦听器响应其事件。</li>
    <li>创建第二个 SimpleCollection 对象，名为 <codeph>greaterThanFourColl</codeph>。</li>
    <li>赋予 <codeph>greaterThanFourColl</codeph> 对象 <codeph>simpleColl.select()</codeph> 的结果，后者包含参数 <codeph>4</codeph> 和一个匿名函数。SimpleCollection 对象的选择方法是一个内部迭代器，它使用匿名函数参数作为块。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class FunctionExample extends Sprite {
        public function FunctionExample() {
            var simpleColl:SimpleCollection;
            simpleColl = new SimpleCollection(0, 1, 2, 3, 4, 5, 6, 7, 8);
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 8

            var listener:EventListener = new EventListener();
            simpleColl.addListener(listener);
            simpleColl.insert(9);        // itemInsertedHandler: 9
            simpleColl.remove(8);        // itemRemovedHandler: 8
            trace(simpleColl);        // 0, 1, 2, 3, 4, 5, 6, 7, 9

            var greaterThanFourColl:SimpleCollection;
            greaterThanFourColl = simpleColl.select(4, function(item:int, value:int){ return item > value });
            trace(greaterThanFourColl);    // 5, 6, 7, 9
        }
    }
}
    
import flash.display.Sprite;
    
class EventBroadcaster {
    private var listeners:Array;

    public function EventBroadcaster() {
        listeners = new Array();
    }
        
    public function addListener(obj:Object):void {
        removeListener(obj);
        listeners.push(obj);
    }
        
    public function removeListener(obj:Object):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            if(listeners[i] == obj) {
                listeners.splice(i, 1);
            }
        }
    }
    
    public function broadcastEvent(evnt:String, ...args):void {
        for(var i:uint = 0; i &lt; listeners.length; i++) {
            listeners[i][evnt].apply(listeners[i], args);
        }
    }    
}
    
class SimpleCollection extends EventBroadcaster {
    private var arr:Array;
        public function SimpleCollection(... args) {
        arr = (args.length == 1 &amp;&amp; !isNaN(args[0])) ? new Array(args[0]) : args;
    }
        
    public function insert(obj:Object):void {
        remove(obj);
        arr.push(obj);
        broadcastEvent("itemInsertedHandler", obj);
    }
        
    public function remove(obj:Object):void {
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(arr[i] == obj) {
                var obj:Object = arr.splice(i, 1)[0];
                broadcastEvent("itemRemovedHandler", obj);
            }
        }
    }

    public function select(val:int, fn:Function):SimpleCollection {
        var col:SimpleCollection = new SimpleCollection();
        for(var i:uint = 0; i &lt; arr.length; i++) {
            if(fn.call(this, arr[i], val)) {
                col.insert(arr[i]);
            }
        }
        return col;
    }
        
    public function toString():String {
        var str:String = new String();
        for(var i:uint = 0; i &lt; arr.length - 1; i++) {
            str += arr[i] + ", ";
        }
        str += arr[arr.length - 1];
        return str;
    }
}

class EventListener {
    public function EventListener() {
    }
    
    public function itemInsertedHandler(obj:Object):void {
        trace("itemInsertedHandler: " + obj);
    }
    
    public function itemRemovedHandler(obj:Object):void {
        trace("itemRemovedHandler: " + obj);        
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="Function:AS3:apply"><apiName>apply</apiName><shortdesc>
  指定要在 ActionScript 调用的任何函数内使用的 thisObject 的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.apply, apply
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>调用函数指定的任何值。
  
  
  </apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>要应用该函数的对象。
  
  </apiDesc></apiParam><apiParam><apiItemName>argArray</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>其元素作为参数传递给函数的数组。
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>指定在其上调用 Function 的对象实例。
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  指定要在 ActionScript 调用的任何函数内使用的 <codeph>thisObject</codeph> 的值。此方法还指定要传递给任何被调用函数的参数。由于 <codeph>apply()</codeph> 是 Function 类的方法，所以它也是 ActionScript 中每个 Function 对象的方法。 
  <p>与 <codeph>Function.call()</codeph> （它将参数指定为用逗号分隔的列表）不同，该方法将参数指定为一个 Array 对象。如果在脚本实际执行前，无法知道要传递的参数的数量，那么这种方法通常很有用。</p>
  <p>返回被调用函数指定为返回值的值。</p>

  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/call()"><linktext>Function.call()</linktext></link></related-links></apiOperation><apiOperation id="Function:AS3:call"><apiName>call</apiName><shortdesc>
  调用 Function 对象表示的函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Function, Function.call, call
  
  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>thisArg</apiItemName><apiType value=""/><apiData>unknown</apiData><apiDesc>指定函数体内 <codeph>thisObject</codeph> 值的对象。
  
  </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>要传递给该函数的参数。可以指定 0 个或多个参数。
  
  </apiDesc></apiParam><apiTipTexts><apiTipText>调用该函数。 
  
  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
  调用 Function 对象表示的函数。ActionScript 中的每个函数都由一个 Function 对象来表示，所以所有的函数都支持此方法。 
  <p>几乎在所有的情形下，都可以使用函数调用运算符 (<codeph>()</codeph>) 来代替此方法。函数调用运算符使代码简明易读。如果需要显式控制函数调用中的 <codeph>thisObject</codeph> 参数，则此方法很有用。通常，如果在函数体内将函数作为对象的方法来调用，则 <codeph>thisObject</codeph> 设置为 <codeph>myObject</codeph>，如下例所示：</p>
  <codeblock>
  myObject.myMethod(1, 2, 3);
  </codeblock>
  <p>在某些情况下，您可能希望 <codeph>thisObject</codeph> 指向其它位置，例如，函数必须作为对象的方法进行调用，但该函数实际上并不作为该对象的方法进行存储的情况。</p>
  <codeblock>
  myObject.myMethod.call(myOtherObject, 1, 2, 3); 
  </codeblock>
  <p>可以为 <codeph>thisObject</codeph> 参数传递值 <codeph>null</codeph>，以便将函数作为一个常规函数而非对象的方法来调用。例如，以下函数调用是等效的：</p>
  <codeblock>
  Math.sin(Math.PI / 4)
  Math.sin.call(null, Math.PI / 4)
  </codeblock>
  
  <p>返回被调用函数指定为返回值的值。</p>
  
  </apiDesc></apiOperationDetail><related-links><link href="#Function/apply()"><linktext>Function.apply()</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="globalClassifier:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
 由于以下原因之一，当发生分析错误时将引发 SyntaxError 异常：</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, SyntaxError
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 由于以下原因之一，当发生分析错误时将引发 SyntaxError 异常： 
 <ul>
   <li>RegExp 类分析无效的正则表达式。</li>
   <li>XML 类分析无效 XML 内容。</li>
 </ul>
 
 </apiDesc></apiClassifierDetail><related-links><link href="#RegExp"><linktext>RegExp 类</linktext></link><link href="#XML"><linktext>XML 类</linktext></link></related-links><apiConstructor id="SyntaxError:SyntaxError"><apiName>SyntaxError</apiName><shortdesc>
	 创建一个新的 SyntaxError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>包含与 SyntaxError 对象关联的消息。 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 SyntaxError 对象。
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:Boolean"><apiName>Boolean</apiName><shortdesc>
Boolean 对象是一种数据类型，其值为 true 或 false（用于进行逻辑运算）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><refpath>Objects/Core/Boolean/
 
 </refpath></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
Boolean 对象是一种数据类型，它可以使用 <codeph>true</codeph> 或 <codeph>false</codeph>（用于进行逻辑运算）两个值中一个值。使用 Boolean 类可检索 Boolean 对象的基元数据类型或字符串表示形式。 

<p>要创建 Boolean 对象，可以使用构造函数、全局函数，或赋予文字值。这与所使用的技术无关；在 ActionScript 3.0 中，上述三种技术功效相同。（这与 JavaScript 不同，JavaScript 中的 Boolean 对象与 Boolean 原始类型不同。）</p>

  <p>下面这几行代码是等同的：</p>
<codeblock rev="3.0">
var flag:Boolean = true;
var flag:Boolean = new Boolean(true);
var flag:Boolean = Boolean(true);
</codeblock>

 </apiDesc><example conref="examples\BooleanExample.as"> 下面的示例切换并显示与 Boolean 对象相对应的每个值：
<codeblock>
 package {
    import flash.display.Sprite;

    public class BooleanExample extends Sprite {
        private var flag:Boolean;

        public function BooleanExample() {
            trace(flag);    // false
            toggle();
            trace(flag);    // true
            toggle();
            trace(flag);    // false
        }
        
        private function toggle():void{
            flag = !flag;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Boolean:Boolean"><apiName>Boolean</apiName><shortdesc>
 创建一个具有指定值的 Boolean 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new boolean, constructor
  
  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>false</apiData><apiDesc>任何表达式。 
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 创建一个具有指定值的 Boolean 对象。如果省略 <codeph>expression</codeph> 参数，则将 Boolean 对象的值初始化为 <codeph>false</codeph>。如果为 <codeph>expression</codeph> 参数指定值，则该方法将计算它并根据全局 <codeph>Boolean()</codeph> 函数中的规则以布尔值返回结果。
 
 </apiDesc><example>以下代码创建一个新的 Boolean 对象，该对象的值初始化为称为 <codeph>myBoolean</codeph> 的 <codeph>false</codeph> 值：
 <codeblock rev="3.0">
 var myBoolean:Boolean = new Boolean();
 </codeblock>
 
 </example></apiConstructorDetail><related-links><link href="package.html#Boolean()"><linktext>Boolean()</linktext></link></related-links></apiConstructor><apiOperation id="Boolean:AS3:toString"><apiName>toString</apiName><shortdesc>
	  返回 Boolean 对象的字符串表示形式（“true”或“false”）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.toString, toString
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>字符串 <codeph>"true"</codeph> 或 <codeph>"false"</codeph>。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	  返回 Boolean 对象的字符串表示形式（<codeph>"true"</codeph> 或 <codeph>"false"</codeph>）。该输出未本地化，无论系统使用何种语言，均为 <codeph>"true"</codeph> 或 <codeph>"false"</codeph>。
	 
 	 </apiDesc><example>本示例创建一个 Boolean 类型的变量，然后使用 <codeph>toString()</codeph> 方法将该值转换为字符串以便在字符串数组中使用：
	 <codeblock rev="3.0">
	 var myStringArray:Array = new Array("yes", "could be");
	 var myBool:Boolean = 0;
	 myBool.toString();
	 myStringArray.push(myBool);
	 trace(myStringArray); // yes,could be,false
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="Boolean:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 如果指定的 Boolean 对象的值为 true，则返回 true；否则返回 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>boolean.valueOf, valueOf
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个布尔值。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 如果指定的 Boolean 对象的值为 true，则返回 <codeph>true</codeph>；否则返回 <codeph>false</codeph>。  
	 
	 </apiDesc><example>以下示例显示此方法的工作方式，同时将新 Boolean 对象的值显示为 <codeph>false</codeph>：
	 <codeblock rev="3.0">
	 var myBool:Boolean = new Boolean();
	 trace(myBool.valueOf());   // false
	 myBool = (6==3+3);
	 trace(myBool.valueOf());   // true  
	 </codeblock>
	 
	 
	 </example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:XMLList"><apiName>XMLList</apiName><shortdesc>
 XMLList 类中包含用于处理一个或多个 XML 元素的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XMLList
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 XMLList 类中包含用于处理一个或多个 XML 元素的方法。XMLList 对象可以表示一个或多个 XML 对象或元素（包括多个节点或属性），因此，可以对作为一个组的多个元素调用方法，也可以对集合中的各个元素分别调用方法。
 <p>如果 XMLList 对象只包含一个 XML 元素，那么可以直接对 XMLList 对象使用 XML 类方法。在下面的示例中，<codeph>example.two</codeph> 为长度 1 的 XMLList 对象，因此可以对它调用任意 XML 方法。</p>
 <codeblock>
 var example2 = &lt;example>&lt;two>2&lt;/two>&lt;/example>;</codeblock>
 <p>如果试图对包含多个 XML 元素的 XMLList 对象使用 XML 类方法，则会引发异常。此时，应遍历 XMLList 集合（例如，使用 <codeph>for each..in</codeph> 语句），并对集合中的每个 XML 对象应用该方法。</p>
 
 </apiDesc><example conref="examples\XMLListExample.as"> 下例创建名为 <codeph>books</codeph> 的 XML 属性并将多个带有 <codeph>book publisher</codeph> 和 <codeph>name</codeph> 标签的项添加到名为 <codeph>books</codeph> 的节点。然后调用 <codeph>showBooksByPublisher()</codeph> 方法，该方法接收 XMLList 并返回与发行人“Addison-Wesley”匹配的每一项。
<codeblock>
package {
    import flash.display.Sprite;

    public class XMLListExample extends Sprite {
        private var books:XML;

        public function XMLListExample() {
            books =    &lt;books>
                        &lt;book publisher="Addison-Wesley" name="Design Patterns" />
                        &lt;book publisher="Addison-Wesley" name="The Pragmatic Programmer" />
                        &lt;book publisher="Addison-Wesley" name="Test Driven Development" />
                        &lt;book publisher="Addison-Wesley" name="Refactoring to Patterns" />
                        &lt;book publisher="O'Reilly Media" name="The Cathedral &amp; the Bazaar" />
                        &lt;book publisher="O'Reilly Media" name="Unit Test Frameworks" />
                    &lt;/books>;

            showBooksByPublisher("Addison-Wesley");
        }

        private function showBooksByPublisher(name:String):void {
            var results:XMLList = books.book.(@publisher == name);
            showList(results);
        }

        private function showList(list:XMLList):void {
            var item:XML;
            for each(item in list) {
                trace("item: " + item.toXMLString());
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="statements.html#for_each..in"><linktext>for each..in</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#QName"><linktext>QName</linktext></link></related-links><apiConstructor id="XMLList:XMLList"><apiName>XMLList</apiName><shortdesc>
	创建一个新的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList 
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>任何可以通过使用顶级 <codeph>XMLList()</codeph> 函数转换为 XMLList 对象的对象。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	创建一个新的 XMLList 对象。
	
	</apiDesc></apiConstructorDetail><related-links><link href="#global/XMLList()"><linktext>top-level XMLList() function</linktext></link></related-links></apiConstructor><apiOperation id="XMLList:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	调用每个 XML 对象的 attribute() 方法并返回结果的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>匹配 XML 对象的 XMLList 对象或空 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>想要包含在 XMLList 对象的属性名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>attribute()</codeph> 方法并返回结果的 XMLList 对象。结果与给定的 <codeph>attributeName</codeph> 参数相匹配。如果不匹配，则 <codeph>attribute()</codeph> 方法将返回一个空 XMLList 对象。
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	调用每个 XML 对象的 attributes() 方法，并返回每个 XML 对象属性的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>各个 XML 对象属性的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>attributes()</codeph> 方法，并返回每个 XML 对象属性的 XMLList 对象。 
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:child"><apiName>child</apiName><shortdesc>
	调用每个 XML 对象的 child() 方法，并返回包含有序结果的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>与输入参数匹配的子节点的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>XML 子对象的元素名称或整数。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>child()</codeph> 方法，并返回包含有序结果的 XMLList 对象。
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:children"><apiName>children</apiName><shortdesc>
	调用每个 XML 对象的 children() 方法，并返回包含结果的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象中子对象的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>children()</codeph> 方法，并返回包含结果的 XMLList 对象。
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/children()"><linktext>XML.children()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:comments"><apiName>comments</apiName><shortdesc>
	调用每个 XML 对象的 comments() 方法，并返回注释的 XMLList。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象中注释的 XMLList。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>comments()</codeph> 方法，并返回注释的 XMLList。
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/comments()"><linktext>XML.comments()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:contains"><apiName>contains</apiName><shortdesc>
	检查 XMLList 对象是否包含与给定的 value 参数相等的 XML 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 XMLList 包含 <codeph>value</codeph> 参数中声明的 XML 对象，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>与当前 XMLList 对象比较的 XML 对象。 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	检查 XMLList 对象是否包含与给定的 <codeph>value</codeph> 参数相等的 XML 对象。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:copy"><apiName>copy</apiName><shortdesc>
	返回给定的 XMLList 对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XMLList 对象的副本。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回给定的 XMLList 对象的副本。该副本为整个节点树的副本。复制的 XML 对象没有父级，如果尝试调用 <codeph>parent()</codeph> 方法，将返回 <codeph>null</codeph>。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	返回包含给定 name 参数的 XML 对象的所有后代（子级、孙级、曾孙级等）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>原始列表中 XML 对象的匹配后代（子级、孙级等）的 XMLList 对象。如果没有后代，则返回空的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>要匹配的元素的名称。
	
 	</apiDesc></apiParam></apiOperationDef><apiDesc>
	返回包含给定 <codeph>name</codeph> 参数的 XML 对象的所有后代（子级、孙级、曾孙级等）。<codeph>name</codeph> 参数可以为 QName 对象、String 数据类型或随后转换为 String 数据类型的任何其它数据类型。
	
	<p>要返回所有后代，请使用星号 (*) 参数。如果未传递任何参数，则传递字符串“*”，并返回此 XML 对象的所有后代。</p>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/descendants()"><linktext>XML.descendants()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:elements"><apiName>elements</apiName><shortdesc>
	调用每个 XML 对象的 elements() 方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.elements, elements
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象的匹配子元素的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>要匹配的元素的名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>elements()</codeph> 方法。将 <codeph>name</codeph> 参数传递给 <codeph>descendants()</codeph> 方法。如果未传递任何参数，则将字符串“*”传递给 <codeph>descendants()</codeph> 方法。
	
 	</apiDesc></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	检查 XMLList 对象是否包含复杂内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 XMLList 对象包含复杂内容，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	检查 XMLList 对象是否包含复杂内容。如果 XMLList 对象不为空且以下任一条件为 true，则该对象将视为包含复杂内容： 
	
	<ul>
	  <li>XMLList 对象包含一个具有复杂内容的 XML 项。</li>
	  <li>XMLList 对象包含元素。</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	检查由 p 指定的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果此参数存在，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要匹配的属性。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	检查由 <codeph>p</codeph> 指定的属性。 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	检查 XMLList 对象是否包含简单内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 XMLList 包含简单内容，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	检查 XMLList 对象是否包含简单内容。如果以下一个或多个条件为 true，则将 XMLList 对象视为包含简单内容：
	<ul>
	  <li>XMLList 对象为空</li>
	  <li>XMLList 对象包含单个带有简单内容的 XML 项</li>
	  <li>XMLList 对象不包含元素</li>
	</ul>
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:length"><apiName>length</apiName><shortdesc>
	返回 XMLList 对象中的属性数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XMLList 对象中的属性数。 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XMLList 对象中的属性数。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	合并相邻的文本节点，并删除下面每一项中的空文本节点：XMLList 中的所有文本节点、XMLList 中包含的所有 XML 对象，以及 XMLList 中的所有 XML 对象的后代。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>标准化的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	合并相邻的文本节点，并删除下面每一项中的空文本节点：XMLList 中的所有文本节点、XMLList 中包含的所有 XML 对象，以及 XMLList 中的所有 XML 对象的后代。 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:parent"><apiName>parent</apiName><shortdesc>
	如果 XMLList 对象中的所有项具有相同的父级，则返回 XMLList 对象的父级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>返回父级 XML 对象。
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	如果 XMLList 对象中的所有项具有相同的父级，则返回 XMLList 对象的父级。如果 XMLList 对象没有父级或者父级不同，则方法将返回 <codeph>undefined</codeph>。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	如果提供了 name 参数，则列出具有此名称的处理指令所属的 XMLList 对象的所有子级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>包含每个 XML 对象的处理指令的 XMLList 对象。
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>要匹配的处理指令的名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	如果提供了 <codeph>name</codeph> 参数，则列出具有此名称的处理指令所属的 XMLList 对象的所有子级。如果没有参数，则方法将列出包含任意处理指令的 XMLList 对象的所有子级。
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/processingInstructions()"><linktext>XML.processingInstructions()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	检查属性 p 所在的属性集是否可在应用于 XMLList 对象的 for..in 语句中遍历。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果该属性可以在 <codeph>for..in</codeph> 语句中，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要检查的属性的索引。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	检查属性 <codeph>p</codeph> 所在的属性集是否可在应用于 XMLList 对象的 <codeph>for..in</codeph> 语句中遍历。只有 <codeph>toNumber(p)</codeph> 大于等于 0 且小于 XMLList 对象的长度时，才为 <codeph>true</codeph>。 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XMLList:AS3:text"><apiName>text</apiName><shortdesc>
	调用每个 XML 对象的 text() 方法并返回包含结果的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个 XMLList 对象，其中包含表示 XML 文本节点的 XMLList 对象的所有 XML 属性。
	
 	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	调用每个 XML 对象的 <codeph>text()</codeph> 方法并返回包含结果的 XMLList 对象。
	
	</apiDesc></apiOperationDetail><related-links><link href="#XML/text()"><linktext>XML.text()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toString"><apiName>toString</apiName><shortdesc>
	返回 XMLList 对象中所有 XML 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象的字符串表示形式。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XMLList 对象中所有 XML 对象的字符串表示形式。此转换的规则取决于 XML 对象包含的是简单内容还是复杂内容：
	
	<ul>
		<li>如果 XML 对象包含简单内容，<codeph>toString()</codeph> 将返回 XML 对象的字符串内容，但从中除去了以下内容：开始标签、属性、命名空间声明和结束标签。</li> 
	</ul>
	
	<ul>
		<li> 如果 XML 对象包含复杂内容，<codeph>toString()</codeph> 将返回 XML 编码字符串，该字符串表示完整的 XML 对象，包括开始标签、属性、命名空间声明和结束标签。</li>
	</ul>
	
	<p>要每次都返回完整的 XML 对象，请使用 <codeph>toXMLString()</codeph> 方法。</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> 下面的示例演示当 XML 对象包含简单内容时 <codeph>toString()</codeph> 方法的返回值：
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> 下面的示例演示当 XML 对象包含复杂内容时 <codeph>toString()</codeph> 方法的返回值：
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XMLList/hasComplexContent()"><linktext>hasComplexContent()</linktext></link><link href="#XMLList/hasSimpleContent()"><linktext>hasSimpleContent()</linktext></link><link href="#XMLList/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	返回 XMLList 对象中所有 XML 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象的字符串表示形式。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XMLList 对象中所有 XML 对象的字符串表示形式。与 <codeph>toString()</codeph> 方法不同，<codeph>toXMLString()</codeph> 方法始终返回 XML 对象的开始标签、属性和结束标签，与 XML 对象包含的是简单内容还是复杂内容无关。（<codeph>toString()</codeph> 方法去除包含简单内容的 XML 对象的这些项。）
	
	
	</apiDesc></apiOperationDetail><related-links><link href="#XMLList/toString()"><linktext>toString()</linktext></link></related-links></apiOperation><apiOperation id="XMLList:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	返回 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XMLList, XMLList.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>返回当前 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XMLList 对象。 
	
	</apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="globalClassifier:Error"><apiName>Error</apiName><shortdesc>
 Error 类包含有关脚本中出现的错误的信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>脚本中发生错误时将引发 Error。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Error 类包含有关脚本中出现的错误的信息。开发 ActionScript 3.0 应用程序过程中，如果在 Flash Player 的调试版中运行已编译的代码，将弹出对话框显示 Error 类型的异常或子类异常，以帮助您排除代码中的故障。可以使用 <codeph>Error</codeph> 构造函数来创建 Error 对象。通常，将新的 Error 对象从 <codeph>try</codeph> 代码块中引发，然后由 <codeph>catch</codeph> 或 <codeph>finally</codeph> 代码块捕获。
 <p>您也可以创建 Error 类的子类，然后引发该子类的实例。</p>
 
 </apiDesc><example conref="examples\ErrorExample.as"> 以下示例使用 <codeph>ErrorExample</codeph> 类说明如何生成自定义错误。这是由以下步骤完成的：
 <ol>
     <li>声明一个 Array 类型的局部变量 <codeph>nullArray</codeph>，但是请注意，从未创建新的 Array 对象。</li>
     <li>构造函数尝试在错误处理代码段中使用 <codeph>push()</codeph> 方法将值加载到未初始化的数组中，该代码段使用 <codeph>CustomError</codeph> 类捕获自定义错误，该类扩展 <codeph>Error</codeph>。</li>
     <li>引发 CustomError 时，构造函数将其捕获并输出一条错误消息（使用 <codeph>trace()</codeph> 语句）。 </li>
 </ol>
<codeblock>
package
{
    import flash.display.Sprite;
    public class ErrorExample extends Sprite 
    {
        private var nullArray:Array;
        public function ErrorExample() 
        {
            try 
            {
                nullArray.push("item");
            }
            catch(e:Error) 
            {
                throw new CustomError("nullArray is null");
            }
        }
    }
}

class CustomError extends Error 
{
    public function CustomError(message:String) 
    {
        super(message);
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="Error:Error"><apiName>Error</apiName><shortdesc>
	 创建新的 Error 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>与 Error 对象关联的字符串；此参数为可选。 
     </apiDesc></apiParam><apiParam><apiItemName>id</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>与特定错误消息关联的引用数字。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>创建具有指定错误消息的新 Error 实例。
	 
	 </apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	 创建新的 Error 对象。如果指定了 <codeph>message</codeph>，它的值将分配给对象的 <codeph>Error.message</codeph> 属性。
	 
	 
	 </apiDesc><example conref="examples\Error.1.as"> 下例创建一个新的 Error 对象 <codeph>err</codeph>，然后使用 <codeph>Error()</codeph> 构造函数，将字符串 <codeph>"New Error Message"</codeph> 分配给 <codeph>err</codeph>。
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message
</codeblock></example></apiConstructorDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiConstructor><apiOperation id="Error:getStackTrace"><apiName>getStackTrace</apiName><shortdesc>
	 在构造错误时，以字符串形式返回错误的调用堆栈（仅适用于 Flash Player 的调试版和 AIR Debug Launcher (ADL)）；如果未使用 Flash Player 的调试版或 ADL，则返回 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, call stack
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>调用堆栈的字符串表示形式。
	 
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>以可读形式返回错误的调用堆栈。
	 
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 在构造错误时，以字符串形式返回错误的调用堆栈（仅适用于 Flash Player 的调试版和 AIR Debug Launcher (ADL)）；如果未使用 Flash Player 的调试版或 ADL，则返回 <codeph>null</codeph>。如下面的示例所示，返回值的第一行是异常对象的字符串表示形式，后跟堆栈跟踪元素：
	 
	 <codeblock>
	 TypeError: null cannot be converted to an object
	     at com.xyz.OrderEntry.retrieveData(OrderEntry.as:995)
	     at com.xyz.OrderEntry.init(OrderEntry.as:200)
	     at com.xyz.OrderEntry.$construct(OrderEntry.as:148)
   	 </codeblock>
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Error:toString"><apiName>toString</apiName><shortdesc>
	
	默认情况下，返回字符串“Error”；如果已定义，则返回 Error.message 属性中包含的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.toString, toString
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>错误消息。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>将返回错误消息，如果未定义消息，则返回单词“Error”。
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	
	默认情况下，返回字符串 <codeph>"Error"</codeph>；如果已定义，则返回 <codeph>Error.message</codeph> 属性中包含的值。
	
    </apiDesc><example conref="examples\Error.toString.1.as"> 下例创建一个新的 Error 对象 <codeph>err</codeph>，然后使用 <codeph>Error()</codeph> 构造函数，将字符串 <codeph>"New Error Message"</codeph> 分配给 <codeph>err</codeph>。最后，将 <codeph>message</codeph> 属性设置为 <codeph>"Another New Error Message"</codeph>，它将覆盖 <codeph>"New Error Message"</codeph>。
 
<codeblock>

var err:Error = new Error();
trace(err.toString());    // Error

err = new Error("New Error Message");
trace(err.toString());    // Error: New Error Message

err.message = "Another New Error Message";
trace(err.toString());    // Error: Another New Error Message
</codeblock></example></apiOperationDetail><related-links><link href="#Error/message"><linktext>Error.message</linktext></link><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiOperation><apiValue id="Error:message"><apiName>message</apiName><shortdesc>
	 包含与 Error 对象关联的消息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.message, message
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>包含与 Error 实例关联的错误消息。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 包含与 Error 对象关联的消息。默认情况下，此属性的值为“<codeph>Error</codeph>”。当通过将错误字符串传递给 <codeph>Error</codeph> 构造函数来创建 Error 对象时，可以指定 <codeph>message</codeph> 属性。
	 
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiValue><apiValue id="Error:name"><apiName>name</apiName><shortdesc>
	  包含 Error 对象的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.name, name
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>Error 实例的名称。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	  包含 Error 对象的名称。默认情况下，此属性的值为“<codeph>Error</codeph>”。
	 
 	 </apiDesc></apiValueDetail><related-links><link href="statements.html#throw"><linktext>statements.html#throw</linktext></link><link href="statements.html#try..catch..finally"><linktext>statements.html#try..catch..finally</linktext></link></related-links></apiValue><apiValue id="Error:errorID:get"><apiName>errorID</apiName><shortdesc>
     包含与特定错误消息相关联的引用编号。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error.errorID, errorID
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>包含错误数字。
     
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     包含与特定错误消息相关联的引用编号。对于自定义的 Error 对象，此数字是构造函数中提供的 <codeph>id</codeph> 参数的值。
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:TypeError"><apiName>TypeError</apiName><shortdesc>
 如果操作数的实际类型与所需类型不同，将引发 TypeError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Error, TypeError
 
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
 如果操作数的实际类型与所需类型不同，将引发 TypeError 异常。 
 <p>
 另外，在以下情况还将引发此异常：
  <ul>
  <li>无法将函数的实际参数或方法强制为正式参数类型。</li>
  <li>值已赋给变量，但无法强制为变量的类型。</li>
  <li><codeph>is</codeph> 或 <codeph>instanceof</codeph> 运算符右侧的内容不是有效类型。</li>
  <li>非法使用了 <codeph>super</codeph> 关键字。</li>
  <li>属性查找生成了多个绑定，因此该查找不明确。</li>
  <li>在一个不兼容的对象调用了某种方法。例如，如果将 RegExp 类方法“转接”到通用对象上，然后调用，将引发 TypeError 异常。</li>
 </ul>
 </p>
 
 </apiDesc><example conref="examples\TypeErrorExample.as"> 下面的示例演示 TypeError 异常是如何生成的，以及如何在 <codeph>try..catch</codeph> 语句中进行处理。 
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class TypeErrorExample extends Sprite {
        public function TypeErrorExample() {
            try {
                var child:Object = new Object();
                addChild(DisplayObject(child));
            }
            catch(e:TypeError) {
                trace(e);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="operators.html#is"><linktext>is 运算符</linktext></link><link href="operators.html#instanceof"><linktext>instanceof 运算符</linktext></link><link href="statements.html#super"><linktext>super 语句</linktext></link><link href="#RegExp"><linktext>RegExp 类</linktext></link></related-links><apiConstructor id="TypeError:TypeError"><apiName>TypeError</apiName><shortdesc>
	 创建一个新的 TypeError 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>包含与 TypeError 对象关联的消息。 
	  
	  </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建一个新的 TypeError 对象。
     </apiDesc></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="globalClassifier:arguments"><apiName>arguments</apiName><shortdesc>
 用于存储和访问函数参数的参数对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>用于存储和访问函数参数的参数对象。
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 用于存储和访问函数参数的参数对象。在一个函数体内，可以使用局部参数变量来访问其参数对象。
 <p>
 这些参数存储为数组元素：第一个存取为 <codeph>arguments[0]</codeph>，第二个存取为 <codeph>arguments[1]</codeph>，依此类推。<codeph>arguments.length</codeph> 属性表示传递给函数的参数数目。传递的参数数目可能与函数声明的数目有所不同。
 </p>
 <p>
 与以前版本的 ActionScript 不同，ActionScript 3.0 中不包含 <codeph>arguments.caller</codeph> 属性。要获得对调用当前函数的函数的引用，必须将一个引用作为参数传递给该函数。可从 <codeph>arguments.callee</codeph> 示例中找到该技术的示例。
 </p>
 <p>ActionScript 3.0 中包括一个新的 <codeph>...(rest)</codeph> 关键字，建议用该关键字替代参数类。</p>
 
 </apiDesc><example conref="examples\ArgumentsExample.as"> 以下示例显示各种 <codeph>arguments</codeph> 属性（如 <codeph>callee</codeph> 和 <codeph>length</codeph>）的用法。
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        public function ArgumentsExample() {
                println("Hello World");
        }
        
        public function println(str:String):void {
            trace(arguments.callee == this.println); // true
            trace(arguments.length);                 // 1
            trace(arguments[0]);                     // Hello World
            trace(str);                                // Hello World
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="statements.html#..._(rest)_parameter"><linktext>...(rest)</linktext></link><link href="#Function"><linktext>Function</linktext></link></related-links><apiValue id="arguments:callee"><apiName>callee</apiName><shortdesc>
	 对当前正在执行的函数的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Function</apiValueClassifier><apiTipTexts><apiTipText>对当前正在执行的函数的引用。
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 对当前正在执行的函数的引用。
	 
	 </apiDesc><example conref="examples\arguments.callee.1.as"> 以下代码演示如何获得对函数的引用，该函数调用名为 <codeph>secondFunction()</codeph> 的函数。<codeph>firstFunction()</codeph> 函数具有布尔参数 <codeph>true</codeph>，以证实 <codeph>secondFunction()</codeph> 成功调用了 <codeph>firstFunction()</codeph>，并防止各个函数因相互间调用而无限循环。
  
 <p>因为 <codeph>callSecond</codeph> 参数为 <codeph>true</codeph>，所以 <codeph>firstFunction()</codeph> 调用 <codeph>secondFunction()</codeph>，并将一个对自身的引用作为唯一的参数传递。函数 <codeph>secondFunction()</codeph> 接收该参数并使用名为 <codeph>caller</codeph> 的参数存储它，该参数属于 Function 数据类型。然后，使用 <codeph>secondFunction()</codeph> 中的 <codeph>caller</codeph> 参数来调用 <codeph>firstFunction</codeph> 函数，但这次将 <codeph>callSecond</codeph> 参数设置为 <codeph>false</codeph>。</p>
 <p>当执行返回到 <codeph>firstFunction()</codeph> 时，执行 <codeph>trace()</codeph> 语句，因为 <codeph>callSecond</codeph> 为 <codeph>false</codeph>。</p>
<codeblock>
  package {
    import flash.display.Sprite;
    
    public class ArgumentsExample extends Sprite {
        private var count:int = 1;
        
        public function ArgumentsExample() {
            firstFunction(true);
        }

        public function firstFunction(callSecond:Boolean) {
            trace(count + ": firstFunction");
            if(callSecond) {
                secondFunction(arguments.callee);
            }
            else {
                trace("CALLS STOPPED");
            }
        }

        public function secondFunction(caller:Function) {
            trace(count + ": secondFunction\n");
            count++;
            caller(false);
        }        
    }
} 
</codeblock></example></apiValueDetail></apiValue><apiValue id="arguments:length"><apiName>length</apiName><shortdesc>
	 传递给函数的参数数目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="8"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier><apiTipTexts><apiTipText>传递给函数的参数的数目。
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 传递给函数的参数数目。此数目可以大于或小于函数声明的参数数目。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:String"><apiName>String</apiName><shortdesc>
 String 类为表示一串字符的数据类型。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string object, built-in class
  
  </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 String 类为表示一串字符的数据类型。String 类提供了处理原始字符串值类型的方法和属性。可以使用 <codeph>String()</codeph> 函数将任意对象的值转换为 String 数据类型的对象。 
 <p> 
 String 类的所有方法（<codeph>concat()</codeph>、<codeph>fromCharCode()</codeph>、<codeph>slice()</codeph> 和 <codeph>substr()</codeph> 除外）都是通用方法，这意味着在对这些方法执行操作前，这些方法都将调用 <codeph>toString()</codeph>，并且可以将这些方法用于其它非 String 对象。 
 </p><p>
 因为所有字符串索引都是从零开始的，所以任何字符串 <codeph>x</codeph> 的最后一个字符的索引都是 <codeph>x.length - 1</codeph>。
 </p><p>
 不论是使用构造函数方法 <codeph>new String()</codeph> 创建新的字符串变量，还是只分配字符串文本值，都可以调用 String 类的任何方法。与以前的 ActionScript 版本不同，现在，使用构造函数、全局函数和只分配字符串文本值之间没有差别。下面这几行代码是等同的：
 </p>
 <codeblock rev="3.0">
 var str:String = new String("foo");
 var str:String = "foo";
 var str:String = String("foo");</codeblock>
 <p>将字符串变量设置为 <codeph>undefined</codeph> 时，Adobe <sup>®</sup> Flash <sup>®</sup> Player 会将 <codeph>undefined</codeph> 强制为 <codeph>null</codeph>。所以，以下语句：</p>
 <pre>
 var s:String = undefined;</pre>
 将值设置为 <codeph>null</codeph> 而不是 <codeph>undefined</codeph>。如果需要使用 <codeph>undefined</codeph>，请使用 <codeph>String()</codeph> 函数。
 </apiDesc><example conref="examples\StringExample.as"> 下面的示例使用 StringExample 和 StringHelper 类说明如何使用 String 类的各种方法。这是使用以下步骤完成的：
 <ol>
    <li>StringExample 的构造函数声明多个局部 String 实例，这些实例可使用不同字符串和一个新的 StringHelper 对象初始化。</li>
    <li>StringHelper 类具有下列方法：
    <ul>
        <li><codeph>replace()</codeph>：调用 String 的 <codeph>split()</codeph> 和 <codeph>join()</codeph> 方法，以删除用新字符串传入的字符串的一个子字符串。</li>
        <li><codeph>trim()</codeph>：使用传入的字符串调用 <codeph>trimBack()</codeph> 和 <codeph>trimFront()</codeph>，并返回更新后的字符串。</li>
        <li><codeph>trimFront()</codeph>：以递归方式删除所有与 <codeph>char</codeph> 参数匹配的字符，从字符串的开头开始向后删除，直到字符串中第一个字符与 <codeph>char</codeph> 不匹配为止，并返回更新后的字符串。</li>
        <li><codeph>trimBack()</codeph>：以递归方式删除所有与 <codeph>char</codeph> 参数匹配的字符，从字符串的末尾开始向前删除，直到字符串中最后一个字符与 <codeph>char</codeph> 不匹配为止，并返回更新后的字符串。</li>
        <li><codeph>stringToCharacter()</codeph>：返回传入字符串的第一个字符。</li>
    </ul>
  </li>
    <li>然后，使用声明的字符串变量生成了 3 个字符串，其中调用 <codeph>replace()</codeph> 方法生成第二个字符串，调用 <codeph>trim()</codeph> 生成第 3 个字符串。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class StringExample extends Sprite {
        public function StringExample() {
            var companyStr:String = new String("     Company X");
            var productStr:String = "Product Z Basic     ";
            var emptyStr:String = " ";
            var strHelper:StringHelper = new StringHelper();

            var companyProductStr:String = companyStr + emptyStr + productStr;
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Basic     '

            companyProductStr = strHelper.replace(companyProductStr, "Basic", "Professional");
            trace("'" + companyProductStr + "'");    // '     Company X Product Z Professional     '

            companyProductStr = strHelper.trim(companyProductStr, emptyStr);
            trace("'" + companyProductStr + "'");    // 'Company X Product Z Professional'
        }
    }
}

class StringHelper {
    public function StringHelper() {
    }

    public function replace(str:String, oldSubStr:String, newSubStr:String):String {
        return str.split(oldSubStr).join(newSubStr);
    }

    public function trim(str:String, char:String):String {
        return trimBack(trimFront(str, char), char);
    }

    public function trimFront(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(0) == char) {
            str = trimFront(str.substring(1), char);
        }
        return str;
    }

    public function trimBack(str:String, char:String):String {
        char = stringToCharacter(char);
        if (str.charAt(str.length - 1) == char) {
            str = trimBack(str.substring(0, str.length - 1), char);
        }
        return str;
    }

    public function stringToCharacter(str:String):String {
        if (str.length == 1) {
            return str;
        }
        return str.slice(0, 1);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="package.html#String()"><linktext>String Function</linktext></link></related-links><apiConstructor id="String:String"><apiName>String</apiName><shortdesc>
  创建已初始化为指定字符串的新 String 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, new string, new, constructor
   
   </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>新 String 对象的初始值。
  
  </apiDesc></apiParam></apiConstructorDef><apiDesc>
  创建已初始化为指定字符串的新 String 对象。
  
  <p>
  <b>注意：</b>由于字符串文本比 String 对象需要的开销少且通常更易于使用，所以，除非有充分的理由要使用 String 对象而不是字符串文本，否则应该使用字符串文本而不是 String 类。
  </p>
  
  </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="String:AS3:charAt"><apiName>charAt</apiName><shortdesc>
     返回由参数 index 指定的位置处的字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charat, charat, character at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>指定索引处的字符。或者，如果指定的索引不在该字符串的索引范围内，则为一个空字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个整数，指定字符在字符串中的位置。第一个字符由 <codeph>0</codeph> 指示，最后一个字符由 <codeph>my_str.length - 1</codeph> 指示。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回由参数 <codeph>index</codeph> 指定的位置处的字符。如果 <codeph>index</codeph> 不是从 0 到 <codeph>string.length - 1</codeph> 之间的数字，则返回一个空字符串。
	 <p>
	 此方法与 <codeph>String.charCodeAt()</codeph> 类似，所不同的是它返回的值是一个字符，而不是 16 位整数字符代码。
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charCodeAt()"><linktext>charCodeAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:charCodeAt"><apiName>charCodeAt</apiName><shortdesc>
	 返回位于指定索引位置处的字符的数值 Unicode 字符代码。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.charcodeat, charcodeat, character code at
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>指定索引处的字符的 Unicode 字符代码。或者，如果索引不在此字符串的索引范围内，则为 <codeph> NaN</codeph>。
	 <p><xref href="" scope="external"/> </p>		 
	 
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个整数，指定字符在字符串中的位置。第一个字符由 <codeph>0,</codeph> 指示，最后一个字符由 <codeph>my_str.length - 1</codeph> 指示。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回指定 <codeph>index</codeph> 处的字符的数值 Unicode 字符代码。如果 <codeph>index</codeph> 不是从 0 到 <codeph> string.length - 1</codeph> 之间的数字，则返回 <codeph>NaN</codeph>。
	 <p>
	 此方法与 <codeph>String.charAt()</codeph> 类似，所不同的是它返回的值是 16 位整型字符代码，而不是实际的字符。
	 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/charAt()"><linktext>charAt()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:concat"><apiName>concat</apiName><shortdesc>
	 在 String 对象末尾追加补充参数（如果需要，将它们转换为字符串）并返回结果字符串。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.concat, concat, concatenate
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>由该字符串与指定的参数连接而成的新字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>0 个或多个要连接的值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在 String 对象末尾追加补充参数（如果需要，将它们转换为字符串）并返回结果字符串。源 String 对象的原始值保持不变。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:fromCharCode"><apiName>fromCharCode</apiName><shortdesc>
	返回一个字符串，该字符串由参数中的 Unicode 字符代码所表示的字符组成。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.fromcharcode, fromcharcode, from character code
	 
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>指定的 Unicode 字符代码的字符串值。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>charCodes</apiItemName><apiType value="restParam"/><apiDesc>一系列表示 Unicode 值的十进制整数。
	<p><xref href="" scope="external"/> </p>	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	返回一个字符串，该字符串由参数中的 Unicode 字符代码所表示的字符组成。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
	 搜索字符串，并返回在调用字符串内的 startIndex 位置或在该位置之后找到的第一个 val 匹配项的位置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.indexof, indexof, index
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>指定子字符串的第一个匹配项的索引，或 <codeph>-1</codeph>。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要搜索的子字符串。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个可选整数，指定搜索的起始索引。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 搜索字符串，并返回在调用字符串内 <codeph>startIndex</codeph> 位置上或之后找到的 <codeph>val</codeph> 的第一个匹配项的位置。此索引从 0 开始，这意味着字符串的第一个字符位于索引 0，而不是索引 1。如果未找到 <codeph>val</codeph>，则该方法返回 -1。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/lastIndexOf()"><linktext>lastIndexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
	 从右向左搜索字符串，并返回在 startIndex 之前找到的最后一个 val 匹配项的索引。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.lastindexof, lastindexof, last index of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>指定子字符串的最后一个匹配项的位置，或 -1（如果未找到）。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要搜索的字符串。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7FFFFFFF</apiData><apiDesc>一个可选整数，指定开始搜索 <codeph>val</codeph> 的起始索引。默认为允许的最大索引值。如果未指定 <codeph>startIndex</codeph>，则从字符串中的最后一项开始搜索。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从右向左搜索字符串，并返回在 <codeph>startIndex</codeph> 之前找到的最后一个 <codeph>val</codeph> 匹配项的索引。此索引从零开始，这意味着第一个字符位于索引 0 处，最后一个字符位于 <codeph>string.length - 1</codeph> 处。如果未找到 <codeph>val</codeph>，则该方法返回 <codeph>-1</codeph>。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/indexOf()"><linktext>indexOf()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:localeCompare"><apiName>localeCompare</apiName><shortdesc>
	 比较两个或更多个字符串的排序顺序，并返回整数形式的比较结果。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>值为 0（如果字符串相等）。否则为一个负整数（如果原始字符串在字符串参数之前）或一个正整数（如果字符串参数在原始字符串之前）。在这两种情况下，该数值的绝对值都表示这两个字符串之间的区别。
	  
	  </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要比较的字符串值。
     </apiDesc></apiParam><apiParam><apiItemName>values</apiItemName><apiType value="restParam"/><apiDesc>由多个要比较的字符串组成的集合（可选）。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 比较两个或更多个字符串的排序顺序，并返回整数形式的比较结果。虽然此方法旨在以特定于区域设置的方式处理比较，但 ActionScript 3.0 实现生成的结果与其它字符串比较的结果相同，例如，等于 (<codeph>==</codeph>) 或不等于 (<codeph>!=</codeph>) 运算符。如果字符串相等，则返回值为 0。如果原始字符串值在 <codeph>other</codeph> 指定的字符串值之前，则返回值为负整数，该值的绝对值表示这两个字符串值之间不相同的字符数。如果原始字符串值在 <codeph>other</codeph> 之后，返回值为正整数，该值的绝对值表示这两个字符串值之间不相同的字符数。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:match"><apiName>match</apiName><shortdesc>
	将指定的 pattern 与字符串匹配。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
		 var myPattern:RegExp = /sh./g;  
			// The dot (.) matches any character.
	 var str:String = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: she,sho
	
		 myPattern = /sh./gi;  
			// This time, make it case insensitive (with the i flag).
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
	 	// Output: She,she,sho	
	
		 myPattern = RegExp = new RegExp("sh(.)", "gi")  
			// Note the grouping parentheses.
	 str = "She sells seashells by the seashore.";
	 trace(str.match(myPattern));  
	
		// Output: She,e,she,e,sho,o
		 	// Note that the result array is 
			// [[She,e],[she,e],[sho,o]] 
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个字符串数组，其中包括与指定的 <codeph>pattern</codeph> 匹配的字符串中的所有子字符串。
	
	<p>如果 <codeph>pattern</codeph> 是正则表达式，为了返回一个具有多个匹配子字符串的数组，必须在该正则表达式中设置 <codeph>g</codeph>（全局）标志： </p>
	
	<ul>
	
		<li>如果<i>未</i>设置 <codeph>g</codeph>（全局）标志，则返回的数组包含的匹配项将不多于一项，且正则表达式的 <codeph>lastIndex</codeph> 属性保持不变。</li> 
	
		<li>如果<i>已</i>设置 <codeph>g</codeph>（全局）标志，则该方法从字符串的起始处（索引位置 0）开始搜索。如果匹配的子字符串为空字符串（正则表达式为 <codeph>/x~~/</codeph> 时可能出现此情况），则该方法将此空字符串添加到匹配项数组，然后在下一个索引位置继续搜索。该方法完成后，将正则表达式的 <codeph>lastIndex</codeph> 属性设置为 0。 </li>
	
	</ul>
	
	<p>如果未找到匹配项，该方法返回 <codeph>null</codeph>。如果未传递值（或传递了未定义的值）作为 <codeph>pattern</codeph> 参数，则该方法返回 <codeph>null</codeph>。</p>
	
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>要匹配的模式，可以为任何类型的对象，但通常是字符串或正则表达式。如果 <codeph>pattern</codeph> 不是正则表达式或字符串，则该方法在执行前会将其转换为字符串。 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	将指定的 <codeph>pattern</codeph> 与字符串匹配。
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:replace"><apiName>replace</apiName><shortdesc>
	对字符串匹配指定模式并返回一个新字符串，其中的第一个模式匹配项被替换为 repl 所指定的内容。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>结果字符串。请注意，源字符串保持不变。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>要匹配的模式，可以为任何类型的对象，但通常是字符串或正则表达式。如果指定的 <codeph>pattern</codeph> 参数是除字符串或正则表达式以外的任何其它对象，将对该参数应用 <codeph>toString()</codeph> 方法，并使用生成的字符串作为 <codeph>pattern</codeph> 来执行 <codeph>replace()</codeph> 方法。 
	
	</apiDesc></apiParam><apiParam><apiItemName>repl</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>通常是以插入的字符串替换匹配内容。但也可以指定一个函数作为此参数。如果指定一个函数，将插入由该函数返回的字符串来替换匹配内容。
	
	<p>如果指定一个字符串作为 <codeph>repl</codeph> 参数，并指定一个正则表达式作为 <codeph>pattern</codeph> 参数，则可以在 <codeph>repl</codeph> 字符串中使用以下特殊的 <i>$ 替换代码</i>：</p>
	
	<adobetable class="innertable">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<tgroup cols="2"><thead><row><entry NOWRAP="true">$ 代码
		</entry><entry>替换文本
		</entry></row></thead><tbody><row>
	
		<entry><codeph>$$</codeph>
		</entry>
	
		<entry><codeph>$</codeph>
		</entry>
	
	</row><row>
	
		<entry><codeph>$&amp;</codeph>
		</entry>
	
		<entry>匹配的子字符串。
		</entry>
	
	</row><row>
	
		<entry><codeph>$`</codeph>	
		</entry>
	
		<entry>字符串中位于匹配的子字符串前面的部分。请注意，此代码使用左侧直单引号字符 (`)，而不是直单引号字符 (') 或左侧弯单引号字符 (‘)。
		</entry>
	
	</row><row>
	
		<entry><codeph>$'</codeph>
		</entry>
	
		<entry>字符串中位于匹配的子字符串后面的部分。请注意，此代码使用直单引号字符 (')。
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>n</i>
		</entry>
	
		<entry>第 <i>n</i> 个捕获的括号组匹配项，其中 <i>n</i> 是 1-9 之间的数字，而且 <codeph>$</codeph><i>n</i> 后面没有十进制数字。 
		</entry>
	
	</row><row>
	
		<entry><codeph>$</codeph><i>nn</i>
		</entry>
	
		<entry>第 <i>nn</i> 个捕获的括号组匹配项，其中 <i>nn</i> 是一个十进制的两位数 (01-99)。如果未定义第 <i>nn</i> 个捕获内容，则替换文本为空字符串。 
		</entry>
	
	</row></tbody></tgroup></adobetable>
	
	<p>例如，下面说明了如何使用 <codeph>$2</codeph> 和 <codeph>$1</codeph> 替换代码，它们分别表示匹配的第一个和第二个捕获组：</p>
	
	<codeblock>var str:String = "flip-flop";
	var pattern:RegExp = /(\w+)-(\w+)/g;
	trace(str.replace(pattern, "$2-$1")); // flop-flip</codeblock>
	
	<p>指定一个函数作为 <codeph>repl</codeph> 时，<codeph>replace()</codeph> 方法将以下参数传递给该函数：
	</p>
	
	<ul>
	
		<li>
		字符串的匹配部分。
		</li>
	
		<li>
		任何捕获到的括号组匹配项都将作为下一组参数提供。按这种方式传递的参数数目因括号匹配项的数目而异。您可以通过检查函数代码中的 <codeph>arguments.length - 3</codeph> 来确定括号匹配项的数目。
		</li>
	
		<li>
		字符串中匹配开始的索引位置。
		</li>
	
		<li>
		完整的字符串。
		</li>
	
	</ul>
	
	<p>例如，请看以下例子：</p>
	
	<codeblock>
	var str1:String = "abc12 def34";
	var pattern:RegExp = /([a-z]+)([0-9]+)/;
	var str2:String = str1.replace(pattern, replFN);
	trace (str2);   // 12abc 34def
	
	function replFN():String {
		return arguments[2] + arguments[1];
	}</codeblock>
	
	
	<p>对 <codeph>replace()</codeph> 方法的调用使用一个函数作为 <codeph>repl</codeph> 参数。匹配两次正则表达式 (<codeph>/([a-z]([0-9]/g</codeph>)。第一次，模式与子字符串 <codeph>"abc12"</codeph> 匹配，并将以下参数列表传递给该函数：
	</p>
	
	<codeblock>
	{"abc12", "abc", "12", 0, "abc12 def34"}</codeblock>
	
	
	<p>第二次，模式与子字符串 <codeph>"def23"</codeph> 匹配，并将以下参数列表传递给该函数：
	</p>
	
	<codeblock>
	{"def34", "def", "34", 6, "abc123 def34"}</codeblock>
	
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	相对于字符串匹配指定的 <codeph>pattern</codeph> 并返回一个新字符串，其中的第一个 <codeph>pattern</codeph> 匹配项被替换为 <codeph>repl</codeph> 所指定的内容。<codeph>pattern</codeph> 参数可以是字符串或正则表达式。<codeph>repl</codeph> 参数可以是字符串或函数；如果是函数，将插入由该函数返回的字符串以替换匹配项。未修改原始字符串。
	
	<p>在下面的示例中，仅替换“sh”（区分大小写）的第一个实例： </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seashore.</codeblock>
	
	<p>在下面的示例中，替换“sh”（区分大小写）的所有实例，这是因为在正则表达式中设置了 <codeph>g</codeph>（全局）标志： </p>
	
	<codeblock>
	var myPattern:RegExp = /sh/g;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // She sells seaschells by the seaschore.</codeblock>
	
	<p>在下面的示例中，替换“sh”的所有实例，这是因为在正则表达式中设置了 <codeph>g</codeph>（全局）标志，并且匹配时<i>不</i> 区分大小写，因为设置了 <codeph>i</codeph>（忽略大小写）标志：</p>
	
	<codeblock>
	var myPattern:RegExp = /sh/gi;  
	var str:String = "She sells seashells by the seashore.";
	trace(str.replace(myPattern, "sch"));  
	   // sche sells seaschells by the seaschore.</codeblock>
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:search"><apiName>search</apiName><shortdesc>
	搜索指定的 pattern 并返回第一个匹配子字符串的索引。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample><pre><code>
	 var str:String = "She sells seashells by the seashore.";
		 var myPattern:RegExp = /sh/;  
			// This time, make it case insensitive (with the i flag).
	 trace(str.match(myPattern));  
	
		// Output: 13
		// (The substring match starts at character position 13.)
	
		 var myPattern:RegExp = /sh/i;
	 trace(str.match(myPattern));  
	
		// Output: 0
		// (The substring match starts at character position 0 
			//   -- the first character of the source string.)
	</code></pre>
	
	</oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>第一个匹配子字符串的索引，如果没有匹配项，则为 <codeph>-1</codeph>。请注意，字符串的索引从零开始；字符串的第一个字符位于索引 0 处，最后一个字符位于 <codeph>string.length - 1</codeph> 处。 
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>pattern</apiItemName><apiType value=""/><apiDesc>要匹配的模式，可以为任何类型的对象，但通常是字符串或正则表达式。如果 <codeph>pattern</codeph> 不是正则表达式或字符串，则该方法在执行前会将其转换为字符串。请注意，如果指定正则表达式，该方法将忽略此正则表达式的全局标志（“g”），并忽略此正则表达式的 <codeph>lastIndex</codeph> 属性（并保持其值不变）。如果传递未定义的值（或未传递值），则该方法返回 <codeph>-1</codeph>。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	搜索指定的 <codeph>pattern</codeph> 并返回第一个匹配子字符串的索引。如果没有匹配的子字符串，该方法返回 <codeph>-1</codeph>。
	
	</apiDesc></apiOperationDetail><related-links><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:slice"><apiName>slice</apiName><shortdesc>
	 返回一个字符串，该字符串包括从 startIndex 字符一直到 endIndex 字符（但不包括该字符）之间的所有字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.slice, slice
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>基于指定索引的子字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>片段起始点的从 0 开始的索引。如果 <codeph>startIndex</codeph> 是一个负数，则从右到左创建片段，其中 -1 是最后一个字符。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>一个比片段终点的索引大 1 的整数。由 <codeph>endIndex</codeph> 参数索引的字符未包括在已提取的字符串中。如果 <codeph>endIndex</codeph> 是一个负数，则终点根据从字符串的结尾向后数确定，其中 -1 表示最后一个字符。默认为允许的最大索引值。如果省略此参数，则使用 <codeph>String.length</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个字符串，该字符串包括从 <codeph>startIndex</codeph> 字符一直到 <codeph>endIndex</codeph> 字符（但不包括该字符）之间的所有字符。不修改原始 String 对象。如果未指定 <codeph>endIndex</codeph> 参数，此子字符串的结尾就是该字符串的结尾。如果按 <codeph>startIndex</codeph> 索引到的字符与按 <codeph>endIndex</codeph> 索引到的字符相同或位于后者的右侧，则该方法返回一个空字符串。
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/substr()"><linktext>substr()</linktext></link><link href="#String/substring()"><linktext>substring()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:split"><apiName>split</apiName><shortdesc>
	 将 String 对象拆分为一个子字符串数组，方法是在所有出现指定 delimiter 参数的位置进行拆分。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.split, split
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个子字符串的数组。
	 
	 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>delimiter</apiItemName><apiType value=""/><apiDesc>指定拆分此字符串的位置的模式。此模式可以是任何类型的对象，但通常为字符串或正则表达式。如果 <codeph>delimiter</codeph> 不是正则表达式或字符串，则该方法在执行前会将其转换为字符串。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>limit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>要放入数组中的最大项数。默认为允许的最大值。 
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 String 对象拆分为一个子字符串数组，方法是在所有出现指定 <codeph>delimiter</codeph> 参数的位置进行拆分。 
	 
	 <p>如果 <codeph>delimiter</codeph> 参数是正则表达式，即使向后跟踪可以找到与该位置匹配的非空子字符串，也仅考虑字符串给定位置处的第一个匹配项。例如：</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "ab";
	 var results:Array = str.split(/a~~?/); // results == ["","b"]
	 
	 results = str.split(/a~~/); // results == ["","b"].)</codeblock>
	 
	 
	 <p>如果 <codeph>delimiter</codeph> 参数是包含分组圆括号的正则表达式，则每次匹配 <codeph>delimiter</codeph> 时，会将分组圆括号的结果（包括任何未定义的结果）连接到输出数组中。例如</p>
	 
	 <codeblock rev="3.0">
	 var str:String = "Thi5 is a tricky-66 example.";
	 var re:RegExp = /(\d+)/;
	 var results:Array = str.split(re);
	     // results == ["Thi","5"," is a tricky-","66"," example."]</codeblock>
	 
	 
	 <p>如果指定 <codeph>limit</codeph> 参数，返回的数组中具有的元素数将不多于指定数目。</p>
     <p>如果 <codeph>delimiter</codeph> 是空字符串、空正则表达式或者可以匹配空字符串的正则表达式，则字符串中的每一个字符都将输出为数组中的一个元素。</p>
     
     <p>如果未定义 <codeph>delimiter</codeph> 参数，则会将整个字符串放入返回的数组的第一个元素中。 </p>     
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Array/join()"><linktext>Array.join()</linktext></link><link href="#RegExp"><linktext>RegExp</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:substr"><apiName>substr</apiName><shortdesc>
	 返回一个子字符串，该子字符串中的字符是通过从指定的 startIndex 开始，按照 len 指定的长度截取所得的。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substr, substr, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>基于指定参数的子字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个整数，指定用于创建子字符串的第一个字符的索引。如果 <codeph>startIndex</codeph> 是一个负数，则起始索引从字符串的结尾开始确定，其中 <codeph>-1</codeph> 表示最后一个字符。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>len</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>要创建的子字符串中的字符数。默认值为所允许的最大值。如果未指定 <codeph>len</codeph>，则子字符串包括从 <codeph>startIndex</codeph> 到字符串结尾的所有字符。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个子字符串，该子字符串中的字符是通过从指定的 <codeph> startIndex</codeph> 开始，按照 <codeph>len</codeph> 指定的长度截取所得的。原始字符串保持不变。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:substring"><apiName>substring</apiName><shortdesc>
	 返回一个字符串，其中包含由 startIndex 指定的字符和一直到 endIndex - 1 的所有字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.substring, substring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>基于指定参数的子字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个整数，指定用于创建子字符串的第一个字符的索引。<codeph>startIndex</codeph> 的有效值范围为从 <codeph>0</codeph> 到 <codeph>String.length</codeph>。如果 <codeph>startIndex</codeph> 是一个负值，则使用 <codeph>0 </codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>一个整数，它比所提取的子字符串中的最后一个字符的索引大 1。<codeph>endIndex</codeph> 的有效值范围为从 <codeph>0</codeph> 到 <codeph>String.length</codeph>。<codeph>endIndex</codeph> 处的字符不包括在子字符串中。默认为允许的最大索引值。如果省略此参数，则使用 <codeph>String.length</codeph>。如果此参数是一个负值，则使用 <codeph>0</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个字符串，其中包含由 <codeph>startIndex</codeph> 指定的字符和一直到 <codeph>endIndex - 1</codeph> 的所有字符。如果未指定 <codeph>endIndex</codeph>，则使用 <codeph>String.length</codeph>。如果 <codeph>startIndex</codeph> 的值等于 <codeph>endIndex</codeph> 的值，则该方法返回一个空字符串。如果 <codeph>startIndex</codeph> 的值大于 <codeph> endIndex</codeph> 的值，则在执行函数之前会自动交换参数。原始字符串保持不变。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="String:AS3:toLocaleLowerCase"><apiName>toLocaleLowerCase</apiName><shortdesc>
	 返回此字符串的一个副本，其中所有大写的字符均转换为小写字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>该字符串的一个副本，其中所有大写的字符均转换为小写字符。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回此字符串的一个副本，其中所有大写的字符均转换为小写字符。原始字符串保持不变。虽然此方法旨在以特定于区域设置的方式处理转换，但 ActionScript 3.0 实现生成的结果与 <codeph>toLowerCase()</codeph> 方法生成的结果相同。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLocaleUpperCase"><apiName>toLocaleUpperCase</apiName><shortdesc>
	 返回此字符串的一个副本，其中所有小写的字符均转换为大写字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>该字符串的一个副本，其中的所有小写字符均转换为大写字符。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回此字符串的一个副本，其中所有小写的字符均转换为大写字符。原始字符串保持不变。虽然此方法旨在以特定于区域设置的方式处理转换，但 ActionScript 3.0 实现生成的结果与 <codeph>toUpperCase()</codeph> 方法生成的结果相同。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toLowerCase"><apiName>toLowerCase</apiName><shortdesc>
	 返回此字符串的一个副本，其中所有大写的字符均转换为小写字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.tolowercase, tolowercase, to lowercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>该字符串的一个副本，其中所有大写的字符均转换为小写字符。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回此字符串的一个副本，其中所有大写的字符均转换为小写字符。原始字符串保持不变。
	 
	 <p>此方法转换所有存在 Unicode 小写等效项的字符（不仅仅是 A-Z）：</p>
	 
	 <codeblock>
	 var str:String = " JOSÉ BARÇA";
	 trace(str.toLowerCase()); // josé barça</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toUpperCase()"><linktext>toUpperCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:toUpperCase"><apiName>toUpperCase</apiName><shortdesc>
	 返回此字符串的一个副本，其中所有小写的字符均转换为大写字符。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.touppercase, touppercase, to uppercase
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>该字符串的一个副本，其中的所有小写字符均转换为大写字符。
	 
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回此字符串的一个副本，其中所有小写的字符均转换为大写字符。原始字符串保持不变。
	 
	 <p>此方法转换所有存在 Unicode 大写等效项的字符（不仅仅是 a-z）：</p>
	 
	 <codeblock>
	 var str:String = "José Barça";
	 trace(str.toUpperCase()); // JOSÉ BARÇA</codeblock>
	 
	 <p><xref href="" scope="external"/> </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#String/toLowerCase()"><linktext>toLowerCase()</linktext></link></related-links></apiOperation><apiOperation id="String:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 返回 String 实例的原始值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><oldexample>The following example creates a new instance of the String class
	 and then shows that the <code>valueOf</code> method returns 
	 the <i>primitive</i> value, rather than a reference to the new instance.
	 
	 <listing version="2.0">
	 var str:String = new String("Hello World");
	 var value:String = str.valueOf();
	 trace(str instanceof String); // true
	 trace(value instanceof String); // false
	 trace(str === value); // false</listing>
	 
	 
	 </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>字符串的值。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回 String 实例的原始值。此方法旨在将 String 对象转换为原始字符串值。因为 Flash Player 会在需要时自动调用 <codeph>valueOf()</codeph>，所以几乎不需要显式调用此方法。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="String:length:get"><apiName>length</apiName><shortdesc>
	 一个整数，它指定在所指定的 String 对象中的字符数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>string, string.length, length
	  
	  </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 一个整数，它指定在所指定的 String 对象中的字符数。
	 <p>
	 因为所有字符串索引都是从零开始的，所以任何字符串 <codeph>x</codeph> 的最后一个字符的索引都是 <codeph>x.length - 1</codeph>。
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Class"><apiName>Class</apiName><shortdesc>
 为程序中的每个类定义创建一个 Class 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 为程序中的每个类定义创建一个 Class 对象。每个 Class 对象都是 Class 类的一个实例。Class 对象包含该类的静态属性和方法。在使用 <codeph>new</codeph> 运算符进行调用时，Class 对象会创建该类的实例。
 
 <p>有些方法（如 <codeph>flash.net.getClassByAlias()</codeph>）返回 Class 类型的对象。其它方法可能返回 Class 类型的参数，例如 <codeph>flash.net.registerClassAlias()</codeph>。 </p>
 <p>该类名称是对 Class 对象的引用，如下例所示：</p>
 <pre> 
 class Foo {
 }
 </pre> 
 <p><codeph>class Foo{}</codeph> 语句是创建 Class 对象 Foo 的类定义。此外，语句 <codeph>new Foo()</codeph> 还将创建类 Foo 的一个新实例，其结果为 Foo 类型。</p>
 <p>使用 <codeph>class</codeph> 语句声明所需类。Class 对象对于高级技术（例如在运行时将类赋值给现有实例对象）很有用，如以下“示例”部分所示。</p>
 <p>一个类的任何静态属性和方法都存在于该类的 Class 对象上。Class 自己声明 <codeph>prototype</codeph>。</p>
 
 <p>一般来讲，不需要手动声明或创建 Class 类型的变量。但是，在以下代码中，一个类被赋予公共 Class 属性 <codeph>circleClass</codeph>，同时可以将该 Class 属性作为主 Library 类的一个属性加以引用：</p>
 <codeblock>
 package {
  import flash.display.Sprite;
  public class Library extends Sprite {
      
      public var circleClass:Class = Circle;
      public function Library() {
      }
  }
 }
  
 import flash.display.Shape;
 class Circle extends Shape {
  public function Circle(color:uint = 0xFFCC00, radius:Number = 10) {
      graphics.beginFill(color);
      graphics.drawCircle(radius, radius, radius);
  }
 }
 </codeblock>
 
 <p>另一个 SWF 文件可以加载生成的 Library.swf 文件，然后实例化 Circle 类型的对象。下面的示例演示一种可以访问子 SWF 文件资源的方法。（其它技术包括使用 <codeph>flash.utils.getDefnitionByName()</codeph> 或导入子 SWF 文件的存根定义。）</p>
 
 <codeblock>
 package {
  import flash.display.Sprite;
  import flash.display.Shape;
  import flash.display.Loader;
  import flash.net.URLRequest;
  import flash.events.Event;
  public class LibaryLoader extends Sprite {
      public function LibaryLoader() {
          var ldr:Loader = new Loader();
          var urlReq:URLRequest = new URLRequest("Library.swf");
          ldr.load(urlReq);
          ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
      }
      private function loaded(event:Event):void {
          var library:Object = event.target.content;
          var circle:Shape = new library.circleClass();
          addChild(circle);
      }
  }
 }
 </codeblock>
 <p>在 ActionScript 3.0 中，可以为编译到 SWF 文件中的外部资源（如图像、声音或字体）创建嵌入类。在较早版本的 ActionScript 中，这些资源通过 <codeph>MovieClip.attachMovie()</codeph> 方法使用链接 ID 关联。在 ActionScript 3.0 中，每个嵌入资源由一个唯一的嵌入资源类表示。因此，可以使用 <codeph>new</codeph> 运算符实例化资源的关联类，并调用该资源上的方法和属性。</p>
 <p product="flex">例如，如果要使用 MXML 编译器生成 SWF 文件，则要按如下所述创建一个嵌入的类：</p>
 <codeblock product="flex">
     [Embed(source="bratwurst.jpg")]
     public var imgClass:Class;
 </codeblock>
 <p product="flex">并且，为了实例化该类，需要编写以下内容：</p>
 <codeblock product="flex">
     var myImg:Bitmap = new imgClass();
 </codeblock>
 
 </apiDesc><example conref="examples\Class.1.as"> 下例演示如何通过下列步骤使用 Class 对象推迟有关实例化哪种类的决定，直到运行时为止：
 <ol>
     <li>声明两个类为 <codeph>ClassA</codeph> 和 <codeph>ClassB</codeph>。 </li>
     <li>声明一个 Class 类型变量，名为 <codeph>classToConstruct</codeph>，以及一个 Boolean 类型 <codeph>chooseClassA</codeph>（在本例中设置为 <codeph>true</codeph>），但您的代码可以使用自定义测试表达式来设置该变量的值。 </li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    
    public class ClassExample extends Sprite {
        public function ClassExample() {
            var classToConstruct:Class;            
            var classInstance:Object;

            classToConstruct = ClassA;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassA]

            classToConstruct = ClassB;
            classInstance = new classToConstruct();
            trace(classInstance);    // [object ClassB]
        }
    }
}

class ClassA {
}
    
class ClassB {
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Object/prototype"><linktext>Object.prototype</linktext></link><link href="operators.html#new"><linktext>new operator</linktext></link></related-links></apiClassifier><apiClassifier id="globalClassifier:Namespace"><apiName>Namespace</apiName><shortdesc>

Namespace 类包含用于定义和使用命名空间的方法和属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>Namespace
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiTipTexts><apiTipText>Namespace 类包含用于定义和使用 XML 对象的命名空间的方法和属性。

</apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

Namespace 类包含用于定义和使用命名空间的方法和属性。使用命名空间有以下三种方案：

<ul>
<li> <b>XML 对象的命名空间</b> 命名空间将命名空间的前缀与标识命名空间的统一资源标识符 (URI) 关联。前缀是字符串，用于在 XML 对象中引用命名空间。如果未定义前缀，则将 XML 转换为字符串时，将自动生成前缀。
</li>

<li> <b>用于区分方法的命名空间</b> 命名空间可以区分具有相同名称的方法从而执行不同任务。如果两种方法具有相同的名称，但具有不同的命名空间，则这两种方法可以执行不同的任务。
</li>

<li> <b>用于访问控制的命名空间</b> 命名空间可用于控制对类中的一组属性和方法的访问。如果将属性和方法置于私有命名空间内，则对该命名空间无访问权限的所有代码将无法访问这些属性和方法。可以将访问权限授予一组属性和方法，方法是将该命名空间传递给其它类、方法或函数。
</li>
</ul>

<p>因为每种形式接受不同的参数，所以此类显示两种形式的构造函数方法。</p>

<p>此类（与 XML、XMLList 和 QName 类一起）可实现强大的 XML 处理标准，该标准在 ECMAScript for XML (E4X) 规范（ECMA-357 第 2 版）中定义。</p>

</apiDesc><example conref="examples\NamespaceExample.as"> 下面的示例说明如何使用 XML 对象中定义的命名空间。这是由以下步骤完成的：
 <ol>
    <li>此示例定义了 3 个 Namespace 对象，每个都有一个定义命名空间的唯一 URI。</li>
    <li>此示例定义了名为 <codeph>myXML</codeph> 的 XML 变量并将其分配给 <codeph>getRSS()</codeph> 的返回值。<codeph>getRSS()</codeph> 方法定义了一个包含多个命名空间的 XML 对象，并返回该 XML 对象。</li>
    <li>此示例声明并计算 Array 变量，方法是调用 <codeph>parseRSS()</codeph> 方法，并将 <codeph>myXML</codeph> 传递给该方法。在 <codeph>parseRSS()</codeph> 中，将默认的 XML 命名空间定义为 <codeph>rss</codeph>，此示例还定义了一个 XMLList 变量，方法是分配 <codeph>myXML</codeph> 中 <codeph>item</codeph> 对象列表。创建一个数组，并用 <codeph>myXML.item</codeph> 中的各个节点填充。然后返回数组。</li>
    <li>将输出数组中的元素，方法是使用 <codeph>for</codeph> 循环并三次调用 <codeph>trace()</codeph>。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class NamespaceExample extends Sprite {
        private var rss:Namespace = new Namespace("http://purl.org/rss/1.0/");
        private var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
        private var dc:Namespace  = new Namespace("http://purl.org/dc/elements/1.1/");

        public function NamespaceExample() {
            var myXML:XML = getRSS();
            var rssItems:Array = parseRSS(myXML);
            
            var len:uint = rssItems.length;
            for (var i:uint; i &lt; len; i++) {
                trace(rssItems[i].title);
                trace(rssItems[i].creator);
                trace(rssItems[i].date);
                // Adobe Flash Developer Center
                // Adobe
                // 2005-08-08
                // Flex Developer Center
                // Adobe
                // 2005-10-16                
            }
        }
        
        private function parseRSS(rssXML:XML):Array {
            default xml namespace = rss;

            var items:XMLList = rssXML.item;

            var arr:Array = new Array();            
            var len:uint = items.length();
            for (var i:uint; i &lt; len; i++) {
                arr.push({title:items[i].title, creator:items[i].dc::creator, date:items[i].dc::date});
            }
            
            return arr;
        }

        private function getRSS():XML {
            var myXML:XML =  &lt;rdf:RDF
              xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              xmlns="http://purl.org/rss/1.0/"
              xmlns:dc="http://purl.org/dc/elements/1.1/"
            >
              &lt;channel rdf:about="http://www.xml.com/cs/xml/query/q/19">
                &lt;title>Test RSS&lt;/title>
                &lt;link>http://www.adobe.com/&lt;/link>
                &lt;description>This is a test RSS document.&lt;/description>
                &lt;language>en-us&lt;/language>
                &lt;items>
                  &lt;rdf:Seq>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flash/"/>
                &lt;rdf:li rdf:resource="http://www.adobe.com/devnet/flex/"/>
                  &lt;/rdf:Seq>
                &lt;/items>
              &lt;/channel>
              &lt;item rdf:about="http://www.adobe.com/devnet/flash/">
                &lt;title>Adobe Flash Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flash/&lt;/link>
                &lt;description>Welcome to the Flash Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-08-08&lt;/dc:date>    
              &lt;/item>
              &lt;item rdf:about="http://www.adobe.com/devnet/flex/">
                &lt;title>Flex Developer Center&lt;/title>
                &lt;link>http://www.adobe.com/devnet/flex/&lt;/link>
                &lt;description>Welcome to the Flex Developer Center&lt;/description>
                &lt;dc:creator>Adobe&lt;/dc:creator>
                &lt;dc:date>2005-10-16&lt;/dc:date>    
              &lt;/item>
            &lt;/rdf:RDF>;
            
            return myXML;
        }
    }
}
</codeblock></example><example conref="examples\Namespace_2_Example.as"> 下面的示例说明如何使用命名空间区分具有相同名称却执行不同任务的方法。在本示例中，3 个名为 <codeph>hello()</codeph> 的方法分别位于不同的命名空间中，调用每个方法时将返回不同的字符串。
<codeblock>
package {

    import flash.display.Sprite;

    public class Namespace_2_Example extends Sprite {    
        public function Namespace_2_Example() {
            var vocab:MultilingualVocabulary = new MultilingualVocabulary();

            trace(vocab.hello());    // hello
            
            var languages:Array = vocab.getLanguages();
            
            for (var i:uint; i &lt; languages.length; i++) {
                var ns:Namespace = languages[i];
                if (ns != null) {
                    trace(ns.toString() + ": " + vocab.ns::hello());
                    // hello
                    // MultilingualVocabulary:Hawaiian: aloha
                    // MultilingualVocabulary:French: bon jour
                }
            }
        }
    }    
}

class MultilingualVocabulary {
    public namespace French;
    public namespace Hawaiian;
    private var languages:Array;

    public function MultilingualVocabulary() {
        languages = new Array(Hawaiian, French);
    }
        
    public function hello():String { 
        return "hello";
    }

    Hawaiian function hello():String {
        return "aloha";
    }

    French function hello():String { 
        return "bon jour";
    }
        
    public function getLanguages():Array {
        return languages;
    }
}
</codeblock></example><example conref="examples\Namespace_3_Example.as"> 下面的示例使用命名空间名称选择相应的变量值。它说明如何在变量中存储命名空间值，并使用该变量引用该命名空间中的对象。
 <p>此示例为矩形按钮定义对应于鼠标状态的命名空间和颜色。每次绘制该按钮，此示例都会应用相应的颜色（鼠标光标在按钮外为红色；悬停在上方为黄色；按下按钮为白色），方法是引用 <codeph>bgcolor</codeph> 变量（针对相应的命名空间 (<codeph>out</codeph>、<codeph>over</codeph>、<codeph>down</codeph>)。 </p>
<codeblock>
package {
    import flash.display.Sprite;
  
    public class Namespace_3_Example extends Sprite {     
        public function Namespace_3_Example() {
            addChild(new StateButton("Press Me."));
        }
    }
}

import flash.display.Sprite;
import flash.text.TextField;
import flash.events.Event;
import flash.events.MouseEvent;

class StateButton extends Sprite{
    private namespace out;
    private namespace over;
    private namespace down;
    private var label:TextField;
    private var labelTxt:String;
    private var ns:Namespace;
    out var bgColor:Number = 0xFF0000;
    over var bgColor:Number = 0xFFFF00;
    down var bgColor:Number = 0xFFFFFF;
      
    public function StateButton(str:String) {
        buttonMode = true;
        labelTxt = str;
        ns = out;
        draw();
        addLabel();
        addListeners();
    }

    private function addLabel():void {
        label = new TextField();
        label.text = labelTxt;
        label.width = 50;
        label.height = 20;
        label.mouseEnabled = false;
        addChild(label);
    }
      
    private function addListeners():void {
        addEventListener(MouseEvent.MOUSE_UP, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
    }
 
    private function mouseOutHandler(e:Event):void {
        ns = out;
        draw();
    }
 
    private function mouseOverHandler(e:Event):void {
        ns = over;
        draw();
    }
 
    private function mouseDownHandler(e:Event):void {
        ns = down;
        draw();
    }
 
    private function draw():void {
        this.graphics.clear();
        this.graphics.beginFill(ns::bgColor);
        this.graphics.drawRect(0, 0, 60, 20);
    }
} 
</codeblock></example></apiClassifierDetail><related-links><link href="#XML"><linktext>XML</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>ECMAScript for XML (E4X) 规范（ECMA-357 第 2 版）</linktext></link></related-links><apiConstructor id="Namespace:Namespace_0"><apiName>Namespace</apiName><shortdesc> 
	创建 Namespace 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>命名空间的统一资源标识符 (URI)。
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>使用给定的 uriValue 创建一个 Namespace 对象。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	创建 Namespace 对象。分配给新 Namespace 对象的 <codeph>uri</codeph> 和 <codeph>prefix</codeph> 属性的值取决于传递给 <codeph>uriValue</codeph> 参数的值的类型：
	<ul>
	  <li>如果未传递任何值，则 <codeph>prefix</codeph> 和 <codeph>uri</codeph> 属性将设置为空字符串。</li>
	  <li>如果值为 Namespace 对象，则将创建该对象的一个副本。</li>
	  <li>如果值为 QName 对象，则将 <codeph>uri</codeph> 属性设置为 QName 对象的 <codeph>uri</codeph> 属性。</li>
	</ul>
    <p><b>注意：</b>因为每种形式接受不同的参数，所以此类显示两个构造函数项。根据传递的参数类型和数量的不同（由每一项详细定义），此构造函数具有不同的行为。ActionScript 3.0 不支持方法或构造函数重载。</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiConstructor id="Namespace:Namespace_1"><apiName>Namespace</apiName><shortdesc> 
	根据 prefixValue 和 uriValue 参数值创建 Namespace 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><helpid>
	</helpid></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>prefixValue</apiItemName><apiType value=""/><apiDesc>用于命名空间的前缀。   
	
	</apiDesc></apiParam><apiParam><apiItemName>uriValue</apiItemName><apiType value=""/><apiDesc>命名空间的统一资源标识符 (URI)。
	
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>使用给定的 prefixValue 和 uriValue 创建一个 Namespace 对象。
	
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc> 
	根据 <codeph>prefixValue</codeph> 和 <codeph>uriValue</codeph> 参数值创建 Namespace 对象。此构造函数需要这两个参数。
	<p><codeph>prefixValue</codeph> 参数的值分配给了 <codeph>prefix</codeph> 属性，如下所示：</p>
	<ul>
	  <li>如果传递了 <codeph>undefined</codeph>，则 <codeph>prefix</codeph> 将设置为 <codeph>undefined</codeph>。</li>
	  <li>如果该值为 <codeph>isXMLName()</codeph> 函数确定的有效 XML 名称，则将其转换为字符串并分配给 <codeph>prefix</codeph> 属性。</li>
	  <li>如果该值不是有效的 XML 名称，则将 <codeph>prefix</codeph> 属性设置为 <codeph>undefined</codeph>。</li>
	</ul>
	
	<p><codeph>uriValue</codeph> 参数的值分配给了 <codeph>uri</codeph> 属性，如下所示：</p>
	<ul>
	  <li>如果已传递 QName 对象，则 <codeph>uri</codeph> 属性将设置为 QName 对象的 <codeph>uri</codeph> 属性的值。</li>
	  <li> 否则，<codeph>uriValue</codeph> 参数将转换为字符串并分配给 <codeph>uri</codeph> 属性。</li>
	</ul>
    <p><b>注意：</b>因为每种形式接受不同的参数，所以此类显示两个构造函数方法项。根据传递的参数类型和数量的不同（由每一项详细定义），此构造函数具有不同的行为。ActionScript 3.0 不支持方法或构造函数重载。</p>
    
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="Namespace:AS3:toString"><apiName>toString</apiName><shortdesc>
	等效于 Namespace.uri 属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>命名空间的统一资源标识符 (URI)（采用字符串形式）。
	
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>等效于 Namespace.uri 属性。 
	
	</apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	等效于 <codeph>Namespace.uri</codeph> 属性。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="Namespace:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
    返回指定对象的 URI 值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.toString, toString
    </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>命名空间的统一资源标识符 (URI)（采用字符串形式）。
    
    
    </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>等效于 Namespace.uri 属性。 
    
    </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
    返回指定对象的 URI 值。 
    
    </apiDesc></apiOperationDetail></apiOperation><apiValue id="Namespace:prefix:get"><apiName>prefix</apiName><shortdesc>
	命名空间的前缀。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.prefix, prefix
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>命名空间的前缀。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	命名空间的前缀。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="Namespace:uri:get"><apiName>uri</apiName><shortdesc>
	命名空间的统一资源标识符 (URI)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Namespace, Namespace.uri, uri
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>命名空间的统一资源标识符 (URI)。
	
	</apiTipText></apiTipTexts></apiValueDef><apiDesc>
	命名空间的统一资源标识符 (URI)。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:XML"><apiName>XML</apiName><shortdesc>
	XML 类包含用于处理 XML 对象的方法和属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>XML
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	XML 类包含用于处理 XML 对象的方法和属性。XML 类（以及 XMLList、Namespace 和 QName 类）可实现 ECMAScript for XML (E4X) 规范（ECMA-357 第 2 版）中定义的强大的 XML 处理标准。
	
	<p>使用 <codeph>toXMLString()</codeph> 方法可返回 XML 对象的字符串表示形式，不管该 XML 对象具有简单内容还是复杂内容。</p>
	
	<p><b>注意</b>：ActionScript 2.0 中的 XML 类（以及相关类）已重命名为 XMLDocument 并移到 flash.xml 包中。它包含在 ActionScript 3.0 中，以实现向后兼容。</p> 
	
	
    </apiDesc><example conref="examples\XMLExample.as"> 下面的示例先创建一个 XML 变量并向其中添加节点。然后使用 XML 属性查找和输出 XML 节点。请注意，“at”(<codeph>@</codeph>) 符号用在多个 <codeph>trace()</codeph> 调用中，以按属性名称查找信息。
<codeblock>
package {
    import flash.display.Sprite;

    public class XmlExample extends Sprite {        
        public function XmlExample() {
            var employees:XML =
                &lt;employees>
                    &lt;employee ssn="123-123-1234">
                        &lt;name first="John" last="Doe"/>
                        &lt;address>
                            &lt;street>11 Main St.&lt;/street>
                            &lt;city>San Francisco&lt;/city>
                            &lt;state>CA&lt;/state>
                            &lt;zip>98765&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                    &lt;employee ssn="789-789-7890">
                        &lt;name first="Mary" last="Roe"/>
                        &lt;address>
                            &lt;street>99 Broad St.&lt;/street>
                            &lt;city>Newton&lt;/city>
                            &lt;state>MA&lt;/state>
                            &lt;zip>01234&lt;/zip>
                        &lt;/address>
                    &lt;/employee>
                &lt;/employees>;

            trace(employees.employee[0].address.zip);   // 98765

            trace(employees.employee[1].@ssn);          // 789-789-7890

            trace(employees.employee.name);             // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees..zip[0]);                   // 98765

            trace(employees..@ssn[1]);                  // 789-789-7890

            trace(employees..name);                     // &lt;name first="John" last="Doe"/>
                                                        // &lt;name first="Mary" last="Roe"/>

            trace(employees.employee[0].address.*);     // &lt;street>11 Main St.&lt;/street>    
                                                        // &lt;city>San Francisco&lt;/city>
                                                        // &lt;state>CA&lt;/state>
                                                        // &lt;zip>98765&lt;/zip>
            var node:String = "zip";
            trace(employees.employee[0].address[node]); // 98765
            
            var attribute:String = "ssn";
            trace(employees.employee[1].@[attribute]);  // 789-789-7890
            
            for each (var num:XML in employees..@ssn) {
                trace(num);                             // 123-123-1234
            }                                           // 789-789-7890
            
            var ssnToFind:String = "789-789-7890";
            trace(employees.employee.(@ssn == ssnToFind).toXMLString());
                                                        // &lt;employee ssn="789-789-7890">
                                                        // &lt;name first="Mary" last="Roe"/>
                                                        // &lt;address>
                                                        // &lt;street>99 Broad St.&lt;/street>
                                                        // &lt;city>Newton&lt;/city>
                                                        // &lt;state>MA&lt;/state>
                                                        // &lt;zip>01234&lt;/zip>
                                                        // &lt;/address>
                                                        // &lt;/employee>
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#XMLList"><linktext>XMLList</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link><link href="http://www.ecma-international.org/publications/standards/Ecma-357.htm"><linktext>ECMAScript for XML (E4X) 规范（ECMA-357 第 2 版）</linktext></link></related-links><apiConstructor id="XML:XML"><apiName>XML</apiName><shortdesc> 
	创建一个新的 XML 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML
	</keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>可通过顶级 <codeph>XML()</codeph> 函数转换为 XML 的任意对象。
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc> 
	创建一个新的 XML 对象。调用 XML 类的方法之前，必须使用该构造函数创建一个 XML 对象。 
	
	<p>使用 <codeph>toXMLString()</codeph> 方法可返回 XML 对象的字符串表示形式，不管该 XML 对象具有简单内容还是复杂内容。</p>
	
	</apiDesc></apiConstructorDetail><related-links><link href="package.html#XML()"><linktext>top-level XML() function</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiConstructor><apiOperation id="XML:AS3:addNamespace"><apiName>addNamespace</apiName><shortdesc>
	可将命名空间添加到该 XML 对象所在范围的命名空间集中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.addNamespace, addNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>添加了命名空间的新 XML 对象。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要添加到 XML 对象中的命名空间。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	可将命名空间添加到该 XML 对象所在范围的命名空间集中。如果 XML 对象（其前缀与给定参数的前缀匹配）所在范围的命名空间中已存在该命名空间，则现有命名空间的前缀将设置为 <codeph>undefined</codeph>。如果输入参数是一个 Namespace 对象，则直接使用该参数。如果它是一个 QName 对象，则使用输入参数的 URI 创建新的命名空间；否则，会将它转换为一个 String 值并根据该 String 值创建命名空间。
	
	</apiDesc><example conref="examples\XML.addNamespace.1.as"> 下面的示例使用在 XML 对象中定义的命名空间，并将其应用于另一个 XML 对象：
<codeblock>
var xml1:XML = &lt;ns:foo xmlns:ns="www.example.com/ns" />;
var nsNamespace:Namespace = xml1.namespace();

var xml2:XML = &lt;bar />;
xml2.addNamespace(nsNamespace);
trace(xml2.toXMLString()); // &lt;bar xmlns:ns="www.example.com/ns"/>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:appendChild"><apiName>appendChild</apiName><shortdesc>
	将给定子项追加到该 XML 对象属性的末尾。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.appendChild, appendChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要追加的 XML 对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
	将给定子项追加到该 XML 对象属性的末尾。<codeph>appendChild()</codeph> 方法可采用 XML 对象、XMLList 对象或随后转换为 String 的任何其它数据类型。 
    
    <p>使用 <codeph>delete</codeph> (XML) 运算符删除 XML 节点。</p>
	
	</apiDesc><example conref="examples\XML.appendChild.1.as"> 下面的示例向 XML 对象的子级列表的末尾追加一个新元素：
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.appendChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>hello&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>world&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>delete (XML) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attribute"><apiName>attribute</apiName><shortdesc>
	返回其名称与 attributeName 参数相符的属性的 XML 值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attribute, attribute
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个 XMLList 对象或空的 XMLList 对象。在未定义属性值时返回一个空的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>attributeName</apiItemName><apiType value=""/><apiDesc>属性的名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	返回其名称与 <codeph>attributeName</codeph> 参数相符的属性的 XML 值。可在 XML 元素内找到属性。在以下示例中，元素具有名为“<codeph>gender</codeph>”的属性，其值为“<codeph>boy</codeph>”：<codeph>&lt;first gender="boy">John&lt;/first></codeph>。
	
	<p><codeph>attributeName</codeph> 参数可以是任何数据类型；但 String 是最常用的数据类型。在传递 QName 对象之外的任何对象时，<codeph>attributeName</codeph> 参数会使用 <codeph>toString()</codeph> 方法将参数转换为字符串。 </p>
	
	<p>如果需要一个限定名称引用，可以传入 QName 对象。QName 对象可定义命名空间和本地名称，还可定义属性的限定名称。因此，调用 <codeph>attribute(qname)</codeph> 不同于调用 <codeph>attribute(qname.toString())</codeph>。</p>
	
	</apiDesc><example conref="examples\XMLAttributeExample1.as"> 本示例演示如何将 QName 对象传递给 <codeph>attribute()</codeph> 方法。<codeph>localName</codeph> 属性为 <codeph>attr</codeph>，<codeph>namespace</codeph> 属性为 <codeph>ns</codeph>。
<codeblock>
 var xml:XML = &lt;ns:node xmlns:ns = "http://uri" ns:attr = '7' />       
 var qn:QName = new QName("http://uri", "attr");
 trace (xml.attribute(qn)); // 7
</codeblock></example><example conref="examples\XMLAttributeExample2.as"> 要返回名称与 ActionScript 保留字匹配的属性，请使用 <codeph>attribute()</codeph> 方法替代属性标识符 (@) 运算符，如下面的示例所示：
<codeblock>
 var xml:XML = &lt;example class="first" />
 trace(xml.attribute("class"));
 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="#QName"><linktext>QName</linktext></link><link href="#Namespace"><linktext>Namespace</linktext></link><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="operators.html#attribute_identifier"><linktext>属性标识符 (&amp;#064;) 运算符</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:attributes"><apiName>attributes</apiName><shortdesc>
	返回给定 XML 对象的属性值列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.attributes, attributes
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>属性值的列表。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回给定 XML 对象的属性值列表。结合使用 <codeph>name()</codeph> 方法和 <codeph>attributes()</codeph> 方法可返回属性的名称。使用 <codeph>xml.attributes()</codeph> 等效于 <codeph>xml.@*</codeph>。
	
	</apiDesc><example conref="examples\XMLAttributesExample1.as"> 下面的示例返回属性的名称：

<codeblock>
var xml:XML=&lt;example id='123' color='blue'/>
trace(xml.attributes()[1].name()); //color
</codeblock></example><example conref="examples\XMLAttributesExample2.as"> 下面的示例返回所有属性的名称：
<codeblock>
 
var xml:XML = &lt;example id='123' color='blue'/>
var attNamesList:XMLList = xml.@*;

trace (attNamesList is XMLList); // true
trace (attNamesList.length()); // 2

for (var i:int = 0; i &lt; attNamesList.length(); i++)
{ 
    trace (typeof (attNamesList[i])); // xml
    trace (attNamesList[i].nodeKind()); // attribute
    trace (attNamesList[i].name()); // id and color
} 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="#XML/name()"><linktext>XML.name()</linktext></link><link href="operators.html#attribute_identifier"><linktext>&amp;#064; 运算符</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:child"><apiName>child</apiName><shortdesc>
	列出 XML 对象的子项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.child, child
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>与输入参数匹配的子节点的 XMLList 对象。 
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>XML 子对象的元素名称或整数。 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	列出 XML 对象的子项。一个 XML 子项就是一个 XML 元素、文本节点、注释或处理指令。 
	
	<p>使用 <codeph>propertyName</codeph> 参数可列出特定 XML 子项的内容。例如，要返回名为 <codeph>&lt;first></codeph> 的子项的内容，可使用 <codeph>child.name("first")</codeph>。使用子项的索引编号，可以生成相同的结果。索引编号标识该子项在其它 XML 子项列表中的位置。例如，<codeph>name.child(0)</codeph> 将返回列表中的第一个子项。 </p>
	
	<p>使用星号 (*) 可输出 XML 文档中的所有子项。例如，<codeph>doc.child("~~")</codeph>。</p>  
	
	<p>结合使用 <codeph>length()</codeph> 方法与 <codeph>child()</codeph> 方法的星号 (*) 参数可输出子项的总数。例如，<codeph>numChildren = doc.child("~~").length()</codeph>。</p>
	
	</apiDesc><example conref="examples\XML.child.1.as"> 本示例演示如何使用 <codeph>child()</codeph> 方法识别具有指定名称的子元素：
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;bar>text1&lt;/bar>
            &lt;bar>text2&lt;/bar>
        &lt;/foo>;
trace(xml.child("bar").length());  // 2
trace(xml.child("bar")[0].toXMLString()); // &lt;bar>text1&lt;/bar>
trace(xml.child("bar")[1].toXMLString()); // &lt;bar>text2&lt;/bar>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/elements()"><linktext>XML.elements()</linktext></link><link href="#XMLList"><linktext>XMLList 类</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:childIndex"><apiName>childIndex</apiName><shortdesc>
	确定该 XML 对象在其父项上下文中从 0 开始编制索引的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.childindex, childindex
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>对象的位置。返回 -1 以及正整数。
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	确定该 XML 对象在其父项上下文中从 0 开始编制索引的位置。
	
	</apiDesc><example conref="examples\XML.childIndex.1.as"> 本示例演示如何使用 <codeph>childIndex()</codeph> 方法：
<codeblock>
var xml:XML = 
            &lt;foo>
                &lt;bar />
                text
                &lt;bob />
            &lt;/foo>;
trace(xml.bar.childIndex()); // 0
trace(xml.bob.childIndex()); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:children"><apiName>children</apiName><shortdesc>
	按 XML 对象的显示顺序列出其子项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.children, children
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象子项的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	按 XML 对象的显示顺序列出其子项。一个 XML 子项就是一个 XML 元素、文本节点、注释或处理指令。 
	
	</apiDesc><example conref="examples\XML.children.1.as"> 本示例演示如何使用 <codeph>children()</codeph> 方法：
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var xml:XML = 
        &lt;foo id="22">
            &lt;bar>44&lt;/bar>
            text
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml.children().length()); // 4
trace(xml.children()[0].toXMLString()); // &lt;bar>44&lt;/bar>
trace(xml.children()[1].toXMLString()); // text
trace(xml.children()[2].toXMLString()); // &lt;!-- comment -->
trace(xml.children()[3].toXMLString()); // &lt;?instruction ?>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:comments"><apiName>comments</apiName><shortdesc>
	列出包含 XML 注释的 XML 对象的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.comments, comments
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>包含注释的属性的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	列出包含 XML 注释的 XML 对象的属性。
	
	</apiDesc><example conref="examples\XML.comments.1.as"> 本示例演示如何使用 <codeph>comments()</codeph> 方法：
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;foo>
            &lt;!-- example -->
            &lt;!-- example2 -->
        &lt;/foo>;
trace(xml.comments().length()); // 2
trace(xml.comments()[1].toXMLString()); // &lt;!-- example2 -->
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:contains"><apiName>contains</apiName><shortdesc>
	对比该 XML 对象与给定 value 参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.contains, contains
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 XML 对象与 <codeph>value</codeph> 参数匹配，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>要与当前 XML 对象进行对比的值。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	对比该 XML 对象与给定 <codeph>value</codeph> 参数。 
	
	</apiDesc><example conref="examples\XML.contains.1.as"> 本示例演示如何使用 <codeph>contains()</codeph> 方法：
<codeblock>
var xml:XML = 
        &lt;order>
            &lt;item>Rice&lt;/item>
            &lt;item>Kung Pao Shrimp&lt;/item>
        &lt;/order>;
trace(xml.item[0].contains(&lt;item>Rice&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>Kung Pao Shrimp&lt;/item>)); // true
trace(xml.item[1].contains(&lt;item>MSG&lt;/item>)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:copy"><apiName>copy</apiName><shortdesc>
	返回给定 XML 对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.copy, copy
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>对象的副本。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回给定 XML 对象的副本。该副本为整个节点树的副本。复制的 XML 对象没有父级，如果尝试调用 <codeph>parent()</codeph> 方法，将返回 <codeph>null</codeph>。
    
	</apiDesc><example conref="examples\XML.copy.1.as"> 本示例演示 <codeph>copy()</codeph> 方法如何创建 XML 对象的新实例。修改副本时，原始对象保持不变：
<codeblock>
var xml1:XML = &lt;foo />;
var xml2:XML = xml1.copy();
xml2.appendChild(&lt;bar />);
trace(xml1.bar.length()); // 0
trace(xml2.bar.length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:defaultSettings"><apiName>defaultSettings</apiName><shortdesc>
	返回一个下列属性设置为默认值的对象：ignoreComments、ignoreProcessingInstructions、ignoreWhitespace、prettyIndent 和 prettyPrinting。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.defaultSettings, defaultSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>属性设置为默认设置的对象。
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回一个下列属性设置为默认值的对象：<codeph>ignoreComments</codeph>、<codeph>ignoreProcessingInstructions</codeph>、<codeph>ignoreWhitespace</codeph>、<codeph>prettyIndent</codeph> 和 <codeph>prettyPrinting</codeph>。其默认值如下：
	
	<ul>
	   <li><codeph>ignoreComments = true</codeph></li>
	   <li><codeph>ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>ignoreWhitespace = true</codeph></li>
	 <li><codeph>prettyIndent = 2</codeph></li>
	   <li><codeph>prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>注意</b>：不要将此方法应用于 XML 类的实例；应将其应用于 <codeph>XML</codeph>，如以下代码所示：<codeph>var df:Object = XML.defaultSettings()</codeph>。 </p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> 下面的示例演示如何在设置 XML 对象之前应用某些自定义设置（以便包含注释和处理指令），如何在设置另一个 XML 对象之前恢复为默认设置，以及如何再次设置自定义设置（以便设置更多 XML 对象）：
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link><link href="#XML/settings()"><linktext>XML.settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:descendants"><apiName>descendants</apiName><shortdesc>
	返回包含给定 name 参数的 XML 对象的所有后代（子级、孙级、曾孙级等）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.descendants, descendants
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>匹配后代的 XMLList 对象。如果没有后代，则返回空的 XMLList 对象。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>要匹配的元素的名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	返回包含给定 <codeph>name</codeph> 参数的 XML 对象的所有后代（子级、孙级、曾孙级等）。<codeph>name</codeph> 参数是可选项。<codeph>name</codeph> 参数可以为 QName 对象、String 数据类型或随后转换为 String 数据类型的任何其它数据类型。
	
	<p>要返回所有后代，请使用“~~”参数。如果未传递任何参数，则传递字符串“*”，并返回此 XML 对象的所有后代。</p>
	
	</apiDesc><example conref="examples\XMLDescendantsExample1.as"> 要返回名称与 ActionScript 保留字相匹配的后代，请使用 <codeph>descendants()</codeph> 方法，而不要使用后代运算符 (..)， 运算符，如下面的示例所示： 
<codeblock>
var xml:XML = 
  &lt;enrollees>
    &lt;student id="239">
        &lt;class name="Algebra" />
        &lt;class name="Spanish 2"/>
    &lt;/student>
    &lt;student id="206">
        &lt;class name="Trigonometry" />
        &lt;class name="Spanish 2" />
    &lt;/student>
  &lt;/enrollees>
trace(xml.descendants("class")); 
</codeblock></example><example conref="examples\XML.descendants.1.as"> 下面的示例演示 <codeph>descendants()</codeph> 方法如何返回包含<i>所有</i>后代对象（包括子级、孙级等）的 XMLList 对象：
<codeblock>
XML.ignoreComments = false;
var xml:XML = 
        &lt;body>
            &lt;!-- comment -->
            text1
            &lt;a>
                &lt;b>text2&lt;/b>
            &lt;/a>
        &lt;/body>;
trace(xml.descendants("*").length()); // 5
trace(xml.descendants("*")[0]); // // &lt;!-- comment -->
trace(xml.descendants("*")[1].toXMLString()); // text1
trace(xml.descendants("a").toXMLString()); // &lt;a>&lt;b>text2&lt;/b>&lt;/a>
trace(xml.descendants("b").toXMLString()); // &lt;b>text2&lt;/b>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#descendant_accessor"><linktext>descendant accessor (..) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:elements"><apiName>elements</apiName><shortdesc>
	 列出某 XML 对象的元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.elements, elements
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>元素内容的 XMLList 对象。元素内容位于起始和结束标签之间。如果使用星号 (*) 调用所有元素，将返回元素的标签和内容。
	 
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>*</apiData><apiDesc>元素的名称。元素的名称由尖括号括起。例如，以下示例中的“<codeph>first</codeph>”为 <codeph>name</codeph>：<codeph>&lt;first>&lt;/first></codeph>。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 列出某 XML 对象的元素。一个由开始和结束标签组成的元素；例如 <codeph>&lt;first>&lt;/first></codeph>。<codeph>name</codeph> 参数是可选项。<codeph>name</codeph> 参数可以为 QName 对象、String 数据类型或随后转换为 String 数据类型的任何其它数据类型。使用 <codeph>name</codeph> 参数可列出特定元素。例如，以下示例中的元素“<codeph>first</codeph>”返回“<codeph>John</codeph>”：<codeph>&lt;first>John&lt;/first></codeph>。 
	 
	 <p>要列出所有元素，请使用星号 (*) 作为参数。该星号也是默认参数。 </p>
	 
	 <p>使用带星号参数的 <codeph>length()</codeph> 方法可输出元素的总数。例如，<codeph>numElement = addressbook.elements("~~").length()</codeph>。</p>
	 
	 </apiDesc><example conref="examples\XML.elements.1.as"> 下例说明 <codeph>elements()</codeph> 方法只返回元素列表，而不返回注释、文本属性或处理指令：
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
            text
            &lt;a>1&lt;/a>
            &lt;b>2&lt;/b>
        &lt;/foo>;
trace(xml.elements("*").length()); // 2
trace(xml.elements("*")[0].toXMLString()); // &lt;a>1&lt;/a>
trace(xml.elements("b").length()); // 1
trace(xml.elements("b")[0].toXMLString()); // &lt;b>2&lt;/b>
</codeblock></example><example conref="examples\XMLElementsExample1.as"> 要返回名称与 ActionScript 保留字相匹配的元素，请使用 <codeph>elements()</codeph> 方法替代 XML 点 (.) 运算符，如下面的示例所示：
<codeblock>
var xml:XML =
 &lt;student id="206">
    &lt;class name="Trigonometry" />
    &lt;class name="Spanish 2" />
 &lt;/student>
trace(xml.elements("class")); 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XMLList"><linktext>XMLList 类</linktext></link><link href="#XML/length()"><linktext>XML.length()</linktext></link><link href="#XML/attribute()"><linktext>XML.attribute()</linktext></link><link href="operators.html#dot_(XML)"><linktext>XML 点 (.) 运算符</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasComplexContent"><apiName>hasComplexContent</apiName><shortdesc>
	检查该 XML 对象是否包含复杂内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasComplexContent, hasComplexContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 XML 对象包含复杂内容，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	检查该 XML 对象是否包含复杂内容。如果 XML 对象具有子元素，则表明它包含复杂内容。表示属性、注释、处理指令和文本节点的 XML 对象不包含复杂内容。但是，仍可将<i>包含</i>上述内容的对象视为包含复杂内容（条件是该对象具有子元素）。
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> 下面的示例演示一个 XML 对象，该对象有一个包含简单内容的名为 <codeph>a</codeph> 的属性，以及一个包含复杂内容的名为 <codeph>a</codeph> 的属性：
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:hasOwnProperty"><apiName>hasOwnProperty</apiName><shortdesc>
	检查该对象是否具有 p 参数所指定的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasOwnProperty, hasOwnProperty
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果此属性存在，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要匹配的属性。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	检查该对象是否具有 <codeph>p</codeph> 参数所指定的属性。 
	
	</apiDesc><example conref="examples\XML.hasOwnProperty.1.as"> 下例使用 <codeph>hasOwnProperty()</codeph> 方法，以确保属性 (<codeph>b</codeph>) 在计算使用该属性的表达式 (<codeph>b == "11"</codeph>) 之前便已存在：
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a />
            &lt;a>
                &lt;b>10&lt;/b>
            &lt;/a>
            &lt;a>
                &lt;b>11&lt;/b>
            &lt;/a>
        &lt;/foo>;
trace(xml.a.(hasOwnProperty("b") &amp;&amp; b == "11")); 
</codeblock> 如果本示例的最后一行内容如下所示，则 Flash Player 将引发异常，因为第一个元素（名为 <codeph>a</codeph>）不具有名为 <codeph>b</codeph> 的属性：
 <p>
 <pre>trace(xml.a.(b == "11"));</pre>
 </p>
</example><example conref="examples\XML.hasOwnProperty.2.as"> 下例使用 <codeph>hasOwnProperty()</codeph> 方法，以确保属性 (<codeph>item</codeph>) 在计算使用该属性的表达式 (<codeph>item.contains("toothbrush")</codeph>) 之前便已存在：
<codeblock>
var xml:XML = 
        &lt;orders>
            &lt;order id='1'>
                &lt;item>toothbrush&lt;/item>
                &lt;item>toothpaste&lt;/item>
            &lt;/order>
            &lt;order>
                &lt;returnItem>shoe polish&lt;/returnItem>
            &lt;/order>
        &lt;/orders>;
trace(xml.order.(hasOwnProperty("item") &amp;&amp; item.contains("toothbrush"))); 
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:hasSimpleContent"><apiName>hasSimpleContent</apiName><shortdesc>
	检查该 XML 对象是否包含简单内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.hasSimpleContent, hasSimpleContent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 XML 对象包含简单内容，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	检查该 XML 对象是否包含简单内容。如果 XML 对象表示文本节点、属性节点或不包含子元素的 XML 元素，则表明它包含简单内容。表示注释和处理指令的 XML 对象<i>不</i>包含简单内容。
	
	</apiDesc><example conref="examples\XML.hasComplexContent.1.as"> 下面的示例演示一个 XML 对象，该对象有一个包含简单内容的名为 <codeph>a</codeph> 的属性，以及一个包含复杂内容的名为 <codeph>a</codeph> 的属性：
<codeblock>
var xml:XML = 
        &lt;foo>
            &lt;a>
                text
            &lt;/a>
            &lt;a>
                &lt;b/>
            &lt;/a>
        &lt;/foo>;
trace(xml.a[0].hasComplexContent()); // false
trace(xml.a[1].hasComplexContent()); // true

trace(xml.a[0].hasSimpleContent()); // true
trace(xml.a[1].hasSimpleContent()); // false
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:inScopeNamespaces"><apiName>inScopeNamespaces</apiName><shortdesc>
	根据该 XML 对象的父项列出其命名空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.inScopeNamespaces, inScopeNamespaces
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Namespace 对象的数组。 
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	根据该 XML 对象的父项列出其命名空间。 
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:insertChildAfter"><apiName>insertChildAfter</apiName><shortdesc>
	在该 XML 对象的 child1 参数后插入给定的 child2 参数并返回生成的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildAfter, insertChildAfter
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象或 <codeph>undefined</codeph>。
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>在 <codeph>child2</codeph> 之前插入的源对象中的对象。
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要插入的对象。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	在该 XML 对象的 <codeph>child1</codeph> 参数后插入给定的 <codeph>child2</codeph> 参数并返回生成的对象。如果 <codeph>child1</codeph> 参数为 <codeph>null</codeph>，则该方法将在 XML 对象的所有子项<i>之前</i> 插入 <codeph>child2</codeph> 的内容（也就是说，<i>不</i> 在任何子项之后）。如果提供 <codeph>child1</codeph>，但 XML 对象中不包含该参数，则不修改该 XML 对象并返回 <codeph>undefined</codeph>。
	
	<p>如果对不是元素（文本、属性、注释、pi 等等）的 XML 子项调用该方法，则返回 <codeph>undefined</codeph>。</p>
    
    <p>使用 <codeph>delete</codeph> (XML) 运算符删除 XML 节点。</p>
	
	</apiDesc><example conref="examples\XML.insertChildAfter.1.as"> 下面的示例将一个元素追加到 XML 对象的子元素的末尾：
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildAfter(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> <codeph>trace()</codeph> 输出如下所示：
 <pre><codeph> &lt;menu>
     &lt;item>burger&lt;/item>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>soda&lt;/item>
 &lt;/menu></codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildBefore()"><linktext>XML.insertChildBefore()</linktext></link><link href="operators.html#delete_(XML)"><linktext>delete (XML) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:insertChildBefore"><apiName>insertChildBefore</apiName><shortdesc>
	在该 XML 对象的 child1 参数前插入给定的 child2 参数并返回生成的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.insertChildBefore, insertChildBefore
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象或 <codeph>undefined</codeph>。
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>在 <codeph>child2</codeph> 之后插入的源对象中的对象。
	</apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要插入的对象。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	在该 XML 对象的 <codeph>child1</codeph> 参数前插入给定的 <codeph>child2</codeph> 参数并返回生成的对象。如果 <codeph>child1</codeph> 参数为 <codeph>null</codeph>，则该方法将在 XML 对象的所有子项<i>之后</i> 插入 <codeph>child2</codeph> 的内容（也就是说，<i>不</i> 在任何子项之前）。如果提供 <codeph>child1</codeph>，但 XML 对象中不包含该参数，则不修改该 XML 对象并返回 <codeph>undefined</codeph>。
	
	<p>如果对不是元素（文本、属性、注释、pi 等等）的 XML 子项调用该方法，则返回 <codeph>undefined</codeph>。</p>
    
    <p>使用 <codeph>delete</codeph> (XML) 运算符删除 XML 节点。</p>
	
	</apiDesc><example conref="examples\XML.insertChildBefore.1.as"> 下面的示例将一个元素追加到 XML 对象的子元素的末尾：
<codeblock>
var xml:XML = 
        &lt;menu>
            &lt;item>burger&lt;/item>
            &lt;item>soda&lt;/item>
        &lt;/menu>;
xml.insertChildBefore(xml.item[0], &lt;saleItem>fries&lt;/saleItem>);
trace(xml);
</codeblock> <codeph>trace()</codeph> 输出如下所示：
 <pre>
 &lt;menu>
     &lt;saleItem>fries&lt;/saleItem>
     &lt;item>burger&lt;/item>
     &lt;item>soda&lt;/item>
 &lt;/menu></pre>
</example></apiOperationDetail><related-links><link href="#XML/insertChildAfter()"><linktext>XML.insertChildAfter()</linktext></link><link href="operators.html#delete_(XML)"><linktext>delete (XML) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:length"><apiName>length</apiName><shortdesc>
	对于 XML 对象，该方法始终返回整数 1。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.length, length
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>对于任何 XML 对象，始终返回 <codeph>1</codeph>。
	
	</apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	对于 XML 对象，该方法始终返回整数 <codeph>1</codeph>。XMLList 类的 <codeph>length()</codeph> 方法对仅包含一个值的 XMLList 对象返回值 <codeph>1</codeph>。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:localName"><apiName>localName</apiName><shortdesc>
	提供该 XML 对象限定名称的本地名称部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.localName, localName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>作为 String 或 <codeph>null</codeph> 的本地名称。
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	提供该 XML 对象限定名称的本地名称部分。
	
	</apiDesc><example conref="examples\XML.localName.1.as"> 下面的示例演示如何使用 <codeph>localName()</codeph> 方法：
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.localName()); // Envelope
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:name"><apiName>name</apiName><shortdesc>
	提供该 XML 对象的限定名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.name, name
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>限定名称为 QName 或 <codeph>null</codeph>。
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	提供该 XML 对象的限定名称。 
	
	</apiDesc><example conref="examples\XML.name.1.as"> 下面的示例演示如何使用 <codeph>name()</codeph> 方法获取 XML 对象的限定名称：
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
trace(xml.name().localName); // Envelope
trace(xml.name().uri); // "http://www.w3.org/2001/12/soap-envelope"
</codeblock></example><example conref="examples\XML.name.2.as"> 下面的示例演示如何对 XML 属性 (property)、文本元素和属性 (attribute) 调用 <codeph>name()</codeph> 方法：
<codeblock>
var xml:XML = 
        &lt;foo x="15" y="22">
            text
        &lt;/foo>;
        
trace(xml.name().localName); // foo
trace(xml.name().uri == ""); // true
trace(xml.children()[0]); // text
trace(xml.children()[0].name()); // null
trace(xml.attributes()[0]); // 15
trace(xml.attributes()[0].name()); // x
</codeblock></example></apiOperationDetail><related-links><link href="#XML/attributes()"><linktext>XML.attributes()</linktext></link><link href="operators.html#attribute_identifier"><linktext>attribute identifier</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:namespace"><apiName>namespace</apiName><shortdesc>
	如果没有提供参数，则提供与该 XML 对象的限定名关联的命名空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespace, namespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>返回 <codeph>null</codeph>、<codeph>undefined</codeph> 或命名空间。
	
	</apiDesc><apiType value="any"/></apiReturn><apiParam><apiItemName>prefix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>要匹配的前缀。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	如果没有提供参数，则提供与该 XML 对象的限定名关联的命名空间。如果指定了 <codeph>prefix</codeph> 参数，则该方法将返回与 <codeph>prefix</codeph> 参数匹配且位于 XML 对象所在范围内的命名空间。如果不存在此类命名空间，该方法将返回 <codeph>undefined</codeph>。
	
	</apiDesc><example conref="examples\XML.namespace.1.as"> 下例使用 <codeph>namespace()</codeph> 方法获取 XML 对象的命名空间，并将其分配给名为 <codeph>soap</codeph> 的 Namespace 对象，随后将使用该对象标识 <codeph>xml</codeph> 对象 (<codeph>xml.soap::Body[0]</codeph>)：
<codeblock>
var xml:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

                        &lt;soap:Body xmlns:wx = "http://example.com/weather">
                &lt;wx:forecast>
                    &lt;wx:city>Quito&lt;/wx:city>
                &lt;/wx:forecast>
            &lt;/soap:Body>
        &lt;/soap:Envelope>;
        
var soap:Namespace = xml.namespace();
trace(soap.prefix); // soap
trace(soap.uri); // http://www.w3.org/2001/12/soap-envelope

var body:XML = xml.soap::Body[0];
trace(body.namespace().prefix); // soap
trace(xml.namespace().uri); // http://www.w3.org/2001/12/soap-envelope
trace(body.namespace("wx").uri); // "http://example.com/weather"
</codeblock></example><example conref="examples\XML.namespace.2.as"> 下例使用 <codeph>namespace()</codeph> 方法获取节点的默认命名空间，以及特定前缀 (<codeph>"dc"</codeph>) 的命名空间：
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">
                &lt;!-- ... -->
        &lt;/rdf:RDF>;
                    
trace(xml.namespace()); // http://www.w3.org/1999/02/22-rdf-syntax-ns#
trace(xml.namespace("dc")); // http://purl.org/dc/elements/1.1/
trace(xml.namespace("foo")); // undefined
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:namespaceDeclarations"><apiName>namespaceDeclarations</apiName><shortdesc>
	在该 XML 对象的父项中列出与其关联的命名空间声明。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.namespaceDeclarations, namespaceDeclarations
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Namespace 对象的数组。
	
	</apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	在该 XML 对象的父项中列出与其关联的命名空间声明。 
	
	</apiDesc><example conref="examples\XML.namespaceDeclarations.1.as"> 下面的示例输出 XML 对象的命名空间声明：
<codeblock>
var xml:XML = 
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
            xmlns:dc="http://purl.org/dc/elements/1.1/" 
            xmlns="http://purl.org/rss/1.0/">

            &lt;!-- ... -->
            
        &lt;/rdf:RDF>;
                    
for (var i:uint = 0; i &lt; xml.namespaceDeclarations().length; i++) {
    var ns:Namespace = xml.namespaceDeclarations()[i]; 
    var prefix:String = ns.prefix;
    if (prefix == "") {
        prefix = "(default)";
    }
    trace(prefix + ":" , ns.uri);
}
</codeblock> <codeph>trace()</codeph> 输出如下所示：
 <pre><codeph>rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
 dc: http://purl.org/dc/elements/1.1/
 (default): http://purl.org/rss/1.0/</codeph></pre>
</example></apiOperationDetail><related-links><link href="#XML/namespace()"><linktext>XML.namespace()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:nodeKind"><apiName>nodeKind</apiName><shortdesc>
	指定节点的类型：文本、注释、处理指令、属性或元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.nodeKind, nodeKind
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>所使用的节点类型。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	指定节点的类型：文本、注释、处理指令、属性或元素。 
	
	</apiDesc><example conref="examples\XMLNodeKindExample1.as"> 下面的示例跟踪所有这五种节点类型：
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;

var xml:XML = 
    &lt;example id="10">
        &lt;!-- this is a comment -->
        &lt;?test this is a pi ?>
        and some text
    &lt;/example>;

trace(xml.nodeKind()); // element
trace(xml.children()[0].nodeKind()); // comment
trace(xml.children()[1].nodeKind()); // processing-instruction
trace(xml.children()[2].nodeKind()); // text
trace(xml.@id[0].nodeKind()); // attribute
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#attribute_identifier"><linktext>attribute identifier</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:normalize"><apiName>normalize</apiName><shortdesc>
	对于该 XML 对象以及所有子级 XML 对象，合并相邻文本节点并删除空文本节点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.normalize, normalize
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的标准 XML 对象。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	对于该 XML 对象以及所有子级 XML 对象，合并相邻文本节点并删除空文本节点。
	
	</apiDesc><example conref="examples\XML.normalize.1.as"> 下面的示例演示调用 <codeph>normalize()</codeph> 方法的效果：
<codeblock>
var xml:XML = &lt;body>&lt;/body>;
xml.appendChild("hello");
xml.appendChild(" world");
trace(xml.children().length()); // 2
xml.normalize();
trace(xml.children().length()); // 1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:parent"><apiName>parent</apiName><shortdesc>
	返回 XML 对象的父项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.parent, parent
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>父节点的 XML 引用或 <codeph>undefined</codeph>（如果 XML 对象没有父级）。
	
	</apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	返回 XML 对象的父项。如果该 XML 对象没有父项，则该方法返回 <codeph>undefined</codeph>。
	
	</apiDesc><example conref="examples\XML.parent.1.as"> 下例使用 <codeph>parent()</codeph> 方法标识 XML 结构中特定元素的父项：
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p id="p1">Hello&lt;/p>
        &lt;p id="p2">Test:
            &lt;ul>
                &lt;li>1&lt;/li>
                &lt;li>2&lt;/li>
            &lt;/ul>
        &lt;/p>
    &lt;/body>;
var node:XML = xml.p.ul.(li.contains("1"))[0]; // == &lt;ul> ... &lt;/ul>
trace(node.parent().@id); // p2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:prependChild"><apiName>prependChild</apiName><shortdesc>
	将提供的 child 对象的副本插入 XML 元素中，并放在该元素的任何现有 XML 属性前面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prependChild, prependChild
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象。
    
    </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要插入的对象。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	将提供的 <codeph>child</codeph> 对象的副本插入 XML 元素中，并放在该元素的任何现有 XML 属性前面。
    
    <p>使用 <codeph>delete</codeph> (XML) 运算符删除 XML 节点。</p> 
	
	</apiDesc><example conref="examples\XML.prependChild.1.as"> 下面的示例使用 <codeph>prependChild()</codeph> 方法将元素添加到 XML 对象子级列表的开头：
<codeblock>
var xml:XML = 
        &lt;body>
            &lt;p>hello&lt;/p>
        &lt;/body>;
        
xml.prependChild(&lt;p>world&lt;/p>);    
trace(xml.p[0].toXMLString()); // &lt;p>world&lt;/p>
trace(xml.p[1].toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="operators.html#delete_(XML)"><linktext>delete (XML) operator</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:processingInstructions"><apiName>processingInstructions</apiName><shortdesc>
	如果提供了 name 参数，则列出 XML 对象中包含带有该 name 的处理指令的所有子项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.processingInstructions, processingInstructions
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>匹配的子对象的列表。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>*</apiData><apiDesc>要匹配的处理指令的名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	如果提供 <codeph>name</codeph> 参数，则列出包含该 <codeph>name</codeph> 的处理指令的 XML 对象的所有子项。如果未提供参数，则该方法会列出包含任何处理指令的 XML 对象的所有子项。
	
	</apiDesc><example conref="examples\XML.processingInstructions.1.as"> 下面的示例使用 <codeph>processingInstructions()</codeph> 方法获取 XML 对象的处理指令数组：
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml:XML =
    &lt;body>
            foo
            &lt;?xml-stylesheet href="headlines.css" type="text/css" ?>
            &lt;?instructionX ?>
            
    &lt;/body>;

trace(xml.processingInstructions().length()); // 2
trace(xml.processingInstructions()[0].name()); // xml-stylesheet
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:propertyIsEnumerable"><apiName>propertyIsEnumerable</apiName><shortdesc>
	检查属性 p 所在的属性集是否可在应用于 XMLList 对象的 for..in 语句中遍历。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.propertyIsEnumerable, propertyIsEnumerable
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果该属性可以在 <codeph>for..in</codeph> 语句中，为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>p</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要检查的属性。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	检查属性 <codeph>p</codeph> 所在的属性集是否可在应用于 XMLList 对象的 <codeph>for..in</codeph> 语句中遍历。仅当 <codeph>toString(p) == "0"</codeph> 时返回 <codeph>true</codeph>。 
	
	</apiDesc><example conref="examples\XML.propertyIsEnumerable.1.as"> 下例演示，对于 XML 对象，<codeph>propertyNameIsEnumerable()</codeph> 方法返回值 <codeph>true</codeph>（仅对于值 <codeph>0</codeph>），而对于 XMLList 对象，返回值为 <codeph>true</codeph>（对于 XMLList 对象的每个有效索引值）：
<codeblock>
var xml:XML = 
        &lt;body>
             &lt;p>Hello&lt;/p>
               &lt;p>World&lt;/p>
        &lt;/body>;

trace(xml.propertyIsEnumerable(0)); // true
trace(xml.propertyIsEnumerable(1)); // false

for (var propertyName:String in xml) {
    trace(xml[propertyName]);
}

var list:XMLList = xml.p;
trace(list.propertyIsEnumerable(0)); // true
trace(list.propertyIsEnumerable(1)); // true
trace(list.propertyIsEnumerable(2)); // false

for (var propertyName:String in list) { 
    trace(list[propertyName]);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:removeNamespace"><apiName>removeNamespace</apiName><shortdesc>
	删除该对象及其所有子级的给定命名空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.removeNamespace, removeNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象的副本。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>要删除的命名空间。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	删除该对象及其所有子级的给定命名空间。如果命名空间由该对象的限定名称或该对象属性的限定名称引用，则 <codeph>removeNamespaces()</codeph> 方法不会删除该命名空间。
	
	</apiDesc><example conref="examples\XML.removeNamespace.1.as"> 下面的示例演示如何删除 XML 对象的命名空间声明：
<codeblock>
var xml:XML = 
    &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
        xmlns:dc="http://purl.org/dc/elements/1.1/" 
        xmlns="http://purl.org/rss/1.0/">
    
        &lt;!-- ... -->
        
    &lt;/rdf:RDF>;

trace(xml.namespaceDeclarations().length); // 3
trace(xml.namespaceDeclarations()[0] is String); // 
var dc:Namespace = xml.namespace("dc");
xml.removeNamespace(dc);
trace(xml.namespaceDeclarations().length); // 2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:replace"><apiName>replace</apiName><shortdesc>
	用给定的 value 参数替换 propertyName 参数所指定的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.replace, replace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象，其中替换了匹配属性。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>可以是数值、XML 元素集的非限定名称、XML 元素集的限定名称或星号通配符 (*)。使用非限定名称标识默认命名空间中的 XML 元素。 
	
	</apiDesc></apiParam><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>XML</apiOperationClassifier><apiDesc>替换值。它可以是 XML 对象、XMLList 对象或可以使用 <codeph>toString()</codeph> 转换的任何值。 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	用给定的 <codeph>value</codeph> 参数替换 <codeph>propertyName</codeph> 参数所指定的属性。如果没有属性与 <codeph>propertyName</codeph> 匹配，会将 XML 对象保持为未修改状态。
	
	</apiDesc><example conref="examples\XML.replace.1.as"> 下面的示例演示在调用 <codeph>replace()</codeph> 方法时将整数作为第一个参数：
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace(1, &lt;p>Bob&lt;/p>);
trace(xml);
</codeblock> 这将产生以下 <codeph>trace()</codeph> 输出：
 <pre><codeph>
 &lt;body>
     &lt;p>Hello&lt;/p>
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/body>
 </codeph></pre>
</example><example conref="examples\XML.replace.2.as"> 下面的示例调用 <codeph>replace()</codeph> 方法时将字符串作为第一个参数：
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("p", &lt;p>Hi&lt;/p>); 
trace(xml);
</codeblock> 这将产生以下 <codeph>trace()</codeph> 输出：
 
 <pre><codeph>
 &lt;body>
     &lt;p>Hi&lt;/p>
     &lt;hr/>
 &lt;/body>;
 </codeph></pre>
</example><example conref="examples\XML.replace.3.as"> 下面的示例演示在调用 <codeph>replace()</codeph> 方法时将 QName 作为第一个参数：
<codeblock>
var xml:XML = 
    &lt;ns:body xmlns:ns = "myNS">
        &lt;ns:p>Hello&lt;/ns:p>
        &lt;ns:p>World&lt;/ns:p>
        &lt;hr/>
    &lt;/ns:body>;

var qname:QName = new QName("myNS", "p");
xml.replace(qname, &lt;p>Bob&lt;/p>);
trace(xml);

</codeblock> 这将产生以下 <codeph>trace()</codeph> 输出：
 
 <pre><codeph>
 &lt;ns:body xmlns:ns = "myNS">
     &lt;p>Bob&lt;/p>
     &lt;hr/>
 &lt;/ns:body>
 </codeph></pre>
</example><example conref="examples\XML.replace.4.as"> 下面的示例演示在调用 <codeph>replace()</codeph> 方法时将字符串 <codeph>"*"</codeph> 作为第一个参数：
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
        &lt;hr/>
    &lt;/body>;

xml.replace("*", &lt;img src = "hello.jpg"/>);
trace(xml);
</codeblock> 这将产生以下 <codeph>trace()</codeph> 输出：
 
 <pre><codeph>
 &lt;body>
     &lt;img src="hello.jpg"/>
 &lt;/body>
 </codeph></pre>
</example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setChildren"><apiName>setChildren</apiName><shortdesc>
	用 value 参数中提供的指定 XML 属性集替换该 XML 对象的子属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setChildren, setChildren
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>生成的 XML 对象。 
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>替换 XML 属性。可以是单个 XML 对象或 XMLList 对象。 
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	用 <codeph>value</codeph> 参数中提供的指定 XML 属性集替换该 XML 对象的子属性。
	
	</apiDesc><example conref="examples\XML.setChildren.1.as"> 下面的示例演示在调用 <codeph>setChildren()</codeph> 方法时，先使用 XML 对象作为参数，然后使用 XMLList 对象作为参数：
<codeblock>
var xml:XML = 
    &lt;body>
        &lt;p>Hello&lt;/p>
        &lt;p>World&lt;/p>
    &lt;/body>;

var list:XMLList = xml.p;

xml.setChildren(&lt;p>hello&lt;/p>);
trace(xml);

//    &lt;body>
//        &lt;p>hello&lt;/p>
//    &lt;/body>

xml.setChildren(list);
trace(xml);

//    &lt;body>
//        &lt;p>Hello&lt;/p>
//        &lt;p>World&lt;/p>
//    &lt;/body>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setLocalName"><apiName>setLocalName</apiName><shortdesc>
	将该 XML 对象的本地名称更改为给定的 name 参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setLocalName, setLocalName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>本地名称的替换名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	将该 XML 对象的本地名称更改为给定的 <codeph>name</codeph> 参数。 
	
	</apiDesc><example conref="examples\XML.setLocalName.1.as"> 下面的示例使用 <codeph>setLocalName()</codeph> 方法更改 XML 元素的本地名称：
<codeblock>
var xml:XML = 
    &lt;ns:item xmlns:ns="http://example.com">
        toothbrush
    &lt;/ns:item>;
    
xml.setLocalName("orderItem");
trace(xml.toXMLString()); // &lt;ns:orderItem xmlns:ns="http://example.com">toothbrush&lt;/ns:orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setName"><apiName>setName</apiName><shortdesc>
	将该 XML 对象的名称设置为给定限定名称或属性名。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setName, setName
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对象的新名称。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	将该 XML 对象的名称设置为给定限定名称或属性名。 
	
	</apiDesc><example conref="examples\XML.setName.1.as"> 下面的示例使用 <codeph>setName()</codeph> 方法更改 XML 元素的名称：
<codeblock>
var xml:XML = 
    &lt;item>
        toothbrush
    &lt;/item>;
    
xml.setName("orderItem");
trace(xml.toXMLString()); // &lt;orderItem>toothbrush&lt;/orderItem>
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setNamespace"><apiName>setNamespace</apiName><shortdesc>
	设置与该 XML 对象关联的命名空间。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setNamespace, setNamespace
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>ns</apiItemName><apiOperationClassifier>Namespace</apiOperationClassifier><apiDesc>新命名空间。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	设置与该 XML 对象关联的命名空间。
	
	</apiDesc><example conref="examples\XML.setNamespace.1.as"> 下例使用在某个 XML 对象中定义的 <codeph>soap</codeph> 命名空间，并将其应用于另一个 XML 对象 (<codeph>xml2</codeph>) 的命名空间：
<codeblock>
var xml1:XML = 
        &lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
            soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
            &lt;!-- ... -->
        &lt;/soap:Envelope>;
var ns:Namespace = xml1.namespace("soap");

var xml2:XML = 
    &lt;Envelope>
        &lt;Body/>
    &lt;/Envelope>;
    
xml2.setNamespace(ns);

trace(xml2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:setSettings"><apiName>setSettings</apiName><shortdesc>
	设置下列 XML 属性的值：ignoreComments、ignoreProcessingInstructions、ignoreWhitespace、prettyIndent 和 prettyPrinting。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.setSettings, setSettings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rest</apiItemName><apiType value="restParam"/><apiDesc>具有下列各个属性的对象： 
	
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	设置下列 XML 属性的值：<codeph>ignoreComments</codeph>、<codeph>ignoreProcessingInstructions</codeph>、<codeph>ignoreWhitespace</codeph>、<codeph>prettyIndent</codeph> 和 <codeph>prettyPrinting</codeph>。以下是默认设置，如果未提供 <codeph>setObj</codeph> 参数，将应用这些设置：
	
	<ul>
	   <li><codeph>XML.ignoreComments = true</codeph></li>
	   <li><codeph>XML.ignoreProcessingInstructions = true</codeph></li>
	   <li><codeph>XML.ignoreWhitespace = true</codeph></li>
	   <li><codeph>XML.prettyIndent = 2</codeph></li>
	   <li><codeph>XML.prettyPrinting = true</codeph></li>
	</ul>
	
	<p><b>注意</b>：不要将此方法应用于 XML 类的实例；应将其应用于 <codeph>XML</codeph>，如以下代码所示：<codeph>XML.setSettings()</codeph>。</p>
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> 下面的示例演示如何在设置 XML 对象之前应用某些自定义设置（以便包含注释和处理指令），如何在设置另一个 XML 对象之前恢复为默认设置，以及如何再次设置自定义设置（以便设置更多 XML 对象）：
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>defaultSettings()</linktext></link><link href="#XML/settings()"><linktext>settings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:settings"><apiName>settings</apiName><shortdesc>
	检索下列属性：ignoreComments、ignoreProcessingInstructions、ignoreWhitespace、prettyIndent 和 prettyPrinting。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.settings, settings
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiStatic/><apiReturn><apiDesc>具有下列 XML 属性的对象：
	<ul>
	   <li><codeph>ignoreComments</codeph></li>
	   <li><codeph>ignoreProcessingInstructions</codeph></li>
	   <li><codeph>ignoreWhitespace</codeph></li>
	   <li><codeph>prettyIndent</codeph></li>
	   <li><codeph>prettyPrinting</codeph></li>
	</ul>
	
	</apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	检索下列属性：<codeph>ignoreComments</codeph>、<codeph>ignoreProcessingInstructions</codeph>、<codeph>ignoreWhitespace</codeph>、<codeph>prettyIndent</codeph> 和 <codeph>prettyPrinting</codeph>。
	
	</apiDesc><example conref="examples\XML.defaultSettings.1.as"> 下面的示例演示如何在设置 XML 对象之前应用某些自定义设置（以便包含注释和处理指令），如何在设置另一个 XML 对象之前恢复为默认设置，以及如何再次设置自定义设置（以便设置更多 XML 对象）：
<codeblock>
XML.ignoreComments = false;
XML.ignoreProcessingInstructions = false;
var customSettings:Object = XML.settings();

var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml1.toXMLString());
//    &lt;foo>
//        &lt;!-- comment -->
//         &lt;?instruction ?>
//    &lt;/foo>

XML.setSettings(XML.defaultSettings());
var xml2:XML = 
        &lt;foo>
            &lt;!-- comment -->
            &lt;?instruction ?>
        &lt;/foo>;
trace(xml2.toXMLString());
</codeblock></example></apiOperationDetail><related-links><link href="#XML/ignoreComments"><linktext>XML.ignoreComments</linktext></link><link href="#XML/ignoreProcessingInstructions"><linktext>XML.ignoreProcessingInstructions</linktext></link><link href="#XML/ignoreWhitespace"><linktext>XML.ignoreWhitespace</linktext></link><link href="#XML/prettyIndent"><linktext>XML.prettyIndent</linktext></link><link href="#XML/prettyPrinting"><linktext>XML.prettyPrinting</linktext></link><link href="#XML/defaultSettings()"><linktext>XML.defaultSettings()</linktext></link><link href="#XML/setSettings()"><linktext>XML.setSettings()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:text"><apiName>text</apiName><shortdesc>
	返回 XML 对象用来表示 XML 文本节点的所有 XML 属性的 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.text, text
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>属性列表。
	
	</apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XML 对象用来表示 XML 文本节点的所有 XML 属性的 XMLList 对象。
	
	</apiDesc><example conref="examples\XML.text.1.as"> 下面的示例使用 <codeph>text()</codeph> 方法获得 XML 对象的文本节点：
<codeblock>
var xml:XML =
        &lt;body>
            text1
            &lt;hr/>
            text2
        &lt;/body>;
trace(xml.text()[0]); // text1
trace(xml.text()[1]); // text2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="XML:AS3:toString"><apiName>toString</apiName><shortdesc>
	返回 XML 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toString, toString 
	
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象的字符串表示形式。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XML 对象的字符串表示形式。此转换的规则取决于 XML 对象包含的是简单内容还是复杂内容：
	
	<ul>
		<li>如果 XML 对象包含简单内容，<codeph>toString()</codeph> 将返回 XML 对象的字符串内容，但从中除去了以下内容：开始标签、属性、命名空间声明和结束标签。</li> 
	</ul>
	
	<ul>
		<li> 如果 XML 对象包含复杂内容，<codeph>toString()</codeph> 将返回 XML 编码字符串，该字符串表示完整的 XML 对象，包括开始标签、属性、命名空间声明和结束标签。</li>
	</ul>
	
	<p>要每次都返回整个 XML 对象，请使用 <codeph>toXMLString()</codeph>。</p>
	
	
	</apiDesc><example conref="examples\XMLToStringExample1.as"> 下面的示例演示当 XML 对象包含简单内容时 <codeph>toString()</codeph> 方法的返回值：
<codeblock>
var test:XML = &lt;type name="Joe">example&lt;/type>;
trace(test.toString()); //example
</codeblock></example><example conref="examples\XMLToStringExample2.as"> 下面的示例演示当 XML 对象包含复杂内容时 <codeph>toString()</codeph> 方法的返回值：
<codeblock>
var test:XML = 
&lt;type name="Joe">
    &lt;base name="Bob">&lt;/base>
    example
&lt;/type>;
trace(test.toString());
  // &lt;type name="Joe">
  // &lt;base name="Bob"/>
  // example
  // &lt;/type> 
</codeblock></example></apiOperationDetail><related-links><link href="#XML/hasSimpleContent()"><linktext>XML.hasSimpleContent()</linktext></link><link href="#XML/hasComplexContent()"><linktext>XML.hasComplexContent()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:toXMLString"><apiName>toXMLString</apiName><shortdesc>
	返回 XML 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.toXMLString, toXMLString
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 对象的字符串表示形式。
	
	</apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回 XML 对象的字符串表示形式。与 <codeph>toString()</codeph> 方法不同，<codeph>toXMLString()</codeph> 方法始终返回 XML 对象的开始标签、属性和结束标签，与 XML 对象包含的是简单内容还是复杂内容无关。（<codeph>toString()</codeph> 方法去除包含简单内容的 XML 对象的这些项。）
	
	</apiDesc><example conref="examples\XML.toXMLString.1.as"> 下面的示例演示使用 <codeph>toString()</codeph> 方法（默认情况下适用于 <codeph>trace()</codeph> 方法的所有参数）与使用 <codeph>toXMLString()</codeph> 方法之间的区别：
<codeblock>
var xml:XML =
        &lt;p>hello&lt;/p>;
trace(xml); // hello
trace(xml.toXMLString()); // &lt;p>hello&lt;/p>
</codeblock></example></apiOperationDetail><related-links><link href="#XML/toString()"><linktext>XML.toString()</linktext></link></related-links></apiOperation><apiOperation id="XML:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	返回该 XML 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.valueOf, valueOf
	</keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>XML 实例的原始值。
	
	</apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	返回该 XML 对象。 
	
	</apiDesc><example conref="examples\XML.valueOf.1.as"> 下面的示例演示 <codeph>valueOf()</codeph> 方法返回的值与源 XML 对象相同：
<codeblock>
var xml:XML = &lt;p>hello&lt;/p>;
trace(xml.valueOf() === xml); // true
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="XML:ignoreComments:get"><apiName>ignoreComments</apiName><shortdesc>
	确定当 XML 对象分析源 XML 数据时，是否忽略 XML 注释。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreComments, ignoreComments
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	确定当 XML 对象分析源 XML 数据时，是否忽略 XML 注释。默认情况下，将忽略注释 (<codeph>true</codeph>)。要包括 XML 注释，请将此属性设置为 <codeph>false</codeph>。<codeph>ignoreComments</codeph> 属性仅在 XML 分析过程中使用，而不能在调用任何方法（例如，<codeph>myXMLObject.child(~~).toXMLString()</codeph>）时使用。如果源 XML 包含注释节点，可在 XML 分析过程中保留或丢弃这些节点。 
	
	</apiDesc><example conref="examples\XML.ignoreComments.1.as"> 本示例演示将 <codeph>XML.ignoreComments</codeph> 设置为 <codeph>false</codeph> 以及设置为 <codeph>true</codeph> 的效果：
<codeblock>
XML.ignoreComments = false;
var xml1:XML = 
        &lt;foo>
            &lt;!-- comment -->
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;!-- comment -->&lt;/foo>

XML.ignoreComments = true;
var xml2:XML = 
        &lt;foo>
            &lt;!-- example -->
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreProcessingInstructions:get"><apiName>ignoreProcessingInstructions</apiName><shortdesc>
	确定当 XML 对象分析源 XML 数据时，是否忽略 XML 处理指令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreProcessingInstructions, ignoreProcessingInstructions
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	确定当 XML 对象分析源 XML 数据时，是否忽略 XML 处理指令。默认情况下，将忽略处理指令 (<codeph>true</codeph>)。要包括 XML 处理指令，请将此属性设置为 <codeph>false</codeph>。<codeph>ignoreProcessingInstructions</codeph> 属性仅在 XML 分析过程中使用，而不能在调用任何方法（例如，<codeph>myXMLObject.child(~~).toXMLString()</codeph>）时使用。如果源 XML 包含处理指令节点，可在 XML 分析过程中保留或丢弃这些节点。
	
	</apiDesc><example conref="examples\XML.ignoreProcessingInstructions.1.as"> 本示例演示将 <codeph>XML.ignoreProcessingInstructions</codeph> 设置为 <codeph>false</codeph> 以及设置为 <codeph>true</codeph> 的效果：
<codeblock>
XML.ignoreProcessingInstructions = false;
var xml1:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml1.toXMLString()); // &lt;foo>&lt;?exampleInstruction ?>&lt;/foo>

XML.ignoreProcessingInstructions = true;
var xml2:XML = 
        &lt;foo>
            &lt;?exampleInstruction ?>
        &lt;/foo>;
trace(xml2.toXMLString()); // &lt;foo/>
</codeblock></example></apiValueDetail><related-links><link href="#XML/child()"><linktext>XML.child()</linktext></link><link href="#XML/toXMLString()"><linktext>XML.toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:ignoreWhitespace:get"><apiName>ignoreWhitespace</apiName><shortdesc>
	确定分析期间是否忽略文本节点开头和末尾处的空白字符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.ignoreWhitespace, ignoreWhitespace
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	确定分析期间是否忽略文本节点开头和末尾处的空白字符。默认情况下，将忽略空白 (<codeph>true</codeph>)。如果文本节点 100% 是空白，且 <codeph>ignoreWhitespace</codeph> 属性设置为 <codeph>true</codeph>，则不会创建该节点。要显示文本节点中的空白，请将 <codeph>ignoreWhitespace</codeph> 属性设置为 <codeph>false</codeph>。 
	
	</apiDesc><example conref="examples\XML.ignoreWhitespace.1.as"> 本示例演示将 <codeph>XML.ignoreWhitespace</codeph> 设置为 <codeph>false</codeph> 以及设置为 <codeph>true</codeph> 的效果：
<codeblock>
XML.ignoreWhitespace = false;
var xml1:XML = &lt;foo>    &lt;/foo>;
trace(xml1.children().length()); // 1

XML.ignoreWhitespace = true;
var xml2:XML = &lt;foo>    &lt;/foo>;
trace(xml2.children().length()); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="XML:prettyIndent:get"><apiName>prettyIndent</apiName><shortdesc>
	确定当 XML.prettyPrinting 属性设置为 true 时，toString() 和 toXMLString() 方法所应用的缩进量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyIndent, prettyIndent
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	确定当 <codeph>XML.prettyPrinting</codeph> 属性设置为 <codeph>true</codeph> 时，<codeph>toString()</codeph> 和 <codeph>toXMLString()</codeph> 方法所应用的缩进量。应用缩进时使用空格字符，而不是制表符。默认值为 <codeph>2</codeph>。
	
	</apiDesc><example conref="examples\XML.prettyIndent.1.as"> 本示例演示设置 <codeph>XML.prettyIndent</codeph> 静态属性的效果：
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyIndent = 0;
trace(xml.toXMLString());

XML.prettyIndent = 1;
trace(xml.toXMLString());

XML.prettyIndent = 2;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyPrinting"><linktext>prettyPrinting</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue><apiValue id="XML:prettyPrinting:get"><apiName>prettyPrinting</apiName><shortdesc>
	确定 toString() 和 toXMLString() 方法是否对某些标签之间的空白字符进行规格化。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>XML, XML.prettyPrinting, prettyPrinting
	</keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	确定 <codeph>toString()</codeph> 和 <codeph>toXMLString()</codeph> 方法是否对某些标签之间的空白字符进行规格化。默认值为 <codeph>true</codeph>。
	
	</apiDesc><example conref="examples\XML.prettyPrinting.1.as"> 本示例演示设置 <codeph>XML.prettyPrinting</codeph> 静态属性的效果：
<codeblock>
var xml:XML = &lt;foo>&lt;bar/>&lt;/foo>;
XML.prettyPrinting = false;
trace(xml.toXMLString());

XML.prettyPrinting = true;
trace(xml.toXMLString());
</codeblock></example></apiValueDetail><related-links><link href="#XML/prettyIndent"><linktext>prettyIndent</linktext></link><link href="#XML/toString()"><linktext>toString()</linktext></link><link href="#XML/toXMLString()"><linktext>toXMLString()</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:Array"><apiName>Array</apiName><shortdesc>
	 创建一个新数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>长度为 0 或大于 0 的数组。
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>不传递参数可以创建空数组，传递单个整数参数可以创建具有特定长度的数组，传递一系列由逗号分隔的具有各种类型的值可创建使用这些值填充的数组。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 创建一个新数组。可以是长度为 0 或大于 0 的数组，也可以是由一组指定元素（可能具有不同的数据类型）填充的数组。所使用参数的数目和数据类型决定了返回数组的内容。
	 <ul>
	   <li>在不使用参数的情况下调用 <codeph>Array()</codeph> 会返回空的数组。</li>
	   <li>使用单个整数参数调用 <codeph>Array()</codeph> 可返回具有指定长度的数组，但数组元素具有未定义的值。</li>
	   <li>使用一组指定值调用 <codeph>Array()</codeph> 将返回由包含各个指定值的元素构成的数组。</li>
	 </ul>
	 使用 <codeph>Array()</codeph> 函数类似于使用 Array 类构造函数创建数组。
	 <p>当参数不是原始值时，应使用 <codeph>as</codeph> 运算符进行显式类型转换或类型转换。有关详细信息，请参阅本条目的“示例”部分。 </p>
	 </apiDesc><example conref="examples\Array.func.4.as"> 下面的示例演示 <codeph>Array()</codeph> 函数在参数不是原始值时的行为。转换为数组的一种常见用法是转换以数组格式存储值的 Object 实例。如果调用 <codeph>Array()</codeph> 时使用了 <codeph>Object</codeph> 类型或其它任何非基元数据类型的参数，则对对象的引用将存储在新数组的元素中。也就是说，如果传递的唯一参数是一个对象，则对该对象的引用将成为新数组的第一个元素。
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = Array( obj );

trace(newArray == obj);    // false
trace(newArray[0] == obj); // true
trace(newArray[0][0])      // a
trace(newArray[0][1])      // b
trace(newArray[0][2])      // c
</codeblock></example><example conref="examples\Array.func.5.as"> 要将 <codeph>obj</codeph> 转换为数组，请使用 <codeph>as</codeph> 运算符，它将在 <codeph>obj</codeph> 为有效数组的情况下返回数组引用，否则返回 <codeph>null</codeph>：
<codeblock>
var obj:Object = [ "a", "b", "c" ];
      
var newArray:Array = obj as Array;

trace(newArray == obj); // true
trace(newArray[0]);     // a
trace(newArray[1]);     // b
trace(newArray[2]);     // c
</codeblock></example></apiOperationDetail><related-links><link href="#Array"><linktext>Array 类</linktext></link><link href="operators.html#as"><linktext>as 运算符</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:Boolean"><apiName>Boolean</apiName><shortdesc>
	 将 expression 参数转换为布尔值并返回该值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>转换为 Boolean 的结果。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要转换为 Boolean 的表达式或对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 <codeph>expression</codeph> 参数转换为布尔值并返回该值。 
	 <p>返回值取决于参数的数据类型和值，如下表所述：</p>
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>输入值</entry><entry>示例</entry><entry>返回值</entry></row></thead><tbody><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>Boolean(0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Boolean(NaN)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>数字（非 <codeph>0</codeph> 或 <codeph>NaN</codeph>）</entry>
	     <entry><codeph>Boolean(4)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>空字符串</entry>
	     <entry><codeph>Boolean("")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>非空字符串</entry>
	     <entry><codeph>Boolean("6")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>Boolean(null)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>Boolean(undefined)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>Object 类的实例</entry>
	     <entry><codeph>Boolean(new Object())</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>无参数</entry>
	     <entry><codeph>Boolean()</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 <p>与 ActionScript 的早期版本不同，<codeph>Boolean()</codeph> 函数与 Boolean 类构造函数返回相同的结果。</p>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Number"><apiName>Number</apiName><shortdesc>
	 将给定值转换成数字值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>转换后的数值
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要转换为数字的值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将给定值转换成数字值。下表显示各种输入类型的结果：
	 
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>输入类型/值</entry><entry>示例</entry><entry>返回值</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>Number(undefined)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>Number(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>Number(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>Number(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>Number(NaN)</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row><row>
	     <entry>空字符串</entry>
	     <entry><codeph>Number("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>转换为数字的字符串</entry>
	     <entry><codeph>Number("5")</codeph></entry>
	     <entry>数字（例如 <codeph>5</codeph>）</entry>
	   </row><row>
	     <entry>没有转换为数字的字符串</entry>
	     <entry><codeph>Number("5a")</codeph></entry>
	     <entry><codeph>NaN</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Object"><apiName>Object</apiName><shortdesc>
	 在 ActionScript 3.0 中，每个值都是一个对象，这意味着对某个值调用 Object() 会返回该值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>由 <codeph>value</codeph> 参数指定的值。
     </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要转换的对象、数字、字符串或布尔值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在 ActionScript 3.0 中，每个值都是一个对象，这意味着对某个值调用 <codeph>Object()</codeph> 会返回该值。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:String"><apiName>String</apiName><shortdesc>
	 返回指定参数的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>为 <codeph>expression</codeph> 参数传递的值的字符串表示形式。
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc> 要转换为字符串的表达式。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回指定参数的字符串表示形式。
	 <p>下表显示各种输入类型的结果：</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>输入类型/值</entry><entry>返回值</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>undefined</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>"null"</codeph></entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>"true"</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>"false"</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>"NaN"</codeph></entry>
	   </row><row>
	     <entry>String</entry>
	     <entry>String</entry>
	   </row><row>
	     <entry>object</entry>
	     <entry>Object.toString()</entry>
	   </row><row>
	     <entry>Number</entry>
	     <entry>数字的字符串表示形式</entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:Vector"><apiName>Vector</apiName><shortdesc>
	 创建新的 Vector 实例，其元素为指定数据类型的实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><commentPrivate>The reason this compiles with the .&lt;T> designation is because
	 a dummy class "T" is declared in the top level Vector.as file. If this file is
	 built without that one, the build will fail.
	 
	 </commentPrivate></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>sourceArray</codeph> 参数包含无法转换为指定数据类型的元素。
	 
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个用 <codeph>sourceArray</codeph> 数组的元素来填充的 Vector 实例。
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>sourceArray</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>一个 Array 或 Vector 实例，其元素会成为结果 Vector 的元素。如果参数是一个 Vector 实例并且其关联数据类型与指定的数据类型相同，则该参数作为函数结果返回。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 创建新的 Vector 实例，其元素为指定数据类型的实例。在调用此函数时，可使用类型参数指定结果 Vector 元素的数据类型（Vector 的<i>基本类型</i>）。此函数使用的语法与声明 Vector 实例或调用 <codeph>new Vector.&lt;T>()</codeph> 构造函数时所使用的语法相同：
	 
	 <codeblock>var v:Vector.&lt;String> = Vector.&lt;String>(["Hello", "World"]);</codeblock>
	 
	 <p>用 <codeph>sourceArray</codeph> 参数的元素中的值填充结果 Vector。如果 <codeph>sourceArray</codeph> 参数已经是 Vector.&lt;T> 实例（其中 <codeph>T</codeph> 为基本类型），则函数将返回该 Vector。否则，将用 <codeph>sourceArray</codeph> Array 或 Vector 的元素填充结果 Vector。</p>
	 
	 <p>在上述任一情况下，<codeph>sourceArray</codeph> 参数的所有元素的数据类型都必须与函数调用中指定的基本类型 <codeph>T</codeph> 匹配。</p>
	 
	 <p>如果 <codeph>sourceArray</codeph> 参数的 <codeph>length</codeph> 为 0，则此函数将返回一个空白 Vector。</p>
	 
	 <p>如果 Vector 作为 <codeph>sourceArray</codeph> 参数传递且其基本类型不是 <codeph>T</codeph>，或者如果传递一个 Array 且其元素并不全是数据类型 <codeph>T</codeph> 的实例，则会尝试将值转换为基本类型。如果这些值可以自动转换，则结果 Vector 中会包含转换后的值。如果无法进行任何转换，则会出现一个错误。</p>
	 
	 <p>同样，如果 <codeph>sourceArray</codeph> 参数中的某个元素是基本类型 <codeph>T</codeph> 的子类的实例，则调用成功，并且该元素将添加到结果 Vector 中。即使 <codeph>sourceArray</codeph> 参数是一个 Vector 并且其基本类型是 <codeph>T</codeph> 的子类，也会出现上述情况。实际上，只有通过这种方法才能将基本类型为 <codeph>T</codeph> 的 Vector 转换为基本类型为 <codeph>T</codeph> 的子类的 Vector。</p>
	 
	 <p>例如，由于以下代码尝试将 Vector.&lt;Sprite> 分配给 Vector，因此该代码在严格模式下会导致出现编译错误或在运行时导致出现 TypeError。&lt;DisplayObject> 变量（Sprite 是 DisplayObject 的子类）：</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = v1;
	 </codeblock>
	 
	 <p>以下替代版本的代码可成功地将 Vector.&lt;Sprite> 实例的元素复制到 Vector.&lt;DisplayObject> 实例中：</p>
	 
	 <codeblock>
	 var v1:Vector.&lt;Sprite> = new Vector.&lt;Sprite>();
	 v1[0] = new Sprite();
	 var v2:Vector.&lt;DisplayObject> = Vector.&lt;DisplayObject>(v1);
	 </codeblock>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#Vector"><linktext>Vector 类</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XMLList"><apiName>XMLList</apiName><shortdesc>
     将某对象转换成 XMLList 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 XMLList 对象，它包含转换后的对象中存放的值。
	 </apiDesc><apiOperationClassifier>XMLList</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要转换为 XMLList 对象的对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将某对象转换成 XMLList 对象。
     <p>下表介绍各种输入类型的返回值。</p>
	 <adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>参数类型</entry><entry>返回值</entry></row></thead><tbody><row>
	 		<entry>Boolean</entry>
	 		<entry>首先将值转换成一个字符串，然后转换成一个 XMLList 对象。</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>发生运行时错误（TypeError 异常）。</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>首先将值转换成一个字符串，然后转换成一个 XMLList 对象。</entry>
	 	</row><row>
	 		<entry>object</entry>
	 		<entry>仅当值为字符串值、数值或布尔值时才转换为 XMLList。否则会发生运行时错误（TypeError 异常）。</entry>
	 	</row><row>
	 		<entry>String</entry>
	 		<entry>将值转换成一个 XMLList 对象。</entry>
	 	</row><row>
	 		<entry>Undefined</entry>
	 		<entry>发生运行时错误（TypeError 异常）。</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>将值转换成一个 XMLList 对象。</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>返回未修改的输入值。</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XML()"><linktext>XML()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:XML"><apiName>XML</apiName><shortdesc>
	 将对象转换成 XML 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 XML 对象，它包含转换后的对象中存放的值。
	 </apiDesc><apiOperationClassifier>XML</apiOperationClassifier></apiReturn><apiParam><apiItemName>expression</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要转换为 XML 的对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将对象转换成 XML 对象。 
	 <p>下表介绍各种输入类型的返回值。</p>
	 	<adobetable class="innertable">
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 <tgroup cols="2"><thead><row><entry>参数类型</entry><entry>返回值</entry></row></thead><tbody><row>
	 		<entry>Boolean</entry>
	 		<entry>首先将值转换成一个字符串，然后转换成一个 XML 对象。</entry>
	 	</row><row>
	 		<entry>Null</entry>
	 		<entry>发生运行时错误（TypeError 异常）。</entry>
	 	</row><row>
	 		<entry>Number</entry>
	 		<entry>首先将值转换成一个字符串，然后转换成一个 XML 对象。</entry>
	 	</row><row>
	 		<entry>Object</entry>
	 		<entry>仅当值为字符串值、数值或布尔值时才转换为 XML。否则会发生运行时错误（TypeError 异常）。</entry>
	 	</row><row>
	 		<entry>String</entry>
	 		<entry>转换为 XML 的值。</entry>
	 	</row><row>
	 		<entry>Undefined</entry>
	 		<entry>发生运行时错误（TypeError 异常）。</entry>
	 	</row><row>
	 		<entry>XML</entry>
	 		<entry>返回未修改的输入值。</entry>
	 	</row><row>
	 		<entry>XMLList</entry>
	 		<entry>仅当 XMLList 对象只包含 XML 类型的某个属性时才返回 XML 对象。否则会发生运行时错误（TypeError 异常）。</entry>
	 	</row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/XMLList()"><linktext>XMLList()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURIComponent"><apiName>decodeURIComponent</apiName><shortdesc>
	 将已编码的 URI 组件解码为字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，其中以前由 <codeph>encodeURIComponent</codeph> 函数转义的所有字符都还原为它们的未转义表示形式。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个使用 <codeph>encodeURIComponent</codeph> 函数编码的字符串。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将已编码的 URI 组件解码为字符串。返回一个字符串，其中以前由 <codeph>encodeURIComponent</codeph> 函数转义的所有字符都还原为它们的未编码表示形式。
	 <p>此函数与 <codeph>decodeURI()</codeph> 函数不同，它仅适用于 URI 字符串的一部分（称为 URI 组件）。URI 组件是指出现在某些特殊字符之间的任何文本，这些特殊字符称为<i>组件分隔符</i> (<codeph>: / ; and ? </codeph>). “http”和“www.adobe.com”是常见的 URI 组件示例。</p>
	 <p>此函数与 <codeph>decodeURI()</codeph> 的另一个重要区别是：由于此函数假定它处理的是 URI 组件，因此它会将表示特殊分隔符字符 (<codeph>; / ? : @ &amp; = + $ , #</codeph>) 的转义序列视为应进行解码的常规文本。 </p>
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:decodeURI"><apiName>decodeURI</apiName><shortdesc>
	 将已编码的 URI 解码为字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，其中以前由 <codeph>encodeURI</codeph> 函数转义的所有字符都还原为它们的未转义表示形式。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个使用 <codeph>encodeURI</codeph> 函数编码的字符串。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将已编码的 URI 解码为字符串。返回一个字符串，其中以前由 <codeph>encodeURI</codeph> 函数编码的所有字符都还原为它们的未编码表示形式。
	 <p>下表显示<i>不会</i> 由 <codeph>decodeURI</codeph> 函数解码为字符的转义序列的集合。使用 <codeph>decodeURIComponent()</codeph> 可解码此表中的转义序列。</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="2"><thead><row><entry>未解码的转义序列</entry><entry>字符等效形式</entry></row></thead><tbody><row>
	     <entry><codeph>%23</codeph></entry>
	     <entry><codeph>#</codeph></entry>
	   </row><row>
	     <entry><codeph>%24</codeph></entry>
	     <entry><codeph>$</codeph></entry>
	   </row><row>
	     <entry><codeph>%26</codeph></entry>
	     <entry><codeph>&amp;</codeph></entry>
	   </row><row>
	     <entry><codeph>%2B</codeph></entry>
	     <entry><codeph>+</codeph></entry>
	   </row><row>
	     <entry><codeph>%2C</codeph></entry>
	     <entry><codeph>,</codeph></entry>
	   </row><row>
	     <entry><codeph>%2F</codeph></entry>
	     <entry><codeph>/</codeph></entry>
	   </row><row>
	     <entry><codeph>%3A</codeph></entry>
	     <entry><codeph>:</codeph></entry>
	   </row><row>
	     <entry><codeph>%3B</codeph></entry>
	     <entry><codeph>;</codeph></entry>
	   </row><row>
	     <entry><codeph>%3D</codeph></entry>
	     <entry><codeph>=</codeph></entry>
	   </row><row>
	     <entry><codeph>%3F</codeph></entry>
	     <entry><codeph>?</codeph></entry>
	   </row><row>
	     <entry><codeph>%40</codeph></entry>
	     <entry><codeph>@</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 
	 </apiDesc><example conref="examples\DecodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class DecodeURIExample extends Sprite {
        public function DecodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURIComponent"><apiName>encodeURIComponent</apiName><shortdesc>
	 将字符串编码为有效的 URI 组件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
	 将字符串编码为有效的 URI 组件。将 URI 的子字符串转换为一个字符串，其中除属于非常小的一组基本字符的字符外，其它所有字符都以 UTF-8 转义序列进行编码。
	 <p><codeph>encodeURIComponent()</codeph> 函数与 <codeph>encodeURI()</codeph> 函数不同，它仅适用于 URI 字符串的一部分（称为 URI 组件）。URI 组件是指出现在某些特殊字符之间的任何文本，这些特殊字符称为<i>组件分隔符</i> (<codeph>: / ; and ? </codeph>). “http”和“www.adobe.com”是常见的 URI 组件示例。</p>
	 <p>此函数与 <codeph>encodeURI()</codeph> 的另一个重要区别是：由于此函数假定它处理的是 URI 组件，因此它会将特殊分隔符字符 (<codeph>; / ? : @ &amp; = + $ , #</codeph>) 视为应进行编码的常规文本。 </p>
	 <p>下表显示<i>不会</i> 由 <codeph>encodeURIComponent</codeph> 函数转换为 UTF-8 转义序列的所有字符。</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>未编码的字符</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>- _ . ! ~ ~~ ' ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURI()"><linktext>encodeURI()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:encodeURI"><apiName>encodeURI</apiName><shortdesc>
	 将字符串编码为有效的 URI（统一资源标识符）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个字符串，其中某些字符已编码为 UTF-8 转义序列。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>uri</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个表示完整 URI 的字符串。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将字符串编码为有效的 URI（统一资源标识符）。将完整的 URI 转换为一个字符串，其中除属于一小组基本字符的字符外，其它所有字符都以 UTF-8 转义序列进行编码。
	 <p>下表显示<i>不会</i> 由 <codeph>encodeURI</codeph> 函数转换为 UTF-8 转义序列的基本字符的整个集合。</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>未编码的字符</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>; / ? : @ &amp; = + $ , #</codeph></entry>
	   </row><row>
	     <entry><codeph>- _ . ! ~ ~~ ' ( )</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc><example conref="examples\EncodeURIExample.as"><codeblock>package {
    import flash.display.Sprite;

    public class EncodeURIExample extends Sprite {
        public function EncodeURIExample() {
            var uri:String = "http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>";
            var encoded:String = encodeURI(uri);
            var decoded:String = decodeURI(encoded);
            trace(uri);        // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
            trace(encoded);    // http://www.example.com/application.jsp?user=%3Cuser%20name='some%20user'%3E%3C/user%3E
            trace(decoded);    // http://www.example.com/application.jsp?user=&lt;user name='some user'>&lt;/user>
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="#global/decodeURI()"><linktext>decodeURI()</linktext></link><link href="#global/decodeURIComponent()"><linktext>decodeURIComponent()</linktext></link><link href="#global/encodeURIComponent()"><linktext>encodeURIComponent()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:escape"><apiName>escape</apiName><shortdesc>
	 将参数转换为字符串，并以 URL 编码格式对其进行编码，在这种格式中，大多数非字母数字的字符都替换为 % 十六进制序列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 URL 编码的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要转换为字符串并以 URL 编码格式进行编码的表达式。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将参数转换为字符串，并以 URL 编码格式对其进行编码，在这种格式中，大多数非字母数字的字符都替换为 <codeph>%</codeph> 十六进制序列。当用于 URL 编码的字符串时，百分号 (<codeph>%</codeph>) 用于引入转义字符，不与模运算符 (<codeph>%</codeph>) 等效。
	 <p>下表显示<i>不会</i> 由 <codeph>escape()</codeph> 函数转换为转义序列的所有字符。</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	 <tgroup cols="1"><thead><row><entry>未编码的字符</entry></row></thead><tbody><row>
	     <entry><codeph>0 1 2 3 4 5 6 7 8 9</codeph></entry>
	   </row><row>
	     <entry><codeph>a b c d e f g h i j k l m n o p q r s t u v w x y z</codeph></entry>
	   </row><row>
	     <entry><codeph>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</codeph></entry>
	   </row><row>
	     <entry><codeph>@ - _ . ~~ + /</codeph></entry>
	   </row></tbody></tgroup></adobetable>	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="#global/unescape()"><linktext>unescape()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:int"><apiName>int</apiName><shortdesc>
	 将给定数字值转换成整数值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>转换后的整数值。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要转换成整数的值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将给定数字值转换成整数值。从小数点处截断十进制值。
	 </apiDesc></apiOperationDetail><related-links><link href="#global/uint()"><linktext>uint()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:isFinite"><apiName>isFinite</apiName><shortdesc>
	 如果该值为有限数，则返回 true，如果该值为正无穷大或负无穷大，则返回 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0."/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>若结果为一个有限数，则返回 <codeph>true</codeph>；若结果为无穷大或负无穷大，则返回 <codeph>false</codeph>
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要计算为有限数或无穷大的数字。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 如果该值为有限数，则返回 <codeph>true</codeph>，如果该值为 <codeph>Infinity</codeph> 或 <codeph>-Infinity</codeph>，则返回 <codeph>false</codeph>。出现的 <codeph>Infinity</codeph> 或 <codeph>-Infinity</codeph> 指示存在错误的数学条件，例如除以 0。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isNaN"><apiName>isNaN</apiName><shortdesc>
	 如果该值为 NaN（非数字），则返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果该值为 <codeph>NaN</codeph>（非数字），则返回 <codeph>true</codeph>；否则返回 <codeph>false</codeph>。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要计算的数值或数学表达式。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 如果该值为 <codeph>NaN</codeph>（非数字），则返回 <codeph>true</codeph>。<codeph>isNaN()</codeph> 函数可用于检查一个数学表达式是否成功地计算为一个数字。<codeph>isNaN()</codeph> 最常用于检查从 <codeph>parseInt()</codeph> 和 <codeph>parseFloat()</codeph> 函数返回的值。<codeph>NaN</codeph> 值是 Number 数据类型的特殊成员，用来表示“非数字”值。 
	 <p><b>注意</b>：<codeph>NaN</codeph> 值不是 int 或 uint 数据类型的成员。</p>
	 <p>下表描述 <codeph>isNaN()</codeph> 针对各种输入类型和值的返回值。（如果编译器警告设置为“严格模式”，则下面的某些操作将生成编译器警告。）</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>输入类型/值</entry><entry>示例</entry><entry>返回值</entry></row></thead><tbody><row>
	     <entry>0 除以 0</entry>
	     <entry><codeph>isNaN(0/0)</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>非零数字除以 <codeph>0</codeph></entry>
	     <entry><codeph>isNaN(5/0)</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>负数的平方根</entry>
	     <entry><codeph>isNaN(Math.sqrt(-1))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>大于 1 或小于 0 的数字的反正弦值</entry>
	     <entry><codeph>isNaN(Math.asin(2))</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row><row>
	     <entry>可以转换为 Number 的字符串</entry>
	     <entry><codeph>isNaN("5")</codeph></entry>
	     <entry><codeph>false</codeph></entry>
	   </row><row>
	     <entry>无法转换为 Number 的字符串</entry>
	     <entry><codeph>isNaN("5a")</codeph></entry>
	     <entry><codeph>true</codeph></entry>
	   </row></tbody></tgroup></adobetable>
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:isXMLName"><apiName>isXMLName</apiName><shortdesc>
	 确定指定字符串对于 XML 元素或属性是否为有效名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 <codeph>str</codeph> 参数为有效的 XML 名称，则返回 <codeph>true</codeph>；否则返回 <codeph>false</codeph>。
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要计算的字符串。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 确定指定字符串对于 XML 元素或属性是否为有效名称。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseFloat"><apiName>parseFloat</apiName><shortdesc>
	 将字符串转换为浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个数字或 <codeph>NaN</codeph>（非数字）。
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要读取并转换为浮点数的字符串。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将字符串转换为浮点数。此函数读取或<i>分析</i> 并返回字符串中的数字，直到此函数遇到不是初始数字一部分的字符。如果字符串不是以可以分析的数字开头，<codeph>parseFloat()</codeph> 将返回 <codeph>NaN</codeph>。有效整数前面的空白将被忽略，有效整数后面的非数字字符也将被忽略。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:parseInt"><apiName>parseInt</apiName><shortdesc>
	 将字符串转换为整数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个数字或 <codeph>NaN</codeph>（非数字）。
     </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要转换为整数的字符串。
	 </apiDesc></apiParam><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>表示要分析的数字的基数（基）的整数。合法值为 2 到 36。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将字符串转换为整数。如果参数中指定的字符串不能转换为数字，则此函数返回 <codeph>NaN</codeph>。以 0x 开头的字符串被解释为十六进制数字。与 ActionScript 的早期版本不同，以 0 开头的整数<i>不会</i>被解释为八进制数字。必须指定 8 的基数才能解释为八进制数字。有效整数前面的空白和 0 以及后面的非数字字符将被忽略。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="globalOperation:trace"><apiName>trace</apiName><shortdesc>
	 调试时显示表达式或写入日志文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>arguments</apiItemName><apiType value="restParam"/><apiDesc>要计算的一个或多个（逗号分隔）表达式。对于多个表达式，输出中每个表达式之间都将插入一个空格。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 调试时显示表达式或写入日志文件。单个跟踪语句可支持多个参数。如果跟踪语句中的任何参数包含 String 之外的数据类型，则跟踪函数将调用与该数据类型关联的 <codeph>toString()</codeph> 方法。例如，如果该参数是一个布尔值，则跟踪函数将调用 <codeph>Boolean.toString()</codeph> 并显示返回值。 
	 </apiDesc><example conref="examples\TraceExample.as"> 下面的示例使用类 <codeph>TraceExample</codeph> 来演示如何使用 <codeph>trace()</codeph> 方法输出简单字符串。通常情况下，消息将输出到“调试”控制台。
<codeblock>
package {
    import flash.display.Sprite;

    public class TraceExample extends Sprite {

        public function TraceExample() {
            trace("Hello World");
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="globalOperation:uint"><apiName>uint</apiName><shortdesc>
	 将给定数字值转换成无符号整数值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>转换后的整数值。
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要转换成整数的值。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将给定数字值转换成无符号整数值。从小数点处截断十进制值。
	 <p>下表描述 <codeph>uint()</codeph> 针对各种输入类型和值的返回值。</p>
	 <adobetable class="innertable">
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	 <tgroup cols="3"><thead><row><entry>输入类型/值</entry><entry>示例</entry><entry>返回值</entry></row></thead><tbody><row>
	     <entry><codeph>undefined</codeph></entry>
	     <entry><codeph>uint(undefined)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>null</codeph></entry>
	     <entry><codeph>uint(null)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>0</codeph></entry>
	     <entry><codeph>uint(0)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry><codeph>NaN</codeph></entry>
	     <entry><codeph>uint(NaN)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>正浮点数</entry>
	     <entry><codeph>uint(5.31)</codeph></entry>
	     <entry>截断的无符号整数（例如，<codeph>5</codeph>）</entry>
	   </row><row>
	     <entry>负浮点数</entry>
	     <entry><codeph>uint(-5.78)</codeph></entry>
	     <entry>截断为整数，然后应用负整数规则</entry>
	   </row><row>
	     <entry>负整数</entry>
	     <entry><codeph>uint(-5)</codeph></entry>
         <entry><codeph>uint.MAX_VALUE</codeph> 与负整数的和（例如，<codeph>uint.MAX_VALUE + (-5)</codeph>）</entry>
	   </row><row>
	     <entry><codeph>true</codeph></entry>
	     <entry><codeph>uint(true)</codeph></entry>
	     <entry><codeph>1</codeph></entry>
	   </row><row>
	     <entry><codeph>false</codeph></entry>
	     <entry><codeph>uint(false)</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>空字符串</entry>
	     <entry><codeph>uint("")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row><row>
	     <entry>转换为数字的字符串</entry>
	     <entry><codeph>uint("5")</codeph></entry>
	     <entry>数字</entry>
	   </row><row>
	     <entry>没有转换为数字的字符串</entry>
	     <entry><codeph>uint("5a")</codeph></entry>
	     <entry><codeph>0</codeph></entry>
	   </row></tbody></tgroup></adobetable>

	 </apiDesc></apiOperationDetail><related-links><link href="#global/int()"><linktext>int()</linktext></link></related-links></apiOperation><apiOperation id="globalOperation:unescape"><apiName>unescape</apiName><shortdesc>
	 将参数 str 作为字符串计算，从 URL 编码格式解码该字符串（将所有十六进制序列转换成 ASCII 字符），并返回该字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>对 URL 编码的参数进行解码所得到的字符串。
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>str</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要转义的十六进制序列字符串。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将参数 <codeph>str</codeph> 作为字符串计算，从 URL 编码格式解码该字符串（将所有十六进制序列转换成 ASCII 字符），并返回该字符串。
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="globalValue:Infinity"><apiName>Infinity</apiName><shortdesc>
 表示正无穷大的特殊值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 表示正 <codeph>Infinity</codeph> 的特殊值。此常量的值与 <codeph>Number.POSITIVE_INFINITY</codeph> 相同。
 </apiDesc><example conref="examples\Constants.Infinity.1.as"> 除以 0 的结果为 <codeph>Infinity</codeph>（仅当除数为正数时）。
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/POSITIVE_INFINITY"><linktext>Number.POSITIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:-Infinity"><apiName>-Infinity</apiName><shortdesc>
 表示负无穷大的特殊值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 表示负 <codeph>Infinity</codeph> 的特殊值。此常量的值与 <codeph>Number.NEGATIVE_INFINITY</codeph> 相同。
 </apiDesc><example conref="examples\Constants.NegInfinity.1.as"> 除以 0 的结果为 <codeph>-Infinity</codeph>（仅当除数为负数时）。
<codeblock>

trace(0 / 0);  // NaN
trace(7 / 0);  // Infinity
trace(-7 / 0); // -Infinity


</codeblock></example></apiValueDetail><related-links><link href="#Number/NEGATIVE_INFINITY"><linktext>Number.NEGATIVE_INFINITY</linktext></link></related-links></apiValue><apiValue id="globalValue:NaN"><apiName>NaN</apiName><shortdesc>
 Number 数据类型的一个特殊成员，用来表示“非数字”(NaN) 值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 Number 数据类型的一个特殊成员，用来表示“非数字”(<codeph>NaN</codeph>) 值。当数学表达式生成的值无法表示为数字时，结果为 <codeph>NaN</codeph>。下表描述了生成 <codeph>NaN</codeph> 的常用表达式。
 <ul>
   <li>除以 0 可生成 <codeph>NaN</codeph>（仅当除数也为 0 时）。如果除数大于 0，除以 0 的结果为 <codeph><codeph>Infinity</codeph></codeph>。如果除数小于 0，除以 0 的结果为 <codeph><codeph>-Infinity</codeph></codeph>；</li>
   <li>负数的平方根；</li>
   <li>在有效范围 0 到 1 之外的数字的反正弦值；</li>
   <li><codeph>Infinity</codeph> 减去 <codeph>Infinity</codeph>；</li>
   <li><codeph>Infinity</codeph> 或 <codeph>-Infinity</codeph> 除以 <codeph>Infinity</codeph> 或 <codeph>-Infinity</codeph>；</li>
   <li><codeph>Infinity</codeph> 或 <codeph>-Infinity</codeph> 乘以 0；</li>
  </ul>
 <p><codeph>NaN</codeph> 值不是 int 或 uint 数据类型的成员。</p>
 <p><codeph>NaN</codeph> 值不被视为等于任何其它值（包括 <codeph>NaN</codeph>），因而无法使用等于运算符测试一个表达式是否为 <codeph>NaN</codeph>。要确定一个数字是否为 <codeph>NaN</codeph> 函数，请使用 <codeph>isNaN()</codeph>。</p>
 
 </apiDesc></apiValueDetail><related-links><link href="#global/isNaN()"><linktext>isNaN()</linktext></link><link href="#Number/NaN"><linktext>Number.NaN</linktext></link></related-links></apiValue><apiValue id="globalValue:undefined"><apiName>undefined</apiName><shortdesc>
 一个适用于尚未初始化的无类型变量或未初始化的动态对象属性的特殊值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiDynamic/><apiType value=""/></apiValueDef><apiDesc>
 一个适用于尚未初始化的无类型变量或未初始化的动态对象属性的特殊值。在 ActionScript 3.0 中，只有无类型变量才能采用值 <codeph>undefined</codeph>，这在 ActionScript 1.0 和 ActionScript 2.0 中并非如此。例如，以下两个变量都是 <codeph>undefined</codeph>，因为它们都未类型化或初始化：
 <ul>
   <li><codeph>var foo;</codeph></li>
   <li><codeph>var bar:~~;</codeph></li>
 </ul>
 <p><codeph>undefined</codeph> 值还适用于动态对象的未初始化或未定义的属性。例如，如果某对象是 Object 类的一个实例，则除非向该属性赋予值，否则动态添加的任何属性的值将为 <codeph>undefined</codeph>。
 </p>
 <p>将 <codeph>undefined</codeph> 用于不同的函数时，结果也不相同：</p>
 <ul>
 <li>由 <codeph>String(undefined)</codeph> 返回的值为 <codeph>"undefined"</codeph>（<codeph>undefined</codeph> 转换为字符串）。</li> 
 <li>由 <codeph>Number(undefined)</codeph> 返回的值为 <codeph>NaN</codeph>。</li> 
 <li>由 <codeph>int(undefined)</codeph> 和 <codeph>uint(undefined)</codeph> 返回的值为 0。</li>
 <li>由 <codeph>Object(undefined)</codeph> 返回的值为新的 Object 实例。</li>
 <li>向类型变量赋予值 <codeph>undefined</codeph> 时，该值将转换为该数据类型的默认值。</li>
 </ul>
 <p>不要混淆 <codeph>undefined</codeph> 和 <codeph>null</codeph>。使用等于运算符 (<codeph>==</codeph>) 对 <codeph>null</codeph> 和 <codeph>undefined</codeph> 进行比较时，它们的比较结果为相等。但是，使用全等运算符 (<codeph>===</codeph>) 对 <codeph>null</codeph> 和 <codeph>undefined</codeph> 进行比较时，它们的比较结果为不相等。</p>
 </apiDesc><example conref="examples\Constants.undefined.1.as"> 在以下示例中，将声明（但不初始化）一个无类型变量 <codeph>myVar</codeph>。<codeph>myVar</codeph> 的值为 <codeph>undefined</codeph>，因为该变量是一个无类型变量。无论变量是没有类型注释，还是使用特殊的 (~~) 无类型注释 (<codeph>var myVar:~~;</codeph>)，都是如此。
<codeblock>

// trace value of untyped and uninitialized variable
var myVar;
trace(myVar); // undefined
</codeblock></example><example conref="examples\Constants.undefined.2.as"> 该规则同样适用于动态对象的未初始化属性。例如，给定实例 <codeph>obj</codeph>（属于动态类 <codeph>A</codeph>），<codeph>obj.propName</codeph>（<codeph>obj</codeph> 实例的未初始化属性）的值为 <codeph>undefined</codeph>。
<codeblock>

dynamic class A {}
var obj:A = new A()

// trace undefined property of obj
trace(obj.propName); // undefined

</codeblock></example></apiValueDetail><related-links><link href="statements.html#null"><linktext>null</linktext></link></related-links></apiValue><apiClassifier id="globalClassifier:uint"><apiName>uint</apiName><shortdesc>
 uint 类提供使用表示 32 位无符号整数的数据类型的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint object, uint, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 uint 类提供使用表示 32 位无符号整数的数据类型的方法。因为无符号整数只能为正，所以其最大值是 int 类最大值的两倍。
 <p>由 uint 类表示的值的范围介于 0 到 4,294,967,295 (2^32-1) 之间。</p>
 <p>可以通过声明 uint 类型的变量并为变量赋予文本值来创建 uint 对象。uint 类型变量的默认值为 <codeph>0</codeph>。</p>
 <p>uint 类主要用于像素颜色值（ARGB 和 RGBA）和 int 数据类型无法正常运行的其它情况。例如，数字 0xFFFFFFFF 表示 Alpha 值为 255 的白色颜色值，它无法用 int 数据类型表示，因为它不在有效的 int 值范围内。</p> 
 
 <p>下例将创建一个 uint 对象并调用 <codeph> toString()</codeph> 方法：</p>
 <pre>
 var myuint:uint = 1234;
 trace(myuint.toString()); // 1234
 </pre>
 <p>下面的示例在不使用构造函数的情况下，将 <codeph>MIN_VALUE</codeph> 属性的值赋予一个变量：</p>
 <pre>
 var smallest:uint = uint.MIN_VALUE;
 trace(smallest.toString()); // 0
 </pre> 
 
 </apiDesc><example conref="examples\UintExample.as"> 下面的示例声明 uint <codeph>i</codeph>（在 <codeph>for</codeph> 循环内），这将输出介于 0 和 9 之间的数字（因为 uint 默认为 0）。
<codeblock>

package {
    import flash.display.Sprite;

    public class UintExample extends Sprite {
        public function UintExample() {
            for(var i:uint; i &lt; 10; i++) {
                trace(i);
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="int.html"><linktext>int</linktext></link><link href="Number.html"><linktext>Number</linktext></link></related-links><apiConstructor id="uint:uint"><apiName>uint</apiName><shortdesc>
	 创建新的 uint 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>new number, constructor
	  
	  </keyword></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>num</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要创建的 uint 对象的数值，或者要转换为数字的值。如果未提供 <codeph>num</codeph>，则默认值为 <codeph>0</codeph>。
	 
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 创建新的 uint 对象。可以创建一个 uint 类型的变量并赋予其文本值。<codeph>new uint()</codeph> 构造函数主要用作占位符。uint 对象与 <codeph> uint()</codeph> 函数不同，后者会将参数转换为原始值。
	 
	 </apiDesc><example>以下代码构造两个新的 uint 对象：其中，第一个通过赋予文本值构造，而第二个则通过使用构造函数构造：
	 <pre>
	 var n1:uint = 3;
	 var n2:uint = new uint(10);
	 </pre>
	 
	 </example></apiConstructorDetail></apiConstructor><apiOperation id="uint:AS3:toExponential"><apiName>toExponential</apiName><shortdesc>
      返回数字的字符串表示形式（采用指数表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fractionDigits</codeph> 参数不在 0 到 20 的范围内，则会引发异常。
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 0 和 20（含）之间的整数，表示所需的小数位数。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回数字的字符串表示形式（采用指数表示法）。字符串在小数点前面包含一位，在小数点后面最多包含 20 位（在 <codeph>fractionDigits</codeph> 参数中指定）。
      </apiDesc><example conref="examples\Number.toExponential.1.as"> 下面的示例演示 <codeph>toExponential(2)</codeph> 如何返回采用指数表示法的字符串。
<codeblock>

var num:Number = 315003;
trace(num.toExponential(2)); // 3.15e+5

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toFixed"><apiName>toFixed</apiName><shortdesc>
     返回数字的字符串表示形式（采用定点表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fractionDigits</codeph> 参数不在 0 到 20 的范围内，则会引发异常。
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>fractionDigits</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 0 和 20（含）之间的整数，表示所需的小数位数。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回数字的字符串表示形式（采用定点表示法）。定点表示法是指字符串的小数点后面包含特定的位数（在 <codeph>fractionDigits</codeph> 参数中指定）。<codeph>fractionDigits</codeph> 参数的有效范围为 0 到 20。如果指定的值在此范围外，则会引发异常。
     
     </apiDesc><example conref="examples\Number.toFixed.1.as"> 下面的示例演示 <codeph>toFixed(3)</codeph> 如何返回舍入到小数点后三位的字符串。
<codeblock>

var num:Number = 7.31343;
trace(num.toFixed(3)); // 7.313
</codeblock></example><example conref="examples\Number.toFixed.2.as"> 下面的示例演示 <codeph>toFixed(2)</codeph> 如何返回添加尾随 0 的字符串。
<codeblock>

var num:Number = 4;
trace(num.toFixed(2)); // 4.00
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toPrecision"><apiName>toPrecision</apiName><shortdesc>
      返回数字的字符串表示形式（采用指数表示法或定点表示法）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>precision</codeph> 参数不在 1 到 21 的范围内，则会引发异常。
	  </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>precision</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>介于 1 和 21（含）之间的整数，表示结果字符串中所需的位数。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回数字的字符串表示形式（采用指数表示法或定点表示法）。字符串将包含 <codeph>precision</codeph> 参数中指定的位数。
      </apiDesc><example conref="examples\Number.toPrecision.1.as"> 下面的示例演示 <codeph>toPrecision(3)</codeph> 如何返回只包含三位数的字符串。由于不需要指数表示法，因此字符串使用定点表示法。
<codeblock>

var num:Number = 31.570;
trace(num.toPrecision(3)); // 31.6
</codeblock></example><example conref="examples\Number.toPrecision.2.as"> 下面的示例演示 <codeph>toPrecision(3)</codeph> 如何返回只包含三位数的字符串。由于结果数字中没有足够的位数来使用定点表示法，因此字符串使用指数表示法。
<codeblock>

var num:Number = 4000;
trace(num.toPrecision(3)); // 4.00e+3
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:toString"><apiName>toString</apiName><shortdesc>
	 返回 uint 对象的字符串表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.tostring, tostring
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>uint 对象的字符串表达式。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>radix</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>指定要用于数字到字符串的转换的基数（从 2 到 36）。如果未指定 <codeph>radix</codeph> 参数，则默认值为 <codeph>10</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回 uint 对象的字符串表示形式。
	 
     </apiDesc><example>下面的示例将 2 和 8 用于 <codeph>radix</codeph> 参数，并返回包含数字 9 的相应表示形式的字符串值：
	 <pre>
	 var myuint:uint = 9;
	 trace(myuint.toString(2)); // 1001
	 trace(myuint.toString(8)); // 11
	 </pre>
	 下面的示例创建十六进制值：
	 <pre>
	 var r:uint = 250;
	 var g:uint = 128;
	 var b:uint = 114;
	 var rgb:String = "0x" + r.toString(16) + g.toString(16) + b.toString(16);
	 trace(rgb); // 0xfa8072 
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiOperation id="uint:AS3:valueOf"><apiName>valueOf</apiName><shortdesc>
	 返回指定 uint 对象的原始 uint 类型值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>number, number.valueof, valueof, value of
	  
	  </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>此 uint 对象的原始 uint 类型值。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回指定 uint 对象的原始 uint 类型值。
	 
	 </apiDesc><example>下例输出 <codeph> numSocks</codeph> 对象的原始值。
	 <pre>
	 var numSocks:uint = 2;
	 trace(numSocks.valueOf()); // 2
	 </pre>
	 
	 </example></apiOperationDetail></apiOperation><apiValue id="uint:MAX_VALUE"><apiName>MAX_VALUE</apiName><shortdesc> 
	可表示的最大 32 位无符号整数为 4,294,967,295。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.max_value, max_value, max value
	 
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4294967295</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
	可表示的最大 32 位无符号整数为 4,294,967,295。
	
   	</apiDesc><example>下面的 ActionScript 显示了可表示的最大和最小 <codeph>uint</codeph> 值：
	<pre>
	trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	</pre>
	<p>这些值为：</p>
	<pre>
	uint.MIN_VALUE = 0
	uint.MAX_VALUE = 4294967295
	</pre>
	
	</example></apiValueDetail></apiValue><apiValue id="uint:MIN_VALUE"><apiName>MIN_VALUE</apiName><shortdesc>
	 可表示的最小无符号整数为 0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><keyword>uint, uint.min_value, min_value, min value
      
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 可表示的最小无符号整数为 <codeph>0</codeph>。
	 
	 </apiDesc><example>下面的 ActionScript 显示了可表示的最大和最小 <codeph>uint</codeph> 值：
	 <pre>
	 trace("uint.MIN_VALUE = " + uint.MIN_VALUE);
	 trace("uint.MAX_VALUE = " + uint.MAX_VALUE);
	 </pre>
	 <p>这些值为：</p>
	 <pre>
	 uint.MIN_VALUE = 0
	 uint.MAX_VALUE = 4294967295
	 </pre>
     
     </example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="globalClassifier:Vector"><apiName>Vector</apiName><shortdesc>
 使用 Vector 类可以访问和操作矢量（即所有元素均具有相同数据类型的数组）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector, Vector object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>可让您定义 Vector（指定类型的数组）。
 </apiTipText></apiTipTexts><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 Vector 类可以访问和操作矢量（即所有元素均具有相同数据类型的数组）。Vector 的元素数据类型称作 Vector 的<i>基本类型</i>。基本类型可以是任何类，包括内置类和自定义类。在声明 Vector 变量以及通过调用类构造函数创建实例时，将指定基本类型。
 
 <p>与 Array 类似，可以使用数组访问 (<codeph>[]</codeph>) 运算符设置或检索 Vector 元素的值。一些 Vector 方法还提供了用于设置和检索元素值的机制。其中包括 <codeph>push()</codeph>、<codeph>pop()</codeph>、<codeph>shift()</codeph>、<codeph>unshift()</codeph>，等等。Vector 对象的属性和方法与 Array 的属性和方法类似（大多数情况下完全相同）。对于任何需要使用所有元素都具有相同数据类型的 Array 的情况，Vector 实例更为可取。</p>
 
 <p>可使用后缀类型参数语法指定 Vector 的基本类型。类型参数语法是一个序列，其中依次包含点 (<codeph>.</codeph>)、左尖括号 (<codeph>&lt;</codeph>)、类名称和右尖括号 (<codeph>></codeph>)，如下例所示：</p>
 
 <codeblock>
 var v:Vector.&lt;String>;
 v = new Vector.&lt;String>();
 </codeblock>
 
 <p>在此示例的第一行内容中，变量 <codeph>v</codeph> 声明为 Vector.&lt;String> 实例。换句话说，它表示一个只能容纳 String 实例的 Vector（数组），并且从中只能检索 String 实例。第二行代码构造了同一 Vector 类型的实例（即，一个所有元素均为 String 对象的 Vector），并将该实例分配给 <codeph>v</codeph>。</p>
 
 <p>使用 Vector.&lt;T> 数据类型声明的变量只能存储用相同的基本类型 <codeph>T</codeph> 构造的 Vector 实例。例如，不能将通过调用 <codeph>new Vector.&lt;String>()</codeph> 构造的 Vector 分配给使用 Vector.&lt;int> 数据类型声明的变量。基本类型必须完全匹配。例如，不会对下列代码进行编译，原因是对象的基本类型与变量声明的基本类型不同（即使 Sprite 是 DisplayObject 的子类）：</p>
 
 <codeblock>
 // This code doesn't compile even though Sprite is a DisplayObject subclass
 var v:Vector.&lt;DisplayObject> = new Vector.&lt;Sprite>();
 </codeblock>
 
 <p>要将基本类型为 <codeph>T</codeph> 的 Vector 转换为超类 <codeph>T</codeph> 的 Vector，请使用 <codeph>Vector()</codeph> 全局函数。</p>
 
 <p>除数据类型限制之外，Vector 类还具有其它一些限制，从而有别于 Array 类：</p>
 
 <ul>
   <li>Vector 是一种密集数组。与 Array 不同，Vector 必须在每个索引中包含一个值（或 <codeph>null</codeph>），而前者可以只在索引 0 和 7 中包含值（即使位置 1 到 6 中不存在任何值）。</li>
   <li>Vector 可以具有固定长度，这意味着其所包含的元素数量不可更改。</li>
   <li>对 Vector 的元素的访问需要接受范围检查。绝对不能从大于最后一个元素 (<codeph>length - 1</codeph>) 的索引中读取值。绝对不能对超过当前最后一个索引一个以上的索引设置值（也就是说，只能在现有索引或索引 <codeph>[length]</codeph> 中设置值）。</li>
 </ul>
 
 <p>由于 Vector 具有这些限制，因此 Vector 相对于所有元素均为单个类的实例的 Array 实例有两个主要优点：</p>
 <ul>
   <li>性能：使用 Vector 实例时的数组元素访问和迭代的速度比使用 Array 时的速度要快很多。</li>
   <li>类型安全性：在严格模式下，编译器可以识别数据类型错误，例如，将数据类型错误的值分配给 Vector 或从 Vector 中读取值时使用错误的数据类型。但请注意，当使用 <codeph>push()</codeph> 方法或 <codeph>unshift()</codeph> 方法向 Vector 添加值时，在编译时不会检查参数的数据类型，而会在运行时检查。</li>
 </ul> 
 
 </apiDesc></apiClassifierDetail><related-links><link href="operators.html#array_access"><linktext>[] 数组访问</linktext></link><link href="#global/Vector()"><linktext>Vector() 函数</linktext></link><link href="#Array"><linktext>Array 类</linktext></link></related-links><apiConstructor id="Vector:Vector"><apiName>Vector</apiName><shortdesc>
	 使用指定的基本类型创建 Vector。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>Vector 的初始长度（元素数目）。如果此参数大于零，则将创建指定数目的 Vector 元素，并使用适合基本类型的默认值（对于引用类型将使用 <codeph>null</codeph>）进行填充。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fixed</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>Vector 的长度是固定的 (<codeph>true</codeph>) 还是可变的 (<codeph>false</codeph>)。可以使用 <codeph>fixed</codeph> 属性设置此值。
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
	 使用指定的基本类型创建 Vector。
	 
	 <p>当调用 <codeph>Vector.&lt;T>()</codeph> 构造函数时，将使用类型参数语法指定基本类型。类型参数语法是一个序列，其中依次包含点 (<codeph>.</codeph>)、左尖括号 (<codeph>&lt;</codeph>)、类名称和右尖括号 (<codeph>></codeph>)，如下例所示：</p>
	 
	 <pre product="flash">
	 var v:Vector.&lt;String> = new Vector.&lt;String>();
	 </pre>
	 
	 <p>与 Array 类不同，不能使用 <codeph>Vector.&lt;T>()</codeph> 构造函数来创建预填充的 Vector 实例。要从一个 Array 或另一个 Vector（例如具有不同的基本类型的 Vector）创建 Vector 实例，请使用 <codeph>Vector()</codeph> 全局函数。</p>
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="#global/Vector()"><linktext>Vector() 函数</linktext></link></related-links></apiConstructor><apiOperation id="Vector:AS3:concat"><apiName>concat</apiName><shortdesc>
     将参数中指定的元素与 Vector 中的元素进行连接并创建新的 Vector。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.concat, concat, concatenate
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果任何参数都不是基本类型的实例且不能转换为基本类型。
     
     </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个与此 Vector 具有相同的基本类型的 Vector，并且其中包含此 Vector 中的元素，后跟参数中的元素。
	 
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>将要在新的 Vector 中进行连接的此 Vector 的基本类型的一个或多个值。如果未传递任何值，则新 Vector 将是原始 Vector 的副本。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>连接参数中指定的元素。
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     将参数中指定的元素与 Vector 中的元素进行连接并创建新的 Vector。如果这些参数指定一个 Vector，则将连接该 Vector 中的元素。 
	 
	 <codeblock>hello world</codeblock>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:every"><apiName>every</apiName><shortdesc>
	对 Vector 中的每一项执行测试函数，直到获得对指定的函数返回 false 的项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>在对 Vector 中的所有项调用指定函数时若返回 <codeph>true</codeph>，则为布尔值 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对 Vector 中的每一项运行的函数。调用此函数时需要使用以下三个参数：Vector 中的当前项、当前项的索引和 Vector 对象：
	<pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre> 
	
	<p>callback 函数应返回一个布尔值。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>调用 callback 函数时该函数中的标识符 <codeph>this</codeph> 引用的对象。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	对 Vector 中的每一项执行测试函数，直到获得对指定的函数返回 <codeph>false</codeph> 的项。使用此方法可确定 Vector 中的所有项是否满足某一条件，如具有小于某一特定数字的值。
	
	<p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。这是使用此方法的最常见方式。</p>
	
	<p product="flash">但是，假设您使用 Flash Professional 在主时间轴上的某个帧上创建函数，但希望在其他 <codeph>this</codeph> 上下文中调用此函数：</p>
	
	<pre product="flash">
	function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	   // your code here
	}
	</pre>
	
	<p product="flash">假设对名为 <codeph>myVector</codeph> 的 Vector 使用 <codeph>every()</codeph> 方法：</p>
	
	<pre product="flash">
	myVector.every(myFunction, someObject);
	</pre>
	
	<p product="flash">由于 <codeph>myFunction</codeph> 是 SWF 的主类的成员，因此不能在不同的 <codeph>this</codeph> 上下文中执行它。在运行此代码时，Flash Player 或 AIR 会引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
	
	<pre product="flash">
	var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
	    //your code here
	};
	myVector.every(myFunction, someObject);
	</pre>
	
	</apiDesc></apiOperationDetail><related-links><link href="#Vector/some()"><linktext>Vector.some()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:filter"><apiName>filter</apiName><shortdesc>
     对 Vector 中的每一项执行测试函数，并返回一个新 Vector，其中包含的所有项都对指定的函数返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个新的 Vector，其中包含原始 Vector 中 <codeph>callback</codeph> 函数为其返回 <codeph>true</codeph> 的所有项目。
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对 Vector 中的每一项运行的函数。调用此函数时需要使用以下三个参数：Vector 中的当前项、当前项的索引和 Vector 对象：
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>调用 callback 函数时该函数中的标识符 <codeph>this</codeph> 引用的对象。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Vector 中的每一项执行测试函数，并返回一个新 Vector，其中包含的所有项都对指定的函数返回 <codeph>true</codeph>。如果某项返回 <codeph>false</codeph>，则结果 Vector 中将不包含此项。返回的 Vector 的基本类型与对其调用此方法的 Vector 的基本类型匹配。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。这是使用此方法的最常见方式。</p>
	 
	 <p product="flash">但是，假设您使用 Flash Professional 在主时间轴上的某个帧上创建函数，但希望在其他 <codeph>this</codeph> 上下文中调用此函数：</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">假设对名为 <codeph>myVector</codeph> 的 Vector 使用 <codeph>filter()</codeph> 方法：</p>
	 
     <pre product="flash">
     var result:Vector.&lt;T> = myVector.filter(myFunction, someObject);
     </pre>
	 
     <p product="flash">由于 <codeph>myFunction</codeph> 是 SWF 的主类的成员，因此不能在不同的 <codeph>this</codeph> 上下文中执行它。在运行此代码时，Flash Player 会引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.filter(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/map()"><linktext>Vector.map()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:forEach"><apiName>forEach</apiName><shortdesc>
     对 Vector 中的每一项执行某个函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对 Vector 中的每一项运行的函数。调用此函数时需要使用以下三个参数：Vector 中的当前项、当前项的索引和 Vector 对象：
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):void;</pre>
	 <p>通过此函数调用获得的任何返回值都将被丢弃。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>调用 callback 函数时该函数中的标识符 <codeph>this</codeph> 引用的对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Vector 中的每一项执行某个函数。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。这是使用此方法的最常见方式。</p>
	 
	 <p product="flash">但是，假设您使用 Flash Professional 在主时间轴上的某个帧上创建函数，但希望在其他 <codeph>this</codeph> 上下文中调用此函数：</p>
	 
     <pre product="flash">
     function myFunction(item:T, index:int, vector:Vector.&lt;T>):void {
        // your code here
     }
     </pre>
	 
     <p product="flash">假设对名为 <codeph>myVector</codeph> 的 Vector 使用 <codeph>forEach()</codeph> 方法：</p>
	 
     <pre product="flash">
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     <p product="flash">由于 <codeph>myFunction</codeph> 是 SWF 的主类的成员，因此不能在不同的 <codeph>this</codeph> 上下文中执行它。在运行此代码时，Flash Player 会引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.forEach(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:indexOf"><apiName>indexOf</apiName><shortdesc>
     搜索 Vector 中的某个项，并返回该项的索引位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Vector 中的项的从零开始的索引位置。如果未找到 <codeph>searchElement</codeph> 参数，则返回值为 -1。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>要在 Vector 中查找的项。
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>要在 Vector 中开始搜索指定项的位置。如果此参数为负数，则将其视为 <codeph>length + fromIndex</codeph>，这意味着搜索将从末尾倒数第 <codeph>-fromIndex</codeph> 项开始，并从该位置向前搜索直到 Vector 的末尾。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     搜索 Vector 中的某个项，并返回该项的索引位置。使用全等运算符 (<codeph>===</codeph>) 将此项与 Vector 元素进行比较。
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/lastIndexOf()"><linktext>Vector.lastIndexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>===（全等）</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:join"><apiName>join</apiName><shortdesc>
     将 Vector 中的元素转换为字符串，在元素间插入指定的分隔符，连接这些元素，然后返回结果字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.join, join
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个字符串，它由转换为字符串并以指定字符串分隔的 Vector 元素组成。
     
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>sep</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>,</apiData><apiDesc>在返回字符串中分隔 Vector 元素的字符或字符串。如果省略此参数，则使用逗号作为默认分隔符。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>将 Vector 中的元素转换为字符串。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     将 Vector 中的元素转换为字符串，在元素间插入指定的分隔符，连接这些元素，然后返回结果字符串。嵌套 Vector 总是以逗号 (,) 分隔，而不使用传递给 <codeph>join()</codeph> 方法的分隔符分隔。
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:lastIndexOf"><apiName>lastIndexOf</apiName><shortdesc>
     在 Vector 中搜索一个项（从指定的索引位置向后搜索），并返回匹配项的索引位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>Vector 中的项的从零开始的索引位置。如果未找到 <codeph>searchElement</codeph> 参数，则返回值为 -1。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>searchElement</apiItemName><apiType value="T"/><apiDesc>要在 Vector 中查找的项。
     
     </apiDesc></apiParam><apiParam><apiItemName>fromIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0x7fffffff</apiData><apiDesc>要在 Vector 中开始搜索指定项的位置。默认值为允许的最大索引值，这表示搜索从 Vector 中的最后一项开始。
	 <p>如果此参数为负数，则将其视为 <codeph>length + fromIndex</codeph>，这意味着搜索将从末尾倒数第 <codeph>-fromIndex</codeph> 项开始，并且从该位置向后搜索直到索引 0。</p>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     在 Vector 中搜索一个项（从指定的索引位置向后搜索），并返回匹配项的索引位置。使用全等运算符 (<codeph>===</codeph>) 将此项与 Vector 元素进行比较。
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/indexOf()"><linktext>Vector.indexOf()</linktext></link><link href="operators.html#strict_equality"><linktext>===（全等）</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:map"><apiName>map</apiName><shortdesc>
     对 Vector 中的每一项执行函数并返回一个新 Vector，其中包含与此 Vector 中的每一项的函数调用结果相对应的项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个新 Vector，其中包含对此 Vector 中的每一项调用函数所获得的结果。结果 Vector 具有与原始 Vector 相同的基本类型和 <codeph>length</codeph>。
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对 Vector 中的每一项运行的函数。调用此函数时需要使用以下三个参数：Vector 中的当前项、当前项的索引和 Vector 对象：
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):T;</pre> 
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>调用 callback 函数时该函数中的标识符 <codeph>this</codeph> 引用的对象。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Vector 中的每一项执行函数并返回一个新 Vector，其中包含与此 Vector 中的每一项的函数调用结果相对应的项。结果 Vector 具有与原始 Vector 相同的基本类型和 <codeph>length</codeph>。位于结果 Vector 中的索引 <codeph>i</codeph> 位置的元素是对位于原始 Vector 中的索引 <codeph>i</codeph> 位置的元素进行调用所获得的结果。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。这是使用此方法的最常见方式。</p>
	 
	 <p product="flash">但是，假设您使用 Flash Professional 在主时间轴上的某个帧上创建函数，但希望在其他 <codeph>this</codeph> 上下文中调用此函数：</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):T {
        // your code here
     }
     </pre>
	 
     <p product="flash">假设对名为 <codeph>myVector</codeph> 的 Vector 使用 <codeph>map()</codeph> 方法：</p>
	 
     <pre product="flash">
     myVector.map(myFunction, someObject);
     </pre>
	 
     <p product="flash">由于 <codeph>myFunction</codeph> 是 SWF 文件的主类的成员，因此无法在其他 <codeph>this</codeph> 上下文中执行。在运行此代码时，Flash Player 会引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):void {
         //your code here
     };
     myVector.map(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/filter()"><linktext>Vector.filter()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:pop"><apiName>pop</apiName><shortdesc>
     删除 Vector 中的最后一个元素，并返回该元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.pop, pop
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果在 <codeph>fixed</codeph> 为 <codeph>true</codeph> 时调用此方法。
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>指定的 Vector 中最后一个元素的值。
	 
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     删除 Vector 中的最后一个元素，并返回该元素。当调用此函数时，将 Vector 的 <codeph>length</codeph> 属性值减一。
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:push"><apiName>push</apiName><shortdesc>
     将一个或多个元素添加到 Vector 的结尾，并返回该 Vector 的新长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.push, push
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果任何参数都不是 Vector 的基本类型 <codeph>T</codeph> 的实例。
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>如果在 <codeph>fixed</codeph> 为 <codeph>true</codeph> 时调用此方法。
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>添加新元素后的 Vector 的长度。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>要追加到 Vector 中的一个或多个值。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个或多个元素添加到 Vector 的结尾，并返回该 Vector 的新长度。
	 
	 <p>由于此函数可接受多个参数，因此在编译时不会检查参数的数据类型（即使在严格模式下也不检查）。但是，如果传递的参数不是基本类型的实例，则在运行时会出现异常。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:reverse"><apiName>reverse</apiName><shortdesc>
     颠倒 Vector 中元素的顺序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.reverse, reverse
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>元素顺序颠倒的 Vector。
	 
     </apiDesc><apiType value="Vector$T"/></apiReturn></apiOperationDef><apiDesc>
     颠倒 Vector 中元素的顺序。此方法会改变对其进行调用的 Vector。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:shift"><apiName>shift</apiName><shortdesc>
     删除 Vector 中的第一个元素，并返回该元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.shift, shift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>fixed</codeph> 为 <codeph>true</codeph>。
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>Vector 中的第一个元素。
     
	 </apiDesc><apiType value="T"/></apiReturn></apiOperationDef><apiDesc>
     删除 Vector 中的第一个元素，并返回该元素。其余的 Vector 元素将从其原始位置 i 移至 i - 1。
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/unshift()"><linktext>Vector.unshift()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:slice"><apiName>slice</apiName><shortdesc>
     返回由原始 Vector 中某一范围的元素构成的新 Vector，而不修改原始 Vector。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.slice, slice
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>一个 Vector，其中包含原始 Vector 中某一范围的元素。
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>一个数字，指定片段起始点的索引。如果 <codeph>startIndex</codeph> 是负数，则起始点从 Vector 的末尾开始，其中 -1 表示最后一个元素。  
     
     </apiDesc></apiParam><apiParam><apiItemName>endIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>16777215</apiData><apiDesc>一个数字，指定片段终点的索引。如果省略此参数，则片段包括从起始点到 Vector 的末尾的所有元素。如果 <codeph>endIndex</codeph> 是负数，则从 Vector 的末尾指定终点，其中 -1 表示最后一个元素。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>返回一个新 Vector，其中包含原始 Vector 中某一范围的元素。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     返回由原始 Vector 中某一范围的元素构成的新 Vector，而不修改原始 Vector。返回的 Vector 包括从 <codeph>startIndex</codeph> 元素开始到 <codeph>endIndex</codeph> 元素（但不包括该元素）的所有元素。
	 
     <p>如果您没有传递任何参数，则创建原始 Vector 的一个副本。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:some"><apiName>some</apiName><shortdesc>
     对 Vector 中的每一项执行测试函数，直到获得返回 true 的项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>如果 Vector 中的所有项对于指定的函数都返回 <codeph>true</codeph>，则为布尔值 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>callback</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>要对 Vector 中的每一项运行的函数。调用此函数时需要使用以下三个参数：Vector 中的当前项、当前项的索引和 Vector 对象：
     <pre>function callback(item:T, index:int, vector:Vector.&lt;T>):Boolean</pre> 
     
     <p>callback 函数应返回一个布尔值。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>thisObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>调用 callback 函数时该函数中的标识符 <codeph>this</codeph> 引用的对象。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Vector 中的每一项执行测试函数，直到获得返回 <codeph>true</codeph> 的项。使用此方法可确定 Vector 中的所有项是否满足条件，如具有小于某一特定数字的值。
     
     <p product="flash">在此方法中，如果第一个参数 <codeph>callback</codeph> 为 closure 方法，则第二个参数 <codeph>thisObject</codeph> 必须为 <codeph>null</codeph>。这是使用此方法的最常见方式。</p>
	 
	 <p product="flash">假设在主时间轴的帧上创建一个函数，并希望在不同的 <codeph>this</codeph> 上下文中调用此函数：</p>
	 
     <pre product="flash">
     function myFunction(item:Object, index:int, vector:Vector.&lt;T>):Boolean {
        // your code here
     }
     </pre>
	 
     <p product="flash">假设对名为 <codeph>myVector</codeph> 的 Vector 使用 <codeph>some()</codeph> 方法：</p>
	 
     <pre product="flash">
     myVector.some(myFunction, someObject);
     </pre>
	 
     <p product="flash">由于 <codeph>myFunction</codeph> 是 SWF 文件的主类的成员，因此无法在其他 <codeph>this</codeph> 上下文中执行。在运行此代码时，Flash Player 会引发异常。通过将该函数分配给某个变量（如下所示），可以避免这种运行时错误：</p>
	 
     <pre product="flash">
     var myFunction:Function = function(item:T, index:int, vector:Vector.&lt;T>):Boolean {
         //your code here
     };
     myVector.some(myFunction, someObject);
     </pre>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/every()"><linktext>every()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:sort"><apiName>sort</apiName><shortdesc>
     对 Vector 中的元素进行排序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.sort, sort
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiReturn><apiDesc>其中的元素按新顺序进行排序的 Vector。
     
     </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>compareFunction</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>一种可确定排序行为的比较方法。
	 
     <p>指定的方法必须采用两个 Vector 基本类型 (<codeph>T</codeph>) 的参数并返回一个 Number：</p>
	 
	 <codeblock>function compare(x:T, y:T):Number {}</codeblock>
	 
	 <p><codeph>compareFunction</codeph> 函数的逻辑为：给定两个元素 <codeph>x</codeph> 和 <codeph>y</codeph>，此函数将返回以下三个值之一：</p>
	 
     <ul>
       <li>一个负数，如果 <codeph>x</codeph> 应在排序后的序列中出现在 <codeph>y</codeph> 之前</li>
       <li>0，如果 <codeph>x</codeph> 等于 <codeph>y</codeph></li>
       <li>一个正数，如果 <codeph>x</codeph> 应在排序后的序列中出现在 <codeph>y</codeph> 之后</li>
     </ul>
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Vector 中的元素进行排序。此方法根据作为 <codeph>compareFunction</codeph> 参数提供的函数执行排序。
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:AS3:splice"><apiName>splice</apiName><shortdesc>
     对 Vector 添加元素以及从 Vector 中删除元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.splice, splice
	 
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果 <codeph>startIndex</codeph> 和 <codeph>deleteCount</codeph> 参数指定要删除的索引超出了 Vector 的范围。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>如果在 <codeph>fixed</codeph> 为 <codeph>true</codeph> 且 <codeph>splice()</codeph> 操作更改 Vector 的 <codeph>length</codeph> 时调用此方法。
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 Vector，其中包含已从原始 Vector 中删除的元素。
     
	 </apiDesc><apiType value="Vector$T"/></apiReturn><apiParam><apiItemName>startIndex</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整数，它指定 Vector 中开始进行插入或删除的位置处的元素的索引。可以用一个负整数来指定相对于 Vector 的末尾的位置（例如，-1 表示 Vector 的最后一个元素）。
	 
     </apiDesc></apiParam><apiParam><apiItemName>deleteCount</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个整数，它指定要删除的元素数量。该数量包括 <codeph>startIndex</codeph> 参数中指定的元素。如果没有为 <codeph>deleteCount</codeph> 参数指定值，则该方法将删除从 <codeph>startIndex</codeph> 元素到 Vector 中最后一个元素的所有值。如果该参数的值为 0，则不删除任何元素。
	 
     </apiDesc></apiParam><apiParam><apiItemName>items</apiItemName><apiType value="restParam"/><apiDesc>以逗号分隔的一个或多个值的可选列表，此可选列表将插入 <codeph>startIndex</codeph> 参数中的指定位置处的 Vector。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     对 Vector 添加元素以及从 Vector 中删除元素。此方法会修改 Vector 但不制作副本。
	 
     <p><b>注意：</b>要在 Vector 的子类中覆盖此方法，请使用 <codeph>...args</codeph> 作为参数，如下例所示：</p>
	 
     <pre>
     public override function splice(...args) {
       // your statements here
     }
     </pre>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="Vector:toLocaleString"><apiName>toLocaleString</apiName><shortdesc>
     返回一个字符串，它表示指定 Vector 中的元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>由 Vector 元素组成的字符串。
	 
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     返回一个字符串，它表示指定 Vector 中的元素。Vector 中的每一个元素（从索引 0 开始到最大索引结束）均会转换为一个连接字符串，并以逗号分隔。在 ActionScript 3.0 实现中，此方法与 <codeph>Vector.toString()</codeph> 方法返回相同的值。
     
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/toString()"><linktext>Vector.toString()</linktext></link></related-links></apiOperation><apiOperation id="Vector:toString"><apiName>toString</apiName><shortdesc>
     返回一个字符串，它表示 Vector 中的元素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.toString, toString
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>由 Vector 元素组成的字符串。
     
     </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
     返回一个字符串，它表示 Vector 中的元素。Vector 中的每一个元素（从索引 0 开始到最大索引结束）均会转换为一个连接字符串，并以逗号分隔。要指定自定义的分隔符，请使用 <codeph>Vector.join()</codeph> 方法。
     
     </apiDesc></apiOperationDetail><related-links><link href="#String/split()"><linktext>String.split()</linktext></link><link href="#Vector/join()"><linktext>Vector.join()</linktext></link></related-links></apiOperation><apiOperation id="Vector:AS3:unshift"><apiName>unshift</apiName><shortdesc>
     将一个或多个元素添加到 Vector 的开头，并返回该 Vector 的新长度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>Vector.unshift, unshift
     
     </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="AS3"/><apiException><apiDesc>如果任何参数都不是 Vector 的基本类型 <codeph>T</codeph> 的实例。
     
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>如果在 <codeph>fixed</codeph> 为 <codeph>true</codeph> 时调用此方法。
     
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个整数，表示 Vector 的新长度。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/><apiDesc>要在 Vector 的开头插入的 Vector 的基本类型的一个或多个实例。  
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将一个或多个元素添加到 Vector 的开头，并返回该 Vector 的新长度。Vector 中的其它元素从其原始位置 i 移到 i + 新元素的数目。
     
	 <p>由于此函数可接受多个参数，因此在编译时不会检查参数的数据类型（即使在严格模式下也不检查）。但是，如果传递的参数不是基本类型的实例，则在运行时会出现异常。</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="#Vector/pop()"><linktext>Vector.pop()</linktext></link><link href="#Vector/push()"><linktext>Vector.push()</linktext></link><link href="#Vector/shift()"><linktext>Vector.shift()</linktext></link></related-links></apiOperation><apiValue id="Vector:fixed:get"><apiName>fixed</apiName><shortdesc>
     指示能否更改 Vector 的 length 属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.fixed, fixed
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示能否更改 Vector 的 <codeph>length</codeph> 属性。如果值为 <codeph>false</codeph>，则无法更改 <codeph>length</codeph> 属性。这表示当 <codeph>fixed</codeph> 为 <codeph>true</codeph> 时，不允许执行以下操作：
	 
	 <ul>
	   <li>直接设置 <codeph>length</codeph> 属性</li>
	   <li>将值分配给索引位置 <codeph>length</codeph></li>
	   <li>调用可更改 <codeph>length</codeph> 属性的方法，包括：
	     <ul>
	       <li><codeph>pop()</codeph></li>
	       <li><codeph>push()</codeph></li>
	       <li><codeph>shift()</codeph></li>
	       <li><codeph>unshift()</codeph></li>
	       <li><codeph>splice()</codeph>（如果 <codeph>splice()</codeph> 调用更改 Vector 的 <codeph>length</codeph>）。</li>
	     </ul>
	   </li>
	 </ul>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="Vector:length:get"><apiName>length</apiName><shortdesc>
     Vector 中可用的有效索引的范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>vector.length, length
     
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>如果在 <codeph>fixed</codeph> 为 <codeph>true</codeph> 时更改此属性。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>如果将此属性设置为一个大于允许的最大索引值 (2<sup>32</sup>) 的值。
	 
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     Vector 中可用的有效索引的范围。Vector 实例具有最大不超过 <codeph>length</codeph> 值的索引位置（但不包括此值）。
	 
	 <p>每个 Vector 元素始终具有一个值，该值要么为一个基本类型的实例，要么为 <codeph>null</codeph>。若将 <codeph>length</codeph> 属性设置为一个大于其先前值的值时，则将创建额外的元素，并使用适合基本类型的默认值（对于引用类型使用 <codeph>null</codeph>）来填充这些元素。</p>
	 
	 <p>当 <codeph>length</codeph> 属性设置为一个小于其先前值的值时，将从 Vector 中删除位于大于或等于新 <codeph>length</codeph> 值的索引位置处的所有元素。</p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>