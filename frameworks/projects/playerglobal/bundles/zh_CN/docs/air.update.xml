<?xml version="1.0"?>
<apiPackage id="air.update"><apiName>air.update</apiName><apiDetail/><apiClassifier id="air.update:ApplicationUpdater"><apiName>ApplicationUpdater</apiName><shortdesc>
	ApplicationUpdater 类定义 Adobe&amp;#xAE; AIR&amp;#xAE; 应用程序更新框架的基本功能，但不提供任何默认的用户界面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	ApplicationUpdater 类定义 Adobe<sup>®</sup> AIR<sup>®</sup> 应用程序更新框架的基本功能，但不提供任何默认的用户界面。（ApplicationUpdaterUI 类包括更新功能<i>和</i> 默认的用户界面。） 
		
	<p product="flex">此类包括在 applicationupdater.swc 文件中。创建 Adobe AIR 项目时，Adobe<sup>®</sup> Flex™ Builder™ 将自动加载此类。Adobe <sup>®</sup> Flex™ SDK 也包括此 applicationupdater.swc 文件，在使用 Flex SDK 编译应用程序时应该加入此文件。</p>
	
	<p product="flash">此类包括在 Adobe<sup>®</sup> Flex™ SDK 中所含的 applicationupdater_ui.swc 文件中。 </p>
	
	<p platform="javascript">要在 JavaScript 代码中使用此类，请加载 applicationupdater.swf 文件（AIR SDK 中提供），如下所示：</p>
	
	<codeblock platform="javascript">&lt;script src="applicationupdater.swf" type="application/x-shockwave-flash"></codeblock>
		
	<p>管理应用程序的更新可能非常复杂。AIR 更新框架提供的 API 可帮助开发人员在 AIR 应用程序中提供良好的更新功能。AIR 更新框架中的功能帮助开发人员完成以下工作：</p>
	
	<ul><li>
	<p>根据某一时间间隔或用户请求定期检查更新</p>
	</li>
	<li>
	<p>从 Web 源下载 AIR 文件（更新）</p>
	</li>
	<li>
	<p>在首次运行新安装的版本时向用户发出警告</p>
	</li>
	<li>
	<p>确认用户希望检查更新</p>
	</li>
	<li>
	<p>向用户显示有关新的更新版本的信息</p>
	</li>
	<li>
	<p>向用户显示下载进度和错误信息</p>
	</li></ul>
	
	<p>AIR 更新框架允许您将有关 AIR 应用程序更新版本的信息存储在简单 XML 配置文件中。对于大多数应用程序，设置这些配置文件以及包括一些基本代码可以为最终用户提供良好的更新功能。</p>
	
	<p>如果要定义自己的用户界面以便与 AIR 更新框架配合使用，请使用 AIRUpdater 类。</p>
	
	<p>更新过程包括一系列状态。updater 对象的 <codeph>currentState</codeph> 属性反映 updater 的当前状态：</p>
	
	<p><adobetable class="innertable">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<tgroup cols="2"><thead><row><entry>
	currentState 值
	</entry><entry>
	说明
	</entry></row></thead><tbody><row><entry>"UNINITIALIZED"</entry>
	<entry>updater 尚未初始化。</entry>
	</row><row><entry>"INITIALIZING"</entry>
	<entry>updater 正在初始化。</entry>
	</row><row><entry>"READY"</entry>
	<entry>updater 已初始化</entry>
	</row><row><entry>"BEFORE_CHECKING"</entry>
	<entry>updater 尚未检查更新描述符文件。</entry>
	</row><row><entry>"CHECKING"</entry>
	<entry>updater 正在检查更新描述符文件。</entry>
	</row><row><entry>"AVAILABLE"</entry>
	<entry>更新描述符文件可用。</entry>
	</row><row><entry>"DOWNLOADING"</entry>
	<entry>updater 正在下载 AIR 文件。</entry>
	</row><row><entry>"DOWNLOADED"</entry>
	<entry>updater 已下载 AIR 文件。</entry>
	</row><row><entry>"INSTALLING"</entry>
	<entry>updater 正在安装 AIR 文件。</entry>
	</row><row><entry>"PENDING_INSTALLING"</entry>
	<entry>updater 已初始化，但存在未处理的更新。</entry>
	</row></tbody></tgroup></adobetable></p>
	
	<p>使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，尝试更新该应用程序会导致 IllegalOperationError 异常。</p>
	
	<p product="flex">有关使用 AIR 更新框架的详细信息，请参阅<xref href="http://www.adobe.com/go/learn_air_flex3">用 Adobe Flex 开发 Adobe AIR 应用程序</xref>的“更新 AIR 应用程序”一章。</p> 
	
	<p product="flash">有关使用 AIR 更新框架的详细信息，请参阅<xref href="http://www.adobe.com/go/learn_air_flash">使用 Adobe Flash 开发 Adobe AIR 应用程序</xref>中的“更新 AIR 应用程序”一章。</p> 
	
	<p platform="javascript">有关使用 AIR 更新框架的详细信息，请参阅<xref href="http://www.adobe.com/go/learn_air_html">使用 HTML 和 Ajax 开发 Adobe AIR 应用程序</xref>的“更新 AIR 应用程序”一章。</p> 
	
	</apiDesc></apiClassifierDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI"><linktext>ApplicationUpdaterUI</linktext></link><link href="flash.desktop.xml#Updater"><linktext>flash.desktop.Updater</linktext></link></related-links><adobeApiEvent id="air.update:ApplicationUpdater_flash.events.ErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc> 
	初始化过程中或更新过程中出错时（如果发生某种意外情况），将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	初始化过程中或更新过程中出错时（如果发生某种意外情况），将分派此事件。
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc> 
	初始化完成之后，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	初始化完成之后，将分派此事件。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.StatusFileUpdateErrorEvent.FILE_UPDATE_ERROR_fileUpdateError"><apiName>fileUpdateError</apiName><shortdesc> 
	 验证调用 installFromAIRFile() 方法过程中作为 airFile 参数传递的文件时，若出错，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusFileUpdateErrorEvent.FILE_UPDATE_ERROR</apiEventType><adobeApiEventClassifier>air.update.events.StatusFileUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	 验证调用 <codeph>installFromAIRFile()</codeph> 方法过程中作为 <codeph>airFile</codeph> 参数传递的文件时，若出错，将分派此事件。
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.StatusFileUpdateEvent.FILE_UPDATE_STATUS_fileUpdateStatus"><apiName>fileUpdateStatus</apiName><shortdesc> 
	updater 成功验证调用 installFromAIRFile() 方法过程中的文件之后将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusFileUpdateEvent.FILE_UPDATE_STATUS</apiEventType><adobeApiEventClassifier>air.update.events.StatusFileUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	updater 成功验证调用 <codeph>installFromAIRFile()</codeph> 方法过程中的文件之后将分派此事件。
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.DownloadErrorEvent.DOWNLOAD_ERROR_downloadError"><apiName>downloadError</apiName><shortdesc> 
	如果在连接或下载更新文件时出错，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.DownloadErrorEvent.DOWNLOAD_ERROR</apiEventType><adobeApiEventClassifier>air.update.events.DownloadErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	如果在连接或下载更新文件时出错，将分派此事件。HTTP 状态无效（如“404 - 找不到文件”）时也会分派此事件。
	
	<p>分派此事件时，定期检查计时器将自动重新启动（如果延迟大于 0）。 </p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.StatusUpdateErrorEvent.UPDATE_ERROR_updateError"><apiName>updateError</apiName><shortdesc> 
	如果尝试下载或分析更新描述符文件时出错，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusUpdateErrorEvent.UPDATE_ERROR</apiEventType><adobeApiEventClassifier>air.update.events.StatusUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	如果尝试下载或分析更新描述符文件时出错，将分派此事件。
	
	<p>updater 分派此事件时，定期检查计时器将自动重新启动（如果延迟设置大于 0）。updater 分派新的 <codeph>checkForUpdate</codeph> 事件时，应用程序应该考虑隐藏所有错误对话框。 </p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.StatusUpdateEvent.UPDATE_STATUS_updateStatus"><apiName>updateStatus</apiName><shortdesc> 
	updater 成功下载并解释更新描述符文件之后，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusUpdateEvent.UPDATE_STATUS</apiEventType><adobeApiEventClassifier>air.update.events.StatusUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	updater 成功下载并解释更新描述符文件之后，将分派此事件。 
	
	<p>如果将 StatusUpdateEvent 对象的 available 属性设置为 <codeph>true</codeph>，则默认行为是开始下载更新。只有在使用 ApplicationUpdater 类时可以阻止默认行为，而使用 ApplicationUpdatorUI 类时不能。</p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.UpdateEvent.BEFORE_INSTALL_beforeInstall"><apiName>beforeInstall</apiName><shortdesc> 
	 调用 installUpdate() 方法之后，恰好在安装更新之前将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.BEFORE_INSTALL</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	 调用 <codeph>installUpdate()</codeph> 方法之后，恰好在安装更新之前将分派此事件。某些情况下，最好在此时阻止更新的安装，这是因为运行时退出应用程序以安装更新时，用户可能会丢失所有当前工作。 
	 
	 <p>调用此事件的 <codeph>preventDefault()</codeph> 方法可将安装推迟到下一次重新启动。如果调用 <codeph>preventDefault()</codeph> 方法，则在此应用程序会话过程中不能再启动其它更新过程（通过调用 <codeph>installUpdate()</codeph> 方法或因定期检查）。 </p>
	 
	 <p>ApplicationUpdater 库的默认行为是下载更新描述符文件。可以调用 <codeph>preventDefault()</codeph> 方法取消此行为。</p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.UpdateEvent.DOWNLOAD_COMPLETE_downloadComplete"><apiName>downloadComplete</apiName><shortdesc> 
	更新文件下载完毕时将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.DOWNLOAD_COMPLETE</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	更新文件下载完毕时将分派此事件。
	
	<p>通常使用此事件显示一条消息，询问用户是否要继续安装更新。 </p>
	
	<p>ApplicationUpdater 库的默认行为是自动调用 <codeph>installUpdate()</codeph> 方法。</p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.UpdateEvent.DOWNLOAD_START_downloadStart"><apiName>downloadStart</apiName><shortdesc> 
	 调用 downloadUpdate() 方法并建立到服务器的连接之后将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.DOWNLOAD_START</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	 调用 <codeph>downloadUpdate()</codeph> 方法并建立到服务器的连接之后将分派此事件。使用 ApplicationUpdater 库时，可能希望此事件的事件处理函数显示进度栏，从而向用户报告下载进度。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.UpdateEvent.CHECK_FOR_UPDATE_checkForUpdate"><apiName>checkForUpdate</apiName><shortdesc> 
	升级过程开始之前，恰好在 updater 尝试下载更新描述符文件之前将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.CHECK_FOR_UPDATE</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	升级过程开始之前，恰好在 updater 尝试下载更新描述符文件之前将分派此事件。updater 分派此事件的原因可以是直接调用 <codeph>checkNow()</codeph> 方法或定期检查计时器到期。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater_air.update.events.UpdateEvent.INITIALIZED_initialized"><apiName>initialized</apiName><shortdesc> 
	初始化完成之后，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.INITIALIZED</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	初始化完成之后，将分派此事件。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="air.update:ApplicationUpdater:ApplicationUpdater"><apiName>ApplicationUpdater</apiName><shortdesc>
		构造函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		构造函数。 
		
		</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="air.update:ApplicationUpdater:cancelUpdate"><apiName>cancelUpdate</apiName><shortdesc>
		取消更新过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		取消更新过程。调用此方法将取消所有未处理的下载，删除所有不完整的下载文件，以及重新启动定期检查计时器。
		
		<p>除状态机处于“UNINITIALIZED”或“INITIALIZING”状态之外的任何时候都可以取消更新过程。在“UNINITIALIZED”或“INITIALIZING”状态下调用此方法时，它不会执行任何操作。</p>
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="air.update:ApplicationUpdater:checkForUpdate"><apiName>checkForUpdate</apiName><shortdesc>
		异步下载并解释更新描述符文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		异步下载并解释更新描述符文件。调用此方法会将 updater 的状态前移至“CHECKING”。请仅在取消 <codeph>checkForUpdate</codeph> 事件后调用此方法。
		
		<p>只有 updater 为“BEFORE_CHECKING”状态时此方法才会执行。 </p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdater:checkForUpdate_updateStatus"><apiName>updateStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:StatusUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>updater 已成功下载并解释了更新描述符文件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>updater 已成功下载并解释了更新描述符文件。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater:checkForUpdate_updateError"><apiName>updateError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:StatusUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>尝试下载或分析更新描述符文件时出错。
		
		</apiDesc></adobeApiEventDetail><shortdesc>尝试下载或分析更新描述符文件时出错。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdater:checkNow"><apiName>checkNow</apiName><shortdesc>
		启动更新过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		启动更新过程。调用此方法不会使定期检查计时器停止；但是，此方法可以检测出更新过程正在运行中，并将跳过当前遍历。
		
		<p>只有当前状态为“READY”时此方法才会执行。 </p>
		
		<p>此方法可能导致 updater 对象分派以下事件：</p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdater:checkNow_checkForUpdate"><apiName>checkForUpdate</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>恰好在更新过程开始之前分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>恰好在更新过程开始之前分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdater:downloadUpdate"><apiName>downloadUpdate</apiName><shortdesc>
		异步下载更新文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		异步下载更新文件。调用此方法会将状态机前移至“DOWNLOADING”。只有当 StatusUpdateEvent.UPDATE_STATUS 事件的 available 属性为 true 时取消该事件后才需要调用此方法。
		
		<p>只有当前状态为“AVAILABLE”时此方法才会执行。</p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdater:downloadUpdate_downloadStart"><apiName>downloadStart</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>建立到服务器的连接之后将分派此事件。 
		
		</apiDesc></adobeApiEventDetail><shortdesc>建立到服务器的连接之后将分派此事件。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater:downloadUpdate_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>初始化完成之后，将分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>初始化完成之后，将分派此事件。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater:downloadUpdate_downloadError"><apiName>downloadError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:DownloadErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果在连接或下载更新文件时出错，将分派此事件。HTTP 状态无效（如“404 - 找不到文件”）时也会分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>如果在连接或下载更新文件时出错，将分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdater:initialize"><apiName>initialize</apiName><shortdesc>
		 初始化 updater。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 初始化 updater。调用此方法可执行以下操作： 
		
		<p><ol><li>
		<p>它将初始化更新框架，以静默方式同步安装所有未处理的更新。由于此方法可能会重新启动应用程序，因此在应用程序启动过程中应该调用此方法。</p>
		</li><li>
		
		<p>它检查是否有被推迟的更新，如果有将安装该更新。</p>
		</li><li>
		<p>如果前一次更新有错误，则它将从存储区域中清除更新文件和版本信息。</p>
		</li><li>
		<p>如果定期检查计时器延迟已到期，则它将启动更新过程；否则它将启动定期检查计时器。但是，在使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，尝试更新应用程序会导致 IllegalOperationError 异常。</p>
		</li>
		</ol></p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdater:initialize_initialized"><apiName>initialized</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>初始化完成。 
		
		</apiDesc></adobeApiEventDetail><shortdesc>初始化完成。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater:initialize_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>初始化过程中有错。
		
		</apiDesc></adobeApiEventDetail><shortdesc>初始化过程中有错。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdater:installFromAIRFile"><apiName>installFromAIRFile</apiName><shortdesc>
		使用本地 AIR 文件启动更新过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>要安装的本地 AIR 文件。
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		使用本地 AIR 文件启动更新过程。 
		
		<p>如果正在运行更新过程，则调用此方法不起作用（如果状态不是 <codeph>"DOWNLOADED"</codeph>）。</p>
		
		<p>对于在应用程序描述符文件中将 <codeph>customUpdateUI</codeph> 元素设置为 <codeph>true</codeph> 的应用程序，此函数很有用。</p>
		
		<p>在使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，调用此方法会导致 IllegalOperationError 异常。</p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdater:installFromAIRFile_fileUpdateStatus"><apiName>fileUpdateStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:StatusFileUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>updater 成功验证 AIR 文件之后将分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>updater 成功验证 AIR 文件之后将分派此事件。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdater:installFromAIRFile_updateError"><apiName>updateError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:StatusFileUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果尝试分析更新描述符文件时出错，将分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>如果尝试分析更新描述符文件时出错，将分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdater:installUpdate"><apiName>installUpdate</apiName><shortdesc>
		安装更新文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		安装更新文件。调用此方法会将状态机前移至“INSTALLING”，且只有在取消 <codeph>downLoadComplete</codeph> 事件后才需要调用此方法。
		
		<p>请在 updater 为“DOWNLOADED”状态时调用此方法。在任何其它状态下调用此方法都不起作用。</p>
		
		<p>在使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，调用此方法会导致 IllegalOperationError 异常。</p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdater:installUpdate_beforeInstall"><apiName>beforeInstall</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>恰好在安装更新之前分派此事件。某些情况下，最好在此时阻止更新的安装，这是因为运行时退出应用程序以安装更新时，用户可能会丢失所有当前工作。
		 
		</apiDesc></adobeApiEventDetail><shortdesc>恰好在安装更新之前分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiValue id="air.update:ApplicationUpdater:configurationFile:get"><apiName>configurationFile</apiName><shortdesc>
		设置 delay 和 updateURL 属性值的配置文件所在的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
		设置 <codeph>delay</codeph> 和 <codeph>updateURL</codeph> 属性值的配置文件所在的位置。如果此属性指向不存在的文件，则调用 <codeph>initialize()</codeph> 方法将引发错误。
		
		<p>下面是一个示例配置文件：</p>
		
		<codeblock> &lt;?xml version="1.0" encoding="utf-8"?> 
 		&lt;configuration xmlns="http://ns.adobe.com/air/framework/update/configuration/1.0" >
 		  &lt;url>app:/server/update.xml&lt;/url>
 		  &lt;delay>1&lt;/delay>
		&lt;/configuration></codeblock>
		
		<p>不必加载配置文件，使用 <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> 代码即可设置 <codeph>delay</codeph> 和 <codeph>updateURL</codeph> 属性。</p> 
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdater/delay"><linktext>delay</linktext></link><link href="air.update.xml#ApplicationUpdater/updateURL"><linktext>updateURL</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdater:currentState:get"><apiName>currentState</apiName><shortdesc>
		updater 的内部状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		updater 的内部状态。此属性可设置为下列值：
		
		<p><ul><li>
		<p><codeph>"UNINITIALIZED"</codeph> — updater 尚未初始化。</p>
		</li><li>
		<p><codeph>"INITIALIZING"</codeph> — updater 正在初始化。</p>
		</li><li>
		<p><codeph>"READY"</codeph> — updater 已初始化。</p>
		</li><li>
		<p><codeph>"BEFORE_CHECKING"</codeph> — 尚未检查 updater 中是否有更新描述符文件。</p>
		</li><li>
		<p><codeph>"CHECKING"</codeph> — updater 正在检查是否有更新描述符文件。</p>
		</li><li>
		<p><codeph>"AVAILABLE"</codeph> — 更新描述符文件可用。</p>
		</li><li>
		<p><codeph>"DOWNLOADING"</codeph> — updater 正在下载 AIR 文件。</p>
		</li><li>
		<p><codeph>"DOWNLOADED"</codeph> — updater 已下载 AIR 文件。</p>
		</li><li>
		<p><codeph>"INSTALLING"</codeph> — updater 正在安装 AIR 文件。</p>
		</li><li>
		<p><codeph>"PENDING_INSTALLING"</codeph> — updater 已初始化，但存在未处理的更新。</p>
		</li></ul></p>
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:currentVersion:get"><apiName>currentVersion</apiName><shortdesc>
		应用程序的当前版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		应用程序的当前版本。在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。将其设置为应用程序描述符文件中的版本。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:delay:get"><apiName>delay</apiName><shortdesc>
		定期检查新更新的间隔天数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
		
		</apiDefaultValue></apiValueDef><apiDesc>
		定期检查新更新的间隔天数。
		
		<p>值为 0（默认值）时表示计时器未处于活动状态，因此不进行任何定期检查。可以通过此属性或通过配置文件设置此值。使用这两种方法设置此值后，将使用以此属性设置的值。</p>
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:isFirstRun:get"><apiName>isFirstRun</apiName><shortdesc>
		这是否为成功更新之后的第一次运行，如果是，则为 (true)，否则为 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		这是否为成功更新之后的第一次运行，如果是，则为 (<codeph>true</codeph>)，否则为 (<codeph>false</codeph>)。updater 在调用 <codeph>initialize()</codeph> 方法的过程中设置此值。如果需要将数据从一个版本迁移到另一个版本，则开发人员应该核实 <codeph>isFirstRun</codeph> 已设置为 <codeph>true</codeph>。
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdater/wasPendingUpdate"><linktext>wasPendingUpdate</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdater:isNewerVersionFunction:get"><apiName>isNewerVersionFunction</apiName><shortdesc>
		updater 执行版本比较所应该使用的函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Function</apiValueClassifier></apiValueDef><apiDesc>
		updater 执行版本比较所应该使用的函数。默认情况下，更新框架进行版本比较，以检测远程站点的版本是否比所安装应用程序的版本新。但是，有时默认的比较并不符合开发人员的版本控制方案。设置此属性可提供进行比较的新函数。 
		
		<p>默认的比较函数接受类似 <i>x.y.z</i> 的版本，其中 x、y 和 z 可以包含字母和数字。默认的比较函数能够识别一些特殊情况。如果测试函数在版本字符串中找到<codeph>“alpha”</codeph>、<codeph>“beta”</codeph>或<codeph>“rc”</codeph>，则顺序为 <codeph>alpha</codeph> &lt; <codeph>beta</codeph> &lt; <codeph>rc</codeph>。</p>
		
		</apiDesc><example conref="examples\ApplicationUpdater.configurationFunction.1.as"> 以下代码定义 <codeph>appUpdate</codeph> updater 对象的自定义函数 <codeph>customFn</codeph>。我们特意将示例函数设计得很简单。自定义函数应根据版本控制方案规则返回一个布尔值。
<codeblock>
appUpdate.isNewerVersionFunction = customFn; 

function customFn (currentVersion:String, updateVersion:String):Boolean 
{
    return updateVersion > currentVersion;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:previousApplicationStorageDirectory:get"><apiName>previousApplicationStorageDirectory</apiName><shortdesc>
		应用程序存储目录的原有位置（如果更新之后该目录发生过更改）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
		应用程序存储目录的原有位置（如果更新之后该目录发生过更改）。进行含证书迁移的升级之后，应用程序存储目录位置将发生更改。如果不进行证书迁移，则用户更新应用程序时，应用程序存储目录不会发生更改。且将此属性设置为 <codeph>null</codeph>。在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。 
		
		<p>如果开发人员用 ADT 打包 AIR 文件时使用 <codeph>-migrate</codeph> 选项，则该开发人员可以用新的证书为 AIR 应用程序的新版本签名。如果 AIR 应用程序的新版本使用新的签名证书，则用户安装新版本时，应用程序的本地存储目录将发生更改。使用此属性将数据从旧的应用程序存储目录转移到新的应用程序存储目录 (<codeph>File.applicationStorageDirectory</codeph>)。有关详细信息，请参阅《Adobe AIR 开发人员指南》中“使用命令行工具创建 AIR 应用程序”一章的“为 AIR 文件签名以更改应用程序证书”。</p>
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:previousVersion:get"><apiName>previousVersion</apiName><shortdesc>
		应用程序的原有版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		应用程序的原有版本。在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。返回升级之前应用程序的<i>原有版本</i>（仅当 <codeph>isfirstRun</codeph> 为 <codeph>true</codeph> 时设置）；否则将其设置为 <codeph>null</codeph>。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:updateDescriptor:get"><apiName>updateDescriptor</apiName><shortdesc>
		从更新 URL 下载的更新描述符文件的内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>XML</apiValueClassifier></apiValueDef><apiDesc>
		从更新 URL 下载的更新描述符文件的内容。只有在 updater 对象分派 <codeph>updateStatus</codeph> 事件之后，此属性才为非 null。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:updateURL:get"><apiName>updateURL</apiName><shortdesc>
		更新描述符文件的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		更新描述符文件的位置。可以接受对 URLRequest 路径有效的任何位置。这是 updater 所需的唯一一个必要设置。可以通过此属性或通过配置文件来设置更新 URL。使用这两种方法设置此值后，updater 将使用以此属性设置的值。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdater:wasPendingUpdate:get"><apiName>wasPendingUpdate</apiName><shortdesc>
		是否有被推迟的更新（即使其未能安装），如果有，则为 (true)；否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		是否有被推迟的更新（即使其未能安装），如果有，则为 (<codeph>true</codeph>)；否则为 <codeph>false</codeph>。updater 在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。使用 <codeph>wasPendingUpdate</codeph> 和 <codeph>isFirstRun</codeph> 属性检查更新是否未能安装（这种情况下 <codeph>wasPendingUpdate</codeph> 设置为 <codeph>true</codeph>，且 <codeph>isFirstRun</codeph> 设置为 <codeph>false</codeph>）。
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdater/isFirstRun"><linktext>isFirstRun</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="air.update:ApplicationUpdaterUI"><apiName>ApplicationUpdaterUI</apiName><shortdesc>
	ApplicationUpdaterUI 类定义 Adobe&amp;#xAE; AIR&amp;#xAE; 应用程序更新框架的基本功能，并提供默认的用户界面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	ApplicationUpdaterUI 类定义 Adobe<sup>®</sup> AIR<sup>®</sup> 应用程序更新框架的基本功能，并提供了一个默认用户界面。（ApplicationUpdater 类定义更新功能，但<i>并不</i> 实现默认的用户界面。） 
	
	<p product="flex">此类包含在 applicationupdater_ui.swc 文件中。创建 Adobe AIR 项目时，Adobe<sup>®</sup> Flex™ Builder™ 将自动加载此类。Adobe<sup>®</sup> Flex™ SDK 也包括此 applicationupdater_ui.swc 文件。如果使用 Flex SDK，则应在编译应用程序时包含此文件。</p>
	
	<p product="flash">此类包括在 Adobe<sup>®</sup> Flex™ SDK 中所含的 applicationupdater_ui.swc 文件中。 </p>
	
	<p platform="javascript">要在 JavaScript 代码中使用此类，请加载 applicationupdater_ui.swf 文件（AIR SDK 中提供），如下所示：</p>
	
	<codeblock platform="javascript">&lt;script src="applicationupdater_ui.swf" type="application/x-shockwave-flash"></codeblock>
		
	<p>管理应用程序的更新可能非常复杂。AIR 更新框架提供的 API 可帮助开发人员在 AIR 应用程序中提供良好的更新功能。AIR 更新框架中的功能帮助开发人员完成以下工作：</p>
	
	<ul><li>
	<p>根据某一时间间隔或用户请求定期检查更新</p>
	</li>
	<li>
	<p>从 Web 源下载 AIR 文件（更新）</p>
	</li>
	<li>
	<p>在首次运行新安装的版本时向用户发出警告</p>
	</li>
	<li>
	<p>确认用户希望检查更新</p>
	</li>
	<li>
	<p>向用户显示有关新的更新版本的信息</p>
	</li>
	<li>
	<p>向用户显示下载进度和错误信息</p>
	</li></ul>
	
	<p>AIR 更新框架允许您将有关 AIR 应用程序更新版本的信息存储在简单 XML 配置文件中。对于大多数应用程序，设置这些配置文件以及包括一些基本代码可以为最终用户提供良好的更新功能。</p>
	
	<p>AIRUpdateUI 类实现默认的用户界面，您的应用程序可以使用该用户界面。该示例用户界面为用户提供了与应用程序更新相关的基本信息和选项。</p>
	
	<p>更新过程要经历一系列状态：</p>
	
	<p><adobetable class="innertable">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<tgroup cols="2"><thead><row><entry>
	状态
	</entry><entry>
	说明
	</entry></row></thead><tbody><row><entry>未初始化</entry>
	<entry>updater 尚未初始化。</entry>
	</row><row><entry>正在初始化</entry>
	<entry>updater 正在初始化。</entry>
	</row><row><entry>就绪</entry>
	<entry>updater 已初始化</entry>
	</row><row><entry>检查之前</entry>
	<entry>updater 尚未检查更新描述符文件。</entry>
	</row><row><entry>正在检查</entry>
	<entry>updater 正在检查更新描述符文件。</entry>
	</row><row><entry>可用</entry>
	<entry>更新描述符文件可用。</entry>
	</row><row><entry>正在下载</entry>
	<entry>updater 正在下载 AIR 文件。</entry>
	</row><row><entry>已下载</entry>
	<entry>updater 已下载 AIR 文件。</entry>
	</row><row><entry>正在安装</entry>
	<entry>updater 正在安装 AIR 文件。</entry>
	</row><row><entry>待处理的安装</entry>
	<entry>updater 已初始化，但存在未处理的更新。</entry>
	</row></tbody></tgroup></adobetable></p>
	
	<p>使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，尝试更新该应用程序会导致 IllegalOperationError 异常。</p>
	
	<p product="flex">有关使用 AIR 更新框架的详细信息，请参阅<xref href="http://www.adobe.com/go/learn_air_flex3">用 Adobe Flex 开发 Adobe AIR 应用程序</xref>的“更新 AIR 应用程序”一章。</p> 
	
	<p product="flash">有关使用 AIR 更新框架的详细信息，请参阅<xref href="http://www.adobe.com/go/learn_air_flash">使用 Adobe Flash 开发 Adobe AIR 应用程序</xref>中的“更新 AIR 应用程序”一章。</p> 
	
	<p platform="javascript">有关使用 AIR 更新框架的详细信息，请参阅<xref href="http://www.adobe.com/go/learn_air_html">用 HTML 和 Ajax 开发 Adobe AIR 应用程序</xref>的“更新 AIR 应用程序”一章。</p> 
	
	</apiDesc></apiClassifierDetail><related-links><link href="air.update.xml#ApplicationUpdater"><linktext>ApplicationUpdater</linktext></link><link href="flash.desktop.xml#Updater"><linktext>flash.desktop.Updater</linktext></link></related-links><adobeApiEvent id="air.update:ApplicationUpdaterUI_flash.events.ErrorEvent.ERROR_error"><apiName>error</apiName><shortdesc> 
	初始化过程中或更新过程中出错时（如果发生某种意外情况），将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ErrorEvent.ERROR</apiEventType><adobeApiEventClassifier>flash.events.ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	初始化过程中或更新过程中出错时（如果发生某种意外情况），将分派此事件。
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc> 
	初始化完成之后，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	初始化完成之后，将分派此事件。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.StatusFileUpdateErrorEvent.FILE_UPDATE_ERROR_fileUpdateError"><apiName>fileUpdateError</apiName><shortdesc> 
	 验证调用 installFromAIRFile() 方法过程中作为 airFile 参数传递的文件时，若出错，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusFileUpdateErrorEvent.FILE_UPDATE_ERROR</apiEventType><adobeApiEventClassifier>air.update.events.StatusFileUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	 验证调用 <codeph>installFromAIRFile()</codeph> 方法过程中作为 <codeph>airFile</codeph> 参数传递的文件时，若出错，将分派此事件。
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.StatusFileUpdateEvent.FILE_UPDATE_STATUS_fileUpdateStatus"><apiName>fileUpdateStatus</apiName><shortdesc> 
	
	updater 成功验证调用 installFromAIRFile() 方法过程中的文件之后将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusFileUpdateEvent.FILE_UPDATE_STATUS</apiEventType><adobeApiEventClassifier>air.update.events.StatusFileUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	
	updater 成功验证调用 <codeph>installFromAIRFile()</codeph> 方法过程中的文件之后将分派此事件。
	
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.DownloadErrorEvent.DOWNLOAD_ERROR_downloadError"><apiName>downloadError</apiName><shortdesc> 
	如果在连接或下载更新文件时出错，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.DownloadErrorEvent.DOWNLOAD_ERROR</apiEventType><adobeApiEventClassifier>air.update.events.DownloadErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	如果在连接或下载更新文件时出错，将分派此事件。HTTP 状态无效（如“404 - 找不到文件”）时也会分派此事件。
	
	<p>分派此事件时，定期检查计时器将自动重新启动（如果延迟大于 0）。 </p>
	
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.StatusUpdateErrorEvent.UPDATE_ERROR_updateError"><apiName>updateError</apiName><shortdesc> 
	
	如果尝试下载或分析更新描述符文件时出错，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusUpdateErrorEvent.UPDATE_ERROR</apiEventType><adobeApiEventClassifier>air.update.events.StatusUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	
	如果尝试下载或分析更新描述符文件时出错，将分派此事件。
	
	<p>updater 分派此事件时，定期检查计时器将自动重新启动（如果延迟设置大于 0）。updater 分派新的 <codeph>checkForUpdate</codeph> 事件时，应用程序应该考虑隐藏所有错误对话框。 </p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.StatusUpdateEvent.UPDATE_STATUS_updateStatus"><apiName>updateStatus</apiName><shortdesc> 
	
	updater 成功下载并解释更新描述符文件之后，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.StatusUpdateEvent.UPDATE_STATUS</apiEventType><adobeApiEventClassifier>air.update.events.StatusUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	
	updater 成功下载并解释更新描述符文件之后，将分派此事件。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.UpdateEvent.BEFORE_INSTALL_beforeInstall"><apiName>beforeInstall</apiName><shortdesc> 
	 调用 installUpdate() 方法之后，恰好在安装更新之前将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.BEFORE_INSTALL</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	 调用 <codeph>installUpdate()</codeph> 方法之后，恰好在安装更新之前将分派此事件。某些情况下，最好在此时阻止更新的安装，这是因为运行时退出应用程序以安装更新时，用户可能会丢失所有当前工作。 
	 
	 <p>调用此事件的 <codeph>preventDefault()</codeph> 方法可将安装推迟到下一次重新启动。如果调用 <codeph>preventDefault()</codeph> 方法，则在此应用程序会话过程中不能再启动其它更新过程（通过调用 <codeph>installUpdate()</codeph> 方法或因定期检查）。 </p>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.UpdateEvent.DOWNLOAD_COMPLETE_downloadComplete"><apiName>downloadComplete</apiName><shortdesc> 
	
	更新文件下载完毕时将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.DOWNLOAD_COMPLETE</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	
	更新文件下载完毕时将分派此事件。
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.UpdateEvent.DOWNLOAD_START_downloadStart"><apiName>downloadStart</apiName><shortdesc> 
	
	 调用 downloadUpdate() 方法并建立到服务器的连接之后将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.DOWNLOAD_START</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	
	 调用 <codeph>downloadUpdate()</codeph> 方法并建立到服务器的连接之后将分派此事件。使用 ApplicationUpdater 库时，可能希望此事件的事件处理函数显示进度栏，从而向用户报告下载进度。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.UpdateEvent.CHECK_FOR_UPDATE_checkForUpdate"><apiName>checkForUpdate</apiName><shortdesc> 
	升级过程开始之前，恰好在 updater 尝试下载更新描述符文件之前将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.CHECK_FOR_UPDATE</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	升级过程开始之前，恰好在 updater 尝试下载更新描述符文件之前将分派此事件。updater 分派此事件的原因可以是直接调用 <codeph>checkNow()</codeph> 方法或定期检查计时器到期。 
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI_air.update.events.UpdateEvent.INITIALIZED_initialized"><apiName>initialized</apiName><shortdesc> 
	
	初始化完成之后，将分派此事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>air.update.events.UpdateEvent.INITIALIZED</apiEventType><adobeApiEventClassifier>air.update.events.UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc> 
	
	初始化完成之后，将分派此事件。 
	 
	 <p>此事件具有以下只读属性： </p>
	 <ul><li>
	 <p>	<codeph>isFirstRun</codeph>（布尔型）如果这是成功更新之后的第一次运行，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。</p>
	 </li><li>
	 <p>	<codeph>previousVersion</codeph>（字符串）应用程序在升级之前的原有版本（仅在 <codeph>isfirstRun</codeph> 为 <codeph>true</codeph> 时设置）。 </p>
	 </li><li>
	 <p>	<codeph>currentVersion</codeph>（字符串）当前安装版本的应用程序描述符文件中的版本。</p>
	 </li>
	 </ul>
	
	</apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="air.update:ApplicationUpdaterUI:ApplicationUpdaterUI"><apiName>ApplicationUpdaterUI</apiName><shortdesc>
		构造函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		构造函数。 
		
		</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="air.update:ApplicationUpdaterUI:addResources"><apiName>addResources</apiName><shortdesc> 
		 为指定语言动态添加新的资源束。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lang</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>语言代码（如 <codeph>"ro"</codeph> 代表罗马尼亚语）。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>res</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>该对象包含供翻译的键和值。这些键是语言属性文件中的键。下表列出了可能的键（属性名称）。
		 
		 <p>
		 <adobetable class="innertable">
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 
		 <tgroup cols="4"><thead><row><entry> 键  </entry><entry> 英语值  </entry><entry> 对话框 </entry><entry> 说明  </entry></row></thead><tbody><row>
		 <entry> <codeph>appWidth </codeph> </entry>
		 <entry> 530  </entry>
		 <entry> 全部  </entry>
		 <entry> 对话框的宽度。 </entry></row><row>
		 <entry> <codeph>titleWindow </codeph> </entry>
		 <entry> 正在更新:  </entry>
		 <entry> 全部  </entry>
		 <entry> 显示于本机窗口标题栏中应用程序名称之前。 </entry></row><row>
		 <entry> <codeph>titleCheck </codeph> </entry>
		 <entry> 检查更新  </entry>
		 <entry> 检查更新  </entry>
		 <entry> 对话框标题。  </entry></row><row>
		 <entry> <codeph>msgCheck </codeph> </entry>
		 <entry> 是否允许应用程序检查更新？  </entry>
		 <entry> 检查更新  </entry>
		 <entry> 对话框消息。  </entry></row><row>
		 <entry> <codeph>btnCheck </codeph> </entry>
		 <entry> 检查更新  </entry>
		 <entry> 检查更新  </entry>
		 <entry> “检查更新”按钮标签。  </entry></row><row>
		 <entry> <codeph>btnCancel</codeph> </entry>
		 <entry> 取消  </entry>
		 <entry> 含有“取消”按钮的所有对话框  </entry>
		 <entry> “取消”按钮标签。 </entry></row><row>
		 <entry> <codeph>titleCheckNoUpdates </codeph> </entry>
		 <entry> 没有可用的更新  </entry>
		 <entry> 检查更新 - 没有可用的更新  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgCheckNoUpdates </codeph> </entry>
		 <entry> 该应用程序没有可用的更新。  </entry>
		 <entry> 检查更新 - 没有可用的更新  </entry>
		 <entry> 对话框消息。  </entry></row><row>
		 <entry> <codeph>btnClose </codeph> </entry>
		 <entry> 关闭  </entry>
		 <entry> 含有“关闭”按钮的所有对话框  </entry>
		 <entry> “关闭”按钮标签。 </entry></row><row>
		 <entry> <codeph>titleCheckError </codeph> </entry>
		 <entry> 更新错误  </entry>
		 <entry> 检查更新 - 连接错误  </entry>
		 <entry> 对话框标题。  </entry></row><row>
		 <entry> <codeph>msgCheckError </codeph> </entry>
		 <entry> 查找更新时出现错误。错误# {0}  </entry>
		 <entry> 检查更新 - 连接错误  </entry>
		 <entry> 对话框消息。{0} 将被替换为错误 ID。 </entry></row><row>
		 <entry> <codeph>titleUpdate </codeph> </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgUpdate </codeph> </entry>
		 <entry> 该应用程序有更新版本可供下载。  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 对话框消息。 </entry></row><row>
		 <entry> <codeph>lblApplication </codeph> </entry>
		 <entry> 应用程序:  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 应用程序名称之前显示的标签。 </entry></row><row>
		 <entry> <codeph>lblInstalledVersion </codeph> </entry>
		 <entry> 安装的版本:  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 所安装版本之前显示的标签。 </entry></row><row>
		 <entry> <codeph>lblAvailableVersion </codeph> </entry>
		 <entry> 更新版本:  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 更新版本之前显示的标签。 </entry></row><row>
		 <entry> <codeph>btnDownload </codeph> </entry>
		 <entry> 立即下载  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> “立即下载”按钮标签。  </entry></row><row>
		 <entry> <codeph>btnDownloadLater </codeph> </entry>
		 <entry> 以后下载  </entry>
		 <entry> 可用的更新  </entry>
		 <entry> “以后下载”按钮标签。  </entry></row><row>
		 <entry> <codeph>lnkReleaseNotes </codeph> </entry>
		 <entry> 发行说明  </entry>
		 <entry> 含有发行说明链接的所有对话框  </entry>
		 <entry> “发行说明”链接名称。  </entry></row><row>
		 <entry> <codeph>titleProgress </codeph> </entry>
		 <entry> 下载进度...  </entry>
		 <entry> 下载进度  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgProgress </codeph> </entry>
		 <entry> 正在下载更新  </entry>
		 <entry> 下载进度  </entry>
		 <entry> 对话框消息。 </entry></row><row>
		 <entry> <codeph>titleDownloadError </codeph> </entry>
		 <entry> 下载失败  </entry>
		 <entry> 下载错误  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgDownloadError </codeph> </entry>
		 <entry> 下载更新时出错。错误# {0}  </entry>
		 <entry> 下载错误  </entry>
		 <entry> 对话框消息。{0} 将被替换为错误 ID。  </entry></row><row>
		 <entry> <codeph>titleInstall </codeph> </entry>
		 <entry> 安装更新  </entry>
		 <entry> 安装更新  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgInstall </codeph> </entry>
		 <entry> 应用程序更新已下载完毕，可以进行安装。  </entry>
		 <entry> 安装更新  </entry>
		 <entry> 对话框消息。 </entry></row><row>
		 <entry> <codeph>btnInstall </codeph> </entry>
		 <entry> 立即安装  </entry>
		 <entry> 安装更新  </entry>
		 <entry> “安装”按钮标签  </entry></row><row>
		 <entry> <codeph>btnInstallLater </codeph> </entry>
		 <entry> 推迟至重新启动  </entry>
		 <entry> 安装更新  </entry>
		 <entry> “推迟至重新启动”按钮标签  </entry></row><row>
		 <entry> <codeph>titleFileUpdate </codeph> </entry>
		 <entry> 可用的更新  </entry>
		 <entry> 文件 - 可用的更新  </entry>
		 <entry> 对话框标题。  </entry></row><row>
		 <entry> <codeph>msgFileUpdate </codeph> </entry>
		 <entry> 文件包含应用程序的更新版本。是否安装？  </entry>
		 <entry> 文件 - 可用的更新  </entry>
		 <entry> 对话框消息。 </entry></row><row>
		 <entry> <codeph>lblFile </codeph> </entry>
		 <entry> 文件:  </entry>
		 <entry> 文件 - 可用的更新  </entry>
		 <entry> 文件名之前显示的标签  </entry></row><row>
		 <entry> <codeph>titleFileNoUpdate </codeph> </entry>
		 <entry> 没有可用的更新  </entry>
		 <entry> 文件 - 没有可用的更新  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgFileNoUpdate </codeph> </entry>
		 <entry> 文件不包含应用程序的更新版本。  </entry>
		 <entry> 文件 - 没有可用的更新  </entry>
		 <entry> 对话框消息。 </entry></row><row>
		 <entry> <codeph>titleFileError </codeph> </entry>
		 <entry> 文件错误  </entry>
		 <entry> 文件 - 错误  </entry>
		 <entry> 对话框标题。  </entry></row><row>
		 <entry> <codeph>msgFileError </codeph> </entry>
		 <entry> 验证更新文件时出错。错误# {0}  </entry>
		 <entry> 文件 - 错误  </entry>
		 <entry> 对话框消息。{0} 将被替换为错误 ID。 </entry></row><row>
		 <entry> <codeph>titleUnexpectedError </codeph> </entry>
		 <entry> 意外错误  </entry>
		 <entry> 意外错误  </entry>
		 <entry> 对话框标题。 </entry></row><row>
		 <entry> <codeph>msgUnexpectedError </codeph> </entry>
		 <entry> 发生意外错误。错误# {0}  </entry>
		 <entry> 意外错误  </entry>
		 <entry> 对话框消息。{0} 将被替换为错误 ID。  </entry></row></tbody></tgroup></adobetable>
		 
		 </p>
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc> 
		 为指定语言动态添加新的资源束。JavaScript 开发人员使用此方法为应用程序 updater UI 显示的对话框动态添加新语言。（Flex 开发人员可以直接将新语言添加到“ApplicationUpdaterDialogs”资源束中。）
		 
		 </apiDesc></apiOperationDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/localeChain"><linktext>localeChain</linktext></link></related-links></apiOperation><apiOperation id="air.update:ApplicationUpdaterUI:cancelUpdate"><apiName>cancelUpdate</apiName><shortdesc>
		取消更新过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		取消更新过程。调用此方法将取消所有未处理的下载，删除所有不完整的下载文件，以及重新启动定期检查计时器。
		
		<p>除状态机处于“uninitialized”或“initializing”状态之外的任何时候都可以取消更新过程。在“uninitialized”或“initializing”状态下调用此方法时，它不会执行任何操作。</p>
		
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="air.update:ApplicationUpdaterUI:checkNow"><apiName>checkNow</apiName><shortdesc>
		启动更新过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		启动更新过程。调用此方法不会使定期检查计时器停止；但是，此方法可以检测出更新过程正在运行中，并将跳过当前遍历。
		
		<p>只有当前状态为“Ready”时此方法才会执行。 </p>
		
		<p>此方法可能导致 updater 对象分派以下事件：</p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdaterUI:checkNow_checkForUpdate"><apiName>checkForUpdate</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>恰好在更新过程开始之前分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>恰好在更新过程开始之前分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdaterUI:initialize"><apiName>initialize</apiName><shortdesc>
		 初始化 updater。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 初始化 updater。调用此方法可执行以下操作： 
		
		<p><ol><li>
		<p>它将初始化更新框架，以静默方式同步安装所有未处理的更新。由于此方法可能会重新启动应用程序，因此在应用程序启动过程中应该调用此方法。</p>
		</li><li>
		
		<p>它检查是否有被推迟的更新，如果有将安装该更新。</p>
		</li><li>
		<p>如果前一次更新有错误，则它将从存储区域中清除更新文件和版本信息。</p>
		</li><li>
		<p>如果定期检查计时器延迟已到期，则它将启动更新过程；否则它将启动定期检查计时器。但是，在使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，尝试更新应用程序会导致 IllegalOperationError 异常。</p>
		</li>
		</ol></p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdaterUI:initialize_initialized"><apiName>initialized</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:UpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>初始化完成。 
		
		</apiDesc></adobeApiEventDetail><shortdesc>初始化完成。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI:initialize_error"><apiName>error</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>初始化过程中有错。
		
		</apiDesc></adobeApiEventDetail><shortdesc>初始化过程中有错。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="air.update:ApplicationUpdaterUI:installFromAIRFile"><apiName>installFromAIRFile</apiName><shortdesc>
		使用本地 AIR 文件启动更新过程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>要安装的本地 AIR 文件。
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
		使用本地 AIR 文件启动更新过程。 
		
		<p>如果正在运行更新过程，则调用此方法不起作用（如果状态不是 <codeph>"Downloaded"</codeph>）。</p>
		
		<p>对于在应用程序描述符文件中将 <codeph>customUpdateUI</codeph> 元素设置为 <codeph>true</codeph> 的应用程序，此函数很有用。</p>
		
		<p>在使用 AIR Debug Launcher (ADL) 应用程序测试某个应用程序时，调用此方法会导致 IllegalOperationError 异常。</p>
		
		</apiDesc></apiOperationDetail><adobeApiEvent id="air.update:ApplicationUpdaterUI:installFromAIRFile_fileUpdateStatus"><apiName>fileUpdateStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:StatusFileUpdateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>updater 成功验证 AIR 文件之后将分派此事件。
		
		</apiDesc></adobeApiEventDetail><shortdesc>updater 成功验证 AIR 文件之后将分派此事件。</shortdesc></adobeApiEvent><adobeApiEvent id="air.update:ApplicationUpdaterUI:installFromAIRFile_updateError"><apiName>updateError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>air.update.events:StatusFileUpdateErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果尝试分析更新描述符文件时出错，将分派此事件。
		 
		</apiDesc></adobeApiEventDetail><shortdesc>如果尝试分析更新描述符文件时出错，将分派此事件。</shortdesc></adobeApiEvent></apiOperation><apiValue id="air.update:ApplicationUpdaterUI:configurationFile:get"><apiName>configurationFile</apiName><shortdesc>
		设置 delay 和 updateURL 属性值的配置文件所在的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
		设置 <codeph>delay</codeph> 和 <codeph>updateURL</codeph> 属性值的配置文件所在的位置。针对确定更新过程中应用程序是否显示不同的确认对话框，它也具有相应设置。如果此属性指向不存在的文件，则调用 <codeph>initialize()</codeph> 方法将引发错误。
		
		<p>下面是一个示例配置文件：</p>
		
		<codeblock> &lt;?xml version="1.0" encoding="utf-8"?> 
 		&lt;configuration xmlns="http://ns.adobe.com/air/framework/update/configuration/1.0" >
 		  &lt;url>app:/server/update.xml&lt;/url>
 		  &lt;delay>1&lt;/delay>
		   &lt;defaultUI>
		      &lt;dialog name="checkForUpdate" visible="true" />
		       &lt;dialog name="downloadUpdate" visible="false" />
		       &lt;dialog name="downloadProgress" visible="true" />
		       &lt;dialog name="installUpdate" visible="true" />    
		   &lt;/defaultUI>
		&lt;/configuration></codeblock>
		
		<p>不必加载配置文件，使用 <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> 代码即可设置 ApplicationUpdaterUI 对象的以下属性：<codeph>delay</codeph>、<codeph>isCheckForUpdateVisible</codeph>、<codeph>isDownloadProgressVisible</codeph>、<codeph>isDownloadUpdateVisible</codeph>、<codeph>isFileUpdateVisible</codeph>、<codeph>isInstallUpdateVisible</codeph> 和 <codeph>updateURL</codeph> 属性。</p>
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/delay"><linktext>delay</linktext></link><link href="air.update.xml#ApplicationUpdaterUI/updateURL"><linktext>updateURL</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdaterUI:currentVersion:get"><apiName>currentVersion</apiName><shortdesc>
		应用程序的当前版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		应用程序的当前版本。在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。将其设置为应用程序描述符文件中的版本。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:delay:get"><apiName>delay</apiName><shortdesc>
		定期检查新更新的间隔天数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiDefaultValue>0
		
		</apiDefaultValue></apiValueDef><apiDesc>
		定期检查新更新的间隔天数。
		
		<p>值为 0（默认值）时表示计时器未处于活动状态，因此不进行任何定期检查。可以通过此属性或通过配置文件设置延迟。使用这两种方法设置此值后，将使用以此属性设置的值。</p>
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/configurationFile"><linktext>configurationFile</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isCheckForUpdateVisible:get"><apiName>isCheckForUpdateVisible</apiName><shortdesc>
		使“检查更新”、“没有更新”和“更新错误”对话框可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		使“检查更新”、“没有更新”和“更新错误”对话框可见。设置为 <codeph>true</codeph> 时，updater 显示这些对话框作为更新过程的一部分。在更新配置文件中也可以设置此属性。使用此属性设置的值优先于更新配置文件中的设置。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isDownloadProgressVisible:get"><apiName>isDownloadProgressVisible</apiName><shortdesc>
		
		使“下载更新”对话框可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		
		使“下载更新”对话框可见。设置为 <codeph>true</codeph> 时，updater 显示此对话框作为更新过程的一部分。在更新配置文件中也可以设置此属性。使用此属性设置的值优先于更新配置文件中的设置。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isDownloadUpdateVisible:get"><apiName>isDownloadUpdateVisible</apiName><shortdesc>
		使“下载更新”对话框可见。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		使“下载更新”对话框可见。设置为 <codeph>true</codeph> 时，updater 显示这些对话框作为更新过程的一部分。在更新配置文件中也可以设置此属性。使用此属性设置的值优先于更新配置文件中的设置。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isFileUpdateVisible:get"><apiName>isFileUpdateVisible</apiName><shortdesc>
		
		使“文件更新”、“文件没有更新”和“文件错误”对话框可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		
		使“文件更新”、“文件没有更新”和“文件错误”对话框可见。设置为 <codeph>true</codeph> 时，updater 显示这些对话框作为更新过程的一部分。在更新配置文件中也可以设置此属性。使用此属性设置的值优先于更新配置文件中的设置。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isFirstRun:get"><apiName>isFirstRun</apiName><shortdesc>
		这是否为成功更新之后的第一次运行，如果是，则为 (true)，否则为 (false)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		这是否为成功更新之后的第一次运行，如果是，则为 (<codeph>true</codeph>)，否则为 (<codeph>false</codeph>)。updater 在调用 <codeph>initialize()</codeph> 方法的过程中设置此值。如果需要将数据从一个版本迁移到另一个版本，则开发人员应该核实 <codeph>isFirstRun</codeph> 已设置为 <codeph>true</codeph>。
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/wasPendingUpdate"><linktext>wasPendingUpdate</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isInstallUpdateVisible:get"><apiName>isInstallUpdateVisible</apiName><shortdesc>
		使“安装更新”对话框可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		使“安装更新”对话框可见。设置为 <codeph>true</codeph> 时，updater 显示此对话框作为更新过程的一部分。在更新配置文件中也可以设置此属性。使用此属性设置的值优先于更新配置文件中的设置。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isNewerVersionFunction:get"><apiName>isNewerVersionFunction</apiName><shortdesc>
		updater 执行版本比较所应该使用的函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Function</apiValueClassifier></apiValueDef><apiDesc>
		updater 执行版本比较所应该使用的函数。默认情况下，更新框架进行版本比较，以检测远程站点的版本是否比所安装应用程序的版本新。但是，有时默认的比较并不符合开发人员的版本控制方案。设置此属性可提供进行比较的新函数。 
		
		<p>默认的比较函数接受类似 <i>x.y.z</i> 的版本，其中 x、y 和 z 可以包含字母和数字。默认的比较函数能够识别一些特殊情况。如果测试函数在版本字符串中找到<codeph>“alpha”</codeph>、<codeph>“beta”</codeph>或<codeph>“rc”</codeph>，则顺序为 <codeph>alpha</codeph> &lt; <codeph>beta</codeph> &lt; <codeph>rc</codeph>。</p>
		
		</apiDesc><example conref="examples\ApplicationUpdater.configurationFunction.1.as"> 以下代码定义 <codeph>appUpdate</codeph> updater 对象的自定义函数 <codeph>customFn</codeph>。我们特意将示例函数设计得很简单。自定义函数应根据版本控制方案规则返回一个布尔值。
<codeblock>
appUpdate.isNewerVersionFunction = customFn; 

function customFn (currentVersion:String, updateVersion:String):Boolean 
{
    return updateVersion > currentVersion;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isUnexpectedErrorVisible:get"><apiName>isUnexpectedErrorVisible</apiName><shortdesc>
		使“意外错误”对话框可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		使“意外错误”对话框可见。设置为 <codeph>true</codeph> 时，Application Updater 显示此对话框作为更新过程的一部分。在更新配置文件中也可以设置此属性。使用此属性设置的值优先于更新配置文件中的设置。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:isUpdateInProgress:get"><apiName>isUpdateInProgress</apiName><shortdesc>
		一个布尔型属性，更新正在运行时为 true，否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		一个布尔型属性，更新正在运行时为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:localeChain:get"><apiName>localeChain</apiName><shortdesc>
		定义用户界面所使用的语言环境链的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		定义用户界面所使用的语言环境链的数组。通常只有 JavaScript (HTML) 开发人员使用此属性。 
		
		<p>Flex 开发人员可以使用 ResourceManager 处理语言环境链。 </p>
		
		<p>默认情况下，在基于 HTML 的应用程序中，在 <codeph>Capabilities.languages</codeph> 数组中的那些语言与用户界面支持的十种语言之间对语言进行排序。如果未找到匹配项，则用户界面使用英语。 </p>
		
		<p>下面的 JavaScript 示例使用 AIR SDK 中所含的 AIR HTML 本地化框架。它根据语言列表对语言进行排序，然后将英语设置为默认的备用语言：</p>
		
		<codeblock> appUpdater.addResources("ro_RO", {titleCheck: "Titlu", msgCheck: "Mesaj", btnCheck: "Buton"});
		appUpdater.addResources("hu", {titleCheck: "C�m", msgCheck: "�zenet"}); 
		var languages = ["ro", "hu"];
		languages = languages.concat(air.Capabilities.languages);
		var sortedLanguages = air.Localizer.sortLanguagesByPreference(languages, air.Capabilities.language, "en-US");  
		sortedLanguages.push("en-US");
		appUpdater.localeChain = sortedLanguages;</codeblock>
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/addResources()"><linktext>addResources()</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdaterUI:previousApplicationStorageDirectory:get"><apiName>previousApplicationStorageDirectory</apiName><shortdesc>
		应用程序存储目录的原有位置（如果更新之后该目录发生过更改）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
		应用程序存储目录的原有位置（如果更新之后该目录发生过更改）。进行含证书迁移的升级之后，应用程序存储目录位置将发生更改。如果不进行证书迁移，则用户更新应用程序时，应用程序存储目录不会发生更改。且将此属性设置为 <codeph>null</codeph>。在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。 
		
		<p>如果开发人员用 ADT 打包 AIR 文件时使用 <codeph>-migrate</codeph> 选项，则该开发人员可以用新的证书为 AIR 应用程序的新版本签名。如果 AIR 应用程序的新版本使用新的签名证书，则用户安装新版本时，应用程序的本地存储目录将发生更改。使用此属性将数据从旧的应用程序存储目录转移到新的应用程序存储目录 (<codeph>File.applicationStorageDirectory</codeph>)。有关详细信息，请参阅《Adobe AIR 开发人员指南》中“使用命令行工具创建 AIR 应用程序”一章的“为 AIR 文件签名以更改应用程序证书”。</p>
		
		 </apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:previousVersion:get"><apiName>previousVersion</apiName><shortdesc>
		应用程序的原有版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		应用程序的原有版本。在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。返回升级之前应用程序的<i>原有版本</i>（仅当 <codeph>isfirstRun</codeph> 为 <codeph>true</codeph> 时设置）；否则将其设置为 <codeph>null</codeph>。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:updateDescriptor:get"><apiName>updateDescriptor</apiName><shortdesc>
		从更新 URL 下载的更新描述符文件的内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>XML</apiValueClassifier></apiValueDef><apiDesc>
		从更新 URL 下载的更新描述符文件的内容。只有在 updater 对象分派 <codeph>updateStatus</codeph> 事件之后，此属性才为非 null。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="air.update:ApplicationUpdaterUI:updateURL:get"><apiName>updateURL</apiName><shortdesc>
		更新描述符文件的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		更新描述符文件的位置。可以接受对 URLRequest 路径有效的任何位置。这是 updater 所需的唯一一个必要设置。可以通过此属性或通过配置文件来设置更新 URL。使用这两种方法设置此值后，updater 将使用以此属性设置的值。
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/configurationFile"><linktext>configurationFile</linktext></link></related-links></apiValue><apiValue id="air.update:ApplicationUpdaterUI:wasPendingUpdate:get"><apiName>wasPendingUpdate</apiName><shortdesc>
		是否有被推迟的更新（即使其未能安装），如果有，则为 (true)；否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
		是否有被推迟的更新（即使其未能安装），如果有，则为 (<codeph>true</codeph>)；否则为 <codeph>false</codeph>。updater 在调用 <codeph>initialize()</codeph> 方法的过程中设置此属性。使用 <codeph>wasPendingUpdate</codeph> 和 <codeph>isFirstRun</codeph> 属性检查更新是否未能安装（这种情况下 <codeph>wasPendingUpdate</codeph> 设置为 <codeph>true</codeph>，且 <codeph>isFirstRun</codeph> 设置为 <codeph>false</codeph>）。
		
		</apiDesc></apiValueDetail><related-links><link href="air.update.xml#ApplicationUpdaterUI/isFirstRun"><linktext>isFirstRun</linktext></link></related-links></apiValue></apiClassifier></apiPackage>