<?xml version="1.0"?>
<apiPackage id="flash.display"><apiName>flash.display</apiName><apiDetail/><apiClassifier id="flash.display:FrameLabel"><apiName>FrameLabel</apiName><shortdesc>
	
	FrameLabel 对象包含用来指定帧编号及相应标签名称的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	
	FrameLabel 对象包含用来指定帧编号及相应标签名称的属性。Scene 类包括 <codeph>labels</codeph> 属性，该属性是场景的 FrameLabel 对象的数组。 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Scene/labels"><linktext>Scene.labels</linktext></link><link href="flash.display.xml#MovieClip/currentLabel"><linktext>MovieClip.currentLabel</linktext></link><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:FrameLabel:frame:get"><apiName>frame</apiName><shortdesc>
		包含标签的帧编号。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		包含标签的帧编号。
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FrameLabel:name:get"><apiName>name</apiName><shortdesc>
		标签的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		标签的名称。
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
 InteractiveObject 类是用户可以使用鼠标和键盘与之交互的所有显示对象的抽象基类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 InteractiveObject 类是用户可以使用鼠标和键盘与之交互的所有显示对象的抽象基类。
 
 <p>不能直接实例化 InteractiveObject 类。调用 <codeph>new InteractiveObject()</codeph> 构造函数会引发 <codeph>ArgumentError</codeph> 异常。</p>
 
 <p>InteractiveObject 类本身不包含任何用于在屏幕上呈现内容的 API。鉴于此原因，如果要创建 InteractiveObject 类的一个自定义子类，您将需要扩展其中一个具有在屏幕上显示内容的 API 的子类，如 Sprite、SimpleButton、TextField 或 MovieClip 类。</p>
 
 </apiDesc><example conref="examples\InteractiveObjectExample.as"> 下例使用 <codeph>InteractiveObjectExample</codeph> 类，该类再使用 <codeph>ChildSprite</codeph> 类来绘制矩形，然后基于各种鼠标事件对该矩形进行操作。执行下列步骤可完成该任务：
 <ol>
    <li>在 <codeph>InteractiveObjectExample</codeph> 构造函数中，创建一个名为 <codeph>child</codeph> 的 Sprite 类型的 ChildSprite 新对象，该对象调用 ChildSprite 构造函数方法来绘制形状，并为所绘制的形状添加鼠标事件（如以下步骤所示）。<codeph>child</codeph> 对象添加至坐标 <i>x = 0, y = 0</i> 处的显示列表顶部。  </li>
 
    <li>在 <codeph>ChildSprite</codeph> 类中，声明以后在 <codeph>draw()</codeph> 方法和 MouseEvent 方法中使用的 <codeph>size</codeph> 和 <codeph>overSize</codeph> 属性。</li>
 
     <li>声明各个相关属性，将背景色设置为橙色，将鼠标经过颜色设置为深黄色，将鼠标按下颜色设置为浅蓝色。</li>
 
    <li>在 <codeph>ChildSprite</codeph> 构造函数中，通过使用 Graphics 类的方法和 <codeph>draw()</codeph> 方法绘制一个橙色的正方形。</li>
 
    <li>构造函数添加四个 MouseEvent 事件侦听器方法：
 
     <ul>
        <li><codeph>mouseOverHandler</codeph>：使用深黄色在原始坐标处重绘一个更大的 60 x 60 像素正方形。</li>
        <li><codeph>mouseOutHandler</codeph>：将正方形恢复至其原始大小和颜色。</li>
        <li><codeph>mouseDownHandler</codeph>：使用浅蓝色在原始坐标处重绘一个更大的 60 x 60 像素正方形。</li>
        <li><codeph>mouseUpHandler</codeph>：与 <codeph>mouseOverHandler</codeph> 相同。</li>
     </ul>
  </li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class InteractiveObjectExample extends Sprite {

        public function InteractiveObjectExample() {
            var child:Sprite = new ChildSprite();
            addChild(child);
        }
    }
}

import flash.display.Sprite;
import flash.events.MouseEvent;

class ChildSprite extends Sprite {
    private var size:uint = 50;
    private var overSize:uint = 60;
    private var backgroundColor:uint = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;

    public function ChildSprite() {
        buttonMode = true;
        draw(size, size, backgroundColor);
        addEventListener(MouseEvent.MOUSE_OVER, mouseOverHandler);
        addEventListener(MouseEvent.MOUSE_OUT, mouseOutHandler);
        addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
        addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
    }

    private function draw(w:uint, h:uint, bgColor:uint):void {
        graphics.clear();
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }

    public function mouseOverHandler(event:MouseEvent):void {
        trace("mouseOverHandler");
        draw(overSize, overSize, overColor);
    }

    public function mouseOutHandler(event:MouseEvent):void {
        trace("mouseOutHandler");
        draw(size, size, backgroundColor);
    }

    public function mouseDownHandler(event:MouseEvent):void {
        trace("mouseDownHandler");
        draw(overSize, overSize, downColor);
    }

    public function mouseUpHandler(event:MouseEvent):void {
        trace("mouseUpHandler");
        draw(overSize, overSize, overColor);
    }
}
</codeblock></example></apiClassifierDetail><adobeApiEvent id="flash.display:InteractiveObject_flash.events.TextEvent.TEXT_INPUT_textInput"><apiName>textInput</apiName><shortdesc>
 当用户输入一个或多个文本字符时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.TextEvent.TEXT_INPUT</apiEventType><adobeApiEventClassifier>flash.events.TextEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户输入一个或多个文本字符时分派。各种文本输入方法都可以生成此事件，包括使用标准键盘、输入法编辑器 (IME)、语音识别系统以及粘贴不带格式设置或样式信息的纯文本的操作。
 </apiDesc><example conref="examples\TextField_textInput.as"/></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CONTEXT_MENU_contextMenu"><apiName>contextMenu</apiName><shortdesc>
 当用户操作触发 AIR 应用程序中与此交互式对象相关联的上下文菜单时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CONTEXT_MENU</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户操作触发 AIR 应用程序中与此交互式对象相关联的上下文菜单时分派。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>contextMenu</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE_nativeDragComplete"><apiName>nativeDragComplete</apiName><shortdesc>
 当用户释放拖动动作时由拖动启动器 InteractiveObject 分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户释放拖动动作时由拖动启动器 InteractiveObject 分派。
 
 <p>该事件的 dropAction 属性指示由拖动目标对象设置的动作；“none”值 (<codeph>DragActions.NONE</codeph>) 指示放置动作被取消或未被接受。</p>
 
 <p><codeph>nativeDragComplete</codeph> 事件处理函数是更新启动显示对象的方便场所，例如，通过从列表中删除一个项目（针对“move”的拖动动作），或通过更改可视属性。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE_nativeDragUpdate"><apiName>nativeDragUpdate</apiName><shortdesc>
 在拖动操作期间由在 DragManager.doDrag() 调用中指定为拖动启动器的 InteractiveObject 分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_UPDATE</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在拖动操作期间由在 DragManager.doDrag() 调用中指定为拖动启动器的 InteractiveObject 分派。
 
 <p>Linux 中不分派 <codeph>nativeDragUpdate</codeph> 事件。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_START_nativeDragStart"><apiName>nativeDragStart</apiName><shortdesc>
 在拖动操作开始时由在 DragManager.doDrag() 调用中指定为拖动启动器的 InteractiveObject 分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_START</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在拖动操作开始时由在 DragManager.doDrag() 调用中指定为拖动启动器的 InteractiveObject 分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_EXIT_nativeDragExit"><apiName>nativeDragExit</apiName><shortdesc>
 当拖动动作离开其边界时由 InteractiveObject 分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_EXIT</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当拖动动作离开其边界时由 InteractiveObject 分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_DROP_nativeDragDrop"><apiName>nativeDragDrop</apiName><shortdesc>
 在将拖动对象放置到目标上且已通过对 DragManager.acceptDragDrop() 的调用接受该放置操作时，由目标 InteractiveObject 分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_DROP</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在将拖动对象放置到目标上且已通过对 DragManager.acceptDragDrop() 的调用接受该放置操作时，由目标 InteractiveObject 分派。
 
 <p>使用事件对象的 <codeph>clipboard</codeph> 属性访问放置的数据。</p>
 
 <p>此事件的处理函数应该设置 <codeph>DragManager.dropAction</codeph> 属性以向启动器提供有关采取了哪种拖动动作的反馈。如果未设置任何值，DragManager 将从允许动作的列表中选择一个默认值。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_OVER_nativeDragOver"><apiName>nativeDragOver</apiName><shortdesc>
 当拖动动作保持在其边界内时，由 InteractiveObject 持续分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_OVER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当拖动动作保持在其边界内时，由 InteractiveObject 持续分派。
 
 <p>鼠标只要移动，就会分派 <codeph>nativeDragOver</codeph> 事件。在 Windows 和 Mac 中，即使不移动鼠标，每隔一小段时间也会分派这些事件。</p>
 
 <p>处理 <codeph>nativeDragOver</codeph> 或 <codeph>nativeDragEnter</codeph> 事件以允许显示对象成为放置目标。</p> 
 
 <p>要确定执行分派的显示对象是否能接受放置，请检查该事件对象的 <codeph>clipboard</codeph> 属性中数据的适用性，并检查 <codeph>allowedActions</codeph> 属性中允许的拖动动作。</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.NativeDragEvent.NATIVE_DRAG_ENTER_nativeDragEnter"><apiName>nativeDragEnter</apiName><shortdesc>
 当拖动动作进入其边界时由 InteractiveObject 分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeDragEvent.NATIVE_DRAG_ENTER</apiEventType><adobeApiEventClassifier>flash.events.NativeDragEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当拖动动作进入其边界时由 InteractiveObject 分派。
 
 <p>处理 <codeph>nativeDragEnter</codeph> 或 <codeph>nativeDragOver</codeph> 事件以允许显示对象成为放置目标。</p>
 
 <p>要确定执行分派的显示对象是否能接受放置，请检查该事件对象的 <codeph>clipboard</codeph> 属性中数据的适用性，并检查 <codeph>allowedActions</codeph> 属性中允许的拖动动作。</p> 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_INDEX_CHANGE_tabIndexChange"><apiName>tabIndexChange</apiName><shortdesc>
 对象的 tabIndex 属性值发生更改时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_INDEX_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 对象的 <codeph>tabIndex</codeph> 属性值发生更改时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_ENABLED_CHANGE_tabEnabledChange"><apiName>tabEnabledChange</apiName><shortdesc>
 对象的 tabEnabled 标志发生更改时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_ENABLED_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 对象的 <codeph>tabEnabled</codeph> 标志发生更改时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.TAB_CHILDREN_CHANGE_tabChildrenChange"><apiName>tabChildrenChange</apiName><shortdesc>
 对象的 tabChildren 标志值发生更改时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.TAB_CHILDREN_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 对象的 <codeph>tabChildren</codeph> 标志值发生更改时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_UP_keyUp"><apiName>keyUp</apiName><shortdesc>
 用户释放某个键时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_UP</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户释放某个键时分派。按键与特定字符之间的映射因设备和操作系统而异。此事件类型是在此类映射发生之后、输入法编辑器 (IME) 处理之前生成的。IME 用于输入标准 QWERTY 键盘无法生成的字符（如中国象形文字）。该事件在 <codeph>keyDown</codeph> 事件之后发生，并具备以下特征：
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.KeyboardEvent.KEY_DOWN_keyDown"><apiName>keyDown</apiName><shortdesc>
 用户按下某个键时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.KeyboardEvent.KEY_DOWN</apiEventType><adobeApiEventClassifier>flash.events.KeyboardEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户按下某个键时分派。按键与特定字符之间的映射因设备和操作系统而异。此事件类型是在此类映射发生之后、输入法编辑器 (IME) 处理之前生成的。IME 用于输入标准 QWERTY 键盘无法生成的字符（如中国象形文字）。该事件在 <codeph>keyUp</codeph> 事件之前发生。
 
 <p>在 AIR 中，取消此事件会禁止将字符输入到文本字段中。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_UP_rightMouseUp"><apiName>rightMouseUp</apiName><shortdesc>
 当用户在 InteractiveObject 实例上释放指针设备按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在 InteractiveObject 实例上释放指针设备按钮时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_MOUSE_DOWN_rightMouseDown"><apiName>rightMouseDown</apiName><shortdesc>
 当用户在 InteractiveObject 实例上按下指针设备按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在 InteractiveObject 实例上按下指针设备按钮时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.RIGHT_CLICK_rightClick"><apiName>rightClick</apiName><shortdesc>
 当用户在同一 InteractiveObject 上按下并释放用户指针设备的右按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.RIGHT_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在同一 InteractiveObject 上按下并释放用户指针设备的右按钮时分派。要使 <codeph>rightClick</codeph> 事件发生，该事件必须始终按照发生顺序跟在以下一系列事件之后：<codeph>rightMouseDown</codeph> 事件，然后是 <codeph>rightMouseUp</codeph>。这两个事件的目标对象必须相同，否则不会发生 <codeph>rightClick</codeph> 事件。在 <codeph>rightMouseDown</codeph> 或 <codeph>rightMouseUp</codeph> 事件之间可以随时发生任意数量的其它鼠标事件；<codeph>rightClick</codeph> 事件仍会发生。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_UP_middleMouseUp"><apiName>middleMouseUp</apiName><shortdesc>
 当用户在 InteractiveObject 实例上释放指针设备按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在 InteractiveObject 实例上释放指针设备按钮时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_MOUSE_DOWN_middleMouseDown"><apiName>middleMouseDown</apiName><shortdesc>
 当用户在 InteractiveObject 实例上按下指针设备的中间按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在 InteractiveObject 实例上按下指针设备的中间按钮时分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MIDDLE_CLICK_middleClick"><apiName>middleClick</apiName><shortdesc>
 当用户在同一 InteractiveObject 上按下并释放用户指针设备的中间按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MIDDLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在同一 InteractiveObject 上按下并释放用户指针设备的中间按钮时分派。要使 <codeph>middleClick</codeph> 事件发生，该事件必须始终按照发生顺序跟在以下一系列事件之后：<codeph>middleMouseDown</codeph> 事件，然后是 <codeph>middleMouseUp</codeph>。这两个事件的目标对象必须相同，否则不会发生 <codeph>middleClick</codeph> 事件。在 <codeph>middleMouseDown</codeph> 或 <codeph>middleMouseUp</codeph> 事件之间可以随时发生任意数量的其它鼠标事件；<codeph>middleClick</codeph> 事件仍会发生。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OVER_rollOver"><apiName>rollOver</apiName><shortdesc>
 用户将指针设备移动到 InteractiveObject 实例上时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户将指针设备移动到 InteractiveObject 实例上时分派。事件目标为指针设备下的对象或该对象的父级。<codeph>relatedObject</codeph> 是以前在指针设备下的对象。在该对象的父级链以下连续分派 <codeph>rollOver</codeph> 事件，以除 <codeph>relatedObject</codeph> 的根或始祖之外的最高级别的父级开头，并以该对象结束。
 <p><codeph>rollOver</codeph> 事件的目的是简化带有子级的显示对象容器的移开行为的编码。当鼠标进入某个显示对象区域或者从其子级以外的对象进入任何其子级区域时，该显示对象将分派 <codeph>rollOver</codeph> 事件。这种行为与 <codeph>mouseOver</codeph> 事件的行为不同，每次鼠标进入显示对象容器的任何子对象区域时都会分派此事件，即使鼠标已在显示对象容器的另一个子对象上也是如此。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.ROLL_OUT_rollOut"><apiName>rollOut</apiName><shortdesc>
 用户将指针设备从 InteractiveObject 实例上移开时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.ROLL_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户将指针设备从 InteractiveObject 实例上移开时分派。事件目标是指先前在指针设备下的对象或该对象的父级。<codeph>relatedObject</codeph> 是将指针设备向其移动的对象。在该对象的父级链以上连续分派 <codeph>rollOut</codeph> 事件，以该对象为开头，并以除 <codeph>relatedObject</codeph> 的根或始祖之外的最高级别的父级结束。 
 <p><codeph>rollOut</codeph> 事件的目的是简化带有子级的显示对象容器的移开行为的编码。当鼠标离开显示对象区域或任何其子级区域并转到除其子级以外的对象时，显示对象分派 <codeph>rollOut</codeph> 事件。这是与 <codeph>mouseOut</codeph> 事件行为不同的行为，因为该事件是在每次鼠标离开显示对象容器的任何子对象区域时才会被分派，即使鼠标仍保留在显示对象容器的另一个子对象上也是如此。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_WHEEL_mouseWheel"><apiName>mouseWheel</apiName><shortdesc>
 当鼠标滚轮滚动到 InteractiveObject 实例上时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_WHEEL</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当鼠标滚轮滚动到 InteractiveObject 实例上时分派。如果目标为文本字段，则作为默认行为，该文本会滚动。仅在 Microsoft Windows 操作系统中提供。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_UP_mouseUp"><apiName>mouseUp</apiName><shortdesc>
 当用户在 InteractiveObject 实例上释放指针设备按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_UP</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在 InteractiveObject 实例上释放指针设备按钮时分派。如果目标为 SimpleButton 实例，该对象会显示 <codeph>upState</codeph> 显示对象。如果目标为可选文本字段，则作为默认行为，该文本字段会结束选择。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OVER_mouseOver"><apiName>mouseOver</apiName><shortdesc>
 用户将指针设备移动到 InteractiveObject 实例上时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OVER</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户将指针设备移动到 InteractiveObject 实例上时分派。<codeph>relatedObject</codeph> 是以前在指针设备下的对象。如果目标为 SimpleButton 实例，作为默认行为，该对象会根据是否按下鼠标按键而显示 <codeph>overState</codeph> 或 <codeph>upState</codeph> 显示对象。
 <p>每次鼠标进入显示对象容器的任何子对象区域时都会分派 <codeph>mouseOver</codeph> 事件，即使鼠标已在显示对象容器的另一个子对象上也是如此。此行为不同于 <codeph>rollOver</codeph> 事件的用途，此事件用于简化带有子级的显示对象容器的移出行为的编码。当鼠标进入某个显示对象区域或者从其子级以外的对象进入任何其子级区域时，该显示对象将分派 <codeph>rollOver</codeph> 事件。<codeph>rollOver</codeph> 事件是沿该对象的父级链向下连续分派的，从 <codeph>relatedObject</codeph> 的根或始祖之外的最高父级开始，并以该对象结束。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_OUT_mouseOut"><apiName>mouseOut</apiName><shortdesc>
 用户将指针设备从 InteractiveObject 实例上移开时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_OUT</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户将指针设备从 InteractiveObject 实例上移开时分派。事件目标是指先前在指针设备下的对象。<codeph>relatedObject</codeph> 是将指针设备向其移动的对象。如果目标为 SimpleButton 实例，作为默认行为，该按钮会显示 <codeph>upState</codeph> 显示对象。
 <p>每次鼠标离开显示对象容器的任何子对象区域时都会分派 <codeph>mouseOut</codeph> 事件，即使鼠标停留在显示对象容器的另一个子对象上也是如此。此行为不同于 <codeph>rollOut</codeph> 事件的用途，此事件用于简化带有子级的显示对象容器的滑过行为的编码。当鼠标离开某个显示对象区域或任何其子级区域以转到其子级以外的对象时，该显示对象将分派 <codeph>rollOut</codeph> 事件。<codeph>rollOut</codeph> 事件是沿该对象的父级链向上连续分派的，从该对象开始，并以 <codeph>relatedObject</codeph> 的根或始祖之外的最高父级结束。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_MOVE_mouseMove"><apiName>mouseMove</apiName><shortdesc>
 用户移动 InteractiveObject 上的指针设备时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_MOVE</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户移动 InteractiveObject 上的指针设备时分派。如果目标为用户正在选择的文本字段，则作为默认行为，会更新选择。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.MOUSE_DOWN_mouseDown"><apiName>mouseDown</apiName><shortdesc>
 当用户在 InteractiveObject 实例上按下指针设备按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.MOUSE_DOWN</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户在 InteractiveObject 实例上按下指针设备按钮时分派。如果目标为 SimpleButton 实例，作为默认行为，SimpleButton 实例会显示 <codeph>downState</codeph> 显示对象。如果目标为可选文本字段，作为默认行为，该文本字段会开始选择。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.DOUBLE_CLICK_doubleClick"><apiName>doubleClick</apiName><shortdesc>
 如果 InteractiveObject 的 doubleClickEnabled 标志设置为 true，当用户在该对象上快速连续按下两次并释放指针设备的主按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.DOUBLE_CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 如果 InteractiveObject 的 <codeph>doubleClickEnabled</codeph> 标志设置为 <codeph>true</codeph>，当用户在该对象上快速连续按下两次并释放指针设备的主按钮时分派。要使 <codeph>doubleClick</codeph> 事件发生，它必在以下一系列事件后面：<codeph>mouseDown</codeph>、<codeph>mouseUp</codeph>、<codeph>click</codeph>、<codeph>mouseDown</codeph>、<codeph>mouseUp</codeph>。所有这些事件必须共享与 <codeph>doubleClick</codeph> 事件相同的目标。第二个 <codeph>mouseDown</codeph> 和 <codeph>mouseUp</codeph> 事件代表第二次单击，该行为必须在 <codeph>click</codeph> 事件之后的指定时间段内发生。该时间段的允许长度因操作系统而异，而且通常可由用户配置。如果目标为可选文本字段，作为默认行为，会选择指针下面的单词。如果目标 InteractiveObject 未将其 <codeph>doubleClickEnabled</codeph> 标志设置为 <codeph>true</codeph>，它将接收两个 <codeph>click</codeph> 事件。  
 
 <p><codeph>doubleClickEnabled</codeph> 属性默认为 <codeph>false</codeph>。  </p>
 
 <p>TextField 对象的双击文本选择行为与 <codeph>doubleClick</codeph> 事件无关。使用 <codeph>TextField.doubleClickEnabled</codeph> 控制 TextField 选择。</p>
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#InteractiveObject/doubleClickEnabled"><linktext>doubleClickEnabled</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.MouseEvent.CLICK_click"><apiName>click</apiName><shortdesc>
 用户在同一 InteractiveObject 上按下并释放用户指针设备的主按钮时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.MouseEvent.CLICK</apiEventType><adobeApiEventClassifier>flash.events.MouseEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户在同一 InteractiveObject 上按下并释放用户指针设备的主按钮时分派。要使单击事件发生，它必须始终在以下顺序的一系列事件后面：mouseDown 事件，然后是 mouseUp 事件。这两个事件的目标对象必须相同，否则不会发生 <codeph>click</codeph> 事件。<codeph>mouseDown</codeph> 或 <codeph>mouseUp</codeph> 事件之间的任何时间都会发生任何数量的其它鼠标事件；<codeph>click</codeph> 事件仍会发生。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.MOUSE_FOCUS_CHANGE_mouseFocusChange"><apiName>mouseFocusChange</apiName><shortdesc>
 用户尝试使用指针设备更改焦点时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.MOUSE_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户尝试使用指针设备更改焦点时分派。此事件的默认行为是更改焦点并分派相应的 <codeph>focusIn</codeph> 和 <codeph>focusOut</codeph> 事件。 
 
 <p>将此事件分派到当前具有焦点的对象。如果您没有禁止默认行为，则此事件的相关对象为接收焦点的 InteractiveObject 实例。可以通过调用正确注册到目标对象的事件侦听器中的 <codeph>preventDefault()</codeph> 来防止更改焦点。未使用 <codeph>shiftKey</codeph> 属性。默认情况下分派焦点更改和 <codeph>focusIn</codeph> 及 <codeph>focusOut</codeph> 事件。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.KEY_FOCUS_CHANGE_keyFocusChange"><apiName>keyFocusChange</apiName><shortdesc>
 用户尝试使用键盘导航更改焦点时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.KEY_FOCUS_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 用户尝试使用键盘导航更改焦点时分派。此事件的默认行为是更改焦点并分派相应的 <codeph>focusIn</codeph> 和 <codeph>focusOut</codeph> 事件。
 
 <p>将此事件分派到当前具有焦点的对象。如果您没有禁止默认行为，则此事件的相关对象为接收焦点的 InteractiveObject 实例。可以通过调用正确注册到目标对象的事件侦听器中的 <codeph>preventDefault()</codeph> 方法来防止更改焦点。默认情况下分派焦点更改和 <codeph>focusIn</codeph> 及 <codeph>focusOut</codeph> 事件。</p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_OUT_focusOut"><apiName>focusOut</apiName><shortdesc>
 显示对象失去焦点后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_OUT</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 显示对象失去焦点<i>后</i>分派。这种情况会在用户使用指针设备或键盘导航加亮显示不同的对象时发生。失去焦点的对象称为该事件的目标对象，而接收焦点的相应 InteractiveObject 实例称为相关对象。对相关对象的引用存储在目标对象的 <codeph>relatedObject</codeph> 属性中。未使用 <codeph>shiftKey</codeph> 属性。该事件在相关对象分派 <codeph>focusIn</codeph> 事件之前发生。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.FocusEvent.FOCUS_IN_focusIn"><apiName>focusIn</apiName><shortdesc>
 显示对象获得焦点后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FocusEvent.FOCUS_IN</apiEventType><adobeApiEventClassifier>flash.events.FocusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 显示对象获得焦点<i>后</i>分派。这种情况会在用户使用指针设备或键盘导航加亮显示对象时发生。该焦点的接收方称为该事件的目标对象，而因该更改而失去焦点的相应 InteractiveObject 实例称为相关对象。对相关对象的引用存储在接收对象的 <codeph>relatedObject</codeph> 属性中。未使用 <codeph>shiftKey</codeph> 属性。在该事件在分派前一个对象的 <codeph>focusOut</codeph> 事件之后发生。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.SELECT_ALL_selectAll"><apiName>selectAll</apiName><shortdesc>
 当用户激活特定于平台的全选操作的快捷键组合或从文本上下文菜单中选择“全选”时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT_ALL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户激活特定于平台的全选操作的快捷键组合或从文本上下文菜单中选择“全选”时分派。将此事件分派到当前具有焦点的对象。如果当前具有焦点的对象是一个 TextField，则此事件的默认行为是使该文本字段的所有内容处于选定状态。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.PASTE_paste"><apiName>paste</apiName><shortdesc>
 当用户激活特定于平台的粘贴操作的快捷键组合或从文本上下文菜单中选择“粘贴”时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.PASTE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户激活特定于平台的粘贴操作的快捷键组合或从文本上下文菜单中选择“粘贴”时分派。将此事件分派到当前具有焦点的对象。如果当前具有焦点的对象是一个 TextField，则此事件的默认行为是将剪贴板的所有内容粘贴到该文本字段的当前插入点，替换文本字段中当前选定的所有文本。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CUT_cut"><apiName>cut</apiName><shortdesc>
 当用户激活特定于平台的剪切操作的快捷键组合或从文本上下文菜单中选择“剪切”时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CUT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户激活特定于平台的剪切操作的快捷键组合或从文本上下文菜单中选择“剪切”时分派。将此事件分派到当前具有焦点的对象。如果当前具有焦点的对象是一个 TextField，则此事件的默认行为是将该文本字段中当前选定的所有文本剪切到剪贴板。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.COPY_copy"><apiName>copy</apiName><shortdesc>
 当用户激活特定于平台的复制操作的快捷键组合或从文本上下文菜单中选择“复制”时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COPY</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户激活特定于平台的复制操作的快捷键组合或从文本上下文菜单中选择“复制”时分派。将此事件分派到当前具有焦点的对象。如果当前具有焦点的对象是一个 TextField，则此事件的默认行为是将该文本字段中当前选定的所有文本复制到剪贴板。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:InteractiveObject_flash.events.Event.CLEAR_clear"><apiName>clear</apiName><shortdesc>
 当用户从文本上下文菜单中选择“清除”（或“删除”）时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLEAR</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户从文本上下文菜单中选择“清除”（或“删除”）时分派。将此事件分派到当前具有焦点的对象。如果当前具有焦点的对象是一个 TextField，则此事件的默认行为是删除该文本字段中当前选定的所有文本。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:InteractiveObject:InteractiveObject"><apiName>InteractiveObject</apiName><shortdesc>
	调用新的 InteractiveObject() 构造函数会引发 ArgumentError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	调用 <codeph>new InteractiveObject()</codeph> 构造函数会引发 <codeph>ArgumentError</codeph> 异常。但是，可以调用以下 InteractiveObject 的子类的构造函数：
	
	<ul>
	
		<li><codeph>new SimpleButton()</codeph></li>
		<li><codeph>new TextField()</codeph></li>
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:InteractiveObject:contextMenu:get"><apiName>contextMenu</apiName><shortdesc> 
	 指定与此对象相关联的上下文菜单。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier><apiTipTexts><apiTipText>与此对象相关联的上下文菜单。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 指定与此对象相关联的上下文菜单。
	 
	 <p>对于在 Flash Player 中运行的内容，此属性是一个 ContextMenu 对象。在 AIR 运行时中，ContextMenu 类扩展 NativeMenu 类，但 Flash Player 只支持 ContextMenu 类，不支持 NativeMenu 类。
	 </p>
	 
	 <p><b>注意：</b>TextField 对象的上下文菜单中始终包含剪贴板菜单。剪贴板菜单包含“剪切”、“复制”、“粘贴”、“清除”和“全选”命令。您不能从 TextField 对象的上下文菜单中删除这些命令。对于 TextField 对象，选择这些命令（或等效键盘命令）不会生成 <codeph>clear</codeph>、<codeph>copy</codeph>、<codeph>cut</codeph>、<codeph>paste</codeph> 或 <codeph>selectAll</codeph> 事件。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:doubleClickEnabled:get"><apiName>doubleClickEnabled</apiName><shortdesc> 
	 指定此对象是否接收 doubleClick 事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>该对象是否接收双击消息。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 指定此对象是否接收 <codeph>doubleClick</codeph> 事件。默认值为 <codeph>false</codeph>，这意味着在默认情况下，InteractiveObject 实例不接收 <codeph>doubleClick</codeph> 事件。如果将 <codeph>doubleClickEnabled</codeph> 属性设置为 <codeph>true</codeph>，实例在其范围内接收 <codeph>doubleClick</codeph> 事件。InteractiveObject 实例的 <codeph>mouseEnabled</codeph> 属性也必须设置为 <codeph>true</codeph>，以便对象能够接收 <codeph>doubleClick</codeph> 事件。
	 
	 <p>设置此属性不会分派任何事件。必须使用 <codeph>addEventListener()</codeph> 方法为 <codeph>doubleClick</codeph> 事件添加事件侦听器。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InteractiveObject/event:doubleClick"><linktext>doubleClick</linktext></link><link href="flash.display.xml#InteractiveObject/mouseEnabled"><linktext>mouseEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:focusRect:get"><apiName>focusRect</apiName><shortdesc> 
	 指定此对象是否显示焦点矩形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip._focusRect, Button._focusRect, and 
	 _focusRect (global property) topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc> 
	 指定此对象是否显示焦点矩形。它可以采用三个值中的一个：<codeph>true</codeph>、<codeph>false</codeph> 或 <codeph>null</codeph>。<codeph>true</codeph> 和 <codeph>false</codeph> 值按预期工作，指定是否显示焦点矩形。<codeph>null</codeph> 值指示此对象遵循舞台的 <codeph>stageFocusRect</codeph> 属性。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:mouseEnabled:get"><apiName>mouseEnabled</apiName><shortdesc> 
	 指定此对象是否接收鼠标消息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
	 指定此对象是否接收鼠标消息。默认值为 <codeph>true</codeph>，这意味着在默认情况下，显示列表上的任何 InteractiveObject 实例均接收鼠标事件。如果将 <codeph>mouseEnabled</codeph> 设置为 <codeph>false</codeph>，实例不接收任何鼠标事件。显示列表上的该实例的任何子级都不会受到影响。要更改显示列表上对象的所有子级的 <codeph>mouseEnabled</codeph> 行为，请使用 <codeph>flash.display.DisplayObjectContainer.mouseChildren</codeph>。
	 <p> 设置此属性不会分派任何事件。您必须使用 <codeph>addEventListener()</codeph> 方法才能创建交互式功能。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>flash.display.DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:InteractiveObject:tabEnabled:get"><apiName>tabEnabled</apiName><shortdesc> 
	 指定此对象是否遵循 Tab 键顺序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>FP IMD: See the AS2 MovieClip.tabEnabled, Button.tabEnabled, and 
	 TextField.tabEnabled topics for information to migrate to the ASDoc description of this 
	 AS3 property.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>该对象是否遵循 Tab 键顺序。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
	 指定此对象是否遵循 Tab 键顺序。如果该对象遵循 Tab 键顺序，值为 <codeph>true</codeph>；否则值为 <codeph>false</codeph>。默认情况下，值为 <codeph>false</codeph>，但以下情况除外：
     <ul><li>对于 SimpleButton 对象，值为 <codeph>true</codeph>。</li>
     <li>对于具有 <codeph>type = "input"</codeph> 的 TextField 对象，值为 <codeph>true</codeph>。</li>
     <li>对于具有 <codeph>buttonMode = true</codeph> 的 Sprite 对象或 MovieClip 对象，值为 <codeph>true</codeph>。</li></ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:InteractiveObject:tabIndex:get"><apiName>tabIndex</apiName><shortdesc> 
   	 指定 SWF 文件中的对象按 Tab 键顺序排列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiTipTexts><apiTipText>该对象的 Tab 键索引。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc> 
   	 指定 SWF 文件中的对象按 Tab 键顺序排列。默认情况下，<codeph>tabIndex</codeph> 属性为 -1，这意味着没有为该对象设置任何 Tab 索引。
	 
   	 <p>如果 SWF 文件中当前显示的任何对象包含 <codeph>tabIndex</codeph> 属性，则禁用 Tab 键自动排序，而使用该 SWF 文件中对象的 <codeph>tabIndex</codeph> 属性来计算 Tab 键顺序。这个自定义的 Tab 键排序仅包括指定了 <codeph>tabIndex</codeph> 属性的对象。</p>
	 
   	 <p><codeph>tabIndex</codeph> 属性可以是非负整数。这些对象按照其 <codeph>tabIndex</codeph> 属性按升序进行排序。<codeph>tabIndex</codeph> 值为 1 的对象在 <codeph>tabIndex</codeph> 值为 2 的对象的前面。不要对多个对象使用相同的 <codeph>tabIndex</codeph> 值。</p>
	 
	 <p>由 <codeph>tabIndex</codeph> 属性定义的自定义 Tab 键顺序为<i>平构</i>。这意味着不考虑 SWF 文件中对象的层次结构关系。SWF 文件中具有 <codeph>tabIndex</codeph> 属性的所有对象都排入 Tab 键顺序中，而 Tab 键顺序由 <codeph>tabIndex</codeph> 值的顺序确定。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
 定义有序的一组三角形，可以使用 (u,v) 填充坐标或普通填充来呈现这些三角形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义有序的一组三角形，可以使用 (u,v) 填充坐标或普通填充来呈现这些三角形。路径中的每个三角形都由三组 (x, y) 坐标表示，其中每组坐标都是三角形的一个点。
 
 <p>
 三角形顶点不包含 z 坐标，并且不一定表示 3D 面。但是，可以使用三角形路径来支持在 2D 空间中呈现 3D 几何图形。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTriangles()"><linktext>flash.display.Graphics.drawTriangles()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsTrianglePath:GraphicsTrianglePath"><apiName>GraphicsTrianglePath</apiName><shortdesc>
     创建新的 GraphicsTrianglePath 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>由数字构成的矢量，其中的每一对数字将被视为一个点（一个 x, y 对）。必需。
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>一个由整数或索引构成的矢量，其中每三个索引定义一个三角形。 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>由用于应用纹理映射的标准坐标构成的矢量。
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>指定是否呈现面向给定方向的三角形。用于防止呈现在当前视图中看不见的三角形。可设置为由 TriangleCulling 类定义的任何值。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的 GraphicsTrianglePath 对象。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsTrianglePath/culling"><linktext>culling</linktext></link><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsTrianglePath:indices"><apiName>indices</apiName><shortdesc>
     一个由整数或索引构成的矢量，其中每三个索引定义一个三角形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     一个由整数或索引构成的矢量，其中每三个索引定义一个三角形。如果 indexes 参数为 null，则每三个顶点（vertices 矢量中的 6 对 x,y）定义一个三角形。否则，每个索引将引用一个顶点，即 vertices 矢量中的一对数字。例如，<codeph>indexes[1]</codeph> 引用 (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>)。 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:uvtData"><apiName>uvtData</apiName><shortdesc>
     由用于应用纹理映射的标准坐标构成的矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     由用于应用纹理映射的标准坐标构成的矢量。每个坐标引用用于填充的位图上的一个点。每个顶点必须具有一个 UV 或一个 UVT 坐标。
     
     <p>
     对于 UV 坐标，(0,0) 是位图的左上角，(1,1) 是位图的右下角。 
     </p>
                    
     <p>
     如果此矢量的长度是 <codeph>vertices</codeph> 矢量长度的两倍，则使用标准坐标而不进行透视校正。
     </p>
     
     <p>
     如果此矢量的长度是 <codeph>vertices</codeph> 矢量长度的三倍，则将第三个坐标解释为“t”，即在视角空间中从视点到纹理的距离。这有助于呈现引擎在 3D 中映射纹理时正确应用透视。
     </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:vertices"><apiName>vertices</apiName><shortdesc>
     由数字构成的矢量，其中的每一对数字将被视为一个点（一个 x, y 对）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     由数字构成的矢量，其中的每一对数字将被视为一个点（一个 x, y 对）。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsTrianglePath:culling:get"><apiName>culling</apiName><shortdesc>
     指定是否呈现面向给定方向的三角形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     指定是否呈现面向给定方向的三角形。用于防止呈现在当前视图中看不见的三角形。 
     <p>
     可设置为由 TriangleCulling 类定义的任何值。
     </p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObject"><apiName>DisplayObject</apiName><shortdesc>
 DisplayObject 类是可放在显示列表中的所有对象的基类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 DisplayObject 类是可放在显示列表中的所有对象的基类。该显示列表管理在 Flash Player 或 Adobe AIR 中显示的所有对象。使用 DisplayObjectContainer 类排列显示列表中的显示对象。DisplayObjectContainer 对象可以有子显示对象，而其它显示对象（如 Shape 和 TextField 对象）是“叶”节点，只有父级和同级，没有子级。 
 
 <p>DisplayObject 类支持基本功能（如对象的 <i>x</i> 和 <i>y</i> 位置），也支持更高级的对象属性（如它的转换矩阵）。 
 </p>
 
 <p>DisplayObject 是一种抽象基类；因此，不能直接调用 DisplayObject。调用 <codeph>new DisplayObject()</codeph> 会引发 <codeph>ArgumentError</codeph> 异常。 </p>
 
 <p>所有显示对象都继承自 DisplayObject 类。</p>
 
 <p>DisplayObject 类本身不包含任何用于在屏幕上呈现内容的 API。因此，如果要创建 DisplayObject 类的自定义子类，您将需要扩展其中一个具有在屏幕上呈现内容的 API 的子类，如 Shape、Sprite、Bitmap、SimpleButton、TextField 或 MovieClip 类。</p>
 
 <p>DisplayObject 类包含若干广播事件。通常，任何特定事件的目标均为一个特定的 DisplayObject 实例。例如，<codeph>added</codeph> 事件的目标是已添加到显示列表的特定 DisplayObject 实例。若只有一个目标，则会将事件侦听器限制为只能放置到该目标上（在某些情况下，可放置到显示列表中该目标的始祖上）。但是，对于广播事件，目标不是特定的 DisplayObject 实例，而是所有 DisplayObject 实例（包括那些不在显示列表中的实例）。这意味着您可以向任何 DisplayObject 实例添加侦听器来侦听广播事件。除了 DisplayObject 类的 Events 表中列出的广播事件，DisplayObject 类还从 EventDispatcher 类继承如下两个广播事件：<codeph>activate</codeph> 和 <codeph>deactivate</codeph>。</p>
 
 <p>一些以前在 ActionScript 1.0 和 2.0 MovieClip、TextField 和 Button 类中使用的属性（如 <codeph>_alpha</codeph>、<codeph>_height</codeph>、<codeph>_name</codeph>、<codeph>_width</codeph>、<codeph>_x</codeph>、<codeph>_y</codeph> 等）在 ActionScript 3.0 DisplayObject 类中有等效属性，但它们已被重命名，因此不再以下划线 (_) 字符开头。</p>
 
 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“显示编程”一章。</p>
 
 </apiDesc><example conref="examples\DisplayObjectExample.as"> 下例使用 <codeph>DisplayObjectExample</codeph> 类在舞台的角上绘制了一个橙色的正方形，然后通过显示每个事件的文本信息对事件作出响应。执行下列步骤可完成该任务：
 <ol>
    <li>声明用于正方形的颜色和大小的类属性。</li>
     <li>构造函数调用 <codeph>draw()</codeph> 方法，在舞台上的默认坐标处 (<i>x = 0, y = 0</i>) 绘制一个橙色的正方形。</li>
    <li>将以下事件侦听器方法附加到该正方形：
     <ul>
        <li><codeph>addedHandler()</codeph> 侦听 <codeph>added</codeph> 事件，该事件在将正方形添加到显示列表中时分派。</li>
        <li><codeph>enterFrameHandler()</codeph> 侦听 <codeph>enterFrame</codeph> 事件，它在本示例中没有实际意义。</li>
        <li><codeph>removedHandler()</codeph> 侦听 <codeph>removed</codeph> 事件，该事件在将正方形从显示列表中删除（单击该正方形时会发生此情况）时分派。</li>
        <li><codeph>clickHandler()</codeph> 侦听 <codeph>click</codeph> 事件，该事件在单击该橙色正方形时分派。</li>
        <li><codeph>renderHandler()</codeph> 在显示列表更新之后侦听 <codeph>render</codeph> 事件。</li>
  </ul></li>
 </ol>
<codeblock>

package {
    import flash.display.Sprite;

    public class DisplayObjectExample extends Sprite {
        public function DisplayObjectExample() {
            var child:CustomDisplayObject = new CustomDisplayObject();
            addChild(child);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.*;

class CustomDisplayObject extends Sprite {
    private var bgColor:uint = 0xFFCC00;
    private var size:uint    = 80;

    public function CustomDisplayObject() {
        draw();
        addEventListener(Event.ADDED, addedHandler);
        addEventListener(Event.ENTER_FRAME, enterFrameHandler);
        addEventListener(Event.REMOVED, removedHandler);
        addEventListener(MouseEvent.CLICK, clickHandler);
        addEventListener(Event.RENDER, renderHandler);
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }

    private function clickHandler(event:MouseEvent):void {
        trace("clickHandler: " + event);
        parent.removeChild(this);
    }

    private function addedHandler(event:Event):void {
        trace("addedHandler: " + event);
        stage.scaleMode = StageScaleMode.NO_SCALE;
        stage.align = StageAlign.TOP_LEFT;
        stage.addEventListener("resize", resizeHandler);
    }

    private function enterFrameHandler(event:Event):void {
        trace("enterFrameHandler: " + event);
        removeEventListener("enterFrame", enterFrameHandler);
    }

    private function removedHandler(event:Event):void {
        trace("removedHandler: " + event);
        stage.removeEventListener("resize", resizeHandler);
    }

    private function renderHandler(event:Event):void {
        trace("renderHandler: " + event);
    }

    private function resizeHandler(event:Event):void {
        trace("resizeHandler: " + event);
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObjectContainer"><linktext>flash.display.DisplayObjectContainer</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.RENDER_render"><apiName>render</apiName><shortdesc>
 [广播事件] 将要更新和呈现显示列表时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RENDER</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [广播事件] 将要更新和呈现显示列表时分派。此事件为侦听此事件的对象在呈现显示列表之前进行更改提供了最后的机会。每次希望分派 <codeph>render</codeph> 事件时，必须调用 Stage 对象的 <codeph>invalidate()</codeph> 方法。只有当 <codeph>Render</codeph> 事件与调用 <codeph>Stage.invalidate()</codeph> 的对象互相信任时，才会将这些事件分派给某个对象。此事件为广播事件，这意味着具有注册了此事件的侦听器的所有显示对象都会分派此事件。
 
 <p><b>注意：</b>如果显示未呈现，则不会分派此事件。当内容最小化或遮蔽时会出现这种情况。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_FROM_STAGE_removedFromStage"><apiName>removedFromStage</apiName><shortdesc>
 在从显示列表中直接删除显示对象或删除包含显示对象的子树时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED_FROM_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在从显示列表中直接删除显示对象或删除包含显示对象的子树时分派。DisplayObjectContainer 类的以下两个方法会生成此事件：<codeph>removeChild()</codeph> 和 <codeph>removeChildAt()</codeph>。 
 
 <p>如果必须删除某个对象来为新对象提供空间，则 DisplayObjectContainer 对象的下列方法也会生成此事件：<codeph>addChild()</codeph>、<codeph>addChildAt()</codeph> 和 <codeph>setChildIndex()</codeph>。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.REMOVED_removed"><apiName>removed</apiName><shortdesc>
 将要从显示列表中删除显示对象时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.REMOVED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 将要从显示列表中删除显示对象时分派。DisplayObjectContainer 类的以下两个方法会生成此事件：<codeph>removeChild()</codeph> 和 <codeph>removeChildAt()</codeph>。 
 
 <p>如果必须删除某个对象来为新对象提供空间，则 DisplayObjectContainer 对象的下列方法也会生成此事件：<codeph>addChild()</codeph>、<codeph>addChildAt()</codeph> 和 <codeph>setChildIndex()</codeph>。 </p>
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.EXIT_FRAME_exitFrame"><apiName>exitFrame</apiName><shortdesc>
 [广播事件] 播放头退出当前帧时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.EXIT_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [广播事件] 播放头退出当前帧时分派。所有帧脚本已运行。如果播放头不移动，或者只有一帧，则会继续以帧速率分派此事件。此事件为广播事件，这意味着具有注册了此事件的侦听器的所有显示对象都会分派此事件。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.FRAME_CONSTRUCTED_frameConstructed"><apiName>frameConstructed</apiName><shortdesc>
 [广播事件] 在帧显示对象的构造函数运行之后但在帧脚本运行之前分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.FRAME_CONSTRUCTED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [广播事件] 在帧显示对象的构造函数运行之后但在帧脚本运行之前分派。如果播放头不移动，或者只有一帧，则会继续以帧速率分派此事件。此事件为广播事件，这意味着具有注册了此事件的侦听器的所有显示对象都会分派此事件。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ENTER_FRAME_enterFrame"><apiName>enterFrame</apiName><shortdesc>
 [播放事件] 播放头进入新帧时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ENTER_FRAME</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 [播放事件] 播放头进入新帧时分派。如果播放头不移动，或者只有一帧，则会继续以帧速率分派此事件。此事件为广播事件，这意味着具有注册了此事件的侦听器的所有显示对象都会分派此事件。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_TO_STAGE_addedToStage"><apiName>addedToStage</apiName><shortdesc>
 在将显示对象直接添加到舞台显示列表或将包含显示对象的子树添加至舞台显示列表中时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED_TO_STAGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在将显示对象直接添加到舞台显示列表或将包含显示对象的子树添加至舞台显示列表中时分派。以下方法会触发此事件：<codeph>DisplayObjectContainer.addChild()</codeph>、<codeph>DisplayObjectContainer.addChildAt()</codeph>。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:DisplayObject_flash.events.Event.ADDED_added"><apiName>added</apiName><shortdesc>
 将显示对象添加到显示列表中时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ADDED</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 将显示对象添加到显示列表中时分派。以下方法会触发此事件：<codeph>DisplayObjectContainer.addChild()</codeph>、<codeph>DisplayObjectContainer.addChildAt()</codeph>。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>flash.display.DisplayObjectContainer.addChild()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>flash.display.DisplayObjectContainer.addChildAt()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:DisplayObject:getBounds"><apiName>getBounds</apiName><shortdesc>
     返回一个矩形，该矩形定义相对于 targetCoordinateSpace 对象坐标系的显示对象区域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>定义与 <codeph>targetCoordinateSpace</codeph> 对象坐标系统相关的显示对象面积的矩形。
     
     </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>定义要使用的坐标系的显示对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回一个矩形，该矩形定义相对于 <codeph>targetCoordinateSpace</codeph> 对象坐标系的显示对象区域。考虑以下代码，此代码显示了矩形的返回方式根据您传递给该方法的 <codeph>targetCoordinateSpace</codeph> 参数的不同而不同：
     
     <codeblock>
     var container:Sprite = new Sprite();
     container.x = 100;
     container.y = 100;
     this.addChild(container);
     var contents:Shape = new Shape();
     contents.graphics.drawCircle(0,0,100);
     container.addChild(contents);
     trace(contents.getBounds(container));
      // (x=-100, y=-100, w=200, h=200)
     trace(contents.getBounds(this));
      // (x=0, y=0, w=200, h=200)
     </codeblock>
     
     
     <p><b>请注意：</b>使用 <codeph>localToGlobal()</codeph> 和 <codeph>globalToLocal()</codeph> 方法可以分别将显示对象的本地坐标转换为显示坐标，或将显示坐标转换为本地坐标。</p>
     
     <p><codeph>getBounds()</codeph> 方法与 <codeph>getRect()</codeph> 方法类似；但是 <codeph>getBounds()</codeph> 方法返回的矩形包括形状的所有笔触，然而 <codeph>getRect()</codeph> 方法返回的矩形则不包括。例如，请参阅 <codeph>getRect()</codeph> 方法的说明。</p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getRect()"><linktext>getRect()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:getRect"><apiName>getRect</apiName><shortdesc>
    返回一个矩形，该矩形根据 targetCoordinateSpace 参数定义的坐标系定义显示对象的边界，但不包括形状上的任何笔触。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>定义与 <codeph>targetCoordinateSpace</codeph> 对象坐标系统相关的显示对象面积的矩形。
    
    </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>targetCoordinateSpace</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>定义要使用的坐标系的显示对象。
    
    </apiDesc></apiParam></apiOperationDef><apiDesc>
    返回一个矩形，该矩形根据 <codeph>targetCoordinateSpace</codeph> 参数定义的坐标系定义显示对象的边界，但不包括形状上的任何笔触。<codeph>getRect()</codeph> 方法返回的值等于或小于由 <codeph>getBounds()</codeph> 方法返回的值。
    
    <p><b>请注意：</b>使用 <codeph>localToGlobal()</codeph> 和 <codeph>globalToLocal()</codeph> 方法可以分别将显示对象的本地坐标转换为舞台坐标，或将舞台坐标转换为本地坐标。</p>
    
    </apiDesc><example conref="examples\DisplayObject.getRect.1.as"> 下例显示 <codeph>getBounds()</codeph> 方法如何由于笔触占据的更多区域而比 <codeph>getRect()</codeph> 方法返回更大的矩形。在这种情况下，<codeph>triangle</codeph> Sprite 包括其它笔触，因为有 <codeph>lineStyle()</codeph> 方法的 <codeph>width</codeph> 和 <codeph>jointStyle</codeph> 参数。<codeph>trace()</codeph> 输出（在最后两行中）显示了 <codeph>getRect()</codeph> 和 <codeph>getBounds()</codeph> 矩形之间的差异：
<codeblock>

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.geom.Rectangle;

var triangle:Sprite = new Sprite();
var color:uint = 0xFF0044;
var width:Number = 20;
var alpha:Number = 1.0;
var pixelHinting:Boolean = true;
var scaleMode:String = LineScaleMode.NORMAL;
var caps:String = CapsStyle.SQUARE;
var joints:String = JointStyle.MITER;
triangle.graphics.lineStyle(width, color, alpha, pixelHinting, scaleMode, caps, joints);

var triangleSide:Number = 100;
triangle.graphics.moveTo(0, 0);
triangle.graphics.lineTo(0, triangleSide);
triangle.graphics.lineTo(triangleSide, triangleSide);
triangle.graphics.lineTo(0, 0);

addChild(triangle);

trace(triangle.getBounds(this)); // (x=-10, y=-24.1, w=134.10000000000002, h=134.1)
trace(triangle.getRect(this));     // (x=0, y=0, w=100, h=100)
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/getBounds()"><linktext>getBounds()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal"><apiName>globalToLocal</apiName><shortdesc>
     将 point 对象从舞台（全局）坐标转换为显示对象的（本地）坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>具有相对于显示对象的坐标的 Point 对象。
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>用 Point 类创建的对象。 该 Point 对象指定 <i>x</i> 和 <i>y</i> 坐标作为属性。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>将 <codeph>point</codeph> 对象从舞台（全局）坐标转换为显示对象的（本地）坐标。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     将 <codeph>point</codeph> 对象从舞台（全局）坐标转换为显示对象的（本地）坐标。
     
     <p>要使用此方法，请先创建 Point 类的一个实例。您分配的 <i>x</i> 和 <i>y</i> 值表示全局坐标，因为它们是相对于主显示区域的原点 (0,0) 的。然后将 Point 实例作为参数传递给 <codeph>globalToLocal()</codeph> 方法。该方法会返回一个新的 Point 对象，该对象具有相对于显示对象原点（而不是舞台原点）的 <i>x</i> 和 <i>y</i> 值。</p>
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> 以下代码创建一个 Shape 对象，并显示使用不同点作为参数调用 <codeph>hitTestPoint()</codeph> 方法的结果。<codeph>globalToLocal()</codeph> 方法将点从 Stage 坐标转换到该形状的坐标空间：
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>localToGlobal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point 类</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:globalToLocal3D"><apiName>globalToLocal3D</apiName><shortdesc>
     将二维点从舞台（全局）坐标转换为三维显示对象的（本地）坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>具有相对于三维显示对象的坐标的 Vector3D 对象。 
     
     </apiDesc><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>表示全局 x 坐标和 y 坐标的二维 Point 对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将二维点从舞台（全局）坐标转换为三维显示对象的（本地）坐标。
     
     <p>要使用此方法，请先创建 Point 类的一个实例。分配给 Point 对象的 x 和 y 值表示全局坐标，原因是这些坐标相对于主显示区域的原点 (0,0)。然后，将 Point 对象作为 <codeph>point</codeph> 参数传递给 <codeph>globalToLocal3D()</codeph> 方法。该方法会以一个 Vector3D 对象的形式返回三维坐标，该对象包含相对于三维显示对象的原点的 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 值。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestObject"><apiName>hitTestObject</apiName><shortdesc>
     计算显示对象的边框，以确定它是否与 obj 显示对象的边框重叠或相交。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果显示对象的边框相交，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
     
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要测试的显示对象。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>计算显示对象的边框，以确定它是否与作为参数传递的显示对象的边框重叠或相交。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     计算显示对象的边框，以确定它是否与 <codeph>obj</codeph> 显示对象的边框重叠或相交。
     
     </apiDesc><example conref="examples\DisplayObject.hitTestObject.1.as"> 以下代码创建三个 Shape 对象，并显示调用 <codeph>hitTestObject()</codeph> 方法的结果。请注意，尽管 circle2 和 circle3 并未重叠，但它们的边框重叠。因此，circle2 和 circle3 的点击测试返回 <codeph>true</codeph>。
<codeblock>

import flash.display.Shape;

var circle1:Shape = new Shape();
circle1.graphics.beginFill(0x0000FF);
circle1.graphics.drawCircle(40, 40, 40);
addChild(circle1);

var circle2:Shape = new Shape();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(40, 40, 40);
circle2.x = 50;
addChild(circle2);

var circle3:Shape = new Shape();
circle3.graphics.beginFill(0xFF0000);
circle3.graphics.drawCircle(40, 40, 40);
circle3.x = 100;
circle3.y = 67;
addChild(circle3);

trace(circle1.hitTestObject(circle2)); // true
trace(circle1.hitTestObject(circle3)); // false
trace(circle2.hitTestObject(circle3)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:hitTestPoint"><apiName>hitTestPoint</apiName><shortdesc>
     计算显示对象，以确定它是否与 x 和 y 参数指定的点重叠或相交。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果显示对象与指定的点重叠或相交，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
     
     </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要测试的此对象的 <i>x</i> 坐标。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要测试的此对象的 <i>y</i> 坐标。
     
     </apiDesc></apiParam><apiParam><apiItemName>shapeFlag</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>是检查对象 (<codeph>true</codeph>) 的实际像素，还是检查边框 (<codeph>false</codeph>) 的实际像素。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>计算显示对象，以确定它是否与 x 和 y 指定的点重叠或相交。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     计算显示对象，以确定它是否与 <codeph>x</codeph> 和 <codeph>y</codeph> 参数指定的点重叠或相交。<codeph>x</codeph> 和 <codeph>y</codeph> 参数指定舞台的坐标空间中的点，而不是包含显示对象的显示对象容器中的点（除非显示对象容器是舞台）。
     
     </apiDesc><example conref="examples\DisplayObject.hitTestPoint.1.as"> 以下代码创建一个 Shape 对象，并显示使用不同点作为参数调用 <codeph>hitTestPoint()</codeph> 方法的结果。<codeph>globalToLocal()</codeph> 方法将点从 Stage 坐标转换到该形状的坐标空间：
<codeblock>

import flash.display.Shape;
import flash.geom.Point;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.x = 10;
addChild(circle);

var point1:Point = new Point(0, 0);
trace(circle.hitTestPoint(point1.x, point1.y, true)); // false
trace(circle.hitTestPoint(point1.x, point1.y, false)); // false
trace(circle.globalToLocal(point1)); // [x=-10, y=0]

var point2:Point = new Point(10, 1);
trace(circle.hitTestPoint(point2.x, point2.y, true)); // false
trace(circle.hitTestPoint(point2.x, point2.y, false)); // true
trace(circle.globalToLocal(point2)); // [x=0, y=1]

var point3:Point = new Point(30, 20);
trace(circle.hitTestPoint(point3.x, point3.y, true)); // true
trace(circle.hitTestPoint(point3.x, point3.y, false)); // true
trace(circle.globalToLocal(point3)); // [x=20, y=20]
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObject:local3DToGlobal"><apiName>local3DToGlobal</apiName><shortdesc>
     将三维显示对象的（本地）坐标的三维点转换为舞台（全局）坐标中的二维点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个表示二维空间中的三维点的二维点。
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point3d</apiItemName><apiOperationClassifier>flash.geom:Vector3D</apiOperationClassifier><apiDesc>一个包含三维点或三维显示对象的坐标的 Vector3D 对象。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将三维显示对象的（本地）坐标的三维点转换为舞台（全局）坐标中的二维点。
     
     <p>例如，您只能使用二维坐标 (x,y) 来通过 <codeph>display.Graphics</codeph> 方法进行绘制。要绘制三维对象，您需要将显示对象的三维坐标映射到二维坐标。首先，创建一个保存三维显示对象的 x、y 和 z 坐标的 Vector3D 类的实例。然后，将 Vector3D 对象作为 <codeph>point3d</codeph> 参数传递给 <codeph>local3DToGlobal()</codeph> 方法。该方法会返回一个二维的 Point 对象，可将该对象与图形 API 一起使用来绘制三维对象。</p>
     
     
     </apiDesc><example conref="examples\Local3DToGlobalExample.as"> 本示例使用 <codeph>display.Graphics</codeph> 方法在二维空间中绘制简单的三维立方体。由于 <codeph>this</codeph> 显示对象的位置是偏移位置，因此立方体的注册点将位于其中心。Vector3D 对象的矢量保存立方体的三维坐标。首先绘制立方体的顶部，再绘制底部，然后将顶部的四个角与底部的四个角相连。您需要在绘制立方体之前先将其添加到显示对象容器中，这样才能使用 <codeph>local3DToGlobal()</codeph> 方法。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Sprite;
    import flash.display.Graphics;
    import flash.geom.*;

    public class Local3DToGlobalExample extends MovieClip {
        private var myCube:Sprite = new Sprite();
        private var v8:Vector.&lt;Vector3D> = new Vector.&lt;Vector3D>(8);

        public function Local3DToGlobalExample():void {
            this.x = -(this.stage.stageWidth / 2);
            this.y = -(this.stage.stageWidth / 2);

            v8[0] = new Vector3D(-40,-40,-40);
            v8[1] = new Vector3D(40,-40,-40);
            v8[2] = new Vector3D(40,-40,40);
            v8[3] = new Vector3D(-40,-40,40);
            v8[4] = new Vector3D(-40,100,-40);
            v8[5] = new Vector3D(40,100,-40);
            v8[6] = new Vector3D(40,100,40);
            v8[7] = new Vector3D(-40,100,40);

            myCube.x = (this.stage.stageWidth / 2);
            myCube.y = (this.stage.stageWidth / 2);
            myCube.z = 1;
            addChild(myCube);

            Cube();         
        }

        private function Cube():void {
            var ps:Point = new Point(0,0);

            myCube.graphics.lineStyle(2,0xFF0000);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);

            ps = myCube.local3DToGlobal(v8[0]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[4]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[1]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[5]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[2]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[6]);
            myCube.graphics.lineTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[3]);
            myCube.graphics.moveTo(ps.x, ps.y);
            ps = myCube.local3DToGlobal(v8[7]);
            myCube.graphics.lineTo(ps.x, ps.y);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObject:localToGlobal"><apiName>localToGlobal</apiName><shortdesc>
     将 point 对象从显示对象的（本地）坐标转换为舞台（全局）坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>具有相对于舞台的坐标的 Point 对象。
     
     </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>使用 Point 类创建的点的名称或标识符，指定 <i>x</i> 和 <i>y</i> 坐标作为属性。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     将 <codeph>point</codeph> 对象从显示对象的（本地）坐标转换为舞台（全局）坐标。
     
     <p>此方法允许您将任何给定的 <i>x</i> 和 <i>y</i> 坐标从相对于特定显示对象原点 (0,0) 的值（本地坐标）转换为相对于舞台原点的值（全局坐标）。</p>
     
     <p>要使用此方法，请先创建 Point 类的一个实例。您分配的 <i>x</i> 和 <i>y</i> 的值表示本地坐标，因为它们是相对于显示对象原点的值。</p>
     
     <p>然后，您可以将创建的 Point 实例作为参数传递给 <codeph>localToGlobal()</codeph> 方法。该方法会返回一个新的 Point 对象，该对象具有相对于舞台原点（而不是显示对象原点）的 <i>x</i> 和 <i>y</i> 值。</p>
     
     </apiDesc><example conref="examples\DisplayObject.localToGlobal.1.as"> 以下代码可创建一个 Sprite 对象。该 Sprite 对象的 <codeph>mouseX</codeph> 和 <codeph>mouseY</codeph> 属性位于显示对象的坐标空间中。此代码使用 <codeph>localToGlobal()</codeph> 方法将这些属性转换为全局（舞台）坐标：
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.Point;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
square.x = 100;
square.y = 200;

addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates)

function traceCoordinates(event:MouseEvent):void {
    var clickPoint:Point = new Point(square.mouseX, square.mouseY);
    trace("display object coordinates:", clickPoint);
    trace("stage coordinates:", square.localToGlobal(clickPoint));
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>oLocal()</linktext></link><link href="flash.geom.xml#Point"><linktext>flash.geom.Point 类</linktext></link></related-links></apiOperation><apiValue id="flash.display:DisplayObject:accessibilityProperties:get"><apiName>accessibilityProperties</apiName><shortdesc>
     此显示对象的当前辅助功能选项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.accessibility:AccessibilityProperties</apiValueClassifier></apiValueDef><apiDesc>
     此显示对象的当前辅助功能选项。如果您修改 <codeph>accessibilityProperties</codeph> 属性或 <codeph>accessibilityProperties</codeph> 内部的任何字段，则必须调用 <codeph>Accessibility.updateProperties()</codeph> 方法以使您的更改生效。
     
     <p class="flashonly"><b>请注意</b>：对于在 Flash 创作环境中创建的对象，将使用您在“辅助功能”面板中为该对象输入的所有信息来填充 <codeph>accessibilityProperties</codeph> 的值。</p>
     
     </apiDesc><example conref="examples\DisplayObject.accessibilityProperties.1.as"> 下例演示如何将简单的 AccessibilityProperties 对象附加到 TextField 实例：
<codeblock>

import flash.text.TextField;
import flash.accessibility.AccessibilityProperties;
import flash.accessibility.Accessibility;
import flash.system.Capabilities;

var tf:TextField = new TextField();
tf.text = "hello";

var accessProps:AccessibilityProperties = new AccessibilityProperties();
accessProps.name = "Greeting";

tf.accessibilityProperties = accessProps;

if (Capabilities.hasAccessibility) {
    Accessibility.updateProperties();
}

trace(tf.accessibilityProperties.name); // Greeting
</codeblock></example></apiValueDetail><related-links><link href="flash.accessibility.xml#Accessibility/updateProperties()"><linktext>flash.accessibility.Accessibility.updateProperties()</linktext></link><link href="flash.accessibility.xml#AccessibilityProperties"><linktext>flash.accessibility.AccessibilityProperties</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:alpha:get"><apiName>alpha</apiName><shortdesc>
     指示指定对象的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示指定对象的 Alpha 透明度值。有效值为 0（完全透明）到 1（完全不透明）。默认值为 1。<codeph>alpha</codeph> 设置为 0 的显示对象<i>是</i>活动的，即使它们不可见。
     
     </apiDesc><example conref="examples\DisplayObject.alpha.1.as"> 当鼠标滑过 Sprite 时，以下代码将 Sprite 的 <codeph>alpha</codeph> 属性设置为 50%：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.alpha = 0.5;
}

function restoreObject(event:MouseEvent):void {
    event.target.alpha = 1.0;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:blendMode:get"><apiName>blendMode</apiName><shortdesc>
     BlendMode 类中的一个值，用于指定要使用的混合模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     BlendMode 类中的一个值，用于指定要使用的混合模式。 内部绘制位图的方法有两种。  如果启用了混合模式或外部剪辑蒙版，则将通过向矢量渲染器添加有位图填充的正方形来绘制位图。如果尝试将此属性设置为无效值，则 Flash Player 或 Adobe AIR 会将该值设置为 <codeph>BlendMode.NORMAL</codeph>。
     
     <p><codeph>blendMode</codeph> 属性影响显示对象的每个像素。每个像素都由三种原色（红色、绿色和蓝色）组成，每种原色的值介于 0x00 和 0xFF 之间。Flash Player 或 Adobe AIR 将影片剪辑中一个像素的每种原色与背景中像素的对应颜色进行比较。例如，如果 <codeph>blendMode</codeph> 设置为 <codeph>BlendMode.LIGHTEN</codeph>，则 Flash Player 或 Adobe AIR 会将显示对象的红色值与背景的红色值进行比较，然后使用两者中较亮的一种颜色作为显示颜色的红色成分的值。</p>
     
     <p>下表将对 <codeph>blendMode</codeph> 设置进行说明。BlendMode 类定义可使用的字符串值。表中的插图显示应用于交叠于显示对象 (1) 之上的圆形显示对象 (2) 的 <codeph>blendMode</codeph> 值。</p>
     
     
     <p>
      <adobeimage alt="编号为 1 的正方形" href="../../images/blendMode-0a.jpg"/><adobeimage alt="编号为 2 的圆" href="../../images/blendMode-0b.jpg"/>
     
     </p>
     
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     <tgroup cols="3"><thead><row><entry>BlendMode 常量</entry><entry>插图</entry><entry>说明</entry></row></thead><tbody><row valign="top">
     <entry><codeph>BlendMode.NORMAL</codeph></entry>
     <entry><adobeimage alt="混合模式 NORMAL" href="../../images/blendMode-1.jpg"/></entry>
     <entry>该显示对象出现在背景前面。显示对象的像素值将覆盖背景的像素值。在显示对象为透明的区域，背景是可见的。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LAYER</codeph></entry>
     <entry><adobeimage alt="混合模式 LAYER" href="../../images/blendMode-2.jpg"/></entry>
     
     <entry>强制为该显示对象创建一个透明度组。这意味着首先在临时缓冲区中预构建显示对象，然后再进行下一步处理。如果显示对象是使用位图缓存进行预缓存的，或显示对象是至少带有一个子对象（具有 <codeph>BlendMode.NORMAL</codeph> 以外的 <codeph>blendMode</codeph> 设置）的显示对象容器，则这将自动完成。
     </entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.MULTIPLY</codeph></entry>
     <entry><adobeimage alt="混合模式 MULTIPLY" href="../../images/blendMode-3.jpg"/></entry>
     
     <entry>将显示对象原色的值与背景颜色的值相乘，然后通过除以 0xFF 进行标准化，从而得到较暗的颜色。此设置通常用于阴影和深度效果。
     
     <p>例如，如果显示对象中一个像素的某个原色（例如红色）与背景中对应的像素颜色的值均为 0x88，则相乘结果为 0x4840。除以 0xFF 将得到该原色的值 0x48，这是比显示对象或背景颜色暗的阴影。</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SCREEN</codeph></entry>
     <entry><adobeimage alt="混合模式 SCREEN" href="../../images/blendMode-4.jpg"/></entry>
     
     <entry>将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。此设置通常用于产生加亮效果或用来删除显示对象的黑色区域。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.LIGHTEN</codeph></entry>
     <entry><adobeimage alt="混合模式 LIGHTEN" href="../../images/blendMode-5.jpg"/></entry>
     
     <entry>在显示对象原色和背景颜色中选择相对较亮的颜色（具有较大值的颜色）。此设置通常用于叠加类型。
     
     <p>例如，如果显示对象的某个像素的 RGB 值为 0xFFCC33，背景像素的 RGB 值为 0xDDF800，则显示像素的结果 RGB 值为 0xFFF833（因为 0xFF > 0xDD，0xCC &lt; 0xF8，且 0x33 > 0x00 = 33）。</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DARKEN</codeph></entry>
     <entry><adobeimage alt="混合模式 DARKEN" href="../../images/blendMode-6.jpg"/></entry>
     
     <entry>在显示对象原色和背景颜色中选择相对较暗的颜色（具有较小值的颜色）。此设置通常用于叠加类型。
     
     <p>例如，如果显示对象的某个像素的 RGB 值为 0xFFCC33，背景像素的 RGB 值为 0xDDF800，则显示像素的结果 RGB 值为 0xDDCC00（因为 0xFF > 0xDD，0xCC &lt; 0xF8，且 0x33 > 0x00 = 33）。</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.DIFFERENCE</codeph></entry>
     <entry><adobeimage alt="混合模式 DIFFERENCE" href="../../images/blendMode-7.jpg"/></entry>
     
     <entry>将显示对象的原色与背景颜色进行比较，然后从较亮的原色值中减去较暗的原色值。此设置通常用于得到更明亮的颜色。
     
     <p>例如，如果显示对象的某个像素的 RGB 值为 0xFFCC33，背景像素的 RGB 值为 0xDDF800，则显示像素的结果 RGB 值为 0x222C33（因为 0xFF - 0xDD = 0x22，0xF8 - 0xCC = 0x2C，且 0x33 - 0x00 = 0x33）。</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ADD</codeph></entry>
     <entry><adobeimage alt="混合模式 ADD" href="../../images/blendMode-8.jpg"/></entry>
     
     <entry>将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。此设置通常用于使两个对象间的加亮溶解产生动画效果。
     
     <p>例如，如果显示对象的某个像素的 RGB 值为 0xAAA633，背景像素的 RGB 值为 0xDD2200，则显示像素的结果 RGB 值为 0xFFC833（因为 0xAA + 0xDD > 0xFF，0xA6 + 0x22 = 0xC8，且 0x33 + 0x00 = 0x33）。</p></entry>
     
     </row><row valign="top">
     <entry><codeph>BlendMode.SUBTRACT</codeph></entry>
     <entry><adobeimage alt="混合模式 SUBTRACT" href="../../images/blendMode-9.jpg"/></entry>
     
     <entry>从背景颜色的值中减去显示对象原色的值，下限值为 0。此设置通常用于使两个对象间的变暗溶解产生动画效果。
     
     <p>例如，如果显示对象的某个像素的 RGB 值为 0xAA2233，背景像素的 RGB 值为 0xDDA600，则显示像素的结果 RGB 值为 0x338400（因为 0xDD - 0xAA = 0x33，0xA6 - 0x22 = 0x84 且 0x00 - 0x33 &lt; 0x00）。</p></entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.INVERT</codeph></entry>
     <entry><adobeimage alt="混合模式 INVERT" href="../../images/blendMode-10.jpg"/></entry>
     
     <entry>反转背景。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ALPHA</codeph></entry>
     <entry><adobeimage alt="混合模式 ALPHA" href="../../images/blendMode-11.jpg"/></entry>
     
     <entry>将显示对象的每个像素的 Alpha 值应用于背景。这要求将父显示对象的 <codeph>blendMode</codeph> 设置设置为 <codeph>BlendMode.LAYER</codeph>。例如，在此插图中，父显示对象是一个白色背景，它具有 <codeph>blendMode = BlendMode.LAYER</codeph>。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.ERASE</codeph></entry>
     <entry><adobeimage alt="混合模式 ERASE" href="../../images/blendMode-12.jpg"/></entry>
     
     <entry>根据显示对象的 Alpha 值擦除背景。这要求将父显示对象的 <codeph>blendMode</codeph> 设置为 <codeph>BlendMode.LAYER</codeph>。例如，在此插图中，父显示对象是一个白色背景，它具有 <codeph>blendMode = BlendMode.LAYER</codeph>。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.OVERLAY</codeph></entry>
     <entry><adobeimage alt="混合模式 OVERLAY" href="../../images/blendMode-13.jpg"/></entry>
     
     <entry>根据背景的暗度调整每个像素的颜色。如果背景灰度值高于 50%，则显示对象和背景颜色进行叠加，从而产生较亮的颜色。如果背景灰度值低于 50%，则颜色相乘，从而产生较暗的颜色。此设置通常用于获得阴影效果。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.HARDLIGHT</codeph></entry>
     <entry><adobeimage alt="混合模式 HARDLIGHT" href="../../images/blendMode-14.jpg"/></entry>
     
     <entry>根据显示对象的暗度调整每个像素的颜色。如果显示对象灰度值高于 50%，则显示对象和背景颜色进行叠加，从而产生较亮的颜色。如果显示对象灰度值低于 50%，则颜色相乘，从而产生较暗的颜色。此设置通常用于获得阴影效果。</entry>
     </row><row valign="top">
     <entry><codeph>BlendMode.SHADER</codeph></entry>
     <entry align="center" valign="middle">不可用</entry>
     
     <entry>使用自定义着色器例程调整颜色。将使用的着色器指定为赋予 <codeph>blendShader</codeph> 属性的 Shader 实例。如果将显示对象的 <codeph>blendShader</codeph> 属性设置为 Shader 实例，则会将显示对象的 <codeph>blendMode</codeph> 属性自动设置为 <codeph>BlendMode.SHADER</codeph>。如果在未首先设置 <codeph>blendShader</codeph> 属性的情况下将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph>，则 <codeph>blendMode</codeph> 属性会设置为 <codeph>BlendMode.NORMAL</codeph>。</entry>
     </row></tbody></tgroup></adobetable>
     
     </apiDesc><example conref="examples\DisplayObject.blendMode.1.as"> 以下代码创建两个 Sprite 对象，一个正方形和一个圆形，并在鼠标指针滑过圆形时将圆形（在前景中）的混合模式设置为 <codeph>BlendMode.SUBTRACT</codeph>：
<codeblock>
import flash.display.Sprite;
import flash.display.BlendMode;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF88CC);
square.graphics.drawRect(0, 0, 80, 80);
addChild(square);

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_OVER, dimObject);
circle.addEventListener(MouseEvent.MOUSE_OUT, restoreObject);

function dimObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.SUBTRACT;
}

function restoreObject(event:MouseEvent):void {
    event.target.blendMode = BlendMode.NORMAL;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>blendShader</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:cacheAsBitmap:get"><apiName>cacheAsBitmap</apiName><shortdesc>
     如果设置为 true，则 Flash Player 或 Adobe AIR 将缓存显示对象的内部位图表示形式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>是否将此 DisplayObject 缓存为位图。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     如果设置为 <codeph>true</codeph>，则 Flash Player 或 Adobe AIR 将缓存显示对象的内部位图表示形式。此缓存可以提高包含复杂矢量内容的显示对象的性能。
     
     <p>具有已缓存位图的显示对象的所有矢量数据都将被绘制到位图而不是主显示。然后，将位图作为贴紧到最接近像素边界的未拉伸、未旋转的像素复制到主显示。像素按一对一与父对象进行映射。如果位图的边界发生更改，则将重新创建位图而不会拉伸它。</p>
     
     <p>除非将 <codeph>cacheAsBitmap</codeph> 属性设置为 <codeph>true</codeph>，否则不会创建内部位图。</p>
     
     <p>将 <codeph>cacheAsBitmap</codeph> 属性设置为 <codeph>true</codeph> 后，呈现并不更改，但是，显示对象将自动执行像素贴紧。动画速度可能会大大加快，具体取决于矢量内容的复杂性。
     </p>
     
     <p>只要对显示对象（当其 <codeph>filter</codeph> 数组不为空时）应用滤镜，<codeph>cacheAsBitmap</codeph> 属性就自动设置为 <codeph>true</codeph>，而且如果对显示对象应用了滤镜，即使将该属性设置为 <codeph>false</codeph>，也会将该显示对象的 <codeph>cacheAsBitmap</codeph> 报告为 <codeph>true</codeph>。如果清除显示对象的所有滤镜，则 <codeph>cacheAsBitmap</codeph> 设置将更改为它上次的设置。</p>
     
     <p>在下面的情况下，即使将 <codeph>cacheAsBitmap</codeph> 属性设置为 <codeph>true</codeph>，显示对象也不使用位图，而是从矢量数据呈现：</p>
     
     <ul>
     
       <li>位图过大。在 AIR 1.5 和 Flash Player 10 中，位图图像的最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果位图图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本中，高度最大为 2880 像素，宽度最大为 2,880 像素。</li>
     
       <li>位图无法分配（内存不足错误）。 </li>
     
     </ul>
     
     <p>最好将 <codeph>cacheAsBitmap</codeph> 属性与主要具有静态内容且不频繁缩放和旋转的影片剪辑一起使用。对于这样的影片剪辑，在转换影片剪辑时（更改其 <i>x</i> 和 <i>y</i> 位置时），<codeph>cacheAsBitmap</codeph> 可以提高性能。</p>
     
     </apiDesc><example conref="examples\DisplayObject.cacheAsBitmap.1.as"> 下例将投影应用于 Shape 实例。然后，它将跟踪 <codeph>cacheAsBitmap</codeph> 属性的值，该值在应用滤镜时设置为 <codeph>true</codeph>：
<codeblock>
import flash.display.Sprite;
import flash.filters.DropShadowFilter

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xAA0022);
circle.graphics.drawCircle(40, 40, 40);

addChild(circle);

trace(circle.cacheAsBitmap); // false

var filter:DropShadowFilter = new DropShadowFilter();
circle.filters = [filter];

trace(circle.cacheAsBitmap); // true
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/opaqueBackground"><linktext>opaqueBackground</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:filters:get"><apiName>filters</apiName><shortdesc>
     包含当前与显示对象关联的每个滤镜对象的索引数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier><apiException><apiDesc>当 <codeph>filters</codeph> 包括 ShaderFilter，并且着色器输出类型与此操作不兼容时（着色器必须指定 <codeph>pixel4</codeph> 输出）。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当 <codeph>filters</codeph> 包括 ShaderFilter，并且着色器未指定任何图像输入或第一个输入不是 <codeph>image4</codeph> 输入时。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当 <codeph>filters</codeph> 包括 ShaderFilter，并且着色器指定了未提供的图像输入时。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当 <codeph>filters</codeph> 包括 ShaderFilter，使用了 ByteArray 或 Vector.&lt;Number> 实例作为着色器输入，没有为 ShaderInput 对象指定 <codeph>width</codeph> 和 <codeph>height</codeph> 属性，或者指定的值与输入数据中的数据量不匹配。有关详细信息，请参阅 <codeph>ShaderInput.input</codeph> 属性。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     包含当前与显示对象关联的每个滤镜对象的索引数组。flash.filters 包中的多个类定义了可使用的特定滤镜。
     
     <p>在设计时可以在 Flash 创作工具中应用滤镜，而在运行时则可以使用 ActionScript 代码应用滤镜。要通过使用 ActionScript 应用滤镜，您必须制作整个 <codeph>filters</codeph> 数组的临时副本，修改临时数组，然后将临时数组的值分配回 <codeph>filters</codeph> 数组。无法直接将新滤镜对象添加到 <codeph>filters</codeph> 数组。</p>
     
     <p>要通过使用 ActionScript 添加滤镜，请执行以下步骤（假定目标显示对象名为 <codeph>myDisplayObject</codeph>）：</p>
     
     <ol>
     
       <li>使用所选滤镜类的构造函数方法创建一个新的滤镜对象。</li>
     
       <li>将 <codeph>myDisplayObject.filters</codeph> 数组的值分配给临时数组，例如一个名为 <codeph>myFilters</codeph> 的数组。</li>
     
       <li>将新的滤镜对象添加到临时数组 <codeph>myFilters</codeph>。</li>
     
       <li>将临时数组的值分配给 <codeph>myDisplayObject.filters</codeph> 数组。</li>
     
     </ol>
     
     <p>如果 <codeph>filters</codeph> 数组未定义，则无需使用临时数组。相反，您可以直接赋值包含一个或多个已创建的滤镜对象的一个数组文本值。“示例”部分的第一个示例通过使用处理已定义和未定义的 <codeph>filters</codeph> 数组的代码来添加投影滤镜。</p>
     
     <p>要修改现有的滤镜对象，必须使用修改 <codeph>filters</codeph> 数组的副本的技术：</p>
     
     <ol>
     
       <li>将 <codeph>filters</codeph> 数组的值分配给临时数组，例如一个名为 <codeph>myFilters</codeph> 的数组。</li>
     
       <li>使用临时数组 <codeph>myFilters</codeph> 修改属性。例如，如果要设置数组中第一个滤镜的品质属性，可以使用以下代码：<codeph>myFilters[0].quality = 1;</codeph></li>
     
       <li>将临时数组的值分配给 <codeph>filters</codeph> 数组。</li>
     
     </ol>
     
     <p>在加载时，如果显示对象具有关联的滤镜，则将它标记为像透明位图那样缓存自身。从此时起，只要显示对象具有有效的滤镜列表，播放器就会将显示对象缓存为位图。此源位图用作滤镜效果的源图像。每个显示对象通常有两个位图：一个包含原始未过滤的源显示对象，另一个是过滤后的最终图像。呈现时使用最终图像。只要显示对象不发生更改，最终图像就不需要更新。</p>
     
     <p>flash.filters 包含有滤镜类。例如，要创建 DropShadow 滤镜，请输入：</p>
     
     <codeblock>
     import flash.filters.DropShadowFilter
     var myFilter:DropShadowFilter = new DropShadowFilter (distance, angle, color, alpha, blurX, blurY, quality, inner, knockout)
     </codeblock>
     
     <p>您可以使用 <codeph>is</codeph> 运算符确定分配给 <codeph>filter</codeph> 数组中每个索引位置的滤镜的类型。例如，以下代码显示如何确定是 DropShadowFilter 的 <codeph>filters</codeph> 数组中第一个滤镜的位置：
     </p>
     
     <codeblock>
     import flash.text.TextField;
     import flash.filters.~~;
     var tf:TextField = new TextField();
     var filter1:DropShadowFilter = new DropShadowFilter();
     var filter2:GradientGlowFilter = new GradientGlowFilter();
     tf.filters = [filter1, filter2];
     
     tf.text = "DropShadow index: " + filterPosition(tf, DropShadowFilter).toString(); // 0
     addChild(tf)
     
     function filterPosition(displayObject:DisplayObject, filterClass:Class):int {
         for (var i:uint = 0; i &lt; displayObject.filters.length; i++) {
             if (displayObject.filters[i] is filterClass) {
                 return i;
             }
         }
         return -1;
     }
     </codeblock>
     <p><b>注意：</b>由于无法直接将新滤镜对象添加到 <codeph>DisplayObject.filters</codeph> 数组，因此以下代码对名为 <codeph>myDisplayObject</codeph> 的目标显示对象不起作用：</p>
     
     <codeblock>
     myDisplayObject.filters.push(myDropShadow);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="../../flash/filters/package-detail.html"><linktext>flash.filters package</linktext></link><link href="flash.display.xml#ShaderInput/input"><linktext>flash.display.ShaderInput.input</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:height:get"><apiName>height</apiName><shortdesc>
     指示显示对象的高度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示显示对象的高度，以像素为单位。高度是根据显示对象内容的范围来计算的。如果您设置了 <codeph>height</codeph> 属性，则 <codeph>scaleY</codeph> 属性会相应调整，如以下代码所示：
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>除 TextField 和 Video 对象以外，没有内容的显示对象（如一个空的 Sprite）的高度为 0，即使您尝试将 <codeph>height</codeph> 设置为其它值，也是这样。</p>
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> 以下代码创建两个 TextField 对象并调整每个对象的 <codeph>height</codeph> 属性（基于每个对象的 <codeph>textHeight</codeph> 属性）；此外，它还通过设置其 <codeph>y</codeph> 属性来定位第二个文本字段：
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
     返回一个 LoaderInfo 对象，其中包含加载此显示对象所属的文件的相关信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     返回一个 LoaderInfo 对象，其中包含加载此显示对象所属的文件的相关信息。<codeph>loaderInfo</codeph> 属性仅为 SWF 文件的根显示对象或已加载的位图（而不是使用 ActionScript 绘制的位图）定义。要查找与包含名为 <codeph>myDisplayObject</codeph> 的显示对象的 SWF 文件相关的 <codeph>loaderInfo</codeph> 对象，请使用 <codeph>myDisplayObject.root.loaderInfo</codeph>。
     
     <p>大的 SWF 文件可以通过调用 <codeph>this.root.loaderInfo.addEventListener(Event.COMPLETE, func)</codeph> 来监控其下载。</p>
     
     </apiDesc><example conref="examples\DisplayObject.loaderInfo.1.as"> 以下代码假定 <codeph>this</codeph> 引用显示对象。代码会输出该显示对象的根 SWF 文件的 URL：
<codeblock>
 trace (this.loaderInfo.url);
 
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>LoaderInfo 类</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:mask:get"><apiName>mask</apiName><shortdesc>
     调用显示对象被指定的 mask 对象遮罩。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>为显示对象设置蒙版。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     调用显示对象被指定的 <codeph>mask</codeph> 对象遮罩。要确保当舞台缩放时蒙版仍然有效，<codeph>mask</codeph> 显示对象必须处于显示列表的活动部分。但不绘制 <codeph>mask</codeph> 对象本身。将 <codeph>mask</codeph> 设置为 <codeph>null</codeph> 可删除蒙版。
     
     <p>要能够缩放遮罩对象，它必须在显示列表中。要能够拖动蒙版 Sprite 对象（通过调用其 <codeph>startDrag()</codeph> 方法），它必须在显示列表中。要为基于 sprite 正在分派的 <codeph>mouseDown</codeph> 事件调用 <codeph>startDrag()</codeph> 方法，请将 sprite 的 <codeph>buttonMode</codeph> 属性设置为 <codeph>true</codeph>。</p>
     
     <p><b>注意：</b>单个 <codeph>mask</codeph> 对象不能用于遮罩多个执行调用的显示对象。在将 <codeph>mask</codeph> 分配给第二个显示对象时，会撤消其作为第一个对象的遮罩，该对象的 <codeph>mask</codeph> 属性将变为 <codeph>null</codeph>。</p>  
     
     </apiDesc><example conref="examples\DisplayObject.mask.1.as"> 以下代码创建 TextField 对象以及被设置为 TextField 对象的遮罩的 Sprite 对象。当用户单击文本字段时，<codeph>drag()</codeph> 事件侦听器函数会调用遮罩 Sprite 对象的 <codeph>startDrag()</codeph> 方法：
<codeblock>
import flash.text.TextField;
import flash.display.Sprite;
import flash.events.MouseEvent;

var tf:TextField = new TextField();
tf.text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " 
            + "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. "
tf.selectable = false;
tf.wordWrap = true;
tf.width = 150;
addChild(tf);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 40, 40);
addChild(square);

tf.mask = square;

tf.addEventListener(MouseEvent.MOUSE_DOWN, drag);
tf.addEventListener(MouseEvent.MOUSE_UP, noDrag);

function drag(event:MouseEvent):void {
    square.startDrag();
}
function noDrag(event:MouseEvent):void {
    square.stopDrag();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseX:get"><apiName>mouseX</apiName><shortdesc>
     指示鼠标位置的 x 坐标，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示鼠标位置的 x 坐标，以像素为单位。
     
     <p><b>注意</b>：对于已旋转的 DisplayObject，返回的 x 坐标将反映未旋转的对象。</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> 以下代码创建一个 Sprite 对象，并在用户单击该对象时跟踪 <codeph>mouseX</codeph> 和 <codeph>mouseY</codeph> 的位置：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:mouseY:get"><apiName>mouseY</apiName><shortdesc>
     指示鼠标位置的 y 坐标，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示鼠标位置的 y 坐标，以像素为单位。
     
     <p><b>注意</b>：对于已旋转的 DisplayObject，返回的 y 坐标将反映未旋转的对象。</p>
     
     </apiDesc><example conref="examples\DisplayObject.mouseX.1.as"> 以下代码创建一个 Sprite 对象，并在用户单击该对象时跟踪 <codeph>mouseX</codeph> 和 <codeph>mouseY</codeph> 的位置：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 200, 200);
addChild(square);

square.addEventListener(MouseEvent.CLICK, traceCoordinates);

function traceCoordinates(event:MouseEvent):void {
    trace(square.mouseX, square.mouseY);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:name:get"><apiName>name</apiName><shortdesc>
     指示 DisplayObject 的实例名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>如果尝试在 Flash 创作工具中对放置在时间轴上的对象设置此属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>此 DisplayObject 的名称。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     指示 DisplayObject 的实例名称。通过调用父显示对象容器的 <codeph>getChildByName()</codeph> 方法，可以在父显示对象容器的子列表中标识该对象。
     
     </apiDesc><example conref="examples\DisplayObject.name.1.as"> 以下代码创建两个 Sprite 对象，并跟踪相关的 <codeph>name</codeph> 属性（当用户单击其中一个对象时）：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.name = "circle1";
addChild(circle1);
circle1.addEventListener(MouseEvent.CLICK, traceName);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x0000FF);
circle2.graphics.drawCircle(140, 40, 40);
circle2.name = "circle2";
addChild(circle2);
circle2.addEventListener(MouseEvent.CLICK, traceName);

function traceName(event:MouseEvent):void {
    trace(event.target.name);
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:opaqueBackground:get"><apiName>opaqueBackground</apiName><shortdesc>
     指定显示对象是否由于具有某种背景颜色而不透明。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
     指定显示对象是否由于具有某种背景颜色而不透明。透明的位图包含 Alpha 通道数据，并以透明的方式进行绘制。不透明位图没有 Alpha 通道（呈现速度比透明位图快）。如果位图是不透明的，则您可以指定要使用的其自己的背景颜色。
     
     <p>如果设置为某个数值，则表面是不透明的，并且带有该数值指定的 RGB 背景颜色。如果设置为 <codeph>null</codeph>（默认值），则显示对象将有透明背景。</p>
     
     <p><codeph>opaqueBackground</codeph> 属性主要与 <codeph>cacheAsBitmap</codeph> 属性一起使用，以优化呈现。对于 <codeph>cacheAsBitmap</codeph> 属性设置为 true 的显示对象，设置 <codeph>opaqueBackground</codeph> 可以提高呈现性能。</p>
     
     <p>如果在 <codeph>shapeFlag</codeph> 参数设置为 <codeph>true</codeph> 时调用 <codeph>hitTestPoint()</codeph> 方法，则不透明的背景区域<i>不</i> 匹配。</p>
     
     <p>不透明背景区域不响应鼠标事件。</p>
     
     </apiDesc><example conref="examples\DisplayObject.opaqueBackground.1.as"> 以下代码创建一个具有蓝色圆形的 Shape 对象，并将其 <codeph>opaqueBackground</codeph> 属性设置为红色 (0xFF0000)：
<codeblock>
import flash.display.Shape;

var circle:Shape = new Shape();
circle.graphics.beginFill(0x0000FF);
circle.graphics.drawCircle(40, 40, 40);
circle.opaqueBackground = 0xFF0000;
addChild(circle);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/cacheAsBitmap"><linktext>cacheAsBitmap</linktext></link><link href="flash.display.xml#DisplayObject/hitTestPoint()"><linktext>hitTestPoint()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:parent:get"><apiName>parent</apiName><shortdesc>
     指示包含此显示对象的 DisplayObjectContainer 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObjectContainer</apiValueClassifier><apiException><apiDesc>父显示对象属于您无权访问的安全沙箱。通过让父影片调用 <codeph>Security.allowDomain()</codeph> 方法，可以避免发生这种情况。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     指示包含此显示对象的 DisplayObjectContainer 对象。使用 <codeph>parent</codeph> 属性可以指定高于显示列表层次结构中当前显示对象的显示对象的相对路径。
     
     <p>可以使用 <codeph>parent</codeph> 在显示列表中上移多个级别，如下所示：</p>
     
     <codeblock>
     this.parent.parent.alpha = 20;
     </codeblock>
     
     </apiDesc><example conref="examples\DisplayObject.parent.1.as"> 以下代码创建三个 Sprite 对象，并显示 <codeph>parent</codeph> 属性如何反映显示列表层次结构：
<codeblock>

import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite2.parent.name); // sprite1
trace(sprite3.parent.name); // sprite2
trace(sprite3.parent.parent.name); // sprite1
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:root:get"><apiName>root</apiName><shortdesc>
     对于加载的 SWF 文件中的显示对象，root 属性是此 SWF 文件所表示的显示列表树结构部分中的顶级显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>返回此对象的根显示对象。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     对于加载的 SWF 文件中的显示对象，<codeph>root</codeph> 属性是此 SWF 文件所表示的显示列表树结构部分中的顶级显示对象。对于代表已加载图像文件的位图对象，<codeph>root</codeph> 属性就是位图对象本身。对于第一个加载的 SWF 文件的主类的实例，<codeph>root</codeph> 属性就是显示对象本身。Stage 对象的 <codeph>root</codeph> 属性是 Stage 对象本身。对于任何未添加到显示列表的显示对象，<codeph>root</codeph> 属性设置为 <codeph>null</codeph>，除非它已添加到符合以下条件的显示对象容器：不在显示列表中，但属于已加载 SWF 文件中顶级显示对象的子级。
     
     <p>例如，如果您通过调用 <codeph>Sprite()</codeph> 构造函数方法创建新的 Sprite 对象，则其 <codeph>root</codeph> 属性将为 <codeph>null</codeph>，除非您将其添加到显示列表中（或添加到不在显示列表中但属于 SWF 文件中顶级显示对象的子级的显示对象容器中）。</p>
     
     <p>对于加载的 SWF 文件，即使用于加载文件的 Loader 对象未在显示列表中，SWF 文件中的顶级显示对象也会为其本身设置 <codeph>root</codeph> 属性。在 Loader 对象添加为对其设置 <codeph>root</codeph> 属性的显示对象的子级前，它不会设置自己的 <codeph>root</codeph> 属性。</p>
     
     </apiDesc><example conref="examples\DisplayObject.root.1.as"> 以下代码显示 Stage 对象、未加载的（添加到显示列表前后）显示对象（Loader 对象）和已加载对象（已加载 Bitmap 对象）的 <codeph>root</codeph> 属性之间的差异：
<codeblock>
import flash.display.Loader;
import flash.net.URLRequest;
import flash.events.Event;

trace(stage.root); // [object Stage]

var ldr:Loader = new Loader();
trace (ldr.root); // null

addChild(ldr); 
trace (ldr.root); // [object ...]

var urlReq:URLRequest = new URLRequest("example.jpg");
ldr.load(urlReq);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);

function loaded(event:Event):void {
    trace(ldr.content.root); // [object Bitmap]
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotation:get"><apiName>rotation</apiName><shortdesc>
     指示 DisplayObject 实例距其原始方向的旋转程度，以度为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例距其原始方向的旋转程度，以度为单位。从 0 到 180 的值表示顺时针方向旋转；从 0 到 -180 的值表示逆时针方向旋转。对于此范围之外的值，可以通过加上或减去 360 获得该范围内的值。例如，<codeph>my_video.rotation = 450</codeph>语句与 <codeph> my_video.rotation = 90</codeph> 是相同的。
     
     </apiDesc><example conref="examples\DisplayObject.rotation.1.as"> 以下代码可创建一个 Sprite 对象并在用户单击该对象时旋转它：
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(-50, -50, 100, 100);
square.x = 150;
square.y = 150;
addChild(square);

square.addEventListener(MouseEvent.CLICK, rotate);

function rotate(event:MouseEvent):void {
        square.rotation += 15;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationX:get"><apiName>rotationX</apiName><shortdesc>
     指示 DisplayObject 实例相对于 3D 父容器距离其原始方向的 x 轴旋转（以度为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例相对于 3D 父容器距离其原始方向的 x 轴旋转（以度为单位）。从 0 到 180 的值表示顺时针方向旋转；从 0 到 -180 的值表示逆时针方向旋转。对于此范围之外的值，可以通过加上或减去 360 获得该范围内的值。
     
     </apiDesc><example conref="examples\RotationExample1.as"> 在本示例中，两个椭圆使用其 <codeph>rotationX</codeph> 和 <codeph>rotationY</codeph> 属性进行旋转。第一个椭圆的注册点设置为椭圆的中心点。它围绕自身进行旋转。第二个椭圆围绕一个外部点进行旋转。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationY:get"><apiName>rotationY</apiName><shortdesc>
     指示 DisplayObject 实例相对于 3D 父容器距离其原始方向的 y 轴旋转（以度为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例相对于 3D 父容器距离其原始方向的 y 轴旋转（以度为单位）。从 0 到 180 的值表示顺时针方向旋转；从 0 到 -180 的值表示逆时针方向旋转。对于此范围之外的值，可以通过加上或减去 360 获得该范围内的值。
     
     
     </apiDesc><example conref="examples\RotationExample1.as"> 在本示例中，两个椭圆使用其 <codeph>rotationX</codeph> 和 <codeph>rotationY</codeph> 属性进行旋转。第一个椭圆的注册点设置为椭圆的中心点。它围绕自身进行旋转。第二个椭圆围绕一个外部点进行旋转。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.geom.*;
    import flash.display.Graphics;
    import flash.events.TimerEvent;
    import flash.utils.Timer;

    public class RotationExample1 extends MovieClip {
        private var ellipse:Shape = new Shape();
        private var speed:int = 10;
        private var ellipse1:Shape;
        private var ellipse2:Shape;
        
        public function RotationExample1():void {

            ellipse1 = drawEllipse(-50, -40, (this.stage.stageWidth / 2), 
                                    (this.stage.stageHeight / 2));
            
            ellipse2 = drawEllipse(30, 40, (this.stage.stageWidth / 2), 
                                          (this.stage.stageHeight / 2));

            this.addChild(ellipse1);
            this.addChild(ellipse2);

            var t:Timer = new Timer(50);
            t.addEventListener(TimerEvent.TIMER, timerHandler);
            t.start();
        }

        private function drawEllipse(x1, y1, x2, y2):Shape {
        
            var e:Shape = new Shape();
            e.graphics.beginFill(0xFF0000);
            e.graphics.lineStyle(2);
            e.graphics.drawEllipse(x1, y1, 100, 80);
            e.graphics.endFill();

            e.x  = x2;  
            e.y  = y2;
            e.z = 1;
            return e;
        }

        private function timerHandler(event:TimerEvent):void {
            ellipse1.rotationY += speed;    
            ellipse1.rotationX -= speed;

            ellipse2.rotationY += speed;    
            ellipse2.rotationX -= speed;
        }
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:rotationZ:get"><apiName>rotationZ</apiName><shortdesc>
     指示 DisplayObject 实例相对于 3D 父容器距离其原始方向的 z 轴旋转（以度为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例相对于 3D 父容器距离其原始方向的 z 轴旋转（以度为单位）。从 0 到 180 的值表示顺时针方向旋转；从 0 到 -180 的值表示逆时针方向旋转。对于此范围之外的值，可以通过加上或减去 360 获得该范围内的值。
     
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scale9Grid:get"><apiName>scale9Grid</apiName><shortdesc>
     当前有效的缩放网格。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><maelexample>The following creates a movie clip that contains a 20-pixel line (which forms a border)
     and a gradient fill. The movie clip scales based on the mouse position, and because of the
     <code>scale9Grid</code> set for the movie clip, the thickness of the 20-pixel line does not
     vary when the clip scales (although the gradient in the movie clip <em>does</em> scale):
     
     <listing version="2.0">
     import flash.geom.Rectangle;
     import flash.geom.Matrix;
     
     this.createEmptyMovieClip("my_mc", this.getNextHighestDepth());
     
     var grid:Rectangle = new Rectangle(20, 20, 260, 260);
     my_mc.scale9Grid = grid ;
     
     my_mc._x = 50;
     my_mc._y = 50;
     
     function onMouseMove()
     {
      my_mc._width  = _xmouse;
      my_mc._height = _ymouse;
     }
     
     my_mc.lineStyle(20, 0xff3333, 100);
     var gradient_matrix:Matrix = new Matrix();
     gradient_matrix.createGradientBox(15, 15, Math.PI, 10, 10);
     my_mc.beginGradientFill("radial", [0xffff00, 0x0000ff],
              [100, 100], [0, 0xFF], gradient_matrix,
              "reflect", "RGB", 0.9);
     my_mc.moveTo(0, 0);
     my_mc.lineTo(0, 300);
     my_mc.lineTo(300, 300);
     my_mc.lineTo(300, 0);
     my_mc.lineTo(0, 0);
     my_mc.endFill();
     </listing>
     
     </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>如果向方法传递的参数无效。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     当前有效的缩放网格。如果设置为 <codeph>null</codeph>，则在应用任何缩放转换时，将正常缩放整个显示对象。
     
     <p>当定义 <codeph>scale9Grid</codeph> 属性时，该显示对象被分割到以 <codeph>scale9Grid</codeph> 矩形为基础的具有九个区域的网格中，该矩形定义网格的中心区域。网格的其它八个区域如下所示： </p>
     
     <ul>
       <li>矩形外的左上角</li>
       <li>矩形上方的区域 </li>
       <li>矩形外的右上角</li>
       <li>矩形左侧的区域</li>
       <li>矩形右侧的区域</li>
       <li>矩形外的左下角</li>
       <li>矩形下方的区域</li>
       <li>矩形外的右下角</li>
     </ul>
     
     <p>可以认为中心区域（由矩形定义）之外的八个区域类似于在缩放时已应用特殊规则的图片帧。</p>
     
     <p>在设置 <codeph>scale9Grid</codeph> 属性并缩放显示对象后，会正常缩放所有文本和渐变；但是，对于其它类型的对象，将应用以下规则：</p>
     
     <ul>
       <li>正常缩放中心区域中的内容。 </li>
       <li>不缩放转角中的内容。 </li>
       <li>仅水平缩放顶部和底部区域中的内容。仅垂直缩放左侧和右侧区域中的内容。</li>
      <li>拉伸所有填充（包括位图、视频和渐变）以适应其形状。</li>
     </ul>
     
     <p>如果旋转显示对象，则所有后续缩放都是正常的（并会忽略 <codeph>scale9Grid</codeph> 属性）。</p>
     
     <p>例如，请考虑以下显示对象和作为该显示对象的 <codeph>scale9Grid</codeph> 属性应用的矩形：</p>
     
     <adobetable>
     
       
     
     <tgroup cols="2"><tbody><row>
      <entry align="center"><adobeimage alt="显示对象图像" href="../../images/scale9Grid-a.jpg"/>
     <p>显示对象。</p></entry>
     
      <entry align="center"><adobeimage alt="显示对象缩放 9 区域" href="../../images/scale9Grid-b.jpg"/>
      <p>红色矩形显示 <codeph>scale9Grid</codeph>。</p></entry>
       </row></tbody></tgroup></adobetable>
     
     <p>缩放或拉伸显示对象时，矩形内的对象正常缩放，但是矩形外的对象则按照 <codeph>scale9Grid</codeph> 规则进行缩放：</p>
     
     <adobetable>
      
     
      
     
      
     
      
     
     <tgroup cols="2"><tbody><row>
      <entry>缩放到 75%：</entry>
      <entry><adobeimage alt="缩放到 75% 的显示对象" href="../../images/scale9Grid-c.jpg"/></entry>
      </row><row>
      <entry>缩放到 50%：</entry>
      <entry><adobeimage alt="缩放到 50% 的显示对象" href="../../images/scale9Grid-d.jpg"/></entry>
      </row><row>
      <entry>缩放到 25%：</entry>
      <entry><adobeimage alt="缩放到 25% 的显示对象" href="../../images/scale9Grid-e.jpg"/></entry>
      </row><row>
      <entry>水平拉伸 150%： </entry>
      <entry><adobeimage alt="拉伸 150% 的显示" href="../../images/scale9Grid-f.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     
     <p>设置 <codeph>scale9Grid</codeph> 的常见用法是设置用作组件的显示对象，当缩放该组件时，其中的边缘区域保持相同的宽度。</p>
     
     </apiDesc><example conref="examples\DisplayObject.scale9Grid.1.as"> 以下代码创建一个 Shape 对象，并用该对象的 <codeph>graphics</codeph> 属性绘制一个矩形。该矩形将一个 20 像素宽的线条作为边框，并且用渐变填充。该 timer 事件调用 <codeph>scale()</codeph> 函数，该函数通过调整 <codeph>scaleX</codeph> 和 <codeph>scaleY</codeph> 属性来缩放 Shape 对象。应用于 Shape 对象的 <codeph>scale9Grid</codeph> 会阻止缩放矩形的边框线，而只缩放渐变填充：
<codeblock>

import flash.display.Shape;
import flash.display.GradientType;
import flash.display.SpreadMethod;
import flash.display.InterpolationMethod;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var square:Shape = new Shape();
square.graphics.lineStyle(20, 0xFFCC00);
var gradientMatrix:Matrix = new Matrix();
gradientMatrix.createGradientBox(15, 15, Math.PI, 10, 10);
square.graphics.beginGradientFill(GradientType.RADIAL, 
            [0xffff00, 0x0000ff], 
            [100, 100], 
            [0, 0xFF], 
            gradientMatrix, 
            SpreadMethod.REFLECT, 
            InterpolationMethod.RGB, 
            0.9);
square.graphics.drawRect(0, 0, 100, 100);

var grid:Rectangle = new Rectangle(20, 20, 60, 60);
square.scale9Grid = grid ;

addChild(square);

var tim:Timer = new Timer(100);
tim.start();
tim.addEventListener(TimerEvent.TIMER, scale);

var scaleFactor:Number = 1.01;

function scale(event:TimerEvent):void {
    square.scaleX *= scaleFactor;
    square.scaleY *= scaleFactor;
    
    if (square.scaleX > 2.0) {
        scaleFactor = 0.99;
    }
    if (square.scaleX &lt; 1.0) {
        scaleFactor = 1.01;
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scaleX:get"><apiName>scaleX</apiName><shortdesc>
     指示从注册点开始应用的对象的水平缩放比例（百分比）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示从注册点开始应用的对象的水平缩放比例（百分比）。默认注册点为 (0,0)。1.0 等于 100% 缩放。
     
     <p>缩放本地坐标系统将更改 <codeph>x</codeph> 和 <codeph>y</codeph> 属性值，这些属性值是以整像素定义的。 </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> 以下代码创建一个 Sprite 对象，并用该对象的 <codeph>graphics</codeph> 属性绘制一个矩形。当用户单击该 Sprite 对象时，它将按 10% 的比例进行缩放：
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleY:get"><apiName>scaleY</apiName><shortdesc>
     指示从对象注册点开始应用的对象的垂直缩放比例（百分比）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示从对象注册点开始应用的对象的垂直缩放比例（百分比）。默认注册点为 (0,0)。1.0 是 100% 缩放。
     
     <p>缩放本地坐标系统将更改 <codeph>x</codeph> 和 <codeph>y</codeph> 属性值，这些属性值是以整像素定义的。 </p>
     
     </apiDesc><example conref="examples\DisplayObject.scaleX.1.as"> 以下代码创建一个 Sprite 对象，并用该对象的 <codeph>graphics</codeph> 属性绘制一个矩形。当用户单击该 Sprite 对象时，它将按 10% 的比例进行缩放：
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFFCC00);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, scale);

function scale(event:MouseEvent):void {
    square.scaleX *= 1.10;
    square.scaleY *= 1.10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:scaleZ:get"><apiName>scaleZ</apiName><shortdesc>
     指示从对象的注册点开始应用的对象的深度缩放比例（百分比）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示从对象的注册点开始应用的对象的深度缩放比例（百分比）。默认注册点为 (0,0)。1.0 是 100% 缩放。
     
     <p>缩放本地坐标系统将更改 <codeph>x</codeph>、<codeph>y</codeph> 和 <codeph>z</codeph> 属性值，这些属性值是以整像素定义的。 </p>
     
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/z"><linktext>z</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:scrollRect:get"><apiName>scrollRect</apiName><shortdesc>
     显示对象的滚动矩形范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
     显示对象的滚动矩形范围。显示对象被裁切为矩形定义的大小，当您更改 <codeph>scrollRect</codeph> 对象的 <codeph>x</codeph> 和 <codeph>y</codeph> 属性时，它会在矩形内滚动。
     
     <p><codeph>scrollRect</codeph> Rectangle 对象的属性使用显示对象的坐标空间，并缩放到像整个显示对象一样。滚动显示对象上已裁切窗口的转角范围是显示对象的原点 (0,0) 和矩形的宽度和高度定义的点。它们不按原点居中，而是使用原点定义区域的左上角。滚动的显示对象始终以整像素为增量进行滚动。 </p>
     
     <p>您可以通过设置 <codeph>scrollRect</codeph> Rectangle 对象的 <codeph>x</codeph> 属性来左右滚动对象， 还可以通过设置 <codeph>scrollRect</codeph> 对象的 <codeph>y</codeph> 属性来上下滚动对象。如果显示对象旋转了 90 度，并且您左右滚动它，则实际上显示对象会上下滚动。</p>
     
     </apiDesc><example conref="examples\DisplayObject.scrollRect.1.as"> 下例显示 <codeph>scrollRect</codeph> 属性如何为显示对象 <codeph>circle</codeph> 定义滚动区域。单击 <codeph>circle</codeph> 对象时，<codeph>clicked()</codeph> 事件处理函数方法会调整 <codeph>circle</codeph> 对象 <codeph>scrollRect</codeph> 属性的 <codeph>y</codeph> 属性，从而使对象向下滚动：
<codeblock>

import flash.display.Sprite;
import flash.geom.Rectangle;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(200, 200, 200);
circle.scrollRect = new Rectangle(0, 0, 200, 200);
addChild(circle);

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    var rect:Rectangle = event.target.scrollRect;
    rect.y -= 5;
    event.target.scrollRect = rect;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:stage:get"><apiName>stage</apiName><shortdesc>
     显示对象的舞台。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
     显示对象的舞台。Flash 应用程序只有一个 Stage 对象。例如，您可以创建多个显示对象并加载到显示列表中，每个显示对象的 <codeph>stage</codeph> 属性是指相同的 Stage 对象（即使显示对象属于已加载的 SWF 文件）。
     
     <p>如果显示对象未添加到显示列表，则其 <codeph>stage</codeph> 属性会设置为 <codeph>null</codeph>。</p>
     
     </apiDesc><example conref="examples\DisplayObject.stage.1.as"> 以下代码创建两个 TextField 对象并使用 Stage 对象的 <codeph>width</codeph> 属性来定位文本字段：
<codeblock>

import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.x = 10;
addChild(tf1);
tf1.width = tf1.stage.stageWidth / 2 - 10;

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.x = tf1.x + tf1.width + 5;
addChild(tf2);
tf2.width = tf2.stage.stageWidth / 2 - 10;

trace(stage.stageWidth);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:transform:get"><apiName>transform</apiName><shortdesc>
    一个对象，具有与显示对象的矩阵、颜色转换和像素范围有关的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Transform</apiValueClassifier></apiValueDef><apiDesc>
    一个对象，具有与显示对象的矩阵、颜色转换和像素范围有关的属性。在 Transform 类的条目中对特定属性 matrix、colorTransform 和三个只读属性（<codeph>concatenatedMatrix</codeph>、<codeph>concatenatedColorTransform</codeph> 和 <codeph>pixelBounds</codeph>）进行了说明。
    
    <p>transform 对象的每个属性本身都是一个对象。此概念很重要，因为设置 matrix 或 colorTransform 对象的新值的唯一方法是，创建新对象并将该对象复制到 transform.matrix 或 transform.colorTransform 属性。</p>
    
    <p>例如，要增加显示对象矩阵的 <codeph>tx</codeph> 值，您必须制作整个矩阵对象的副本，然后将新对象复制到 transform 对象的 matrix 属性中：</p>
    
    <pre><codeph>
    var myMatrix:Matrix = myDisplayObject.transform.matrix;  
    myMatrix.tx += 10; 
    myDisplayObject.transform.matrix = myMatrix;  
    </codeph></pre>
    
    <p>不能直接设置 <codeph>tx</codeph> 属性。下面的代码对 <codeph>myDisplayObject</codeph> 不起作用： </p>
    
    <pre><codeph>
    myDisplayObject.transform.matrix.tx += 10;
    </codeph></pre>
    
    <p>您也可以复制整个 transform 对象并为其赋予另一个显示对象的 transform 属性。例如，下面的代码将整个 transform 对象从 <codeph>myOldDisplayObj</codeph> 复制到 <codeph>myNewDisplayObj</codeph>：</p>
    <codeph>myNewDisplayObj.transform = myOldDisplayObj.transform;</codeph>
    <p>现在，新显示对象 <codeph>myNewDisplayObj</codeph> 与旧显示对象 <codeph>myOldDisplayObj</codeph> 具有相同的矩阵、颜色转换和像素范围值。</p>
     
    </apiDesc><example conref="examples\DisplayObject.transform.1.as"> 以下代码设置一个 <codeph>square</codeph> Sprite 对象。当用户单击 Sprite 时，<codeph>transformer()</codeph> 方法会调整 Sprite <codeph>transform</codeph> 属性的 <codeph>colorTransform</codeph> 和 <codeph>matrix</codeph> 属性：
<codeblock>

import flash.display.Sprite;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Transform;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.lineStyle(20, 0xFF2200);
square.graphics.beginFill(0x0000DD);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

var resultColorTransform:ColorTransform = new ColorTransform();
resultColorTransform.alphaMultiplier = 0.5;
resultColorTransform.redOffset = 155;
resultColorTransform.greenMultiplier = 0.5;

var skewMatrix:Matrix = new Matrix(1, 1, 0, 1);

square.addEventListener(MouseEvent.CLICK, transformer);

function transformer(event:MouseEvent):void {
    var transformation:Transform = square.transform;
    var tempMatrix:Matrix = square.transform.matrix;
    tempMatrix.concat(skewMatrix);
    square.transform.colorTransform = resultColorTransform;
    
    square.transform.matrix = tempMatrix;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#Transform"><linktext>Transform 类</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:visible:get"><apiName>visible</apiName><shortdesc>
     显示对象是否可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     显示对象是否可见。不可见的显示对象已被禁用。例如，如果 InteractiveObject 实例的 <codeph>visible=false</codeph>，则无法单击该对象。
     
     </apiDesc><example conref="examples\DisplayObject.visible.1.as"> 以下代码使用 Timer 对象调用定期更改显示对象的 <codeph>visible</codeph> 属性的函数，从而会产生闪烁的效果：
<codeblock>

import flash.text.TextField;
import flash.utils.Timer;
import flash.events.TimerEvent;

var tf:TextField = new TextField();
tf.text = "Hello.";
addChild(tf);

var tim:Timer = new Timer(250);
tim.start();
tim.addEventListener(TimerEvent.TIMER, blinker);

function blinker(event:TimerEvent):void {
    tf.visible = !tf.visible;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:width:get"><apiName>width</apiName><shortdesc>
     指示显示对象的宽度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示显示对象的宽度，以像素为单位。宽度是根据显示对象内容的范围来计算的。如果您设置了 <codeph>width</codeph> 属性，则 <codeph>scaleX</codeph> 属性会相应调整，如以下代码所示：
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>除 TextField 和 Video 对象以外，没有内容的显示对象（如一个空的 Sprite）的宽度为 0，即使您尝试将 <codeph>width</codeph> 设置为其它值，也是这样。</p>
     
     </apiDesc><example conref="examples\DisplayObject.width.1.as"> 以下代码设置一个 <codeph>square</codeph> Sprite 对象。当用户单击 Sprite 时，<codeph>widen()</codeph> 方法会增加 Sprite 的 <codeph>width</codeph> 属性：
<codeblock>

import flash.display.Sprite;
import flash.events.MouseEvent;

var square:Sprite = new Sprite();
square.graphics.beginFill(0xFF0000);
square.graphics.drawRect(0, 0, 100, 100);
addChild(square);

square.addEventListener(MouseEvent.CLICK, widen);

function widen(event:MouseEvent):void {
    square.width += 10;
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:x:get"><apiName>x</apiName><shortdesc>
     指示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 x 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 <i>x</i> 坐标。如果该对象位于具有变形的 DisplayObjectContainer 内，则它也位于包含 DisplayObjectContainer 的本地坐标系中。因此，对于逆时针旋转 90 度的 DisplayObjectContainer，该 DisplayObjectContainer 的子级将继承逆时针旋转 90 度的坐标系。对象的坐标指的是注册点的位置。
     
     </apiDesc><example conref="examples\DisplayObject.x.1.as"> 以下代码设置一个 <codeph>circle</codeph> Sprite 对象。Timer 对象用于每 50 毫秒更改一次 Sprite 的 <codeph>x</codeph> 属性：
<codeblock>

import flash.display.Sprite;
import flash.utils.Timer;
import flash.events.TimerEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFF0000);
circle.graphics.drawCircle(100, 100, 100);
addChild(circle);

var tim:Timer = new Timer(50);
tim.start();
tim.addEventListener(TimerEvent.TIMER, bounce);

var xInc:Number = 2;

function bounce(event:TimerEvent):void {
    circle.x += xInc;
    if (circle.x > circle.width) {
        xInc = -2;
    }
    if (circle.x &lt; 0) {
        xInc = 2;
    }
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:y:get"><apiName>y</apiName><shortdesc>
     指示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 y 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例相对于父级 DisplayObjectContainer 本地坐标的 <i>y</i> 坐标。如果该对象位于具有变形的 DisplayObjectContainer 内，则它也位于包含 DisplayObjectContainer 的本地坐标系中。因此，对于逆时针旋转 90 度的 DisplayObjectContainer，该 DisplayObjectContainer 的子级将继承逆时针旋转 90 度的坐标系。对象的坐标指的是注册点的位置。
     
     </apiDesc><example conref="examples\DisplayObject.height.1.as"> 以下代码创建两个 TextField 对象并调整每个对象的 <codeph>height</codeph> 属性（基于每个对象的 <codeph>textHeight</codeph> 属性）；此外，它还通过设置其 <codeph>y</codeph> 属性来定位第二个文本字段：
<codeblock>
import flash.text.TextField;

var tf1:TextField = new TextField();
tf1.text = "Text Field 1";
tf1.border = true;
tf1.wordWrap = true;
tf1.width = 40;
tf1.height = tf1.textHeight + 5;
addChild(tf1);

var tf2:TextField = new TextField();
tf2.text = "Text Field 2";
tf2.border = true;
tf2.wordWrap = true;
tf2.width = 40;
tf2.height = tf2.textHeight + 5;
tf2.y = tf1.y + tf1.height + 5;
addChild(tf2);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObject:z:get"><apiName>z</apiName><shortdesc>
     指示 DisplayObject 实例相对于 3D 父容器沿 z 轴的 z 坐标位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     指示 DisplayObject 实例相对于 3D 父容器沿 z 轴的 z 坐标位置。z 属性用于 3D 坐标，而不是屏幕坐标或像素坐标。 
     <p>当您将显示对象的 <codeph>z</codeph> 属性设置为默认值 <codeph>0</codeph> 之外的其它值时，将自动创建一个相对应的 Matrix3D 对象，以便调整显示对象在三维中的位置和方向。在使用 z 轴时，x 和 y 属性的现有行为将从屏幕坐标或像素坐标更改为相对于 3D 父容器的位置。</p>
     <p>例如，位于 x = 100、y = 100、z = 200 位置的 <codeph>_root</codeph> 的子级不在像素位置 (100,100) 处进行绘制。将在 3D 投影计算将其所置之处绘制该子级。计算方法为：</p>
     <p><codeph> (x~~cameraFocalLength/cameraRelativeZPosition, y~~cameraFocalLength/cameraRelativeZPosition)</codeph></p>
     
     
     </apiDesc><example conref="examples\ZAxisExample1.as"> 本示例绘制了两个椭圆并使其朝着消失点前后移动（沿 <codeph>z</codeph> 轴上下移动）。一个椭圆设置的移动速度要快于另一个。 
<codeblock>
package {
    import flash.display.MovieClip;
    import flash.display.Shape;
    import flash.display.Graphics;
    import flash.events.Event;
    import flash.geom.*;

    public class ZAxisExample1 extends MovieClip {
        private var ellipse1Back:int = 1;
        private var ellipse2Back:int = 1;
        private var depth:int = 1000;
        
        public function ZAxisExample1():void {
            
            var ellipse1 = drawEllipse((this.stage.stageWidth / 2) - 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 10);
            var ellipse2 = drawEllipse((this.stage.stageWidth / 2) + 100, 
                                      (this.stage.stageHeight / 2), 100, 80, 300);

            this.addChild(ellipse1);
            this.addChild(ellipse2);
            
            ellipse1.addEventListener(Event.ENTER_FRAME, ellipse1FrameHandler);
            ellipse2.addEventListener(Event.ENTER_FRAME, ellipse2FrameHandler);
        }

        private function drawEllipse(x:Number, y:Number, w:Number, h:Number, z:Number):Shape {
            var s:Shape = new Shape();                            
            s.z = z;
            s.graphics.beginFill(0xFF0000);
            s.graphics.lineStyle(2);
            s.graphics.drawEllipse(x, y, w, h);
            s.graphics.endFill();
            return s;
        }

        private function ellipse1FrameHandler(e:Event):void {
            ellipse1Back = setDepth(e, ellipse1Back);
            e.currentTarget.z += ellipse1Back * 10;
        }

        private function ellipse2FrameHandler(e:Event):void {
            ellipse2Back = setDepth(e, ellipse2Back);
            e.currentTarget.z += ellipse2Back * 20;
        }

        private function setDepth(e:Event, d:int):int {
            if(e.currentTarget.z > depth) {
                e.currentTarget.z = depth; 
                d = -1;
            }else if (e.currentTarget.z &lt;  0) {
                e.currentTarget.z = 0;
                d = 1;
            }
            return d;
        }
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.geom.xml#PerspectiveProjection"><linktext>flash.geom.PerspectiveProjection</linktext></link><link href="flash.geom.xml#Matrix3D"><linktext>flash.geom.Matrix3D</linktext></link><link href="flash.display.xml#DisplayObject/transform"><linktext>transform</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObject:blendShader:set"><apiName>blendShader</apiName><shortdesc>
     设置用于混合前景和背景的着色器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.display:Shader</apiValueClassifier><apiException><apiDesc>当着色器输出类型与此操作不兼容时（着色器必须指定 <codeph>pixel4</codeph> 输出）。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当着色器指定的图像输入少于两个，或者前两个输入不是 <codeph>image4</codeph> 输入时。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当着色器指定了未提供的图像输入时。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当使用 ByteArray 或 Vector.&lt;Number> 实例作为输入，并且没有为 ShaderInput 指定 <codeph>width</codeph> 和 <codeph>height</codeph> 属性或指定的值与输入对象中的数据量不匹配时。有关详细信息，请参阅 <codeph>ShaderInput.input</codeph> 属性。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     设置用于混合前景和背景的着色器。当 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph> 时，将使用指定的着色器为显示对象创建混合模式输出。
     
     <p>如果将显示对象的 <codeph>blendShader</codeph> 属性设置为 Shader 实例，则会将显示对象的 <codeph>blendMode</codeph> 属性自动设置为 <codeph>BlendMode.SHADER</codeph>。如果设置了 <codeph>blendShader</codeph> 属性（这会将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph>），则 <codeph>blendMode</codeph> 属性的值会发生变化，只需将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph> 即可将混合模式重置为使用混合着色器。除非要更改用于混合模式的着色器，否则无需再次设置 <codeph>blendShader</codeph> 属性。</p>
     
     <p>赋予 <codeph>blendShader</codeph> 属性的 Shader 至少必须指定两个 <codeph>image4</codeph> 输入。<b>无需</b>使用关联 ShaderInput 对象的 <codeph>input</codeph> 属性在代码中指定输入。会自动使用背景显示对象作为第一个输入（<codeph>index</codeph> 为 0 的输入）。使用前景显示对象作为第二个输入（<codeph>index</codeph> 为 1 的输入）。用作混合着色器的着色器可以指定超过两个输入。在这种情况下，必须通过设置其 ShaderInput 实例的 <codeph>input</codeph> 属性来指定任何附加输入。</p>
     
     <p>将 Shader 实例赋予此属性时，会在内部复制着色器。混合操作将使用该内部副本，而不是对原始着色器的引用。对着色器进行的任何更改（比如更改参数值、输入或字节代码）不会应用于所复制的用于混合模式的着色器。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Loader"><apiName>Loader</apiName><shortdesc>
 Loader 类可用于加载 SWF 文件或图像（JPG、PNG 或 GIF）文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Loader 类可用于加载 SWF 文件或图像（JPG、PNG 或 GIF）文件。使用 <codeph>load()</codeph> 方法来启动加载。被加载的显示对象将作为 Loader 对象的子级添加。
 
 <p>使用 URLLoader 类加载文本或二进制数据。</p>
 
 <p>Loader 类会覆盖其继承的以下方法，因为 Loader 对象只能有一个子显示对象 -- 其加载的显示对象。调用以下方法将引发异常：<codeph>addChild()</codeph>、<codeph>addChildAt()</codeph>、<codeph>removeChild()</codeph>、<codeph>removeChildAt()</codeph> 和 <codeph>setChildIndex()</codeph>。要删除被加载的显示对象，必须从其父 DisplayObjectContainer 子级数组中删除 <i>Loader</i> 对象。 </p>
 
 <p><b>注意：</b>在 ActionScript 3.0 中使用的不是 ActionScript 2.0 MovieClipLoader 和 LoadVars 类，而是 Loader 和 URLLoader 类。</p>
 
 <p>在使用 Loader 类时，请考虑 Flash Player 和 Adobe AIR 的安全模型： </p>
 
 <ul>
  <li>您可以加载来自任何可访问源的内容。 </li>
 
  <li>如果执行调用的 SWF 文件位于网络沙箱中并且要加载的文件是本地的，则不允许加载。 </li>
 
  <li>如果加载的内容为用 ActionScript 3.0 编写的 SWF 文件，那么除非可以通过调用加载的内容文件中的 <codeph>System.allowDomain()</codeph> 或 <codeph>System.allowInsecureDomain()</codeph> 方法来允许跨脚本排列，否则另一个安全沙箱中的 SWF 文件不能对它执行跨脚本操作。</li>
  
  <li>如果被加载的内容为 AVM1 SWF 文件（用 ActionScript 1.0 或 2.0 编写），则 AVM2 SWF 文件（用 ActionScript 3.0 编写）不能对它执行跨脚本操作。但是，可以通过使用 LocalConnection 类在两个 SWF 文件之间实现通信。</li>
  
  <li>如果加载的内容为图像，则安全沙箱之外的 SWF 文件将无法访问其数据，除非该 SWF 文件的域包含在该图像的原始域上的 URL 策略文件中。</li>
 
  <li>在只能与本地文件系统的内容交互的沙箱中的影片剪辑不能对只能与远程内容交互的沙箱中的影片剪辑使用脚本，反之亦然。 </li>
 
  <li>无法连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》一书的<ph product="flex"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref></ph><ph product="flash"><xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref></ph><i/>中的“限制网络 API”。 </li>
 
 
 </ul>
 
 <p>但在 AIR 中，<codeph>application</codeph> 安全沙箱中的内容（使用 AIR 应用程序安装的内容）不受这些安全限制的约束。</p>
 
 <p>有关详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
 <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
 
 </ul>
 
 <p>当从不受信任的源（如除 Loader 对象的根 SWF 文件以外的域）加载 SWF 文件时，您可能需要为 Loader 对象定义蒙版，以防止将加载的内容（Loader 对象的子级）绘画到该蒙版之外的舞台部分中，如以下代码所示：</p>
 
 <codeblock>import flash.display.~~;
 import flash.net.URLRequest;
 var rect:Shape = new Shape();
 rect.graphics.beginFill(0xFFFFFF);
 rect.graphics.drawRect(0, 0, 100, 100);
 rect.graphics.endFill();
 addChild(rect);
 var ldr:Loader = new Loader();
 ldr.mask = rect;
 var url:String = "http://www.unknown.example.com/content.swf";
 var urlReq:URLRequest = new URLRequest(url);
 ldr.load(urlReq);
 addChild(ldr);
 </codeblock>
 
 </apiDesc><example conref="examples\LoaderExample.as"> 下例用 LoaderExample 类来说明如何使用各种事件侦听器。执行下列步骤可完成该任务：
 <ol>
  <li>创建 <codeph>url</codeph> 属性，它是图像文件的位置和名称</li>
  <li>在 <codeph>LoaderExample</codeph> 构造函数中，创建一个新的 Loader 对象，名为 <codeph>loader</codeph>，该对象随后被传递给 <codeph>configureListeners()</codeph> 方法，如步骤 3 所述。</li>
  <li>构造函数创建一个 URLRequest 对象的新实例 <codeph>request</codeph>，该实例带有传递的 <codeph>url</codeph>，这样，就可以知道文件的名称和位置。</li>
  <li><codeph>request</codeph> 对象传递给 <codeph>loader</codeph> 对象的 <codeph>load()</codeph> 方法，该方法会将图像加载到显示列表上。</li>
  <li>为加载器上的 <codeph>click</codeph> 事件注册 <codeph>clickHandler</codeph> 事件侦听器。在单击鼠标后，便可卸载加载的图像。</li>
  <li><codeph>configureListeners()</codeph> 方法通过以下方法添加 7 个事件侦听器：
  <ul>
      <li>图像加载完成时，执行 <codeph>completeHandler()</codeph> 方法。</li>
 
      <li>图像不是在本地加载，并且只有在网络请求可用并可被 Flash Player 检测到的情况下，才会执行 <codeph>httpStatusHandler()</codeph> 方法。</li>
 
      <li><codeph>initHandler()</codeph> 方法在 <codeph>completeHandler()</codeph> 方法之前、<codeph>progressHandler()</codeph> 方法之后执行。通常，<codeph>init</codeph> 事件在加载 SWF 文件时更有用。</li>
 
      <li>图像文件不可用或不可访问，则执行 <codeph>ioErrorHandler()</codeph> 方法。</li>
 
      <li>首次打开图像文件时，执行 <codeph>openHandler()</codeph> 方法。</li>
 
      <li>图像文件开始下载和下载完成时，执行 <codeph>progressHandler()</codeph> 方法。</li>
 
      <li>通过使用用户单击图像时使用的 <codeph>unload()</codeph> 方法卸载图像时，执行 <codeph>unLoadHandler()</codeph> 方法。</li>
 
  </ul>
  </li>
 </ol>
 <p> 请牢记以下要求：</p>
 
 <ul>
  <li>该示例要求您将名为 Image.gif 的文件放置在与经过编译的 SWF 文件相同的目录中。使用具有一个适合主 SWF 文件尺寸的区域的图像。</li>
 
  <li>虽然该示例使用可用于 LoaderInfo 对象的所有事件，但是在大部分情况下，只需要一个子集。特别是在只加载图像文件时，<codeph>complete</codeph> 事件（还可能是 <codeph>ioError</codeph> 事件）足够用于加载本地图像。</li>
 
 </ul>
 
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderExample() {
            var loader:Loader = new Loader();
            configureListeners(loader.contentLoaderInfo);
            loader.addEventListener(MouseEvent.CLICK, clickHandler);

            var request:URLRequest = new URLRequest(url);
            loader.load(request);

            addChild(loader);
        }

        private function configureListeners(dispatcher:IEventDispatcher):void {
            dispatcher.addEventListener(Event.COMPLETE, completeHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
            dispatcher.addEventListener(Event.INIT, initHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            dispatcher.addEventListener(Event.OPEN, openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);
            dispatcher.addEventListener(Event.UNLOAD, unLoadHandler);
        }

        private function completeHandler(event:Event):void {
            trace("completeHandler: " + event);
        }

        private function httpStatusHandler(event:HTTPStatusEvent):void {
            trace("httpStatusHandler: " + event);
        }

        private function initHandler(event:Event):void {
            trace("initHandler: " + event);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }

        private function openHandler(event:Event):void {
            trace("openHandler: " + event);
        }

        private function progressHandler(event:ProgressEvent):void {
            trace("progressHandler: bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
        }

        private function unLoadHandler(event:Event):void {
            trace("unLoadHandler: " + event);
        }

        private function clickHandler(event:MouseEvent):void {
            trace("clickHandler: " + event);
            var loader:Loader = Loader(event.target);
            loader.unload();
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:Loader:Loader"><apiName>Loader</apiName><shortdesc>
     创建一个可用于加载文件（如 SWF、JPEG、GIF 或 PNG 文件）的 Loader 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need wording on parent/child relationships, root DisplayObjects, and so on.
     </internal></asCustoms></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     创建一个可用于加载文件（如 SWF、JPEG、GIF 或 PNG 文件）的 Loader 对象。调用 <codeph>load()</codeph> 方法可将资源加载为 Loader 实例的子级。然后，可以将 Loader 对象添加到显示列表（例如，通过使用 DisplayObjectContainer 实例的 <codeph>addChild()</codeph> 方法）。这样，资源在加载时会出现在舞台上。
     
     <p>您也可以在“offlist”模式下使用 Loader 实例，这样就不会将 Loader 实例添加到显示列表的显示对象容器中。在该模式下，Loader 实例可以用于加载包含应用程序的其它模块的 SWF 文件。 </p>
     
     <p>要检测何时可以完成 SWF 文件的加载，您可以使用与 Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性相关联的 LoaderInfo 对象的事件。此时，便可执行模块 SWF 文件中的代码以初始化和启动模块。在 offlist 模式下，还可以使用 Loader 实例来加载包含组件或媒体资源的 SWF 文件。同时，您可以使用 LoaderInfo 对象事件通知来检测组件的加载何时完成。此时，应用程序可以通过实例化代表这些组件和资源的 ActionScript 3.0 类来开始使用 SWF 文件库中的组件和媒体资源。</p>
     
     <p>要确定 Loader 对象的状态，请监视与 Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性相关联的 LoaderInfo 对象的以下事件：</p>
     
     <ul>
       
     <li>在加载开始时分派 <codeph>open</codeph> 事件。</li>
       
     <li>在无法加载文件或在加载过程中出现错误时，分派 <codeph>ioError</codeph> 或 <codeph>securityError</codeph> 事件。 </li>
       
     <li>在文件加载过程中会不断引发 <codeph>progress</codeph> 事件。</li>
       
     <li>在文件完成下载但加载的影片剪辑的方法和属性尚不可用时分派 <codeph>complete</codeph> 事件。 </li>
       
     <li>在可以访问加载的 SWF 文件的属性和方法，即可以开始操作加载的 SWF 文件时分派 <codeph>init</codeph> 事件。在 <codeph>complete</codeph> 处理函数之前分派该事件。在流式 SWF 文件中，<codeph>init</codeph> 事件可以在明显早于 <codeph>complete</codeph> 事件的时间发生。在大多数情况下，请使用 <codeph>init</codeph> 处理函数。</li>
     
     </ul>
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:Loader:close"><apiName>close</apiName><shortdesc>
     取消当前正在对 Loader 实例执行的 load() 方法操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     取消当前正在对 Loader 实例执行的 <codeph>load()</codeph> 方法操作。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:load"><apiName>load</apiName><shortdesc>
     将 SWF、JPEG、渐进式 JPEG、非动画 GIF 或 PNG 文件加载到此 Loader 对象的子对象中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><oldexample>The following example shows how to use the <code>MovieClipLoader.loadClip()</code> 
     method by creating a handler for the <code>onLoadInit</code> event and then making the request.
     <p>You should either place the following code directly into a frame action on a Timeline, or 
     paste it into a class that extends MovieClip. This code also expects an image named YourImage.jpg
     to exist in the same directory as the compiled SWF file.</p>
     
     <listing version="2.0">
     var container:MovieClip = createEmptyMovieClip("container", getNextHighestDepth());
     var mcLoader:MovieClipLoader = new MovieClipLoader();
     mcLoader.addListener(this);
     mcLoader.loadClip("YourImage.jpg", container);
     
     function onLoadInit(mc:MovieClip) {
         trace("onLoadInit: " + mc);
     }
     </listing>
     
     </oldexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>request</codeph> 对象的 <codeph>digest</codeph> 属性不是 <codeph>null</codeph>。如果在加载 SWZ 文件（一个 Adobe 平台组件）时调用 <codeph>URLLoader.load()</codeph> 方法，仅应设置 URLRequest 对象的 <codeph>digest</codeph> 属性。
     
     </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>LoaderContext.securityDomain</codeph> 的值必须是 <codeph>null</codeph> 或 <codeph>SecurityDomain.currentDomain</codeph>。这说明您只能将被加载的媒体放置在其原始的安全沙箱或您自己的安全沙箱中（后者需要策略文件）。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>本地 SWF 文件可能只会将 LoaderContext.securityDomain 设置为 <codeph>null</codeph>。不允许将非本地媒体导入到本地沙箱中，或者将其它本地媒体放置在除其原始沙箱以外的其它位置。
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>context</codeph> 参数的 <codeph>applicationDomain</codeph> 或 <codeph>securityDomain</codeph> 属性来自不允许的域。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果本地 SWF 文件尝试使用 <codeph>context</codeph> 参数的 <codeph>securityDomain</codeph> 属性。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>request</apiItemName><apiOperationClassifier>flash.net:URLRequest</apiOperationClassifier><apiDesc> 要加载的 SWF、JPEG、GIF 或 PNG 文件的绝对或相对 URL。相对路径必须相对于主 SWF 文件。绝对 URL 必须包括协议引用，如 http:// 或 file:///。文件名不能包括磁盘驱动器指定。
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>LoaderContext 对象，它具有定义下列内容的属性：
     
     <ul>
     
	 <li>是否应在加载对象时检查策略文件是否存在</li>
     
     <li>被加载的对象的 ApplicationDomain</li>
     
     <li>加载的对象的 SecurityDomain</li>
     
     </ul>
     <p>如果未指定 <codeph>context</codeph> 参数或者该参数引用了 null 对象，则已加载的内容将保留在自己的安全域中。</p>
     
     <p>有关完整的详细信息，请参阅 <xref href="../system/LoaderContext.html">LoaderContext</xref> 类中的属性说明。</p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>将 SWF 文件或图像文件加载到该 Loader 实例的 DisplayObject 子级中。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     将 SWF、JPEG、渐进式 JPEG、非动画 GIF 或 PNG 文件加载到此 Loader 对象的子对象中。如果加载 GIF 动画文件，将仅显示第一帧。由于 Loader 对象可以只包含一个子级，因此，发出后续 <codeph>load()</codeph> 请求将终止先前的请求，如果仍然存在未处理的请求，则会开始新的加载。
     
     <p><b>注意</b>：在 AIR 1.5 和 Flash Player 10 中，所加载图像的最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果所加载图像的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。</p>
     
     <p>加载到 Loader 对象中的 SWF 文件或图像会继承该 Loader 对象的父显示对象的位置、旋转和缩放属性。 </p>
     
     <p>使用 <codeph>unload()</codeph> 方法可删除用此方法加载的影片或图像，或者取消正在进行中的加载操作。</p>
     
     <p>可以在包含 SWF 内容的 HTML 页中设置 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>allowNetworking</codeph> 参数，防止 SWF 文件使用此方法。</p>
     
     <p>使用此方法时，请考虑 Loader 类说明中描述的 Flash Player 安全模型。 </p>
     
     <p> 在 Flash Player 10 和更高版本中，如果使用包含上载（由 POST 体内的“content-disposition”标头中的“filename”参数表示）的 multipart Content-Type（例如“multipart/form-data”），则 POST 操作会受应用于上载的安全规则的约束：</p>
	 <ul>
	 <li>必须执行 POST 操作以响应用户启动的操作（如鼠标单击或按键）。</li>
	 <li>如果 POST 操作是跨域的（POST 目标与发送 POST 请求的 SWF 文件不在同一台服务器上），则目标服务器必须提供一个允许跨域访问的 URL 策略文件。</li>
	 </ul>
     <p>同样，对于任何 multipart Content-Type，语法必须有效（根据 RFC2046 标准）。如果语法无效，则 POST 操作受应用于上载的安全规则约束。</p>
     <p>有关安全性的详细信息，请参阅以下部分：</p>
     
     <ul>
     
     <li class="flexonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
     
     </ul>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/contentLoaderInfo"><linktext>contentLoaderInfo</linktext></link><link href="flash.net.xml#URLRequest"><linktext>flash.net.URLRequest</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>flash.display.Loader.unload()</linktext></link><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link><link href="flash.system.xml#LoaderContext"><linktext>flash.system.LoaderContext</linktext></link></related-links><adobeApiEvent id="flash.display:Loader:load_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件完成加载时由 <codeph>contentLoaderInfo</codeph> 对象分派。<codeph>complete</codeph> 事件始终在 <codeph>init</codeph> 事件之后分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在文件完成加载时由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_httpStatus"><apiName>httpStatus</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在通过 HTTP 发出网络请求并且 Flash Player 可以检测到 HTTP 状态代码时，由 <codeph>contentLoaderInfo</codeph> 对象分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在通过 HTTP 发出网络请求并且 Flash Player 可以检测到 HTTP 状态代码时，由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_init"><apiName>init</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在可以访问所加载的 SWF 文件的属性和方法时，由 <codeph>contentLoaderInfo</codeph> 对象分派。<codeph>init</codeph> 事件始终在 <codeph>complete</codeph> 事件之前。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在可以访问所加载的 SWF 文件的属性和方法时，由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在发生会导致加载操作失败的输入或输出错误时，由 <codeph>contentLoaderInfo</codeph> 对象分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在发生会导致加载操作失败的输入或输出错误时，由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_open"><apiName>open</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在加载操作开始时，由 <codeph>contentLoaderInfo</codeph> 对象分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在加载操作开始时，由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在加载操作进行过程中接收到数据时，由<codeph> contentLoaderInfo </codeph>对象分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在加载操作进行过程中接收到数据时，由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_securityError"><apiName>securityError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>当位于只能与本地文件系统内容交互的沙箱中的 SWF 文件尝试加载只能与远程内容交互的沙箱中的内容时（反之亦然），由 <codeph>contentLoaderInfo</codeph> 对象分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>当位于只能与本地文件系统内容交互的沙箱中的 SWF 文件尝试加载只能与远程内容交互的沙箱中的内容时（反之亦然），由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.display:Loader:load_unload"><apiName>unload</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在删除所加载的对象时，由 <codeph>contentLoaderInfo</codeph> 对象分派。
     
     </apiDesc></adobeApiEventDetail><shortdesc>在删除所加载的对象时，由 contentLoaderInfo 对象分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:Loader:loadBytes"><apiName>loadBytes</apiName><shortdesc>
     从 ByteArray 对象中所存储的二进制数据中加载。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 ByteArray 对象的 <codeph>length</codeph> 属性不大于 0。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>context</codeph> 参数的 <codeph>checkPolicyFile</codeph> 或 <codeph>securityDomain</codeph> 属性为非空。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果提供的 <codeph>context</codeph> 属性的 <codeph>applicationDomain</codeph> 属性来自不允许的域。
     
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果尝试连接到常用的保留端口。有关已阻止的端口的完整列表，请参阅《ActionScript 3.0 编程》<i/>一书的“安全性”一章中的“限制网络 API”。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>一个 ByteArray 对象。ByteArray 的内容可以采用受 Loader 类支持的任何文件格式：SWF、GIF、JPEG 或 PNG。
     
     </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>flash.system:LoaderContext</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 LoaderContext 对象。只应用 LoaderContext 对象的 <codeph>applicationDomain</codeph> 属性；不应用 LoaderContext 对象的 <codeph>checkPolicyFile</codeph> 和 <codeph>securityDomain</codeph> 属性。 
     
     <p>如果未指定 <codeph>context</codeph> 参数或者该参数引用了 null 对象，则内容将加载到当前的安全域（在 Flash Player 安全文档中称为“导入加载”的进程）中。具体来说，如果执行加载的 SWF 文件通过将远程 SWF 并入到其代码中来信任远程 SWF，则执行加载的 SWF 可直接将其导入到自己的安全域中。</p>
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     从 ByteArray 对象中所存储的二进制数据中加载。
     
     <p>使用此方法时，请考虑 Loader 类说明中描述的 Flash Player 安全模型。 </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link><link href="flash.system.xml#LoaderContext/applicationDomain"><linktext>flash.system.LoaderContext.applicationDomain</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unload"><apiName>unload</apiName><shortdesc>
     删除此 Loader 对象中使用 load() 方法加载的子项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>The funky-looking code formatting above is intentional to work around a bug!
     </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     删除此 Loader 对象中使用 <codeph>load()</codeph> 方法加载的子项。将关联 LoaderInfo 对象的 <codeph>property</codeph> 重置为 <codeph>null</codeph>。不必破坏子级，因为其它对象可能要引用它；但是，它不再是 Loader 对象的子级。
     
     <p>最佳做法是，在卸载子 SWF 文件之前，您应该显式关闭子 SWF 文件的对象（如 LocalConnection、NetConnection、NetStream 和 Sound 对象）中的任何流。否则，子 SWF 文件中的音频可能会继续播放，即使已卸载子级 SWF 文件。要关闭子 SWF 文件中的流，请向子文件中添加事件侦听器以侦听 <codeph>unload</codeph> 事件。当父文件调用 <codeph>Loader.unload()</codeph> 时，将为子文件分派 <codeph>unload</codeph> 事件。以下代码显示了完成上述任务的方法：</p>
<pre>
function closeAllStreams(evt:Event) { 
    myNetStream.close();
    mySound.close();
    myNetConnection.close();
    myLocalConnection.close();
}

myMovieClip.loaderInfo.addEventListener(Event.UNLOAD, closeAllStreams);</pre>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.media.xml#Sound/close()"><linktext>flash.media.Sound.close()</linktext></link><link href="flash.net.xml#LocalConnection/close()"><linktext>flash.net.LocalConnection.close()</linktext></link><link href="flash.net.xml#NetConnection/close()"><linktext>flash.net.NetConnection.close()</linktext></link><link href="flash.net.xml#NetStream/close()"><linktext>flash.net.NetStream.close()</linktext></link><link href="../../operators.html#delete"><linktext>delete 运算符</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Loader:unloadAndStop"><apiName>unloadAndStop</apiName><shortdesc>
     尝试卸载子 SWF 文件内容并停止执行已加载的 SWF 文件中的命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>gc</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>提示垃圾回收器对 SWF 子对象执行 (<codeph>true</codeph>) 还是不执行 (<codeph>false</codeph>) 垃圾回收。如果要以异步方式卸载很多对象，则将 <codeph>gc</codeph> 参数设置为 <codeph>false</codeph> 可能会提高应用程序的性能。但是，如果将该参数设置为 <codeph>false</codeph>，则在运行 <codeph>unloadAndStop()</codeph> 命令之后，子 SWF 文件的媒体和显示对象可能还会保存在内存中。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     尝试卸载子 SWF 文件内容并停止执行已加载的 SWF 文件中的命令。此方法尝试通过删除对子 SWF 文件的 EventDispatcher、NetConnection、Timer、Sound 或 Video 对象的引用，从而卸载使用 <codeph>Loader.load()</codeph> 或 <codeph>Loader.loadBytes()</codeph> 加载的 SWF 文件。因此，针对子 SWF 文件和子 SWF 文件的显示列表将发生以下行为：
     <ul><li>停止声音。</li>
     <li>删除舞台事件侦听器。</li>
     <li>删除 <codeph>enterFrame</codeph>、<codeph>frameConstructed</codeph>、<codeph>exitFrame</codeph>、<codeph>activate</codeph> 和 <codeph>deactivate</codeph> 的事件侦听器。</li>
     <li>停止计时器。</li>
     <li>断开摄像机和麦克风实例</li>
     <li>停止影片剪辑。</li></ul>
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Loader:content:get"><apiName>content</apiName><shortdesc>
     包含使用 load() 或 loadBytes() 方法加载的 SWF 文件或图像（JPG、PNG 或 GIF）文件的根显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>加载的 SWF 文件或图像文件属于您无权访问的安全沙箱。对于加载的 SWF 文件，可以避免这种情况的方法是：使该文件调用 <codeph>Security.allowDomain()</codeph> 方法，或在您调用 <codeph>load()</codeph> 或 <codeph>loadBytes()</codeph> 方法时使加载文件指定 <codeph>loaderContext</codeph> 参数，并将该参数的 <codeph>securityDomain</codeph> 属性设置为 <codeph>SecurityDomain.currentDomain</codeph>。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     包含使用 <codeph>load()</codeph> 或 <codeph>loadBytes()</codeph> 方法加载的 SWF 文件或图像（JPG、PNG 或 GIF）文件的根显示对象。
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:Loader:contentLoaderInfo:get"><apiName>contentLoaderInfo</apiName><shortdesc>
     返回与正在加载的对象相对应的 LoaderInfo 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:LoaderInfo</apiValueClassifier></apiValueDef><apiDesc>
     返回与正在加载的对象相对应的 LoaderInfo 对象。LoaderInfo 对象在 Loader 对象和加载的内容对象之间共享。LoaderInfo 对象提供有关加载的文件的加载进度信息和统计。 
     
     <p>与加载相关的事件由 Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性引用的 LoaderInfo 对象分派。<codeph>contentLoaderInfo</codeph> 属性设置为有效的 LoaderInfo 对象（即使在加载内容之前），这样您就可以在加载前将事件侦听器添加到该对象。</p>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo"><linktext>flash.display.LoaderInfo</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
     NativeMenuItem 类表示菜单中的单个项目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     NativeMenuItem 类表示菜单中的单个项目。
     
     <p>菜单项可以是一个命令、一个子菜单或一条分隔线：</p> 
     
     <ul>
     <li>要创建一个命令项，请调用 NativeMenuItem 构造函数，为标签传递一个字符串，并为 <codeph>isSeparator</codeph> 参数传递 <codeph>false</codeph>。</li>
     
     <li>要创建一个子菜单，请为父菜单创建一个命令项，并将子菜单的 NativeMenu 对象分配给该命令项的 <codeph>submenu</codeph> 属性。也可以调用父级 NativeMenu 对象的 <codeph>addSubmenu()</codeph> 方法来创建该项并同时设置 <codeph>submenu</codeph> 属性。</li>
     
     <li>要创建一个分隔符，请调用 NativeMenuItem 构造函数，为标签传递一个空字符串，并为 <codeph>isSeparator</codeph> 参数传递 <codeph>true</codeph>。</li>
     </ul>
     
     <p>在一个项目或父菜单上侦听 <codeph>select</codeph> 事件可以检测何时选择某一菜单命令。子菜单和分隔符都不分派 select 事件。侦听 <codeph>displaying</codeph> 事件可以确定何时显示某一菜单项。</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     在显示包含此项目的菜单的前一刻由此 NativeMenuItem 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     在显示包含此项目的菜单的前一刻由此 NativeMenuItem 对象分派。 
     
	 <p>该事件对象的 <codeph>target</codeph> 属性将引用包含此 NativeMenuItem 对象的 NativeMenu 对象，<codeph>currentTarget</codeph> 属性将引用此 NativeMenuItem。</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenuItem_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     每当用户选择菜单项时分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     每当用户选择菜单项时分派。 
     
     <p><codeph>select</codeph> 事件将从此项目<i>冒泡</i> 到包含菜单，并贯穿父菜单链到达根菜单对象。该事件对象的 <codeph>target</codeph> 属性将引用此 NativeMenuItem 对象；<codeph>currentTarget</codeph> 属性将引用分派对象（此 NativeMenuItem 或祖先级 NativeMenu 对象）。</p>
	 
	 <p><b>注意：</b>如果包含该菜单的窗口处于全屏模式，则当用户输入键盘等效项作为菜单项时，NativeMenuItem 对象<i>不会</i> 分派 <codeph>select</codeph> 事件。不过，可以侦听由 NativeWindow 对象的 <codeph>stage</codeph> 属性分派的 <codeph>keyDown</codeph> 事件。</p>
       
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeMenuItem:NativeMenuItem"><apiName>NativeMenuItem</apiName><shortdesc>
         创建新的 NativeMenuItem 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData/><apiDesc>用于该项目的显示标签，或用于分隔符的空字符串。
         </apiDesc></apiParam><apiParam><apiItemName>isSeparator</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>设置为 <codeph>true</codeph> 可创建分隔符；否则设置为 <codeph>false</codeph>。
         
         </apiDesc></apiParam></apiConstructorDef><apiDesc>
         创建新的 NativeMenuItem 对象。
         
         <p>要创建一个菜单命令，请将 <codeph>label</codeph> 参数设置为包含该显示标签的字符串，并将 <codeph>isSeparator</codeph> 设置为 <codeph>false</codeph>。</p>
	     
	     <p>要创建一个子菜单命令，请创建一个命令项，然后将子菜单的 NativeMenu 对象分配给该命令项的 <codeph>submenu</codeph> 属性。将该项添加到父菜单。</p>
		  
	     <p>要创建一个分隔符，请将 <codeph>label</codeph> 参数设置为空字符串，并将 <codeph>isSeparator</codeph> 设置为 <codeph>true</codeph>。</p>
         
         <p>使用 NativeMenu <codeph>addItem()</codeph> 和 <codeph>removeItem()</codeph> 方法在菜单中添加和删除项目。</p>
         
         </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeMenuItem:clone"><apiName>clone</apiName><shortdesc>
         创建 NativeMenuItem 对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         创建 NativeMenuItem 对象的副本。
         
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenuItem:toString"><apiName>toString</apiName><shortdesc>
         返回一个字符串，其中包含 NativeMenuItem 对象的所有属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>一个字符串，其中包含 Event 对象的所有属性。
		 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
         返回一个字符串，其中包含 NativeMenuItem 对象的所有属性。
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenuItem:checked:get"><apiName>checked</apiName><shortdesc>
         控制此菜单项是否显示复选标记。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         控制此菜单项是否显示复选标记。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:data:get"><apiName>data</apiName><shortdesc>
         与此菜单项关联的任意数据对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
         与此菜单项关联的任意数据对象。
         
         <p>可以向此属性分配任何对象。分配的对象不会由菜单系统使用，但可供事件处理代码使用，（通过事件对象的 target 属性）。默认情况下，此属性的值为 <codeph>null</codeph>。</p>
           
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:enabled:get"><apiName>enabled</apiName><shortdesc>
         控制是否启用此菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         控制是否启用此菜单项。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:isSeparator:get"><apiName>isSeparator</apiName><shortdesc>
         报告此项目是否为菜单分隔线。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
         报告此项目是否为菜单分隔线。
         
         <p>通过将 NativeMenuItem 构造函数中的 <codeph>isSeparator</codeph> 属性设置为 <codeph>true</codeph> 创建一条分隔线。</p> 
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalent:get"><apiName>keyEquivalent</apiName><shortdesc>
         此菜单项的等效键。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         此菜单项的等效键。
		 
		 <p>使用小写字母设置 <codeph>keyEquivalent</codeph> 可以分配无 Shift 功能键的快捷键。使用大写字母设置此属性可以分配具有 Shift 功能键的快捷键。</p>
		 
		 <p>默认情况下，等效功能键（Windows 或 Linux 中为 Ctrl，Mac OS X 中为 Command）作为等效键的一部分包括在内。如果希望等效键是一个没有修饰符的键，可将 <codeph>keyEquivalentModifiers</codeph> 属性设置为一个空数组。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:keyEquivalentModifiers:get"><apiName>keyEquivalentModifiers</apiName><shortdesc>
         等效功能键的键控代码数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         等效功能键的键控代码数组。
         
         <p>使用 Keyboard 类中定义的常量可以指定功能键代码。有效的功能键包括：</p>
         <ul>
         <li><codeph>Keyboard.ALTERNATE</codeph></li>
         <li><codeph>Keyboard.COMMAND</codeph></li>
         <li><codeph>Keyboard.CONTROL</codeph></li>
         </ul>
		 
		 <p>如果未指定任何功能键，则默认情况下，将在 Windows 或 Linux 中分配 <codeph>Keyboard.CONTROL</codeph> 键，在 Mac OS X 中分配 <codeph>Keyboard.COMMAND</codeph> 键。如果不希望等效键包括这些功能键，可将此属性设置为空数组。</p>
		 
		 <p>如果为 <codeph>keyEquivalent</codeph> 属性分配一个大写字母，则会自动将 Shift 键用作修饰符。将 <codeph>keyEquivalentModifier</codeph> 设置为一个空数组不会撤消将 Shift 键用作修饰符。</p> 
         
         </apiDesc></apiValueDetail><related-links><link href="flash.ui.xml#Keyboard"><linktext>flash.ui.Keyboard</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeMenuItem:label:get"><apiName>label</apiName><shortdesc>
         此菜单项的显示字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         此菜单项的显示字符串。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:menu:get"><apiName>menu</apiName><shortdesc>
         包含此项目的菜单。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         包含此项目的菜单。  
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:mnemonicIndex:get"><apiName>mnemonicIndex</apiName><shortdesc>
         菜单项标签中的助记键字符的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         菜单项标签中的助记键字符的位置。
         
         <p>位于指定位置的字符是该菜单项的助记键字符。索引是从 0 开始的，所以第一个字符的索引为 0。</p>
         
         <p>在不使用菜单助记键的操作系统中将忽略此属性。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:name:get"><apiName>name</apiName><shortdesc>
         此菜单项的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         此菜单项的名称。  
         
         <p>名称值不显示，并可用作独立于区域设置的标识符。不自动分配名称。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenuItem:submenu:get"><apiName>submenu</apiName><shortdesc>
		 与此菜单项关联的子菜单。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
		 与此菜单项关联的子菜单。  
		 
		 <p>将 NativeMenu 对象分配给此属性将更改该菜单项的外观和行为。子菜单项将显示子菜单图标，并且不再分派 select 事件。</p>
         
        <p><b>注意：</b>将菜单添加为其自身的一个子菜单（在循环引用中）可能导致应用程序挂起。</p>
        
         </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu/addSubmenu()"><linktext>flash.display.NativeMenu.addSubmenu()</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeMenu"><apiName>NativeMenu</apiName><shortdesc>
     NativeMenu 类包含用于定义菜单的方法和属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
     NativeMenu 类包含用于定义菜单的方法和属性。
     
     <p>AIR 支持以下类型的菜单：</p>
     <adobetable class="innertable">
     
     
     
     
     
     
     
     <tgroup cols="5"><thead><row><entry>Menu</entry><entry>实例</entry><entry>功能测试</entry><entry>支持平台</entry><entry>默认提供?</entry></row></thead><tbody><row><entry> 应用程序</entry><entry><codeph>NativeApplication.nativeApplication.menu</codeph></entry><entry><codeph>NativeApplication.supportsMenu</codeph></entry><entry>Mac OS X</entry><entry>是</entry></row><row><entry>窗口</entry><entry><codeph>NativeWindow.menu</codeph></entry><entry><codeph>NativeWindow.supportsMenu</codeph></entry><entry>Windows、Linux</entry><entry>否</entry></row><row><entry>停靠图标</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsDockIcon</codeph></entry><entry>Mac OS X</entry><entry>是</entry></row><row><entry>系统任务栏图标</entry><entry><codeph>NativeApplication.nativeApplication.icon.menu</codeph></entry><entry><codeph>NativeApplication.supportsSystemTrayIcon</codeph></entry><entry>Windows、Linux</entry><entry>否</entry></row><row><entry>上下文</entry><entry><codeph>InteractiveObject.contextMenu</codeph></entry><entry>始终支持</entry><entry>全部</entry><entry>否</entry></row><row><entry>弹出菜单</entry><entry>任何 NativeMenu 实例</entry><entry>始终支持</entry><entry>全部</entry><entry>否</entry></row></tbody></tgroup></adobetable>
     
     <p>菜单可以包含命令项、子菜单项和分隔线项。菜单项是使用 <codeph>addItem()</codeph>、<codeph>addItemAt()</codeph>、<codeph>addSubmenu()</codeph> 和 <codeph>addSubmenuAt()</codeph> 方法添加到菜单中的。菜单项的显示顺序与菜单项在菜单的 <codeph>items</codeph> 数组中的顺序相符。</p>
      
     <p>子菜单是通过父菜单的匹配菜单项的 <codeph>submenu</codeph> 属性附加到其父菜单的。窗口和应用程序菜单的根菜单必须只包含子菜单项；没有子菜单的项目可能不予显示，它们与用户对这些菜单类型的预期相反。</p>
     
     <p>当选择了菜单中的命令项或其子菜单之一时，菜单将分派 <codeph>select</codeph> 事件。（子菜单和分隔符项不可选择。）事件对象的 <codeph>target</codeph> 属性将引用所选项目。</p>
     
     <p>在显示菜单的前一刻，菜单将分派 <codeph>displaying</codeph> 事件。您可以根据应用程序的当前状态使用此事件来更新菜单内容。</p> 
     
     <p platform="actionscript"><b>注意：</b>您可用使用 NativeMenu 或 ContextMenu 对象来设置上下文菜单。Flash Player 仅支持 ContextMenu 类，不支持 NativeMenu 类。
	 </p>
     
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject/contextMenu"><linktext>flash.display.InteractiveObject.contextMenu</linktext></link><link href="flash.display.xml#NativeMenuItem"><linktext>flash.display.NativeMenuItem</linktext></link><link href="flash.display.xml#NativeWindow/menu"><linktext>flash.display.NativeWindow.menu</linktext></link><link href="flash.desktop.xml#DockIcon"><linktext>flash.desktop.DockIcon</linktext></link><link href="flash.desktop.xml#SystemTrayIcon"><linktext>flash.desktop.SystemTrayIcon</linktext></link><link href="flash.desktop.xml#NativeApplication/menu"><linktext>flash.desktop.NativeApplication.menu</linktext></link><link href="flash.desktop.xml#NativeApplication/icon"><linktext>flash.desktop.NativeApplication.icon</linktext></link></related-links><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.DISPLAYING_displaying"><apiName>displaying</apiName><shortdesc>
     在显示菜单的前一刻由此 NativeMenu 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DISPLAYING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     在显示菜单的前一刻由此 NativeMenu 对象分派。 
     
     <p>侦听此事件可在显示菜单之前更新菜单。菜单中的项目也分派 displaying 事件。</p>
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeMenu_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
     在选择其菜单项之一或其后代子菜单之一中的项目时由此 NativeMenu 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
     在选择其菜单项之一或其后代子菜单之一中的项目时由此 NativeMenu 对象分派。 
     
     <p>select 事件将从菜单项<i>冒泡</i> 到包含它的菜单，并贯穿父菜单链到达根菜单对象。该事件对象的 <codeph>target</codeph> 属性将引用所选的 NativeMenuItem 对象；<codeph>currentTarget</codeph> 属性将引用此 NativeMenu 对象。</p>  
     
     </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:NativeMenu:addItem"><apiName>addItem</apiName><shortdesc>
         在菜单底部添加一个菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>item</codeph> 为 <codeph>null</codeph>。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>item</codeph> 为其它菜单的成员。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>要在菜单底部添加的 NativeMenuItem 对象。
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         在菜单底部添加一个菜单项。
         
         <p platform="actionscript">创建上下文菜单时，可以添加 NativeMenuItem 或 ContextMenuItem 对象。但是，建议在上下文菜单中仅使用一种类型的对象，以使菜单中的所有项都具有相同的属性。</p>
         
         <p><b>注意：</b>将一个项添加到菜单时，如果该项的子菜单设置为菜单本身（造成循环引用），可能导致应用程序挂起。</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addItemAt"><apiName>addItemAt</apiName><shortdesc>
         在指定位置插入一个菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>item</codeph> 为 <codeph>null</codeph>。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果 <codeph>item</codeph> 为其它菜单的成员。
         </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果 index 位于菜单的 <codeph>items</codeph> 数组的范围以外。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>要插入的 NativeMenuItem 对象。
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>菜单中要插入该菜单项的位置（从 0 开始）。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         在指定位置插入一个菜单项。
         
         <p><b>注意：</b>将一个项添加到菜单时，如果该项的子菜单设置为菜单本身（造成循环引用），可能导致应用程序挂起。</p>
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenu"><apiName>addSubmenu</apiName><shortdesc>
        通过插入新菜单项，在菜单中添加子菜单。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>为该子菜单创建的 NativeMenuItem 对象。 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>定义要添加的子菜单的 NativeMenu 对象。
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要添加的菜单项的显示标签。
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        通过插入新菜单项，在菜单中添加子菜单。
        
        <p>调用 <codeph>addSubMenu()</codeph> 方法等效于创建一个新菜单项、将其添加到菜单，并将 NativeMenu 对象分配给该项目的 <codeph>submenu</codeph> 属性。</p>
        
        <p><b>注意：</b>将菜单添加为其自身的一个子菜单（在循环引用中）可能导致应用程序挂起。</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:addSubmenuAt"><apiName>addSubmenuAt</apiName><shortdesc>
        通过在指定位置插入新菜单项，在菜单中添加子菜单。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>为该子菜单创建的 NativeMenuItem 对象。 
		</apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>submenu</apiItemName><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier><apiDesc>定义要添加的子菜单的 NativeMenu 对象。
        </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>此菜单的 <codeph>items</codeph> 数组中要插入将添加的菜单项的位置。
        </apiDesc></apiParam><apiParam><apiItemName>label</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要添加的菜单项的显示标签。
        
        </apiDesc></apiParam></apiOperationDef><apiDesc>
        通过在指定位置插入新菜单项，在菜单中添加子菜单。
        
        <p>调用 <codeph>addSubMenuAt()</codeph> 方法等效于创建一个新菜单项、将其插入到菜单中需要的位置，并将 NativeMenu 对象分配给该项目的 <codeph>submenu</codeph> 属性。</p>
        
        <p><b>注意：</b>将菜单添加为其自身的一个子菜单（在循环引用中）可能导致应用程序挂起。</p>
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:clone"><apiName>clone</apiName><shortdesc>
        
        创建菜单和所有项目的副本。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.display:NativeMenu</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
        
        创建菜单和所有项目的副本。
        
		</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:containsItem"><apiName>containsItem</apiName><shortdesc>
         报告此菜单是否包含指定的菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 <codeph>item</codeph> 位于此菜单中，则为 <codeph>true</codeph>。
         
         </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>要查找的 NativeMenuItem 对象。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         报告此菜单是否包含指定的菜单项。
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:display"><apiName>display</apiName><shortdesc>
        在指定位置弹出此菜单。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>stage</apiItemName><apiOperationClassifier>flash.display:Stage</apiOperationClassifier><apiDesc>要显示此菜单的 Stage 对象。
		
        </apiDesc></apiParam><apiParam><apiItemName>stageX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>相对于要显示此菜单的舞台原点的水平像素数。
		
        </apiDesc></apiParam><apiParam><apiItemName>stageY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>相对于要显示此菜单的舞台原点的垂直像素数。
		
		</apiDesc></apiParam></apiOperationDef><apiDesc>
        在指定位置弹出此菜单。
        
        </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemAt"><apiName>getItemAt</apiName><shortdesc>
         获取指定索引处的菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>index</codeph> 位于此菜单的 <codeph>items</codeph> 数组的范围以外。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>位于菜单中指定位置的 NativeMenuItem 对象。
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要返回的项目的位置（从 0 开始）。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         获取指定索引处的菜单项。  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemByName"><apiName>getItemByName</apiName><shortdesc>
         获取具有指定名称的菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>具有指定名称的 NativeMenuItem 对象，如果菜单中没有这样的项目，则为 <codeph>null</codeph>。
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要查找的字符串。
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         获取具有指定名称的菜单项。
         
         <p><b>注意：</b>默认情况下不分配菜单项的 <codeph>name</codeph> 属性。</p>
            
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:getItemIndex"><apiName>getItemIndex</apiName><shortdesc>
         获取指定项目的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>此菜单中指定项目的位置（从 0 开始），如果该项目不在此菜单中，则为 <codeph>null</codeph>。
         
         </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>要查找的 NativeMenuItem 对象.
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         获取指定项目的位置。 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeAllItems"><apiName>removeAllItems</apiName><shortdesc>
         删除菜单中的所有项目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
         删除菜单中的所有项目。  
         
         
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItem"><apiName>removeItem</apiName><shortdesc>
         删除指定的菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>item</codeph> 不在此菜单中
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>要从此菜单删除的 NativeMenuItem 对象。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         删除指定的菜单项。 
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:removeItemAt"><apiName>removeItemAt</apiName><shortdesc>
         删除并返回指定索引处的菜单项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>index</codeph> 位于此菜单的 <codeph>items</codeph> 数组的范围以外。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>已删除的 NativeMenuItem 对象。
         
         </apiDesc><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要删除的项目的位置（从 0 开始）。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         删除并返回指定索引处的菜单项。  
         
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeMenu:setItemIndex"><apiName>setItemIndex</apiName><shortdesc>
         将菜单项移到指定位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>index</codeph> 位于此菜单的 <codeph>items</codeph> 数组的范围以外。
         
         </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>item</apiItemName><apiOperationClassifier>flash.display:NativeMenuItem</apiOperationClassifier><apiDesc>要移动的 NativeMenuItem 对象。
         </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>菜单中要将 <codeph>item</codeph> 移动到的位置（从 0 开始）。
         
         </apiDesc></apiParam></apiOperationDef><apiDesc>
         将菜单项移到指定位置。如果菜单中还没有该项目，调用此方法时会将项目添加到菜单中。
         
         </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeMenu:items:get"><apiName>items</apiName><shortdesc>
         此菜单中 NativeMenuItem 对象的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
         此菜单中 NativeMenuItem 对象的数组。
         
         <p>数组按显示顺序排序。</p>
         
         <p><i>注意：</i>此属性在 AIR 1.0 中是只读的， 而在 AIR 1.1 中则变为可读/写的。</p>
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:numItems:get"><apiName>numItems</apiName><shortdesc>
         此菜单中 NativeMenuItem 对象的数量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         此菜单中 NativeMenuItem 对象的数量。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeMenu:parent:get"><apiName>parent</apiName><shortdesc>
         父菜单。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
         父菜单。  
         
         <p>根（顶级）菜单对象的 <codeph>parent</codeph> 为 <codeph>null</codeph>。</p>
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
DisplayObjectContainer 类是可用作显示列表中显示对象容器的所有对象的基类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>可以包含子对象的所有显示对象的抽象基类。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
DisplayObjectContainer 类是可用作显示列表中显示对象容器的所有对象的基类。该显示列表管理在 Flash Player 或 Adobe AIR 中显示的所有对象。使用 DisplayObjectContainer 类排列显示列表中的显示对象。每个 DisplayObjectContainer 对象都有自己的子级列表，用于组织对象的 Z 轴顺序。Z 轴顺序是由前至后的顺序，可确定哪个对象绘制在前，哪个对象绘制在后等。 
 
 <p>DisplayObject 是一种抽象基类；因此，不能直接调用 DisplayObject。调用 <codeph>new DisplayObject()</codeph> 会引发 <codeph>ArgumentError</codeph> 异常。</p>
 
 DisplayObjectContainer 类是可以包含子对象的所有对象的抽象基类。无法直接对其进行实例化；调用 <codeph>new DisplayObjectContainer()</codeph> 构造函数会引发 <codeph>ArgumentError</codeph> 异常。
 
 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“显示编程”一章。</p>
 
 </apiDesc><example conref="examples\DisplayObjectContainerExample.as"> 下例使用类 <codeph>DisplayObjectContainerExample</codeph> 连续创建五个橙色正方形。执行下列步骤可完成该任务：
 
 <ol>
     <li>构造函数调用 <codeph>configureAssets()</codeph> 方法。</li>
 
  <li><codeph>configureAssets()</codeph> 方法创建 <codeph>child</codeph> 和 <codeph>lastChild</codeph> Sprite 对象。</li>
 
    <li><codeph>for</codeph> 循环创建 5 个橙色正方形并依次放置它们。</li>
 
     <li>每次创建 CustomSprite 对象时，其构造函数都调用 <codeph>CustomSprite</codeph> 对象的 <codeph>draw()</codeph> 方法，该方法通过调用 Graphics 类的 <codeph>beginFill()</codeph>、<codeph>drawRect()</codeph> 和 <codeph>endFill()</codeph> 方法创建 50 x 50 像素的正方形。<codeph>addChild()</codeph> 将每个正方形添加到显示列表。</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Sprite;

    public class DisplayObjectContainerExample extends Sprite {
        private var gutter:uint     = 5;
        private var childCount:uint = 5;

        public function DisplayObjectContainerExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var child:Sprite = new CustomSprite();
            var lastChild:Sprite = child;
            for (var i:uint = 1; i &lt;= childCount; i++) {
                child = new CustomSprite();
                child.x = lastChild.x + lastChild.width + gutter;
                addChild(child);
                lastChild = child;
            }
        }
    }
}

import flash.display.Sprite;

class CustomSprite extends Sprite {
    private var size:uint = 50;
    private var bgColor:uint = 0xFFCC00;

    public function CustomSprite() {
        draw(size, size);
    }

    private function draw(w:uint, h:uint):void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, w, h);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><apiConstructor id="flash.display:DisplayObjectContainer:DisplayObjectContainer"><apiName>DisplayObjectContainer</apiName><shortdesc>
	调用新的 DisplayObjectContainer() 构造函数会引发 ArgumentError 异常。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	调用 <codeph>new DisplayObjectContainer()</codeph> 构造函数会引发 <codeph>ArgumentError</codeph> 异常。但是，<i>可以</i>调用 DisplayObjectContainer 的以下子类的构造函数：
	
	<ul>
	
		<li><codeph>new Loader()</codeph></li>
		<li><codeph>new Sprite()</codeph></li>
		<li><codeph>new MovieClip()</codeph></li>
	
	</ul>
	
 	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:DisplayObjectContainer:addChild"><apiName>addChild</apiName><shortdesc>
     将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子项与父项相同时引发。此外，当调用方是要添加的子项的子项（即孙项等）时也会引发。
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>在 <codeph>child</codeph> 参数中传递的 DisplayObject 实例。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>向此 DisplayObjectContainer 示例中添加子对象。
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。子项将被添加到该 DisplayObjectContainer 实例中其它所有子项的前（上）面。（要将某子项添加到特定索引位置，请使用 <codeph>addChildAt()</codeph> 方法。）
     
	 <p>如果添加一个已将其它显示对象容器作为父项的子对象，则会从其它显示对象容器的子列表中删除该对象。 </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> 下例设置了两个名称分别为 <codeph>container1</codeph> 和 <codeph>container2</codeph> 的 Sprite 对象。Sprite 是一种显示对象容器。该示例调用 <codeph>addChild()</codeph> 方法以设置显示层次结构：<codeph>container1</codeph> 是 <codeph>container2</codeph> 的子项，其它两个显示对象 <codeph>circle1</codeph> 和 <codeph>circle2</codeph> 是 <codeph>container1</codeph> 的子项。<codeph>trace()</codeph> 方法的调用显示每个对象的子项数。请注意，孙项并不包括在 <codeph>numChildren</codeph> 计数中：
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChild_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>将显示对象添加到显示列表中时分派。
     </apiDesc></adobeApiEventDetail><shortdesc>将显示对象添加到显示列表中时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子级列表中不存在索引位置时引发。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>在子项与父项相同时引发。此外，当调用方是要添加的子项的子项（即孙项等）时也会引发。
 	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>在 <codeph>child</codeph> 参数中传递的 DisplayObject 实例。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>添加该子项的索引位置。  如果指定当前占用的索引位置，则该位置以及所有更高位置上的子对象会在子级列表中上移一个位置。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>向此 DisplayObjectContainer 示例中添加子对象。
     
  	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。该子项将被添加到指定的索引位置。索引为 0 表示该 DisplayObjectContainer 对象的显示列表的后（底）部。
	 
	 <p>例如，下例在索引位置 0、2、1 处分别显示 a、b、c 三个显示对象：</p>
	 
	 <p><adobeimage alt="b 在 c 之上，c 在 a 之上" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>如果添加一个已将其它显示对象容器作为父项的子对象，则会从其它显示对象容器的子列表中删除该对象。 </p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.addChildAt.1.as"> 下例创建一个 <codeph>container</codeph> 显示对象容器，并将一个显示对象 <codeph>circle1</codeph> 添加到其显示列表。然后，通过调用 <codeph>container.addChildAt(circle2, 0)</codeph>，它将 <codeph>circle2</codeph> 对象添加到索引位置零（后面），并将 <codeph>circle1</codeph> 对象移动到索引位置 1：
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
var circle2:Sprite = new Sprite();

container.addChild(circle1);
container.addChildAt(circle2, 0);

trace(container.getChildAt(0) == circle2); // true
trace(container.getChildAt(1) == circle1); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChild()"><linktext>addChild()</linktext></link></related-links><adobeApiEvent id="flash.display:DisplayObjectContainer:addChildAt_added"><apiName>added</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>将显示对象添加到显示列表中时分派。
     </apiDesc></adobeApiEventDetail><shortdesc>将显示对象添加到显示列表中时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:areInaccessibleObjectsUnderPoint"><apiName>areInaccessibleObjectsUnderPoint</apiName><shortdesc>
	 指示安全限制是否会导致出现以下情况：在列表中忽略了使用指定 point 点调用 DisplayObjectContainer.getObjectsUnderPoint() 方法时返回的所有显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果点包含具有安全限制的子显示对象，则为 <codeph>true</codeph>。
	 
 	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要查看其下方内容的点。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指示安全限制是否会导致出现以下情况：在列表中忽略了使用指定 <codeph>point</codeph> 点调用 <codeph>DisplayObjectContainer.getObjectsUnderPoint()</codeph> 方法时返回的所有显示对象。默认情况下，一个域中的内容无法访问另一个域中的对象，除非通过调用 <codeph>Security.allowDomain()</codeph> 方法而允许它们这样做。 
	 
	 <p>有关详细信息，请参阅以下部分： </p>
	 
     <ul>
     
     <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
     <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
     
     <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_cn" scope="external">安全性</xref></li>
     </ul>     
     
	 <p><codeph>point</codeph> 参数位于舞台的坐标空间中，此坐标空间可能与显示对象容器的坐标空间不同（除非显示对象容器是舞台）。您可以使用 <codeph>globalToLocal()</codeph> 和 <codeph>localToGlobal()</codeph> 方法在这些坐标空间之间转换点。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.areInaccessibleObjectsUnderPoint.as"> 下面的代码将创建一个名为 <codeph>container</codeph> 的显示对象容器。下一个代码块使用 Loader 对象从远程文件服务器中加载一个名为“test.jpg”的 JPEG 文件。请注意，LoaderContext 对象的 <codeph>checkPolicyFile</codeph> 属性（在 <codeph>load()</codeph> 方法中用作参数）被设置为 <codeph>false</codeph>。加载了该文件后，代码将调用 <codeph>loaded()</codeph> 方法，后者又将调用 <codeph>container.areInaccessibleObjectsUnderPoint()</codeph>，这将返回 <codeph>true</codeph> 值，因为假定被加载的内容来自无法访问的域：
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.system.LoaderContext;
import flash.net.URLRequest;
import flash.events.Event;
import flash.geom.Point;

var container:Sprite = new Sprite();

var urlReq:URLRequest = new URLRequest("http://localhost/RemoteFile.swf");
var ldr:Loader = new Loader();
var context:LoaderContext = new LoaderContext();
context.checkPolicyFile = false;
ldr.load(urlReq, context);

ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);

function loaded(event:Event):void {
    var pt:Point = new Point(1, 1);
    trace(container.areInaccessibleObjectsUnderPoint(pt)); // true
}

function urlNotFound(event:Event):void {
    trace("The URL was not found."); 
}
</codeblock> 此示例假定由此代码生成的 SWF 文件从与 JPEG 文件不同的域中加载，并且加载的 JPEG 文件占用点 (1, 1)。 
</example></apiOperationDetail><related-links><link href="flash.system.xml#Security/allowDomain()"><linktext>flash.system.Security.allowDomain()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getObjectsUnderPoint()"><linktext>getObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:contains"><apiName>contains</apiName><shortdesc>
	 确定指定显示对象是 DisplayObjectContainer 实例的子项还是该实例本身。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 <codeph>child</codeph> 对象是 DisplayObjectContainer 的子项或容器本身，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	  
	  </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要测试的子对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 确定指定显示对象是 DisplayObjectContainer 实例的子项还是该实例本身。搜索包括整个显示列表（其中包括此 DisplayObjectContainer 实例）。孙项、曾孙项等，每项都返回 <codeph>true</codeph>。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.contains.1.as"> 下例设置多个 Sprite 对象并将其中一些对象添加到其它对象的子列表中。（Sprite 对象是一种显示对象容器。） 通过调用 <codeph>contains()</codeph> 方法可显示各种对象之间的关系：
<codeblock>
import flash.display.Sprite;

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();
var sprite4:Sprite = new Sprite();

sprite1.addChild(sprite2);
sprite2.addChild(sprite3);

trace(sprite1.contains(sprite1)); // true
trace(sprite1.contains(sprite2)); // true
trace(sprite1.contains(sprite3)); // true
trace(sprite1.contains(sprite4)); // false
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildAt"><apiName>getChildAt</apiName><shortdesc>
     返回位于指定索引处的子显示对象实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子级列表中不存在索引时引发。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>此子显示对象属于您无权访问的沙箱。通过让子影片调用 <codeph>Security.allowDomain()</codeph>，可以避免发生这种情况。
     
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>位于指定索引位置处的子显示对象。
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>子对象的索引位置。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回位于指定索引处的子显示对象实例。
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildAt.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后将 3 个显示对象添加到 <codeph>container</codeph> 对象的子级列表。<codeph>getChildAt()</codeph> 方法的调用随后会显示这些子对象的位置：
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
var sprite2:Sprite = new Sprite();
var sprite3:Sprite = new Sprite();

container.addChild(sprite1);
container.addChild(sprite2);
container.addChildAt(sprite3, 0);

trace(container.getChildAt(0) == sprite3); // true
trace(container.getChildAt(1) == sprite1); // true
trace(container.getChildAt(2) == sprite2); // true
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildByName()"><linktext>getChildByName()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildByName"><apiName>getChildByName</apiName><shortdesc>
     返回具有指定名称的子显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>此子显示对象属于您无权访问的沙箱。通过让子影片调用 <codeph>Security.allowDomain()</codeph> 方法，可以避免发生这种情况。
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>具有指定名称的子显示对象。
     
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>name</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要返回的子项的名称。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回具有指定名称的子显示对象。如果多个子显示对象具有指定名称，则该方法会返回子级列表中的第一个对象。
     
	 <p><codeph>getChildAt()</codeph> 方法比 <codeph>getChildByName()</codeph> 方法快。<codeph>getChildAt()</codeph> 方法从缓存数组中访问子项，而 <codeph>getChildByName()</codeph> 方法则必须遍历链接的列表来访问子项。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后向该容器中添加两个子显示对象。然后，代码会调用 <codeph>getChildByName()</codeph> 和 <codeph>getChildIndex()</codeph> 方法来返回具有 <codeph>name "sprite1"</codeph> 的 <codeph>container</codeph> 对象子项的索引位置。
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/getChildAt()"><linktext>getChildAt()</linktext></link><link href="flash.display.xml#DisplayObject/name"><linktext>flash.display.DisplayObject.name</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getChildIndex"><apiName>getChildIndex</apiName><shortdesc>
     返回 DisplayObject 的 child 实例的索引位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子参数不是此对象的子项时引发。
     
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>要标识的子显示对象的索引位置。
     
     </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要标识的 DisplayObject 实例。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>返回 DisplayObject 子实例的索引编号。
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     返回 DisplayObject 的 <codeph>child</codeph> 实例的索引位置。
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getChildByName.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后向该容器中添加两个子显示对象。然后，代码会调用 <codeph>getChildByName()</codeph> 和 <codeph>getChildIndex()</codeph> 方法来返回具有 <codeph>name "sprite1"</codeph> 的 <codeph>container</codeph> 对象子项的索引位置。
<codeblock>
import flash.display.Sprite;
import flash.display.DisplayObject;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

var target:DisplayObject = container.getChildByName("sprite1"); 
trace(container.getChildIndex(target)); // 0
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:getObjectsUnderPoint"><apiName>getObjectsUnderPoint</apiName><shortdesc>
     返回对象的数组，这些对象位于指定点下，并且是该 DisplayObjectContainer 实例的子项（或孙子项，依此类推）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个对象数组，这些对象位于指定点下方，并且是该 DisplayObjectContainer 实例的子项（或孙项等等）。
     
 	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>point</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要查看其下方内容的点。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回对象的数组，这些对象位于指定点下，并且是该 DisplayObjectContainer 实例的子项（或孙子项，依此类推）。返回的数组中将省略出于安全原因而无法访问的任何子对象。要确定此安全限制是否影响返回的数组，请调用 <codeph>areInaccessibleObjectsUnderPoint()</codeph> 方法。
	 
	 <p><codeph>point</codeph> 参数位于舞台的坐标空间中，此坐标空间可能与显示对象容器的坐标空间不同（除非显示对象容器是舞台）。您可以使用 <codeph>globalToLocal()</codeph> 和 <codeph>localToGlobal()</codeph> 方法在这些坐标空间之间转换点。</p>
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.getObjectsUnderPoint.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后向该容器中添加两个重叠的子显示对象。然后，代码会调用 <codeph>getObjectsUnderPoint()</codeph> 两次（第一次使用只接触到一个对象的点，第二次使用对象的重叠点），并且返回数组的 <codeph>length</codeph> 将显示容器中每个点上的对象数量：
<codeblock>
import flash.display.Sprite;
import flash.geom.Point;

var container:Sprite = new Sprite();

var square1:Sprite = new Sprite();
square1.graphics.beginFill(0xFFCC00);
square1.graphics.drawRect(0, 0, 40, 40);

var square2:Sprite = new Sprite();
square2.graphics.beginFill(0x00CCFF);
square2.graphics.drawRect(20, 0, 30, 40);

container.addChild(square1);
container.addChild(square2);

var pt:Point = new Point(10, 20);
var objects:Array = container.getObjectsUnderPoint(pt); 
trace(objects.length); // 1

pt = new Point(35, 20);
objects = container.getObjectsUnderPoint(pt);
trace(objects.length);  // 2
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/areInaccessibleObjectsUnderPoint()"><linktext>areInaccessibleObjectsUnderPoint()</linktext></link><link href="flash.display.xml#DisplayObject/globalToLocal()"><linktext>DisplayObject.oLocal()</linktext></link><link href="flash.display.xml#DisplayObject/localToGlobal()"><linktext>DisplayObject.localToGlobal()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChild"><apiName>removeChild</apiName><shortdesc>
	 从 DisplayObjectContainer 实例的子列表中删除指定的 child DisplayObject 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子参数不是此对象的子项时引发。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>在 <codeph>child</codeph> 参数中传递的 DisplayObject 实例。
	 
	 </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要删除的 DisplayObject 实例。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>删除 DisplayObjectContainer 实例中的子显示对象。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 从 DisplayObjectContainer 实例的子列表中删除指定的 <codeph>child</codeph> DisplayObject 实例。将已删除子项的 <codeph>parent</codeph> 属性设置为 <codeph>null</codeph>；如果不存在对该子项的任何其它引用，则将该对象作为垃圾回收。DisplayObjectContainer 中该子项之上的任何显示对象的索引位置都减去 1。
	 
	 <p>垃圾回收器重新分配未使用的内存空间。当在某处变量或对象不再被主动地引用或存储时，如果不存在对该变量或对象的任何其它引用，则垃圾回收器将清理并擦除其过去占用的内存空间。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChild.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后向该容器中添加两个子显示对象。将事件侦听器添加到 <codeph>container</codeph> 对象，以便在用户单击容器的子对象时，<codeph>removeChild()</codeph> 方法从容器的子级列表中删除单击的子项：
<codeblock>
 
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);

container.addChild(circle1);
container.addChild(circle2);

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    container.removeChild(DisplayObject(event.target)); 
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 从 DisplayObjectContainer 的子级列表中指定的索引位置删除子级 DisplayObject。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>此子显示对象属于执行调用的对象无权访问的沙箱。通过让子影片调用 <codeph>Security.allowDomain()</codeph> 方法，可以避免发生这种情况。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>在子级列表中不存在索引时引发。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiDesc>已删除的 DisplayObject 实例。
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要删除的 DisplayObject 的子索引。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>从 DisplayObjectContainer 实例中删除指定 <codeph>index</codeph> 位置上的子显示对象。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 从 DisplayObjectContainer 的子列表中指定的 <codeph>index</codeph> 位置删除子 DisplayObject。将已删除子项的 <codeph>parent</codeph> 属性设置为 <codeph>null</codeph>；如果没有对该子项的任何其它引用，则将该对象作为垃圾回收。DisplayObjectContainer 中该子项之上的任何显示对象的索引位置都减去 1。
	 
	 <p>垃圾回收器重新分配未使用的内存空间。当在某处变量或对象不再被主动地引用或存储时，如果不存在对该变量或对象的任何其它引用，则垃圾回收器将清理并擦除其过去占用的内存空间。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.removeChildAt.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后向该容器中添加两个子显示对象。接着代码会显示：当您调用 <codeph>removeChildAt()</codeph> 方法以删除最低索引位置 (0) 上的子项时，列表中的任何其它子对象将下移一个位置：
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.numChildren) // 2
container.removeChildAt(0); 
trace(container.numChildren) // 1
trace(container.getChildAt(0).name); // sprite2
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	更改现有子项在显示对象容器中的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子级列表中不存在索引时引发。
     </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiException><apiDesc>在子参数不是此对象的子项时引发。
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要为其更改索引编号的 DisplayObject 子实例。
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>生成的 <codeph>child</codeph> 显示对象的索引编号。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>更改现有子项的索引编号。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	更改现有子项在显示对象容器中的位置。这会影响子对象的分层。例如，下例在索引位置 0、1、2 处分别显示 a、b、c 三个显示对象：
	
	<p><adobeimage alt="c 在 b 之上，b 在 a 之上" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>在使用 <codeph>setChildIndex()</codeph> 方法并指定一个已经占用的索引位置时，唯一发生更改的位置是显示对象先前的位置和新位置之间的位置。所有其它位置将保持不变。如果将一个子项移动到比它当前的索引更低的索引处，则这两个索引之间的所有子项的索引引用都将增加 1。如果将一个子项移动到比它当前的索引更高的索引处，则这两个索引之间的所有子项的索引引用都将减小 1。例如，如果上例中的显示对象容器名为 <codeph>container</codeph>，则可以通过调用以下代码来交换带有 a 和 b 标记的显示对象的位置：</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>该代码产生以下对象排列：</p>
	
    <p><adobeimage alt="c 在 a 之上，a 在 b 之上" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc><example conref="examples\DisplayObjectContainer.setChildIndex.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，然后向该容器添加三个稍微重叠的子显示对象。当用户单击这些对象中的任何一个对象时，<codeph>clicked()</codeph> 方法调用 <codeph>setChildIndex()</codeph> 方法，将单击的对象移动到 <codeph>container</codeph> 对象的子级列表中最上面的位置：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
addChild(container);

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFF0000);
circle1.graphics.drawCircle(40, 40, 40);
circle1.addEventListener(MouseEvent.CLICK, clicked);
 
var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00FF00);
circle2.graphics.drawCircle(100, 40, 40);
circle2.addEventListener(MouseEvent.CLICK, clicked);
 
var circle3:Sprite = new Sprite();
circle3.graphics.beginFill(0x0000FF);
circle3.graphics.drawCircle(70, 80, 40);
circle3.addEventListener(MouseEvent.CLICK, clicked);
 
container.addChild(circle1);
container.addChild(circle2);
container.addChild(circle3);
addChild(container);
 
function clicked(event:MouseEvent):void {
    var circle:Sprite = Sprite(event.target);
    var topPosition:uint = container.numChildren - 1;
    container.setChildIndex(circle, topPosition);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#DisplayObjectContainer/addChildAt()"><linktext>addChildAt()</linktext></link><link href="flash.display.xml#DisplayObjectContainer/getChildIndex()"><linktext>getChildIndex()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildren"><apiName>swapChildren</apiName><shortdesc>
	 交换两个指定子对象的 Z 轴顺序（从前到后顺序）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>在子参数不是此对象的子项时引发。
	 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child1</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>第一个子对象。
	 
     </apiDesc></apiParam><apiParam><apiItemName>child2</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>第二个子对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 交换两个指定子对象的 Z 轴顺序（从前到后顺序）。显示对象容器中所有其它子对象的索引位置保持不变。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildren.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，接着向该容器添加两个子显示对象，然后显示调用 <codeph>swapChildren()</codeph> 方法的效果：
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";

container.addChild(sprite1);
container.addChild(sprite2);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2

container.swapChildren(sprite1, sprite2);

trace(container.getChildAt(0).name); // sprite2
trace(container.getChildAt(1).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:DisplayObjectContainer:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 在子级列表中两个指定的索引位置，交换子对象的 Z 轴顺序（前后顺序）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果子级列表中不存在任何一个索引。
	 
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>第一个子对象的索引位置。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>第二个子对象的索引位置。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在子级列表中两个指定的索引位置，交换子对象的 Z 轴顺序（前后顺序）。显示对象容器中所有其它子对象的索引位置保持不变。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.swapChildrenAt.1.as"> 下例创建一个名为 <codeph>container</codeph> 的显示对象容器，接着向该容器添加三个子显示对象，然后显示对 <codeph>swapChildrenAt()</codeph> 方法的调用如何重新排列该显示对象容器的子级列表：
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();

var sprite1:Sprite = new Sprite();
sprite1.name = "sprite1";
var sprite2:Sprite = new Sprite();
sprite2.name = "sprite2";
var sprite3:Sprite = new Sprite();
sprite3.name = "sprite3";

container.addChild(sprite1);
container.addChild(sprite2);
container.addChild(sprite3);

trace(container.getChildAt(0).name); // sprite1
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite3

container.swapChildrenAt(0, 2);

trace(container.getChildAt(0).name); // sprite3
trace(container.getChildAt(1).name); // sprite2
trace(container.getChildAt(2).name); // sprite1
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:DisplayObjectContainer:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 确定对象的子项是否支持鼠标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 确定对象的子项是否支持鼠标。如果对象支持鼠标，则用户可以使用鼠标与其交互。默认值为 <codeph>true</codeph>。
	 
	 <p>当您使用 Sprite 类的实例（而不是使用 SimpleButton 类）来创建按钮时，此属性很有用。当您使用 Sprite 实例来创建按钮时，可以选择使用 <codeph>addChild()</codeph> 方法添加其它 Sprite 实例来修饰该按钮。此过程可能导致鼠标事件出现意外行为，因为当您期望父实例成为鼠标事件的目标对象时，作为子项添加的 Sprite 实例却可能成为目标对象。要确保父实例用作鼠标事件的目标对象，您可以将父实例的 <codeph>mouseChildren</codeph> 属性设置为 <codeph>false</codeph>。</p>
	 <p> 设置此属性不会分派任何事件。您必须使用 <codeph>addEventListener()</codeph> 方法才能创建交互式功能。</p>
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.mouseChildren.1.as"> 下例设置一个名为 <codeph>container</codeph> 的 Sprite 对象（一种显示对象容器），并显示：当您将该对象的 <codeph>mouseChildren</codeph> 属性设置为 <codeph>false</codeph> 时，<codeph>mouseClick</codeph> 事件的目标为 <codeph>container</codeph> 对象，而不是其子对象中的任一个：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var container:Sprite = new Sprite();
container.name = "container";
addChild(container);

var circle:Sprite = new Sprite();
circle.name = "circle";
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);

container.addChild(circle);

container.mouseChildren = false;

container.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace(event.target.name); // container
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>flash.display.Sprite.buttonMode</linktext></link><link href="flash.events.xml#EventDispatcher/addEventListener()"><linktext>flash.events.EventDispatcher.addEventListener()</linktext></link></related-links></apiValue><apiValue id="flash.display:DisplayObjectContainer:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 返回此对象的子项数目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 返回此对象的子项数目。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.numChildren.1.as"> 下例设置了两个名称分别为 <codeph>container1</codeph> 和 <codeph>container2</codeph> 的 Sprite 对象。Sprite 是一种显示对象容器。该示例调用 <codeph>addChild()</codeph> 方法以设置显示层次结构：<codeph>container1</codeph> 是 <codeph>container2</codeph> 的子项，其它两个显示对象 <codeph>circle1</codeph> 和 <codeph>circle2</codeph> 是 <codeph>container1</codeph> 的子项。<codeph>trace()</codeph> 方法的调用显示每个对象的子项数。请注意，孙项并不包括在 <codeph>numChildren</codeph> 计数中：
<codeblock>
import flash.display.Sprite;

var container1:Sprite = new Sprite();
var container2:Sprite = new Sprite();

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(80, 40, 40);

container2.addChild(container1);
container1.addChild(circle1);
container1.addChild(circle2);

trace(container1.numChildren); // 2
trace(container2.numChildren); // 1
trace(circle1.numChildren); // 0
trace(circle2.numChildren); // 0
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 确定对象的子项是否支持 Tab 键。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的此属性会引发异常。Stage 对象未实现此属性。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 确定对象的子项是否支持 Tab 键。为对象的子项启用或禁用 Tab 切换。默认值为 <codeph>true</codeph>。
	 
	 </apiDesc><example conref="examples\DisplayObjectContainer.tabChildren.1.as"> 下例创建一个 <codeph>container1</codeph> 显示对象容器，并将两个显示对象 <codeph>circle1</codeph> 和 <codeph>circle2</codeph> 添加到其子级列表。该示例将子项的 tabChildren 设置为 <codeph>false</codeph>，以便它可以使用 <codeph>tabIndex</codeph> 管理自己的 Tab 键顺序：
<codeblock>
import flash.display.Sprite;

var container:Sprite = new Sprite();
container.tabChildren = false;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.tabIndex = 1;

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0x00CCFF);
circle2.graphics.drawCircle(120, 40, 40);
circle2.tabIndex = 0;

container.addChild(circle1);
container.addChild(circle2);
</codeblock> 要查看此示例的结果，请编译并运行文件。当单击其中一个圆形时，可以按 Tab 键切换具有焦点（由亮黄色的矩形表示）的显示对象。
</example></apiValueDetail></apiValue><apiValue id="flash.display:DisplayObjectContainer:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
     返回此 DisplayObjectContainer 实例的 TextSnapshot 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier></apiValueDef><apiDesc>
     返回此 DisplayObjectContainer 实例的 TextSnapshot 对象。
     
	 </apiDesc><example conref="examples\DisplayObjectContainer.textSnapshot.1.as"> 下例只适用于 Flash 创作环境。Flex 没有提供用于将静态文本添加到文件的任何方法。要为此示例准备 Flash 文件，请在影片的第一帧中添加一个或多个静态文本字段。然后将以下脚本插入到第一帧并运行该文件。输出将为所添加的静态文本：
<codeblock>
trace(this.textSnapshot.getText(0, this.textSnapshot.charCount));
</codeblock></example></apiValueDetail><related-links><link href="flash.text.xml#TextSnapshot"><linktext>flash.text.TextSnapshot</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
 定义渐变填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义渐变填充。 
 
 <p>
 将 GraphicsGradientFill 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。绘制 GraphicsGradientFill 对象与调用 <codeph>Graphics.beginGradientFill()</codeph> 方法是等效的。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsGradientFill:GraphicsGradientFill"><apiName>GraphicsGradientFill</apiName><shortdesc>
     创建新的 GraphicsGradientFill 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>linear</apiData><apiDesc>用于指定要使用哪种渐变类型的 GradientType 类的值：<codeph>GradientType.LINEAR</codeph> 或 <codeph>GradientType.RADIAL</codeph>。 
     
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>渐变中使用的 RGB 十六进制颜色值的数组（例如，红色为 0xFF0000，蓝色为 0x0000FF，等等）。可以至多指定 15 种颜色。对于每种颜色，请在 alphas 和 ratios 参数中指定对应值。
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>colors 数组中对应颜色的 alpha 值数组；有效值为 0 到 1。如果值小于 0，则使用 0。如果值大于 1，则使用 1。
     
     </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>颜色分布比率的数组；有效值为 0 到 255。该值定义 100% 采样的颜色所在位置的宽度百分比。值 0 表示渐变框中的左侧位置，255 表示渐变框中的右侧位置。 
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>一个由 flash.geom.Matrix 类定义的转换矩阵。flash.geom.Matrix 类包括 <codeph>createGradientBox()</codeph> 方法，通过该方法可以方便地设置矩阵，以便与 <codeph>beginGradientFill()</codeph> 方法一起使用。
     
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>pad</apiData><apiDesc>用于指定要使用哪种 spread 方法的 SpreadMethod 类的值：<codeph>SpreadMethod.PAD</codeph>、<codeph>SpreadMethod.REFLECT</codeph> 或 <codeph>SpreadMethod.REPEAT</codeph>。 
     
     </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiType value=""/><apiData>rgb</apiData><apiDesc>用于指定要使用哪个值的 InterpolationMethod 类的值：<codeph>InterpolationMethod.LINEAR_RGB</codeph> 或 <codeph>InterpolationMethod.RGB</codeph>
     
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiType value=""/><apiData>0.0</apiData><apiDesc>一个控制渐变的焦点位置的数字。值 0 将焦点设置在中心。值 1 将焦点设置在渐变圆的一条边界上。值 -1 将焦点设置在渐变圆的另一条边界上。小于 -1 或大于 1 的值将分别舍入为 -1 或 1。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的 GraphicsGradientFill 对象。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsGradientFill:alphas"><apiName>alphas</apiName><shortdesc>
     colors 数组中的对应颜色的 Alpha 值的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     colors 数组中的对应颜色的 Alpha 值的数组。有效值为 0 到 1。如果值小于 0，则使用 0。如果值大于 1，则使用 1。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:colors"><apiName>colors</apiName><shortdesc>
     渐变中使用的 RGB 十六进制颜色值数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     渐变中使用的 RGB 十六进制颜色值数组。例如，红色为 0xFF0000，蓝色为 0x0000FF 等等。可以至多指定 15 种颜色。对于每种颜色，请在 alphas 和 ratios 属性中指定对应值。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:focalPointRatio"><apiName>focalPointRatio</apiName><shortdesc>
     一个控制渐变的焦点位置的数字。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
     一个控制渐变的焦点位置的数字。值 0 将焦点设置在中心。值 1 表示焦点位于渐变圆的一条边界上；值 -1 表示焦点位于渐变圆的另一条边界上。小于 -1 或大于 1 的值将分别舍入为 -1 或 1。例如，下例显示了设置为 0.75 的 <codeph>focalPointRatio</codeph>：
     
     <p><adobeimage alt="focalPointRatio 设置为 0.75 时的放射状渐变" href="../../images/radial_sketch.jpg"/> </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:matrix"><apiName>matrix</apiName><shortdesc>
     一个由 Matrix 类定义的转换矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     一个由 Matrix 类定义的转换矩阵。flash.geom.Matrix 类包括一个 <codeph>createGradientBox()</codeph> 方法，可通过该方法设置与 <codeph>beginGradientFill()</codeph> 方法一起使用的矩阵。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:ratios"><apiName>ratios</apiName><shortdesc>
     颜色分布比例的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
     颜色分布比例的数组。有效值为 0 到 255。该值定义 100% 采样的颜色所在位置的宽度百分比。值 0 表示渐变框中的左侧位置，值 255 表示渐变框中的右侧位置。 
     
     <p><b>注意：</b>此值表示渐变框中的位置，而不是最终渐变的坐标空间。最终渐变可能会比渐变框更宽或更窄。为 <codeph>colors</codeph> 属性中的每个值指定一个对应值。 </p>
     
     <p>例如，对于包括蓝和绿两种颜色的线性渐变，以下示例显示了渐变中的颜色基于不同 <codeph>ratios</codeph> 数组值的配比：</p>
     
     <adobetable class="innertable">
     
     
     
     
     
     
     
     
     
     <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>渐变</entry></row></thead><tbody><row>
     
      <entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="ratios 为 0 和 127 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-1.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="ratios 为 0 和 255 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-2.jpg"/></entry>
     
     </row><row>
     
      <entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="ratios 为 127 和 255 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-3.jpg"/></entry>
     
     </row></tbody></tgroup></adobetable>
     
     <p>数组中的值必须持续增加；例如，<codeph>[0, 63, 127, 190, 255]</codeph>。 </p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsGradientFill:interpolationMethod:get"><apiName>interpolationMethod</apiName><shortdesc>
     InterpolationMethod 类中用于指定要使用的值的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     InterpolationMethod 类中用于指定要使用的值的值。有效值为：<codeph>InterpolationMethod.LINEAR_RGB</codeph> 或 <codeph>InterpolationMethod.RGB</codeph>
     
     <p>例如，下例显示了两种颜色之间的简单线性渐变（<codeph>spreadMethod</codeph> 参数设置为 <codeph>SpreadMethod.REFLECT</codeph>）。不同的插值方法会更改外观，如下所示： </p>
     
      <adobetable>
      
      
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="以 InterpolationMethod.LINEAR_RGB 线性渐变" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="以 InterpolationMethod.RGB 线性渐变" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
      </row><row>
      <entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
      <entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
      </row></tbody></tgroup></adobetable>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod"><linktext>flash.display.InterpolationMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:spreadMethod:get"><apiName>spreadMethod</apiName><shortdesc>
     SpreadMethod 类中用于指定要使用的扩展方法的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     SpreadMethod 类中用于指定要使用的扩展方法的值。有效值为：<codeph>SpreadMethod.PAD</codeph>、<codeph>SpreadMethod.REFLECT</codeph> 或 <codeph>SpreadMethod.REPEAT</codeph>。 
     
     <p>例如，下例显示了两种颜色之间的简单线性渐变：</p>
     
     <codeblock>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);       
     this.graphics.drawRect(0,0,100,100);
     </codeblock>
     
      <p>此示例将 <codeph>SpreadMethod.PAD</codeph> 用于 spread 方法，并且渐变填充看起来将类似于下图：</p>
     
      <p><adobeimage alt="以 SpreadMethod.PAD 线性渐变" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
     
      <p>如果将 <codeph>SpreadMethod.REFLECT</codeph> 用于 spread 方法，则渐变填充看起来将类似于下图：</p>
     
      <p><adobeimage alt="以 SpreadMethod.REFLECT 线性渐变" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
     
      <p>如果将 <codeph>SpreadMethod.REPEAT</codeph> 用于 spread 方法，则渐变填充看起来将类似于下图：</p>
     
      <p><adobeimage alt="以 SpreadMethod.REPEAT 线性渐变" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsGradientFill:type:get"><apiName>type</apiName><shortdesc>
     GradientType 类中用于指定要使用的渐变类型的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     GradientType 类中用于指定要使用的渐变类型的值。值为 <codeph>GradientType.LINEAR</codeph> 或 <codeph>GradientType.RADIAL</codeph>。 
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Sprite"><apiName>Sprite</apiName><shortdesc>
 Sprite 类是基本显示列表构造块：一个可显示图形并且也可包含子项的显示列表节点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>ActionScript 的基本显示对象创建了对象。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Sprite 类是基本显示列表构造块：一个可显示图形并且也可包含子项的显示列表节点。
 
 <p>Sprite 对象与影片剪辑类似，但没有时间轴。Sprite 是不需要时间轴的对象的相应基类。例如，Sprite 将是通常不使用时间轴的用户界面 (UI) 组件的逻辑基类。</p>
 
 <p>Sprite 类是 ActionScript 3.0 中新引入的类。它提供了 MovieClip 类功能的替代功能，此替代功能保留了 ActionScript 以前版本的所有功能以提供向后兼容性。</p>
 
 </apiDesc><example conref="examples\SpriteExample.as"> 下例使用 SpriteExample 类在舞台上绘制一个橙色正方形，然后在用户单击或拖动该正方形时分派事件。执行下列步骤可完成该任务：
 <ol>
  <li>声明 <codeph>size</codeph> 属性（100 x 100 像素）和背景颜色（橙色）供以后绘制正方形时使用。</li>
 
  <li>然后，构造函数创建一个新的 <codeph>child</codeph> Sprite 对象，并用它来添加两个事件侦听器和与之相关联的方法：<codeph>mouseDownHandler()</codeph> 和 <codeph>mouseUpHandler()</codeph>。</li>
 
  <li>然后，将 <codeph>child</codeph> Sprite 对象传递给 <codeph>draw()</codeph> 方法，该方法将绘制橙色正方形。</li>
 
  <li>然后，将子项放置在显示列表上，方法是调用 <codeph>addChild()</codeph> 方法。 </li>
 
  <li>事件侦听器的工作方式如下：
 
  <ul>
      <li><codeph>mouseDownHandler()</codeph>：当用户单击 Sprite 对象时，此方法将添加一个 mouseMove 事件侦听器，即可以处理鼠标移动的 <codeph>mouseMoveHandler()</codeph> 方法。然后调用 <codeph>startDrag()</codeph> 方法，此方法允许拖动 Sprite 对象。</li>
 
      <li><codeph>mouseUpHandler()</codeph>：当释放鼠标按键时，将删除 mouseMove 事件侦听器，并调用 <codeph>stopDrag()</codeph> 方法，该方法可使橙色正方形的位置保持不变。</li>
 
      <li><codeph>mouseMoveHandler</codeph>：只要按住鼠标左键不放，此方法就会指示播放器不断重绘橙色正方形。</li>
 
  </ul>
  </li>
 
 </ol>
 
 <p><b>注意：</b>每个事件侦听器方法都声明一个局部 <codeph>sprite</codeph> 变量，已为该变量赋予了事件的 <codeph>target</codeph> 属性。</p>
 
<codeblock>

package {
    import flash.display.Sprite;
    import flash.events.*;

    public class SpriteExample extends Sprite {
        private var size:uint    = 100;
        private var bgColor:uint = 0xFFCC00;

        public function SpriteExample() {
            var child:Sprite = new Sprite();
            child.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
            child.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
            draw(child);
            addChild(child);
        }

        private function mouseDownHandler(event:MouseEvent):void {
            trace("mouseDownHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.startDrag();
        }

        private function mouseUpHandler(event:MouseEvent):void {
            trace("mouseUpHandler");
            var sprite:Sprite = Sprite(event.target);
            sprite.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            sprite.stopDrag();
        }

        private function mouseMoveHandler(event:MouseEvent):void {
            trace("mouseMoveHandler");
            event.updateAfterEvent();
        }

        private function draw(sprite:Sprite):void {
            sprite.graphics.beginFill(bgColor);
            sprite.graphics.drawRect(0, 0, size, size);
            sprite.graphics.endFill();
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:Sprite:Sprite"><apiName>Sprite</apiName><shortdesc>
	创建一个新的 Sprite 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	创建一个新的 Sprite 实例。创建 Sprite 实例后，调用 <codeph>DisplayObjectContainer.addChild()</codeph> 或 <codeph>DisplayObjectContainer.addChildAt()</codeph> 方法，以便将 Sprite 添加到父级 DisplayObjectContainer。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:Sprite:startDrag"><apiName>startDrag</apiName><shortdesc>
	 允许用户拖动指定的 Sprite。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.startDrag, startDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>lockCenter</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定是将可拖动的 Sprite 锁定到鼠标位置中央 (<codeph>true</codeph>)，还是锁定到用户首次单击该 Sprite 时所在的点上 (<codeph>false</codeph>)。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>bounds</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>相对于 Sprite 父级的坐标的值，用于指定 Sprite 约束矩形。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 允许用户拖动指定的 Sprite。Sprite 将一直保持可拖动，直到通过调用 <codeph>Sprite.stopDrag()</codeph> 方法来明确停止，或直到将另一个 Sprite 变为可拖动为止。在同一时间只有一个 Sprite 是可拖动的。
	 <p>三维显示对象将跟随鼠标，并且 <codeph>Sprite.startDrag()</codeph> 将在由显示对象定义的三维平面中移动对象。或者，如果显示对象为二维对象和三维对象的子对象，则二维对象将在由三维父对象定义的三维平面中移动。</p>
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> 下例创建一个 <codeph>circle</codeph> Sprite 和两个 <codeph>target</codeph> Sprite。当用户将光标放在 Sprite 上并按下鼠标按键时，将对 <codeph>circle</codeph> Sprite 调用 <codeph>startDrag()</codeph> 方法；当用户释放鼠标按键时，将调用 <codeph>stopDrag()</codeph> 方法。这样，用户就可以拖动 sprite。松开鼠标按键时，将调用 <codeph>mouseRelease()</codeph> 方法，此方法又会跟踪 <codeph>dropTarget</codeph> 对象（用户将 <codeph>circle</codeph> Sprite 拖动到的对象）的 <codeph>name</codeph>：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Sprite:stopDrag"><apiName>stopDrag</apiName><shortdesc>
	 结束 startDrag() 方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>sprite, movieclip.stopDrag, stopDrag
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 结束 <codeph>startDrag()</codeph> 方法。通过 <codeph>startDrag()</codeph> 方法变为可拖动的 Sprite 将一直保持可拖动状态，直到添加 <codeph>stopDrag()</codeph> 方法或另一个 Sprite 变为可拖动状态为止。在同一时间只有一个 Sprite 是可拖动的。
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> 下例创建一个 <codeph>circle</codeph> Sprite 和两个 <codeph>target</codeph> Sprite。当用户将光标放在 Sprite 上并按下鼠标按键时，将对 <codeph>circle</codeph> Sprite 调用 <codeph>startDrag()</codeph> 方法；当用户释放鼠标按键时，将调用 <codeph>stopDrag()</codeph> 方法。这样，用户就可以拖动 sprite。松开鼠标按键时，将调用 <codeph>mouseRelease()</codeph> 方法，此方法又会跟踪 <codeph>dropTarget</codeph> 对象（用户将 <codeph>circle</codeph> Sprite 拖动到的对象）的 <codeph>name</codeph>：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Sprite/dropTarget"><linktext>dropTarget</linktext></link><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link></related-links></apiOperation><apiValue id="flash.display:Sprite:buttonMode:get"><apiName>buttonMode</apiName><shortdesc>
     指定此 sprite 的按钮模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>指定此 sprite 的按钮模式。
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     指定此 sprite 的按钮模式。如果为 <codeph>true</codeph>，则此 Sprite 的行为方式就像按钮，也就是说当鼠标指针经过 Sprite 上方时它会触发手形光标的显示，并在 Sprite 具有焦点的情况下按下 Enter 或空格键时可以接收 <codeph>click</codeph> 事件。通过将 <codeph>useHandCursor</codeph> 属性设置为 <codeph>false</codeph> 可以禁止显示手形光标，在此情况下将显示指针。
     
     <p>虽然使用 SimpleButton 类创建按钮是一种比较好的方法，但是可以使用 <codeph>buttonMode</codeph> 属性为 Sprite 提供某种类似按钮的功能。要在 Tab 键顺序中包括 Sprite，请将 <codeph>tabEnabled</codeph> 属性（继承自 InteractiveObject 类，默认情况下为 <codeph>false</codeph>）设置为 <codeph>true</codeph>。此外，请考虑是否想要 Sprite 的子项支持鼠标。大部分按钮并未启用其子对象的鼠标交互性操作，因为此操作会混淆事件流。要对所有子对象禁用鼠标交互性操作，则必须将 <codeph>mouseChildren</codeph> 属性（继承自 DisplayObjectContainer 类）设置为 <codeph>false</codeph>。</p>
     
     <p>如果将 <codeph>buttonMode</codeph> 属性与 MovieClip 类（该类是 Sprite 类的子类）一起使用，则按钮可能会具有一些增加的功能。如果包括具有 _up、_over 和 _down 标签的帧，则 Flash Player 将提供自动状态更改功能（类似于 ActionScript 的以前版本中为用作按钮的影片剪辑提供的功能）。没有时间轴的 Sprite 不可以使用这些自动状态更改，因此没有要加标签的帧。 </p>
	 
	 </apiDesc><example conref="examples\Sprite.buttonMode.1.as"> 下例创建两个 Sprite 并将其中一个的 <codeph>buttonMode</codeph> 属性设置为 <codeph>true</codeph>，将另一个的此属性设置为 <codeph>false</codeph>。当您编译和运行应用程序时，这两个 Sprite 都响应鼠标事件，但只有将 <codeph>buttonMode</codeph> 设置为 <codeph>true</codeph> 的那个 Sprite 才使用手形光标并包括在 Tab 键顺序中：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton"><linktext>SimpleButton</linktext></link><link href="flash.display.xml#Sprite/useHandCursor"><linktext>Sprite.useHandCursor</linktext></link><link href="flash.display.xml#InteractiveObject/tabEnabled"><linktext>InteractiveObject.tabEnabled</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:dropTarget:get"><apiName>dropTarget</apiName><shortdesc>
	 指定拖动 sprite 时经过的显示对象，或放置 sprite 的显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>Sprite, Sprite.dropTarget, dropTarget
	 
     </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>指定要在其上拖动或放置 Sprite 的 DisplayObject。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定拖动 sprite 时经过的显示对象，或放置 sprite 的显示对象。
	 
	 </apiDesc><example conref="examples\Sprite.dropTarget.1.as"> 下例创建一个 <codeph>circle</codeph> Sprite 和两个 <codeph>target</codeph> Sprite。当用户将光标放在 Sprite 上并按下鼠标按键时，将对 <codeph>circle</codeph> Sprite 调用 <codeph>startDrag()</codeph> 方法；当用户释放鼠标按键时，将调用 <codeph>stopDrag()</codeph> 方法。这样，用户就可以拖动 sprite。松开鼠标按键时，将调用 <codeph>mouseRelease()</codeph> 方法，此方法又会跟踪 <codeph>dropTarget</codeph> 对象（用户将 <codeph>circle</codeph> Sprite 拖动到的对象）的 <codeph>name</codeph>：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var target1:Sprite = new Sprite();
target1.graphics.beginFill(0xCCFF00);
target1.graphics.drawRect(0, 0, 100, 100);
target1.name = "target1";

var target2:Sprite = new Sprite();
target2.graphics.beginFill(0xCCFF00);
target2.graphics.drawRect(0, 200, 100, 100);
target2.name = "target2";

addChild(target1);
addChild(target2);
addChild(circle);

circle.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown) 

function mouseDown(event:MouseEvent):void {
    circle.startDrag();
}
circle.addEventListener(MouseEvent.MOUSE_UP, mouseReleased);

function mouseReleased(event:MouseEvent):void {
    circle.stopDrag();
    trace(circle.dropTarget.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/startDrag()"><linktext>startDrag()</linktext></link><link href="flash.display.xml#Sprite/stopDrag()"><linktext>stopDrag()</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:graphics:get"><apiName>graphics</apiName><shortdesc>
     指定属于此 sprite 的 Graphics 对象，在此 sprite 中可执行矢量绘画命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>指定 Graphics 对象。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     指定属于此 sprite 的 Graphics 对象，在此 sprite 中可执行矢量绘画命令。
     
	 </apiDesc><example conref="examples\Sprite.graphics.1.as"> 下例创建一个 <codeph>circle</codeph> Sprite，并使用其 <codeph>graphics</codeph> 属性以黄色 (0xFFCC00) 填充色绘制一个圆形：
<codeblock>
import flash.display.Sprite;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(40, 40, 40);
addChild(circle);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:hitArea:get"><apiName>hitArea</apiName><shortdesc>
	 指定一个 sprite 用作另一个 sprite 的点击区域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Sprite</apiValueClassifier></apiValueDef><apiDesc>
	 指定一个 sprite 用作另一个 sprite 的点击区域。如果 <codeph>hitArea</codeph> 属性不存在或者其值为 <codeph>null</codeph> 或 <codeph>undefined</codeph>，则 Sprite 本身将用作点击区域。<codeph>hitArea</codeph> 属性的值可以是对 Sprite 对象的引用。
	 
	 <p>可以随时更改 <codeph>hitArea</codeph> 属性；修改后的 Sprite 会立即使用新的点击区域行为。指定为点击区域的 Sprite 不必是可见的；虽然不可见，但其图形形状仍会作为点击区域被检测。</p>
	 
	 <p><b>注意：</b>必须将指定为点击区域的 Sprite 的 <codeph>mouseEnabled</codeph> 属性设置为 <codeph>false</codeph>。否则，可能无法使用 Sprite 按钮，因为将是指定为点击区域的 Sprite（而不是 Sprite 按钮）接收鼠标事件。</p>
	 
	 </apiDesc><example conref="examples\Sprite.hitArea.1.as"> 下例创建一个 <codeph>circle</codeph> Sprite 和一个 <codeph>square</codeph> Sprite。<codeph>square</codeph> Sprite 是 <codeph>circle</codeph> Sprite 的 <codeph>hitArea</codeph>。因此，当用户单击 <codeph>square</codeph> Sprite 时，<codeph>circle</codeph> Sprite 将分派 <codeph>click</codeph> 事件：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle:Sprite = new Sprite();
circle.graphics.beginFill(0xFFCC00);
circle.graphics.drawCircle(0, 0, 40);

var square:Sprite = new Sprite();
square.graphics.beginFill(0xCCFF00);
square.graphics.drawRect(200, 0, 100, 100);

circle.hitArea = square;
square.mouseEnabled = false;

circle.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void{
    trace(event.target == circle); // true
    trace(event.target == square); // false
}

addChild(circle);
addChild(square);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Sprite:soundTransform:get"><apiName>soundTransform</apiName><shortdesc>
	 控制此 sprite 中的声音。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc>
	 控制此 sprite 中的声音。
	 
	 </apiDesc><example conref="examples\Sprite.soundTransform.1.as"> 下例创建一个名为 <codeph>container</codeph> 的 Sprite，并将 Loader 对象添加到其子级列表。Loader 对象将加载 SWF 文件。当用户单击 <codeph>tf</codeph> 文本字段中的链接时，<codeph>mute()</codeph> 方法将 <codeph>container</codeph> Sprite <codeph>soundTransform</codeph> 属性的 <codeph>volume</codeph> 属性设置为 <codeph>true</codeph>：
<codeblock>
import flash.display.Sprite;
import flash.display.Loader;
import flash.events.IOErrorEvent;
import flash.events.MouseEvent;
import flash.net.URLRequest;
import flash.text.TextField;
import flash.media.SoundTransform;

var container:Sprite = new Sprite();
addChild(container);

var ldr:Loader = new Loader;
var urlReq:URLRequest = new URLRequest("SoundPlayer.swf");
ldr.load(urlReq);

container.addChild(ldr);
ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, urlNotFound);
            
var tf:TextField = new TextField();
tf.htmlText = "&lt;a href = 'event:Mute'>Mute / Unmute&lt;/a>";
addChild(tf);

var mySoundTransform:SoundTransform = new SoundTransform();
mySoundTransform.volume = 1;

tf.addEventListener(MouseEvent.CLICK, mute);

function mute(event:MouseEvent):void {    
    if (mySoundTransform.volume == 0) {
        mySoundTransform.volume = 1;
    } else {
        mySoundTransform.volume = 0;        
    }
    container.soundTransform = mySoundTransform;
}

function urlNotFound(event:IOErrorEvent):void {
    trace("The URL was not found."); 
}
</codeblock></example></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:Sprite:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
	 布尔值，指示当鼠标滑过其 buttonMode 属性设置为 true 的 sprite 时是否显示手指形（手形光标）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>布尔值，指示当鼠标滑过其 buttonMode 属性设置为 true 的 sprite 时是否显示手指形（手形光标）。 
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 布尔值，指示当鼠标滑过其 <codeph>buttonMode</codeph> 属性设置为 <codeph>true</codeph> 的 Sprite 时是否显示手指形（手形光标）。<codeph>useHandCursor</codeph> 属性的默认值是 <codeph>true</codeph>。如果 <codeph>useHandCursor</codeph> 被设置为 <codeph>true</codeph>，则当鼠标滑过按钮 Sprite 时会显示用于按钮的手形光标。如果 <codeph>useHandCursor</codeph> 为 <codeph>false</codeph>，则将改用箭头指针。
	 
	 <p>可以随时更改 <codeph>useHandCursor</codeph> 属性；修改后的 Sprite 会立即具有新的光标外观。 </p>
     
     <p product="flex"><b>注意：</b>如果您的 sprite 具有子级 sprite，则可能需要将 <codeph>mouseChildren</codeph> 属性设置为 <codeph>false</codeph>。例如，如果您希望在 Flex &lt;mx:Label> 控件上出现手形光标，请将 <codeph>useHandCursor</codeph> 和 <codeph>buttonMode</codeph> 属性设置为 <codeph>true</codeph>，并将 <codeph>mouseChildren</codeph> 属性设置为 <codeph>false</codeph>。</p>
	 
	 </apiDesc><example conref="examples\Sprite.useHandCursor.1.as"> 下例创建两个 Sprite 并将二者的 <codeph>buttonMode</codeph> 属性设置为 <codeph>true</codeph>，但将其中一个的 <codeph>useHandCursor</codeph> 属性设置为 <codeph>true</codeph>，将另一个的此属性设置为 <codeph>false</codeph>。当您编译和运行应用程序时，这两个 Sprite 都作为按钮进行响应（并且都包括在 Tab 键顺序中），但只有将 <codeph>useHandCursor</codeph> 设置为 <codeph>true</codeph> 的那个 Sprite 才使用手形光标：
<codeblock>
import flash.display.Sprite;
import flash.events.MouseEvent;

var circle1:Sprite = new Sprite();
circle1.graphics.beginFill(0xFFCC00);
circle1.graphics.drawCircle(40, 40, 40);
circle1.buttonMode = true;
circle1.useHandCursor = true;
circle1.addEventListener(MouseEvent.CLICK, clicked);

var circle2:Sprite = new Sprite();
circle2.graphics.beginFill(0xFFCC00);
circle2.graphics.drawCircle(120, 40, 40);
circle2.buttonMode = true;
circle2.useHandCursor = false;
circle2.addEventListener(MouseEvent.CLICK, clicked);

function clicked(event:MouseEvent):void {
    trace ("Click!");
}

addChild(circle1);
addChild(circle2);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Sprite/buttonMode"><linktext>buttonMode</linktext></link><link href="flash.display.xml#DisplayObjectContainer/mouseChildren"><linktext>DisplayObjectContainer.mouseChildren</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
 定义位图填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义位图填充。可对位图进行平滑处理、重复位图或平铺位图以填充区域，或使用转换矩阵处理位图。
 <p>
 将 GraphicsBitmapFill 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。绘制 GraphicsBitmapFill 对象与调用 <codeph>Graphics.beginBitmapFill()</codeph> 方法是等效的。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsBitmapFill:GraphicsBitmapFill"><apiName>GraphicsBitmapFill</apiName><shortdesc>
     创建新的 GraphicsBitmapFill 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>包含要显示的位数的透明或不透明位图图像。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 Matrix 对象（属于 flash.geom.Matrix 类），您可以使用它在位图上定义转换。
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>如果为 <codeph>true</codeph>，则位图图像按平铺模式重复。如果为 <codeph>false</codeph>，位图图像不会重复，并且位图边缘将用于所有扩展出位图的填充区域。 
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果为 <codeph>false</codeph>，则使用最近邻点算法来呈现放大的位图图像（带有像素化效果）。如果为 <codeph>true</codeph>，则使用双线性算法来呈现放大的位图图像。使用最近邻点算法呈现通常较快。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的 GraphicsBitmapFill 对象。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsBitmapFill:bitmapData"><apiName>bitmapData</apiName><shortdesc>
     透明的或不透明的位图图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
     透明的或不透明的位图图像。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:matrix"><apiName>matrix</apiName><shortdesc>
     一个用于定义位图上的转换的 Matrix 对象（属于 flash.geom.Matrix 类）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     一个用于定义位图上的转换的 Matrix 对象（属于 flash.geom.Matrix 类）。例如，以下矩阵可将位图旋转 45 度（pi/4 弧度）：
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsBitmapFill:repeat"><apiName>repeat</apiName><shortdesc>
     指定是否以平铺模式重复位图图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指定是否以平铺模式重复位图图像。
     
     <p>
     如果为 <codeph>true</codeph>，则位图图像按平铺模式重复。如果为 <codeph>false</codeph>，则位图图像不会重复，并且位图边缘最外部的像素将用于所有延伸出位图边界的填充区域。</p>
     
     <p>例如，请考虑下列位图（20 x 20 像素的棋盘图案）：</p>
     
     <p><adobeimage alt="20 x 20 像素棋盘" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
     
     <p>当 <codeph>repeat</codeph> 设置为 <codeph>true</codeph> 时（如下例所示），位图填充将重复位图：</p>
     
     <p><adobeimage alt="60 x 60 像素棋盘" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
     
     <p><codeph>repeat</codeph> 设置为 <codeph>false</codeph> 时，位图填充将对位图外部的填充区域使用边缘像素：</p>
     
     <p><adobeimage alt="60 x 60 像素图像，无重复" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsBitmapFill:smooth"><apiName>smooth</apiName><shortdesc>
     指定是否将平滑处理算法应用于位图图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指定是否将平滑处理算法应用于位图图像。
     <p>
     如果为 <codeph>false</codeph>，则使用最近邻点算法来呈现放大的位图图像，而且该图像看起来是像素化的。如果为 <codeph>true</codeph>，则使用双线性算法来呈现放大的位图图像。使用最近邻点算法呈现通常较快。
     </p>
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 定义线条样式或笔触。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsStroke</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义线条样式或笔触。 
 
 <p>
 将 GraphicsStroke 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。绘制 GraphicsStroke 对象与调用设置线条样式的 Graphics 类的方法之一（例如 <codeph>Graphics.lineStyle()</codeph> 方法、<codeph>Graphics.lineBitmapStyle()</codeph> 方法或 <codeph>Graphics.lineGradientStyle()</codeph> 方法）是等效的。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>flash.display.Graphics.lineBitmapStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsStroke:GraphicsStroke"><apiName>GraphicsStroke</apiName><shortdesc>
 创建新的 GraphicsStroke 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>一个整数，以磅为单位表示线条的粗细；有效值为 0 到 255。如果未指定数字，或者未定义该参数，则不绘制线条。如果传递的值小于 0，则默认值为 0。值 0 表示极细的粗细；最大粗细为 255。如果传递的值大于 255，则默认值为 255。 
 
 </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>用于指定是否提示笔触采用完整像素的布尔值。它同时影响曲线锚点的位置以及线条笔触大小本身。在 <codeph>pixelHinting</codeph> 设置为 <codeph>true</codeph> 的情况下，Flash Player 将提示线条宽度采用完整像素宽度。在 <codeph>pixelHinting</codeph> 设置为 <codeph>false</codeph> 的情况下，对于曲线和直线可能会出现脱节。例如，下图显示了 Flash Player 如何呈现两个相同的圆角矩形，不同之处是用于 <codeph>lineStyle()</codeph> 方法的 <codeph>pixelHinting</codeph> 参数设置不同（将图像放大 200% 以强调差异）：
 
 <p><adobeimage alt="pixelHinting 为 false，pixelHinting 为 true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 <p>如果未提供值，则线条不使用像素提示。</p>
  
 </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>用于指定要使用哪种缩放模式的 LineScaleMode 类的值：
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> -- 在缩放对象时总是缩放线条的粗细（默认值）。
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> -- 从不缩放线条粗细。
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> -- 如果<i>仅</i> 垂直缩放对象，则不缩放线条粗细。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.VERTICAL</codeph>。左边的圆仅在垂直方向上缩放，而右边的圆则同时在垂直和水平方向上缩放：
 
 <p><adobeimage alt="一个在垂直方向缩放的圆和一个在垂直和水平方向同时缩放的圆。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> -- 如果<i>仅</i> 水平缩放对象，则不缩放线条粗细。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.HORIZONTAL</codeph>。左边的圆仅在水平方向上缩放，而右边的圆则同时在垂直和水平方向上缩放：
 
 <p><adobeimage alt="一个在水平方向缩放的圆和一个在水平和垂直方向同时缩放的圆。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 
 </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>用于指定线条末端处端点类型的 CapsStyle 类的值。有效值为：<codeph>CapsStyle.NONE</codeph>、<codeph>CapsStyle.ROUND</codeph> 和 <codeph>CapsStyle.SQUARE</codeph>。如果未指示值，则 Flash 使用圆头端点。 
 <p>例如，以下图示显示了不同的 <codeph>capsStyle</codeph> 设置。对于每种设置，插图显示了一条粗细为 30 的蓝色线条（应用 <codeph>capsStyle</codeph> 的线条），以及重叠于其上的粗细为 1 的黑色线条（未应用 <codeph>capsStyle</codeph> 的线条）：
 </p>
 <p><adobeimage alt="NONE、ROUND 和 SQUARE" href="../../images/linecap.jpg"/></p>
 
 </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>round</apiData><apiDesc>JointStyle 类的值，指定用于拐角的连接外观的类型。有效值为：<codeph>JointStyle.BEVEL</codeph>、<codeph>JointStyle.MITER</codeph> 和 <codeph>JointStyle.ROUND</codeph>。如果未指示值，则 Flash 使用圆角连接。 
 
 <p>例如，以下图示显示了不同的 <codeph>joints</codeph> 设置。对于每种设置，插图显示了一条粗细为 30 的带拐角的蓝色线条（应用 <codeph>jointStyle</codeph> 的线条），以及重叠于其上的粗细为 1 的带拐角的黑色线条（未应用 <codeph>jointStyle</codeph> 的线条）：
 </p>
 
 <p><adobeimage alt="MITER、ROUND 和 BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>注意：</b>对于设置为 <codeph>JointStyle.MITER</codeph> 的 <codeph>joints</codeph>，您可以使用 <codeph>miterLimit</codeph> 参数限制尖角的长度。</p>
 
 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3.0</apiData><apiDesc>一个表示将在哪个限制位置切断尖角的数字。有效值的范围是 1 到 255（超出该范围的值将舍入为 1 或 255）。此值只可用于 <codeph>jointStyle</codeph> 设置为 <codeph>"miter"</codeph> 的情况下。<codeph>miterLimit</codeph> 值表示向外延伸的尖角可以超出角边相交所形成的结合点的长度。此值表示为线条 <codeph>thickness</codeph> 的因子。例如，<codeph>miterLimit</codeph> 因子为 2.5 且 <codeph>thickness</codeph> 为 10 像素时，尖角将在 25 像素处切断。 
 
 <p>例如，请考虑下列带拐角的线条，每个线条都以 <codeph>thickness</codeph> 20 进行绘制，但它们的 <codeph>miterLimit</codeph> 分别设置为 1、2 和 4。重叠在其上的黑色参考线条显示了结合处的联结点：</p>
 
 <p><adobeimage alt="miterLimit 设置为 1、2 和 4 的线条" href="../../images/miterLimit.jpg"/></p>
 
 <p>请注意，对于给定的 <codeph>miterLimit</codeph> 值，会有一个被切断的尖角的特定最大角度。下表列出了部分示例：</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> 值：</entry><entry>小于此角度将被切断：</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 度</entry></row><row><entry>2</entry>      <entry>60 度</entry></row><row><entry>4</entry>      <entry>30 度</entry></row><row><entry>8</entry>      <entry>15 度</entry></row></tbody></tgroup></adobetable>
 </apiDesc></apiParam><apiParam><apiItemName>fill</apiItemName><apiOperationClassifier>flash.display:IGraphicsFill</apiOperationClassifier><apiData>null</apiData><apiDesc>一个包含用于填充笔触的数据的 IGraphicsFill 实例。IGraphicsFill 实例可表示一系列填充命令。
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 创建新的 GraphicsStroke 对象。
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsStroke:fill"><apiName>fill</apiName><shortdesc>
 指定包含用于填充笔触的数据的实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:IGraphicsFill</apiValueClassifier></apiValueDef><apiDesc>
 指定包含用于填充笔触的数据的实例。IGraphicsFill 实例可表示一系列填充命令。
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#IGraphicsFill"><linktext>flash.display.IGraphicsFill</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:miterLimit"><apiName>miterLimit</apiName><shortdesc>
 指示将在哪个限制位置切断尖角。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 指示将在哪个限制位置切断尖角。有效值的范围是 1 到 255（超出该范围的值将舍入为 1 或 255）。此值只可用于 <codeph>jointStyle</codeph> 设置为 <codeph>"miter"</codeph> 的情况下。<codeph>miterLimit</codeph> 值表示向外延伸的尖角可以超出角边相交所形成的结合点的长度。此值表示为线条 <codeph>thickness</codeph> 的因子。例如，<codeph>miterLimit</codeph> 因子为 2.5 且 <codeph>thickness</codeph> 为 10 像素时，尖角将在 25 像素处切断。 
 
 <p>例如，请考虑下列带拐角的线条，每个线条都以 <codeph>thickness</codeph> 20 进行绘制，但它们的 <codeph>miterLimit</codeph> 分别设置为 1、2 和 4。重叠在其上的黑色参考线条显示了结合处的联结点：</p>
 
 <p><adobeimage alt="miterLimit 设置为 1、2 和 4 的线条" href="../../images/miterLimit.jpg"/></p>
 
 <p>请注意，对于给定的 <codeph>miterLimit</codeph> 值，会有一个被切断的尖角的特定最大角度。下表列出了部分示例：</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 
 
 
 
 
 
 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> 值：</entry><entry>小于此角度将被切断：</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 度</entry></row><row><entry>2</entry>      <entry>60 度</entry></row><row><entry>4</entry>      <entry>30 度</entry></row><row><entry>8</entry>      <entry>15 度</entry></row></tbody></tgroup></adobetable>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:pixelHinting"><apiName>pixelHinting</apiName><shortdesc>
 指定是否提示笔触采用完整像素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
 指定是否提示笔触采用完整像素。它同时影响曲线锚点的位置以及线条笔触大小本身。在 <codeph>pixelHinting</codeph> 设置为 <codeph>true</codeph> 的情况下，Flash Player 将提示线条宽度采用完整像素宽度。在 <codeph>pixelHinting</codeph> 设置为 <codeph>false</codeph> 的情况下，对于曲线和直线可能会出现脱节。例如，下图显示了 Flash Player 如何呈现两个相同的圆角矩形，不同之处是用于 <codeph>lineStyle()</codeph> 方法的 <codeph>pixelHinting</codeph> 参数设置不同（将图像放大 200% 以强调差异）：
 
 <p><adobeimage alt="pixelHinting 为 false，pixelHinting 为 true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:thickness"><apiName>thickness</apiName><shortdesc>
 指示以磅为单位的线条粗细；有效值为 0 到 255。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 指示以磅为单位的线条粗细；有效值为 0 到 255。如果未指定数字，或者未定义该参数，则不绘制线条。如果传递的值小于 0，则默认值为 0。值 0 表示极细的粗细；最大粗细为 255。如果传递的值大于 255，则默认值为 255。
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsStroke:caps:get"><apiName>caps</apiName><shortdesc>
 指定线条结尾处的端点的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 指定线条结尾处的端点的类型。有效值为：<codeph>CapsStyle.NONE</codeph>、<codeph>CapsStyle.ROUND</codeph> 和 <codeph>CapsStyle.SQUARE</codeph>。如果未指示值，则 Flash 使用圆头端点。 
 <p>例如，以下图示显示了不同的 <codeph>capsStyle</codeph> 设置。对于每种设置，插图显示了一条粗细为 30 的蓝色线条（应用 <codeph>capsStyle</codeph> 的线条），以及重叠于其上的粗细为 1 的黑色线条（未应用 <codeph>capsStyle</codeph> 的线条）：
 </p>
 <p><adobeimage alt="NONE、ROUND 和 SQUARE" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#CapsStyle"><linktext>flash.display.CapsStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:joints:get"><apiName>joints</apiName><shortdesc>
 指定拐角处使用的连接外观的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 指定拐角处使用的连接外观的类型。有效值为：<codeph>JointStyle.BEVEL</codeph>、<codeph>JointStyle.MITER</codeph> 和 <codeph>JointStyle.ROUND</codeph>。如果未指示值，则 Flash 使用圆角连接。 
 
 <p>例如，以下图示显示了不同的 <codeph>joints</codeph> 设置。对于每种设置，插图显示了一条粗细为 30 的带拐角的蓝色线条（应用 <codeph>jointStyle</codeph> 的线条），以及重叠于其上的粗细为 1 的带拐角的黑色线条（未应用 <codeph>jointStyle</codeph> 的线条）：
 </p>
 
 <p><adobeimage alt="MITER、ROUND 和 BEVEL" href="../../images/linejoin.jpg"/></p>
 
 <p><b>注意：</b>对于设置为 <codeph>JointStyle.MITER</codeph> 的 <codeph>joints</codeph>，您可以使用 <codeph>miterLimit</codeph> 参数限制尖角的长度。</p>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#JointStyle"><linktext>flash.display.JointStyle</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsStroke:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
 指定笔触粗细缩放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
 指定笔触粗细缩放。有效值为：
 
 <ul>
 
 <li>
 <codeph>LineScaleMode.NORMAL</codeph> -- 在缩放对象时总是缩放线条的粗细（默认值）。
 </li>
 
 <li>
 <codeph>LineScaleMode.NONE</codeph> -- 从不缩放线条粗细。
 </li>
 
 
 <li>
 <codeph>LineScaleMode.VERTICAL</codeph> -- 如果<i>仅</i> 垂直缩放对象，则不缩放线条粗细。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.VERTICAL</codeph>。左边的圆仅在垂直方向上缩放，而右边的圆则同时在垂直和水平方向上缩放：
 
 <p><adobeimage alt="一个在垂直方向缩放的圆和一个在垂直和水平方向同时缩放的圆。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
 
 </li>
 
 
 <li>
 <codeph>LineScaleMode.HORIZONTAL</codeph> -- 如果<i>仅</i> 水平缩放对象，则不缩放线条粗细。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.HORIZONTAL</codeph>。左边的圆仅在水平方向上缩放，而右边的圆则同时在垂直和水平方向上缩放：
 
 <p><adobeimage alt="一个在水平方向缩放的圆和一个在水平和垂直方向同时缩放的圆。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
 
 </li>
 
 
 </ul>
 
 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LineScaleMode"><linktext>flash.display.LineScaleMode</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 指示图形填充的结束。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 指示图形填充的结束。将 GraphicsEndFill 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。
 
 <p>
 绘制 GraphicsEndFill 对象与调用 <codeph>Graphics.endFill()</codeph> 方法是等效的。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsEndFill:GraphicsEndFill"><apiName>GraphicsEndFill</apiName><shortdesc>
 创建与 Graphics.drawGraphicsData() 方法一起使用的对象，以显式结束填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
 创建与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用的对象，以显式结束填充。
 
 
 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/endFill()"><linktext>flash.display.Graphics.endFill()</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderPrecision"><apiName>ShaderPrecision</apiName><shortdesc>
	 该类定义一些常量，它们表示 Shader 类的 precisionHint 属性的可能值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 该类定义一些常量，它们表示 Shader 类的 <codeph>precisionHint</codeph> 属性的可能值。每个常量都表示用于执行着色器操作的精度模式之一。
	 
	 <p>精度模式选择将影响以下着色器操作。在包含 SSE 指令集的 Intel 处理器上，这些操作的执行速度较快：</p>
	 
	 <ul>
	   <li><codeph>sin(x)</codeph></li>
	   <li><codeph>cos(x)</codeph></li>
	   <li><codeph>tan(x)</codeph></li>
	   <li><codeph>asin(x)</codeph></li>
	   <li><codeph>acos(x)</codeph></li>
	   <li><codeph>atan(x)</codeph></li>
	   <li><codeph>atan(x, y)</codeph></li>
	   <li><codeph>exp(x)</codeph></li>
	   <li><codeph>exp2(x)</codeph></li>
	   <li><codeph>log(x)</codeph></li>
	   <li><codeph>log2(x)</codeph></li>
	   <li><codeph>pow(x, y)</codeph></li>
	   <li><codeph>reciprocal(x)</codeph></li>
	   <li><codeph>sqrt(x)</codeph></li>
	 </ul>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links><apiValue id="flash.display:ShaderPrecision:FAST"><apiName>FAST</apiName><shortdesc>
		 表示 fast 精度模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fast</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 表示 fast 精度模式。
		 
		 <p>fast 精度模式旨在获得最高性能，但在不同平台上和各种 CPU 配置下工作不一致。多数情况下，这种精度级别足以创建无可见失真的图形效果。</p>
		 
		 <p>通常，使用 fast 精度模式比使用查找表更快。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderPrecision:FULL"><apiName>FULL</apiName><shortdesc>
		 表示 full 精度模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>full</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 表示 full 精度模式。
		 
		 <p>在 full 精度模式下，着色器将按照 IEEE 32 位浮点标准的全宽计算所有数学运算。此模式可在所有平台上提供一致的行为。在此模式下，某些数学运算（比如三角函数和指数函数）可能速度较慢。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader/precisionHint"><linktext>flash.display.Shader.precisionHint</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:BlendMode"><apiName>BlendMode</apiName><shortdesc>
提供混合模式可视效果的常量值的类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
提供混合模式可视效果的常量值的类。这些常量在以下项目中使用：

<ul>

	<li> flash.display.DisplayObject 类的 <codeph>blendMode</codeph> 属性。</li>

	<li> flash.display.BitmapData 类的 <codeph>draw()</codeph> 方法的 <codeph>blendMode</codeph> 参数</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link></related-links><apiValue id="flash.display:BlendMode:ADD"><apiName>ADD</apiName><shortdesc>
将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>add</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
将显示对象的原色值添加到它的背景颜色中，上限值为 0xFF。此设置通常用于使两个对象间的加亮溶解产生动画效果。

<p>例如，如果显示对象的某个像素的 RGB 值为 0xAAA633，背景像素的 RGB 值为 0xDD2200，则显示像素的结果 RGB 值为 0xFFC833（因为 0xAA + 0xDD > 0xFF，0xA6 + 0x22 = 0xC8，且 0x33 + 0x00 = 0x33）。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ALPHA"><apiName>ALPHA</apiName><shortdesc>
将显示对象的每个像素的 Alpha 值应用于背景。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>alpha</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
将显示对象的每个像素的 Alpha 值应用于背景。这要求将父显示对象的 <codeph>blendMode</codeph> 属性设置为 <codeph>flash.display.BlendMode.LAYER</codeph>。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DARKEN"><apiName>DARKEN</apiName><shortdesc>
在显示对象原色和背景颜色中选择相对较暗的颜色（具有较小值的颜色）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>darken</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
在显示对象原色和背景颜色中选择相对较暗的颜色（具有较小值的颜色）。此设置通常用于叠加类型。 

<p>例如，如果显示对象的某个像素的 RGB 值为 0xFFCC33，背景像素的 RGB 值为 0xDDF800，则显示像素的结果 RGB 值为 0xDDCC00（因为 0xFF > 0xDD，0xCC &lt; 0xF8，且 0x33 > 0x00 = 33）。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:DIFFERENCE"><apiName>DIFFERENCE</apiName><shortdesc>
将显示对象的原色与背景颜色进行比较，然后从较亮的原色值中减去较暗的原色值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>difference</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
将显示对象的原色与背景颜色进行比较，然后从较亮的原色值中减去较暗的原色值。此设置通常用于得到更明亮的颜色。 

<p>例如，如果显示对象的某个像素的 RGB 值为 0xFFCC33，背景像素的 RGB 值为 0xDDF800，则显示像素的结果 RGB 值为 0x222C33（因为 0xFF - 0xDD = 0x22，0xF8 - 0xCC = 0x2C，且 0x33 - 0x00 = 0x33）。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:ERASE"><apiName>ERASE</apiName><shortdesc>
根据显示对象的 Alpha 值擦除背景。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>erase</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
根据显示对象的 Alpha 值擦除背景。此过程要求将父显示对象的 <codeph>blendMode</codeph> 属性设置为 <codeph>flash.display.BlendMode.LAYER</codeph>。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:HARDLIGHT"><apiName>HARDLIGHT</apiName><shortdesc>
根据显示对象的暗度调整每个像素的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>hardlight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
根据显示对象的暗度调整每个像素的颜色。如果显示对象灰度值高于 50%，则显示对象和背景颜色进行叠加，从而产生较亮的颜色。如果显示对象灰度值低于 50%，则颜色相乘，从而产生较暗的颜色。此设置通常用于获得阴影效果。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:INVERT"><apiName>INVERT</apiName><shortdesc>
反转背景。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>invert</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
反转背景。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LAYER"><apiName>LAYER</apiName><shortdesc>
强制为该显示对象创建一个透明度组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>layer</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
强制为该显示对象创建一个透明度组。这意味着在对显示对象进行进一步处理之前，该对象已在临时缓冲区中预先构成。在以下情况下将会自动完成预先构成操作：显示对象通过位图缓存进行预缓存，或者显示对象是一个显示对象容器，该容器至少具有一个带有 <codeph>blendMode</codeph> 设置（而不是 <codeph>"normal"</codeph>）的子对象。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:LIGHTEN"><apiName>LIGHTEN</apiName><shortdesc>
在显示对象原色和背景颜色中选择相对较亮的颜色（具有较大值的颜色）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lighten</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
在显示对象原色和背景颜色中选择相对较亮的颜色（具有较大值的颜色）。此设置通常用于叠加类型。 

<p>例如，如果显示对象的某个像素的 RGB 值为 0xFFCC33，背景像素的 RGB 值为 0xDDF800，则显示像素的结果 RGB 值为 0xFFF833（因为 0xFF > 0xDD，0xCC &lt; 0xF8，且 0x33 > 0x00 = 33）。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:MULTIPLY"><apiName>MULTIPLY</apiName><shortdesc>
将显示对象的原色值与背景颜色的原色值相乘，然后除以 0xFF 进行标准化，从而得到较暗的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>multiply</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
将显示对象的原色值与背景颜色的原色值相乘，然后除以 0xFF 进行标准化，从而得到较暗的颜色。此设置通常用于阴影和深度效果。

<p>例如，如果显示对象中一个像素的某个原色（例如红色）与背景中对应的像素颜色的值均为 0x88，则相乘结果为 0x4840。除以 0xFF 将得到该原色的值 0x48，这是比显示对象或背景颜色暗的阴影。</p>
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
该显示对象出现在背景前面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
该显示对象出现在背景前面。显示对象的像素值会覆盖背景的像素值。在显示对象为透明的区域，背景是可见的。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:OVERLAY"><apiName>OVERLAY</apiName><shortdesc>
根据背景的暗度调整每个像素的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>overlay</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
根据背景的暗度调整每个像素的颜色。如果背景灰度值高于 50%，则显示对象和背景颜色进行叠加，从而产生较亮的颜色。如果背景灰度值低于 50%，则颜色相乘，从而产生较暗的颜色。此设置通常用于获得阴影效果。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SCREEN"><apiName>SCREEN</apiName><shortdesc>
将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>screen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
将显示对象颜色的补色（反色）与背景颜色的补色相乘，会产生漂白效果。此设置通常用于产生加亮效果或用来删除显示对象的黑色区域。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BlendMode:SHADER"><apiName>SHADER</apiName><shortdesc>
使用着色器来定义对象之间的混合。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>shader</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
使用着色器来定义对象之间的混合。

<p>将 <codeph>blendShader</codeph> 属性设置为 Shader 实例时，会自动将显示对象的 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph>。如果在未首先设置 <codeph>blendShader</codeph> 属性的情况下将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph>，则会改为将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.NORMAL</codeph>。如果设置了 <codeph>blendShader</codeph> 属性（这会将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph>），则随后 <codeph>blendMode</codeph> 属性的值发生更改，只需将 <codeph>blendMode</codeph> 属性设置为 <codeph>BlendMode.SHADER</codeph> 即可将混合模式重置为使用混合着色器。除非要更改用于定义混合模式的着色器，否则无需再次设置 <codeph>blendShader</codeph> 属性。</p>

</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#DisplayObject/blendMode"><linktext>flash.display.DisplayObject.blendMode</linktext></link><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue><apiValue id="flash.display:BlendMode:SUBTRACT"><apiName>SUBTRACT</apiName><shortdesc>
从背景颜色的值中减去显示对象原色的值，下限值为 0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>subtract</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
从背景颜色的值中减去显示对象原色的值，下限值为 0。此设置通常用于使两个对象间的变暗溶解产生动画效果。

<p>例如，如果显示对象的某个像素的 RGB 值为 0xAA2233，背景像素的 RGB 值为 0xDDA600，则显示像素的结果 RGB 值为 0x338400（因为 0xDD - 0xAA = 0x33，0xA6 - 0x22 = 0x84 且 0x00 - 0x33 &lt; 0x00）。</p>
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Graphics"><apiName>Graphics</apiName><shortdesc>
 Graphics 类包含一组可用来创建矢量形状的方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 Graphics 类包含一组可用来创建矢量形状的方法。支持绘制的显示对象包括 Sprite 和 Shape 对象。这些类中的每一个类都包括 <codeph>graphics</codeph> 属性，该属性是一个 Graphics 对象。以下是为便于使用而提供的一些辅助函数：<codeph>drawRect()</codeph>、<codeph>drawRoundRect()</codeph>、<codeph>drawCircle()</codeph> 和 <codeph>drawEllipse()</codeph>。
 
 <p>无法通过 ActionScript 代码直接创建 Graphics 对象。如果调用 <codeph>new Graphics()</codeph>，则会引发异常。</p>
 
 <p>Graphics 类是最终类；无法从其派生子类。</p>
 
 
 </apiDesc><example conref="examples\GraphicsExample.as"> 下例使用 GraphicsExample 类绘制圆形、圆角矩形和正方形。执行下列步骤可完成该任务：
 <ol>
    <li>声明 <codeph>size</codeph> 属性以备日后在确定每个形状的大小时使用。</li>
     <li>声明以下属性：将背景色设置为橙色、将边框颜色设置为深灰色、将边框大小设置为 0 个像素、将角半径设置为 9 个像素并将舞台边缘与其它对象之间的间距设置为 5 个像素。</li>
    <li>使用在前面步骤中声明的属性以及使用 Graphics 类的内置方法，可在坐标 x = 0, y = 0 处绘制圆形、圆角矩形和正方形。</li>
    <li>沿舞台顶部重新绘制每个形状，起点为 x = 5，y = 5，各形状之间的间隔为 5 个像素。</li>
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Graphics:beginBitmapFill"><apiName>beginBitmapFill</apiName><shortdesc>
	 用位图图像填充绘图区。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>包含要显示的位的透明或不透明位图图像。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 matrix 对象（属于 flash.geom.Matrix 类），您可以使用它在位图上定义转换。例如，可以使用以下矩阵将位图旋转 45 度（pi/4 弧度）：
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>如果为 <codeph>true</codeph>，则位图图像按平铺模式重复。如果为 <codeph>false</codeph>，位图图像不会重复，并且位图边缘将用于所有扩展出位图的填充区域。 
	 
	 <p>例如，请考虑下列位图（20 x 20 像素的棋盘图案）：</p>
	 
     <p><adobeimage alt="20 x 20 像素棋盘" href="../../images/movieClip_beginBitmapFill_repeat_1.jpg"/></p>
	 
	 <p>当 <codeph>repeat</codeph> 设置为 <codeph>true</codeph> 时（如下例所示），位图填充将重复位图：</p>
	 
     <p><adobeimage alt="60 x 60 像素棋盘" href="../../images/movieClip_beginBitmapFill_repeat_2.jpg"/></p>
	 
	 <p><codeph>repeat</codeph> 设置为 <codeph>false</codeph> 时，位图填充将对位图外部的填充区域使用边缘像素：</p>
	 
     <p><adobeimage alt="60 x 60 像素图像，无重复" href="../../images/movieClip_beginBitmapFill_repeat_3.jpg"/></p>
	 
   	 
	 </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果为 <codeph>false</codeph>，则使用最近邻点算法来呈现放大的位图图像，而且该图像看起来是像素化的。如果为 <codeph>true</codeph>，则使用双线性算法来呈现放大的位图图像。使用最近邻点算法呈现较快。
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>开始绘制位图填充的形状。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 用位图图像填充绘图区。可以重复或平铺位图以填充该区域。该填充将保持有效，直到您调用 <codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginShaderFill()</codeph> 方法。调用 <codeph>clear()</codeph> 方法会清除填充。
	 
	 <p>只要绘制 3 个或更多个点，或者调用 <codeph>endFill()</codeph> 方法时，应用程序就会呈现填充。 </p>
	 
	 </apiDesc><example conref="examples\Graphics_beginBitmapFillExample.as"> 下面的示例使用一个图像 (<codeph>image1.jpg</codeph>)，它不断旋转并反复填充一个矩形。
 
 <ol>
    <li>使用 <codeph>Loader</codeph> 和 <codeph>URLRequest</codeph> 对象加载此图像文件 (<codeph>image1.jpg</codeph>)。此处，该文件位于与 SWF 文件相同的目录中。需要编译 SWF 文件，并将“本地回放安全性”设置为“只访问本地文件”。</li>
     <li>在加载图像后（<codeph>Event</codeph> 为 complete），将调用 <codeph>drawImage()</codeph> 方法。如果未正确加载图像，<codeph>ioErrorHandler()</codeph> 方法将写入跟踪注释。</li>  
  <li>在 <codeph>drawImage()</codeph> 方法中，将实例化 <codeph>BitmapData</codeph> 对象，并将其宽度和高度设置为图像 (<codeph>image1.jpg</codeph>) 的宽度和高度。然后，将源图像绘制到 BitmapData 对象中。接下来，在 <codeph>mySprite</codeph> Sprite 对象中绘制一个矩形，并使用 BitmapData 对象对其进行填充。通过使用 <codeph>Matrix</codeph> 对象，<codeph>beginBitmapFill()</codeph> 方法将图像旋转 45 度，然后开始使用图像填充矩形，直至完成时为止。</li> 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginFill"><apiName>beginFill</apiName><shortdesc>
 	 指定一种简单的单一颜色填充，在绘制时该填充将在随后对其它 Graphics 方法（如 lineTo() 或 drawCircle()）的调用中使用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>填充的颜色 (0xRRGGBB)。
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>填充的 Alpha 值（从 0.0 到 1.0）。 
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>指定单色填充。
     
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 指定一种简单的单一颜色填充，在绘制时该填充将在随后对其它 Graphics 方法（如 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph>）的调用中使用。该填充将保持有效，直到您调用 <codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginShaderFill()</codeph> 方法。调用 <codeph>clear()</codeph> 方法会清除填充。
	 
	 <p>只要绘制 3 个或更多个点，或者调用 <codeph>endFill()</codeph> 方法时，应用程序就会呈现填充。</p>
	 
	 </apiDesc><example>有关如何使用此方法的说明，请参阅此类末尾的<xref href="Graphics.html#includeExamplesSummary">示例</xref>。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginGradientFill"><apiName>beginGradientFill</apiName><shortdesc>
	 指定一种渐变填充，用于随后调用对象的其它 Graphics 方法（如 lineTo() 或 drawCircle()）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>type</codeph> 参数无效。
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>用于指定要使用哪种渐变类型的 GradientType 类的值：<codeph>GradientType.LINEAR</codeph> 或 <codeph>GradientType.RADIAL</codeph>。 
	 
     </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>渐变中使用的 RGB 十六进制颜色值的数组（例如，红色为 0xFF0000，蓝色为 0x0000FF，等等）。可以至多指定 15 种颜色。对于每种颜色，请在 alphas 和 ratios 参数中指定对应值。
     
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>colors 数组中对应颜色的 alpha 值数组；有效值为 0 到 1。如果值小于 0，则默认值为 0。如果值大于 1，则默认值为 1。
     
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>颜色分布比率的数组；有效值为 0 到 255。该值定义 100% 采样的颜色所在位置的宽度百分比。值 0 表示渐变框中的左侧位置，255 表示渐变框中的右侧位置。 
	 
	 <p><b>注意：</b>此值表示渐变框中的位置，而不是最终渐变的坐标空间，最终渐变可能会比渐变框更宽或更窄。为 <codeph>colors</codeph> 参数中的每个值指定一个值。 </p>
	 
	 <p>例如，对于包括蓝和绿两种颜色的线性渐变，下例显示了基于不同 <codeph>ratios</codeph> 数组值的渐变中的颜色配比：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>渐变</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
	 	<entry><adobeimage alt="ratios 为 0 和 127 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="ratios 为 0 和 255 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="ratios 为 127 和 255 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>数组中的值必须持续增加；例如，<codeph>[0, 63, 127, 190, 255]</codeph>。 </p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个由 flash.geom.Matrix 类定义的转换矩阵。flash.geom.Matrix 类包括 <codeph>createGradientBox()</codeph> 方法，通过该方法可以方便地设置矩阵，以便与 <codeph>beginGradientFill()</codeph> 方法一起使用。
	 
     </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>用于指定要使用哪种 spread 方法的 SpreadMethod 类的值：<codeph>SpreadMethod.PAD</codeph>、<codeph>SpreadMethod.REFLECT</codeph> 或 <codeph>SpreadMethod.REPEAT</codeph>。 
	 
	 <p>例如，请考虑两种颜色之间的简单线性渐变：</p>
	 
	 <codeblock>
	 import flash.geom.*
	 import flash.display.*
	 var fillType:String = GradientType.LINEAR;
	 var colors:Array = [0xFF0000, 0x0000FF];
	 var alphas:Array = [1, 1];
	 var ratios:Array = [0x00, 0xFF];
	 var matr:Matrix = new Matrix();
	 matr.createGradientBox(20, 20, 0, 0, 0);
	 var spreadMethod:String = SpreadMethod.PAD;
	 this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);		
	 this.graphics.drawRect(0,0,100,100);
	 </codeblock>
	 
	 	<p>此示例将 <codeph>SpreadMethod.PAD</codeph> 用于 spread 方法，并且渐变填充看起来将类似于下图：</p>
	 
      <p><adobeimage alt="以 SpreadMethod.PAD 线性渐变" href="../../images/beginGradientFill_spread_pad.jpg"/></p>
 	 
	 	<p>如果将 <codeph>SpreadMethod.REFLECT</codeph> 用于 spread 方法，则渐变填充看起来将类似于下图：</p>
 	 
      <p><adobeimage alt="以 SpreadMethod.REFLECT 线性渐变" href="../../images/beginGradientFill_spread_reflect.jpg"/></p>
 	 
	 	<p>如果将 <codeph>SpreadMethod.REPEAT</codeph> 用于 spread 方法，则渐变填充看起来将类似于下图：</p>
 	 
      <p><adobeimage alt="以 SpreadMethod.REPEAT 线性渐变" href="../../images/beginGradientFill_spread_repeat.jpg"/></p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>用于指定要使用哪个值的 InterpolationMethod 类的值：<codeph>InterpolationMethod.LINEAR_RGB</codeph> 或 <codeph>InterpolationMethod.RGB</codeph>
	 
	 <p>例如，假设有两种颜色之间的简单线性渐变（<codeph>spreadMethod</codeph> 参数设置为 <codeph>SpreadMethod.REFLECT</codeph>）。不同的插值方法对外观的影响如下所示： </p>
	 
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center">  <adobeimage alt="以 InterpolationMethod.LINEAR_RGB 线性渐变" href="../../images/beginGradientFill_interp_linearrgb.jpg"/>  </entry>
      <entry align="center">  <adobeimage alt="以 InterpolationMethod.RGB 线性渐变" href="../../images/beginGradientFill_interp_rgb.jpg"/>  </entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个控制渐变的焦点位置的数字。0 表示焦点位于中心。1 表示焦点位于渐变圆的一条边界上。-1 表示焦点位于渐变圆的另一条边界上。小于 -1 或大于 1 的值将舍入为 -1 或 1。例如，下例显示 <codeph>focalPointRatio</codeph> 设置为 0.75：
	 
     <p><adobeimage alt="focalPointRatio 设置为 0.75 时的放射状渐变" href="../../images/radial_sketch.jpg"/> </p>
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>指定渐变填充。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 指定一种渐变填充，用于随后调用对象的其它 Graphics 方法（如 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph>）。该填充将保持有效，直到您调用 <codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginShaderFill()</codeph> 方法。调用 <codeph>clear()</codeph> 方法会清除填充。
	 
	 <p>只要绘制 3 个或更多个点，或者调用 <codeph>endFill()</codeph> 方法时，应用程序就会呈现填充。 </p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:beginShaderFill"><apiName>beginShaderFill</apiName><shortdesc>
 	 为对象指定着色器填充，供随后调用其它 Graphics 方法（如 lineTo() 或 drawCircle()）时使用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>当着色器输出类型与此操作不兼容时（着色器必须指定 <codeph>pixel3</codeph> 或 <codeph>pixel4</codeph> 输出）。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当着色器指定了未提供的图像输入时。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当使用 ByteArray 或 Vector.&lt;Number> 实例作为输入，并且没有为 ShaderInput 指定 <codeph>width</codeph> 和 <codeph>height</codeph> 属性或指定的值与输入对象中的数据量不匹配时。有关详细信息，请参阅 <codeph>ShaderInput.input</codeph> 属性。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>要用于填充的着色器。此 Shader 实例无需指定图像输入。但是，如果在着色器中指定图像输入，则必须手动提供输入。要指定输入，请设置 <codeph>Shader.data</codeph> 属性的对应 ShaderInput 属性的 <codeph>input</codeph> 属性。
	 
	 <p>传递 Shader 实例作为参数时，会在内部复制着色器。绘图填充操作将使用该内部副本，而不是对原始着色器的引用。对着色器进行的任何更改（比如更改参数值、输入或字节代码）不会应用于所复制的用于填充的着色器。</p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 matrix 对象（属于 flash.geom.Matrix 类），可用于对着色器定义转换。例如，可以使用以下矩阵将着色器旋转 45 度（pi/4 弧度）：
	 
	 <codeblock>
	 matrix = new flash.geom.Matrix(); 
	 matrix.rotate(Math.PI / 4);
	 </codeblock>
	 
	 <p>着色器中收到的坐标基于为 <codeph>matrix</codeph> 参数指定的矩阵。对于默认 (<codeph>null</codeph>) 矩阵，着色器中的坐标是可用于对输入采样的局部像素坐标。</p>
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>指定着色器填充。
	 
 	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
 	 为对象指定着色器填充，供随后调用其它 Graphics 方法（如 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph>）时使用。该填充将保持有效，直到您调用 <codeph>beginFill()</codeph>、<codeph>beginBitmapFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginShaderFill()</codeph> 方法。调用 <codeph>clear()</codeph> 方法会清除填充。
	 
	 <p>只要绘制 3 个或更多个点，或者调用 <codeph>endFill()</codeph> 方法时，应用程序就会呈现填充。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/endFill()"><linktext>endFill()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:clear"><apiName>clear</apiName><shortdesc>
     清除绘制到此 Graphics 对象的图形，并重置填充和线条样式设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
     清除绘制到此 Graphics 对象的图形，并重置填充和线条样式设置。
     
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:copyFrom"><apiName>copyFrom</apiName><shortdesc>
	 将源 Graphics 对象中的所有绘画命令复制到执行调用的 Graphics 对象中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceGraphics</apiItemName><apiOperationClassifier>flash.display:Graphics</apiOperationClassifier><apiDesc>从中复制绘画命令的 Graphics 对象。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将源 Graphics 对象中的所有绘画命令复制到执行调用的 Graphics 对象中。
	 
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:curveTo"><apiName>curveTo</apiName><shortdesc>
	 使用当前线条样式和由 (controlX, controlY) 指定的控制点绘制一条从当前绘画位置开始到 (anchorX, anchorY) 结束的曲线。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定控制点相对于父显示对象注册点的水平位置。  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定控制点相对于父显示对象注册点的垂直位置。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定下一个锚点相对于父显示对象注册点的水平位置。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定下一个锚点相对于父显示对象注册点的垂直位置。  
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>使用由 (controlX, controlY) 指定的控制点绘制一条从当前绘画位置开始到 (anchorX, anchorY) 结束的曲线。
     
	 
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 通过由 (<codeph>controlX</codeph>, <codeph>controlY</codeph>) 指定的控制点，使用当前线条样式绘制一条从当前绘画位置开始到 (anchorX, anchorY) 结束的曲线。当前绘画位置随后设置为 (<codeph>anchorX</codeph>, <codeph>anchorY</codeph>)。如果正在其中绘制的影片剪辑包含用 Flash 绘画工具创建的内容，则调用 <codeph>curveTo()</codeph> 方法将在该内容下面进行绘制。如果在调用 <codeph>moveTo()</codeph> 方法之前调用了 <codeph>curveTo()</codeph> 方法，则当前绘画位置的默认值为 (0, 0)。如果缺少任何一个参数，则此方法将失败，并且当前绘画位置不改变。
	 
	 <p>绘制的曲线是二次贝塞尔曲线。二次贝塞尔曲线包含两个锚点和一个控制点。该曲线内插这两个锚点，并向控制点弯曲。 </p>
	 
	 <p><adobeimage alt="二次贝塞尔和三次贝塞尔" href="../../images/quad_bezier.jpg"/></p>
	 
  	 </apiDesc><example conref="examples\Graphics_curveToExample1.as"> 下面的示例在 Sprite 显示对象注册点 (0, 0) 右侧 250 个像素的位置绘制一个绿色圆形对象，宽度和高度为 100 个像素。 
 <p>绘制 4 条曲线以生成一个圆，并将其填充为绿色。</p>
   
 <p>请注意，由于二次贝塞尔方程式所具有的特性，此对象并不是完美的圆。绘制圆的最佳方法是使用 Graphics 类的 <codeph>drawCircle()</codeph> 方法。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</codeblock></example><example conref="examples\Graphics_curveToExample2.as"> 下面的示例使用 <codeph>curveTo()</codeph> 方法绘制一个新月。
 
 <p>绘制两条 1 个像素粗的曲线，并将两条曲线之间的区域填充为白色。<codeph>moveTo()</codeph> 方法用于将当前绘制位置放在坐标 (100, 100) 上。第一条曲线将绘制位置移到 (100, 200)，这是其目标点。第二条曲线将该位置恢复为开始位置 (100, 100)，这是其目标点。水平控制点决定了不同的曲线大小。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:drawCircle"><apiName>drawCircle</apiName><shortdesc>
	 绘制一个圆。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>圆心相对于父显示对象注册点的 <i>x</i> 位置（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>相对于父显示对象注册点的圆心的 <i>y</i> 位置（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>radius</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>圆的半径（以像素为单位）。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>绘制一个圆。
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 绘制一个圆。在调用 <codeph>drawCircle()</codeph> 方法之前，通过调用 <codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginBitmapFill()</codeph> 方法来设置线条样式或/和填充。
	 
	 </apiDesc><example>有关如何使用此方法的说明，请参阅此类末尾的<xref href="Graphics.html#includeExamplesSummary">示例</xref>。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawEllipse()"><linktext>drawEllipse()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawEllipse"><apiName>drawEllipse</apiName><shortdesc>
	 绘制一个椭圆。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>椭圆边框左上角相对于父显示对象注册点的 <i>x</i> 位置（以像素为单位）。
	
	</apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>椭圆边框左上角相对于父显示对象注册点的 <i>y</i> 位置（以像素为单位）。
	
	</apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>椭圆的宽度（以像素为单位）。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>椭圆的高度（以像素为单位）。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>绘制一个椭圆。
         
         </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 绘制一个椭圆。在调用 <codeph>drawEllipse()</codeph> 方法之前，通过调用 <codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginBitmapFill()</codeph> 方法来设置线条样式或/和填充。
	 
	 </apiDesc><example conref="examples\Graphics_drawEllipseExample.as"> 下面的示例使用 <codeph>drawEgg()</codeph> 函数绘制三个不同大小的鸡蛋（三种尺寸的椭圆），具体取决于 <codeph>eggSize</codeph> 参数。  
 <ol>
 <li>构造函数调用 <codeph>drawEgg()</codeph> 函数，并为应该绘制鸡蛋的位置传递水平和垂直参数以及鸡蛋类型 (<codeph>eggSize</codeph>)。（可使用鸡蛋（椭圆形）高度和宽度来确定其显示位置。）</li> 
 <li><codeph>drawEgg()</codeph> 函数绘制不同大小的椭圆，并使用 <codeph>beginFill()</codeph> 方法将其填充为白色。没有事先为此函数编写错误处理代码。</li>
 </ol>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/drawCircle()"><linktext>drawCircle()</linktext></link><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawGraphicsData"><apiName>drawGraphicsData</apiName><shortdesc>
	 提交一系列 IGraphicsData 实例来进行绘图。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>graphicsData</apiItemName><apiType value="Vector$flash.display:IGraphicsData"/><apiDesc>一个包含图形对象的矢量，其中的每个对象都必须实现 IGraphicsData 接口。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 提交一系列 IGraphicsData 实例来进行绘图。此方法接受一个包含对象（包括路径、填充和笔触）的矢量，这些对象实现 IGraphicsData 接口。包含 IGraphicsData 实例的矢量可以引用形状的一部分，或引用一组完整定义的复杂数据以呈现完整的形状。
     
     
     <p>
     图形路径可以包含其它图形路径。如果 <codeph>graphicsData</codeph> 矢量包括路径，则在此操作期间将呈现该路径及其所有子路径。
     </p>
     
     </apiDesc><example conref="examples\Graphics_DrawGraphicsDataExample.as"> 以下示例创建了一个 GraphicsGradientFill 对象，用于建立正方形的填充属性。然后，该示例创建了一个 GraphicsStroke 对象（表示线宽）类和 GraphicsSolidFill 对象（表示线色），用于设置正方形边框线的属性。接下来，创建了一个 GraphicsPath 对象，用于包含绘制形状所用的值。所有这些对象都存储在 IGraphicsData 对象中，并传递给 <codeph>drawGraphicsData()</codeph> 命令来呈现形状。
<codeblock>
package{
    import flash.display.*;
    import flash.geom.*;
    
    public class DrawGraphicsDataExample extends Sprite {

    public function DrawGraphicsDataExample(){    

    // establish the fill properties
    var myFill:GraphicsGradientFill = new GraphicsGradientFill();
    myFill.colors = [0xEEFFEE, 0x0000FF];
    myFill.matrix = new Matrix();
    myFill.matrix.createGradientBox(100, 100, 0);
 
    // establish the stroke properties
    var myStroke:GraphicsStroke = new GraphicsStroke(2);
    myStroke.fill = new GraphicsSolidFill(0x000000);
 
    // establish the path properties
    var myPath:GraphicsPath = new GraphicsPath(new Vector.&lt;int>(), new Vector.&lt;Number>());
    myPath.commands.push(1,2,2,2,2);
    myPath.data.push(10,10, 10,100, 100,100, 100,10, 10,10);
 
    // populate the IGraphicsData Vector array
    var myDrawing:Vector.&lt;IGraphicsData> = new Vector.&lt;IGraphicsData>();
    myDrawing.push(myFill, myStroke, myPath);
 
    // render the drawing 
    graphics.drawGraphicsData(myDrawing);
    }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#IGraphicsData"><linktext>flash.display.IGraphicsData</linktext></link><link href="flash.display.xml#GraphicsBitmapFill"><linktext>flash.display.GraphicsBitmapFill</linktext></link><link href="flash.display.xml#GraphicsEndFill"><linktext>flash.display.GraphicsEndFill</linktext></link><link href="flash.display.xml#GraphicsGradientFill"><linktext>flash.display.GraphicsGradientFill</linktext></link><link href="flash.display.xml#GraphicsPath"><linktext>flash.display.GraphicsPath</linktext></link><link href="flash.display.xml#GraphicsShaderFill"><linktext>flash.display.GraphicsShaderFill</linktext></link><link href="flash.display.xml#GraphicsSolidFill"><linktext>flash.display.GraphicsSolidFill</linktext></link><link href="flash.display.xml#GraphicsStroke"><linktext>flash.display.GraphicsStroke</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawPath"><apiName>drawPath</apiName><shortdesc>
	 提交一系列绘制命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiDesc>一个由整数构成的矢量，表示由 GraphicsPathCommand 类定义的命令。GraphicsPathCommand 类将命令映射到此矢量数组的数字标识符。
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiDesc>由数字构成的矢量，其中的每一对数字将被视为一个坐标位置（一个 x, y 对）。x 和 y 坐标值对不是 Point 对象；<codeph>data</codeph> 矢量是一系列数字，其中的每个由两个数字构成的组表示一个坐标位置。 
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>使用 GraphicsPathWinding 类中定义的值指定缠绕规则。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 提交一系列绘制命令。<codeph>drawPath()</codeph> 方法使用矢量数组来将各个 <codeph>moveTo()</codeph>、<codeph>lineTo()</codeph> 和 <codeph>curveTo()</codeph> 绘图命令并入到一个调用中。<codeph>drawPath()</codeph> 方法参数将绘图命令与 x 和 y 坐标值对以及绘图方向合并起来。绘图命令为 GraphicsPathCommand 类中的值。x 和 y 坐标值对是数组中的数字，其中的每对数字定义一个坐标位置。绘图方向为 GraphicsPathWinding 类中的值。
     
	 <p>
	 通常，与使用一系列单个 <codeph>lineTo()</codeph> 和 <codeph>curveTo()</codeph> 方法相比，使用 <codeph>drawPath()</codeph> 呈现绘图的速度会更快。 
	 </p>
     
	 <p>
     <codeph>drawPath()</codeph> 方法使用浮动计算，因此形状的旋转和缩放更准确，可以获得更好的结果。但是，通过使用 <codeph>drawPath()</codeph> 方法提交的曲线在与 <codeph>lineTo()</codeph> 和 <codeph>curveTo()</codeph> 方法结合使用时，可能会存在小的子像素对齐误差。
     </p>
     
	 <p>
	 <codeph>drawPath()</codeph> 方法还使用稍有不同的规则进行填充和绘制线条。这些规则是：
     </p>
     
	 <ul>
     <li>在应用填充以呈现路径时：
	  <ul>
          <li>不呈现少于 3 个点的子路径。（但请注意，笔触呈现仍将发生，并与下面的笔触规则相一致。）</li>
	      <li>隐式闭合未闭合的子路径（结束点不等于开始点）。</li>
	   </ul>
     </li>
     <li>在应用笔触以呈现路径时：
       <ul>
	     <li>子路径可以由任何数量的点组成。</li>
	     <li>从不隐式闭合子路径。</li>
        </ul>
     </li>
     </ul>
     
     </apiDesc><example conref="examples\Graphics_DrawPathExample.as"> 下面的示例填充两个 Vector 对象，然后将其传递给 <codeph>drawPath()</codeph> 方法以呈现一个蓝星。第一个 Vector 对象 <codeph>star_commands</codeph> 包含一系列表示 flash.display.GraphicsPathCommand 类中的绘图命令的整数，其中的值 1 表示 <codeph>MoveTo()</codeph> 命令，值 2 表示 <codeph>LineTo()</codeph> 命令。第二个 Vector 对象 <codeph>star_coord</codeph> 包含 5 组 x 和 y 坐标对。<codeph>drawPath()</codeph> 方法将命令与位置进行匹配以绘制一个星形。
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {

    public function DrawPathExample(){

    var star_commands:Vector.&lt;int> = new Vector.&lt;int>(5, true);
    
    star_commands[0] = 1;
    star_commands[1] = 2;
    star_commands[2] = 2;
    star_commands[3] = 2;
    star_commands[4] = 2;

    var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>(10, true);
    star_coord[0] = 66; //x
    star_coord[1] = 10; //y 
    star_coord[2] = 23; 
    star_coord[3] = 127; 
    star_coord[4] = 122; 
    star_coord[5] = 50; 
    star_coord[6] = 10; 
    star_coord[7] = 49; 
    star_coord[8] = 109; 
    star_coord[9] = 127;


    graphics.beginFill(0x003366);
    graphics.drawPath(star_commands, star_coord);

    }

    }
}

</codeblock></example><example conref="examples\Graphics_DrawPathExample2.as"> 在以上示例中，每个命令和坐标对是分别赋值的，以显示其在数组中的位置，但是可以在一条语句中同时对其进行赋值。以下示例通过在一条 <codeph>push()</codeph> 语句中同时为各个数组赋值来绘制这个星形：
<codeblock>
package{
    import flash.display.*;
    
    public class DrawPathExample extends Sprite {
    public function DrawPathExample(){
        var star_commands:Vector.&lt;int> = new Vector.&lt;int>();
        star_commands.push(1, 2, 2, 2, 2);

           var star_coord:Vector.&lt;Number> = new Vector.&lt;Number>();
           star_coord.push(66,10, 23,127, 122,50, 10,49, 109,127);

        graphics.beginFill(0x003366);
        graphics.drawPath(star_commands, star_coord);
    }
    }
}


</codeblock> <b>注意：</b>默认情况下，<codeph>drawPath()</codeph> 方法使用奇偶缠绕类型。因此，不会填充星形的中心。为第三个参数指定非零的缠绕类型，该类型将填充星形的中心：
 <codeblock>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </codeblock>
 
</example></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRect"><apiName>drawRect</apiName><shortdesc>
	 绘制一个矩形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>width</codeph> 或 <codeph>height</codeph> 参数不是数值 (<codeph>Number.NaN</codeph>)。
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>矩形的宽度（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>矩形的高度（以像素为单位）。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>绘制一个圆角矩形。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 绘制一个矩形。在调用 <codeph>drawRect()</codeph> 方法之前，通过调用 <codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginBitmapFill()</codeph> 方法来设置线条样式或/和填充。
	 
	 </apiDesc><example>有关如何使用此方法的说明，请参阅此类末尾的<xref href="Graphics.html#includeExamplesSummary">示例</xref>。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRoundRect()"><linktext>drawRoundRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawRoundRect"><apiName>drawRoundRect</apiName><shortdesc>
	 绘制一个圆角矩形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>width</codeph>、<codeph>height</codeph>、<codeph>ellipseWidth</codeph> 或 <codeph>ellipseHeight</codeph> 参数不是数值 (<codeph>Number.NaN</codeph>)。
	 
     </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>圆角矩形的宽度（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>圆角矩形的高度（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseWidth</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>用于绘制圆角的椭圆的宽度（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>ellipseHeight</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>用于绘制圆角的椭圆的高度（以像素为单位）。（可选）如果未指定值，则默认值与为 <codeph>ellipseWidth</codeph> 参数提供的值相匹配。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>绘制一个圆角矩形。
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 绘制一个圆角矩形。在调用 <codeph>drawRoundRect()</codeph> 方法之前，通过调用 <codeph>linestyle()</codeph>、<codeph>lineGradientStyle()</codeph>、<codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginBitmapFill()</codeph> 方法来设置线条样式或/和填充。
	 
	 </apiDesc><example>有关如何使用此方法的说明，请参阅此类末尾的<xref href="Graphics.html#includeExamplesSummary">示例</xref>。 
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/drawRect()"><linktext>drawRect()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:drawTriangles"><apiName>drawTriangles</apiName><shortdesc>
	 呈现一组三角形（通常用于扭曲位图），并为其指定三维外观。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>vertices</apiItemName><apiType value="Vector$Number"/><apiDesc>由数字构成的矢量，其中的每一对数字将被视为一个坐标位置（一个 x, y 对）。<codeph>vertices</codeph> 参数是必需的。
     
     </apiDesc></apiParam><apiParam><apiItemName>indices</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>一个由整数或索引构成的矢量，其中每三个索引定义一个三角形。如果 <codeph>indexes</codeph> 参数为 null，则每三个顶点（<codeph>vertices</codeph> 矢量中的 6 对 x,y）定义一个三角形。否则，每个索引将引用一个顶点，即 <codeph>vertices</codeph> 矢量中的一对数字。例如，<codeph>indexes[1]</codeph> 引用 (<codeph>vertices[2]</codeph>, <codeph>vertices[3]</codeph>)。<codeph>indexes</codeph> 参数是可选的，但 indexes 通常会减少提交的数据量和计算的数据量。 
     
     </apiDesc></apiParam><apiParam><apiItemName>uvtData</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>由用于应用纹理映射的标准坐标构成的矢量。每个坐标引用用于填充的位图上的一个点。每个顶点必须具有一个 UV 或一个 UVT 坐标。对于 UV 坐标，(0,0) 是位图的左上角，(1,1) 是位图的右下角。 
     <p>如果此矢量的长度是 <codeph>vertices</codeph> 矢量长度的两倍，则使用标准坐标而不进行透视校正。 </p>
     <p>如果此矢量的长度是 <codeph>vertices</codeph> 矢量长度的三倍，则将第三个坐标解释为“t”（即在视角空间中从视点到纹理的距离）。这有助于呈现引擎在三维中映射纹理时正确应用透视。</p>
     <p>如果 <codeph>uvtData</codeph> 参数为 null，则将应用普通填充规则（和任何填充类型）。</p>
     
     </apiDesc></apiParam><apiParam><apiItemName>culling</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>none</apiData><apiDesc>指定是否呈现面向指定方向的三角形。此参数可防止呈现在当前视图中看不见的三角形。此参数可设置为由 TriangleCulling 类定义的任何值。 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 呈现一组三角形（通常用于扭曲位图），并为其指定三维外观。<codeph>drawTriangles()</codeph> 方法使用一组 (u,v) 坐标将当前填充或位图填充映射到三角形面。 
     <p>
     可以使用任何类型的填充，但如果填充有转换矩阵，则将忽略该转换矩阵。
     </p>
     
     <p>
     在使用位图填充时，<codeph>uvtData</codeph> 参数可改善纹理映射。 
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#TriangleCulling"><linktext>flash.display.TriangleCulling</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:endFill"><apiName>endFill</apiName><shortdesc>
	 对从上一次调用 beginFill()、beginGradientFill() 或 beginBitmapFill() 方法之后添加的直线和曲线应用填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example creates a square with red fill on the Stage:
	 
	 <listing>
	 this.createEmptyMovieClip("square_mc", this.getNextHighestDepth());
	 square_mc.beginFill(0xFF0000);
	 square_mc.moveTo(10, 10);
	 square_mc.lineTo(100, 10);
	 square_mc.lineTo(100, 100);
	 square_mc.lineTo(10, 100);
	 square_mc.lineTo(10, 10);
	 square_mc.endFill();
	 </listing>
	 
	 </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>对直线和曲线应用填充。
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 对从上一次调用 <codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginBitmapFill()</codeph> 方法之后添加的直线和曲线应用填充。Flash 使用的是对 <codeph>beginFill()</codeph>、<codeph>beginGradientFill()</codeph> 或 <codeph>beginBitmapFill()</codeph> 方法的先前调用中指定的填充。如果当前绘画位置不等于 <codeph>moveTo()</codeph> 方法中指定的上一个位置，而且定义了填充，则用线条闭合该路径，然后进行填充。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>beginFill()</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>beginBitmapFill()</linktext></link><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>beginGradientFill()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineBitmapStyle"><apiName>lineBitmapStyle</apiName><shortdesc>
	 指定一个位图，用于绘制线条时的线条笔触。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bitmap</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>用于线条笔触的位图。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个由 flash.geom.Matrix 类定义的可选转换矩阵。该矩阵可用于在将位图应用于线条样式之前缩放位图或以其它方式处理位图。
     
     </apiDesc></apiParam><apiParam><apiItemName>repeat</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>是否以平铺方式重复位图。
     
     </apiDesc></apiParam><apiParam><apiItemName>smooth</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>是否应对位图应用平滑处理。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定一个位图，用于绘制线条时的线条笔触。 
     
     <p>位图线条样式将用于随后对 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph> 等 Graphics 方法的调用。线条样式仍然有效，直到您使用不同的参数调用 <codeph>lineStyle()</codeph> 或 <codeph>lineGradientStyle()</codeph> 方法或再次调用 <codeph>lineBitmapStyle()</codeph> 方法。 </p>
     
     <p>可以在绘制路径的中间调用 <codeph>lineBitmapStyle()</codeph> 方法以为路径中的不同线段指定不同的样式。 </p>
     
     <p>请在调用 <codeph>lineBitmapStyle()</codeph> 方法之前调用 <codeph>lineStyle()</codeph> 方法以启用笔触，否则线条样式的值将为 <codeph>undefined</codeph>。</p>
     
     <p>调用 <codeph>clear()</codeph> 方法会将线条样式设置回 <codeph>undefined</codeph>。
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>lineGradientStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineGradientStyle"><apiName>lineGradientStyle</apiName><shortdesc>
	 指定一种渐变，用于绘制线条时的笔触。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>用于指定要使用哪种渐变类型的 GradientType 类的值：GradientType.LINEAR 或 GradientType.RADIAL。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colors</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>要在渐变中使用的 RGB 十六进制颜色值数组（例如，红色为 0xFF0000，蓝色为 0x0000FF 等等）。
	 
     </apiDesc></apiParam><apiParam><apiItemName>alphas</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>colors 数组中对应颜色的 alpha 值数组；有效值为 0 到 1。如果值小于 0，则默认值为 0。如果值大于 1，则默认值为 1。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>ratios</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiDesc>颜色分布比率的数组；有效值为 0 到 255。该值定义 100% 采样的颜色所在位置的宽度百分比。值 0 表示渐变框中的左侧位置，255 表示渐变框中的右侧位置。此值表示渐变框中的位置，而不是最终渐变的坐标空间，最终渐变可能会比渐变框更宽或更窄。为 <codeph>colors</codeph> 参数中的每个值指定一个值。 
	 
	 <p>例如，对于包含蓝和绿两种颜色的线性渐变，下图显示了基于不同 <codeph>ratios</codeph> 数组值的颜色配比：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>ratios</codeph></entry><entry>渐变</entry></row></thead><tbody><row>
	 
	 	<entry><codeph>[0, 127]</codeph></entry>
      <entry><adobeimage alt="ratios 为 0 和 127 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-1.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[0, 255]</codeph></entry>
      <entry><adobeimage alt="ratios 为 0 和 255 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-2.jpg"/></entry>
	 
	 </row><row>
	 
	 	<entry><codeph>[127, 255]</codeph></entry>
      <entry><adobeimage alt="ratios 为 127 和 255 时蓝色到绿色的线性渐变" href="../../images/gradient-ratios-3.jpg"/></entry>
	 
	 </row></tbody></tgroup></adobetable>
	 
	 <p>数组中的值必须持续增加；例如，<codeph>[0, 63, 127, 190, 255]</codeph>。 </p>
   	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个由 flash.geom.Matrix 类定义的转换矩阵。flash.geom.Matrix 类包括 <codeph>createGradientBox()</codeph> 方法，通过该方法可以方便地设置矩阵，以便与 <codeph>lineGradientStyle()</codeph> 方法一起使用。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>spreadMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>pad</apiData><apiDesc>用于指定要使用哪种 spread 方法的 SpreadMethod 类的值： 
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="3"><tbody><row><entry align="center"><adobeimage alt="以 SpreadMethod.PAD 线性渐变" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>
      <entry align="center"><adobeimage alt="以 SpreadMethod.REFLECT 线性渐变" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>
      <entry align="center"><adobeimage alt="以 SpreadMethod.REPEAT 线性渐变" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>
	 	<entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>interpolationMethod</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>rgb</apiData><apiDesc>InterpolationMethod 类中用于指定要使用的值的值。例如，假设有两种颜色之间的简单线性渐变（<codeph>spreadMethod</codeph> 参数设置为 <codeph>SpreadMethod.REFLECT</codeph>）。不同的插值方法对外观的影响如下所示：
	 
	 <p>
      <adobetable>
	 	
      
	 	
	 	
	 	
	 	<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="以 InterpolationMethod.LINEAR_RGB 线性渐变" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="以 InterpolationMethod.RGB 线性渐变" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
	 	</row><row>
	 	<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
	 	<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
	 	</row></tbody></tgroup></adobetable>
	 </p>
	 
	 </apiDesc></apiParam><apiParam><apiItemName>focalPointRatio</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>0</apiData><apiDesc>一个控制渐变的焦点位置的数字。值 0 表示焦点位于中心。值 1 表示焦点位于渐变圆的一条边界上。值 -1 表示焦点位于渐变圆的另一条边界上。小于 -1 或大于 1 的值将舍入为 -1 或 1。下列图像显示 <codeph>focalPointRatio</codeph> 为 -0.75 的渐变：
   	 
     <p><adobeimage alt="focalPointRatio 设置为 0.75 时的放射状渐变" href="../../images/radial_sketch.jpg"/> </p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定一种渐变，用于绘制线条时的笔触。
     
     <p>渐变线条样式将用于随后对 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph> 等 Graphics 方法的调用。线条样式仍然有效，直到您使用不同的参数调用 <codeph>lineStyle()</codeph> 或 <codeph>lineBitmapStyle()</codeph> 方法或再次调用 <codeph>lineGradientStyle()</codeph> 方法。 </p>
     
     <p>可以在绘制路径的中间调用 <codeph>lineGradientStyle()</codeph> 方法以为路径中的不同线段指定不同的样式。 </p>
     
     <p>请在调用 <codeph>lineGradientStyle()</codeph> 方法之前调用 <codeph>lineStyle()</codeph> 方法以启用笔触，否则线条样式的值将为 <codeph>undefined</codeph>。</p>
     
     <p>调用 <codeph>clear()</codeph> 方法会将线条样式设置回 <codeph>undefined</codeph>。
     </p>
	 
	 </apiDesc><example conref="examples\Graphics_lineGradientStyleExample.as"> 下面的示例绘制一个矩形和一个圆，它们使用从红色到绿色、再到蓝色的渐变笔触。
 
 <p><codeph>Matrix</codeph> 类中的方法 <codeph>createGradientBox()</codeph> 用于将渐变框定义为 200 个像素宽、40 个像素高。线条粗细设置为 5 个像素。必须为 <codeph>lineGradientStyle()</codeph> 方法定义笔触粗细。渐变设置为线性。渐变颜色设置为红色、绿色和蓝色。颜色透明度（Alpha 值）设置为 1（不透明）。渐变的分布是均匀的，其中在 0（渐变框中的左侧位置）、128（渐变框的中间位置）和 255（渐变框中的右侧位置）处的颜色采样率为 100%。矩形宽度范围内包含渐变的所有色谱；而圆包含色谱中间的 50%。</p>  
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix/createGradientBox()"><linktext>flash.geom.Matrix.createGradientBox()</linktext></link><link href="flash.display.xml#GradientType"><linktext>flash.display.GradientType</linktext></link><link href="flash.display.xml#SpreadMethod"><linktext>flash.display.SpreadMethod</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineShaderStyle"><apiName>lineShaderStyle</apiName><shortdesc>
	 指定一个着色器以用于绘制线条时的线条笔触。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiDesc>用于线条笔触的着色器。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个由 flash.geom.Matrix 类定义的可选转换矩阵。该矩阵可用于在将位图应用于线条样式之前缩放位图或以其它方式处理位图。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 指定一个着色器以用于绘制线条时的线条笔触。 
     
     <p>着色器线条样式将用于随后对 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph> 等 Graphics 方法的调用。线条样式仍然有效，直到您使用不同的参数调用 <codeph>lineStyle()</codeph> 或 <codeph>lineGradientStyle()</codeph> 方法或再次调用 <codeph>lineBitmapStyle()</codeph> 方法。 </p>
     
     <p>可以在绘制路径的中间调用 <codeph>lineShaderStyle()</codeph> 方法，以便为路径中的不同线段指定不同的样式。 </p>
     
     <p>请在调用 <codeph>lineShaderStyle()</codeph> 方法之前调用 <codeph>lineStyle()</codeph> 方法以启用笔触，否则线条样式的值将为 <codeph>undefined</codeph>。</p>
     
     <p>调用 <codeph>clear()</codeph> 方法会将线条样式设置回 <codeph>undefined</codeph>。
     </p>
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>lineStyle()</linktext></link><link href="flash.display.xml#Graphics/lineBitmapStyle()"><linktext>lineBitmapStyle()</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineStyle"><apiName>lineStyle</apiName><shortdesc>
     指定一种线条样式以用于随后对 lineTo() 或 drawCircle() 等 Graphics 方法的调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following code draws a triangle with a 5-pixel, solid magenta line with 
	 no fill, with pixel hinting, no stroke scaling, no caps, and miter joints with 
	 <code>miterLimit</code> set to 1:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", this.getNextHighestDepth());
	 triangle_mc.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 </listing>
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>thickness</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>unknown</apiData><apiDesc>一个整数，以磅为单位表示线条的粗细；有效值为 0 到 255。如果未指定数字，或者未定义该参数，则不绘制线条。如果传递的值小于 0，则默认值为 0。值 0 表示极细的粗细；最大粗细为 255。如果传递的值大于 255，则默认值为 255。 
     
     </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>线条的十六进制颜色值（例如，红色为 0xFF0000，蓝色为 0x0000FF 等）。如果未指明值，则默认值为 0x000000（黑色）。可选。
	 
 	 
     </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>表示线条颜色的 Alpha 值的数字；有效值为 0 到 1。如果未指明值，则默认值为 1（纯色）。如果值小于 0，则默认值为 0。如果值大于 1，则默认值为 1。 
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>pixelHinting</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>用于指定是否提示笔触采用完整像素的布尔值。它同时影响曲线锚点的位置以及线条笔触大小本身。在 <codeph>pixelHinting</codeph> 设置为 <codeph>true</codeph> 的情况下，线条宽度会调整到完整像素宽度。在 <codeph>pixelHinting</codeph> 设置为 <codeph>false</codeph> 的情况下，对于曲线和直线可能会出现脱节。例如，下面的插图显示了 Flash Player 或 Adobe AIR 如何呈现两个相同的圆角矩形，不同之处是 <codeph>lineStyle()</codeph> 方法中使用的 <codeph>pixelHinting</codeph> 参数的设置不同（图像已放大 200% 以强调差异）：
	 
	 <p><adobeimage alt="pixelHinting 为 false，pixelHinting 为 true" href="../../images/lineStyle_pixelHinting.jpg"/></p>
	 
	 <p>如果未提供值，则线条不使用像素提示。</p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>scaleMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>normal</apiData><apiDesc>用于指定要使用哪种缩放模式的 LineScaleMode 类的值：
	 
	 <ul>
	 
	 <li>
	 <codeph>LineScaleMode.NORMAL</codeph> -- 在缩放对象时总是缩放线条的粗细（默认值）。
	 </li>
	 
	 <li>
	 <codeph>LineScaleMode.NONE</codeph> -- 从不缩放线条粗细。
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.VERTICAL</codeph> -- 如果<i>仅</i> 垂直缩放对象，则不缩放线条粗细。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.VERTICAL</codeph>。左边的圆仅在垂直方向上缩放，而右边的圆则同时在垂直和水平方向上缩放：
	 
     <p><adobeimage alt="一个在垂直方向缩放的圆和一个在垂直和水平方向同时缩放的圆。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	 
	 </li>
	 
	 
	 <li>
	 <codeph>LineScaleMode.HORIZONTAL</codeph> -- 如果<i>仅</i> 水平缩放对象，则不缩放线条粗细。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.HORIZONTAL</codeph>。左边的圆仅在水平方向上缩放，而右边的圆则同时在垂直和水平方向上缩放：
	 
     <p><adobeimage alt="一个在水平方向缩放的圆和一个在水平和垂直方向同时缩放的圆。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	 
	 </li>
	 
	 
	 </ul>
	 
	 
     </apiDesc></apiParam><apiParam><apiItemName>caps</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>用于指定线条末端处端点类型的 CapsStyle 类的值。有效值为：<codeph>CapsStyle.NONE</codeph>、<codeph>CapsStyle.ROUND</codeph> 和 <codeph>CapsStyle.SQUARE</codeph>。如果未指示值，则 Flash 使用圆头端点。 
	 <p>例如，以下图示显示了不同的 <codeph>capsStyle</codeph> 设置。对于每种设置，插图显示了一条粗细为 30 的蓝色线条（应用 <codeph>capsStyle</codeph> 的线条），以及重叠于其上的粗细为 1 的黑色线条（未应用 <codeph>capsStyle</codeph> 的线条）：
	 </p>
	 <p><adobeimage alt="NONE、ROUND 和 SQUARE" href="../../images/linecap.jpg"/></p>
	 
     </apiDesc></apiParam><apiParam><apiItemName>joints</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>JointStyle 类的值，指定用于拐角的连接外观的类型。有效值为：<codeph>JointStyle.BEVEL</codeph>、<codeph>JointStyle.MITER</codeph> 和 <codeph>JointStyle.ROUND</codeph>。如果未指示值，则 Flash 使用圆角连接。 
	 
	 <p>例如，以下图示显示了不同的 <codeph>joints</codeph> 设置。对于每种设置，插图显示了一条粗细为 30 的带拐角的蓝色线条（应用 <codeph>jointStyle</codeph> 的线条），以及重叠于其上的粗细为 1 的带拐角的黑色线条（未应用 <codeph>jointStyle</codeph> 的线条）：
	 </p>
	 
     <p><adobeimage alt="MITER、ROUND 和 BEVEL" href="../../images/linejoin.jpg"/></p>
	 
	 <p><b>注意：</b>对于设置为 <codeph>JointStyle.MITER</codeph> 的 <codeph>joints</codeph>，您可以使用 <codeph>miterLimit</codeph> 参数限制尖角的长度。</p>
 	 
	 </apiDesc></apiParam><apiParam><apiItemName>miterLimit</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>3</apiData><apiDesc>一个表示将在哪个限制位置切断尖角的数字。有效值的范围是 1 到 255（超出该范围的值将舍入为 1 或 255）。此值只可用于 <codeph>jointStyle</codeph> 设置为 <codeph>"miter"</codeph> 的情况下。<codeph>miterLimit</codeph> 值表示向外延伸的尖角可以超出角边相交所形成的结合点的长度。此值表示为线条 <codeph>thickness</codeph> 的因子。例如，<codeph>miterLimit</codeph> 因子为 2.5 且 <codeph>thickness</codeph> 为 10 像素时，尖角将在 25 像素处切断。 
	 
	 <p>例如，请考虑下列带拐角的线条，每个线条都以 <codeph>thickness</codeph> 20 进行绘制，但它们的 <codeph>miterLimit</codeph> 分别设置为 1、2 和 4。重叠在其上的黑色参考线条显示了结合处的联结点：</p>
	 
     <p><adobeimage alt="miterLimit 设置为 1、2 和 4 的线条" href="../../images/miterLimit.jpg"/></p>
	 
	 <p>请注意，对于给定的 <codeph>miterLimit</codeph> 值，会有一个被切断的尖角的特定最大角度。下表列出了部分示例：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="2"><thead><row><entry><codeph>miterLimit</codeph> 值：</entry><entry>小于此角度将被切断：</entry></row></thead><tbody><row><entry>1.414</entry>  <entry>90 度</entry></row><row><entry>2</entry>      <entry>60 度</entry></row><row><entry>4</entry>      <entry>30 度</entry></row><row><entry>8</entry>      <entry>15 度</entry></row></tbody></tgroup></adobetable>
	 
     </apiDesc></apiParam><apiTipTexts><apiTipText>指定 Flash 用于绘制线条的线条样式。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     指定一种线条样式以用于随后对 <codeph>lineTo()</codeph> 或 <codeph>drawCircle()</codeph> 等 Graphics 方法的调用。线条样式仍然有效，直到您使用不同的参数调用 <codeph>lineGradientStyle()</codeph> 方法、<codeph>lineBitmapStyle()</codeph> 方法或 <codeph>lineStyle()</codeph> 方法。 
     
     <p>可以在绘制路径的中间调用 <codeph>lineStyle()</codeph> 方法以为路径中的不同线段指定不同的样式。</p> 
	 
	 <p><b>注意：</b>调用 <codeph>clear()</codeph> 方法会将线条样式设置回 <codeph>undefined</codeph>。</p>
     
	 </apiDesc><example>有关如何使用 <codeph>getStyle()</codeph> 方法的说明，请参阅 <xref href="Graphics.html#lineTo()">lineTo()</xref> 或 <xref href="Graphics.html#moveTo()">moveTo()</xref> 方法的示例。 
     
     </example></apiOperationDetail><related-links><link href="flash.display.xml#Graphics/lineBitmapStyle"><linktext>lineBitmapStyle</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle"><linktext>lineGradientStyle</linktext></link><link href="flash.display.xml#LineScaleMode"><linktext>LineScaleMode</linktext></link><link href="flash.display.xml#CapsStyle"><linktext>CapsStyle</linktext></link><link href="flash.display.xml#JointStyle"><linktext>JointStyle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Graphics:lineTo"><apiName>lineTo</apiName><shortdesc>
	 使用当前线条样式绘制一条从当前绘画位置开始到 (x, y) 结束的直线；当前绘画位置随后会设置为 (x, y)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill.
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
     
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>绘制一条从当前绘画位置开始到 (x, y) 结束的直线。
     
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 使用当前线条样式绘制一条从当前绘画位置开始到 (<codeph>x</codeph>, <codeph>y</codeph>) 结束的直线；当前绘画位置随后会设置为 (<codeph>x</codeph>, <codeph>y</codeph>)。如果正在其中绘制的显示对象包含用 Flash 绘画工具创建的内容，则调用 <codeph>lineTo()</codeph> 方法将在该内容下面进行绘制。如果在对 <codeph>moveTo()</codeph> 方法进行任何调用之前调用了 <codeph>lineTo()</codeph>，则当前绘画的默认位置为 (<i>0, 0</i>)。如果缺少任何一个参数，则此方法将失败，并且当前绘画位置不改变。
	 
	 </apiDesc><example conref="examples\Graphics_lineToExample.as"> 下面的示例使用 <codeph>lineTo()</codeph> 方法绘制一个梯形，从像素 (100, 100) 开始。 
 <p>线条粗细设置为 10 个像素，颜色为金色且不透明，线条终点设置为 none（因为联接了所有线条），两条线之间的联接点设置为 <codeph>MITER</codeph> 并将尖角限制设置为 10 以绘制尖锐的边角。</p>     
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:Graphics:moveTo"><apiName>moveTo</apiName><shortdesc>
     将当前绘画位置移动到 (x, y)。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>The following example draws a triangle with a 5-pixel, solid magenta line and a 
	 partially transparent blue fill:
	 
	 <listing>
	 this.createEmptyMovieClip("triangle_mc", 1);
	 triangle_mc.beginFill(0x0000FF, 30);
	 triangle_mc.lineStyle(5, 0xFF00FF, 100);
	 triangle_mc.moveTo(200, 200);
	 triangle_mc.lineTo(300, 300);
	 triangle_mc.lineTo(100, 300);
	 triangle_mc.lineTo(200, 200);
	 triangle_mc.endFill();
	 </listing>
	 
	 
     </maelexample></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的水平位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个表示相对于父显示对象注册点的垂直位置的数字（以像素为单位）。
     
     </apiDesc></apiParam><apiTipTexts><apiTipText>将当前绘画位置移动到 (x, y)。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     将当前绘画位置移动到 (<codeph>x</codeph>, <codeph>y</codeph>)。如果缺少任何一个参数，则此方法将失败，并且当前绘画位置不改变。
     
	 </apiDesc><example conref="examples\Graphics_moveToExample.as"> 下面的示例使用 <codeph>moveTo()</codeph> 和 <codeph>lineTo()</codeph> 方法绘制一条 3 个像素粗的虚线。
 
 <p>通过使用 <codeph>lineStyle()</codeph> 方法，将线条粗细设置为 3 个像素。还将其设置为不进行缩放。颜色设置为红色，并且不透明度为 25%。<codeph>CapsStyle</codeph> 属性设置为 square（默认值为 round）。</p>
 
 <p>由于 <codeph>Graphics_moveToExample</codeph> 是 <codeph>Sprite</codeph> 类实例，因此，它具有所有 Graphics 类方法的访问权限。可以使用 Graphics 类方法直接在 <codeph>Graphic_moveToExample</codeph> Sprite 对象上进行绘制。但是，如果未将矢量绘画对象放在 <codeph>Shape</codeph> 中，则会限制它们的管理、移动或更改方式。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</codeblock></example></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="flash.display:NativeWindowType"><apiName>NativeWindowType</apiName><shortdesc>
	 NativeWindowType 类定义一些常量，它们用作创建本机窗口的 NativeWindowInitOptions 对象的 type 属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 NativeWindowType 类定义一些常量，它们用作创建本机窗口的 NativeWindowInitOptions 对象的 <codeph>type</codeph> 属性。
	 
	 <p><b>注意：</b>type 值是在创建窗口时指定的，无法更改。</p>
	 	  
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowType:LIGHTWEIGHT"><apiName>LIGHTWEIGHT</apiName><shortdesc>
		 最小窗口。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>lightweight</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 最小窗口。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:NORMAL"><apiName>NORMAL</apiName><shortdesc>
		 典型窗口。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 典型窗口。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowType:UTILITY"><apiName>UTILITY</apiName><shortdesc>
		 实用程序窗口。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>utility</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 实用程序窗口。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowDisplayState"><apiName>NativeWindowDisplayState</apiName><shortdesc>
     NativeWindowDisplayState 类定义表示窗口显示状态名称的常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
     NativeWindowDisplayState 类定义表示窗口显示状态名称的常量。
     
     <p><b>注意：</b>全屏模式是使用 Stage 对象的 <codeph>displayState</codeph> 属性，而不是窗口的 <codeph>displaySate</codeph> 设置的。</p>
     
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link></related-links><apiValue id="flash.display:NativeWindowDisplayState:MAXIMIZED"><apiName>MAXIMIZED</apiName><shortdesc>
         最大化显示状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>maximized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         最大化显示状态。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:MINIMIZED"><apiName>MINIMIZED</apiName><shortdesc>
         最小化显示状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>minimized</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         最小化显示状态。
         
         </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
         正常显示状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
         正常显示状态。
         
         </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Screen"><apiName>Screen</apiName><shortdesc>
	 Screen 类提供此应用程序的可用显示屏幕的相关信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Screen 类提供此应用程序的可用显示屏幕的相关信息。
	 
	 <p>屏幕是位于可能更大的“虚拟桌面”内的独立桌面区域。虚拟桌面的原点是操作系统指定的主屏幕的左上角。因此，个别显示屏幕范围的坐标可能是负数。虚拟桌面也可能有一些不在任何显示屏幕内的区域。</p>
	 
	 <p>Screen 类包括用于访问可用屏幕对象的静态类成员和用于访问个别屏幕属性的实例成员。屏幕信息不应进行缓存，因为这些信息可能会由用户随时更改。</p>
	  
	 <p>请注意，屏幕和连接到计算机的物理监视器之间不一定有一对一的对应关系。例如，两台监视器可以显示同一个屏幕。</p>
	 
	 <p>无法直接实例化 Screen 类。调用 <codeph>new Screen()</codeph> 构造函数将引发 <codeph>ArgumentError</codeph> 异常。</p>
	 
	 </apiDesc><example conref="examples\ScreenExample.as"> 下面的示例通过定义 DockingWindow 类来创建一个停靠在屏幕某一侧的窗口。执行下列步骤可完成该任务：
 
 <ol>
     <li>响应键盘事件以确定停靠在屏幕的哪一侧。</li>
 
    <li>访问静态 Screen 类方法 <codeph>getScreensForRectangle()</codeph> 可以获取当前显示该窗口的屏幕的 Screen 对象。</li>
 
    <li>根据屏幕尺寸重新设置窗口范围。</li>
 
    <li>根据新窗口尺寸重新绘制窗口内容。</li>
 
 </ol>
 
 <p>请注意，此类旨在用作具有 <codeph>SystemChrome="none"</codeph> 和 <codeph>transparent="true"</codeph> 设置的 AIR 应用程序的根类。要在具有系统镶边的窗口中使用此类，在计算窗口位置和大小时，必须将镶边的粗细和窗口的最小宽度考虑在内。</p>
<codeblock>

package
{
    import flash.display.Screen;
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.KeyboardEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;

    public class DockingWindow extends Sprite
    {
        private const dockedWidth:uint = 80;
        private const dockedHeight:uint = 80;
        
        public function DockingWindow():void{
            stage.align = StageAlign.TOP_LEFT;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.addEventListener(KeyboardEvent.KEY_DOWN,onKey);
            dockLeft();
        }
        
        private function onKey(event:KeyboardEvent):void{
            switch(event.keyCode){
                case Keyboard.LEFT :
                    dockLeft();
                    break;
                case Keyboard.RIGHT :
                    dockRight();
                    break;
                case Keyboard.UP :
                    dockTop();
                    break;
                case Keyboard.DOWN :
                    dockBottom();
                    break;
                case Keyboard.SPACE :
                    stage.nativeWindow.close();
            }    
        }
        
        public function dockLeft():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.height = screen.visibleBounds.height;
            stage.stageWidth = dockedWidth;
            drawContent();
        }
        
        public function dockRight():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.width - dockedWidth;            
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.stageWidth = dockedWidth;
            stage.nativeWindow.height = screen.visibleBounds.height;
            drawContent();
        }
        
        public function dockTop():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.top;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;
            drawContent();
        }
        
        public function dockBottom():void{
            var screen:Screen = getCurrentScreen();
            stage.nativeWindow.x = screen.visibleBounds.left;
            stage.nativeWindow.y = screen.visibleBounds.height - dockedHeight;
            stage.nativeWindow.width = screen.visibleBounds.width;
            stage.stageHeight = dockedHeight;    
            drawContent();        
        }
        
        private function getCurrentScreen():Screen{
            return Screen.getScreensForRectangle(stage.nativeWindow.bounds)[0];
        }
        
        private function drawContent():void{
            const size:int = 60;
            const pad:int = 10;
            var numHSquares:int = Math.floor(stage.stageWidth/(size + pad));
            var numVSquares:int = Math.floor(stage.stageHeight/(size + pad));
            with (graphics){
                clear();
                lineStyle(1);
                beginFill(0x3462d5,.7);
                for(var i:int = 0; i &lt; numHSquares; i++){
                    for(var j:int = 0; j &lt; numVSquares; j++){                
                            drawRect((i * (size + pad)) + pad, (j * (size + pad)) + pad, size, size);
                    }
                }
                endFill();
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><apiOperation id="flash.display:Screen:getScreensForRectangle"><apiName>getScreensForRectangle</apiName><shortdesc>
		 返回一组与提供的矩形相交的屏幕（可能为空）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>包含屏幕的 Screen 对象的数组，这些屏幕包含由 <codeph>rect</codeph> 参数定义的区域的任何部分。
		 
		 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>一个具有相对于虚拟桌面原点（主屏幕的左上角）的坐标的矩形。
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 返回一组与提供的矩形相交的屏幕（可能为空）。
		  
		 </apiDesc><example conref="examples\Screen.getScreensForRectangle.1.as"> 下面的示例显示如何获取至少包含给定矩形一部分的屏幕的数组：
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var rect:Rectangle = new Rectangle(-200, 100, 1000, 600);
var intersectedScreens:Array = Screen.getScreensForRectangle(rect);
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:Screen:bounds:get"><apiName>bounds</apiName><shortdesc>
		 此屏幕的范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 此屏幕的范围。
		 
		 <p>屏幕位置相对于虚拟桌面。</p>
		 
		 </apiDesc><example conref="examples\Screen.bounds.1.as"> 下面的示例显示如何获取屏幕（在本例中为主显示屏幕）的范围：
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.bounds;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:colorDepth:get"><apiName>colorDepth</apiName><shortdesc>
		 此屏幕的颜色深度（以位数为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 此屏幕的颜色深度（以位数为单位）。
		 
		 </apiDesc><example conref="examples\Screen.colorDepth.1.as"> 下面的示例显示如何获取屏幕（在本例中为主显示屏幕）的颜色深度：
<codeblock>

var mainScreen:Screen = Screen.mainScreen;
var colors:uint = mainScreen.colorDepth;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:mainScreen:get"><apiName>mainScreen</apiName><shortdesc>
		 主显示器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Screen</apiValueClassifier></apiValueDef><apiDesc>
		 主显示器。
		 
		 </apiDesc><example conref="examples\Screen.mainScreen.1.as"> 下面的示例显示如何获取表示此计算机的“主”屏幕的 Screen 对象。
<codeblock>

var primaryScreen:Screen = Screen.mainScreen;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:screens:get"><apiName>screens</apiName><shortdesc>
		 当前可用的屏幕的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3."/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		 当前可用的屏幕的数组。 
		 
		 <p>修改返回的数组对可用的屏幕没有任何效果。</p>
		 
		 </apiDesc><example conref="examples\Screen.screens.1.as"> 下面的示例显示如何获取包含可用屏幕的数组：
<codeblock>

var screenArray:Array = Screen.screens;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Screen:visibleBounds:get"><apiName>visibleBounds</apiName><shortdesc>
		 此屏幕上可以看见窗口的区域范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
		 此屏幕上可以看见窗口的区域范围。
		 
		 <p>屏幕的 <codeph>visibleBounds</codeph> 在 Windows 中不包括任务栏（和其它停靠的桌面栏），而在 Mac OS X 中则不包括菜单栏和停靠栏（具体取决于系统设置）。在某些 Linux 配置中无法确定可见边界。在这些情况下，<codeph>visibleBounds</codeph> 属性返回与 <codeph>screenBounds</codeph> 属性相同的值。</p>
		 
		 </apiDesc><example conref="examples\Screen.usableBounds.1.as"> 下面的示例显示如何获取屏幕（在本例中为主显示屏幕）的可用范围：
<codeblock>
import flash.display.Screen;
import flash.geom.Rectangle;

var mainScreen:Screen = Screen.mainScreen;
var screenBounds:Rectangle = mainScreen.visibleBounds;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Bitmap"><apiName>Bitmap</apiName><shortdesc>
 Bitmap 类表示用于表示位图图像的显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>表示从图像派生的显示对象。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 Bitmap 类表示用于表示位图图像的显示对象。这些图像可以是使用 flash.display.Loader 类加载的图像，也可以是使用 <codeph>Bitmap()</codeph> 构造函数创建的图像。 
 
 <p>利用 <codeph>Bitmap()</codeph> 构造函数，可以创建包含对 BitmapData 对象的引用的 Bitmap 对象。创建了 Bitmap 对象后，使用父 DisplayObjectContainer 实例的 <codeph>addChild()</codeph> 或 <codeph>addChildAt()</codeph> 方法将位图放在显示列表中。</p>
 
 <p>一个 Bitmap 对象可在若干 Bitmap 对象之中共享其 BitmapData 引用，与转换属性或旋转属性无关。由于能够创建引用相同 BitmapData 对象的多个 Bitmap 对象，因此，多个显示对象可以使用相同的复杂 BitmapData 对象，而不会因为每个显示对象实例使用一个 BitmapData 对象而产生内存开销。</p>
 
 <p>Bitmap 对象可通过以下两种方式之一将 BitmapData 对象绘制到屏幕上：使用矢量渲染器作为填充位图形状，或使用更快的像素复制例程。像素复制例程的速度比矢量渲染器要快很多，但 Bitmap 对象必须满足某些条件才能使用该例程：</p>
 
 <ul>
 
 <li> 不能将拉伸、旋转或倾斜效果应用于 Bitmap 对象。</li>
 <li> 不能将颜色转换应用于 Bitmap 对象。 </li>
 <li> 不能将混合模式应用于 Bitmap 对象。 </li>
 <li> 不能通过蒙版或 <codeph>setMask()</codeph> 方法进行剪裁。 </li>
 <li> 图像本身不能是遮罩。 </li>
 <li> 目标坐标必须位于一个整像素边界上。 </li>
 
 </ul>
 
 <p>如果从中加载 Bitmap 对象的域不同于用于加载图像的 Loader 对象的域，并且没有用于允许访问 Loader 对象的域的 URL 策略文件，则该域中的脚本无法访问 Bitmap 对象或其属性及方法。有关详细信息，请参阅以下部分：</p>
 
 <ul>
 
 <li class="flexonly"><xref href="http://www.adobe.com/go/flex3_progAS3_security" scope="external">“安全性”一章</xref>（位于《ActionScript 3.0 编程》<i/>一书中）和有关 LiveDocs 的最新评论</li>
 <li class="flashonly">《ActionScript 3.0 编程》一书中的<xref href="http://www.adobe.com/go/flashcs4_prog_as3_security_en" scope="external">“安全性”一章</xref><i/>和 LiveDocs 上的最新评论</li>
 
 <li>Flash Player 开发人员中心主题：<xref href="http://www.adobe.com/go/devnet_security_en" scope="external">安全性</xref></li>
 </ul>
 
 
 <p><b>注意：</b>Bitmap 类不是 InteractiveObject 类的子类，因此它无法分派鼠标事件。但是，可以使用包含 Bitmap 对象的显示对象容器的 <codeph>addEventListener()</codeph> 方法。</p>
 
 </apiDesc><example conref="examples\BitmapExample.as"> 下例将使用 BitmapExample 类将“Image.gif”图像加载到位于默认位置（<i>x = 0, y = 0</i>）的 DisplayObject 中。然后，将 Image.gif 的副本放在原图像的右边，它使用 <codeph>threshold()</codeph> 方法。此任务是使用以下步骤完成的：
 <ol>
  <li>创建一个 <codeph>url</codeph> 属性，它是图像文件的位置和名称</li>
  <li>类构造函数调用 <codeph>configureAssets()</codeph> 方法，而后者又调用 <codeph>completeHandler()</codeph> 方法。</li>
  <li><codeph>configureAssets()</codeph> 创建 Loader 对象，该对象随后实例化一个事件侦听器，而该事件侦听器在 <codeph>completeHandler()</codeph> 完成图像操作时分派。</li>
  <li>下一步，<codeph>buildChild()</codeph> 方法创建一个 URLRequest 对象的新实例 <codeph>request</codeph>，该实例带有传递的 <codeph>url</codeph>，这样，就可以知道文件的名称和位置。</li>
  <li><codeph>request</codeph> 对象被传递给 <codeph>loader.load()</codeph> 方法，该方法通过显示对象将图像加载到内存中。</li>
  <li>图像随后将被放在显示列表中，后者将图像立即显示在屏幕的坐标 <i>x = 0, y = 0</i> 处。</li>
  <li>然后，<codeph>completeHandler()</codeph> 方法将执行下列任务：
  <ol outputclass="A">
      <li>创建另一个 Loader 对象，以及使用 Loader 对象初始化的 Bitmap 对象。</li>
      <li>创建第二个 Bitmap 对象 <codeph>duplicate</codeph>，该对象再调用 <codeph>duplicateImage()</codeph> 方法，该方法创建原始图像的副本。 </li>
      <li>创建一个 BitmapData 对象，该对象将被分配给 <codeph>duplicate</codeph> 对象的 BitmapData 对象。</li>
      <li>创建一个与原始图像具有相同的坐标、宽度和高度的新的 Rectangle 对象。</li>
      <li>创建一个新的 Point 对象，其默认为 <i>x = 0, y = 0</i>。</li>
      <li>创建以下变量：
      <ul>
          <li><codeph>operation</codeph>：在阈值大于等于原始值时应用新颜色。</li>
          <li><codeph>threshold</codeph>：依据其对每个像素进行比较的值设置为浅灰色（Alpha 值为 0xCC）。 </li>
          <li><codeph>color</codeph>：通过阈值测试的像素将被设置的颜色，在本例中为纯黄色。</li>
          <li><codeph>mask</codeph>：设置为与颜色正好相反的颜色（透明的蓝色）。</li>
          <li><codeph>copySource</codeph>：设置为 false，指示在阈值未通过测试的情况下不复制像素值。该值没有意义，因为图像是重复的，并且只更改通过了阈值测试的像素。</li>
      </ul></li>
      <li>使用前面的变量调用 <codeph>threshold()</codeph> 方法。得到的阈值计算式如下所示：<codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>。 </li>
  </ol></li>
 </ol>
 <p> <b>注意：</b>
 <ul>
  <li>您需要编译 SWF 文件，将“本地回放安全性”设置为“只访问本地文件”。
 </li>
  <li>此示例要求将名为 Image.gif 的文件与您的 SWF 文件放在同一目录中。
 </li>
  <li>建议使用宽度最大为 80 像素的图像。 </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link></related-links><apiConstructor id="flash.display:Bitmap:Bitmap"><apiName>Bitmap</apiName><shortdesc>
     初始化 Bitmap 对象以引用指定的 BitmapData 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>被引用的 BitmapData 对象。 
     
     </apiDesc></apiParam><apiParam><apiItemName>pixelSnapping</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>auto</apiData><apiDesc>Bitmap 对象是否贴紧至最近的像素。
     
     </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>在缩放时是否对位图进行平滑处理。例如，下例显示使用系数 3 缩放的同一位图，<codeph>smoothing</codeph> 设置为 <codeph>false</codeph>（左侧）和 <codeph>true</codeph>（右侧）：
     
     <p>
      <adobetable>
      
      
      
      <tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="未经过平滑处理的位图。" href="../../images/bitmap_smoothing_off.jpg"/></entry>
      <entry align="center"><adobeimage alt="经过平滑处理的位图。" href="../../images/bitmap_smoothing_on.jpg"/></entry>
      </row></tbody></tgroup></adobetable>
     </p>
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     初始化 Bitmap 对象以引用指定的 BitmapData 对象。
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Bitmap:bitmapData:get"><apiName>bitmapData</apiName><shortdesc>
    被引用的 BitmapData 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:BitmapData</apiValueClassifier></apiValueDef><apiDesc>
    被引用的 BitmapData 对象。
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:pixelSnapping:get"><apiName>pixelSnapping</apiName><shortdesc>
    控制 Bitmap 对象是否贴紧至最近的像素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
    控制 Bitmap 对象是否贴紧至最近的像素。PixelSnapping 类包括以下可能值：
    
    <ul>
    
      <li><codeph>PixelSnapping.NEVER</codeph> -- 不进行像素贴紧。</li>
    
      <li><codeph>PixelSnapping.ALWAYS</codeph> -- 图像始终与最近的像素贴紧，与变形无关。</li>
    
      <li><codeph>PixelSnapping.AUTO</codeph> -- 如果绘制图像时未应用旋转或倾斜效果，并且图像是以 99.9% 到 100.1% 的缩放系数绘制的，则图像将与最近的像素贴紧。如果这些条件得到满足，则以 100% 的缩放比例绘制位图图像，与最近的像素贴紧。在内部，此值允许用矢量渲染器以尽可能快的速度绘制图像。</li>
    
    </ul>
    </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Bitmap:smoothing:get"><apiName>smoothing</apiName><shortdesc>
    控制在缩放时是否对位图进行平滑处理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
    控制在缩放时是否对位图进行平滑处理。如果为 <codeph>true</codeph>，则会在缩放时对位图进行平滑处理。如果为 <codeph>false</codeph>，则不会在缩放时对位图进行平滑处理。
    </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Scene"><apiName>Scene</apiName><shortdesc>
	Scene 类包括用于标识场景中帧的名称、标签和数量的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	Scene 类包括用于标识场景中帧的名称、标签和数量的属性。MovieClip 类包括 <codeph>currentScene</codeph> 属性，它是可以标识以下场景的 Scene 对象：播放头位于 MovieClip 实例的时间轴中。MovieClip 类的 <codeph>scenes</codeph> 属性是 Scene 对象的数组。而且，MovieClip 类的 <codeph>gotoAndPlay()</codeph> 和 <codeph>gotoAndStop()</codeph> 方法使用 Scene 对象作为参数。
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#MovieClip/currentScene"><linktext>MovieClip.currentScene</linktext></link><link href="flash.display.xml#MovieClip/scenes"><linktext>MovieClip.scenes</linktext></link><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>MovieClip.gotoAndPlay()</linktext></link><link href="flash.display.xml#MovieClip/gotoAndStop()"><linktext>MovieClip.gotoAndStop()</linktext></link></related-links><apiValue id="flash.display:Scene:labels:get"><apiName>labels</apiName><shortdesc>
		一个由场景的 FrameLabel 对象组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		一个由场景的 FrameLabel 对象组成的数组。每个 FrameLabel 对象都包含一个 <codeph>frame</codeph> 属性，该属性指定与标签对应的帧编号以及 <codeph>name</codeph> 属性。
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:Scene:name:get"><apiName>name</apiName><shortdesc>
		场景的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		场景的名称。
        </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Scene:numFrames:get"><apiName>numFrames</apiName><shortdesc>
		场景中的帧数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		场景中的帧数。
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageDisplayState"><apiName>StageDisplayState</apiName><shortdesc>
StageDisplayState 类为 Stage.displayState 属性提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageDisplayState 类为 <codeph>Stage.displayState</codeph> 属性提供值。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>flash.display.Stage.displayState</linktext></link></related-links><apiValue id="flash.display:StageDisplayState:FULL_SCREEN"><apiName>FULL_SCREEN</apiName><shortdesc>
指定舞台处于全屏模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreen</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台处于全屏模式。在此模式下禁用键盘交互性操作。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:FULL_SCREEN_INTERACTIVE"><apiName>FULL_SCREEN_INTERACTIVE</apiName><shortdesc>
指定舞台处于启用键盘交互性操作的全屏模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>fullScreenInteractive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台处于启用键盘交互性操作的全屏模式。<ph platform="actionscript">只有 AIR 应用程序支持此功能。</ph>

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageDisplayState:NORMAL"><apiName>NORMAL</apiName><shortdesc>
指定舞台处于标准模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台处于标准模式。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderData"><apiName>ShaderData</apiName><shortdesc>
	 ShaderData 对象包含以下属性：表示着色器内核的任何参数和输入的属性，以及包含为着色器指定的任何元数据的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderData 对象包含以下属性：表示着色器内核的任何参数和输入的属性，以及包含为着色器指定的任何元数据的属性。
	 
	 <p>创建 ShaderData 对象时会将这些属性添加到该对象中。这些属性的名称与着色器源代码中指定的名称相匹配。每个属性的数据类型因属性所表示的着色器方面而异。表示着色器参数的属性是 ShaderParameter 实例，表示输入图像的属性是 ShaderInput 实例，而表示着色器元数据的属性是与其数据类型相对应的 ActionScript 类的实例（例如，文本元数据的 String 实例和 uint 元数据的 uint）。</p>
	 
	 <p>例如，假设有以下着色器，其中定义有一个输入图像 (<codeph>src</codeph>)、两个参数（<codeph>size</codeph> 和 <codeph>radius</codeph>）以及三个元数据值（<codeph>nameSpace</codeph>、<codeph>version</codeph> 和 <codeph>description</codeph>）：</p>
	 
	 <codeblock>
	 &lt;languageVersion : 1.0;>
	 
	 kernel DoNothing
	 &lt;
	     namespace: "Adobe::Example";
	     vendor: "Adobe examples";
	     version: 1;
	     description: "A shader that does nothing, but does it well.";
	 >
	 {
	     input image4 src;
	 
	     output pixel4 dst;
	     
	     parameter float2 size
	     &lt;
	         description: "The size of the image to which the kernel is applied";
	         minValue: float2(0.0, 0.0);
	         maxValue: float2(100.0, 100.0);
	         defaultValue: float2(50.0, 50.0);
	     >;
	     
	     parameter float radius
	     &lt;
	         description: "The radius of the effect";
	         minValue: 0.0;
	         maxValue: 50.0;
	         defaultValue: 25.0;
	     >;
	 
	     void evaluatePixel()
	     {
	         float2 one = (radius / radius) ∗ (size / size);
	         dst = sampleNearest(src, outCoord());
	     }
	 }
	 </codeblock>
	 
	 <p>如果通过为此着色器加载字节代码来创建 Shader 实例，则其 <codeph>data</codeph> 属性中的 ShaderData 实例包含以下属性：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>属性</entry><entry>数据类型</entry><entry>值</entry></row></thead><tbody><row>
	   <entry>name</entry>
	   <entry>字符串</entry>
	   <entry>"DoNothing"</entry>
	 </row><row>
	   <entry>nameSpace</entry>
	   <entry>字符串</entry>
	   <entry>"Adobe::Example"</entry>
	 </row><row>
	   <entry>version</entry>
	   <entry>字符串</entry>
	   <entry>"1"</entry>
	 </row><row>
	   <entry>description</entry>
	   <entry>String</entry>
	   <entry>"A shader that does nothing, but does it well."</entry>
	 </row><row>
	   <entry>src</entry>
	   <entry>ShaderInput</entry>
	   <entry><i>[一个 ShaderInput 实例]</i></entry>
	 </row><row>
	   <entry>size</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[一个 ShaderParameter 实例，包含参数元数据的属性]</i></entry>
	 </row><row>
	   <entry>radius</entry>
	   <entry>ShaderParameter</entry>
	   <entry><i>[一个 ShaderParameter 实例，包含参数元数据的属性]</i></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>请注意，将着色器编译为字节代码时，会删除着色器源代码中已定义但未在着色器的 <codeph>evaluatePixel()</codeph> 函数中使用的任何输入图像或参数。这种情况下，不会添加对应的 ShaderInput 或 ShaderParameter 实例作为 ShaderData 实例的属性。</p> 
	 
	 <p>通常，开发人员代码不创建 ShaderData 实例。包含着色器数据、参数和输入的 ShaderData 实例可用作 Shader 实例的 <codeph>data</codeph> 属性。</p>
	 
	 </apiDesc><example conref="examples\ShaderDataExample.1.as"> 下面的示例加载着色器并枚举着色器的 <codeph>data</codeph> 属性中的 ShaderData 实例，以显示着色器的输入、参数和元数据属性。
 
 <p>请注意，此示例假设应用程序输出目录所在的同一目录中有一个名为“donothing.pbj”的着色器字节码文件。</p>
<codeblock>

//
// Source code for the shader:
//
&lt;languageVersion : 1.0;>

kernel DoNothing
&lt;
    namespace: "Adobe::Example";
    vendor: "Adobe examples";
    version: 1;
    description: "A shader that does nothing, but does it well.";
>
{
    input image4 src;
    
    output pixel4 dst;
    
    parameter float2 size
    &lt;
        description: "The size of the image to which the shader is applied";
        minValue: float2(0.0, 0.0);
        maxValue: float2(100.0, 100.0);
        defaultValue: float2(50.0, 50.0);
    >;
    
    parameter float radius
    &lt;
        description: "The radius of the effect";
        minValue: float(0.0);
        maxValue: float(50.0);
        defaultValue: float(25.0);
    >;

    void evaluatePixel()
    {
        float2 one = (radius / radius) * (size / size);
        dst = sampleNearest(src, outCoord());
    }
}

//
// ActionScript source code:
//
package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class ShaderDataExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function ShaderDataExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            for (var p:String in shader.data) {
                trace(p, ":", shader.data[p]);
                for (var d:String in shader.data[p]) {
                    trace("\t", d, ":", shader.data[p][d]);
                }
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links><apiConstructor id="flash.display:ShaderData:ShaderData"><apiName>ShaderData</apiName><shortdesc>
		 创建 ShaderData 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>byteCode</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>着色器的字节代码。
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 创建 ShaderData 实例。通常，开发人员代码不直接调用 ShaderData 构造函数。使用 Shader 实例的 <codeph>data</codeph> 属性来访问包含该实例数据、参数和输入的 ShaderData 实例。
		 
		 </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links></apiConstructor></apiClassifier><apiClassifier id="flash.display:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
	 ShaderJob 实例用于在独立模式中执行着色器操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderJob 实例用于在独立模式中执行着色器操作。着色器操作执行并返回其结果数据。由开发人员确定如何使用结果。
	 
	 <p>在独立模式中使用着色器有两个主要原因：</p>
	 
	 <ul>
	   <li>处理非图像数据：使用 ShaderJob 实例可以控制输入值和着色器结果的使用方式。着色器可以作为二进制数据或数字数据（而非图像数据）返回结果。</li>
	   <li>后台处理：某些着色器很复杂，并且需要执行很长时间。在应用程序的主要执行操作中执行复杂着色器可能会减慢其它应用程序部件（比如用户交互或更新屏幕操作）的运行速度。使用 ShaderJob 实例，您可以在后台执行着色器。以此方法执行着色器时，着色器操作将独立于应用程序的主执行过程运行。</li>
	 </ul>
	 
	 <p><codeph>shader</codeph> 属性（或构造函数参数）指定 Shader 实例（表示用于操作的着色器）。您使用关联的 ShaderParameter 或 ShaderInput 实例提供着色器所需的任何参数或输入。</p>
	 
	 <p>在执行 ShaderJob 操作之前，您提供一个向其写入结果的对象，方法是将其设置为 <codeph>target</codeph> 属性的值。当着色器操作完成时，结果将写入 <codeph>target</codeph> 对象。</p>
	 
	 <p>要开始后台着色器操作，请调用 <codeph>start()</codeph> 方法。当该操作完成时，结果将写入 <codeph>target</codeph> 对象。此时 ShaderJob 实例将分派 <codeph>complete</codeph> 事件，通知侦听器结果已可用。</p>
	 
	 <p>要同步执行着色器操作（即不在后台运行），请调用 <codeph>start()</codeph> 方法并作为参数传递 <codeph>true</codeph>。着色器在主要执行线程中运行，并且您的代码在操作完成之前将暂停。完成时，结果将写入 <codeph>target</codeph> 对象。这时，应用程序将继续运行下一行代码。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Shader"><linktext>Shader</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>ShaderParameter</linktext></link><link href="flash.events.xml#ShaderEvent"><linktext>ShaderEvent</linktext></link></related-links><adobeApiEvent id="flash.display:ShaderJob_flash.events.ShaderEvent.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
	 当异步执行的 ShaderJob 使用着色器处理完数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ShaderEvent.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
	 当异步执行的 ShaderJob 使用着色器处理完数据时分派。当使用 <codeph>waitForCompletion</codeph> 参数的 <codeph>false</codeph> 值调用 <codeph>start()</codeph> 方法时，将异步执行 ShaderJob 实例。
	 
	 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:ShaderJob:ShaderJob"><apiName>ShaderJob</apiName><shortdesc>
		 
		 </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>要用于操作的着色器。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiData>null</apiData><apiDesc>在其中写入着色器操作结果的对象。此参数必须为 BitmapData、ByteArray 或 Vector.&lt;Number> 实例。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc><codeph>target</codeph> 中结果数据的宽度（如果为 ByteArray 或 Vector.&lt;Number> 实例）。如有必要，会增大 ByteArray 或 Vector.&lt;Number> 实例的大小，并会覆盖现有数据。
		 
		 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc><codeph>target</codeph> 中结果数据的高度（如果为 ByteArray 或 Vector.&lt;Number> 实例）。如有必要，会增大 ByteArray 或 Vector.&lt;Number> 实例的大小，并会覆盖现有数据。
         
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:ShaderJob:cancel"><apiName>cancel</apiName><shortdesc>
		 取消当前运行的着色器操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 取消当前运行的着色器操作。放弃任何已计算出的结果数据。未分派 <codeph>complete</codeph> 事件。
		 
		 <p>调用 <codeph>cancel()</codeph> 多次不会产生额外效果。</p>
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:ShaderJob:start"><apiName>start</apiName><shortdesc>
		 根据 waitForCompletion 参数的值，以同步模式或异步模式启动着色器操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>当 <codeph>target</codeph> 属性为 <codeph>null</codeph>，或者不是 BitmapData、ByteArray 或 Vector 时。&lt;Number> 实例时。
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当着色器指定了未提供的图像输入时。
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>当使用 ByteArray 或 Vector.&lt;Number> 实例作为输入，并且没有为 ShaderInput 指定 <codeph>width</codeph> 和 <codeph>height</codeph> 属性或指定的值与输入对象中的数据量不匹配时。有关详细信息，请参阅 <codeph>ShaderInput.input</codeph> 属性。
		 
		 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>waitForCompletion</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定是在后台（默认值为 <codeph>false</codeph>）还是在主要程序执行 (<codeph>true</codeph>) 中执行着色器。
		 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 根据 <codeph>waitForCompletion</codeph> 参数的值，以同步模式或异步模式启动着色器操作。
		 
		 <p>在异步模式（当 <codeph>waitForCompletion</codeph> 为 <codeph>false</codeph> 时，即默认模式）中，ShaderJob 执行在后台运行。着色器操作不影响显示或其它操作的响应能力。在异步模式中，<codeph>start()</codeph> 调用将立即返回，并且该程序继续执行下一行代码。当异步着色器操作完成时，结果将可用并分派 <codeph>complete</codeph> 事件。</p>
		 
		 <p>一次只有一个后台 ShaderJob 操作执行。Shader 操作在执行之前将保留在队列中。如果在着色器操作正在执行的过程中调用 <codeph>start()</codeph> 方法，则会将附加操作添加到队列的末尾。以后，在轮到它时将会执行。</p>
		 
		 <p>要以同步模式执行着色器操作，请使用 <codeph>waitForCompletion</codeph> 参数（唯一参数）的 <codeph>true</codeph> 值调用 <codeph>start()</codeph>。您的代码将在调用 <codeph>start()</codeph> 时暂停，直到着色器操作完成。这时，结果将可用并将继续执行下一行代码。</p>
		 
		 <p>调用 <codeph>start()</codeph> 方法时，将在内部复制 <codeph>shader</codeph> 属性中的 Shader 实例。着色器操作将使用该内部副本，而不是对原始着色器的引用。对着色器进行的任何更改（比如更改参数值、输入或字节代码）不会应用于所复制的用于着色器处理的着色器。要将着色器更改结合到着色器处理中，请调用 <codeph>cancel()</codeph> 方法（如有必要），并再次调用 <codeph>start()</codeph> 方法以重新开始着色器处理。</p>
		 
		 <p>当着色器操作正在执行时，<codeph>target</codeph> 对象的值不会变化。操作完成（并以异步模式分派了 <codeph>complete</codeph> 事件）后，整个结果将一次性写入 <codeph>target</codeph> 对象。如果 <codeph>target</codeph> 对象是 BitmapData 实例，并且在操作完成之前调用了其 <codeph>dispose()</codeph> 方法，则仍然会以异步模式分派 <codeph>complete</codeph> 事件。但是，结果数据不会写入 BitmapData 对象，因为该对象处于已处理状态。</p>
         
		 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.display:ShaderJob:start_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ShaderEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>如果使用值为 <codeph>true</codeph> 的 <codeph>waitForCompletion</codeph> 参数调用 <codeph>start() </codeph>方法，则在操作完成时分派。
		 
		 </apiDesc></adobeApiEventDetail><shortdesc>如果使用值为 true 的 waitForCompletion 参数调用 start() 方法，则在操作完成时分派。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.display:ShaderJob:height:get"><apiName>height</apiName><shortdesc>
		 target 中结果数据的高度（如果为 ByteArray 或 Vector.&amp;lt;Number&amp;gt; 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 <codeph>target</codeph> 中结果数据的高度（如果为 ByteArray 或 Vector.&lt;Number> 实例）。如有必要，会增大 ByteArray 或 Vector.&lt;Number> 实例的大小，并会覆盖现有数据。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:progress:get"><apiName>progress</apiName><shortdesc>
		 正在运行的着色器的进度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
		 正在运行的着色器的进度。此属性是从 0 到 1 的一个值。0 为初始值（0% 完成）。1 指示着色器已完成其操作。
		 
		 <p>如果调用了 <codeph>cancel()</codeph> 方法，此属性将变为 <codeph>undefined</codeph>，并且，在着色器操作再次开始之前，将无法可靠地使用此属性的值。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:shader:get"><apiName>shader</apiName><shortdesc>
		 用于操作的着色器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
		 用于操作的着色器。必须使用 Shader 实例的 <codeph>data</codeph> 属性的 ShaderInput 或 ShaderParameter 属性提供着色器所需的任何输入或参数。必须使用与输入对应的 ShaderInput 来提供输入，即使它与 <codeph>target</codeph> 对象相同。
		 
		 <p>要处理包含线性数据数组（而不是图像数据）的 ByteArray，请在 ByteArray 中将对应 ShaderInput 实例的 <codeph>height</codeph> 设置为 1，并将 <codeph>width</codeph> 设置为 32 位浮点值数字。在这种情况下，必须将着色器中的输入定义为具有 <codeph>image1</codeph> 数据类型。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderJob:target:get"><apiName>target</apiName><shortdesc>
		 在其中写入着色器操作结果的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 在其中写入着色器操作结果的对象。此对象必须为 BitmapData、ByteArray 或 Vector.&lt;Number> 实例。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderJob:width:get"><apiName>width</apiName><shortdesc>
		 target 中结果数据的宽度（如果为 ByteArray 或 Vector.&amp;lt;Number&amp;gt; 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 <codeph>target</codeph> 中结果数据的宽度（如果为 ByteArray 或 Vector.&lt;Number> 实例）。如有必要，会增大 ByteArray 或 Vector.&lt;Number> 实例的大小，并会覆盖现有数据。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowSystemChrome"><apiName>NativeWindowSystemChrome</apiName><shortdesc>
	 NativeWindowSystemChrome 类定义一些常量，它们用作用于创建本机窗口的 NativeWindowInitOptions 对象的 systemChrome 属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 NativeWindowSystemChrome 类定义一些常量，它们用作用于创建本机窗口的 NativeWindowInitOptions 对象的 <codeph>systemChrome</codeph> 属性。  
	 
	 <p>系统镶边是指窗口特定于操作系统的元素，比如标题栏、最小化按钮、最大化按钮和关闭按钮。</p>
  	 
	 <p><b>注意：</b>所使用的系统镶边的类型是在创建窗口时指定的，无法更改。</p>
	 
     </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link></related-links><apiValue id="flash.display:NativeWindowSystemChrome:NONE"><apiName>NONE</apiName><shortdesc>
	 无系统镶边。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 无系统镶边。 
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowSystemChrome:STANDARD"><apiName>STANDARD</apiName><shortdesc>
	 主机操作系统的标准镶边。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>standard</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 主机操作系统的标准镶边。
	 
	 <p>使用此设置可模拟本机操作系统的外观。</p>
	 
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsStroke"><apiName>IGraphicsStroke</apiName><shortdesc>
	此接口用于定义可用作 flash.display.Graphics 方法和绘图类中的笔触参数的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	此接口用于定义可用作 flash.display.Graphics 方法和绘图类中的笔触参数的对象。使用此接口的实现器类来创建和管理笔触属性数据，并将相同的数据重新用于不同的实例。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
 使用 SimpleButton 类，您可以控制 SWF 文件中按钮元件的所有实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button object, built-in class
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>使用 SimpleButton 类，您可以控制 SWF 文件中按钮元件的所有实例。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:InteractiveObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 SimpleButton 类，您可以控制 SWF 文件中按钮元件的所有实例。在创作工具中创建了按钮的一个实例后，您可以使用 SimpleButton 类的方法和属性，通过 ActionScript 来操作按钮。
 
 <p product="flash">您可在属性检查器中指定按钮的实例名称。SimpleButton 实例名称显示在影片浏览器中和“动作”面板的“插入目标路径”对话框中。</p>
 
 <p>在 ActionScript 3.0 中，您使用 <codeph>new SimpleButton()</codeph> 构造函数来创建 SimpleButton 实例。</p>
 
 <p>SimpleButton 类继承自 InteractiveObject 类。</p>
 
 </apiDesc><example conref="examples\SimpleButtonExample.as"> 下例使用 SimpleButtonExample 类，该类又使用 CustomSimpleButton 类，后者又实例化四个 ButtonDisplayState 对象。最终会创建一个正方形的按钮，通过覆盖 SimpleButton 类的实例属性，其背景色会根据鼠标状态而发生变化。执行下列步骤可完成此操作：
 <ol>
  <li>在 <codeph>SimpleButtonExample()</codeph> 构造函数中，创建一个名为 <codeph>button</codeph> 的 SimpleButton 类型的新 CustomSimpleButton 对象，该对象调用 <codeph>CustomSimpleButton</codeph> 构造函数方法。<codeph>button</codeph> 对象将添加到显示列表中。按钮的颜色和大小在以下步骤中确定。</li>
 
  <li>在 CustomSimpleButton 类中，声明一些实例属性，以后将使用这些属性控制 <codeph>button</codeph> 处于不同状态时的大小和背景色（正常状态为黄色，鼠标滑过时为深黄色，鼠标按下时为浅蓝色）。在 <codeph>button</codeph> 的所有状态下，可使用 <codeph>size</codeph> 属性将正方形的大小设置为 80 像素。</li>
 
  <li>CustomSimpleButton 类的构造函数使用 ButtonDisplayState 类的四个实例设置 <codeph>downState</codeph>、<codeph>overState</codeph>、<codeph>upState</codeph>、<codeph>hitTestState</codeph> 和 <codeph>useHandCursor</codeph> 属性。</li>
 
  <li>在 ButtonDisplayState 类中，构造函数设置正方形的大小和背景色的值，并调用 <codeph>draw()</codeph> 方法。</li>
 
  <li><codeph>draw()</codeph> 方法使用构造函数中设置的大小和背景色根据按钮的状态重绘正方形。</li>
 </ol>
<codeblock>
package {
    import flash.display.Sprite;

    public class SimpleButtonExample extends Sprite {
        public function SimpleButtonExample() {
            var button:CustomSimpleButton = new CustomSimpleButton();
            addChild(button);
        }
    }
}

import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.SimpleButton;

class CustomSimpleButton extends SimpleButton {
    private var upColor:uint   = 0xFFCC00;
    private var overColor:uint = 0xCCFF00;
    private var downColor:uint = 0x00CCFF;
    private var size:uint      = 80;

    public function CustomSimpleButton() {
        downState      = new ButtonDisplayState(downColor, size);
        overState      = new ButtonDisplayState(overColor, size);
        upState        = new ButtonDisplayState(upColor, size);
        hitTestState   = new ButtonDisplayState(upColor, size * 2);
        hitTestState.x = -(size / 4);
        hitTestState.y = hitTestState.x;
        useHandCursor  = true;
    }
}

class ButtonDisplayState extends Shape {
    private var bgColor:uint;
    private var size:uint;

    public function ButtonDisplayState(bgColor:uint, size:uint) {
        this.bgColor = bgColor;
        this.size    = size;
        draw();
    }

    private function draw():void {
        graphics.beginFill(bgColor);
        graphics.drawRect(0, 0, size, size);
        graphics.endFill();
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#InteractiveObject"><linktext>InteractiveObject 类</linktext></link></related-links><apiConstructor id="flash.display:SimpleButton:SimpleButton"><apiName>SimpleButton</apiName><shortdesc>
	创建一个新的 SimpleButton 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>upState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton 弹起状态的初始值。
	</apiDesc></apiParam><apiParam><apiItemName>overState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton 经过状态的初始值。
	</apiDesc></apiParam><apiParam><apiItemName>downState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton 按下状态的初始值。
	</apiDesc></apiParam><apiParam><apiItemName>hitTestState</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>SimpleButton hitTest 状态的初始值。
	
	</apiDesc></apiParam><apiTipTexts><apiTipText>创建一个新的 SimpleButton 实例。
	</apiTipText></apiTipTexts></apiConstructorDef><apiDesc>
	创建一个新的 SimpleButton 实例。可以将表示各种按钮状态的任意或全部显示对象都设置为构造函数中的参数。  
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:SimpleButton:downState:get"><apiName>downState</apiName><shortdesc>
	 指定一个用作按钮“按下”状态（当用户单击 hitTestState 对象时，按钮所处的状态）的可视对象的显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>指定用于按钮“按下”状态的 DisplayObject 值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定一个用作按钮“按下”状态（当用户单击 <codeph>hitTestState</codeph> 对象时，按钮所处的状态）的可视对象的显示对象。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:enabled:get"><apiName>enabled</apiName><shortdesc>
	 布尔值，指定按钮是否处于启用状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>button, button.enabled, enabled
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>指定是启用 (true) 还是禁用 (false) 按钮。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 布尔值，指定按钮是否处于启用状态。按钮被禁用时（enabled 属性设置为 <codeph>false</codeph>），该按钮虽然可见，但不能被单击。默认值为 <codeph>true</codeph>。如果想要禁用部分导航按钮，则此属性非常有用；例如，您可能希望禁用当前显示的页面上的某个按钮，以便禁止单击该按钮并禁止重新加载该页面。
	 
	 <p><b>注意：</b>要防止按钮上的 mouseClicks 行为，请将 <codeph>enabled</codeph> 和 <codeph>mouseEnabled</codeph> 属性设置为 <codeph>false</codeph>。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:hitTestState:get"><apiName>hitTestState</apiName><shortdesc>
	 指定一个用作按钮的点击测试对象的显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier></apiValueDef><apiDesc>
	 指定一个用作按钮的点击测试对象的显示对象。对于基本按钮，将 <codeph>hitTestState</codeph> 属性设置为与 <codeph>overState</codeph> 属性相同的显示对象。如果没有设置 <codeph>hitTestState</codeph> 属性，则 SimpleButton 处于非活动状态 -- 它不对鼠标和键盘事件进行响应。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:overState:get"><apiName>overState</apiName><shortdesc>
	 指定一个用作按钮“经过”状态（当鼠标位于按钮上方时，按钮所处的状态）的可视对象的显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>指定用于按钮“经过”状态的 DisplayObject 值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定一个用作按钮经过状态（当鼠标位于按钮上方时，按钮所处的状态）的可视对象的显示对象。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/upState"><linktext>upState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:soundTransform:get"><apiName>soundTransform</apiName><shortdesc> 
	 分配给此按钮的 SoundTransform 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Should information from AS2 setTransform be here? e.g. percentage values indicating
	 how much of the left input to play in the left speaker or right speaker; it is generally
	 best to use 22-KHZ 6-bit mono sounds?
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.media:SoundTransform</apiValueClassifier></apiValueDef><apiDesc> 
	 分配给此按钮的 SoundTransform 对象。SoundTransform 对象包含用于设置音量、平移、左扬声器指定和右扬声器指定的属性。SoundTransform 对象适用于按钮的所有状态。SoundTransform 对象仅影响嵌入的声音。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.media.xml#SoundTransform"><linktext>flash.media.SoundTransform</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 指示属于 SimpleButton 或 MovieClip 对象的其它显示对象是否可以接收鼠标释放事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指示属于 SimpleButton 或 MovieClip 对象的其它显示对象是否可以接收鼠标释放事件。<codeph>trackAsMenu</codeph> 属性允许您创建菜单。可以对任何 SimpleButton 或 MovieClip 对象设置 <codeph>trackAsMenu</codeph> 属性。如果不存在 <codeph>trackAsMenu</codeph> 属性，则默认行为是 <codeph>false</codeph>。 
	 
	 <p>您可以随时更改 <codeph>trackAsMenu</codeph> 属性；修改后的按钮会立即具有新的行为。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SimpleButton:upState:get"><apiName>upState</apiName><shortdesc>
	 指定一个用作按钮“弹起”状态（当鼠标没有位于按钮上方时，按钮所处的状态）的可视对象的显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiTipTexts><apiTipText>指定用于按钮“弹起”状态的 DisplayObject 值。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定一个用作按钮弹起状态（当鼠标没有位于按钮上方时，按钮所处的状态）的可视对象的显示对象。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SimpleButton/downState"><linktext>downState</linktext></link><link href="flash.display.xml#SimpleButton/hitTestState"><linktext>hitTestState</linktext></link><link href="flash.display.xml#SimpleButton/overState"><linktext>overState</linktext></link></related-links></apiValue><apiValue id="flash.display:SimpleButton:useHandCursor:get"><apiName>useHandCursor</apiName><shortdesc>
     一个布尔值，当设置为 true 时，指示鼠标指针滑过按钮上方时是否显示手形光标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><maelexample>Create two buttons on the Stage with the instance names <code>myBtn1_btn</code> and <code>myBtn2_btn</code>. Enter the following ActionScript in Frame 1 of the Timeline:
	 <listing>
	 myBtn1_btn.useHandCursor = false;
	 myBtn1_btn.onRelease = buttonClick;
	 myBtn2_btn.onRelease = buttonClick;
	 function buttonClick() {
	   trace(this._name);
	 }
	 </listing>
	 <p>When the mouse is over and clicks <code>myBtn1_btn</code>, there is no pointing hand. However, you see the pointing hand when the button is over and clicks <code>myBtn2_btn</code>.</p>
	 
	 </maelexample></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiTipTexts><apiTipText>设置为 true 时显示手形光标。
	 
	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     一个布尔值，当设置为 <codeph>true</codeph> 时，指示鼠标指针滑过按钮上方时是否显示手形光标。如果此属性设置为 <codeph>false</codeph>，则将改用箭头指针。默认值为 <codeph>true</codeph>。
	 
	 <p>可以随时更改 <codeph>useHandCursor</codeph> 属性；修改后的按钮会立即使用新的光标行为。 </p>
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:TriangleCulling"><apiName>TriangleCulling</apiName><shortdesc>
 定义剔除算法的代码，这些算法确定在绘制三角形路径时不呈现哪些三角形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义剔除算法的代码，这些算法确定在绘制三角形路径时不呈现哪些三角形。
 
 <p>
 术语 <codeph>POSITIVE</codeph> 和 <codeph>NEGATIVE</codeph> 指三角形的法线在 z 轴两侧的符号。法线是一个 3D 矢量，与三角形的表面垂直。
 </p>
 
 <p>
 顶点 0、1 和 2 按顺时针顺序排列的三角形的法线值为正。也就是说，其法线指向正 z 轴方向，远离当前视图点。如果使用了 <codeph>TriangleCulling.POSITIVE</codeph> 算法，则不呈现法线为正的三角形。这里的另一个术语是背面剔除。
 </p>
 
 <p>
 顶点按逆时针顺序排列的三角形的法线值为负。也就是说，其法线指向负 z 轴方向，朝向当前视图点。如果使用了 <codeph>TriangleCulling.NEGATIVE</codeph> 算法，则不呈现法线为负的三角形。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawTrianglePath()"><linktext>flash.display.Graphics.drawTrianglePath()</linktext></link><link href="flash.display.xml#GraphicsTrianglePath"><linktext>flash.display.GraphicsTrianglePath</linktext></link><link href="http://www.gamedev.net/reference/articles/article1089.asp"><linktext>3D 矢量简介</linktext></link><link href="http://www.gamedev.net/reference/articles/article1088.asp"><linktext>3D 背面剔除</linktext></link></related-links><apiValue id="flash.display:TriangleCulling:NEGATIVE"><apiName>NEGATIVE</apiName><shortdesc>
     指定剔除朝向当前视图点的所有三角形。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>negative</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     指定剔除朝向当前视图点的所有三角形。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:NONE"><apiName>NONE</apiName><shortdesc>
     指定不进行剔除。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     指定不进行剔除。将呈现路径中的所有三角形。
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:TriangleCulling:POSITIVE"><apiName>POSITIVE</apiName><shortdesc>
     指定剔除背向当前视图点的所有三角形。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>positive</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     指定剔除背向当前视图点的所有三角形。这也称为背面剔除。
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
 NativeWindow 类提供一个接口，用于创建和控制本机桌面窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 NativeWindow 类提供一个接口，用于创建和控制本机桌面窗口。
  
 <p platform="actionscript">对 NativeWindow 实例的引用由 window 构造函数返回。也可以使用该窗口的舞台上的任何显示对象的 <codeph>stage.nativeWindow</codeph> 属性来访问对 NativeWindow 实例的引用。
 </p>
 
 <pre platform="actionscript">var window:NativeWindow = displayObject.stage.nativeWindow;</pre>
 
 <p platform="javascript">对 NativeWindow 实例的引用由 window 构造函数返回。HTML 页中的 JavaScript 可以通过使用 <codeph>window.nativeWindow</codeph> 属性引用 NativeWindow 实例。
 </p>
 
 <p>NativeWindow 实例的属性只能由应用程序内容访问。如果非应用程序内容尝试访问 NativeWindow 对象，则将引发安全错误。</p>
 
 <p>可以使用 Stage 对象的 DisplayObjectContainer 方法（如 <codeph>addChild()</codeph>）将内容添加到窗口中。</p>
 
 <p platform="actionscript">不能将 Flex 组件直接添加到 NativeWindow 实例的显示列表中。而应使用 Flex mx:WindowedApplication 和 mx:Window 组件创建窗口并将其它 Flex 组件添加为上述对象的子项。可以将基于 Flex 的 SWF 内容直接添加到 NativeWindow 窗口，只要该 SWF 文件已加载到自己的应用程序域中并且是应用程序内容。
 </p>
 
 <p>要创建根 HTML 窗口以显示 HTML 内容，使用 <codeph>HTMLLoader.createRootWindow()</codeph> 创建该窗口通常更容易些。以此方式创建的窗口将会自动添加 HTMLLoader 对象。（也可以从 JavaScript 中使用 JavaScript <codeph>window.open()</codeph> 函数。不过，此方法对窗口外观和行为的控制能力较差。）</p>
 
 <p>
 下面对 NativeWindow 对象的操作是异步执行的：<codeph>close()</codeph>、<codeph>maximize()</codeph>、<codeph>minimize()</codeph>、<codeph>restore()</codeph> 和 <codeph>bounds</codeph> 更改。应用程序可以通过侦听相应的事件来检测这些操作何时完成。
 </p>
 
 <p>
 如果 <codeph>NativeApplication.autoExit</codeph> 属性为默认值 <codeph>true</codeph>，则当应用程序的最后一个窗口关闭时，应用程序也将关闭（并且所有 <codeph>close</codeph> 事件处理函数均已返回）。如果 <codeph>autoExit</codeph> 为 <codeph>false</codeph>，则必须调用 <codeph>NativeApplication.nativeApplication.exit()</codeph> 才能终止应用程序。
 </p>
 <p>
 在调用 window 构造函数之后和调用 <codeph>close()</codeph> 之前，不会对 NativeWindow 对象进行垃圾回收。应用程序负责关闭其自己的窗口。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/nativeWindow"><linktext>flash.display.Stage.nativeWindow</linktext></link><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="flash.desktop.xml#NativeApplication"><linktext>flash.desktop.NativeApplication</linktext></link><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.DEACTIVATE_deactivate"><apiName>deactivate</apiName><shortdesc>
 在取消激活窗口后由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.DEACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在取消激活窗口后由此 NativeWindow 对象分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.ACTIVATE_activate"><apiName>activate</apiName><shortdesc>
 在激活窗口后由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.ACTIVATE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在激活窗口后由此 NativeWindow 对象分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 在关闭窗口后由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在关闭窗口后由此 NativeWindow 对象分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.Event.CLOSING_closing"><apiName>closing</apiName><shortdesc>
 在关闭窗口的前一刻由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSING</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在关闭窗口的前一刻由此 NativeWindow 对象分派。可以取消此事件以避免关闭窗口。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE_displayStateChange"><apiName>displayStateChange</apiName><shortdesc>
 在窗口的 displayState 属性更改后由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在窗口的 <codeph>displayState</codeph> 属性更改后由此 NativeWindow 对象分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING_displayStateChanging"><apiName>displayStateChanging</apiName><shortdesc>
 在窗口更改其显示状态的前一刻由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowDisplayStateEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在窗口更改其显示状态的前一刻由此 NativeWindow 对象分派。可以取消此事件以避免更改。
 
 </apiDesc><example conref="examples\NativeWindow.displayStateChanging.1.as"> 下面的示例演示如何取消 <codeph>displayStateChanging</codeph> 事件。
<codeblock>
function displayStateChanging_handler(displayStateEvent:NativeWindowDisplayStateEvent):void
{
  //shouldStopStateChange is an application-defined Boolean indicating 
  //that display state changes should be canceled
  if (displayStateEvent.type == NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING 
                                  &amp;&amp;    shouldStopStateChange)
  {
    displayStateEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 在调整窗口大小后由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在调整窗口大小后由此 NativeWindow 对象分派。每当窗口大小（<codeph>width</codeph> 或 <codeph>height</codeph> 属性）更改时分派 <codeph>resize</codeph> 事件，窗口大小的更改可能是系统控制的窗口大小调整操作的结果：最小化、最大化或还原窗口、或通过设置 <codeph>width</codeph>、<codeph>height</codeph> 或 <codeph>bounds</codeph> 属性更改窗口大小。NativeWindow 的 <codeph>resize</codeph> 事件是在系统控制的调整大小循环中分派的。相反，Stage 对象的 <codeph>resize</codeph> 事件是在舞台准备好绘图时分派的。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Stage/resize"><linktext>flash.display.Stage.resize</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.RESIZING_resizing"><apiName>resizing</apiName><shortdesc>
 在桌面上调整窗口大小的前一刻由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.RESIZING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在桌面上调整窗口大小的前一刻由此 NativeWindow 对象分派。可以取消此事件以避免或修改调整大小。
 
 </apiDesc><example conref="examples\NativeWindow.resizing.1.as"> 下面的示例演示如何取消 <codeph>resizing</codeph> 事件。
<codeblock>
function boundsChanging_handler(boundsEvent:NativeWindowBoundsEvent):void
{
  //shouldStopResize is an application-defined Boolean indicating 
  //that resize operations should be canceled
  if (boundsEvent.type == NativeWindowBoundsEvent.RESIZING &amp;&amp; shouldStopResize)
  {
    boundsEvent.preventDefault();
  }
}
</codeblock></example></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVE_move"><apiName>move</apiName><shortdesc>
 在桌面上移动窗口后由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVE</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在桌面上移动窗口后由此 NativeWindow 对象分派。
 <p>
 每当窗口原点（<codeph>x</codeph> 或 <codeph>y</codeph> 属性）更改时分派 <codeph>move</codeph> 事件，窗口原点的更改可能是系统控制的窗口移动操作的结果：最小化、最大化或还原窗口、或通过设置 <codeph>x</codeph>、<codeph>y</codeph> 或 <codeph>bounds</codeph> 属性更改窗口位置。
 </p>
 <p><b>注意：</b>在 NativeWindow 对象的 <codeph>moving</codeph> 和 <codeph>move</codeph> 事件的处理函数中，避免可能会同时打开操作系统对话框的动作。例如，如果两个处理函数都引发错误，则可能发生这种情况。如果真的发生这种情况，则打开的第二个对话框将不会注册鼠标单击，必须使用键盘才能取消。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:NativeWindow_flash.events.NativeWindowBoundsEvent.MOVING_moving"><apiName>moving</apiName><shortdesc>
 在桌面上移动窗口的前一刻由此 NativeWindow 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.NativeWindowBoundsEvent.MOVING</apiEventType><adobeApiEventClassifier>flash.events.NativeWindowBoundsEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在桌面上移动窗口的前一刻由此 NativeWindow 对象分派。可以取消此事件以避免或修改移动。
 
 <p><b>注意：</b>在 NativeWindow 对象的 <codeph>moving</codeph> 和 <codeph>move</codeph> 事件的处理函数中，避免可能会同时打开操作系统对话框的动作。例如，如果两个处理函数都引发错误，则可能发生这种情况。如果真的发生这种情况，则打开的第二个对话框将不会注册鼠标单击，必须使用键盘才能取消。</p>
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.display:NativeWindow:NativeWindow"><apiName>NativeWindow</apiName><shortdesc>
    创建新的 NativeWindow 实例和相应的操作系统窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>如果 <codeph>initOptions</codeph> 参数无效。
    
    </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiParam><apiItemName>initOptions</apiItemName><apiOperationClassifier>flash.display:NativeWindowInitOptions</apiOperationClassifier><apiDesc>一个包含此窗口初始化属性的对象。
    </apiDesc></apiParam></apiConstructorDef><apiDesc>
    创建新的 NativeWindow 实例和相应的操作系统窗口。
    <p>
    创建窗口后，不能更改 <codeph>initOptions</codeph> 参数中定义的设置。无效的 <codeph>initOptions</codeph> 设置将导致引发非法操作错误。在当前系统中有效但不可用的设置不会引发异常。如果需要，可以使用静态 NativeWindow 成员（比如 <codeph>systemMaxSize</codeph>）来检测特定于当前操作系统的窗口功能。
    </p>
    
    <p>默认的窗口大小由操作系统确定，但是可以通过设置窗口范围来更改。如果窗口的 <codeph>visible</codeph> 属性为 <codeph>false</codeph>，则更改将是不可见的。</p>
    
    </apiDesc><example conref="examples\NativeWindow.constructor.1.as"> 下面的示例将创建并激活一个新的 NativeWindow 实例：
<codeblock>
import flash.display.NativeWindowInitOptions;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowType;
import flash.display.NativeWindow;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.geom.Rectangle;

var windowOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
windowOptions.systemChrome = NativeWindowSystemChrome.STANDARD;
windowOptions.type = NativeWindowType.NORMAL;

var newWindow:NativeWindow = new NativeWindow(windowOptions);
newWindow.stage.scaleMode = StageScaleMode.NO_SCALE;
newWindow.stage.align = StageAlign.TOP_LEFT;
newWindow.bounds = new Rectangle(100, 100, 800, 800);

newWindow.activate();
</codeblock></example></apiConstructorDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions"><linktext>flash.display.NativeWindowInitOptions</linktext></link><link href="../../flash/html/HTMLLoader.html#createRootWindow()"><linktext>flash.html.HTMLLoader.createRootWindow()</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:NativeWindow:activate"><apiName>activate</apiName><shortdesc>
	 激活此窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 激活此窗口。 
	 
	 <p>激活一个窗口将会：</p>
	 <ul> 
	 <li>使该窗口可见</li>
	 <li>将该窗口置于前面</li> 
	 <li>为该窗口提供键盘和鼠标焦点</li>
	 </ul>
	 
	 <p>在 Linux 上，<codeph>activate()</codeph> 是一种异步操作。</p>
	 
	 <p>在所有平台上，NativeWindow 对象都会分派 <codeph>activate</codeph> 事件。</p>
	 
	 </apiDesc><example conref="examples\NativeWindow.activate.1.as"> 下面的示例演示如何激活窗口。
  
 <p>使用对窗口舞台上的显示对象的引用：</p>
<codeblock>
displayObject.stage.nativeWindow.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.2.as"> 使用对 NativeWindow 类的实例的引用：
<codeblock>
windowObj.activate();
</codeblock></example><example conref="examples\NativeWindow.activate.3.as"> 从窗口中呈现的 HTML 页中的 JavaScript（此处的 <codeph>window</codeph> 是全局 JavaScript window 对象）：
<codeblock>
window.nativeWindow.activate();
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/visible"><linktext>visible</linktext></link><link href="flash.display.xml#NativeWindow/orderToFront"><linktext>orderToFront</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:close"><apiName>close</apiName><shortdesc>
      关闭此窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      关闭此窗口。 
      
      <p>关闭操作一旦完成即分派 <codeph>close</codeph> 事件。将不分派 <codeph>closing</codeph> 事件。如果应该允许取消关闭操作，请分派一个 <codeph>closing</codeph> 事件并检查在调用 <codeph>close()</codeph> 方法之前是否有任何注册的侦听器取消了默认行为。
      </p>
      <p>
      如果未在其它位置引用当前处于此窗口中的显示对象实例，则会将这些实例作为垃圾回收，除非它们位于由 AIR 创建的初始应用程序窗口中。要允许将初始窗口中的显示对象作为垃圾进行回收，请将它们从窗口舞台上删除。
      </p>
      <p>
      关闭后的 NativeWindow 对象仍然是有效的引用，但访问大多数属性和方法都将引发非法操作错误。
      </p>
      <p>
      关闭的窗口无法重新打开。如果窗口已经关闭，则不执行任何动作，也不分派任何事件。
      </p>
      
      <p>注意：要在不关闭窗口的情况下隐藏一个窗口，请将该窗口的 <codeph>visible</codeph> 属性设置为 <codeph>false</codeph>。
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.close.1.as"> 下面的示例演示如何关闭窗口：
  
 <p>通过引用 NativeWindow 实例 (<codeph>windowObj</codeph>)：</p>
<codeblock>
windowObj.close();

</codeblock></example><example conref="examples\NativeWindow.close.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObj.stage.nativeWindow.close();
</codeblock></example><example conref="examples\NativeWindow.close.3.as"> 从 HTMLLoader 对象（或 HTML 根窗口）中运行的 JavaScript 例程：
<codeblock>
window.close(); //overriddable in HTMLHost
</codeblock></example><example conref="examples\NativeWindow.close.4.as"> 或者：
<codeblock>
window.nativeWindow.close(); //not overriddable
</codeblock></example><example conref="examples\NativeWindow.close.5.as">  
 下面的示例演示如何允许取消关闭操作（其中 <codeph>windowObj</codeph> 是要关闭的 NativeWindow 实例）：
<codeblock>
public function closeCommand():Boolean{
    var closeEvent:Event = new Event(Event.CLOSING,true,true);
    windowObj.dispatchEvent(closeEvent);
    if(!closeEvent.isDefaultPrevented()){
        windowObj.close();
        return true;
    } else {
      return false;
    }
}
</codeblock></example><example conref="examples\NativeWindow.close.6.as"> 下面的示例演示如何从 HTMLLoader 对象（或 HTML 根窗口）中运行的 JavaScript 例程关闭窗口，同时允许取消该操作：
<codeblock>
&lt;script src="AIRAliases.js" type="text/javascript">&lt;/script>
&lt;script type="text/javascript">
    var dirtyData = false;
    function closeWindow(){
            var closingEvent = new air.Event(air.Event.CLOSING,true,true);
            window.nativeWindow.dispatchEvent(closingEvent);
               if(!closingEvent.isDefaultPrevented()){
                   window.nativeWindow.close();
                //or use: window.close(); 
               return true;
           } else {
               return false;
        }
    }
        
    function onClosing(event){
        if(dirtyData){
            event.preventDefault();
            //Save data...
        }
    }    

    window.nativeWindow.addEventListener(air.Event.CLOSING,onClosing);        
&lt;/script>
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindow/closed"><linktext>flash.display.NativeWindow.closed</linktext></link><link href="../../flash/html/HTMLLoader.html"><linktext>flash.html.HTMLLoader</linktext></link><link href="../../flash/html/HTMLHost.html"><linktext>flash.html.HTMLHost</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:globalToScreen"><apiName>globalToScreen</apiName><shortdesc>
      将像素坐标中相对于窗口舞台原点（就显示列表而言为全局点）转换为虚拟桌面上的点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定的相对于桌面的全局点。
      
      </apiDesc><apiOperationClassifier>flash.geom:Point</apiOperationClassifier></apiReturn><apiParam><apiItemName>globalPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>要转换为屏幕上的点的舞台上的点。
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      将像素坐标中相对于窗口舞台原点（就显示列表而言为全局点）转换为虚拟桌面上的点。
      
      <p>虚拟桌面坐标相对于主监视器的左上角。</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:maximize"><apiName>maximize</apiName><shortdesc>
      使此窗口最大化。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果此窗口的 <codeph>maximizable</codeph> 属性为 <codeph>false</codeph> 或如果在关闭此窗口后调用该方法。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      使此窗口最大化。  
      <p>
      调用 <codeph>maximize()</codeph> 将分派 <codeph>displayStateChange</codeph> 事件，如果适用，还将分派 <codeph>move</codeph> 和 <codeph>resize</codeph> 事件。系统镶边将分派 <codeph>displayStateChanging</codeph> 事件，当用户启动最大化命令时可取消该事件，如果需要，您的最大化逻辑必须实现此行为。
      </p>
      <p>
      <codeph>maximize()</codeph> 方法异步执行。要检测状态更改是否完成，请侦听 <codeph>displayStateChange</codeph> 事件。
      </p>
      <p>如果窗口已经最大化，则不执行任何动作，也不分派任何事件。</p>
      
      <p><b>注意：</b></p> 
      <ul>
      <li>在某些操作系统（如 Mac OS X）中，将窗口最大化并不会同时阻止调整大小，调用 <codeph>maximize()</codeph> 将缩放窗口以填充屏幕，但并不阻止随后的调整窗口大小。调整经过缩放的窗口的大小也会还原显示状态。</li>
      
      <li>在某些操作系统（如 Mac OS X）中以及在某些 Linux 窗口管理器中，将窗口最大化并不会将窗口扩大至超出 <codeph>maxSize</codeph> 属性中指定的宽度和高度。在其它操作系统中，即使屏幕大于 <codeph>maxSize</codeph>，也将扩大窗口以填充屏幕。</li>
      
      <li>某些 Linux 窗口管理器不允许将实用程序窗口最大化。</li>
      
      </ul>
      
      </apiDesc><example conref="examples\NativeWindow.maximize.1.as">  
 下面的示例演示如何允许取消最大化操作：  
<codeblock>
public function maximizeWindow(nativeWin:NativeWindow):Boolean{
  if(nativeWin.displayState != NativeWindowDisplayState.MAXIMIZED){
    var beforeState:String = nativeWin.displayState;
    var afterState:String = NativeWindowDisplayState.MAXIMIZED;
    var displayStateEvent:NativeWindowDisplayStateEvent = 
        new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
    nativeWin.dispatchEvent(displayStateEvent);
    if(!displayStateEvent.isDefaultPrevented()){
        nativeWin.maximize();
        return true;
    } else {
      return false;
    }
  }
  return false;
}
</codeblock></example><example conref="examples\NativeWindow.maximize.2.as">  
 下面的示例演示如何允许在窗口（或 HTML 窗口）上的 HTMLLoader 对象中运行的 JavaScript 例程中取消最大化操作：  
<codeblock>
function maximizeWindow(nativeWin){
    if(nativeWin.displayState != air.NativeWindowDisplayState.MAXIMIZED){
        var beforeState = nativeWin.displayState;
        var afterState = air.NativeWindowDisplayState.MAXIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.maximize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:minimize"><apiName>minimize</apiName><shortdesc>
      使此窗口最小化。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果此窗口的 <codeph>minimizable</codeph> 属性为 <codeph>false</codeph> 或如果在关闭此窗口后调用该方法。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      使此窗口最小化。 
      <p>
      调用 <codeph>minimize()</codeph> 将分派 displayStateChange 事件，如果适用，还将分派 move 和 resize 事件。<codeph/><codeph/><codeph/>系统镶边将分派 <codeph>displayStateChanging</codeph> 事件，当用户启动最小化命令时可取消该事件，而直接调用 <codeph>minimize()</codeph> 不能分派该事件。如果需要，您的最小化逻辑可以实现此行为。
      </p>
      
      <p><codeph>minimize()</codeph> 方法异步执行。要检测状态更改是否完成，请侦听 <codeph>displayStateChange</codeph> 事件。如果窗口已经最小化，则不执行任何动作，也不分派任何事件。</p>
      
      <p>某些 Linux 窗口管理器不允许将实用程序窗口最小化。</p>
      
	  </apiDesc><example conref="examples\NativeWindow.minimize.1.as"> 下面的示例演示如何通过分派 <codeph>displayStateChanging</codeph> 事件来允许取消对 <codeph>minimize()</codeph> 的调用： 
<codeblock>
public function minimizeWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.MINIMIZED){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            nativeWin.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.minimize.2.as"> 下面示例演示如何允许在 HTMLLoader 对象（或 HTML 窗口）中运行的 JavaScript 中取消对 <codeph>minimize()</codeph> 的调用： 
<codeblock> 
function minimizeWindow(){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.MINIMIZED){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.MINIMIZED;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.minimize();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:notifyUser"><apiName>notifyUser</apiName><shortdesc>
      通过操作系统触发可视提示：发生了需要关注的事件。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>一个表示通知紧急程度的字符串。   
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      通过操作系统触发可视提示：发生了需要关注的事件。
      
      <p>当 <codeph>NativeWindow.supportsNotification</codeph> 为 <codeph>true</codeph> 时，可视提示将遵循本机系统的操作系统约定。例如在 Windows 中，任务栏图标将闪烁。</p>
      
      <p><codeph>type</codeph> 参数确定提示的强度。用作允许值的常量在 NotificationType 类中定义，这些常量可以是：</p>
      <ul>
      <li><codeph>NotificationType.INFORMATIONAL</codeph></li>
      <li><codeph>NotificationType.CRITICAL</codeph></li>
      </ul>
      <p>为信息性通知提供的提示持续时间很短，而为关键通知提供的提示将持续到用户激活此窗口为止。并非所有 Linux 窗口管理器都支持两种通知级别。对于此类窗口管理器，无论指定哪个选项，<codeph>notifyUser()</codeph> 的效果都将相同。</p>
      
      <p><b>注意：</b>允许在 <codeph>NativeWindow.supportsNotification</codeph> 为 <codeph>false</codeph> 时调用 <codeph>notifyUser()</codeph>，但不执行任何操作。</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInBackOf"><apiName>orderInBackOf</apiName><shortdesc>
      将此窗口放在紧靠指定窗口后面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此窗口成功地放到了后面，则为 <codeph>true</codeph>；如果此窗口不可见或最小化，则为 <codeph>false</codeph>。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>一个应用程序窗口。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      将此窗口放在紧靠指定窗口后面。
      
      <p>不要激活此窗口或应用程序或获取其焦点。最小化或隐藏的 (<codeph>visible</codeph> 为 <codeph>false</codeph>) 窗口无法重新排序。</p>
      
      <p>某些 Linux 窗口管理器不允许将实用程序窗口排在常规窗口之后。</p>
      
      </apiDesc><example conref="NativeWindow.orderInBackOf.1.as"> 下面的示例显示如何通过引用 NativeWindow 实例将一个窗口移动到紧靠另一个窗口下面：
<codeblock>
windowBehind.orderInBackOf(windowFront);
</codeblock></example><example conref="NativeWindow.orderInBackOf.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObjBehind.stage.nativeWindow.orderInBackOf(displayObjectFront.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInBackOf.3.as"> 从使用对两个 JavaScript 窗口对象的引用的 HTMLLoader 对象（或 HTML 根窗口）中运行的 JavaScript 例程中：
<codeblock>
jsWindowObjBehind.nativeWindow.orderInBackOf(jsWindowObjFront.nativeWindow);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderInFrontOf"><apiName>orderInFrontOf</apiName><shortdesc>
      将此窗口放在紧靠指定窗口前面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此窗口成功地放到了前面，则为 <codeph>true</codeph>；如果此窗口不可见或最小化，则为 <codeph>false</codeph>。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>flash.display:NativeWindow</apiOperationClassifier><apiDesc>一个应用程序窗口。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      将此窗口放在紧靠指定窗口前面。
      
      <p>不要激活此窗口或应用程序或获取其焦点。最小化或隐藏的 (<codeph>visible</codeph> 为 <codeph>false</codeph>) 窗口无法重新排序。</p>
      
      <p>某些 Linux 窗口管理器不允许将常规窗口排在实用程序窗口之前。</p>
      
      </apiDesc><example conref="NativeWindow.orderInFrontOf.1.as"> 下面的示例显示如何通过引用 NativeWindow 实例将一个窗口移动到紧靠另一个窗口上面：
<codeblock>
windowFront.orderInFrontOf(windowBehind);
</codeblock></example><example conref="NativeWindow.orderInFrontOf.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObjFront.stage.nativeWindow.orderInFrontOf(displayObjectBehind.stage.nativeWindow);

</codeblock></example><example conref="NativeWindow.orderInFrontOf.3.as"> 从使用对两个 JavaScript 窗口对象的引用的 HTMLLoader 对象（或 HTML 根窗口）中运行的 JavaScript 例程中：
<codeblock>
jsWindowObjFront.nativeWindow.orderInFrontOf(jsWindowObjBehind.nativeWindow);

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToBack"><apiName>orderToBack</apiName><shortdesc>
      将此窗口放在任何其它可见窗口后面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此窗口成功地放到了后面，则为 <codeph>true</codeph>；如果此窗口不可见或最小化，则为 <codeph>false</codeph>。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      将此窗口放在任何其它可见窗口后面。
      
      <p>不要激活此窗口或应用程序或获取其焦点。最小化或隐藏的 (<codeph>visible</codeph> 为 <codeph>false</codeph>) 窗口无法重新排序。</p>
      
      <p>如果 <codeph>alwaysInFront</codeph> 为 <codeph>true</codeph>，则调用此方法不会将此窗口置于任何 <codeph>alwaysInFront</codeph> 设置为 <codeph>false</codeph> 的窗口的后面。</p>
      
      <p>某些 Linux 窗口管理器不允许将实用程序窗口排在常规窗口之后。</p>
      
      </apiDesc><example conref="NativeWindow.orderToBack.1.as"> 下面的示例显示如何将某个窗口放在应用程序中所有其它窗口（使用同样的 <codeph>alwaysInFront</codeph> 设置）的后面：
<codeblock>
windowObj.orderToBack();

</codeblock></example><example conref="NativeWindow.orderToBack.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObj.stage.nativeWindow.orderToBack();
</codeblock></example><example conref="NativeWindow.orderToBack.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.orderToBack();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:orderToFront"><apiName>orderToFront</apiName><shortdesc>
      将此窗口放在任何其它可见窗口前面。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此窗口成功地放到了前面，则为 <codeph>true</codeph>；如果此窗口不可见或最小化，则为 <codeph>false</codeph>。
      
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      将此窗口放在任何其它可见窗口前面。 
      
      <p>不要激活此窗口或应用程序或获取其焦点。最小化或隐藏的 (<codeph>visible</codeph> 为 <codeph>false</codeph>) 窗口无法重新排序。</p>
       
      <p>如果 <codeph>alwaysInFront</codeph> 为 <codeph>false</codeph>，则调用此方法不会将此窗口置于任何已将 <codeph>alwaysInFront</codeph> 设置为 <codeph>true</codeph> 的窗口的前面。</p>
      
      <p>某些 Linux 窗口管理器不允许将常规窗口排在实用程序窗口之前。</p> 
      
      </apiDesc><example conref="NativeWindow.orderToFront.1.as"> 下面的示例显示如何将某个窗口放在应用程序中所有其它窗口（使用同样的 <codeph>alwaysInFront</codeph> 设置）的前面：
<codeblock>
windowObj.orderToFront();

</codeblock></example><example conref="NativeWindow.orderToFront.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObj.stage.nativeWindow.orderToFront();
</codeblock></example><example conref="NativeWindow.orderToFront.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.orderToFront();

</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:restore"><apiName>restore</apiName><shortdesc>
      从最小化或最大化状态还原此窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果在已关闭此窗口后调用此方法。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      从最小化或最大化状态还原此窗口。
      
      <p>调用 <codeph>restore()</codeph> 将分派 <codeph>displayStateChange</codeph> 事件，如果适用，还将分派 <codeph>move</codeph> 和 <codeph>resize</codeph> 事件。系统镶边将分派 <codeph>displayStateChanging</codeph> 事件，当用户启动还原命令时可取消该事件，如果需要，您的还原逻辑必须实现此行为。
      </p>
      
      <p>如果窗口已经处于 <codeph>NativeWindowDisplayState.NORMAL</codeph> 状态，则不执行任何动作，也不分派任何事件。</p>
      
      <p>
      要检测状态更改是否完成，请侦听 <codeph>displayStateChange</codeph> 事件，所有平台上都会分派该事件。
      </p>
      
	  </apiDesc><example conref="examples\NativeWindow.restore.1.as">  
 下面的示例演示如何允许取消还原操作： 
<codeblock>
public function restoreWindow(nativeWin:NativeWindow):Boolean{
    if(nativeWin.displayState != NativeWindowDisplayState.NORMAL){
        var beforeState:String = nativeWin.displayState;
        var afterState:String = NativeWindowDisplayState.NORMAL;
        var displayStateChangingEvent:NativeWindowDisplayStateEvent = 
            new NativeWindowDisplayStateEvent(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        nativeWin.dispatchEvent(displayStateChangingEvent);
        if(!displayStateChangingEvent.isDefaultPrevented()){
            nativeWin.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example><example conref="examples\NativeWindow.restore.2.as"> 下面的示例演示如何允许在窗口（或 HTML 窗口）上的 HTMLLoader 对象中运行的 JavaScript 例程中取消还原操作： 
<codeblock>
function restoreWindow(nativeWin){
    if(window.nativeWindow.displayState != air.NativeWindowDisplayState.NORMAL){
        var beforeState = window.nativeWindow.displayState;
        var afterState = air.NativeWindowDisplayState.NORMAL;
        var displayStateEvent = 
            new air.NativeWindowDisplayStateEvent(air.NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING,
                                              true,true,beforeState,afterState);
        window.nativeWindow.dispatchEvent(displayStateEvent);
        if(!displayStateEvent.isDefaultPrevented()){
            window.nativeWindow.restore();
            return true;
        } else {
          return false;
        }
     }
     return false;
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link><link href="flash.events.xml#NativeWindowDisplayStateEvent"><linktext>flash.events.NativeWindowDisplayStateEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:NativeWindow:startMove"><apiName>startMove</apiName><shortdesc>
      启动此窗口的系统控制移动。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果在已关闭此窗口后调用此方法。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果成功启动了移动，则为 <codeph>true</codeph>；如果最大化了窗口，则为 <codeph>false</codeph>。
      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      启动此窗口的系统控制移动。
      <p>
      在从 <codeph>mouseDown</codeph> 事件调用时，此方法开始一个由鼠标驱动的移动序列，该序列将持续到发生 <codeph>mouseUp</codeph> 事件为止。 
      </p>
      <p>
      在从其它代码调用时，此方法开始一个由键盘或鼠标驱动的移动序列，该序列与操作系统的默认序列一致。
      </p>
      
      <p>在移动序列执行期间，随着窗口原点的移动，将分派一系列事件。对于每次增量移动，首先分派一个 <codeph>moving</codeph> 事件，然后，如果未取消该 <codeph>moving</codeph> 事件，则将更新窗口位置并分派一个 <codeph>move</codeph> 事件。如果取消了 <codeph>moving</codeph> 事件，则移动序列将立即终止。</p>
      
      </apiDesc><example conref="NativeWindow.startMove.1.as"> 下面的示例演示如何为响应 <codeph>mouseDown</codeph> 事件来移动窗口：
<codeblock>
var initOpts:NativeWindowInitOptions = new NativeWindowInitOptions();
var win:NativeWindow = new NativeWindow(initOpts);
win.activate();
win.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);

function mouseDownHandler(event:MouseEvent):void
{
    win.startMove();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:NativeWindow:startResize"><apiName>startResize</apiName><shortdesc>
      启动此窗口的系统控制调整大小操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果在已关闭此窗口后调用此方法。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果成功启动了调整大小，则为 <codeph>true</codeph>；如果最大化了窗口，则为 <codeph>false</codeph>。

      </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>edgeOrCorner</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>unknown</apiData><apiDesc>NativeWindowResize 类中的一个常量，用于指定要调整此窗口的哪个边或角的大小。以下是有效值：
      
      <p>
      <adobetable class="innertable">
          
           
           
           
           
            
            
            
            
            
           
      <tgroup cols="3"><thead><row><entry>值</entry><entry>垂直对齐方式</entry><entry>水平对齐方式</entry></row></thead><tbody><row><entry><codeph>NativeWindowResize.TOP</codeph></entry>
           <entry>顶对齐</entry>
           <entry>居中对齐</entry>
           </row><row><entry><codeph>NativeWindowResize.BOTTOM</codeph></entry>
           <entry>底对齐</entry>
           <entry>居中对齐</entry>
           </row><row><entry><codeph>NativeWindowResize.LEFT</codeph></entry>
           <entry>居中对齐</entry>
           <entry>左对齐</entry>
           </row><row><entry><codeph>NativeWindowResize.RIGHT</codeph></entry>
           <entry>居中对齐</entry>
           <entry>右对齐</entry>
           </row><row><entry><codeph>NativeWindowResize.TOP_LEFT</codeph></entry>
            <entry>顶对齐</entry>
            <entry>左对齐</entry>
            </row><row><entry><codeph>NativeWindowResize.TOP_RIGHT</codeph></entry>
            <entry>顶对齐</entry>
            <entry>右对齐</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_LEFT</codeph></entry>
            <entry>底对齐</entry>
            <entry>左对齐</entry>
            </row><row><entry><codeph>NativeWindowResize.BOTTOM_RIGHT</codeph></entry>
            <entry>底对齐</entry>
            <entry>右对齐</entry>
            </row><row><entry><codeph>NativeWindowResize.NONE</codeph></entry>
            <entry>底对齐</entry>
            <entry>右对齐</entry>
            </row></tbody></tgroup></adobetable>
      </p>
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      启动此窗口的系统控制调整大小操作。
      <p>
      在从 <codeph>mouseDown</codeph> 事件处理函数调用时，此方法开始一个由鼠标驱动的调整大小序列，该序列将持续到发生 <codeph>mouseUp</codeph> 事件为止。  
      </p>
      <p>
      在从其它代码调用时，此方法开始一个由键盘或鼠标驱动的调整大小序列，该序列与操作系统的默认序列一致。
      </p>
      <p>在调整大小序列执行期间，随着窗口尺寸的更改，将分派一系列事件。对于每次增量更改，首先分派一个 <codeph>resizing</codeph> 事件，然后，如果未取消该 <codeph>resizing</codeph> 事件，则将更新窗口尺寸并分派一个 <codeph>resize</codeph> 事件。如果取消了 <codeph>resizing</codeph> 事件，则该序列将立即终止。</p>
      
      </apiDesc><example conref="NativeWindow.startResize.1.as"> 下面示例演示如何为响应 <codeph>mouseDown</codeph> 事件来调整窗口大小：
<codeblock>
stage.addEventListener(MouseEvent.MOUSE_DOWN, onResizeCommand);

function onResizeCommand(event:MouseEvent):void
{
    var win:NativeWindow = event.target.nativeWindow;
    var resizeFrom:String = "";
    if (event.stageY &lt; win.height * .33)
    {
        resizeFrom = NativeWindowResize.TOP;
    }
    else if (event.stageY > win.height * .66)
    {
        resizeFrom = NativeWindowResize.BOTTOM;
    }
    if (event.stageX &lt; win.width * .33)
    {
        resizeFrom += NativeWindowResize.LEFT;
    }
    else if (event.stageX > win.width * .66)
    {
        resizeFrom += NativeWindowResize.RIGHT;
    }
    win.startResize(resizeFrom);    
}
</codeblock></example></apiOperationDetail></apiOperation><apiValue id="flash.display:NativeWindow:active:get"><apiName>active</apiName><shortdesc>
      指示此窗口是否为活动应用程序窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      指示此窗口是否为活动应用程序窗口。
      
      <p>使用 <codeph>activate()</codeph> 方法可使窗口处于活动状态。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate"><linktext>flash.display.NativeWindow.activate</linktext></link><link href="flash.desktop.xml#NativeApplication/activate"><linktext>flash.desktop.NativeApplication.activate</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:alwaysInFront:get"><apiName>alwaysInFront</apiName><shortdesc>
      指定此窗口是否始终显示在其它窗口前面（包括其它应用程序的窗口）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      指定此窗口是否始终显示在其它窗口前面（包括其它应用程序的窗口）。
      
      <p>沿系统深度顺序有两组窗口。位于 <codeph>alwaysInFront</codeph> 组中的窗口始终显示在所有其它窗口的前面。同一组内的窗口之间的深度顺序按常规确定。换句话说，激活一个窗口会将该窗口置于其组内的其它窗口前面。</p>
      
      <p>将 <codeph>alwaysInFront</codeph> 从 <codeph>false</codeph> 更改为 <codeph>true</codeph> 会将该窗口置于所有其它窗口的前面。将该属性从 <codeph>true</codeph> 更改为 <codeph>false</codeph> 会将该窗口置于“alwaysInFront”窗口的后面，但仍位于其它窗口前面。将该属性设置为其当前值不会更改该窗口的深度顺序。</p>
      
      <p>应该尽量少将 <codeph>alwaysInFront</codeph> 设置为 <codeph>true</codeph>，因为使用此设置的窗口将出现在其它应用程序的窗口之前，即使其它应用程序处于活动状态时也是如此。</p>
      
      <p>某些 Linux 窗口管理器始终将实用程序窗口显示在常规窗口之前。</p>
      
      <p><b>注意：</b>在 Mac<sup>®</sup> OS X 中，如果窗口舞台的 <codeph>displayState</codeph> 属性为 <codeph>fullScreen</codeph> 或 <codeph>fullScreenInteractive</codeph>，将 <codeph>alwaysInFront</codeph> 设置为 <codeph>true</codeph> 将不起作用。在 Linux 中，<codeph>alwaysInFront</codeph> 设置为 <codeph>true</codeph> 的全屏窗口始终显示在 <codeph>alwaysInFront</codeph> 设置为 <codeph>true</codeph> 的其它窗口之前。</p> 
      
      </apiDesc><example conref="NativeWindow.alwaysInFront.1.as"> 下列示例强制将某个窗口显示在其它所有窗口（这些窗口不受类似的强制）前面：
<codeblock>
windowObj.alwaysInFront = true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObject.stage.nativeWindow.alwaysInFront=true;
</codeblock></example><example conref="NativeWindow.alwaysInFront.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.alwaysInFront = true;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:bounds:set"><apiName>bounds</apiName><shortdesc>
      此窗口的大小和位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier><apiException><apiDesc>如果矩形为空或包含无效值。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问 bounds 属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的大小和位置。  
      <p>
      窗口尺寸包括任何系统镶边。窗口舞台的尺寸等于窗口尺寸减去任何系统镶边的大小。更改窗口的宽度和高度将更改舞台的 <codeph>stageWidth</codeph> 和 <codeph>stageHeight</codeph>。反之亦然：更改舞台尺寸也将更改窗口大小。
      </p>
      <p>在根 HTML 窗口中，<codeph>outerWidth</codeph> 和 <codeph>outerHeigth</codeph> 属性等效于窗口的 <codeph>height</codeph> 和 <codeph>width</codeph> 属性。<codeph>innerWidth</codeph> 和 <codeph>innerHeight</codeph> 属性等于 <codeph>stage.stageWidth</codeph> 和 <codeph>stage.stageHeight</codeph> 属性减去该窗口显示的任何滚动条的粗细。</p>
      <p>
      每当此窗口的宽度或高度更改时即分派 <codeph>resize</codeph> 事件。同样，每当此窗口的原点 (x,y) 更改时即分派 <codeph>move</codeph> 事件。在 Mac OS 和 Windows 上，直接设置 <codeph>bounds</codeph> 属性不会分派 <codeph>moving</codeph> 或 <codeph>resizing</codeph> 事件。但在 Linux 上，设置 <codeph>bounds</codeph> 属性时，NativeWindow <i/>会分派 <codeph>moving</codeph> 和 <codeph>resizing</codeph> 事件。 
      </p>
      <p>
      设置窗口的 <codeph>bounds</codeph> 属性等效于设置其 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性。同样，设置任何单个尺寸等效于设置 <codeph>bounds</codeph> 属性。使用 <codeph>bounds</codeph> 属性同时设置所有尺寸时，分派的事件会较少。 
      </p>
      <p>无法保证设置各个尺寸的顺序。在不允许窗口扩大到桌面区域之外的 Linux 窗口管理器中，即使应用所有属性更改的最终效果会产生合法的窗口，也可能会阻止对单个属性的更改。</p>
      
      <p>如果指定的宽度或高度小于允许的最小值或大于允许的最大值，则会将窗口宽度或高度设置为最接近的合法大小。决定宽度和高度的最小值和最大值的因素包括以下这些：</p>
      
      <ul>
      
      	<li>NativeWindow 对象的 <codeph>minSize</codeph> 属性和 <codeph>maxSize</codeph> 属性</li>
      	<li>操作系统的最小限值和最大限值，即 <codeph>NativeWindow.systemMinSize</codeph> 和 <codeph>NativeWindow.systemMaxSize</codeph> 的值。</li>
      	<li>在 Adobe AIR 中，窗口的最大宽度和高度均为 2880 像素。</li>
      	<li>任何显示的系统镶边需要的最小宽度和高度。</li>
      
      </ul>
      
	  </apiDesc><example conref="examples\NativeWindow.bounds.1.as"> 下面的示例使用对 NativeWindow 对象的引用设置窗口的范围：
<codeblock>
windowObj.bounds = new Rectangle(200, 200, 1000, 800);
</codeblock></example><example conref="examples\NativeWindow.bounds.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObject.stage.nativeWindow.bounds = new Rectangle(20, 20, 800, 600);
</codeblock></example><example conref="examples\NativeWindow.bounds.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.bounds = new air.Rectangle(20, 20, 800, 600);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:closed:get"><apiName>closed</apiName><shortdesc>
      指示此窗口是否已关闭。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
      指示此窗口是否已关闭。  
      
      <p>对已关闭的窗口访问以下属性将引发非法操作错误：</p>
      <ul> 
      <li><codeph>title</codeph></li>
      <li><codeph>bounds</codeph></li>
      <li><codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph>、<codeph>height</codeph></li>
      <li><codeph>displayState</codeph></li>
      <li><codeph>visible</codeph></li>
      </ul>
      <p>同样，对已关闭的窗口调用以下方法也将引发非法操作错误：</p>
      <ul>
      <li><codeph>minimize()</codeph></li>
      <li><codeph>maximize()</codeph></li>
      <li><codeph>restore()</codeph></li>
      <li><codeph>startResize()</codeph></li>
      <li><codeph>startMove()</codeph></li>
      </ul>
      
      </apiDesc><example conref="NativeWindow.closed.1.as"> 下列示例演示如何访问窗口的 <codeph>closed</codeph> 属性：
<codeblock>
var isWindowClosed:Boolean = windowObj.closed;
</codeblock></example><example conref="NativeWindow.closed.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
var isWindowClosed:Boolean = displayObject.stage.nativeWindow.closed;
</codeblock></example><example conref="NativeWindow.closed.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
var isWindowClosed = window.nativeWindow.closed;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:displayState:get"><apiName>displayState</apiName><shortdesc>
     此窗口的显示状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>如果在关闭此窗口后访问 <codeph>displayState</codeph> 属性。
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     此窗口的显示状态。
     <p>
     用作可能值的常量在 NativeWindowDisplayState 类中定义： 
     </p>
     <ul>
     <li><codeph>NativeWindowDisplayState.NORMAL</codeph></li>
     <li><codeph>NativeWindowDisplayState.MINIMIZED</codeph></li>
     <li><codeph>NativeWindowDisplayState.MAXIMIZED</codeph></li>
     </ul> 
     
     </apiDesc><example conref="examples\NativeWindow.displayState.1.as"> 下面的示例显示如何在给定一个对窗口对象的引用的情况下获取当前窗口的显示状态：
<codeblock>
var state:String = windowObj.displayState;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowDisplayState"><linktext>flash.display.NativeWindowDisplayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:height:get"><apiName>height</apiName><shortdesc>
      此窗口的高度（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>如果设置的值为 <codeph>null</codeph> 或无效。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的高度（以像素为单位）。
      
      <p>窗口的尺寸包括显示的任何系统窗口镶边。可以从 <codeph>Stage.stageHeight</codeph> 属性获取窗口内部可用的显示区域高度。</p>
      
      <p>更改窗口的 <codeph>height</codeph> 属性等效于通过 <codeph>bounds</codeph> 属性更改高度。</p>
      
      <p>如果指定高度小于允许的最小值或大于允许的最大值，则会将窗口高度设置为最接近的合法大小。决定高度的最小值和最大值的因素包括以下这些：</p>
      
      <ul>
      
      	<li>NativeWindow 对象的 <codeph>minSize.x</codeph> 和属性 <codeph>maxSize.x</codeph> 属性 </li>
      	<li>操作系统的最小限值和最大限值，即 <codeph>NativeWindow.systemMinSize.x</codeph> 和 <codeph>NativeWindow.systemMaxSize.x</codeph> 的值。</li>
      	<li>在 Adobe AIR 中，窗口的最大高度为 2880 像素。</li>
      
      </ul>
      
      <p>在 Linux 上，设置 <codeph>height</codeph> 属性是一种异步操作。</p>
     
      <p>
      要检测高度更改是否完成，请侦听 <codeph>resize</codeph> 事件，所有平台上都会分派该事件。
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageHeight"><linktext>flash.display.Stage.stageHeight</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maxSize:get"><apiName>maxSize</apiName><shortdesc>
      此窗口的最大大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>如果分配的大小不在操作系统的最小和最大窗口大小范围之内。 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果因为内容的当前权限而禁止该大小。
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果该大小为 <codeph>null</codeph> 或包含无效值。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问 <codeph>maxSize</codeph> 属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的最大大小。  
      
      <p>大小限制指定为 Point 对象的坐标。点的 <codeph>x</codeph> 属性对应于窗口宽度，<codeph>y</codeph> 属性对应于窗口高度。</p>
      
      <p>
      对于通过 <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> 代码和通过操作系统调用的窗口大小调整操作实施 <codeph>maxSize</codeph> 限制。
      </p>
      <p>
      如果窗口的当前范围大于新的最大大小，则设置 <codeph>maxSize</codeph> 将更改窗口的范围。
      </p>
      
      <p>如果指定的宽度或高度大于允许的最大值，则会将相应的值设置为最接近的合法大小。决定宽度和高度最大值的因素包括：</p>
      
      <ul>
      
      	<li>操作系统的最大限值，即 <codeph>NativeWindow.systemMaxSize</codeph> 的值。</li>
      	<li>在 Adobe AIR 中，窗口的最大宽度和高度均为 2880 像素。</li>
      
      </ul>
      
      <p>
      <b>注意：</b>在某些操作系统（如 Mac OS X）中，即使最大化后的窗口将小于操作系统屏幕，将窗口最大化也只能使窗口扩大至 <codeph>maxSize</codeph> 值。该窗口将仍然处于最大化显示状态。
      </p>
      
      </apiDesc><example conref="NativeWindow.maxSize.1.as"> 下面的示例显示如何为窗口设置允许的最大大小。
<codeblock>
windowObj.maxSize = new Point(1040,920);
</codeblock></example><example conref="NativeWindow.maxSize.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObject.stage.nativeWindow.maxSize = new Point(800,600);
</codeblock></example><example conref="NativeWindow.maxSize.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.maxSize = new air.Point(960,960);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:maximizable:get"><apiName>maximizable</apiName><shortdesc>
	 报告用于创建此窗口的可最大化设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 报告用于创建此窗口的 <codeph>maximizable</codeph> 设置。
	  
	 <p>创建窗口后，不能更改 <codeph>maximizable</codeph> 设置。</p>
	 
	 <p>并非所有 Linux 窗口管理器都保留 <codeph>maximizable</codeph> 设置。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/maximizable"><linktext>flash.display.NativeWindowInitOptions.maximizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:menu:get"><apiName>menu</apiName><shortdesc>
      此窗口的本机菜单。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:NativeMenu</apiValueClassifier></apiValueDef><apiDesc>
      此窗口的本机菜单。 
      
      <p>在将 NativeMenu 对象分配给窗口的 <codeph>menu</codeph> 属性时，如果 <codeph>NativeWindow.supportsMenu</codeph> 为 <codeph>true</codeph>，将为窗口显示一个本机菜单，除非该窗口的 <codeph>systemChrome</codeph> 属性为 <codeph>NativeWindowSystemChrome.NONE</codeph>。</p>
      
      <p><b>注意：</b>允许在 <codeph>NativeWindow.supportsMenu</codeph> 为 <codeph>false</codeph> 或窗口的 <codeph>systemChrome</codeph> 属性为 <codeph>NativeWindowSystemChrome.NONE</codeph> 时为窗口分配菜单，但不执行任何操作。务必使用 <codeph>NativeWindow.supportsMenu</codeph> 属性来确定操作系统是否支持窗口菜单。使用其它方法（如 <codeph>Capabilities.os</codeph>）确定支持情况可能导致编程错误（如果没有考虑到某些可行的目标操作系统）。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/supportsMenu"><linktext>flash.display.NativeWindow.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minSize:get"><apiName>minSize</apiName><shortdesc>
      此窗口的最小大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Point</apiValueClassifier><apiException><apiDesc>如果分配的大小不在操作系统的最小和最大窗口大小范围之内。 
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiException><apiDesc>如果因为内容的当前权限而禁止该大小。
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果该大小为 <codeph>null</codeph> 或包含无效值。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问 <codeph>minSize</codeph> 属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的最小大小。 
       
      <p>大小限制指定为 Point 对象的坐标。点的 <codeph>x</codeph> 属性对应于窗口宽度，<codeph>y</codeph> 属性对应于窗口高度。</p>
      <p>
      如果窗口的当前范围小于新的最小大小，则设置 <codeph>minSize</codeph> 将更改窗口的范围。
      </p>
      <p>
      对于通过 <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> 代码和通过操作系统调用的窗口大小调整操作实施 <codeph>minSize</codeph> 限制。
      </p>
      <p>
      <b>注意：</b>显示的任何系统镶边的宽度和高度可能使得无法将窗口设置得与指定的最小大小一样小。 
      </p>
      
      </apiDesc><example conref="NativeWindow.minSize.1.as"> 下面的示例演示如何为窗口设置允许的最小大小：
<codeblock>
windowObj.minSize = new Point(200,80);
</codeblock></example><example conref="NativeWindow.minSize.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObject.stage.nativeWindow.minSize = new Point(120,60);
</codeblock></example><example conref="NativeWindow.minSize.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.minSize = new air.Point(80,60);
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/systemMinSize"><linktext>flash.display.NativeWindow.systemMinSize</linktext></link><link href="flash.display.xml#NativeWindow/systemMaxSize"><linktext>flash.display.NativeWindow.systemMaxSize</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:minimizable:get"><apiName>minimizable</apiName><shortdesc>
	 报告用于创建此窗口的可最小化设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 报告用于创建此窗口的 <codeph>minimizable</codeph> 设置。
	 
	 <p>创建窗口后，不能更改 <codeph>minimizable</codeph> 设置。</p>
	 
	 <p>并非所有 Linux 窗口管理器都保留 <codeph>minimizable</codeph> 设置。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/minimizable"><linktext>flash.display.NativeWindowInitOptions.minimizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:resizable:get"><apiName>resizable</apiName><shortdesc>
	 报告用于创建此窗口的可调整大小设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 报告用于创建此窗口的 <codeph>resizable</codeph> 设置。
	 
	 <p>创建窗口后，不能更改 <codeph>resizable</codeph> 设置。</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/resizable"><linktext>flash.display.NativeWindowInitOptions.resizable</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:stage:get"><apiName>stage</apiName><shortdesc>
      此窗口的 Stage 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Stage</apiValueClassifier></apiValueDef><apiDesc>
      此窗口的 Stage 对象。<ph platform="actionscript">Stage 对象是基于 ActionScript 3.0 的 SWF 内容中使用的显示列表体系结构中的根对象。</ph>
      
      <p>
      舞台是窗口显示列表的根。通过将可视显示对象添加到舞台或添加到此舞台的显示列表中已有的另一个对象来将可视显示对象添加到窗口。舞台尺寸是在窗口使用系统镶边时窗口客户端区域的尺寸。如果不使用系统镶边，舞台尺寸等于窗口尺寸。
      </p>
      
      <p platform="javascript">呈现 HTML 内容的 HTMLLoader 是显示列表树上的一个叶。由 ActionScript 定义的显示对象可以按绘制顺序位于 HTMLLoader 之上，也可以位于其下，但不能位于由 HTMLLoader 呈现的可视元素之间。</p>
      
      </apiDesc><example conref="NativeWindow.stage.1.as"> 下面的示例显示如何为 NativeWindow 实例设置舞台属性：
<codeblock>
import flash.display.StageAlign;

windowObj.stage.align = StageAlign.TOP_LEFT;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage"><linktext>flash.display.Stage</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsMenu:get"><apiName>supportsMenu</apiName><shortdesc> 
      指示 AIR 是否在当前计算机系统上支持本机窗口菜单。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      指示 AIR 是否在当前计算机系统上支持本机窗口菜单。
      
      <p>如果 <codeph>NativeWindow.supportsMenu</codeph> 为 <codeph>true</codeph>，则在将 NativeMenu 对象分配给窗口的 <codeph>menu</codeph> 属性时，将为该窗口显示本机菜单（除非该窗口的 <codeph>systemChrome</codeph> 属性为 <codeph>NativeWindowSystemChrome.NONE</codeph>）。务必使用 <codeph>NativeWindow.supportsMenu</codeph> 属性来确定操作系统是否支持本机窗口菜单。使用其它方法（如 <codeph>Capabilities.os</codeph>）确定支持情况可能导致编程错误（如果没有考虑到某些可行的目标操作系统）。</p>
      
      <p><b>注意：</b>允许在 <codeph>NativeWindow.supportsMenu</codeph> 为 <codeph>false</codeph> 或窗口的 <codeph>systemChrome</codeph> 属性为 <codeph>NativeWindowSystemChrome.NONE</codeph> 时为窗口分配菜单，但不执行任何操作。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeMenu"><linktext>flash.display.NativeMenu</linktext></link><link href="flash.desktop.xml#NativeApplication/supportsMenu"><linktext>flash.desktop.NativeApplication.supportsMenu</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsNotification:get"><apiName>supportsNotification</apiName><shortdesc> 
      指示 AIR 是否在当前计算机系统上支持窗口通知提示。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      指示 AIR 是否在当前计算机系统上支持窗口通知提示。
      
      <p>如果 <codeph>NativeWindow.supportsNotification</codeph> 为 <codeph>true</codeph>，则调用该窗口的 <codeph>notifyUser()</codeph> 方法将向用户显示一个可视提示，提示用户发生了需要关注的事件。此可视提示将遵循本机系统的操作系统约定。例如在 Windows<sup>®</sup>中，任务栏图标将闪烁。</p>
      
      <p><b>注意：</b>允许在 <codeph>NativeWindow.supportsNotification</codeph> 为 <codeph>false</codeph> 时调用 <codeph>notifyUser()</codeph>，但不执行任何操作。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/notifyUser()"><linktext>flash.display.NativeWindow.notifyUser()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:supportsTransparency:get"><apiName>supportsTransparency</apiName><shortdesc> 
      指示 AIR 是否支持使用透明像素的本机窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc> 
      指示 AIR 是否支持使用透明像素的本机窗口。
      
      <p>当 <codeph>NativeWindow.supportsTransparency</codeph> 为 <codeph>true</codeph>，若窗口 <codeph>transparent</codeph> 属性设为 <codeph>true</codeph>，将保留本机窗口的像素的透明度。若 <codeph>NativeWindow.supportsTransparency</codeph> 为 <codeph>false</codeph>，则无论窗口 <codeph>transparent</codeph> 属性为何值，所有像素的不透明度都将设为 1。当 <codeph>NativeWindow.supportsTransparency</codeph> 为 <codeph>false</codeph> 时，完全透明的像素将呈现为黑色。务必使用 <codeph>NativeWindow.supportsTransparency</codeph> 属性来确定操作系统是否支持透明度。使用其它方法（如 <codeph>Capabilities.os</codeph>）确定支持情况可能导致编程错误（如果没有考虑到某些可行的目标操作系统）。</p>
      
      <p><b>注意：</b>根据为操作系统设置的用户首选项的不同，在应用程序运行过程中，此属性的值可能会发生变化。</p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/transparent"><linktext>flash.display.NativeWindow.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
	 报告用于创建此窗口的系统镶边设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 报告用于创建此窗口的系统镶边设置。
	 
	 <p>由 <codeph>NativeWindow.systemChrome</codeph> 返回的值将是在 NativeWindowSystemChrome 类中定义的常量之一。</p>
	 
	 <p>创建窗口后，不能更改系统镶边设置。</p>
	 
	 </apiDesc><example conref="NativeWindow.systemChrome.1.as"> 以下示例说明了如何获得窗口的系统镶边类型：
<codeblock>
var sysChromeType:String = windowObj.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
var sysChromeType:String = displayObject.stage.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
var sysChromeType = window.nativeWindow.systemChrome;
</codeblock></example><example conref="NativeWindow.systemChrome.4.as"> 下面的示例显示如何通过创建一个新窗口并将所有子级显示对象移动到该新窗口来更改系统外观镶边和透明度设置：
<codeblock>
import flash.display.NativeWindow;
import flash.display.NativeWindowSystemChrome;
import flash.display.NativeWindowInitOptions;

public function deChromeWindow(oldWindow:NativeWindow):NativeWindow{
    if(oldWindow.systemChrome != NativeWindowSystemChrome.NONE){
        var newOptions:NativeWindowInitOptions = new NativeWindowInitOptions();
        newOptions.systemChrome = NativeWindowSystemChrome.NONE;
        newOptions.transparent = true;
        
        var newWindow:NativeWindow = new NativeWindow(newOptions);
        newWindow.stage.stageWidth = oldWindow.stage.stageWidth;
        newWindow.stage.stageHeight = oldWindow.stage.stageHeight;
        newWindow.stage.align = oldWindow.stage.align;
        newWindow.stage.scaleMode = oldWindow.stage.scaleMode;
        
        for(var i:int = 0; i &lt; oldWindow.stage.numChildren; i++){
            newWindow.stage.addChild(oldWindow.stage.getChildAt(i));
        }
        newWindow.activate();
        oldWindow.close();
        
        return newWindow;
    }
    return oldWindow;
}

</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/systemChrome"><linktext>flash.display.NativeWindowInitOptions.systemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:systemMaxSize:get"><apiName>systemMaxSize</apiName><shortdesc>
	 操作系统允许的最大窗口大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 操作系统允许的最大窗口大小。
	 
      <p>大小限制指定为 Point 对象的坐标。点的 <codeph>x</codeph> 属性对应于窗口宽度，<codeph>y</codeph> 属性对应于窗口高度。</p>
      
      <p>除了操作系统的大小限值外，AIR 也有最大窗口大小限值：2880 x 2880 像素。此外，应用程序可以使用 NativeWindow 对象的 <codeph>maxSize</codeph> 属性来设置限值。</p>
	 
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:systemMinSize:get"><apiName>systemMinSize</apiName><shortdesc>
	 操作系统允许的最小窗口大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Point</apiValueClassifier></apiValueDef><apiDesc>
	 操作系统允许的最小窗口大小。
	 
      <p>大小限制指定为 Point 对象的坐标。点的 <codeph>x</codeph> 属性对应于窗口宽度，<codeph>y</codeph> 属性对应于窗口高度。</p>
      
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:title:set"><apiName>title</apiName><shortdesc>
      窗口标题。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Low-privilege apps will probably have a string appended to all of their title strings
      
      </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>如果在关闭此窗口后访问该属性。
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      窗口标题。  
      <p>
      该标题将出现在该窗口的系统镶边中（如果显示系统镶边），也会出现在与系统相关的其它位置（如任务栏）。
      </p>
      
      </apiDesc><example conref="NativeWindow.title.1.as"> 下面的示例设置窗口对象的标题：
<codeblock>
windowObj.title = "Window Title";
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindow:transparent:get"><apiName>transparent</apiName><shortdesc>
	 报告用于创建此窗口的透明度设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 报告用于创建此窗口的透明度设置。
	 
     <p>创建窗口后，不能更改 <codeph>transparent</codeph> 属性。透明度影响窗口的视觉外观和鼠标行为。在 Windows 和 Mac OS X 中，当像素的 Alpha 值低于特定的阈值（大约在 .06 和 .01 之间变化，具体取决于操作系统）时，窗口将无法捕获鼠标事件。在 Linux 中，窗口将捕获完全透明区域上方的鼠标事件，从而阻止用户访问桌面上的其它窗口和项目。</p>
     
     <p><b>注意：</b>并不总是支持窗口透明度。如果用户的操作系统配置不提供透明度，则创建窗口时将不含透明度。原本要透明的区域将混合为黑色。请使用 <codeph>NativeWindow.supportsTransparency</codeph> 属性确定是否支持窗口透明度。</p>
	 
	 </apiDesc><example conref="NativeWindow.transparent.1.as"/><example conref="NativeWindow.transparent.2.as"/><example conref="NativeWindow.transparent.3.as"/></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowInitOptions/transparent"><linktext>flash.display.NativeWindowInitOptions.transparent</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:type:get"><apiName>type</apiName><shortdesc>
	 报告用于创建此窗口的窗口类型设置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
     
     </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 报告用于创建此窗口的窗口 <codeph>type</codeph> 设置。
	 
	 <p>由 <codeph>NativeWindow.type</codeph> 返回的值将是在 NativeWindowType 类中定义的常量之一。</p>
	 
	 <p>创建窗口后，不能更改 <codeph>type</codeph> 设置。</p>
	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowInitOptions/type"><linktext>flash.display.NativeWindowInitOptions.type</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:visible:get"><apiName>visible</apiName><shortdesc> 
      指定此窗口是否可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>在没有足够权限的情况下尝试设置为 <codeph>false</codeph> 时。
      </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc> 
      指定此窗口是否可见。  
      
      <p>
      不可见窗口不显示在桌面上，但所有窗口属性和方法都是有效的。
      </p> 
      <p>
      在默认情况下，<codeph>visible</codeph> 设置为 <codeph>false</codeph>。要显示窗口，请将 <codeph>visible</codeph> 设置为 <codeph>true</codeph> 或调用 <codeph>NativeWindow.activate()</codeph>。
      </p>
      <p>
      <b>注意：</b>在 Mac OS X 中，对一个最小化的窗口设置 <codeph>visible=false</codeph> 不会从停靠处删除该窗口图标。如果用户随后单击该停靠图标，该窗口将返回可见状态并显示在桌面上。
      </p>
      
      </apiDesc><example conref="NativeWindow.visible.1.as"> 下列示例演示如何访问窗口的 <codeph>visible</codeph> 属性：
<codeblock>
windowObj.visible = true;
</codeblock></example><example conref="NativeWindow.visible.2.as"> 使用对窗口舞台上的显示对象的引用：
<codeblock>
displayObj.stage.nativeWindow.visible = true;
</codeblock></example><example conref="NativeWindow.visible.3.as"> 从窗口（或 HTML 根窗口）的 HTMLLoader 对象中运行的 JavaScript 例程：
<codeblock>
window.nativeWindow.visible = true;
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/activate()"><linktext>activate()</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:width:get"><apiName>width</apiName><shortdesc>
      此窗口的宽度（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>如果设置的值为 <codeph>null</codeph> 或无效。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的宽度（以像素为单位）。
      
      <p>为本机窗口报告的尺寸包括显示的任何系统窗口镶边。可以从 <codeph>Stage.stageWidth</codeph> 属性获取窗口内部可用的显示区域宽度。</p>
      
      <p>更改窗口的 <codeph>width</codeph> 属性等效于通过 <codeph>bounds</codeph> 属性更改宽度。</p>
      
      <p>如果指定宽度小于允许的最小值或大于允许的最大值，则会将窗口宽度设置为最接近的合法大小。决定宽度的最小值和最大值的因素包括以下这些：</p>
      
      <ul>
      
      	<li>NativeWindow 对象的 <codeph>minSize.y</codeph> 属性和 <codeph>maxSize.y</codeph> 属性</li>
      	<li>操作系统的最小限值和最大限值，即 <codeph>NativeWindow.systemMinSize.y</codeph> 和 <codeph>NativeWindow.systemMaxSize.y</codeph> 的值。</li>
      	<li>在 Adobe AIR 中，窗口的最大宽度为 2880 像素。</li>
      
      </ul>
      
      <p>在 Linux 上，设置 <codeph>width</codeph> 属性是一种异步操作。</p>
      
      <p>
      要检测宽度更改是否完成，请侦听 <codeph>resize</codeph> 事件，所有平台上都会分派该事件。
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Stage/stageWidth"><linktext>flash.display.Stage.stageWidth</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:x:get"><apiName>x</apiName><shortdesc>
      此窗口的左上角相对于操作系统桌面原点的水平轴坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>如果设置的值为 <codeph>null</codeph> 或无效。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的左上角相对于操作系统桌面原点的水平轴坐标。
      
      <p>在安装了多个显示器的系统中，<codeph>x</codeph> 可能为负。如果保存该值可能是为了将窗口重新定位在上次的位置，则应始终验证在还原位置时是否将窗口放置到可用的位置。更改屏幕分辨率或显示器布置可能会导致窗口被置于屏幕以外。使用 Screen 类可获取有关桌面几何形状的信息。</p> 
      
      <p>更改窗口的 <codeph>x</codeph> 属性等效于通过 <codeph>bounds</codeph> 属性更改位置。</p>
      
      <p>在 Linux 上，设置 <codeph>x</codeph> 属性是一种异步操作。</p>
      
      <p>
      要检测位置更改是否完成，请侦听 <codeph>move</codeph> 事件，所有平台上都会分派该事件。
      </p>
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindow:y:get"><apiName>y</apiName><shortdesc>
      此窗口的左上角相对于操作系统桌面左上角的垂直轴坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>如果设置的值为 <codeph>null</codeph> 或无效。
      </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>如果在关闭此窗口后访问该属性。
      
      </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
      此窗口的左上角相对于操作系统桌面左上角的垂直轴坐标。
      
      <p>在安装了多个显示器的系统中，<codeph>y</codeph> 可能为负。如果保存该值可能是为了将窗口重新定位在上次的位置，则应始终验证在还原位置时是否将窗口放置到可用的位置。更改屏幕分辨率或显示器布置可能会导致窗口被置于屏幕以外。使用 Screen 类可获取有关桌面几何形状的信息。</p> 
      
      <p>更改窗口的 <codeph>y</codeph> 属性等效于通过 <codeph>bounds</codeph> 属性更改位置。</p>
      
      <p>在 Linux 上，设置 <codeph>y</codeph> 属性是一种异步操作。</p>
       
      <p>
      要检测位置更改是否完成，请侦听 <codeph>move</codeph> 事件，所有平台上都会分派该事件。
      </p>
     
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link><link href="flash.display.xml#Screen"><linktext>flash.display.Screen</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Stage"><apiName>Stage</apiName><shortdesc>
 Stage 类代表主绘图区。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObjectContainer</apiBaseClassifier></apiClassifierDef><apiDesc>
 Stage 类代表主绘图区。 
 
 <p platform="actionscript">对于在浏览器中（使用 Flash<sup>®</sup> Player）运行的 SWF 内容，Stage 表示显示 Flash 内容的整个区域。对于在 AIR 中运行的内容，每个 NativeWindow 对象都有一个相应的 Stage 对象。</p>
 
 <p platform="actionscript">无法以全局方式访问 Stage 对象。而是需要利用 DisplayObject 实例的 <codeph>stage</codeph> 属性进行访问。</p> 
 
 <p platform="actionscript">Stage 类具有多个始祖类 -- DisplayObjectContainer、InteractiveObject、DisplayObject 和 EventDispatcher，属性和方法便是从这些类继承而来的。从这些继承的许多属性和方法不适用于 Stage 对象，或在调用 Stage 类时需要安全检查。需要安全检查的属性和方法被记录为 Stage 类的一部分。</p>
 
 <p platform="actionscript">此外，下面的继承属性不适用于 Stage 对象。如果尝试设置这些属性，便会引发 IllegalOperationError。这些属性通常可以读取，但是由于无法进行设置，所以它们将始终包含默认值。</p>
 
 <ul platform="actionscript">
 <li><codeph>accessibilityProperties</codeph></li>
 <li><codeph>alpha</codeph></li>
 <li><codeph>blendMode</codeph></li>
 <li><codeph>cacheAsBitmap</codeph></li>
 <li><codeph>contextMenu</codeph></li>
 <li><codeph>filters</codeph></li>
 <li><codeph>focusRect</codeph></li>
 <li><codeph>loaderInfo</codeph></li>
 <li><codeph>mask</codeph></li>
 <li><codeph>mouseEnabled</codeph></li>
 <li><codeph>name</codeph></li>
 <li><codeph>opaqueBackground</codeph></li>
 <li><codeph>rotation</codeph></li>
 <li><codeph>scale9Grid</codeph></li>
 <li><codeph>scaleX</codeph></li>
 <li><codeph>scaleY</codeph></li>
 <li><codeph>scrollRect</codeph></li>
 <li><codeph>tabEnabled</codeph></li>
 <li><codeph>tabIndex</codeph></li>
 <li><codeph>transform</codeph></li>
 <li><codeph>visible</codeph></li>
 <li><codeph>x</codeph></li>
 <li><codeph>y</codeph></li>
 </ul>
 
 <p>一些您可能期望成为 Stage 类的一部分的事件（例如 <codeph>enterFrame</codeph>、<codeph>exitFrame</codeph>、<codeph>frameConstructed</codeph> 和 <codeph>render</codeph>）不能是 Stage 事件，因为不能保证在使用这些事件的每种情况下对 Stage 对象的引用都会存在。由于这些事件无法由 Stage 对象进行分派，而是由每个 DisplayObject 实例分派，因此这就意味着您可以向任何 DisplayObject 实例添加事件侦听器来侦听这些事件。这些事件（DisplayObject 类的一部分）称为广播事件，以使其与针对特定 DisplayObject 实例的事件区分开。其它两个广播事件 <codeph>activate</codeph> 和 <codeph>deactivate</codeph> 属于 DisplayObject 的超类 EventDispatcher。<codeph>activate</codeph> 和 <codeph>deactivate</codeph> 事件的行为与 DisplayObject 广播事件类似，不过，这两个事件不仅可由所有 DisplayObject 实例进行分派，还可由所有 EventDispatcher 实例和其它的 EventDispatcher 子类实例进行分派。有关广播事件的详细信息，请参阅 DisplayObject 类。</p>
 
 </apiDesc><example conref="examples\StageExample.as"> 下例使用 <codeph>StageExample</codeph> 类在激活舞台或调整舞台大小时分派事件。执行下列步骤可完成此操作：
 <ol>
  <li>无论 Flash Player 窗口的大小如何，类的构造函数都会首先将 Flash 应用程序设置为固定大小，然后使用 <codeph>activateHandler()</codeph> 和 <codeph>resizeHandler()</codeph> 方法添加两个事件侦听器。</li>
 
  <li>用鼠标左键单击后，便可运行 <codeph>activateHandler()</codeph> 方法。</li>
 
  <li>当调整舞台大小时，便可运行 <codeph>resizeHandler()</codeph> 方法。</li>
 
 </ol>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.events.Event;

    public class StageExample extends Sprite {

        public function StageExample() {
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.addEventListener(Event.ACTIVATE, activateHandler);
            stage.addEventListener(Event.RESIZE, resizeHandler);
        }

        private function activateHandler(event:Event):void {
            trace("activateHandler: " + event);
        }

        private function resizeHandler(event:Event):void {
            trace("resizeHandler: " + event);
            trace("stageWidth: " + stage.stageWidth + " stageHeight: " + stage.stageHeight);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links><adobeApiEvent id="flash.display:Stage_flash.events.FullScreenEvent.FULL_SCREEN_fullScreen"><apiName>fullScreen</apiName><shortdesc>
 当 Stage 对象进入或离开全屏模式时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FullScreenEvent.FULL_SCREEN</apiEventType><adobeApiEventClassifier>flash.events.FullScreenEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当 Stage 对象进入或离开全屏模式时分派。可以通过 ActionScript、或用户调用键盘快捷键或者当前焦点离开全屏窗口来启动全屏模式的更改。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
 当 Stage 对象的 scaleMode 属性设置为 StageScaleMode.NO_SCALE 且 SWF 文件大小经过重新调整时进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当 Stage 对象的 <codeph>scaleMode</codeph> 属性设置为 <codeph>StageScaleMode.NO_SCALE</codeph> 且 SWF 文件大小经过重新调整时进行分派。 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.display:Stage_flash.events.Event.MOUSE_LEAVE_mouseLeave"><apiName>mouseLeave</apiName><shortdesc>
 当鼠标指针移出舞台区域时由 Stage 对象进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.MOUSE_LEAVE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当鼠标指针移出舞台区域时由 Stage 对象进行分派。如果按下鼠标按钮，则不分派此事件。
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="flash.display:Stage:addChild"><apiName>addChild</apiName><shortdesc>
	 
     将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>addChild()</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>在 <codeph>child</codeph> 参数中传递的 DisplayObject 实例。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
     将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。子项将被添加到该 DisplayObjectContainer 实例中其它所有子项的前（上）面。（要将某子项添加到特定索引位置，请使用 <codeph>addChildAt()</codeph> 方法。）
     
	 <p>如果添加一个已将其它显示对象容器作为父项的子对象，则会从其它显示对象容器的子列表中删除该对象。 </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addChildAt"><apiName>addChildAt</apiName><shortdesc>
	 
	 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>addChildAt()</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>在 <codeph>child</codeph> 参数中传递的 DisplayObject 实例。
	 
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要作为该 DisplayObjectContainer 实例的子项添加的 DisplayObject 实例。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>添加该子项的索引位置。  如果指定当前占用的索引位置，则该位置以及所有更高位置上的子对象会在子级列表中上移一个位置。 
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 将一个 DisplayObject 子实例添加到该 DisplayObjectContainer 实例中。该子项将被添加到指定的索引位置。索引为 0 表示该 DisplayObjectContainer 对象的显示列表的后（底）部。
	 
	 <p>例如，下例在索引位置 0、2、1 处分别显示 a、b、c 三个显示对象：</p>
	 
	 <p><adobeimage alt="b 在 c 之上，c 在 a 之上" href="../../images/DisplayObjectContainer_layers.jpg"/></p>
	 
	 <p>如果添加一个已将其它显示对象容器作为父项的子对象，则会从其它显示对象容器的子列表中删除该对象。 </p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:addEventListener"><apiName>addEventListener</apiName><shortdesc>
	 
	使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>addEventListener</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>事件的类型。
	
	</apiDesc></apiParam><apiParam><apiItemName>listener</apiItemName><apiOperationClassifier>Function</apiOperationClassifier><apiDesc>处理事件的侦听器函数。此函数必须接受 Event 对象作为其唯一的参数，并且不能返回任何结果<ph platform="actionscript">，如下面的示例所示：</ph> <ph platform="javascript">。</ph>
	
    <codeblock platform="actionscript">function(evt:Event):void</codeblock>
	
	<p>函数可以有任何名称。</p>
	
	</apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc><ph platform="javascript">此参数适用于 SWF 内容所使用的 ActionScript 3.0 显示列表体系结构中的显示对象。</ph><ph platform="actionscript">确定侦听器是运行于捕获阶段还是目标阶段和冒泡阶段。如果将 <codeph>useCapture</codeph> 设置为 <codeph>true</codeph>，则侦听器只在捕获阶段处理事件，而不在目标或冒泡阶段处理事件。如果 <codeph>useCapture</codeph> 为 <codeph>false</codeph>，则侦听器只在目标或冒泡阶段处理事件。要在所有三个阶段都侦听事件，请调用 <codeph>addEventListener</codeph> 两次：一次将 <codeph>useCapture</codeph> 设置为 <codeph>true</codeph>，一次将 <codeph>useCapture</codeph> 设置为 <codeph>false</codeph>。</ph>
	
	</apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>事件侦听器的优先级。优先级由一个带符号的 32 位整数指定。数字越大，优先级越高。优先级为 <i>n</i> 的所有侦听器会在优先级为 <i>n</i> -1 的侦听器之前得到处理。如果两个或更多个侦听器共享相同的优先级，则按照它们的添加顺序进行处理。默认优先级为 0。
	
	</apiDesc></apiParam><apiParam><apiItemName>useWeakReference</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>确定对侦听器的引用是强引用，还是弱引用。强引用（默认值）可防止您的侦听器被当作垃圾回收。弱引用则没有此作用。 <p>类级别成员函数不属于垃圾回收的对象，因此可以对类级别成员函数将 <codeph>useWeakReference</codeph> 设置为 <codeph>true</codeph> 而不会使它们受垃圾回收的影响。如果对作为嵌套内部函数的侦听器将 <codeph>useWeakReference</codeph> 设置为 <codeph>true</codeph>，则该函数将作为垃圾回收并且不再是永久函数。如果创建对该内部函数的引用（将该函数保存到另一个变量中），则该函数将不作为垃圾回收并仍将保持永久。</p>
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	使用 EventDispatcher 对象注册事件侦听器对象，以使侦听器能够接收事件通知。<ph platform="actionscript">可以为特定类型的事件、阶段和优先级在显示列表中的所有节点上注册事件侦听器。</ph>
	
	<p platform="javascript">AIR 运行时中的 JavaScript 代码使用此方法注册 AIR API 定义的事件的事件侦听器。对于其它 JavaScript 事件（如 DOM <codeph>body</codeph> 对象的 <codeph>onload</codeph> 事件），您可以像对浏览器中运行的内容一样使用标准事件处理技术。</p>
	
	<p>成功注册一个事件侦听器后，无法通过额外调用 <codeph>addEventListener()</codeph> 来更改其优先级。要更改侦听器的优先级，必须首先调用 <codeph>removeListener()</codeph>。然后，可以使用新的优先级再次注册该侦听器。 </p>
	
	<p>请记住，注册该侦听器后，如果继续调用具有不同 <codeph>type</codeph> 或 <codeph>useCapture</codeph> 值的 <codeph>addEventListener()</codeph>，则会创建单独的侦听器注册。<ph platform="actionscript">例如，如果首先注册 <codeph>useCapture</codeph> 设置为 <codeph>true</codeph> 的侦听器，则该侦听器只在捕获阶段进行侦听。如果使用同一个侦听器对象再次调用 <codeph>addEventListener()</codeph>，并将 <codeph>useCapture</codeph> 设置为 <codeph>false</codeph>，那么便会拥有两个单独的侦听器：一个在捕获阶段进行侦听，另一个在目标和冒泡阶段进行侦听。</ph>
	</p>
	
	<p platform="actionscript">不能只为目标阶段或冒泡阶段注册事件侦听器。这些阶段在注册期间是成对出现的，因为冒泡阶段只适用于目标节点的始祖。</p>
	
	<p>如果不再需要某个事件侦听器，可调用 <codeph>removeEventListener()</codeph> 删除它，否则会产生内存问题。事件侦听器不会自动从内存中删除，因为只要调度对象存在，垃圾回收器就不会删除侦听器（除非 <codeph>useWeakReference</codeph> 参数设置为 <codeph>true</codeph>）。</p>
		
	<p>复制 EventDispatcher 实例时并不复制其中附加的事件侦听器。（如果新近创建的节点需要一个事件侦听器，必须在创建该节点后附加该侦听器。）但是，如果移动 EventDispatcher 实例，则其中附加的事件侦听器也会随之移动。</p>
	
	
	<p platform="actionscript">如果在正在处理事件的节点上注册事件侦听器，则不会在当前阶段触发事件侦听器，但会在事件流的稍后阶段触发，如冒泡阶段。</p>
	
	<p platform="actionscript">如果从正在处理事件的节点中删除事件侦听器，则该事件侦听器仍由当前操作触发。删除事件侦听器后，决不会再次调用该事件侦听器（除非再次注册以备将来处理）。 </p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	 将键盘焦点设置为由 objectToFocus 指定的交互式对象，焦点方向由 direction 参数指定。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果无法将焦点设置到目标或 direction 不是有效的类型。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>objectToFocus</apiItemName><apiOperationClassifier>flash.display:InteractiveObject</apiOperationClassifier><apiDesc>要设置焦点的对象；如果要从舞台上任何元素中清除焦点，则为 <codeph>null</codeph>。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>direction</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>对 <codeph>objectToFocus</codeph> 设置焦点所使用的方向。有效值枚举为 FocusDirection 类中的常量。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>将键盘焦点分配给一个交互式对象并指定焦点的来自方向。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 将键盘焦点设置为由 <codeph>objectToFocus</codeph> 指定的交互式对象，焦点方向由 <codeph>direction</codeph> 参数指定。 
	 
	 <p>焦点方向的概念必须由应用程序（或应用程序框架）来定义。虽然可以使用其它可用的属性来确定排序原则，但交互式对象并不存在固有的焦点排序。例如，您可以按照交互式对象在舞台上或在显示列表中的位置对这些对象进行排序。调用 <codeph>assignFocus()</codeph> 等效于设置 <codeph>Stage.focus</codeph> 属性，但它还具有另外的功能，可以指示设置焦点时所使用的方向。</p>
	 
	 <p>在接收焦点时，<codeph>objectToFocus</codeph> 将分派 <codeph>focusIn</codeph> 事件。FocusEvent 对象的 <codeph>direction</codeph> 属性将报告 <codeph>direction</codeph> 参数的设置。</p>
	 
	 <p>如果将 HTMLLoader 对象赋予 <codeph>objectToFocus</codeph> 参数，则 HTMLLoader 对象会根据 <codeph>direction</codeph> 参数值在 HTML DOM 中选择适当的可获得焦点对象。如果该参数值为 <codeph>FocusDirection.BOTTOM</codeph>，则 HTML DOM 中位于读取顺序末尾的可获得焦点对象将获得焦点。如果该参数值为 <codeph>FocusDirection.TOP</codeph>，则 HTML DOM 中位于读取顺序开头的可获得焦点对象将获得焦点。如果该参数值为 <codeph>NONE</codeph>，则 HTMLLoader 对象会在不更改其当前已设置焦点元素的情况下获得焦点。</p>
	 
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#Stage/focus"><linktext>flash.display.Stage.focus</linktext></link><link href="flash.display.xml#FocusDirection"><linktext>flash.display.FocusDirection</linktext></link><link href="flash.events.xml#FocusEvent"><linktext>flash.events.FocusEvent</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:dispatchEvent"><apiName>dispatchEvent</apiName><shortdesc>
	 
	将事件分派到事件流中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>dispatchEvent()</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果成功分派了事件，则值为 <codeph>true</codeph>。值 <codeph>false</codeph> 表示失败或对事件调用了 <codeph>preventDefault()</codeph>。
	
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>event</apiItemName><apiOperationClassifier>flash.events:Event</apiOperationClassifier><apiDesc>分派到事件流中的 Event 对象。如果正在重新分派事件，则会自动创建此事件的一个克隆。  在分派了事件后，其 <codeph>target</codeph> 属性将无法更改，因此您必须创建此事件的一个新副本以能够重新分派。
	
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	将事件分派到事件流中。事件目标是对其调用 <codeph>dispatchEvent()</codeph> 方法的 EventDispatcher 对象。
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:hasEventListener"><apiName>hasEventListener</apiName><shortdesc>
	 
	检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>hasEventListener()</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果指定类型的侦听器已注册，则值为 <codeph>true</codeph>；否则，值为 <codeph>false</codeph>。
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>事件的类型。
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。这样，您就可以确定 EventDispatcher 对象在事件流层次结构中的哪个位置改变了对事件类型的处理。要确定特定事件类型是否确实触发了事件侦听器，请使用 <codeph>willTrigger()</codeph>。
	
	<p><codeph>hasEventListener()</codeph> 与 <codeph>willTrigger()</codeph> 的区别是：<codeph>hasEventListener()</codeph> 只检查它所属的对象，而 <codeph>willTrigger()</codeph> 检查整个事件流以查找由 <codeph>type</codeph> 参数指定的事件。<ph platform="javascript">事件流适用于 SWF 内容中使用的 ActionScript 3.0 显示列表。</ph>
	</p>
	
	<p>当从 LoaderInfo 对象调用 <codeph>hasEventListener()</codeph> 时，只考虑调用方可以访问的侦听器。</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:invalidate"><apiName>invalidate</apiName><shortdesc>
     调用 invalidate() 方法，以便在出现下一个 Flash Player 必须呈现显示列表的时机（例如，当播放头前进到一个新帧）时，向其发出提醒显示对象的信号。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiTipTexts><apiTipText>在下一次 Flash Player 必须刷新舞台时，向其发送更新显示对象属性的信号。
     
     </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
     调用 <codeph>invalidate()</codeph> 方法，以便在出现下一个 Flash Player 必须呈现显示列表的时机（例如，当播放头前进到一个新帧）时，向其发出提醒显示对象的信号。调用 <codeph>invalidate()</codeph> 方法后，在显示列表下次呈现时，Flash Player 会向每个已注册侦听 <codeph>render</codeph> 事件的显示对象发送一个 <codeph>render</codeph> 事件。每次想让 Flash Player 发送 <codeph>render</codeph> 事件时，都必须调用 <codeph>invalidate()</codeph> 方法。 
     
     <p><codeph>render</codeph> 事件使您可以在显示列表实际呈现前对其进行更改。因此，您就可以将对显示列表的更新尽可能地向后延迟。这样可以通过消除不必要的屏幕更新来提高性能。</p>
     
     <p>只将 <codeph>render</codeph> 事件分派到与调用 <codeph>stage.invalidate()</codeph> 方法的代码位于同一安全域中的显示对象，或位于通过 <codeph>Security.allowDomain()</codeph> 方法被授予权限的安全域中的显示对象。</p>
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.events.xml#Event/RENDER"><linktext>flash.events.Event.RENDER</linktext></link></related-links></apiOperation><apiOperation id="flash.display:Stage:isFocusInaccessible"><apiName>isFocusInaccessible</apiName><shortdesc>
	 确定 Stage.focus 属性是否因某些安全原因返回 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc><codeph>true</codeph>（如果具有焦点的对象属于 SWF 文件无权访问的安全沙箱）。
	 
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>确定 <codeph>Stage.focus</codeph> 属性是否因某些安全原因返回 <codeph>null</codeph>。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 确定 <codeph>Stage.focus</codeph> 属性是否因某些安全原因返回 <codeph>null</codeph>。也就是说，如果具有焦点的对象属于 SWF 文件无权访问的安全沙箱，那么 <codeph>isFocusInaccessible</codeph> 就会返回 <codeph>true</codeph>。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:removeChildAt"><apiName>removeChildAt</apiName><shortdesc>
	 
	 从 DisplayObjectContainer 的子级列表中指定的索引位置删除子级 DisplayObject。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>removeChildAt()</codeph> 方法会因任何调用方没有与要删除的对象位于同一个安全沙箱而引发异常。为避免出现这种情况，该对象的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>已删除的 DisplayObject 实例。
	  
     </apiDesc><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要删除的 DisplayObject 的子索引。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 从 DisplayObjectContainer 的子列表中指定的 <codeph>index</codeph> 位置删除子 DisplayObject。将已删除子项的 <codeph>parent</codeph> 属性设置为 <codeph>null</codeph>；如果没有对该子项的任何其它引用，则将该对象作为垃圾回收。DisplayObjectContainer 中该子项之上的任何显示对象的索引位置都减去 1。
	 
	 <p>垃圾回收器重新分配未使用的内存空间。当在某处变量或对象不再被主动地引用或存储时，如果不存在对该变量或对象的任何其它引用，则垃圾回收器将清理并擦除其过去占用的内存空间。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:setChildIndex"><apiName>setChildIndex</apiName><shortdesc>
	 
	更改现有子项在显示对象容器中的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>setChildIndex()</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiOperationClassifier>flash.display:DisplayObject</apiOperationClassifier><apiDesc>要为其更改索引编号的 DisplayObject 子实例。
     
     </apiDesc></apiParam><apiParam><apiItemName>index</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>生成的 <codeph>child</codeph> 显示对象的索引编号。
     
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	更改现有子项在显示对象容器中的位置。这会影响子对象的分层。例如，下例在索引位置 0、1、2 处分别显示 a、b、c 三个显示对象：
	
	<p><adobeimage alt="c 在 b 之上，b 在 a 之上" href="../../images/DisplayObjectContainerSetChildIndex1.jpg"/></p>
	
	<p>在使用 <codeph>setChildIndex()</codeph> 方法并指定一个已经占用的索引位置时，唯一发生更改的位置是显示对象先前的位置和新位置之间的位置。所有其它位置将保持不变。如果将一个子项移动到比它当前的索引更低的索引处，则这两个索引之间的所有子项的索引引用都将增加 1。如果将一个子项移动到比它当前的索引更高的索引处，则这两个索引之间的所有子项的索引引用都将减小 1。例如，如果上例中的显示对象容器名为 <codeph>container</codeph>，则可以通过调用以下代码来交换带有 a 和 b 标记的显示对象的位置：</p>
	
	<codeblock>container.setChildIndex(container.getChildAt(1), 0);</codeblock>
	
	<p>该代码产生以下对象排列：</p>
	
    <p><adobeimage alt="c 在 a 之上，a 在 b 之上" href="../../images/DisplayObjectContainerSetChildIndex2.jpg"/></p>
	
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:swapChildrenAt"><apiName>swapChildrenAt</apiName><shortdesc>
	 
	 在子级列表中两个指定的索引位置，交换子对象的 z 顺序（前后顺序）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>swapChildrenAt()</codeph> 方法会因任何调用方没有与要互换的任一对象的所有者位于同一安全沙箱而引发异常。为避免出现这种情况，对象所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>index1</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>第一个子对象的索引位置。
	 
     </apiDesc></apiParam><apiParam><apiItemName>index2</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>第二个子对象的索引位置。
	 
     </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 在子级列表中两个指定的索引位置，交换子对象的 Z 轴顺序（前后顺序）。显示对象容器中所有其它子对象的索引位置保持不变。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:Stage:willTrigger"><apiName>willTrigger</apiName><shortdesc>
	 
	检查是否用此 EventDispatcher 对象或其任何始祖为指定事件类型注册了事件侦听器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiException><apiDesc>调用 Stage 对象的 <codeph>willTrigger()</codeph> 方法会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一个安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果将会触发指定类型的侦听器，则值为 <codeph>true</codeph>；否则，值为 <codeph>false</codeph>。
	</apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>type</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>事件的类型。
	</apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	检查是否用此 EventDispatcher 对象或其任何始祖为指定事件类型注册了事件侦听器。将指定类型的事件分派给此 EventDispatcher 对象或其任一后代时，如果在事件流的任何阶段触发了事件侦听器，则此方法返回 <codeph>true</codeph>。
	
	<p><codeph>hasEventListener()</codeph> 与 <codeph>willTrigger()</codeph> 方法的区别是：<codeph>hasEventListener()</codeph> 只检查它所属的对象，而 <codeph>willTrigger()</codeph> 方法检查整个事件流以查找由 <codeph>type</codeph> 参数指定的事件。<ph platform="javascript">事件流适用于 SWF 内容中使用的 ActionScript 3.0 显示列表。</ph></p>
	
	<p>当从 LoaderInfo 对象调用 <codeph>willTrigger()</codeph> 时，只考虑调用方可以访问的侦听器。</p>
	
	</apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:Stage:align:get"><apiName>align</apiName><shortdesc>
	 一个 StageAlign 类中指定舞台在 Flash Player 或浏览器中的对齐方式的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 一个 StageAlign 类中指定舞台在 Flash Player 或浏览器中的对齐方式的值。以下是有效值：
	 
	 <p>
	 <adobetable class="innertable">
	 	
	 	 
	 	 
	 	 
	 	 
	 	  
	 	  
	 	  
	 	  
	 	 
	 <tgroup cols="3"><thead><row><entry>值</entry><entry>垂直对齐方式</entry><entry>水平对齐方式</entry></row></thead><tbody><row><entry><codeph>StageAlign.TOP</codeph></entry>
	 	 <entry>顶对齐</entry>
	 	 <entry>居中对齐</entry>
	 	 </row><row><entry><codeph>StageAlign.BOTTOM</codeph></entry>
	 	 <entry>底对齐</entry>
	 	 <entry>居中对齐</entry>
	 	 </row><row><entry><codeph>StageAlign.LEFT</codeph></entry>
	 	 <entry>居中对齐</entry>
	 	 <entry>左对齐</entry>
	 	 </row><row><entry><codeph>StageAlign.RIGHT</codeph></entry>
	 	 <entry>居中对齐</entry>
	 	 <entry>右对齐</entry>
	 	 </row><row><entry><codeph>StageAlign.TOP_LEFT</codeph></entry>
	 	  <entry>顶对齐</entry>
	 	  <entry>左对齐</entry>
	 	  </row><row><entry><codeph>StageAlign.TOP_RIGHT</codeph></entry>
	 	  <entry>顶对齐</entry>
	 	  <entry>右对齐</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_LEFT</codeph></entry>
	 	  <entry>底对齐</entry>
	 	  <entry>左对齐</entry>
	 	  </row><row><entry><codeph>StageAlign.BOTTOM_RIGHT</codeph></entry>
	 	  <entry>底对齐</entry>
	 	  <entry>右对齐</entry>
	 	  </row></tbody></tgroup></adobetable>
	 </p>
	 
	 <p><codeph>align</codeph> 属性只可用于与 Stage 所有者（主 SWF 文件）位于同一安全沙箱的对象。为避免出现这种情况，Stage 所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.alowInsecureDomain()</codeph> 方法来向域的调用对象授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageAlign"><linktext>flash.display.StageAlign</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrection:get"><apiName>colorCorrection</apiName><shortdesc>
 	 控制显示效果的 Flash Player 颜色校正。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiTipTexts><apiTipText>尝试使用监视器颜色校正
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
 	 控制显示效果的 Flash Player 颜色校正。只有在为监视器分配了有效的 ICC 颜色配置文件（指定设备的特定颜色属性）时，颜色校正才起作用。默认情况下，Flash Player 尝试匹配其主机（通常是一个浏览器）的颜色校正。
     
     <p>使用 <codeph>Stage.colorCorrectionSupport</codeph> 属性可确定颜色校正在当前系统和默认状态中是否可用。如果可以使用颜色校正，则将假定舞台上的所有颜色都处于 sRGB 颜色空间，这是最标准的颜色空间。在颜色校正过程中未考虑输入设备的源配置文件。不应用输入颜色校正；只将舞台输出映射到主监视器的 ICC 颜色配置文件。</p>
      
     <p>通常，通过激活颜色管理可获得以下好处：可预知而一致的颜色、更好的转换、准确的校对以及更有效的跨媒体输出。但是请注意，由于设备相互之间或与原始图像的色域不同，因此颜色管理无法提供完美的转换。同时，尽管有颜色管理，但仍然需要自定义配置文件或编辑的配置文件。颜色配置文件取决于浏览器、操作系统 (OS)、OS 扩展、输出设备和应用程序支持。</p>
     
     <p>应用颜色校正将会降低 Flash Player 的性能。Flash Player 的颜色校正是一种文档式颜色校正，因为所有 SWF 影片都被视为带有隐式 sRGB 配置文件的文档。使用 <codeph>Stage.colorCorrectionSupport</codeph> 属性指示 Flash Player，在将 SWF（文档）显示到显示颜色空间时将颜色校正到最佳水平。Flash Player 只会补偿监视器之间的差异，而不会补偿输入设备（摄像头/扫描仪等）之间的差异。
     </p>
     
 	 <p>三个可能的值是在 flash.display.ColorCorrection 类中具有对应常数的字符串。</p>
 	  <ul><li><codeph>“default”</codeph>：使用与主机系统相同的颜色校正。</li> 
 	 <li><codeph>“on”</codeph>：始终执行颜色校正。</li>
 	 <li><codeph>“off”</codeph>：从不执行颜色校正。</li>
 	 </ul>
 	 
     </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrection"><linktext>flash.display.ColorCorrection</linktext></link><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>colorCorrectionSupport</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:colorCorrectionSupport:get"><apiName>colorCorrectionSupport</apiName><shortdesc>
      指定 Flash Player 当前所在的操作系统是否支持颜色校正，以及 Flash Player 是否能够读取和理解主监视器的颜色配置文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata><asCustoms><keyword>ColorCorrection
      </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
      指定 Flash Player 当前所在的操作系统是否支持颜色校正，以及 Flash Player 是否能够读取和理解主监视器的颜色配置文件。此属性还返回主机系统（通常是浏览器）上颜色校正的默认状态。当前返回值可能是：
 	  <p>三个可能的值是在 flash.display.ColorCorrectionSupport 类中具有对应常数的字符串。</p>
 	   <ul><li><codeph>“unsupported”</codeph>：颜色校正不可用。</li> 
 	  <li><codeph>“defaultOn”</codeph>：始终执行颜色校正。</li>
 	  <li><codeph>“defaultOff”</codeph>：从不执行颜色校正。</li>
 	  </ul>      
      
      </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ColorCorrectionSupport"><linktext>flash.display.ColorCorrectionSupport</linktext></link><link href="flash.display.xml#Stage/colorCorrection"><linktext>colorCorrection</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:displayState:get"><apiName>displayState</apiName><shortdesc>
	 用于指定要使用哪个显示状态的 StageDisplayState 类的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.28.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>displayState</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。在已显示设置对话框但用户没有响应时，尝试设置 <codeph>displayState</codeph> 属性 (property)，或者如果 <codeph>param</codeph> 或 <codeph>embed</codeph> HTML 标签的 <codeph>allowFullScreen</codeph> 属性 (attribute) 没有设置为 <codeph>true</codeph>，则引发安全错误。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 用于指定要使用哪个显示状态的 StageDisplayState 类的值。以下是有效值： 
	 
	 <ul>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN</codeph> 将 AIR 应用程序或 Flash Player 设置成扩展舞台以覆盖用户的整个屏幕（禁用键盘输入）。</li>
	 
     <li><codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> 将 AIR 应用程序设置成扩展舞台以覆盖用户的整个屏幕（允许键盘输入）。<ph platform="actionscript">（对于在 Flash Player 的内容不适用。）</ph></li>
	 
     <li><codeph>StageDisplayState.NORMAL</codeph> 将播放器设置回标准的舞台显示模式。</li>
	 
	 </ul> 
	 
     <p platform="actionscript">影片在全屏模式下的缩放行为由 <codeph>scaleMode</codeph> 设置确定（在 HTML 文件中使用 <codeph>Stage.scaleMode</codeph> 属性或 SWF 文件的 <codeph>embed</codeph> 标签设置进行设置）。如果将 <codeph>scaleMode</codeph> 属性设置为 <codeph>noScale</codeph>，则当应用程序过渡为全屏模式时，舞台的 <codeph>width</codeph> 和 <codeph>height</codeph> 属性将更新并引发舞台的 <codeph>resize</codeph> 事件。</p>
     
     <p platform="actionscript">以下限制适用于在 HTML 页内播放的 SWF 文件（而不是使用独立 Flash Player 播放的文件或不在 AIR 运行时中运行的文件）：</p>
     
     <ul platform="actionscript">
	 
	 <li>要启用全屏模式，请将 <codeph>allowFullScreen</codeph> 参数添加到包含 SWF 文件的 HTML 页中的 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签，同时将 <codeph>allowFullScreen</codeph> 设置为 <codeph>"true"</codeph>，如下例所示：
	 
	 <codeblock>&lt;param name="allowFullScreen" value="true" />
	        ...
	 &lt;embed src="example.swf" allowFullScreen="true" ... ></codeblock>
	 
	 <p>HTML 页还可以使用脚本生成 SWF 嵌入标签。您需要修改脚本，以使其插入正确的 <codeph>allowFullScreen</codeph> 设置。Flash 和 Flex Builder 生成的 HTML 页使用 <codeph>AC_FL_RunContent()</codeph> 函数嵌入对 SWF 文件的引用，并且您需要添加 <codeph>allowFullScreen</codeph> 参数设置，如下所示：</p>
	 
	 <codeblock>AC_FL_RunContent( ... "allowFullScreen", "true", ... )</codeblock></li>
	 
     <li>全屏模式是在响应用户单击鼠标或按键时初始化的；在没有用户输入的情况下，影片不能更改 <codeph>Stage.displayState</codeph>。在全屏模式下，Flash Player 会限制键盘输入。可接受的键包括用于终止全屏模式的快捷键和非打印键，例如箭头、空格、Shift 键和 Tab 键。用于终止全屏模式的快捷键包括 Escape（Windows、Linux 和 Mac）、Ctrl+W (Windows)、Command+W (Mac) 和 Alt+F4。
     <p>当用户进入全屏模式时，将在影片前面显示一个 Flash Player 对话框，告诉用户已经进入了全屏模式，并可以按 Esc 键退出全屏模式。</p></li>
     <li>从 Flash Player 9.0.115.0 开始，全屏模式在无窗口模式下的工作方式与窗口模式相同。如果将窗口模式（HTML 中的 <codeph>wmode</codeph>）设置为不透明无窗口 (<codeph>opaque</codeph>) 或透明无窗口 (<codeph>transparent</codeph>)，则可以启动全屏模式，但全屏窗口始终是不透明的。</li> 
	 
     </ul>
     
 	 <p platform="actionscript">对于在独立 Flash Player 或 AIR 中运行的 SWF 内容，<i>不</i>存在这些限制。AIR 支持允许键盘输入的交互式全屏模式。</p>  
	 
	 <p>对于以全屏模式运行的 <ph platform="actionscript">AIR</ph> 内容，在播放视频内容时，将禁用系统屏幕保护程序和节能选项，直到该视频停止或退出全屏幕模式。</p>
 	 
	 <p>在 Linux 上，将 <codeph>displayState</codeph> 设置为 <codeph>StageDisplayState.FULL_SCREEN</codeph> 或 <codeph>StageDisplayState.FULL_SCREEN_INTERACTIVE</codeph> 是一种异步操作。</p>
    
	 </apiDesc><example conref="examples\StageExample2.as"> 下例以一种交互的方式演示如何通过修改 <codeph>displayState</codeph> 属性创造全屏体验。 <p><b>注意</b>：出于安全方面的限制，只有在某些情况下才能触发全屏，例如，如果用户单击了鼠标或按了键盘键。在浏览器中运行时，allowFullScreen 属性必须设置为 true。</p>
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.Stage;
    import flash.events.*;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.media.Video;
    
    public class FullScreenExample extends Sprite
    {
        private var videoURL:String = "testVideo.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var video:Video;        
        
        public function FullScreenExample() {
            connection = new NetConnection();
            connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);
            
            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK,toggleFullScreen);
        }        
        
        private function toggleFullScreen(event:MouseEvent):void {
            switch(stage.displayState) {
                case "normal":
                    stage.displayState = "fullScreen";    
                    break;
                case "fullScreen":
                default:
                    stage.displayState = "normal";    
                    break;
            }
        }    
        
        // Video related:
        private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace("Unable to locate video: " + videoURL);
                    break;
            }
        }
        private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);

            video = new Video(stage.stageWidth,stage.stageHeight);
            video.attachNetStream(stream);
            stream.play(videoURL);
            addChild(video);
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);
        }
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            // ignore AsyncErrorEvent events.
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:focus:get"><apiName>focus</apiName><shortdesc>
	 具有键盘焦点的交互式对象；如果没有设置焦点，或者具有焦点的对象属于调用对象无权访问的安全沙箱，则为 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:InteractiveObject</apiValueClassifier><apiException><apiDesc>如果不能将焦点设置到目标，则会引发错误。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiTipTexts><apiTipText>具有键盘焦点的对象。
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 具有键盘焦点的交互式对象；如果没有设置焦点，或者具有焦点的对象属于调用对象无权访问的安全沙箱，则为 <codeph>null</codeph>。
	 
	 </apiDesc><example conref="Stage.focus.as"> <codeph/>
<codeblock>
var myTF:TextField = new TextField();
myTF.border =true;
myTF.type = TextFieldType.INPUT;

addChild(myTF);
stage.focus= myTF;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:Stage:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 获取并设置舞台的帧速率。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>frameRate</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 获取并设置舞台的帧速率。帧速率是指每秒显示的帧数。默认情况下，速率设置为第一个加载的 SWF 文件的帧速率。帧速率的有效范围为每秒 0.01 到 1000 个帧。 
	 
	 <p><codeph>注意：</codeph>应用程序可能由于以下原因而无法支持高帧速率设置：目标平台不够快或播放器与显示设备的垂直空白时间（在 LCD 设备上通常为 60 Hz）同步。在某些情况下，如果目标平台将占用高 CPU 使用率，它可能还会选择降低最大帧率。</p>
	 
	 <p>对于在 Adobe AIR 中运行的内容，设置一个 Stage 对象的 <codeph>frameRate</codeph> 属性会更改所有 Stage 对象（由不同的 NativeWindow 对象使用）的帧速率。
	 </p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:fullScreenHeight:get"><apiName>fullScreenHeight</apiName><shortdesc>
  返回变为全屏大小时使用的显示器高度（如果立即进入该状态）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  返回变为全屏大小时使用的显示器高度（如果立即进入该状态）。如果用户有多台显示器，则使用的显示器是此时显示大部分舞台的显示器。
  
  <p><b>注意：</b>在检索值和变为全屏大小之间，如果用户有机会将浏览器从一台显示器移到另一台显示器，则该值可能不正确。如果在将 <codeph>Stage.displayState</codeph> 设置为 <codeph>StageDisplayState.FULL_SCREEN</codeph> 的事件处理函数中检索值，则该值是正确的。</p>
  
  <p>如果将 <codeph>Stage.align</codeph> 设置为 <codeph>StageAlign.TOP_LEFT</codeph> 并将 <codeph>Stage.scaleMode</codeph> 设置为 <codeph>StageScaleMode.NO_SCALE</codeph>，则该值是显示器的像素高度并且与舞台高度相同。</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> 本示例创建一个舞台大小的绿色矩形，并在其上面放置一个红色正方形，它将作为按钮进行激活。单击红色正方形可触发 <codeph>enterFullScreen()</codeph> 事件处理函数，它将设置 <codeph>fullScreenSourceRect</codeph> 属性并进入全屏模式。为了设置 <codeph>fullScreenSourceRect</codeph> 属性，该事件处理函数先从红色正方形的位置和尺寸入手。然后，它将红色正方形的高宽比（宽度除以高度）与舞台在全屏宽度和高度下的高宽比进行比较，以便扩展矩形 (<codeph>fullScreenSourceRect</codeph>) 使其与屏幕高宽比相匹配。结果是红色正方形占据了显示器的整个高度，并且可以在每条边上看见绿色背景。如果高宽比不匹配，将在每条边上显示舞台背景颜色（默认情况下为白色），而不是显示绿色背景。
 
 <p><b>注意：</b>应在浏览器中测试此示例。在“Flash 发布设置”对话框的“HTML”选项卡上，选择“仅 Flash - 允许全屏”模板。指定 Flash Player 的 9.0.115.0 版本，并确保在“格式”选项卡中选择了 Flash 和 HTML 格式。然后，发布生成的 HTML 文件，并在浏览器中打开该文件。</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/fullScreenWidth"><linktext>fullScreenWidth</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenSourceRect:get"><apiName>fullScreenSourceRect</apiName><shortdesc>
  设置 Flash Player 以将特定的舞台区域放大到全屏模式。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
  设置 Flash Player 以将特定的舞台区域放大到全屏模式。如果可用，Flash Player 将使用硬件进行缩放（它使用用户计算机上的图形和视频卡），通常其内容显示速度比软件缩放快。
  
  <p>如果将此属性设置为有效矩形并将 <codeph>displayState</codeph> 属性设置为全屏模式，Flash Player 将对指定区域进行缩放。ActionScript 中的实际舞台大小（以像素为单位）不会发生改变。Flash Player 对矩形大小强制规定了最小限制，以容纳标准的“按 Esc 退出全屏模式”消息。通常，此限制大约为 260 x 30 个像素，但可能会随平台和 Flash Player 版本的不同而发生变化。</p>
  
  <p>仅当 Flash Player 未处于全屏模式时，才能设置此属性。要正确使用此属性，应先设置此属性，然后将 <codeph>displayState</codeph> 属性设置为全屏模式，如代码示例中所示。</p>
  <p>要启用缩放功能，请将 <codeph>fullScreenSourceRect</codeph> 属性设置为矩形对象：</p>
  <codeblock>  
  // valid, will enable hardware scaling
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240); 
  </codeblock>
  
  <p>要禁用缩放功能，请在 ActionScript 3.0 中设置 <codeph>fullScreenSourceRect=null</codeph>，而在 ActionScript 2.0 中设置 <codeph>undefined</codeph>。</p>
  <codeblock>
  stage.fullScreenSourceRect = null;
  </codeblock>
  
  <p>最终用户还可以在“Flash Player 显示设置”中进行选择以关闭硬件缩放功能，默认情况下，将启用此功能。有关详细信息，请参阅 <xref href="http://www.adobe.com/go/display_settings" scope="external">www.adobe.com/go/display_settings</xref>。</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenSourceRect.1.as"> 要利用硬件缩放功能，请将整个舞台或部分舞台设置为全屏模式。以下 ActionScript 3.0 代码将整个舞台设置为全屏模式：
<codeblock>
 
import flash.geom.*; 
{
  stage.fullScreenSourceRect = new Rectangle(0,0,320,240);
  stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example><example conref="examples\Stage_fullScreenSourceRectExample2.as"> 在以下示例中，用户可以通过单击舞台来切换播放视频的方式：全屏模式或正常模式。如果此示例的 SWF 在 Flash Player 9.0.115.0 或更高版本中运行，它将使用硬件加速功能来改进显示时的全屏缩放。
  
 <p>在使用带有硬件缩放的全屏模式之前，必须具备以下条件：</p>
 
 <ol>
 <li>需要有 Flash Player 9.0.115.0 或更高版本，以及支持该版本的创作工具。</li>
 <li>需要修改 HTML 模板以支持全屏模式。必须为 <codeph>object</codeph> 和 <codeph>embed</codeph> 标签将 <codeph>allowFullScreen</codeph> 属性设置为 <codeph>true</codeph>。（生成 SWF 嵌入标签的脚本也必须考虑到全屏模式。） 有关可以用于 Flex Builder 的文件示例，请参阅文章：<xref href="http://www.adobe.com/devnet/flashplayer/articles/full_screen_mode.html" scope="external">Exploring full-screen mode in Flash Player 9</xref>（了解 Flash Player 9 中的全屏模式）。</li>
 <li>您的应用程序必须具有访问 FLV 视频文件的权限。在此示例中，假定 Flash 视频 (FLV) 文件与 SWF 文件在同一目录中。</li>
 <li>用户必须允许使用全屏模式。</li>
 <li>有关硬件缩放的更多信息，请参阅适用于 Flash Player 的文章：<xref href="http://www.adobe.com/go/hardware_scaling_en" scope="external">Exploring Flash Player support for high-definition H.264 video and AAC audio</xref>（了解高分辨率 H.264 视频和 AAC 音频的 Flash Player 支持）。</li>
 </ol>
 
 <p>使用 NetConnection and NetStream 对象加载了一个 FLV 文件。由于 FLV 文件与 SWF 文件在同一目录中并且将通过 HTTP 进行连接，所以 <codeph>NetConnection.connect()</codeph> 方法的参数会被设置为 <codeph>null</codeph>。<codeph>connect</codeph> NetConnection 对象会通过分派一个调用 <codeph>netStatusHandler()</codeph> 方法的 <codeph>netStatus</codeph> 事件来报告其状态。<codeph>netStatusHandler()</codeph> 方法会检查连接是否成功并调用 <codeph>connectStream()</codeph> 方法，而 connectStream() 方法创建一个使用 NetConnection 对象作为参数的 NetStream 对象。它还会创建一个视频对象并将 NetStream 对象附加到该视频对象。然后，该视频对象会被添加到显示列表中，并且会设置流进行播放。由于 FLV 视频文件不包含元数据或提示点信息，所以将会分派一个 <codeph>AsyncError</codeph> 事件。必须设置一个侦听器来处理该事件。这里设置了侦听器并且它忽略该事件。另外还为 NetStream 对象设置了 <codeph>netStatus</codeph> 事件的另一个侦听器。如果没有找到流，它将会显示一条错误信息。（请注意，可以使用 <codeph>netStatusHandler()</codeph> 来处理为流或连接报告的任意数量的不同状态信息。）</p>
 
 <p>在可以访问所加载 SWF 文件的属性和方法时，会调用 <codeph>createMouseListener()</codeph> 方法。它会设置一个在用鼠标单击舞台时使用的事件侦听器。<codeph>toggleFullScreen()</codeph> 方法会检查显示状态是处于全屏模式还是处于正常模式。如果是正常模式，视频对象的大小会被设置为视频流的大小。<codeph>fullScreenSourceRect</codeph> 属性会被设置为一个与视频对象尺寸匹配的矩形。然后，<codeph>Stage.displayMode</codeph> 属性会被设置为全屏模式，这样就会导致源矩形中的视频扩展，从而填满全屏。如果符合系统要求，将会使用计算机的图形硬件来改进全屏视频呈现的性能，并且显示状态会被设置为全屏模式。为了捕捉在切换为全屏模式时可能出现的任何安全错误，可以使用 <codeph>try...catch</codeph>。（请注意，在设置 <codeph>fullScreenSourceRect</codeph> 属性之后，必须将显示状态设置为全屏模式。） 在切换到正常模式之前，会将视频对象的宽度和高度设回所保存的原始视频对象的高度和宽度。否则，为全屏模式而对视频对象所做的更改将会确定宽度和高度。</p>
 
<codeblock>
package {
    import flash.display.Sprite;
    import flash.display.StageDisplayState;
    import flash.media.Video;
    import flash.net.NetConnection;
    import flash.net.NetStream;
    import flash.events.NetStatusEvent;
    import flash.events.AsyncErrorEvent;
    import flash.events.SecurityErrorEvent;
    import flash.events.MouseEvent;
    import flash.events.Event;
    import flash.geom.Rectangle;
    
    public class Stage_fullScreenSourceRectExample2 extends Sprite {
        private var videoURL:String = "testVideo1.flv";
        private var connection:NetConnection;
        private var stream:NetStream;
        private var myVideo:Video;        
        private    var savedWidth:uint;
        private    var savedHeight:uint;
 
        public function Stage_fullScreenSourceRectExample2() {
    
            connection = new NetConnection();
             connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);    
            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            connection.connect(null);

            loaderInfo.addEventListener(Event.INIT, createMouseListener);            
        }

        private function createMouseListener(event:Event):void {
            stage.addEventListener(MouseEvent.CLICK, toggleFullScreen);
        }        

        private function toggleFullScreen(event:MouseEvent):void {

            if(stage.displayState == StageDisplayState.NORMAL) {
                myVideo.width = myVideo.videoWidth;
                  myVideo.height = myVideo.videoHeight;

                try {
                    stage.fullScreenSourceRect = new Rectangle(myVideo.x, myVideo.y, 
                                                           myVideo.width, myVideo.height);
                     stage.displayState = StageDisplayState.FULL_SCREEN;

                 } catch (e:SecurityError) {
                     trace ("A security error occurred while switching to full screen: " + event);
                    myVideo.width = savedWidth;
                    myVideo.height = savedHeight;
                 }

            }else {
                myVideo.width = savedWidth;
                myVideo.height = savedHeight;
                stage.displayState = StageDisplayState.NORMAL;
            }
        }    

       private function netStatusHandler(event:NetStatusEvent):void {
            switch (event.info.code) {
                case "NetConnection.Connect.Success":
                    connectStream();
                    break;
                case "NetStream.Play.StreamNotFound":
                    trace ("Unable to locate video: " + videoURL);
                    break;
            }
        }

       private function connectStream():void {
            var stream:NetStream = new NetStream(connection);
            stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);
            stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);     

             myVideo = new Video();
            myVideo.attachNetStream(stream);
            stream.play(videoURL);

            savedWidth = myVideo.width;
            savedHeight = myVideo.height;

            addChild(myVideo);
        }
       
        private function securityErrorHandler(event:SecurityErrorEvent):void {
            trace("securityErrorHandler: " + event);    
        }
        
        private function asyncErrorHandler(event:AsyncErrorEvent):void {
            
        }            
    }
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#StageDisplayState"><linktext>flash.display.StageDisplayState</linktext></link><link href="flash.display.xml#Stage/displayState"><linktext>Stage.displayState</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>Stage.scaleMode</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:fullScreenWidth:get"><apiName>fullScreenWidth</apiName><shortdesc>
  返回变为全屏大小时使用的显示器宽度（如果立即进入该状态）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
  返回变为全屏大小时使用的显示器宽度（如果立即进入该状态）。如果用户有多台显示器，则使用的显示器是此时显示大部分舞台的显示器。 
  
  <p><b>注意：</b>在检索值和变为全屏大小之间，如果用户有机会将浏览器从一台显示器移到另一台显示器，则该值可能不正确。如果在将 <codeph>Stage.displayState</codeph> 设置为 <codeph>StageDisplayState.FULL_SCREEN</codeph> 的事件处理函数中检索值，则该值是正确的。</p>
  
  <p>如果将 <codeph>Stage.align</codeph> 设置为 <codeph>StageAlign.TOP_LEFT</codeph> 并将 <codeph>Stage.scaleMode</codeph> 设置为 <codeph>StageScaleMode.NO_SCALE</codeph>，则该值是显示器的像素宽度并且与舞台宽度相同。</p>
  
  
  </apiDesc><example conref="examples\Stage.fullScreenHeightWidth.as"> 本示例创建一个舞台大小的绿色矩形，并在其上面放置一个红色正方形，它将作为按钮进行激活。单击红色正方形可触发 <codeph>enterFullScreen()</codeph> 事件处理函数，它将设置 <codeph>fullScreenSourceRect</codeph> 属性并进入全屏模式。为了设置 <codeph>fullScreenSourceRect</codeph> 属性，该事件处理函数先从红色正方形的位置和尺寸入手。然后，它将红色正方形的高宽比（宽度除以高度）与舞台在全屏宽度和高度下的高宽比进行比较，以便扩展矩形 (<codeph>fullScreenSourceRect</codeph>) 使其与屏幕高宽比相匹配。结果是红色正方形占据了显示器的整个高度，并且可以在每条边上看见绿色背景。如果高宽比不匹配，将在每条边上显示舞台背景颜色（默认情况下为白色），而不是显示绿色背景。
 
 <p><b>注意：</b>应在浏览器中测试此示例。在“Flash 发布设置”对话框的“HTML”选项卡上，选择“仅 Flash - 允许全屏”模板。指定 Flash Player 的 9.0.115.0 版本，并确保在“格式”选项卡中选择了 Flash 和 HTML 格式。然后，发布生成的 HTML 文件，并在浏览器中打开该文件。</p>
<codeblock>

import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.MouseEvent;
import flash.geom.Rectangle;
 
// cover the stage with a green rectangle
var greenRect:Sprite = new Sprite();
greenRect.graphics.beginFill(0x00FF00);
greenRect.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);
addChild(greenRect);
 
// create red square on stage, turn it into a button for going to full screen
var redSquare:Sprite = new Sprite();
redSquare.graphics.beginFill(0xFF0000);
redSquare.graphics.drawRect(0, 0, 300, 300);
redSquare.x = 50;
redSquare.y = 50;
redSquare.addEventListener(MouseEvent.CLICK, enterFullScreen);
redSquare.buttonMode = true;
addChild(redSquare);
 
function enterFullScreen(e:MouseEvent):void
{
    // we will go to full screen zoomed in on the red square
    var redSquare:Sprite = e.target as Sprite;
    var fullScreenRect:Rectangle = new Rectangle(redSquare.x, redSquare.y, redSquare.width, redSquare.height);
 
    // calculate aspect ratio of the red square
    var rectAspectRatio:Number = fullScreenRect.width / fullScreenRect.height;
 
    // calculate aspect ratio of the screen
    var screenAspectRatio:Number = stage.fullScreenWidth / stage.fullScreenHeight;
  
    // change the fullScreenRect so that it covers the entire screen, keeping it centered on the redSquare
    // try commenting out this section to see what happens if you do not fix the aspect ratio.
    if (rectAspectRatio > screenAspectRatio) {
         var newHeight:Number = fullScreenRect.width / screenAspectRatio;
         fullScreenRect.y -= ((newHeight - fullScreenRect.height) / 2);
        fullScreenRect.height = newHeight;
    } else if (rectAspectRatio &lt; screenAspectRatio) {
        var newWidth:Number = fullScreenRect.height * screenAspectRatio;
        fullScreenRect.x -= ((newWidth - fullScreenRect.width) / 2);
        fullScreenRect.width = newWidth;
    }
 
    // go to full screen
    stage.fullScreenSourceRect = fullScreenRect;
    stage.displayState = StageDisplayState.FULL_SCREEN;
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Stage/displayState"><linktext>displayState</linktext></link><link href="flash.display.xml#Stage/fullScreenHeight"><linktext>fullScreenHeight</linktext></link><link href="flash.display.xml#Stage/fullScreenSourceRect"><linktext>fullScreenSourceRect</linktext></link><link href="flash.display.xml#Stage/scaleMode"><linktext>scaleMode</linktext></link><link href="flash.display.xml#StageDisplayState"><linktext>StageDisplayState</linktext></link><link href="flash.events.xml#Event/RESIZE"><linktext>flash.events.Event.RESIZE</linktext></link><link href="flash.events.xml#FullScreenEvent"><linktext>flash.events.FullScreenEvent</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:height:get"><apiName>height</apiName><shortdesc>
	 
     指示显示对象的高度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>引用 Stage 对象的 <codeph>height</codeph> 属性会因任何调用者没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>即使调用对象是 Stage 所有者（主 SWF 文件），设置 Stage 对象的 <codeph>height</codeph> 属性也是非法的。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     指示显示对象的高度，以像素为单位。高度是根据显示对象内容的范围来计算的。如果您设置了 <codeph>height</codeph> 属性，则 <codeph>scaleY</codeph> 属性会相应调整，如以下代码所示：
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleY) // 1;
    rect.height = 200;
    trace(rect.scaleY) // 2;</codeblock>
    
    <p>除 TextField 和 Video 对象以外，没有内容的显示对象（如一个空的 Sprite）的高度为 0，即使您尝试将 <codeph>height</codeph> 设置为其它值，也是这样。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:mouseChildren:get"><apiName>mouseChildren</apiName><shortdesc>
	 
	 确定对象的子项是否支持鼠标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>引用 Stage 对象的 <codeph>mouseChildren</codeph> 属性会因任何调用者没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 确定对象的子项是否支持鼠标。如果对象支持鼠标，则用户可以使用鼠标与其交互。默认值为 <codeph>true</codeph>。
	 
	 <p>当您使用 Sprite 类的实例（而不是使用 SimpleButton 类）来创建按钮时，此属性很有用。当您使用 Sprite 实例来创建按钮时，可以选择使用 <codeph>addChild()</codeph> 方法添加其它 Sprite 实例来修饰该按钮。此过程可能导致鼠标事件出现意外行为，因为当您期望父实例成为鼠标事件的目标对象时，作为子项添加的 Sprite 实例却可能成为目标对象。要确保父实例用作鼠标事件的目标对象，您可以将父实例的 <codeph>mouseChildren</codeph> 属性设置为 <codeph>false</codeph>。</p>
	 <p> 设置此属性不会分派任何事件。您必须使用 <codeph>addEventListener()</codeph> 方法才能创建交互式功能。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:nativeWindow:get"><apiName>nativeWindow</apiName><shortdesc>
	 对包含此舞台的 NativeWindow 对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:NativeWindow</apiValueClassifier></apiValueDef><apiDesc>
	 对包含此舞台的 NativeWindow 对象的引用。 
	 
	 <p>窗口表示本机操作系统的窗口，舞台表示窗口所包含的内容。此属性只对在 AIR 中运行的内容有效。在 Flash Player 中（在浏览器中运行的内容），此属性将为 <codeph>null</codeph>。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:numChildren:get"><apiName>numChildren</apiName><shortdesc>
	 
	 返回此对象的子项数目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>引用 Stage 对象的 <codeph>numChildren</codeph> 属性会因任何调用者没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 返回此对象的子项数目。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:quality:get"><apiName>quality</apiName><shortdesc>
	 StageQuality 类中的一个用于指定使用哪种呈现品质的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>quality</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 StageQuality 类中的一个用于指定使用哪种呈现品质的值。以下是有效值：
	 
	 <ul>
	 
	 <li><codeph>StageQuality.LOW</codeph> -- 低呈现品质。图形不是消除锯齿的，且位图未进行平滑处理，但运行时仍使用 mip 贴图技术。Adobe AIR 中不支持此设置。</li>
	 
	 <li><codeph>StageQuality.MEDIUM</codeph> -- 中等呈现品质。图形是使用 2 x 2 像素网格消除锯齿的，而位图平滑处理取决于 <codeph>Bitmap.smoothing</codeph> 设置。运行时使用 mip 贴图技术。此设置适用于不包含文本的影片。Adobe AIR 中不支持此设置。</li>
	 
	 <li><codeph>StageQuality.HIGH</codeph> -- 高呈现品质。图形是使用 4 x 4 像素网格消除锯齿的，而位图平滑处理取决于 <codeph>Bitmap.smoothing</codeph> 设置。运行时使用 mip 贴图技术。这是 Flash Player 使用的默认呈现品质设置。</li>
	 
	 <li><codeph>StageQuality.BEST</codeph> -- 极高呈现品质。图形是使用 4 x 4 像素网格消除锯齿的。如果将 <codeph>Bitmap.smoothing</codeph> 设置为 <codeph>true</codeph>，则运行时会使用产生较少伪像的高品质降级算法（但是，使用 <codeph>StageQuality.BEST</codeph> 时将 <codeph>Bitmap.smoothing</codeph> 设置为 <codeph>true</codeph> 会显著降低性能，因此不建议使用此设置）。</li>
	 
	 </ul>
	 
	 <p>较高的品质设置可以使缩放的位图得到较好的呈现品质。不过，较高的品质设置从运算角度看更昂贵。尤其在呈现缩放的视频时，使用较高的品质设置可以降低帧速率。
	 </p>
	 
	 <p>对于在 Adobe AIR 中运行的内容，可以将 <codeph>quality</codeph> 设置为 <codeph>StageQuality.BEST</codeph> 或 <codeph>StageQuality.HIGH</codeph>（默认值为 <codeph>StageQuality.HIGH</codeph>）。试图将其设置为其它值没有任何效果（且该属性保持不变）。
	 </p>
	 
	 <p>对于在 Adobe AIR 中运行的内容，设置一个 Stage 对象的 <codeph>quality</codeph> 属性会更改所有 Stage 对象（由不同的 NativeWindow 对象使用）的呈现品质。
	 </p>
	 
	 <b><i>注意：</i></b>操作系统绘制设备字体，因此，这些设备字体不会受 <codeph>quality</codeph> 属性的影响。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageQuality"><linktext>flash.display.StageQuality</linktext></link><link href="flash.display.xml#Bitmap/smoothing"><linktext>flash.display.Bitmap.smoothing</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:scaleMode:get"><apiName>scaleMode</apiName><shortdesc>
	 一个 StageScaleMode 类中指定要使用哪种缩放模式的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>scaleMode</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>一个 StageScaleMode 类中指定要使用哪种缩放模式的值。
 	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 一个 StageScaleMode 类中指定要使用哪种缩放模式的值。以下是有效值：
	 
     <ul>
     
     <li><codeph>StageScaleMode.EXACT_FIT</codeph> -- 整个应用程序在指定区域中可见，但不尝试保持原始高宽比。可能会发生扭曲，应用程序可能会拉伸或压缩显示。
     </li>
     
     <li><codeph>StageScaleMode.SHOW_ALL</codeph> -- 整个应用程序在指定区域中可见，且不发生扭曲，同时保持应用程序的原始高宽比。应用程序的两侧可能会显示边框。   
     </li>
     
	 <li><codeph>StageScaleMode.NO_BORDER</codeph> -- 整个应用程序填满指定区域，不发生扭曲，但有可能进行一些裁切，同时保持应用程序的原始高宽比。
	 </li>
	 
	 <li><codeph>StageScaleMode.NO_SCALE</codeph> -- 整个应用程序的大小固定，因此，即使播放器窗口的大小更改，它也会保持不变。如果播放器窗口比内容小，则可能进行一些裁切。
	 </li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:showDefaultContextMenu:get"><apiName>showDefaultContextMenu</apiName><shortdesc>
     指定显示或隐藏 Flash Player 上下文菜单中的默认项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>showDefaultContextMenu</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>指定显示或隐藏 Flash Player 上下文菜单中的默认项。
	 
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     指定显示或隐藏 Flash Player 上下文菜单中的默认项。
     
     <p>如果将 <codeph>showDefaultContextMenu</codeph> 属性设置为 <codeph>true</codeph>（默认设置），则会显示所有上下文菜单项。如果将 <codeph>showDefaultContextMenu</codeph> 属性设置为 <codeph>false</codeph>，则只显示“设置”和“关于 Adobe Flash Player”菜单项。</p>
     
 	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageFocusRect:get"><apiName>stageFocusRect</apiName><shortdesc>
	 指定对象在具有焦点时是否显示加亮的边框。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>stageFocusRect</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiTipTexts><apiTipText>指定对象在具有焦点时是否显示加亮的边框。
	 
 	 </apiTipText></apiTipTexts></apiValueDef><apiDesc>
	 指定对象在具有焦点时是否显示加亮的边框。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:stageHeight:get"><apiName>stageHeight</apiName><shortdesc>
     舞台的当前高度（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>stageHeight</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
 	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     舞台的当前高度（以像素为单位）。
     
     <p>如果将 <codeph>Stage.scaleMode</codeph> 属性的值设置 <codeph>StageScaleMode.NO_SCALE</codeph>，则当用户调整该窗口的大小时，舞台内容将保持其大小，而 <codeph>stageHeight</codeph> 属性将发生更改以反映由 SWF 文件占用的屏幕区域的新高度大小。（在其它缩放模式中，<codeph>stageHeight</codeph> 属性始终反映 SWF 文件的原始高度。）您可以为 <codeph>resize</codeph> 事件添加事件侦听器，然后使用 Stage 类的 <codeph>stageHeight</codeph> 属性来确定调整大小后的 Flash Player 窗口的实际像素尺寸。使用该事件侦听器可以控制用户调整窗口大小时屏幕内容的调整方式。</p>
	 
	 <p><b>注意：</b>在承载 SWF 文件的 HTML 页上，<codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>height</codeph> 属性必须设置为一个百分数（比如 <codeph>100%</codeph>），而不是像素。如果该设置是由 JavaScript 代码生成的，则 <codeph>AC_FL_RunContent()</codeph> 方法的 <codeph>height</codeph> 参数也必须设置为百分数。此百分数应用于 <codeph>stageHeight</codeph> 值。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:stageWidth:get"><apiName>stageWidth</apiName><shortdesc>
     指定舞台的当前宽度（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>调用 Stage 对象的 <codeph>stageWidth</codeph> 属性会因任何调用方没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
     指定舞台的当前宽度（以像素为单位）。
     
     
     <p>如果将 <codeph>Stage.scaleMode</codeph> 属性的值设置 <codeph>StageScaleMode.NO_SCALE</codeph>，则当用户调整该窗口的大小时，舞台内容将保持其定义的大小，而 <codeph>stageWidth</codeph> 属性将发生更改以反映由 SWF 文件占用的屏幕区域的新宽度大小。（在其它缩放模式中，<codeph>stageWidth</codeph> 属性始终反映 SWF 文件的原始宽度。）您可以为 <codeph>resize</codeph> 事件添加事件侦听器，然后使用 Stage 类的 <codeph>stageWidth</codeph> 属性来确定调整大小后的 Flash Player 窗口的实际像素尺寸。使用该事件侦听器可以控制用户调整窗口大小时屏幕内容的调整方式。</p>
	 
     <p><b>注意：</b>在承载 SWF 文件的 HTML 页上，<codeph>object</codeph> 和 <codeph>embed</codeph> 标签的 <codeph>width</codeph> 属性必须设置为一个百分数（比如 <codeph>100%</codeph>），而不是像素。如果该设置是由 JavaScript 代码生成的，则 <codeph>AC_FL_RunContent()</codeph> 方法的 <codeph>width</codeph> 参数也必须设置为百分数。此百分数应用于 <codeph>stageWidth</codeph> 值。</p>
     
 	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#StageScaleMode"><linktext>flash.display.StageScaleMode</linktext></link></related-links></apiValue><apiValue id="flash.display:Stage:tabChildren:get"><apiName>tabChildren</apiName><shortdesc>
	 
	 确定对象的子项是否支持 Tab 键。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc>引用 Stage 对象的 <codeph>tabChildren</codeph> 属性会因任何调用者没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
	 确定对象的子项是否支持 Tab 键。为对象的子项启用或禁用 Tab 切换。默认值为 <codeph>true</codeph>。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:textSnapshot:get"><apiName>textSnapshot</apiName><shortdesc>
	 
     返回此 DisplayObjectContainer 实例的 TextSnapshot 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.text:TextSnapshot</apiValueClassifier><apiException><apiDesc>引用 Stage 对象的 <codeph>textSnapshot</codeph> 属性会因 Stage 类未实现该属性而引发异常。为避免出现这种情况，请调用显示对象容器而非 Stage 对象的 <codeph>textSnapshot</codeph> 属性。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     返回此 DisplayObjectContainer 实例的 TextSnapshot 对象。
     
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:width:get"><apiName>width</apiName><shortdesc>
	 
     指示显示对象的宽度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>引用 Stage 对象的 <codeph>width</codeph> 属性会因任何调用者没有与 Stage 所有者（主 SWF 文件）位于同一安全沙箱而引发异常。为避免出现这种情况，Stage 的所有者可以通过调用 <codeph>Security.allowDomain()</codeph> 方法或 <codeph>Security.allowInsecureDomain()</codeph> 方法来向域的调用方授予权限。有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“安全性”一章。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>即使您是 Stage 所有者，设置 Stage 对象的 <codeph>width</codeph> 属性也是非法的。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 
     指示显示对象的宽度，以像素为单位。宽度是根据显示对象内容的范围来计算的。如果您设置了 <codeph>width</codeph> 属性，则 <codeph>scaleX</codeph> 属性会相应调整，如以下代码所示：
     
     <codeblock>
    var rect:Shape = new Shape();
    rect.graphics.beginFill(0xFF0000);
    rect.graphics.drawRect(0, 0, 100, 100);
    trace(rect.scaleX) // 1;
    rect.width = 200;
    trace(rect.scaleX) // 2;</codeblock>
    
    <p>除 TextField 和 Video 对象以外，没有内容的显示对象（如一个空的 Sprite）的宽度为 0，即使您尝试将 <codeph>width</codeph> 设置为其它值，也是这样。</p>
     
     </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:Stage:wmodeGPU:get"><apiName>wmodeGPU</apiName><shortdesc>
	 指示 GPU 合成是否可用及是否正在使用中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.0.32"/><apiPlatform description="" name="AIR" version="1.5.2"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指示 GPU 合成是否可用及是否正在使用中。仅当下列三个条件同时存在时，<codeph>wmodeGPU</codeph> 的值才为 <codeph>true</codeph><i/>：
	 <p><ul><li>已请求 GPU 合成。</li>
	 <li>GPU 合成可用。</li>
	 <li>GPU 合成正在使用。</li></ul></p>
	 <p>具体来说，<codeph>wmodeGPU</codeph> 属性指示下列条件之一：</p>
	 <p><ol><li>尚未请求 GPU 合成或 GPU 合成不可用。在这种情况下，<codeph>wmodeGPU</codeph> 属性值为 <codeph>false</codeph>。</li>
	 <li>已请求 GPU 合成（如果适用且可用），但是由于内容限制，此环境正在“回退模式”（非最佳渲染方式）下工作。在这种情况下，<codeph>wmodeGPU</codeph> 属性值为 <codeph>true</codeph>。</li>
	 <li>已请求 GPU 合成（如果适用且可用），并且环境正在最佳模式下工作。在这种情况下，<codeph>wmodeGPU</codeph> 属性值也为 <codeph>true</codeph>。</li></ol></p>
	 <p>换句话说，<codeph>wmodeGPU</codeph> 属性会标识呈现环境的功能和状态。对于不支持 GPU 合成的运行时（例如，AIR 1.5.2），此值始终为 <codeph>false</codeph>，因为（如上所述）此值仅在已请求 GPU 合成、GPU 合成可用且正在使用时为 <codeph>true</codeph>。</p>
	 <p><codeph>wmodeGPU</codeph> 属性用于确定 GPU 合成在运行时是否正在使用中。<codeph>wmodeGPU</codeph> 的值指示是否将由硬件对您的内容进行缩放，以使您可以显示正确大小的图形。您还可以确定是否要通过快速途径渲染，以使您可以对内容复杂性进行相应调整。</p>
	 <p>对于位于浏览器中的 Flash Player，可由承载 SWF 文件的页面中的 <codeph>wmode</codeph> HTML 参数的 <codeph>gpu</codeph> 的值请求 GPU 合成。对于其他配置，可在 SWF 文件（使用 SWF 创作工具进行设置）头中请求 GPU 合成。</p>	 
	 <p>但是，<codeph>wmodeGPU</codeph> 属性不标识当前渲染性能。即使 GPU 合成“正在使用中”，渲染过程可能也不会在最佳模式下进行操作。要调整您的内容以实现最佳渲染，请使用 Flash 运行时调试版本并在您的 mm.cfg 文件中设置 <codeph>DisplayGPUBlendsetting</codeph>。</p>
	 
	 <p><b>注意：</b>从运行时首次执行渲染传递之前运行的 ActionScript 引用此属性时，此属性始终为 <codeph>false</codeph>。例如，如果您从 Adobe Flash Professional 的第 1 帧的脚本检查 <codeph>wmodeGPU</codeph>，而且您的 SWF 文件是运行时新实例中加载的第一个 SWF 文件，则 <codeph>wmodeGPU</codeph> 值为 <codeph>false</codeph>。至少发生一次渲染传递后，才能获取精确值。如果为 <codeph>DisplayObject</codeph> 的 <codeph>exitFrame</codeph> 事件编写事件侦听器，则 <codeph>wmodeGPU</codeph> 值是正确的值。</p>
	 
	 </apiDesc><example conref="examples\Stage.wmodeGPU.as"> 以下示例在渲染显示对象 mySprite 后检查 <codeph>wmodeGPU</codeph> 属性，使您可以获取精确值。
<codeblock>
mySprite.addEventListener(EXIT_FRAME, exithandler):

function exithandler(exiteventobject:Event):void {
                trace(stage.wmodeGPU);
}
</codeblock></example></apiValueDetail><related-links><link href="DisplayObject.html#event:exitFrame"><linktext>DisplayObject exitFrame 事件</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	 NativeWindowInitOptions 类定义用于构造新的 NativeWindow 实例的初始化选项。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 NativeWindowInitOptions 类定义用于构造新的 NativeWindow 实例的初始化选项。 
	 <p>创建窗口后，不能更改初始化选项中定义的属性。</p>
	 
	 <p><b>注意：</b>对于由 AIR 自动创建的初始应用程序窗口，所有这些属性（<codeph>type</codeph> 除外）均在应用程序的描述符中设置。初始窗口的类型始终为正常。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow"><linktext>flash.display.NativeWindow</linktext></link><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links><apiConstructor id="flash.display:NativeWindowInitOptions:NativeWindowInitOptions"><apiName>NativeWindowInitOptions</apiName><shortdesc>
	    创建新的 NativeWindowInitOptions 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	    创建新的 NativeWindowInitOptions 对象。
	    
        <p>新创建的对象的默认值为：</p>
	    <ul>
        <li><codeph>systemChrome = NativeWindowSystemChrome.STANDARD</codeph></li>
        <li><codeph>type = NativeWindowType.NORMAL</codeph></li>
	    <li><codeph>transparent = false</codeph></li>
	    <li><codeph>resizable = true</codeph></li>
	    <li><codeph>maximizable = true</codeph></li>
	    <li><codeph>minimizable = true</codeph></li>
	    </ul>
	    
	    </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:NativeWindowInitOptions:maximizable:get"><apiName>maximizable</apiName><shortdesc>
		 指定用户是否可以最大化窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MAXIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 指定用户是否可以最大化窗口。  
		 
		 <p>
		 对于带有系统镶边的窗口，此设置将影响窗口最大化按钮的外观。它还将影响系统管理的用户界面的其它部分，比如 Microsoft Windows 中的窗口菜单。
		 </p>
		 
		 <p>
		 设置为 <codeph>false</codeph> 时，用户将无法最大化窗口。直接调用 NativeWindow <codeph>maximize()</codeph> 方法可使窗口最大化。
		 </p>
		 
		 <p><b>注意：</b>在某些操作系统中（比如 Mac OS X），最大化窗口后并不会阻止调整窗口大小，要阻止窗口缩放或调整大小，<codeph>maximizable</codeph> 和 <codeph>resizable</codeph> 必须同时设置为 <codeph>false</codeph>。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:minimizable:get"><apiName>minimizable</apiName><shortdesc>
		 指定用户是否可以最小化窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_MINIMIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 指定用户是否可以最小化窗口。
		 
		 <p>
		 对于带有系统镶边的窗口，此设置将影响窗口最小化按钮的外观。它还将影响系统管理的用户界面的其它部分，比如 Microsoft Windows 中的窗口菜单。
		 </p>
		 
		 <p>
		 设置为 <codeph>false</codeph> 时，用户将无法最小化窗口。直接调用 NativeWindow <codeph>minimize()</codeph> 方法可使窗口最小化。
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/displayState"><linktext>flash.display.NativeWindow.displayState</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:resizable:get"><apiName>resizable</apiName><shortdesc>
		 指定用户是否可以调整窗口大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>WS_SIZEBOX
		 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>true
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 指定用户是否可以调整窗口大小。
		 
		 <p>
		 设置为 <codeph>false</codeph> 时，用户无法使用系统镶边调整窗口大小。在发生鼠标事件时调用 NativeWindow <codeph>startResize()</codeph> 方法可以允许用户调整窗口大小。直接设置窗口边界也可更改窗口大小。
		 </p>
		 
		 <p><b>注意：</b>在某些操作系统中（比如 Mac OS X），最大化窗口是一种调整大小操作，要阻止窗口缩放或调整大小，<codeph>maximizable</codeph> 和 <codeph>resizable</codeph> 必须同时设置为 <codeph>false</codeph>。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindow/bounds"><linktext>flash.display.NativeWindow.bounds</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:systemChrome:get"><apiName>systemChrome</apiName><shortdesc>
		 指定是否为窗口提供系统镶边。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowSystemChrome.STANDARD
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 指定是否为窗口提供系统镶边。 
		  
		 <p> 镶边指的是允许用户控制窗口的桌面属性的窗口控件。系统镶边使用桌面环境的标准控件，其中可以运行 AIR 应用程序，并符合本机操作系统的标准外观。</p>
		 <p>
		 要使用由框架（诸如 Flex）提供的镶边，或要提供您自己的窗口镶边，请将 <codeph>systemChrome</codeph> 设置为 <codeph>NativeWindowSystemChrome.NONE</codeph>。
		 </p>
		 <p>用作此属性的有效值的常数在 NativeWindowSystemChrome 类中定义：
         </p>
		 <ul>
         <li><codeph>NativeWindowSystemChrome.NONE</codeph></li>
		 <li><codeph>NativeWindowSystemChrome.STANDARD</codeph></li>
		 </ul>
		 
		 <p>如果未指定，<codeph>systemChrome</codeph> 的默认值为 <codeph>NativeWindowSystemChrome.STANDARD</codeph>。
		 </p>
		 
		 <p>对于带有系统镶边的窗口，不支持将 <codeph>transparent</codeph> 属性设置为 <codeph>true</codeph>。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowSystemChrome"><linktext>flash.display.NativeWindowSystemChrome</linktext></link></related-links></apiValue><apiValue id="flash.display:NativeWindowInitOptions:transparent:get"><apiName>transparent</apiName><shortdesc>
		 指定窗口是否支持针对桌面的透明度和 Alpha 混合。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier><apiDefaultValue>false
		 
	     </apiDefaultValue></apiValueDef><apiDesc>
		 指定窗口是否支持针对桌面的透明度和 Alpha 混合。
		 
		 <p>
		 如果为 <codeph>true</codeph>，则窗口显示与桌面复合。窗口中未被显示对象覆盖的区域或被 Alpha 设置接近 0 的显示对象覆盖的区域，从效果上说是不可见的，不会截获鼠标事件（窗口下面的桌面对象将接收这些事件）。对象不再截获鼠标事件时的 Alpha 值在大约 0.06 和 0.01 之间变化，具体取决于操作系统。
		 </p>  
		 
		 <p>对于带有系统镶边的窗口，不支持将 <codeph>transparent</codeph> 属性设置为 <codeph>true</codeph>。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowInitOptions:type:get"><apiName>type</apiName><shortdesc>
		 指定要创建的窗口的类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiDefaultValue>NativeWindowType.NORMAL
		 
		 </apiDefaultValue></apiValueDef><apiDesc>
		 指定要创建的窗口的类型。  
		 
		 <p>用作此属性的有效值的常量在 NativeWindowType 类中定义：
         </p>
         
		 <ul>
		 <li><codeph>NativeWindowType.NORMAL</codeph> -- 一个典型窗口。常规窗口使用完全尺寸的镶边，并出现在 Windows 或 Linux 的任务栏和 Mac OS X 的窗口菜单上。</li>
		 
		 <li><codeph>NativeWindowType.UTILITY</codeph> -- 一个工具调板。实用程序窗口使用较细的系统镶边，而且不出现在 Windows 的任务栏上，也不出现在 Mac OS X 的窗口菜单上。</li>
		 
		 <li><codeph>NativeWindowType.LIGHTWEIGHT</codeph> — 轻量型窗口不能具有系统镶边，而且不出现在 Windows 或 Linux 的任务栏中，也不出现在 Mac OS X 的窗口菜单中。此外，在 Windows 中轻量型窗口没有系统菜单（Alt+空格键）。轻量型窗口适用于通知气泡和控件，比如用于可打开一个短期显示区域的组合框。当使用轻量类型时，必须将 <codeph>systemChrome</codeph> 设置为 <codeph>none</codeph>。</li>
		 </ul>
		 
		 <p>
		 如果未指定，<codeph>type</codeph> 的默认值为 <codeph>NativeWindowType.NORMAL</codeph>。
		 </p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#NativeWindowType"><linktext>flash.display.NativeWindowType</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
	 ShaderParameter 实例表示着色器内核的单一输入参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderParameter 实例表示着色器内核的单一输入参数。可以将内核定义为接受在内核执行过程中使用的 0 个、1 个或更多参数。ShaderParameter 提供有关参数的信息，比如参数所需数据的类型。它还提供一个机制，用于设置在着色器执行时使用的参数值。要为着色器参数指定一个或多个值，请创建包含这个值或这些值的数组，并将其赋予 <codeph>value</codeph> 属性。
	 
	 <p>表示 Shader 实例的参数的 ShaderParameter 实例将作为 Shader 实例的 <codeph>data</codeph> 属性的一个属性进行访问。ShaderParameter 属性的名称与着色器代码中参数的名称相同。例如，如果着色器定义一个名为 <codeph>radius</codeph> 的参数，则表示 <codeph>radius</codeph> 参数的 ShaderParameter 实例可作为 <codeph>radius</codeph> 属性使用，如下所示：</p>
	 
	 <codeblock>var radiusParam:ShaderParameter = myShader.data.radius;</codeblock>
	 
	 <p>除了 ShaderParameter 类的已定义属性外，每个 ShaderParameter 实例还具有与为参数定义的任何元数据对应的附加属性。创建 ShaderParameter 对象时会将这些属性添加到该对象中。这些属性的名称与着色器源代码中指定的元数据名称相匹配。每个属性的数据类型因对应元数据的数据类型而异。文本元数据值（如“description”）是 String 实例。具有非字符串值（如 <codeph>minValue</codeph> 或 <codeph>defaultValue</codeph>）的元数据属性表示为 Array 实例。元素的数量和元素数据类型对应于元数据值。</p>
	 
	 <p>例如，假设一个着色器包括以下两个参数声明：</p>
	 
	 <codeblock>
	 parameter float2 size
	 &lt;
	     description: "The size of the image to which the kernel is applied";
	     minValue: float2(0.0, 0.0);
	     maxValue: float2(100.0, 100.0);
	     defaultValue: float2(50.0, 50.0);
	 >;
	 
	 parameter float radius
	 &lt;
	     description: "The radius of the effect";
	     minValue: 0.0;
	     maxValue: 50.0;
	     defaultValue: 25.0;
	 >;
	 </codeblock>
	 
	 <p>对应于 <codeph>size</codeph> 参数的 ShaderParameter 实例除了其内置属性外还具有以下元数据属性：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>属性名称</entry><entry>数据类型</entry><entry>值</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>字符串</entry>
	   <entry><codeph>"size"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>字符串</entry>
	   <entry><codeph>"The size of the image to which the kernel is applied"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0, 0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[100, 100]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50, 50]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>对应于 <codeph>radius</codeph> 参数的 ShaderParameter 具有以下附加属性：</p>
	 
	 <adobetable class="innertable">
	 
	 
	 
	 
	 
	 
	 <tgroup cols="3"><thead><row><entry>属性名称</entry><entry>数据类型</entry><entry>值</entry></row></thead><tbody><row>
	   <entry><codeph>name</codeph></entry>
	   <entry>字符串</entry>
	   <entry><codeph>"radius"</codeph></entry>
	 </row><row>
	   <entry><codeph>description</codeph></entry>
	   <entry>字符串</entry>
	   <entry><codeph>"The radius of the effect"</codeph></entry>
	 </row><row>
	   <entry><codeph>minValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[0]</codeph></entry>
	 </row><row>
	   <entry><codeph>maxValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[50]</codeph></entry>
	 </row><row>
	   <entry><codeph>defaultValue</codeph></entry>
	   <entry>Array</entry>
	   <entry><codeph>[25]</codeph></entry>
	 </row></tbody></tgroup></adobetable>
	 
	 <p>通常，开发人员代码不直接创建 ShaderParameter 实例。在创建 Shader 实例时，将为着色器的每个参数创建一个 ShaderParameter 实例。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link></related-links><apiConstructor id="flash.display:ShaderParameter:ShaderParameter"><apiName>ShaderParameter</apiName><shortdesc>
		 创建 ShaderParameter 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 创建 ShaderParameter 实例。开发人员代码不直接调用 ShaderParameter 构造函数。在创建 Shader 实例时，将为着色器的每个参数创建一个 ShaderParameter 实例。
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderParameter:index:get"><apiName>index</apiName><shortdesc>
         参数的从 0 开始的索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         参数的从 0 开始的索引。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameter:type:get"><apiName>type</apiName><shortdesc>
		着色器中定义的参数的数据类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		着色器中定义的参数的数据类型。<codeph>type</codeph> 属性的可能值的集合由 ShaderParameterType 类中的常量定义。
		
		</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameterType"><linktext>flash.display.ShaderParameterType</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameter:value:get"><apiName>value</apiName><shortdesc>
		以参数值形式传入到着色器的一个或多个值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
		以参数值形式传入到着色器的一个或多个值。<codeph>value</codeph> 属性为索引数组。数组元素的数量和类型对应于参数的数据类型（可使用 <codeph>type</codeph> 属性确定）。
		
		<p>下表指示参数类型以及 <codeph>value</codeph> 数组元素的对应数量和数据类型：</p>
		
		<adobetable class="innertable">
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		<tgroup cols="3"><thead><row><entry>参数类型</entry><entry>元素数量</entry><entry>元素数据类型</entry></row></thead><tbody><row>
		  <entry>float (<codeph>ShaderParameterType.FLOAT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float2 (<codeph>ShaderParameterType.FLOAT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3 (<codeph>ShaderParameterType.FLOAT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4 (<codeph>ShaderParameterType.FLOAT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>int (<codeph>ShaderParameterType.INT</codeph>)</entry>
		  <entry>1</entry>
		  <entry>int 或 uint</entry>
		</row><row>
		  <entry>int2 (<codeph>ShaderParameterType.INT2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>int 或 uint</entry>
		</row><row>
		  <entry>int3 (<codeph>ShaderParameterType.INT3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>int 或 uint</entry>
		</row><row>
		  <entry>int4 (<codeph>ShaderParameterType.INT4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>int 或 uint</entry>
		</row><row>
		  <entry>bool (<codeph>ShaderParameterType.BOOL</codeph>)</entry>
		  <entry>1</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool2 (<codeph>ShaderParameterType.BOOL2</codeph>)</entry>
		  <entry>2</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool3 (<codeph>ShaderParameterType.BOOL3</codeph>)</entry>
		  <entry>3</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>bool4 (<codeph>ShaderParameterType.BOOL4</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Boolean</entry>
		</row><row>
		  <entry>float2x2 (<codeph>ShaderParameterType.MATRIX2X2</codeph>)</entry>
		  <entry>4</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float3x3 (<codeph>ShaderParameterType.MATRIX3X3</codeph>)</entry>
		  <entry>9</entry>
		  <entry>Number</entry>
		</row><row>
		  <entry>float4x4 (<codeph>ShaderParameterType.MATRIX4X4</codeph>)</entry>
		  <entry>16</entry>
		  <entry>Number</entry>
		</row></tbody></tgroup></adobetable>
		
		<p>对于矩阵参数类型，数组元素将填充矩阵的行，然后填充列。例如，假设使用以下 ActionScript 行来填充名为 <codeph>myMatrix</codeph> 的 <codeph>float2x2</codeph> 参数：</p>
		
		<codeblock>myShader.data.myMatrix.value = [.1, .2, .3, .4];</codeblock>
		
		<p>在着色器内，矩阵元素具有以下值：</p>
		
		<ul>
		  <li><codeph>myMatrix[0][0]</codeph>: .1</li>
		  <li><codeph>myMatrix[0][1]</codeph>: .2</li>
		  <li><codeph>myMatrix[1][0]</codeph>: .3</li>
		  <li><codeph>myMatrix[1][1]</codeph>: .4</li>
		</ul>
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GradientType"><apiName>GradientType</apiName><shortdesc>
GradientType 类为 flash.display.Graphics 类的 beginGradientFill() 和 lineGradientStyle() 方法中的 type 参数提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
GradientType 类为 flash.display.Graphics 类的 <codeph>beginGradientFill()</codeph> 和 <codeph>lineGradientStyle()</codeph> 方法中的 <codeph>type</codeph> 参数提供值。

</apiDesc></apiClassifierDetail><apiValue id="flash.display:GradientType:LINEAR"><apiName>LINEAR</apiName><shortdesc>
	用于指定线性渐变填充的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linear</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	用于指定线性渐变填充的值。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GradientType:RADIAL"><apiName>RADIAL</apiName><shortdesc>
	用于指定放射状渐变填充的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>radial</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	用于指定放射状渐变填充的值。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:InterpolationMethod"><apiName>InterpolationMethod</apiName><shortdesc>
InterpolationMethod 类为 Graphics.beginGradientFill() 和 Graphics.lineGradientStyle() 方法中的 interpolationMethod 参数提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
InterpolationMethod 类为 <codeph>Graphics.beginGradientFill()</codeph> 和 <codeph>Graphics.lineGradientStyle()</codeph> 方法中的 <codeph>interpolationMethod</codeph> 参数提供值。此参数确定在呈现渐变时所用的 RGB 空间。 

 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:InterpolationMethod:LINEAR_RGB"><apiName>LINEAR_RGB</apiName><shortdesc>
	指定应使用线性 RGB 插值方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>linearRGB</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	指定应使用线性 RGB 插值方法。这意味着使用基于线性 RGB 颜色模型的 RGB 颜色空间。
	
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/RGB"><linktext>RGB</linktext></link></related-links></apiValue><apiValue id="flash.display:InterpolationMethod:RGB"><apiName>RGB</apiName><shortdesc>
	指定应使用 RGB 插值方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>rgb</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	指定应使用 RGB 插值方法。这意味着使用指数式 sRGB（标准 RGB）空间来呈现渐变。sRGB 空间是一种 W3C 批准的标准，用于定义红色、绿色和蓝色成分值和可见成分颜色实际浓度之间的非线性转换。
	
	<p>例如，假设有两种颜色之间的简单线性渐变（<codeph>spreadMethod</codeph> 参数设置为 <codeph>SpreadMethod.REFLECT</codeph>）。不同的插值方法对外观的影响如下所示： </p>
	
		<adobetable>
		
      
		
		
		
		<tgroup cols="2"><tbody><row><entry align="center"><adobeimage alt="以 InterpolationMethod.LINEAR_RGB 线性渐变" href="../../images/beginGradientFill_interp_linearrgb.jpg"/></entry>
      <entry align="center"><adobeimage alt="以 InterpolationMethod.RGB 线性渐变" href="../../images/beginGradientFill_interp_rgb.jpg"/></entry>
		</row><row>
		<entry align="center"><codeph>InterpolationMethod.LINEAR_RGB</codeph></entry>
		<entry align="center"><codeph>InterpolationMethod.RGB</codeph></entry>
		</row></tbody></tgroup></adobetable>
	
	</apiDesc></apiValueDetail><related-links><link href="flash.display.xml#InterpolationMethod/LINEAR_RGB"><linktext>LINEAR_RGB</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsPath"><apiName>IGraphicsPath</apiName><shortdesc>
	此接口用于定义可用作 flash.display.Graphics 方法和绘图类中的路径参数的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	此接口用于定义可用作 flash.display.Graphics 方法和绘图类中的路径参数的对象。使用此接口的实现器类来创建和管理路径属性数据，并将相同的数据重新用于不同的实例。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:IGraphicsFill"><apiName>IGraphicsFill</apiName><shortdesc>
	此接口用于定义可用作 flash.display.Graphics 方法和绘图类中的填充参数的对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	此接口用于定义可用作 flash.display.Graphics 方法和绘图类中的填充参数的对象。使用此接口的实现器类来创建和管理填充属性数据，并将相同的数据重新用于不同的实例。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#GraphicsStroke/fill"><linktext>flash.display.GraphicsStroke.fill</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:LoaderInfo"><apiName>LoaderInfo</apiName><shortdesc>
 LoaderInfo 类可提供有关已加载的 SWF 文件或图像文件（JPEG、GIF 或 PNG）的信息。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion><Exclude kind="method" name="dispatchEvent"/></asMetadata><asCustoms><internal>Update the places LoaderInfo can be obtained from (playerglobal.as) and double-check loader vs. loadee.
 </internal></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 LoaderInfo 类可提供有关已加载的 SWF 文件或图像文件（JPEG、GIF 或 PNG）的信息。LoaderInfo 对象可用于任何显示对象。提供的信息包括加载进度、加载程序的 URL 和加载内容、媒体的字节总数以及媒体的标示的高度和宽度。
 
 <p>您可以通过以下两种方法访问 LoaderInfo 对象： </p>
 
 <ul>
 
 	<li>flash.display.Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性 -- <codeph>contentLoaderInfo</codeph> 属性始终可用于任何 Loader 对象。对于尚未调用 <codeph>load()</codeph> 或 <codeph>loadBytes()</codeph> 方法，或者尚未充分加载的 Loader 对象，在尝试访问 <codeph>contentLoaderInfo</codeph> 属性的多个属性时，将引发错误。</li>
 
 	<li>显示对象的 <codeph>loaderInfo</codeph> 属性。 </li>
 
 </ul>
 
 <p>Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性提供有关 Loader 对象正在加载的内容的信息，而 DisplayObject 的 <codeph>loaderInfo</codeph> 属性提供有关该显示对象的根 SWF 文件的信息。 </p>
 
 <p>当使用 Loader 对象加载显示对象（如 SWF 文件或位图）时，显示对象的 <codeph>loaderInfo</codeph> 属性与 Loader 对象 (<codeph>DisplayObject.loaderInfo = Loader.contentLoaderInfo</codeph>) 的 <codeph>contentLoaderInfo</codeph> 属性相同。由于 SWF 文件的主类的实例没有 Loader 对象，因此 <codeph>loaderInfo</codeph> 属性是访问 SWF 文件主类实例的 LoaderInfo 的唯一方法。</p>
 
 <p>下图显示了对于 SWF 文件主类实例、Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性以及加载对象的 <codeph>loaderInfo</codeph> 属性，LoaderInfo 对象的不同用法：</p>
 
 <p>
 <adobeimage alt="显示 LoaderInfo 的不同应用情况的图像" href="../../images/loaderInfo_object.jpg"/>
 </p>
 
 <p>在加载操作未完成时，Loader 对象的 <codeph>contentLoaderInfo</codeph> 属性的某些属性不可用。您可以获得某些属性，如 <codeph>bytesLoaded</codeph>、<codeph>bytesTotal</codeph>、<codeph>url</codeph>、<codeph>loaderURL</codeph> 和 <codeph>applicationDomain</codeph>。当 <codeph>loaderInfo</codeph> 对象分派 <codeph>init</codeph> 事件时，您可以访问 <codeph>loaderInfo</codeph> 对象以及加载的图像或 SWF 文件的所有属性。</p>
 
 <p><b>注意：</b>LoaderInfo 对象的所有属性都是只读的。</p>
 
 <p><codeph>EventDispatcher.dispatchEvent()</codeph> 方法不适用于 LoaderInfo 对象。如果在 LoaderInfo 对象上调用 <codeph>dispatchEvent()</codeph>，将引发 IllegalOperationError 异常。</p>
 
 
 
 </apiDesc><example conref="examples\LoaderInfoExample.as"> 下例使用 LoaderInfoExample 类在舞台上显示一幅图像。执行下列步骤可完成此操作：
 <ol>
  <li>属性 <codeph>url</codeph>被创建，该属性是图像的位置和名称。</li>
 
  <li>类构造函数创建一个名为 <codeph>loader</codeph> 的 Loader 对象。</li>
 
  <li><codeph>loader</codeph> 对象将事件侦听器进行实例化，以确保图像正确加载。</li>
 
  <li>构造函数创建一个 URLRequest 对象的新实例 <codeph>request</codeph>，该实例带有传递的 <codeph>url</codeph>，这样，就可以知道文件的名称和位置。</li>
 
  <li>然后，<codeph>request</codeph> 对象被传递给 <codeph>loader</codeph> 对象的 <codeph>load()</codeph> 方法，该方法会将图像加载到显示列表上。</li>
 
 </ol>
 <p><b>重要提示：</b>该示例要求您在编译的 SWF 文件所在的目录中添加一个名为 Image.gif 的文件。使用具有一个适合主 SWF 文件尺寸的区域的图像。</p>
<codeblock>
package {
    import flash.display.Loader;
    import flash.display.LoaderInfo;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.net.URLRequest;

    public class LoaderInfoExample extends Sprite {
        private var url:String = "Image.gif";

        public function LoaderInfoExample() {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.INIT, initHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            var request:URLRequest = new URLRequest(url);
            loader.load(request);
            addChild(loader);
        }

        private function initHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var info:LoaderInfo = LoaderInfo(loader.contentLoaderInfo);
            trace("initHandler: loaderURL=" + info.loaderURL + " url=" + info.url);
        }

        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("ioErrorHandler: " + event);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.display.xml#Loader/content"><linktext>flash.display.Loader.content</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link><link href="flash.display.xml#DisplayObject/loaderInfo"><linktext>flash.display.DisplayObject.loaderInfo</linktext></link></related-links><adobeApiEvent id="flash.display:LoaderInfo_flash.events.HTTPStatusEvent.HTTP_STATUS_httpStatus"><apiName>httpStatus</apiName><shortdesc>
 在通过 HTTP 发出网络请求并且可以检测到 HTTP 状态代码时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.HTTPStatusEvent.HTTP_STATUS</apiEventType><adobeApiEventClassifier>flash.events.HTTPStatusEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在通过 HTTP 发出网络请求并且可以检测到 HTTP 状态代码时分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.UNLOAD_unload"><apiName>unload</apiName><shortdesc>
 每次使用 Loader 对象的 unload() 方法删除已加载对象时，或者当同一 Loader 对象执行第二次加载并且在加载开始之前删除了原始内容时，由 LoaderInfo 对象分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.UNLOAD</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当使用 Loader 对象的 <codeph>unload()</codeph> 方法删除已加载对象时，或者当同一 Loader 对象执行第二次加载并且在加载开始之前删除了原始内容时，由 LoaderInfo 对象分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link><link href="flash.display.xml#Loader/unload()"><linktext>Loader.unload()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 在下载操作过程中收到数据时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在下载操作过程中收到数据时分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.OPEN_open"><apiName>open</apiName><shortdesc>
 在加载操作开始时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.OPEN</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在加载操作开始时分派。
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在发生导致加载操作失败的输入或输出错误时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在发生导致加载操作失败的输入或输出错误时分派。 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.INIT_init"><apiName>init</apiName><shortdesc>
 当已加载的 SWF 文件的属性和方法可供访问并做好使用准备时进行分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.INIT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当已加载的 SWF 文件的属性和方法可供访问并做好使用准备时进行分派。不过，内容可能仍在下载之中。如果存在以下条件，则 LoaderInfo 对象将分派 <codeph>init</codeph> 事件：
 <ul>
     <li>可以访问与加载的对象关联的所有属性和方法以及与 LoaderInfo 对象关联的属性和方法。</li>
     <li>所有子对象的构造函数已完成。</li>
     <li>已执行所加载的 SWF 主时间轴的第一帧中的所有 ActionScript 代码。</li>
 </ul>
 
 <p>例如，在加载影片或动画的第一帧时将分派 <codeph>Event.INIT</codeph>。然后，影片将可供访问并可添加到显示列表中。不过，下载完整的影片可能需要花更长的时间。只有在加载了完整的影片之后才会分派 <codeph>Event.COMPLETE</codeph>。</p>
 
 <p><codeph>init</codeph> 事件始终在 <codeph>complete</codeph> 事件之前。</p>
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.display:LoaderInfo_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 成功加载数据后分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 成功加载数据后分派。也就是说，当已下载所有内容并且已完成加载过程时分派它。<codeph>complete</codeph> 事件始终在 <codeph>init</codeph> 事件之后分派。当该对象已做好访问准备（尽管可能仍在下载内容）时，将分派 <codeph>init</codeph> 事件。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>Loader.load()</linktext></link></related-links></adobeApiEvent><apiOperation id="flash.display:LoaderInfo:getLoaderInfoByDefinition"><apiName>getLoaderInfoByDefinition</apiName><shortdesc>
     返回与定义为对象的 SWF 文件相关联的 LoaderInfo 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiException><apiDesc>调用方不在本地受信任沙箱中运行。
     
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>关联的 LoaderInfo 对象。当在非调试器构建中调用时（或未启用调试时），或当引用的 <codeph>object</codeph> 没有相关联的 LoaderInfo 对象（比如由 AIR 运行时使用的某些对象）时，返回 <codeph>null</codeph>。
	 
	 </apiDesc><apiOperationClassifier>flash.display:LoaderInfo</apiOperationClassifier></apiReturn><apiParam><apiItemName>object</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>要为其获取关联 LoaderInfo 对象的对象。
     </apiDesc></apiParam></apiOperationDef><apiDesc>
     返回与定义为对象的 SWF 文件相关联的 LoaderInfo 对象。
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:LoaderInfo:actionScriptVersion:get"><apiName>actionScriptVersion</apiName><shortdesc>
	 被加载的 SWF 文件的 ActionScript 版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>如果文件未完整下载，不足以检索到所请求的信息。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>如果文件不是 SWF 文件。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 被加载的 SWF 文件的 ActionScript 版本。通过使用 ActionScriptVersion 类中的枚举（如 <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> 和 <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>）来指定语言版本。
	 
	 <p><b>注意：</b>此属性始终具有值 <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph> 或 <codeph>ActionScriptVersion.ACTIONSCRIPT3</codeph>。ActionScript 1.0 和 2.0 都被报告为 <codeph>ActionScriptVersion.ACTIONSCRIPT2</codeph>（版本 2.0）。此属性只对 ActionScript 1.0 和 2.0 与 ActionScript 3.0 进行区分。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ActionScriptVersion"><linktext>flash.display.ActionScriptVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:applicationDomain:get"><apiName>applicationDomain</apiName><shortdesc>
	 加载外部 SWF 文件后，包含在已加载类中的所有 ActionScript 3.0 定义将存储在 applicationDomain 属性中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><internal>Need better description and example.  
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.system:ApplicationDomain</apiValueClassifier><apiException><apiDesc>不允许调用方的此安全沙箱访问此 ApplicationDomain。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 加载外部 SWF 文件后，包含在已加载类中的所有 ActionScript 3.0 定义将存储在 <codeph>applicationDomain</codeph> 属性中。
	 
	 <p>SWF 文件中的所有代码被定义为存在于应用程序域中。主应用程序就在当前的应用程序域中运行。系统域包含所有应用程序域，包括当前域和由 Flash Player 或 Adobe AIR 使用的所有类。</p>
	 
	 <p>所有应用程序域（系统域除外）都有关联的父域。主应用程序的 <codeph>applicationDomain</codeph> 的父域为系统域。已加载的类仅在其父级中没有相关定义时才进行定义。不能用较新的定义覆盖已加载的类定义。</p>
	 
	 <p>有关应用程序域的用法示例，请参阅<i>《ActionScript 3.0 编程》</i>中的“客户端系统环境”一章。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.system.xml#ApplicationDomain"><linktext>flash.system.ApplicationDomain</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:bytes:get"><apiName>bytes</apiName><shortdesc>
	 与 LoaderInfo 对象相关联的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9.0.115.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier><apiException><apiDesc>如果由于安全限制的缘故而阻止访问此 API 的对象访问加载的对象。例如，如果 Loader 对象尝试访问 <codeph>contentLoaderInfo.content</codeph> 属性，但未向其授予访问加载的内容的安全权限，则可能会出现此情况。
	 
	 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
     </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 与 LoaderInfo 对象相关联的字节数。 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesLoaded:get"><apiName>bytesLoaded</apiName><shortdesc>
	 媒体已加载的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 媒体已加载的字节数。如果此数字与 <codeph>bytesTotal</codeph> 的值相等，则会加载所有字节。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:bytesTotal:get"><apiName>bytesTotal</apiName><shortdesc>
	 整个媒体文件中压缩的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	 整个媒体文件中压缩的字节数。
	 
	 <p>在此 LoaderInfo 对象相应的 Loader 对象分派第一个 <codeph>progress</codeph> 事件之前，<codeph>bytesTotal</codeph> 为 0。在该 Loader 对象分派第一个 <codeph>progress</codeph> 事件之后，<codeph>bytesTotal</codeph> 反映的是要下载的实际字节数。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.events.xml#ProgressEvent"><linktext>flash.events.ProgressEvent</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
	 表示内容（子级）对加载者（父级）的信任关系。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> 文件未完整下载而不足以检索到所请求的信息时引发。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 表示内容（子级）对加载者（父级）的信任关系。如果子项允许父项访问，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。如果子对象已调用 <codeph>allowDomain()</codeph> 方法向父域授予权限，或者在子域中加载了向父域授予权限的 URL 策略，则将此属性设置为 <codeph>true</codeph>。如果子级和父级在同一域中，则此属性设置为 <codeph>true</codeph>。
	 
	 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:childSandboxBridge:get"><apiName>childSandboxBridge</apiName><shortdesc>
	 一个对象，它可以通过所加载内容的代码进行设置以公开可以由 Loader 对象的沙箱中的代码访问的属性和方法。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>只有所加载内容的沙箱中的内容可以设置此属性。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 一个对象，它可以通过所加载内容的代码进行设置以公开可以由 Loader 对象的沙箱中的代码访问的属性和方法。此<i>沙箱桥</i> 使来自非应用程序域的内容对 AIR 应用程序沙箱中的脚本具有受控的访问权，反之亦然。沙箱桥充当沙箱之间的通道，在应用程序安全沙箱和非应用程序安全沙箱之间提供显式交互。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/parentSandboxBridge"><linktext>parentSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:content:get"><apiName>content</apiName><shortdesc>
	 与此 LoaderInfo 对象关联的已加载对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:DisplayObject</apiValueClassifier><apiException><apiDesc>如果由于安全限制的缘故而阻止访问此 API 的对象访问加载的对象。例如，如果 Loader 对象尝试访问 <codeph>contentLoaderInfo.content</codeph> 属性，但未向其授予访问加载的内容的安全权限，则可能会出现此情况。
	 
	 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 与此 LoaderInfo 对象关联的已加载对象。 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:contentType:get"><apiName>contentType</apiName><shortdesc>
	 被加载文件的 MIME 类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 被加载文件的 MIME 类型。如果所加载的文件内容不足以确定类型，则该值为 <codeph>null</codeph>。以下列表给出了可能的值：
	 
	 <ul>
	 	
	 	<li><codeph>"application/x-shockwave-flash"</codeph></li>
	 
	 	<li><codeph>"image/jpeg"</codeph></li>
	 
	 	<li><codeph>"image/gif"</codeph></li>
	 
	 	<li><codeph>"image/png"</codeph></li>
	 
	 </ul>
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:frameRate:get"><apiName>frameRate</apiName><shortdesc>
	 被加载的 SWF 文件的标示的帧速率，以每秒帧数为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier><apiException><apiDesc>如果文件未完整下载，不足以检索到所请求的信息。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>如果文件不是 SWF 文件。 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 被加载的 SWF 文件的标示的帧速率，以每秒帧数为单位。此数字通常是整数，但并不需要是整数。
	 
	 <p>此值可能与使用时的实际帧速率不同。Flash Player 或 Adobe AIR 在任何时候为所有加载的 SWF 文件只使用单个帧速率，此帧速率由主 SWF 文件的标称帧速率确定。此外，根据硬件、声音同步和其它因素，可能无法达到主帧速率。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:height:get"><apiName>height</apiName><shortdesc>
	 加载文件的标示的高度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>如果文件未完整下载，不足以检索到所请求的信息。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 加载文件的标示的高度。此值可能与所显示内容的实际高度不同，因为被加载的内容或其父显示对象可能被缩放。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loader:get"><apiName>loader</apiName><shortdesc>
	 与此 LoaderInfo 对象关联的 Loader 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Loader</apiValueClassifier><apiException><apiDesc>如果由于安全限制的缘故而阻止访问此 API 的对象访问 Loader 对象。例如，如果加载的 SWF 文件尝试访问其 <codeph>loaderInfo.loader</codeph> 属性，但未向其授予访问正在加载的 SWF 文件的安全权限，则可能会出现此情况。
	 
	 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 与此 LoaderInfo 对象关联的 Loader 对象。如果此 LoaderInfo 对象是 SWF 文件的主类实例的 <codeph>loaderInfo</codeph> 属性，则没有关联的 Loader 对象。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:loaderURL:get"><apiName>loaderURL</apiName><shortdesc>
	 SWF 文件的 URL，该 SWF 文件启动对此 LoaderInfo 对象所描述的媒体的加载。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 SWF 文件的 URL，该 SWF 文件启动对此 LoaderInfo 对象所描述的媒体的加载。对于 SWF 文件的主类的实例，此 URL 与 SWF 文件自己的 URL 相同。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parameters:get"><apiName>parameters</apiName><shortdesc>
	 包含名称-值对的对象，表示为被加载的 SWF 文件提供的参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
	 包含名称-值对的对象，表示为被加载的 SWF 文件提供的参数。
	 
	 <p>可以使用 <codeph>for-in</codeph> 循环来提取 <codeph>parameters</codeph> 对象中的所有名称和值。</p>
	 
	 <p>参数的两个源为：主 SWF 文件的 URL 中的查询字符串和 <codeph>FlashVars</codeph> HTML 参数（这只影响主 SWF 文件）的值。</p>
	 
	 <p><codeph>parameters</codeph> 属性替换了 ActionScript 1.0 和 2.0 提供 SWF 文件参数作为主时间轴的技术。</p>
	 
	 <p>Loader 对象（该对象包含使用 ActionScript 1.0 或 2.0 的 SWF 文件）的 <codeph>parameters</codeph> 属性的值为 null。只有对于包含使用 ActionScript 3.0 的 SWF 文件的 Loader 对象，该值才非 null。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc>
	 表示加载者（父级）对内容（子级）的信任关系。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> 文件未完整下载而不足以检索到所请求的信息时引发。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 表示加载者（父级）对内容（子级）的信任关系。如果父项允许子项访问，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。如果父对象调用了 <codeph>allowDomain()</codeph> 方法向子域授予权限，或者在父域中加载了向子域授予权限的 URL 策略文件，则将此属性设置为 <codeph>true</codeph>。如果子级和父级在同一域中，则此属性设置为 <codeph>true</codeph>。
	 
	 <p>有关详细信息，请参阅<i>《ActionScript 3.0 编程》</i>中的“Flash Player 安全性”一章。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:parentSandboxBridge:get"><apiName>parentSandboxBridge</apiName><shortdesc>
	 一个对象，它可以在 Loader 对象的沙箱中通过代码进行设置以公开可以由所加载内容的代码访问的属性和方法。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier><apiException><apiDesc>只有 Loader 对象的沙箱中的内容可以设置此属性。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 一个对象，它可以在 Loader 对象的沙箱中通过代码进行设置以公开可以由所加载内容的代码访问的属性和方法。此<i>沙箱桥</i> 使来自非应用程序域的内容对 AIR 应用程序沙箱中的脚本具有受控的访问权，反之亦然。沙箱桥充当沙箱之间的通道，在应用程序安全沙箱和非应用程序安全沙箱之间提供显式交互。 
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#LoaderInfo/childSandboxBridge"><linktext>childSandboxBridge</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:sameDomain:get"><apiName>sameDomain</apiName><shortdesc>
	 表示加载者和内容之间的域关系：如果它们具有相同的原始域，则为 true；否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier><apiException><apiDesc> 文件未完整下载而不足以检索到所请求的信息时引发。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 表示加载者和内容之间的域关系：如果它们具有相同的原始域，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:sharedEvents:get"><apiName>sharedEvents</apiName><shortdesc>
	 EventDispatcher 实例，可用于跨安全边界交换事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.events:EventDispatcher</apiValueClassifier></apiValueDef><apiDesc>
	 EventDispatcher 实例，可用于跨安全边界交换事件。即使 Loader 对象和加载的内容源于彼此不信任的安全域，两者仍然可以访问 <codeph>sharedEvents</codeph> 并通过此对象发送和接收事件。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LoaderInfo:swfVersion:get"><apiName>swfVersion</apiName><shortdesc>
	 已加载的 SWF 文件的文件格式版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier><apiException><apiDesc>如果文件未完整下载，不足以检索到所请求的信息。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException><apiException><apiDesc>如果文件不是 SWF 文件。
	 
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 已加载的 SWF 文件的文件格式版本。使用 SWFVersion 类（如 <codeph>SWFVersion.FLASH7</codeph> 和 <codeph>SWFVersion.FLASH9</codeph>）中的枚举指定文件格式。
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#SWFVersion"><linktext>flash.display.SWFVersion</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:url:get"><apiName>url</apiName><shortdesc>
	 所加载媒体的 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 所加载媒体的 URL。
	 
	 <p>在此 LoaderInfo 对象的对应 Loader 对象分派第一个 <codeph>progress</codeph> 事件之前，<codeph>url</codeph> 属性的值可能只反映在对 Loader 对象的 <codeph>load()</codeph> 方法的调用中指定的初始 URL。在第一个 <codeph>progress</codeph> 事件之后，<codeph>url</codeph> 属性将在解析了任何重定向和相对 URL 后反映媒体的最终 URL。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Loader/load()"><linktext>flash.display.Loader.load()</linktext></link></related-links></apiValue><apiValue id="flash.display:LoaderInfo:width:get"><apiName>width</apiName><shortdesc>
	 被加载内容的标示的宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier><apiException><apiDesc>如果文件未完整下载，不足以检索到所请求的信息。
	 </apiDesc><apiItemName>Error</apiItemName><apiOperationClassifier>Error</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 被加载内容的标示的宽度。此值可能与所显示内容的实际宽度不同，因为被加载的内容或其父显示对象可能被缩放。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageQuality"><apiName>StageQuality</apiName><shortdesc>
StageQuality 类为 Stage.quality 属性提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageQuality 类为 <codeph>Stage.quality</codeph> 属性提供值。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/quality"><linktext>flash.display.Stage.quality</linktext></link></related-links><apiValue id="flash.display:StageQuality:BEST"><apiName>BEST</apiName><shortdesc>
指定极高呈现品质：使用 4 x 4 像素网格消除图形锯齿，并且始终对位图进行平滑处理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>best</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定极高呈现品质：使用 4 x 4 像素网格消除图形锯齿，并且始终对位图进行平滑处理。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:HIGH"><apiName>HIGH</apiName><shortdesc>
指定高呈现品质：使用 4 x 4 像素网格消除图形锯齿，并且如果影片是静态的，则还对位图进行平滑处理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>high</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定高呈现品质：使用 4 x 4 像素网格消除图形锯齿，并且如果影片是静态的，则还对位图进行平滑处理。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:LOW"><apiName>LOW</apiName><shortdesc>
指定低呈现品质：不消除图形的锯齿，不对位图进行平滑处理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>low</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定低呈现品质：不消除图形的锯齿，不对位图进行平滑处理。Adobe AIR 中不支持此设置。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageQuality:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
指定中等呈现品质：使用 2 x 2 像素网格消除图形锯齿，但不对位图进行平滑处理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>medium</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定中等呈现品质：使用 2 x 2 像素网格消除图形锯齿，但不对位图进行平滑处理。此设置适用于不包含文本的影片。Adobe AIR 中不支持此设置。

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 使用 BitmapData 类可以处理 Bitmap 对象的位图图像的数据（像素）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>允许使用 Bitmap 对象的位图数据。
 
 </apiTipText></apiTipTexts><apiBaseInterface>flash.display:IBitmapDrawable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 BitmapData 类可以处理 <ph platform="actionscript">Bitmap 对象</ph>的<ph platform="javascript">位图图像</ph>的数据（像素）。可以使用 BitmapData 类的方法创建任意大小的透明或不透明位图图像，并在运行时采用多种方式操作这些图像。<ph platform="actionscript">也可以访问使用 <codeph>flash.display.Loader</codeph> 类加载的位图图像的 BitmapData。</ph> 
 
 <p platform="actionscript">此类允许您将位图呈现操作与 Flash Player 的内部显示更新例程分隔开来。通过直接操作 BitmapData 对象，您可以创建复杂的图像，不会因连续重新绘制矢量数据的内容而产生每帧开销。</p>
 
 <p platform="actionscript">BitmapData 类的方法支持通过可用于非位图显示对象的滤镜无法得到的效果。</p>
 
 <p>BitmapData 对象包含像素数据的数组。此数据可以表示完全不透明的位图，或表示包含 Alpha 通道数据的透明位图。以上任一类型的 BitmapData 对象都作为 32 位整数的缓冲区进行存储。每个 32 位整数确定位图中单个像素的属性。</p>
 
 <p>每个 32 位整数都是四个 8 位通道值（从 0 到 255）的组合，这些值描述像素的 Alpha 透明度以及红色、绿色、蓝色 (ARGB) 值。（对于 ARGB 值，最高有效字节代表 Alpha 通道值，其后的有效字节分别代表红色、绿色和蓝色通道值。）</p>
 
 <p>将这四个通道（Alpha、红色、绿色和蓝色）与 <codeph>BitmapData.copyChannel()</codeph> 方法或 <codeph>DisplacementMapFilter.componentX</codeph> 及 <codeph>DisplacementMapFilter.componentY</codeph> 属性一起使用时，这些通道以数字形式表示，并且这些数字在 BitmapDataChannel 类中由以下常量表示：</p>
 
 <ul>
 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
  <li><codeph>BitmapDataChannel.RED</codeph></li>
 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
</ul>
 
 <p platform="actionscript">通过使用 Bitmap 对象的 <codeph>bitmapData</codeph> 属性，可以将 BitmapData 对象附加到 Bitmap 对象。</p>
 
 <p platform="actionscript">可以使用 <codeph>Graphics.beginBitmapFill()</codeph> 方法用 BitmapData 对象填充 Graphics 对象。</p>
 
 <p>在 AIR 运行时中，DockIcon、Icon、InteractiveIcon 和 SystemTrayIcon 类中的每个类都包括一个 <codeph>bitmaps</codeph> 属性，该属性是定义图标的位图图像的 BitmapData 对象的数组。</p>
 
 <p>在 AIR 1.5 和 Flash Player 10 中，BitmapData 对象的最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果 BitmapData 对象的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。</p>
 
 <p>如果 BitmapData 对象无效（例如，如果它的 <codeph>height == 0</codeph> 且 <codeph>width == 0</codeph>），或者已通过 dispose() 处理了该对象，则对 BitmapData 对象的任何方法或属性的调用都会引发 ArgumentError 错误。 </p>
 
 </apiDesc><example conref="examples\BitmapDataExample.as"> 下例使用 BitmapDataExample 类将图像 Image.gif 加载到位于默认位置 (0, 0) 的 DisplayObject 中。然后，将 Image.gif 的副本放在原图像的右边，它使用 <codeph>threshold()</codeph> 方法。此任务是使用以下步骤完成的：
 <ol>
     <li>创建 <codeph>url</codeph> 属性，它是图像文件的位置和名称</li>
     <li>类构造函数创建一个 Loader 对象，该对象随后对一个事件侦听器进行实例化，该事件侦听器的分派是在 <codeph>completeHandler()</codeph> 方法完成图像操作以后进行的。</li>
        <li>然后，<codeph>request</codeph>URLRequest 对象被传递给 <codeph>loader.load()</codeph>，该方法使用显示对象将图像加载到内存中。</li>
     <li>图像随后将被放在显示列表中，后者将图像显示在屏幕上，坐标为 <i>x = 0, y = 0</i>。</li>
     <li>然后，<codeph>completeHandler()</codeph> 方法执行以下操作： 
     <ul>
         <li>创建另一个 Loader 对象以及使用 Loader 对象初始化的 Bitmap 对象。</li>
         <li>创建第二个 Bitmap 对象 <codeph>duplicate</codeph>，该对象再调用 <codeph>duplicateImage()</codeph> 方法，该方法创建原始图像的副本。 </li>
         <li>创建一个 BitmapData 对象，该对象将被分配给 <codeph>duplicate</codeph> 对象的 BitmapData 对象。</li>
         <li>创建一个与原始图像具有相同的坐标、宽度和高度的新的 Rectangle 对象。</li>
         <li>创建一个新的 Point 对象，其默认为 <i>x = 0, y = 0</i>。</li>
         <li>创建以下变量：
         <ul>
             <li><codeph>operation</codeph> -- 当阈值大于或等于原始值时应用新颜色。</li>
             <li><codeph>threshold</codeph> -- 与每个像素相比较的值（在本例中是 Alpha 值为 0xCC 的浅灰色）。 </li>
             <li><codeph>color</codeph> -- 对通过阈值测试的像素设置的颜色，在本例中为纯黄色。</li>
             <li><codeph>mask</codeph> -- 正好相反的颜色（透明的蓝色）。</li>
             <li><codeph>copySource</codeph> -- 设置为 <codeph>false</codeph>，指示阈值未通过测试时不复制像素值。该值没有意义，因为图像是重复的，并且只更改通过了阈值测试的像素。</li>
      </ul></li>
         <li>使用前面的变量调用 <codeph>threshold()</codeph> 方法。得到的阈值计算式如下所示：<codeph>if (current pixel Value &amp; 0x000000FF) >= (0xCCCCCCCC &amp; 0x000000FF) then set pixel to 0xFFFFFF00</codeph>。 </li>
  </ul></li>
 </ol>
 <p> <b>注意：</b>
 <ul>
     <li>您需要编译 SWF 文件，并将“本地回放安全性”设置为“只访问本地文件”。
 </li>
     <li>此示例要求将名为 Image.gif 的文件与您的 SWF 文件放在同一目录中。
 </li>
  <li>建议使用宽度最大约为 80 像素的图像。 </li>
 </ul>
 </p>
<codeblock>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = ">=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</codeblock></example><example conref="examples\BitmapDataExample2.as"/></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/bitmapData"><linktext>flash.display.Bitmap.bitmapData</linktext></link><link href="flash.desktop.xml#DockIcon/bitmaps"><linktext>flash.desktop.DockIcon.bitmaps</linktext></link><link href="flash.display.xml#Graphics/beginBitmapFill()"><linktext>flash.display.Graphics.beginBitmapFill()</linktext></link><link href="flash.desktop.xml#Icon/bitmaps"><linktext>flash.desktop.Icon.bitmaps</linktext></link><link href="flash.desktop.xml#InteractiveIcon/bitmaps"><linktext>flash.desktop.InteractiveIcon.bitmaps</linktext></link><link href="flash.display.xml#Loader"><linktext>flash.display.Loader</linktext></link><link href="flash.desktop.xml#SystemTrayIcon/bitmaps"><linktext>flash.desktop.SystemTrayIcon.bitmaps</linktext></link></related-links><apiConstructor id="flash.display:BitmapData:BitmapData"><apiName>BitmapData</apiName><shortdesc>
 	 创建一个具有指定的宽度和高度的 BitmapData 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc>宽度和/或高度超过最大尺寸。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>width</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>位图图像的宽度，以像素为单位。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>height</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>位图图像的高度，以像素为单位。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>transparent</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>指定位图图像是否支持每个像素具有不同的透明度。默认值为 <codeph>true</codeph>（透明）。要创建完全透明的位图，请将 <codeph>transparent</codeph> 参数的值设置为 <codeph>true</codeph>，将 <codeph>fillColor</codeph> 参数的值设置为 0x00000000（或设置为 0）。将 <codeph>transparent</codeph> 属性设置为 <codeph>false</codeph> 可以略微提升呈现性能。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>用于填充位图图像区域的 32 位 ARGB 颜色值。默认值为 0xFFFFFFFF（纯白色）。
	 
 	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 	 创建一个具有指定的宽度和高度的 BitmapData 对象。如果为 <codeph>fillColor</codeph> 参数指定一个值，则位图中的每个像素都将设置为该颜色。
	 
	 <p>默认情况下，将位图创建为透明位图，除非您为 <codeph>transparent</codeph> 参数传递值 <codeph>false</codeph>。创建了不透明位图后，将无法将其更改为透明位图。不透明位图中的每个像素仅使用 24 位的颜色通道信息。如果将位图定义为透明，则每个像素将使用 32 位的颜色通道信息，其中包括 Alpha 透明度通道。</p>
	 
	 <p>在 AIR 1.5 和 Flash Player 10 中，BitmapData 对象的最大宽度或高度为 8,191 像素，并且像素总数不能超过 16,777,215 像素。（因此，如果 BitmapData 对象的宽度为 8,191 像素，则其高度只能为 2,048 像素。）在 Flash Player 9 及早期版本和 AIR 1.1 及早期版本中，高度最大为 2,880 像素，宽度最大为 2,880 像素。如果指定的宽度值或高度值大于 2880，则不会创建新实例。</p>
	 
	 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:BitmapData:applyFilter"><apiName>applyFilter</apiName><shortdesc>
	 取得一个源图像和一个滤镜对象，并生成过滤的图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、destPoint 或滤镜为空。
 	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>BitmapData 对象的透明度与滤镜操作不兼容。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个数字，指示是否成功应用了滤镜。如果返回 0，则说明已成功应用了滤镜。如果返回一个负数，则说明在应用该滤镜的过程中出现了错误。
	 
	 </apiDesc><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要使用的输入位图图像。源图像可以是另一个 BitmapData 对象，也可以引用当前 BitmapData 实例。

	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>定义要用作输入的源图像区域的矩形。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标图像（当前 BitmapData 实例）中与源矩形的左上角对应的点。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>用于执行过滤操作的滤镜对象。每种滤镜都有某些要求，如下所示：
	 
	 <ul><li><b>BlurFilter</b> — 此滤镜可使用不透明或透明的源图像和目标图像。如果这两种图像的格式不匹配，则在过滤过程中生成的源图像副本将与目标图像的格式匹配。</li>
	 
	 <li><b>BevelFilter、DropShadowFilter、GlowFilter、ChromeFilter</b> — 这些滤镜的目标图像必须是透明图像。调用 DropShadowFilter 或 GlowFilter 会创建包含投影或发光的 Alpha 通道数据的图像。它不会在目标图像上创建投影。如果将这些滤镜中的任何滤镜用于不透明的目标图像，将会引发异常.</li>
	 
	 <li><b>ConvolutionFilter</b> — 此滤镜可使用不透明或透明的源图像和目标图像。</li>
	 
	 <li><b>ColorMatrixFilter</b> — 此滤镜可使用不透明或透明的源图像和目标图像。</li>
	 
	 <li><b>DisplacementMapFilter</b> — 此滤镜可使用不透明或透明的源图像和目标图像，但源图像和目标图像的格式必须相同。</li></ul>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 取得一个源图像和一个滤镜对象，并生成过滤的图像。
	 
	 <p>此方法依赖于内置滤镜对象的行为，这些对象确定受输入源矩形影响的目标矩形。</p>
	 
	 <p>应用滤镜后，结果图像可能会大于输入图像。例如，如果使用 BlurFilter 类来模糊源矩形 (50,50,100,100)，并且目标点为 (10,10)，则在目标图像中更改的区域将会由于该模糊处理而大于 (10,10,60,60)。这会在 <codeph>applyFilter()</codeph> 调用过程中在内部发生。</p>
	 
	 <p>如果 <codeph>sourceBitmapData</codeph> 参数的 <codeph>sourceRect</codeph> 参数是内部区域，如 200 x 200 图像中的 (50,50,100,100)，则滤镜会使用 <codeph>sourceRect</codeph> 参数外部的源像素来生成目标矩形。</p>
	 
	 <p>如果 BitmapData 对象和指定为 <codeph>sourceBitmapData</codeph> 参数的对象是同一对象，应用程序将使用该对象的临时副本来执行滤镜。为了获得最佳性能，请避免这种情况。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.applyFilter.1.as"> 下例演示如何将模糊滤镜应用于 BitmapData 实例：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.filters.xml#BevelFilter"><linktext>flash.filters.BevelFilter</linktext></link><link href="flash.filters.xml#BlurFilter"><linktext>flash.filters.BlurFilter</linktext></link><link href="flash.filters.xml#ColorMatrixFilter"><linktext>flash.filters.ColorMatrixFilter</linktext></link><link href="flash.filters.xml#ConvolutionFilter"><linktext>flash.filters.ConvolutionFilter</linktext></link><link href="flash.filters.xml#DisplacementMapFilter"><linktext>flash.filters.DisplacementMapFilter</linktext></link><link href="flash.filters.xml#DropShadowFilter"><linktext>flash.filters.DropShadowFilter</linktext></link><link href="flash.filters.xml#GlowFilter"><linktext>flash.filters.GlowFilter</linktext></link><link href="flash.display.xml#DisplayObject/filters"><linktext>flash.display.DisplayObject.filters</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:clone"><apiName>clone</apiName><shortdesc>
	 返回一个新的 BitmapData 对象，它是对原始实例的克隆，包含与原始实例所含位图完全相同的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个新的 BitmapData 对象，它与原始对象相同。
	 
	 </apiDesc><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier></apiReturn><apiTipTexts><apiTipText>返回一个新的 BitmapData 对象，包含与原始位图完全相同的副本。

	  

	  </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回一个新的 BitmapData 对象，它是对原始实例的克隆，包含与原始实例所含位图完全相同的副本。
	 
	 </apiDesc><example conref="examples\BitmapData.clone.1.as"> 下例演示如何克隆 BitmapData 实例，并演示在修改克隆的 BitmapData 实例时，原始实例保持不变：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:colorTransform"><apiName>colorTransform</apiName><shortdesc>
	 使用 ColorTransform 对象调整位图图像的指定区域中的颜色值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>rect 或 colorTransform 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>一个 Rectangle 对象，它定义在其中应用 ColorTransform 对象的图像区域。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiDesc>一个 ColorTransform 对象，它描述要应用的颜色转换值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用 <codeph>ColorTransform</codeph> 对象调整位图图像的指定区域中的颜色值。如果矩形与位图图像的边界匹配，则此方法将转换整个图像的颜色值。
	 
	 </apiDesc><example conref="examples\BitmapData.colorTransform.1.as"> 下例演示如何将颜色转换应用于 BitmapData 对象的左半部分（矩形）：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:compare"><apiName>compare</apiName><shortdesc>
	 
	 比较两个 BitmapData 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>otherBitmapData 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果两个 BitmapData 对象的尺寸（宽度和高度）相同，则方法将返回一个新的 BitmapData 对象，其中包含两个对象之间的差异（请参阅主要讨论内容）。如果这两个 BitmapData 对象相同，则该方法返回数字 0。如果这两个 BitmapData 对象的宽度不相等，则该方法返回数字 -3。如果这两个 BitmapData 对象的高度不相等，则该方法返回数字 -4。 
	 
	 </apiDesc><apiOperationClassifier>Object</apiOperationClassifier></apiReturn><apiParam><apiItemName>otherBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要与源 BitmapData 对象比较的 BitmapData 对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 
	 比较两个 BitmapData 对象。如果两个 BitmapData 对象的尺寸（宽度和高度）相同，该方法将返回一个新的 BitmapData 对象，其中的每个像素都是两个源对象中的像素之间的“差”：
	 
	 <ul>
	 
	 	<li>如果两个像素相等，则差异像素为 0x00000000。 </li>
	 
	 	<li>如果两个像素具有不同的 RGB 值（忽略 Alpha 值），则差异像素为 0xRRGGBB，其中 RR/GG/BB 分别是红色、绿色和蓝色通道之间的个别差异值（源对象中的像素值减去 <codeph>otherBitmapData</codeph> 对象中的像素值）。本例中忽略了 Alpha 通道差异。 </li> 
	 
	 	<li>如果只有 Alpha 通道值不同，则像素值为 0x<i>ZZ</i>FFFFFF，其中 <i>ZZ</i> 是 Alpha 值差异（源对象中的 Alpha 值减去 <codeph>otherBitmapData</codeph> 对象中的 Alpha 值）。</li>
	 
	 </ul>
	 
	 <p>例如，考虑下面两个 BitmapData 对象：</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
     </codeblock>
	 
	 <p><b>注意：</b>用于填充这两个 BitmapData 对象的颜色具有略微不同的 RGB 值（0xFF0000 和 0xFFAA00）。<codeph>compare()</codeph> 方法的结果是一个新的 BitmapData 对象，其中的每个像素都显示两个位图之间 RGB 值的差异。</p>
	 
	 <p>以下面两个 BitmapData 对象为例，其中 RGB 颜色相同，但 Alpha 值不同。</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
	 trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(50, 50, true, 0xFFFFAA00);
	 var bmd2 = new air.BitmapData(50, 50, true, 0xCCFFAA00);
	 var diffBmpData = bmd1.compare(bmd2);
	 </codeblock>
	 
	 <p><codeph>compare()</codeph> 方法的结果是一个新的 BitmapData 对象，其中的每个像素都显示两个位图之间 Alpha 值的差异。</p>
	 
	 <p>如果 BitmapData 对象相同（宽度、高度和像素值都相同），则方法返回数字 0。</p>
	 
	 <p>如果这两个 BitmapData 对象的宽度不相等，则该方法返回数字 -3。 </p>
	 
	 <p>如果 BitmapData 对象的高度不相等，但宽度相同，则方法返回数字 -4。</p>
	 
	 <p>以下示例比较两个具有不同宽度（50 和 60）的 Bitmap 对象：</p>
	 
	 <codeblock platform="actionscript">
	 var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 <codeblock platform="javascript">
	 var bmd1 = new air.BitmapData(100, 50, false, 0xFFFF0000);
	 var bmd2 = new air.BitmapData(100, 60, false, 0xFFFFAA00);
	 trace(bmd1.compare(bmd2)); // -4
	 </codeblock>
	 
	 </apiDesc><example conref="examples\BitmapData.compare.1.as"> 下例显示通过比较两个尺寸相同的 BitmapData 对象而得到的 BitmapData 对象中的像素值：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:copyChannel"><apiName>copyChannel</apiName><shortdesc>
	 将数据从另一个 BitmapData 对象或当前 BitmapData 对象的一个通道传输到当前 BitmapData 对象的某个通道中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect 或 destPoint 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要使用的输入位图图像。源图像可以是另一个 BitmapData 对象，也可以指当前 BitmapData 对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>源 Rectangle 对象。若只想复制位图内较小区域中的通道数据，请指定一个小于 BitmapData 对象整体大小的源矩形。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标 Point 对象，它表示将要在其中放置新通道数据的矩形区域的左上角。若只想将通道数据从目标图像中的一个区域复制到其它区域，请指定一个 (0,0) 以外的点。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>源通道。使用来自 BitmapDataChannel 类（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph>、<codeph>BitmapDataChannel.ALPHA</codeph>）的值。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destChannel</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>目标通道。使用来自 BitmapDataChannel 类（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph>、<codeph>BitmapDataChannel.ALPHA</codeph>）的值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将数据从另一个 BitmapData 对象或当前 BitmapData 对象的一个通道传输到当前 BitmapData 对象的某个通道中。目标 BitmapData 对象的其它通道中的所有数据都将被保留。
	 
	 <p>源通道值和目标通道值可以是下列值之一： </p>
	 <ul>
	 <li><codeph>BitmapDataChannel.RED</codeph></li>
	 <li><codeph>BitmapDataChannel.GREEN</codeph></li>
	 <li><codeph>BitmapDataChannel.BLUE</codeph></li>
	 <li><codeph>BitmapDataChannel.ALPHA</codeph></li>
	 </ul>

	 
	 </apiDesc><example conref="examples\BitmapData.copyChannel.1.as"> 下例演示如何将 BitmapData 对象中的红色通道复制到一个在 20 x 20 像素的自身区域中的蓝色通道。
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:copyPixels"><apiName>copyPixels</apiName><shortdesc>
	 为没有拉伸、旋转或色彩效果的图像之间的像素处理提供一个快速例程。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect 和 destPoint 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要从中复制像素的输入位图图像。源图像可以是另一个 BitmapData 实例，也可以指当前 BitmapData 实例。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>定义要用作输入的源图像区域的矩形。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标点，它表示将在其中放置新像素的矩形区域的左上角。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiData>null</apiData><apiDesc>第二个 Alpha BitmapData 对象源。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>alphaPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>Alpha BitmapData 对象源中与 <codeph>sourceRect</codeph> 参数的左上角对应的点。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mergeAlpha</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>要使用 Alpha 通道，请将该值设置为 <codeph>true</codeph>。要复制不含 Alpha 通道的像素，请将该值设置为 <codeph>false</codeph>。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 为没有拉伸、旋转或色彩效果的图像之间的像素处理提供一个快速例程。此方法在目标 BitmapData 对象的目标点将源图像的矩形区域复制为同样大小的矩形区域。
	 
	 <p>如果包括 <codeph>alphaBitmap</codeph> 参数和 <codeph>alphaPoint</codeph> 参数，则可以将另一个图像用作源图像的 Alpha 源。如果源图像具有 Alpha 数据，则这两组 Alpha 数据都用于将源图像中的像素组合到目标图像中。<codeph>alphaPoint</codeph> 参数是 Alpha 图像中与源矩形左上角对应的点。源图像和 Alpha 图像交叉区域之外的任何像素都不会被复制到目标图像。</p>
	 
	 <p><codeph>mergeAlpha</codeph> 属性控制在将透明图像复制到另一透明图像时是否使用 Alpha 通道。要复制含有 Alpha 通道数据的像素，请将 <codeph>mergeAlpha</codeph> 属性设置为 <codeph>true</codeph>。默认情况下，<codeph>mergeAlpha</codeph> 属性为 <codeph>false</codeph>。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.copyPixels.1.as"> 下例演示如何将一个 BitmapData 对象中 20 x 20 像素的区域内的像素复制到另一个 BitmapData 对象：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:dispose"><apiName>dispose</apiName><shortdesc>
	 释放用来存储 BitmapData 对象的内存。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 释放用来存储 BitmapData 对象的内存。 
	 
	 <p>对图像调用 <codeph>dispose()</codeph> 方法时，该图像的宽度和高度将设置为 0。对此 BitmapData 实例的方法或属性的所有后续调用都将失败，并引发异常。 </p>
	 <p><codeph>BitmapData.dispose()</codeph> 立即释放由实际的位图数据占用的内存（一个位图最多可使用 64 MB 的内存）。使用 <codeph>BitmapData.dispose()</codeph> 后，BitmapData 对象不再可用，而且，如果对 BitmapData 对象调用函数，Flash 运行时将引发异常。但是，<codeph>BitmapData.dispose()</codeph> 不会将 BitmapData 对象（大约 128 个字节）作为垃圾回收；由实际的 BitmapData 对象占用的内存在垃圾回收器收集 BitmapData 对象时释放。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.dispose.1.as"> 下例显示在调用 <codeph>dispose()</codeph> 方法后调用 BitmapData 对象的方法所产生的结果（引发异常）：
<codeblock>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.system.xml#System/gc()"><linktext>flash.system.System.gc()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:draw"><apiName>draw</apiName><shortdesc>
	 使用 Flash Player 或 AIR 矢量渲染器在位图图像上绘制 source 显示对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>source</codeph> 参数不是 BitmapData 或 DisplayObject 对象。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc><codeph>source</codeph> 对象及其所有子对象（如果是 Sprite 或 MovieClip 对象）与调用方不来自同一个域，或者不在调用方可通过调用 <codeph>Security.allowDomain()</codeph> 方法访问的内容中。此限制不适用于应用程序安全沙箱中的 AIR 内容。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>源为空或不是有效的 IBitmapDrawable 对象。
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>flash.display:IBitmapDrawable</apiOperationClassifier><apiDesc>要绘制到 BitmapData 对象的显示对象或 BitmapData 对象。（DisplayObject 和 BitmapData 类实现 IBitmapDrawable 接口。）
	 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 Matrix 对象，用于缩放、旋转位图或转换位图的坐标。如果不想将矩阵转换应用于图像，请将此参数设置为恒等矩阵（使用默认 <codeph>new Matrix()</codeph> 构造函数创建），或传递 <codeph>null</codeph> 值。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>colorTransform</apiItemName><apiOperationClassifier>flash.geom:ColorTransform</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 ColorTransform 对象，用于调整位图的颜色值。如果没有提供任何对象，则不会转换位图图像的颜色。如果必须传递此参数但又不想转换图像，请将此参数设置为使用默认 <codeph>new ColorTransform()</codeph> 构造函数创建的 ColorTransform 对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>blendMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>来自 flash.display.BlendMode 类的一个字符串值，指定要应用于所生成位图的混合模式。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>clipRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 Rectangle 对象，定义要绘制的源对象的区域。 如果不提供此值，则不会进行剪裁，并且将绘制整个源对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>smoothing</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个布尔值，用于确定因在 <codeph>matrix</codeph> 参数中指定缩放或旋转而对 BitmapData 对象进行缩放或旋转以后，是否对该对象进行平滑处理。<codeph>smoothing</codeph> 参数只有在 <codeph>source</codeph> 参数是 BitmapData 对象时才适用。在将 <codeph>smoothing</codeph> 设置为 <codeph>false</codeph> 的情况下，经过旋转或缩放的 BitmapData 图像可能会显得像素化或带有锯齿。例如，下面两个图像的 <codeph>source</codeph> 参数使用同一个 BitmapData 对象，但对左侧的图像，<codeph>smoothing</codeph> 参数设置为 <codeph>true</codeph>，对右侧的图像，该参数设置为 <codeph>false</codeph>：
	 
	 <p><adobeimage alt="两个图像：左边的图像经过平滑处理，右边的图像未经过平滑处理。" href="../../images/bitmapData_draw_smoothing.jpg"/></p>
	 
	 <p>在将 <codeph>smoothing</codeph> 设置为 <codeph>true</codeph> 的情况下绘制位图要比在将 <codeph>smoothing</codeph> 设置为 <codeph>false</codeph> 的情况下执行相同操作更为缓慢。</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用 <ph platform="actionscript">Flash Player 或</ph> AIR 矢量渲染器在位图图像上绘制 <codeph>source</codeph> 显示对象。可以指定 <codeph>matrix</codeph>、<codeph>colorTransform</codeph>、<codeph>blendMode</codeph> 和目标 <codeph>clipRect</codeph> 参数来控制呈现的执行方式。您可以根据需要指定是否应在缩放时对位图进行平滑处理（这只适用于源对象是 BitmapData 对象的情况）。
	  
	 <p>此方法与如何在创作工具界面中使用对象的标准矢量渲染器来绘制对像直接对应。</p>
	 
	 <p>源显示对象不对此调用使用其任何已应用的转换。它会被视为存在于库或文件中，没有矩阵转换、没有颜色转换，也没有混合模式。要使用对象自己的 transform 属性来绘制显示对象（如影片剪辑），可以将其 <codeph>transform</codeph> 属性对象复制到使用 BitmapData 对象的 Bitmap 对象的 <codeph>transform</codeph> 属性。</p>
	 
     <p>在 <ph platform="actionscript">Flash Player 9.0.115.0 及更高版本和 </ph>Adobe AIR 中，通过 RTMP 支持此方法。在 Flash Media Server 上，可以在服务器端脚本中控制对流的访问。有关详细信息，请参阅 <xref href="http://www.adobe.com/go/documentation" scope="external"> <i>Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></xref>（《Adobe Flash Media Server 服务器端 ActionScript 语言参考》）中的 <codeph>Client.audioSampleAccess</codeph> 和 <codeph>Client.videoSampleAccess</codeph> 属性。</p>
	 
	 <p platform="actionscript">如果 source 对象和其所有子对象（如果是 Sprite 或 MovieClip 对象）与调用方不来自同一个域，或者不在调用方可通过调用 <codeph>Security.allowDomain()</codeph> 方法访问的内容中，则调用 <codeph>draw()</codeph> 将引发 SecurityError 异常。此限制不适用于应用程序安全沙箱中的 AIR 内容。</p>
	 
	 <p platform="actionscript">对于使用所加载的位图图像作为 <codeph>source</codeph> 也有一些限制。如果所加载的图像来自与调用方相同的域，则调用 <codeph>draw()</codeph> 方法成功。此外，图像服务器上的跨域策略文件可以向调用 <codeph>draw()</codeph> 方法的 SWF 内容的域授予权限。在这种情况下，必须设置 LoaderContext 对象的 <codeph>checkPolicyFile</codeph> 属性，并在调用用于加载图像的 Loader 对象的 <codeph>load()</codeph> 方法时使用 LoaderContext 对象作为 <codeph>context</codeph> 参数。这些限制不适用于应用程序安全沙箱中的 AIR 内容。</p>
	 
	 <p>在 Windows 中，<codeph>draw()</codeph> 方法无法<ph platform="actionscript">在 Adobe AIR 的 HTMLLoader 对象中</ph>捕获嵌入 HTML 页的 SWF 内容。</p>
	 
	 <p><codeph>draw()</codeph> 方法无法捕获<ph platform="actionscript"> Adobe AIR 中</ph>的 PDF 内容。也无法捕获 <ph platform="actionscript">Adobe AIR</ph> 中 <codeph>wmode</codeph> 属性设置为<codeph>“window”</codeph>的 HTML 中嵌入的 SWF 内容。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.draw.1.as"> 下例演示如何将 TextField 对象绘制到 BitmapData 对象：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BlendMode"><linktext>flash.display.BlendMode</linktext></link><link href="flash.geom.xml#ColorTransform"><linktext>flash.geom.ColorTransform</linktext></link><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.system.xml#JPEGLoaderContext"><linktext>flash.system.JPEGLoaderContext</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:fillRect"><apiName>fillRect</apiName><shortdesc>
	 使用指定的 ARGB 颜色填充一个矩形像素区域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>矩形是空的。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>要填充的矩形区域。
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>用于填充区域的 ARGB 颜色值。通常以十六进制格式指定 ARGB 颜色；例如，0xFF336699。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用指定的 ARGB 颜色填充一个矩形像素区域。
	 
	 </apiDesc><example conref="examples\BitmapData.fillRect.1.as"> 下例演示如何用蓝色填充 BitmapData 对象的一个矩形区域：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.geom.xml#Rectangle"><linktext>flash.geom.Rectangle</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:floodFill"><apiName>floodFill</apiName><shortdesc>
	 对图像执行倾倒填充操作，从 (x, y) 坐标开始，填充一种特定的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>图像的 <i>x</i> 坐标。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>图像的 <i>y</i> 坐标。
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要用作填充色的 ARGB 颜色。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>在图像上执行倾倒填充操作，从 (x, y) 坐标开始。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 对图像执行倾倒填充操作，从 (<i>x</i>, <i>y</i>) 坐标开始，填充一种特定的颜色。<codeph>floodFill()</codeph> 方法类似于各种绘图程序中的“颜料桶”工具。该颜色是包含 Alpha 信息和颜色信息的 ARGB 颜色。
	 
	 </apiDesc><example conref="examples\BitmapData.floodFill.1.as"> 下面的示例演示如何用红色填充 BitmapData 对象的一个区域，即围绕由点 <codeph>(10, 10)</codeph> 定义的像素的区域，在该区域中所有颜色均与该点的颜色相匹配
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:generateFilterRect"><apiName>generateFilterRect</apiName><shortdesc>
	 已知 BitmapData 对象、源矩形和滤镜对象，确定 applyFilter() 方法调用所影响的目标矩形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceRect 或滤镜为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个目标矩形，它是使用图像、<codeph>sourceRect</codeph> 参数和滤镜计算得到的。
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>一个矩形，它定义要用作输入的源图像的区域。
	 </apiDesc></apiParam><apiParam><apiItemName>filter</apiItemName><apiOperationClassifier>flash.filters:BitmapFilter</apiOperationClassifier><apiDesc>一个滤镜对象，用于计算目标矩形。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>确定将受 applyFilter() 调用影响的目标矩形。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 已知 BitmapData 对象、源矩形和滤镜对象，确定 <codeph>applyFilter()</codeph> 方法调用所影响的目标矩形。
	 
	 <p>例如，模糊滤镜影响的区域通常比原始图像大。由一个默认 BlurFilter 实例过滤的 100 x 200 像素图像，其中 <codeph>blurX = blurY = 4</codeph> 将生成一个目标矩形 <codeph>(-2,-2,104,204)</codeph>。<codeph>generateFilterRect()</codeph> 方法使您可以提前了解到此目标矩形的大小，以便能够在执行滤镜操作之前相应地调整目标图像的大小。</p>
	 
	 <p>有些滤镜会基于源图像大小裁剪其目标矩形。例如，一个内部 <codeph>DropShadow</codeph> 不会生成比其源图像大的结果。在此 API 中，BitmapData 对象用作源范围而不是源 <codeph>rect</codeph> 参数。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.generateFilterRect.1.as"> 下例演示如何使用 <codeph>generateFilterRect()</codeph> 方法来确定模糊滤镜的结果将要占据的矩形区域。<codeph>generateFilterRect()</codeph> 方法的结果由 <codeph>trace()</codeph> 函数输出：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock> 请注意，<codeph>generateFilterRect()</codeph> 方法不会应用滤镜。调用 <codeph>applyFilter()</codeph> 方法来应用滤镜。 
</example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getColorBoundsRect"><apiName>getColorBoundsRect</apiName><shortdesc>
	 确定矩形区域是将位图图像中指定颜色的所有像素完全包括起来（如果将 findColor 参数设置为 true），还是将不包括指定颜色的所有像素完全包括起来（如果将 findColor 参数设置为 false）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指定颜色的图像区域。 
	 
	 </apiDesc><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier></apiReturn><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个十六进制值，指定要考虑的 ARGB 颜色的位。通过使用 <codeph>&amp;</codeph>（按位 AND）运算符，将颜色值与此十六进制值合并。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个十六进制值，指定要匹配（如果 <codeph>findColor</codeph> 设置为 <codeph>true</codeph>）或<i>不</i> 匹配（如果 <codeph>findColor</codeph> 设置为 <codeph>false</codeph>）的 ARGB 颜色。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>findColor</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>true</apiData><apiDesc>如果该值设置为 <codeph>true</codeph>，则返回图像中颜色值的范围。如果该值设置为 <codeph>false</codeph>，则返回图像中不存在此颜色的范围。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 确定矩形区域是将位图图像中指定颜色的所有像素完全包括起来（如果将 <codeph>findColor</codeph> 参数设置为 <codeph>true</codeph>），还是将不包括指定颜色的所有像素完全包括起来（如果将 <codeph>findColor</codeph> 参数设置为 <codeph>false</codeph>）。 
	 
	 <p>例如，如果有一个源图像并且想要确定包含非零 Alpha 通道的图像矩形，请传递 <codeph>{mask: 0xFF000000, color: 0x00000000}</codeph> 作为参数。如果 <codeph>findColor</codeph> 参数设置为 <codeph>true</codeph>，则会在整个图像中搜索其 <codeph>(value &amp; mask) == color</codeph> 的像素范围（其中 <codeph>value</codeph> 是像素的颜色值）。如果 <codeph>findColor</codeph> 参数设置为 <codeph>false</codeph>，则在整个图像中搜索以下像素的范围，这些像素满足条件 <codeph>(value &amp; mask) != color</codeph>（其中 <codeph>value</codeph> 是像素的颜色值）。要确定图像周围的空白区域，请传递 <codeph>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</codeph> 以查找非空白像素的范围。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getColorBoundsRect.1.as"> 下例将创建一个 BitmapData 对象，其上半部分的像素为红色。然后，该示例将调用 <codeph>getColorBoundsRect()</codeph> 方法来确定其中像素为红色 (0xFF0000) 的矩形；最后，调用同一方法来确定其中像素不为红色的矩形（通过将 <codeph>findColor</codeph> 参数设置为 <codeph>false</codeph>）：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:getPixel"><apiName>getPixel</apiName><shortdesc>
	 返回一个整数，它表示 BitmapData 对象中在特定点 (x, y) 处的 RGB 像素值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个表示 RGB 像素值的数字。如果 (<i>x</i>, <i>y</i>) 坐标在图像范围以外，则该方法返回 0。 
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素的 <i>x</i> 位置。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素的 <i>y</i> 位置。
	 
	 </apiDesc></apiParam><apiTipTexts><apiTipText>返回一个整数，它表示 BitmapData 对象中在某个特定点上的 RGB 像素值。
	 
	 </apiTipText></apiTipTexts></apiOperationDef><apiDesc>
	 返回一个整数，它表示 BitmapData 对象中在某个特定点 (<i>x</i>, <i>y</i>) 处的 RGB 像素值。<codeph>getPixel()</codeph> 方法将返回一个未经过相乘的像素值。没有返回任何 Alpha 信息。
	 
	 <p>BitmapData 对象中的所有像素都作为预乘颜色值进行存储。预乘图像像素具有已经与 Alpha 数据相乘的红色、绿色和蓝色通道值。例如，如果 Alpha 值为 0，则 RGB 通道的值也为 0，与它们未经过相乘的值无关。这种丢失数据的情况可能会在执行操作时导致一些问题。所有 BitmapData 方法都采用并返回未经过相乘的值。内部像素表示形式在其作为值返回之前从经过预乘的形式转换为未经过相乘的形式。在设置操作过程中，设置原始图像像素之前，像素值是经过预乘的。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel.1.as"> 下例创建一个用红色填充的 BitmapData 对象，然后使用 <codeph>getPixel()</codeph> 方法确定左上角像素中的颜色值：
<codeblock>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(1, 1);
trace(pixelValue.toString(16)); // ff0000;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixel32"><apiName>getPixel32</apiName><shortdesc>
	 返回一个 ARGB 颜色值，它包含 Alpha 通道数据和 RGB 数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个表示 ARGB 像素值的数字。如果 (<i>x</i>, <i>y</i>) 坐标在图像范围以外，则返回 0。
	 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素的 <i>x</i> 位置。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素的 <i>y</i> 位置。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 返回一个 ARGB 颜色值，它包含 Alpha 通道数据和 RGB 数据。此方法与 <codeph>getPixel()</codeph> 方法类似，后者返回没有 Alpha 通道数据的 RGB 颜色。
	 
	 <p>BitmapData 对象中的所有像素都作为预乘颜色值进行存储。预乘图像像素具有已经与 Alpha 数据相乘的红色、绿色和蓝色通道值。例如，如果 Alpha 值为 0，则 RGB 通道的值也为 0，与它们未经过相乘的值无关。这种丢失数据的情况可能会在执行操作时导致一些问题。所有 BitmapData 方法都采用并返回未经过相乘的值。内部像素表示形式在其作为值返回之前从经过预乘的形式转换为未经过相乘的形式。在设置操作过程中，设置原始图像像素之前，像素值是经过预乘的。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.getPixel32.1.as"> 下面的示例创建一个用颜色填充的 BitmapData 对象，然后使用 <codeph>getPixel32()</codeph> 方法确定左上角像素中的颜色值，并随之确定每个颜色成分（Alpha、红色、绿色和蓝色）的十六进制值：
<codeblock>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(1, 1);
var alphaValue:uint = pixelValue >> 24 &amp; 0xFF;
var red:uint = pixelValue >> 16 &amp; 0xFF;
var green:uint = pixelValue >> 8 &amp; 0xFF;
var blue:uint = pixelValue &amp; 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getPixels"><apiName>getPixels</apiName><shortdesc>
	 从像素数据的矩形区域生成一个字节数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>矩形是空的。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>表示给定矩形中的像素的 ByteArray。
	 
	 </apiDesc><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>当前 BitmapData 对象中的一个矩形区域。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从像素数据的矩形区域生成一个字节数组。为每个像素将一个无符号整数（32 位未经相乘的像素值）写入字节数组。
	 
	 </apiDesc><example conref="examples\BitmapData.getPixels.1.as"> 下例将创建一个用随机杂点像素填充的 BitmapData 对象，然后通过 <codeph>getPixels()</codeph> 方法用 BitmapData 对象的像素值来填充 ByteArray 对象
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray"><linktext>flash.utils.ByteArray</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:getVector"><apiName>getVector</apiName><shortdesc>
	 从像素数据的矩形区域生成一个矢量数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>矩形是空的。
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>表示给定矩形的 Vector。
	 </apiDesc><apiType value="Vector$uint"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>当前 BitmapData 对象中的一个矩形区域。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从像素数据的矩形区域生成一个矢量数组。为指定矩形返回一个无符号整数（32 位未经相乘的像素值）的 Vector 对象。
	 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:histogram"><apiName>histogram</apiName><shortdesc>
	 计算 BitmapData 对象的 256 值二进制数直方图。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Vector$Vector$Number"/></apiReturn><apiParam><apiItemName>hRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>要使用的 BitmapData 对象的区域。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 计算 BitmapData 对象的 256 值二进制数直方图。此方法返回包含四个矢量的 Vector 对象。&lt;Number> 个实例（四个包含数字对象的 Vector 对象）。这四个 Vector 实例依次表示红色、绿色、蓝色和 Alpha 成分。每个 Vector 实例包含从 0 到 255 这 256 个值，这些值表示各个成分值的填充计数。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:hitTest"><apiName>hitTest</apiName><shortdesc>
	 在一个位图图像与一个点、矩形或其它位图图像之间执行像素级的点击检测。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>secondObject</codeph> 参数不是 Point、Rectangle、Bitmap 或 BitmapData 对象。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>firstPoint 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果发生点击，则值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	    
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn><apiParam><apiItemName>firstPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc> 任意坐标空间中 BitmapData 图像的左上角的位置。在定义 <codeph>secondBitmapPoint</codeph> 参数时，使用了相同的坐标空间。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>firstAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>最小的 Alpha 通道值，此点击测试将其视为不透明的。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondObject</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>一个 Rectangle、Point、Bitmap 或 BitmapData 对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondBitmapDataPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiData>null</apiData><apiDesc>一个点，用于定义第二个 BitmapData 对象中的一个像素位置。仅当 <codeph>secondObject</codeph> 的值是 BitmapData 对象时使用此参数。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>secondAlphaThreshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>1</apiData><apiDesc>最小的 Alpha 通道值，它在第二个 BitmapData 对象中被视为不透明的。仅当 <codeph>secondObject</codeph> 的值是 BitmapData 对象，并且这两个 BitmapData 对象都为透明时使用此参数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 在一个位图图像与一个点、矩形或其它位图图像之间执行像素级的点击检测。根据定义，点击区域是指一个不透明像素或两个重叠的不透明像素上的点或矩形的重叠部分。在执行点击测试时，将不会考虑两个对象中任何一个对象的拉伸、旋转或其它变形。 
	 
	 <p>如果某个图像是不透明图像，则此方法会将其视为完全不透明的矩形。两个图像必须是透明图像才能执行判断透明度的像素级点击测试。当您在测试两个透明图像时，Alpha 阈值参数将控制哪些 Alpha 通道值（从 0 到 255）将被视为是不透明的。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.hitTest.1.as"> 下例将创建一个仅在矩形区域 (20, 20, 40, 40) 中不透明的 BitmapData 对象，然后调用 <codeph>hitTest()</codeph> 方法，且使用 Point 对象作为 <codeph>secondObject</codeph>。在第一次调用中，Point 对象定义 BitmapData 对象的左上角，是透明的；在第二次调用中，Point 对象定义 BitmapData 对象的中心，是不透明的。
<codeblock>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:lock"><apiName>lock</apiName><shortdesc>
	 锁定图像，以使引用 BitmapData 对象的任何对象（如 Bitmap 对象）在此 BitmapData 对象更改时不会更新。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 锁定图像，以使引用 BitmapData 对象的任何对象（如 Bitmap 对象）在此 BitmapData 对象更改时不会更新。要提高性能，请在对 <codeph>setPixel()</codeph> 或 <codeph>setPixel32()</codeph> 方法进行多次调用之前和之后使用此方法及 <codeph>unlock()</codeph> 方法。
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> 下例根据 Bitmap 对象 <codeph>picture</codeph> 的 <codeph>bitmapData</codeph> 属性创建一个 BitmapData 对象。然后，该示例先调用 <codeph>lock()</codeph> 方法再调用复杂的自定义函数 <codeph>complexTransformation()</codeph>，该函数可修改 BitmapData 对象。（<codeph>picture</codeph> 对象和 <codeph>complexTransformation()</codeph> 函数未在本示例中定义。） 即使 <codeph>complexTransformation()</codeph> 函数更新了 <codeph>picture</codeph> 对象的 <codeph>bitmapData</codeph> 属性，这些更新也只有在代码对 <codeph>bitmapData</codeph> 对象调用 <codeph>unlock()</codeph> 方法之后才会得到体现：
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:merge"><apiName>merge</apiName><shortdesc>
     对每个通道执行从源图像向目标图像的混合。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect 或 destPoint 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要使用的输入位图图像。源图像可以是另一个 BitmapData 对象，也可以引用当前 BitmapData 对象。
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>定义要用作输入的源图像区域的矩形。
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标图像（当前 BitmapData 实例）中与源矩形的左上角对应的点。
     </apiDesc></apiParam><apiParam><apiItemName>redMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个要与红色通道值相乘的十六进制 uint 值。 
     </apiDesc></apiParam><apiParam><apiItemName>greenMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个要与绿色通道值相乘的十六进制 uint 值。 
     </apiDesc></apiParam><apiParam><apiItemName>blueMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个要与蓝色通道值相乘的十六进制 uint 值。
     </apiDesc></apiParam><apiParam><apiItemName>alphaMultiplier</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个要与 Alpha 透明度值相乘的十六进制 uint 值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     对每个通道执行从源图像向目标图像的混合。对于每个通道和每个像素，将基于源和目标像素的通道值来计算新值。例如，在红色通道中，新值是按如下方式计算的（其中 <codeph>redSrc</codeph> 是源图像中像素的红色通道值，而 <codeph>redDest</codeph> 是目标图像中对应像素的红色通道值）： 
	 <p>
	 <codeph> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </codeph>
	 </p>
	 
	 <p><codeph>redMultiplier</codeph>、<codeph>greenMultiplier</codeph>、<codeph>blueMultiplier</codeph> 和 <codeph>alphaMultiplier</codeph> 值是用于每个颜色通道的乘数。应使用从 <codeph>0</codeph> 到 <codeph>0x100</codeph> (256) 的十六进制值范围，其中 <codeph>0</codeph> 指定在结果中使用来自目标的完整值，<codeph>0x100</codeph> 指定使用来自源的完整值，介于两者之间的数字指定使用混合值 （如 <codeph>0x80</codeph> 表示 50%）。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.merge.1.as"> 下例将创建两个 BitmapData 对象。这两个对象的大小均为 100 x 80 像素。第一个对象用绿色填充，第二个对象用红色填充。该代码调用 <codeph>merge()</codeph> 方法，将第二个 BitmapData 对象的像素合并到第一个 BitmapData 对象中，但仅在指定矩形区域上进行：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:noise"><apiName>noise</apiName><shortdesc>
	 使用表示随机杂点的像素填充图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要使用的随机种子数。如果您保持使所有其它参数不变，可以通过改变随机种子值来生成不同的伪随机结果。杂点函数是一个映射函数，不是真正的随机数生成函数，所以它每次都会根据相同的随机种子创建相同的结果。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>low</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要为每个通道生成的最低值（0 到 255）。 
	 </apiDesc></apiParam><apiParam><apiItemName>high</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>255</apiData><apiDesc>要为每个通道生成的最高值（0 到 255）。 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc>一个数字，可以是四个颜色通道值（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph> 和 <codeph>BitmapDataChannel.ALPHA</codeph>）的任意组合。您可以使用逻辑 OR 运算符（<codeph>|</codeph>）来组合通道值。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个布尔值。如果该值为 <codeph>true</codeph>，则会通过将所有颜色通道设置为相同的值来创建一个灰度图像。将此参数设置为 <codeph>true</codeph> 不会影响 Alpha 通道的选择。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 使用表示随机杂点的像素填充图像。
	 
	 </apiDesc><example conref="examples\BitmapData.noise.1.as"> 下例将创建两个 BitmapData 对象，并对这两个对象都调用 <codeph>noise()</codeph> 方法。但是，对于第一个对象的 <codeph>noise()</codeph> 方法的调用，<codeph>grayscale</codeph> 参数设置为 <codeph>false</codeph>，而对于第二个对象的 <codeph>noise()</codeph> 方法的调用，该参数设置为 <codeph>true</codeph>：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapDataChannel/RED"><linktext>flash.display.BitmapDataChannel.RED</linktext></link><link href="flash.display.xml#BitmapDataChannel/BLUE"><linktext>flash.display.BitmapDataChannel.BLUE</linktext></link><link href="flash.display.xml#BitmapDataChannel/GREEN"><linktext>flash.display.BitmapDataChannel.GREEN</linktext></link><link href="flash.display.xml#BitmapDataChannel/ALPHA"><linktext>flash.display.BitmapDataChannel.ALPHA</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:paletteMap"><apiName>paletteMap</apiName><shortdesc>
	 重新映射一个具有最多四组调色板数据（每个通道一组）的图像中的颜色通道值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect 或 destPoint 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要使用的输入位图图像。源图像可以是另一个 BitmapData 对象，也可以引用当前 BitmapData 实例。
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>定义要用作输入的源图像区域的矩形。
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标图像（当前 BitmapData 对象）中与源矩形的左上角对应的点。
	 </apiDesc></apiParam><apiParam><apiItemName>redArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>如果 <codeph>redArray</codeph> 不为 <codeph>null</codeph>，则 <codeph>red = redArray[source red value] else red = source rect value</codeph>。
	 </apiDesc></apiParam><apiParam><apiItemName>greenArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>如果 <codeph>greenArray</codeph> 不为 <codeph>null</codeph>，则 <codeph>green = greenArray[source green value] else green = source green value.</codeph>
	 </apiDesc></apiParam><apiParam><apiItemName>blueArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>如果 <codeph>blueArray</codeph> 不为 <codeph>null</codeph>，则 <codeph>blue = blueArray[source blue value] else blue = source blue value</codeph>。
	 </apiDesc></apiParam><apiParam><apiItemName>alphaArray</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>如果 <codeph>alphaArray</codeph> 不为 <codeph>null</codeph>，则 <codeph>alpha = alphaArray[source alpha value] else alpha = source alpha value</codeph>。
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 重新映射一个具有最多四组调色板数据（每个通道一组）的图像中的颜色通道值。 
	 
	 <p><ph platform="actionscript">Flash Player 或</ph> AIR 使用以下步骤生成结果图像：</p>
	 
	 <ol>
	 
	 <li>计算了红色、绿色、蓝色和 Alpha 值后，将使用标准 32 位整数算法将它们相加在一起。 </li>
	 
	 <li>每个像素的红色、绿色、蓝色和 Alpha 通道值被分别提取为一个 0 到 255 的值。使用这些值在相应的数组中查找新的颜色值：<codeph>redArray</codeph>、<codeph>greenArray</codeph>、<codeph>blueArray</codeph> 和 <codeph>alphaArray</codeph>。这四个数组中的每一个都应包含 256 个值。 </li>
	 
	 <li>在检索了所有四个新通道值之后，它们会被组合成一个应用于像素的标准 ARGB 值。</li>
	 
	 </ol>
	 
	 <p>此方法可以支持跨通道效果。每个输入数组可以包含完整的 32 位值，并且在将这些值相加到一起时不会发生任何移位。此例程不支持按通道锁定。 </p>
	 
	 <p>如果没有为通道指定数组，则颜色通道会从源图像复制到目标图像。</p>
	 
	 <p>您可以为多种效果（例如，常规调色板映射）使用此方法（采用一个通道并将其转换为假颜色图像）。您也可以为各种高级颜色操作算法（例如，灰度系数、曲线、级别和量化）使用此方法。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.paletteMap.1.as"> 下例将创建一个中心有红色方框的绿色 BitmapData 对象，然后使用 <codeph>paletteMap()</codeph> 方法在 BitmapData 对象的下半部分的矩形中将红色与绿色交换：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:perlinNoise"><apiName>perlinNoise</apiName><shortdesc>
	 生成 Perlin 杂点图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>baseX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要在 <i>x</i> 方向上使用的频率。例如，要生成大小适合 64 x 128 图像的杂点，请为 <codeph>baseX</codeph> 值传递 64。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>baseY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>要在 <i>y</i> 方向上使用的频率。例如，要生成大小适合 64 x 128 图像的杂点，请为 <codeph>baseY</codeph> 值传递 128。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numOctaves</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要组合以创建此杂点的 octave 函数或各个杂点函数的数目。octave 的数目越多，创建的图像越细腻。octave 的数目越多，需要的处理时间也会越长。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>要使用的随机种子数。如果您保持使所有其它参数不变，可以通过改变随机种子值来生成不同的伪随机结果。Perlin 杂点函数是一个映射函数，不是真正的随机数生成函数，所以它会每次根据相同的随机种子创建相同的结果。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>stitch</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>一个布尔值。如果该值为 <codeph>true</codeph>，则该方法将尝试平滑图像的转变边缘以创建无缝的纹理，用于作为位图填充进行平铺。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fractalNoise</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>一个布尔值。如果该值为 <codeph>true</codeph>，则该方法将生成碎片杂点；否则，它将生成湍流。带有湍流的图像具有可见的不连续性渐变，可以使其具有更接近锐化的视觉效果，例如火焰或海浪。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>channelOptions</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>7</apiData><apiDesc> 一个数字，可以是四个颜色通道值（<codeph>BitmapDataChannel.RED</codeph>、<codeph>BitmapDataChannel.BLUE</codeph>、<codeph>BitmapDataChannel.GREEN</codeph> 和 <codeph>BitmapDataChannel.ALPHA</codeph>）的任意组合。您可以使用逻辑 OR 运算符（<codeph>|</codeph>）来组合通道值。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>grayScale</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>一个布尔值。如果该值为 <codeph>true</codeph>，则通过将红色、绿色和蓝色通道的每一个值都设置为相同的值来创建一个灰度图像。如果此值设置为 <codeph>true</codeph>，则 Alpha 通道值将不会受到影响。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>offsets</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>与每个 octave 的 <i>x</i> 和 <i>y</i> 偏移量相对应的点数组。通过操作这些偏移量值，您可以平滑滚动 perlinNoise 图像的图层。偏移数组中的每个点将影响一个特定的 octave 杂点函数。
	 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 生成 Perlin 杂点图像。
	 
	 <p>Perlin 杂点生成算法会内插单个随机杂点函数名为 octave 并将它们组合成一个函数，该函数生成多个看起来很自然的随机杂点。就像音乐上的八音度，每个 octave 函数的频率都是其前面一个 octave 函数频率的两倍。Perlin 杂点被描述为“杂点的碎片总和”，因为它将多组杂点数据与不同级别的细节组合在一起。</p>
	 
	 <p>您可以使用 Perlin 杂点函数来模拟自然现象和风景，例如，木材纹理、云彩或山脉。在大多数情况下，Perlin 杂点函数的输出不会直接显示出来，而是用于增强其它图像并为其它图像提供伪随机变化。</p>
	 
	 <p>简单的数字随机杂点函数通常生成具有粗糙的对比度点的图像。这种粗糙的对比度在自然界中通常是找不到的。Perlin 杂点算法混合了在不同的详细级别上进行操作的多个杂点函数。此算法在相邻的像素值间产生较小的变化。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.perlinNoise.1.as"> 下例将创建一个 200 x 200 像素的 BitmapData 对象，该对象调用 <codeph>perlinNoise()</codeph> 方法来生成红色和蓝色的水彩画效果：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:pixelDissolve"><apiName>pixelDissolve</apiName><shortdesc>
	 执行源图像到目标图像的像素溶解，或使用同一图像执行像素溶解。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect 或 destPoint 为空。
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>numPixels 值为负
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiDesc>用于后续调用的新随机种子值。
	 
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要使用的输入位图图像。源图像可以是另一个 BitmapData 对象，也可以引用当前 BitmapData 实例。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>定义要用作输入的源图像区域的矩形。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标图像（当前 BitmapData 实例）中与源矩形的左上角对应的点。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>randomSeed</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>用于开始像素溶解的随机种子。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>numPixels</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiData>0</apiData><apiDesc>默认值是源区域（宽度 x 高度）的 1/30。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fillColor</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>一个 ARGB 颜色值，用于填充其源值等于目标值的像素。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 执行源图像到目标图像的像素溶解，或使用同一图像执行像素溶解。<ph platform="actionscript">Flash Player 或</ph> AIR 使用 <codeph>randomSeed</codeph> 值生成随机像素溶解。函数的返回值必须在后续调用中传入才能继续进行像素溶解，直至完成。
	 
	 <p>如果源图像不等于目标图像，则会使用所有的属性将像素从源复制到目标。此过程允许从空白图像溶解到完全填充的图像。</p>
	 
	 <p>如果源图像和目标图像相等，则使用 <codeph>color</codeph> 参数填充像素。此过程允许从完全填充的图像溶解掉。在此模式中，将会忽略目标 <codeph>point</codeph> 参数。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.pixelDissolve.1.as"> 下例使用 <codeph>pixelDissolve()</codeph> 方法一次溶解 40 个像素，直到所有像素的颜色都已更改，从而将 BitmapData 对象由灰色转换为红色：
<codeblock>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 &amp;&amp; grayRegion.height == 0 ) {
        tim.stop();
    }
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:scroll"><apiName>scroll</apiName><shortdesc>
	 按某一 (x, y) 像素量滚动图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>水平滚动量。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>垂直滚动量。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将图像按一定量的 (<i>x</i>, <i>y</i>) 像素进行滚动。滚动区域之外的边缘区域保持不变。
	 
	 </apiDesc><example conref="examples\BitmapData.scroll.1.as"> 下例显示将 Bitmap 数据对象向右滚动 40 个像素的效果：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:setPixel"><apiName>setPixel</apiName><shortdesc>
	 设置 BitmapData 对象的单个像素。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素值会更改的像素的 <i>x</i> 位置。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素值会更改的像素的 <i>y</i> 位置。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>生成的像素 RGB 颜色。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 设置 BitmapData 对象的单个像素。在此操作过程中将会保留图像像素的当前 Alpha 通道值。RGB 颜色参数的值被视为一个未经过相乘的颜色值。
	 
	 <p><b>注意：</b>要提高性能，请在重复使用 <codeph>setPixel()</codeph> 或 <codeph>setPixel32()</codeph> 方法时，在调用 <codeph>setPixel()</codeph> 或 <codeph>setPixel32()</codeph> 方法之前先调用 <codeph>lock()</codeph> 方法，然后在做出所有像素更改后调用 <codeph>unlock()</codeph> 方法。此过程可防止引用此 BitmapData 实例的对象在您完成像素更改之前进行更新。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel.1.as"> 下例使用 <codeph>setPixel()</codeph> 方法在 BitmapData 对象中绘制一条红色直线：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/getPixel()"><linktext>getPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixel32"><apiName>setPixel32</apiName><shortdesc>
	 设置 BitmapData 对象单个像素的颜色和 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素值会更改的像素的 <i>x</i> 位置。
	 </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>像素值会更改的像素的 <i>y</i> 位置。
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>生成的像素 ARGB 颜色。如果位图是不透明的（非透明）位图，则会忽略此颜色值的 Alpha 透明度部分。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 设置 BitmapData 对象单个像素的颜色和 Alpha 透明度值。此方法与 <codeph>setPixel()</codeph> 方法类似；主要差别在于 <codeph>setPixel32()</codeph> 方法采用包含 Alpha 通道信息的 ARGB 颜色值。
	 
	 <p>BitmapData 对象中的所有像素都作为预乘颜色值进行存储。预乘图像像素具有已经与 Alpha 数据相乘的红色、绿色和蓝色通道值。例如，如果 Alpha 值为 0，则 RGB 通道的值也为 0，与它们未经过相乘的值无关。这种丢失数据的情况可能会在执行操作时导致一些问题。所有 BitmapData 方法都采用并返回未经过相乘的值。内部像素表示形式在其作为值返回之前从经过预乘的形式转换为未经过相乘的形式。在设置操作过程中，设置原始图像像素之前，像素值是经过预乘的。</p>
	 
	 <p><b>注意：</b>要提高性能，请在重复使用 <codeph>setPixel()</codeph> 或 <codeph>setPixel32()</codeph> 方法时，在调用 <codeph>setPixel()</codeph> 或 <codeph>setPixel32()</codeph> 方法之前先调用 <codeph>lock()</codeph> 方法，然后在做出所有像素更改后调用 <codeph>unlock()</codeph> 方法。此过程可防止引用此 BitmapData 实例的对象在您完成像素更改之前进行更新。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.setPixel32.1.as"> 下例使用 <codeph>setPixel32()</codeph> 方法在 BitmapData 对象中绘制一条透明的 (Alpha == 0x60) 红色直线：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/getPixel32()"><linktext>getPixel32()</linktext></link><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/unlock()"><linktext>unlock()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setPixels"><apiName>setPixels</apiName><shortdesc>
	 将字节数组转换为像素数据的矩形区域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc><codeph>inputByteArray</codeph> 对象包括的数据不足以填充 <codeph>rect</codeph> 矩形的区域。在引发异常之前，该方法会尽可能多地填充像素。
	 
	 </apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiException><apiDesc>rect 或 inputByteArray 为空。
	  
	  </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>指定 BitmapData 对象的矩形区域。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputByteArray</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>一个 ByteArray 对象，由要在矩形区域中使用的 32 位未经过相乘的像素值组成。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将字节数组转换为像素数据的矩形区域。对于每个像素，将调用 <codeph>ByteArray.readUnsignedInt()</codeph> 方法并将返回值写入像素。如果字节数组在写入整个矩形之前结束，将返回函数。字节数组中的数据应该是 32 位 ARGB 像素值。在读取像素之前或之后，不会对字节数组执行搜索。  
	 
	 </apiDesc><example conref="examples\BitmapData.setPixels.1.as"> 下例使用 <codeph>getPixels()</codeph> 和 <codeph>setPixels()</codeph> 方法将像素从一个 BitmapData 对象复制到另一个 BitmapData 对象：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</codeblock></example></apiOperationDetail><related-links><link href="flash.utils.xml#ByteArray/readUnsignedInt()"><linktext>flash.utils.ByteArray.readUnsignedInt()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:BitmapData:setVector"><apiName>setVector</apiName><shortdesc>
	 将 Vector 转换为像素数据的矩形区域。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>矢量数组不够大，无法读取所有像素数据。
	 </apiDesc><apiItemName>RangeError</apiItemName><apiOperationClassifier>RangeError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>rect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>指定 BitmapData 对象的矩形区域。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>inputVector</apiItemName><apiType value="Vector$uint"/><apiDesc>一个 Vector 对象，由将在矩形区域中使用的 32 位未经过相乘的像素值组成。  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将 Vector 转换为像素数据的矩形区域。对于每个像素，将会读取 Vector 元素并将其写入到 BitmapData 像素中。Vector 中的数据应该是 32 位 ARGB 像素值。 
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:threshold"><apiName>threshold</apiName><shortdesc>
	 根据指定的阈值测试图像中的像素值，并将通过测试的像素设置为新的颜色值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>sourceBitmapData、sourceRect、destPoint 或操作为空。
	 </apiDesc><apiItemName>TypeError</apiItemName><apiOperationClassifier>TypeError</apiOperationClassifier></apiException><apiException><apiDesc>操作字符串不是有效的操作 
	  
	  </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiDesc>已更改像素的数目。
 	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn><apiParam><apiItemName>sourceBitmapData</apiItemName><apiOperationClassifier>flash.display:BitmapData</apiOperationClassifier><apiDesc>要使用的输入位图图像。源图像可以是另一个 BitmapData 对象，也可以引用当前 BitmapData 实例。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>sourceRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiDesc>定义要用作输入的源图像区域的矩形。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>destPoint</apiItemName><apiOperationClassifier>flash.geom:Point</apiOperationClassifier><apiDesc>目标图像（当前 BitmapData 实例）中与源矩形的左上角对应的点。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>operation</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>下列比较运算符之一（作为字符串传递）:“&lt;”、“&lt;=”、“>”、“>=”、“==”“!=”
	 
	 </apiDesc></apiParam><apiParam><apiItemName>threshold</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>测试每个像素时要比较的值，以查看该值是达到还是超过阈值。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>阈值测试成功时对像素设置的颜色值。默认值为 0x00000000。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>mask</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0xFFFFFFFF</apiData><apiDesc>用于隔离颜色成分的遮罩。 
	 
	 </apiDesc></apiParam><apiParam><apiItemName>copySource</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果该值为 <codeph>true</codeph>，则源图像中的像素值将在阈值测试失败时复制到目标图像。如果为 <codeph>false</codeph>，则在阈值测试失败时不会复制源图像。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 根据指定的阈值测试图像中的像素值，并将通过测试的像素设置为新的颜色值。通过使用 <codeph>threshold()</codeph> 方法，您可以隔离和替换图像中的颜色范围，并对图像像素执行其它逻辑操作。 
	 
	 <p><codeph>threshold()</codeph> 方法的测试逻辑如下所示：</p> 
	 
	 <ol> 
	 
	 	<li>如果 <codeph>((pixelValue &amp; mask) operation (threshold &amp; mask))</codeph>，则将像素设置为 <codeph>color</codeph>；</li>
	 
	 	<li>否则，如果 <codeph>copySource == true</codeph>，则将像素设置为 <codeph>sourceBitmap</codeph> 中的对应像素值。</li>
	 </ol>
	 
	 <p><codeph>operation</codeph> 参数指定要用于阈值测试的比较运算符。例如，通过使用“==”作为 <codeph>operation</codeph> 参数，您可以隔离图像中的特定颜色值。或者通过使用 <codeph>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</codeph>，您可以将所有目标像素设置为在源图像像素的 Alpha 小于 0x7F 时是完全透明的。您可以将此技巧用于动画过渡和其它效果。</p>
	 
	 </apiDesc><example conref="examples\BitmapData.threshold.1.as"> 下例使用 <codeph>perlinNoise()</codeph> 方法将蓝色和红色图案添加到一个 BitmapData 对象，然后使用 <codeph>threshold()</codeph> 方法将那些像素从第一个 BitmapData 对象复制到第二个 BitmapData 对象，并将红色值大于 0x80 (50%) 的那些像素替换成已设置为透明红色 (0x20FF0000) 的像素：
<codeblock>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, ">", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:BitmapData:unlock"><apiName>unlock</apiName><shortdesc>
	 解除锁定图像，以使引用 BitmapData 对象的任何对象（如 Bitmap 对象）在此 BitmapData 对象更改时更新。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>changeRect</apiItemName><apiOperationClassifier>flash.geom:Rectangle</apiOperationClassifier><apiData>null</apiData><apiDesc>已更改的 BitmapData 对象的区域。如果没有为此参数指定值，则会认为 BitmapData 对象的整个区域已更改。此参数需要 Flash Player 9.0.115.0 版或更高版本。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 解除锁定图像，以使引用 BitmapData 对象的任何对象（如 Bitmap 对象）在此 BitmapData 对象更改时更新。要提高性能，请在对 <codeph>setPixel()</codeph> 或 <codeph>setPixel32()</codeph> 方法进行多次调用之前和之后使用此方法及 <codeph>lock()</codeph> 方法。
	 
	 </apiDesc><example conref="examples\BitmapData.lock.1.as"> 下例根据 Bitmap 对象 <codeph>picture</codeph> 的 <codeph>bitmapData</codeph> 属性创建一个 BitmapData 对象。然后，该示例先调用 <codeph>lock()</codeph> 方法再调用复杂的自定义函数 <codeph>complexTransformation()</codeph>，该函数可修改 BitmapData 对象。（<codeph>picture</codeph> 对象和 <codeph>complexTransformation()</codeph> 函数未在本示例中定义。） 即使 <codeph>complexTransformation()</codeph> 函数更新了 <codeph>picture</codeph> 对象的 <codeph>bitmapData</codeph> 属性，这些更新也只有在代码对 <codeph>bitmapData</codeph> 对象调用 <codeph>unlock()</codeph> 方法之后才会得到体现：
<codeblock>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#BitmapData/lock()"><linktext>lock()</linktext></link><link href="flash.display.xml#BitmapData/setPixel()"><linktext>setPixel()</linktext></link><link href="flash.display.xml#BitmapData/setPixel32()"><linktext>setPixel32()</linktext></link></related-links></apiOperation><apiValue id="flash.display:BitmapData:height:get"><apiName>height</apiName><shortdesc>
	 位图图像的高度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 位图图像的高度，以像素为单位。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:rect:get"><apiName>rect</apiName><shortdesc>
	 定义位图图像大小和位置的矩形。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.geom:Rectangle</apiValueClassifier></apiValueDef><apiDesc>
	 定义位图图像大小和位置的矩形。矩形的顶部和左侧为零；宽度和高度等于 BitmapData 对象的宽度和高度（以像素为单位）。
   	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:transparent:get"><apiName>transparent</apiName><shortdesc>
	 定义位图图像是否支持每个像素具有不同的透明度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 定义位图图像是否支持每个像素具有不同的透明度。只有当通过为构造函数的 <codeph>transparent</codeph> 参数传入 <codeph>true</codeph> 来构造 BitmapData 对象时，才能设置此值。然后，在创建 BitmapData 对象之后，可以通过确定 <codeph>transparent</codeph> 属性的值是否为 <codeph>true</codeph> 来检查该对象是否支持每个像素具有不同的透明度。
   	 
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapData:width:get"><apiName>width</apiName><shortdesc>
	 位图图像的宽度，以像素为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 位图图像的宽度，以像素为单位。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:JointStyle"><apiName>JointStyle</apiName><shortdesc>
JointStyle 类是指定要在绘制线条中使用的联接点样式的常量值枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
JointStyle 类是指定要在绘制线条中使用的联接点样式的常量值枚举。提供的这些常量用作 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>joints</codeph> 参数中的值。此方法支持三种类型的连接：尖角、圆角和斜角，如下例所示： 

<p><adobeimage alt="MITER、ROUND 和 BEVEL" href="../../images/linejoin.jpg"/></p> 

 
</apiDesc><example conref="examples\JointStyleExample.as"> 下例使用 JointStyleExample 类显示应用于三组连接线的三种不同联接点样式的结果。执行下列步骤可完成该任务：
 <ol>
  <li>每条线的属性设置如下所示：
  <ul>
      <li>将线条长度设置为 80 像素。</li>
      <li>将边框颜色设置为橙色。</li>
      <li>将边框大小设置为 30 像素。</li>
      <li>将加亮颜色设置为灰色。</li>
      <li>将加亮大小设置为 0 像素。</li>
      <li>将 Alpha 设置为 1，使其成为实线。</li>
      <li>将像素提示设置为 false（不提示笔触采用全部像素）。</li>
      <li>将线条缩放模式设置为正常，这将缩放粗细。</li>
      <li>声明了边框端点和尖角限制，但未进行设置，因此使用默认值。</li>
  </ul></li>
  <li>类构造函数创建了三组两条连接的线段。线段的起始位置为 x = 0, y = 0，这是通过使用三种联接点样式（尖角、圆角和斜角）调用 <codeph>doDrawCorner()</codeph> 方法三次实现的。对 <codeph>doDrawCorner()</codeph> 的三次调用均使用先前列出的联接点样式和属性，来绘制两条连接的线段以及关联的线条加亮效果。实现此操作的方法是：首先创建一个新的 Shape 对象 <codeph>child</codeph>，然后使用 Graphics 类的方法来设置线条样式，并绘制线条和加亮效果。<codeph>child</codeph> 的每个实例都添加到显示列表中，并且在舞台上快速绘制。</li>
  <li>然后使用 <codeph>refreshLayout()</codeph> 方法，在 y = 80 像素处并从 x = 80 像素处开始以 25 像素的线段间距重绘连接的线段。</li>
 </ol>
<codeblock>
package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class JointStyleExample extends Sprite {
        private var size:uint                  = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderCaps:String;
        private var borderMiterLimit:uint;

        public function JointStyleExample() {
            doDrawCorner(JointStyle.MITER);
            doDrawCorner(JointStyle.ROUND);
            doDrawCorner(JointStyle.BEVEL);
            refreshLayout();
        }

        private function doDrawCorner(jointStyle:String):void {
            var halfSize:uint = Math.round(size / 2);
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     borderCaps,
                                     jointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(size, 0);
            child.graphics.lineTo(halfSize, size);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = size;
            lastChild.y = size;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = size;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:JointStyle:BEVEL"><apiName>BEVEL</apiName><shortdesc>
	
	在 flash.display.Graphics.lineStyle() 方法的 joints 参数中指定斜角连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bevel</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	在 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>joints</codeph> 参数中指定斜角连接。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:MITER"><apiName>MITER</apiName><shortdesc>
	
	在 flash.display.Graphics.lineStyle() 方法的 joints 参数中指定尖角连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>miter</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	在 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>joints</codeph> 参数中指定尖角连接。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:JointStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	
	在 flash.display.Graphics.lineStyle() 方法的 joints 参数中指定圆角连接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	在 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>joints</codeph> 参数中指定圆角连接。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:AVM1Movie"><apiName>AVM1Movie</apiName><shortdesc>
	AVM1Movie 是表示使用 ActionScript 1.0 或 2.0 的 AVM1 影片剪辑的简单类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
	AVM1Movie 是表示使用 ActionScript 1.0 或 2.0 的 AVM1 影片剪辑的简单类。（AVM1 是用于运行 ActionScript 1.0 和 2.0 的 ActionScript 虚拟机。AVM2 是用于运行 ActionScript 3.0 的 ActionScript 虚拟机。） 当 Loader 对象加载 Flash Player 8 或更低版本的 SWF 文件时，会创建 AVM1Movie 对象。AVM1Movie 对象可以使用继承自 DisplayObject 类的方法和属性（如 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 等）。但是，不允许 AVM1Movie 对象和 AVM2 对象之间进行互操作（如调用方法或使用参数）。
	
	<p>AVM2 SWF 文件加载 AVM1 SWF 文件具有几个限制：</p>
	
	<ul>
	
	<li>加载的 AVM1Movie 对象将作为 AVM1 SWF 文件和它加载的所有 AVM1 SWF 文件的 psuedo-root 对象操作（如同将 ActionScript 1.0 <codeph>lockroot</codeph> 属性设置为 <codeph>true</codeph>）。AVM1 影片始终位于任何子级中任何 ActionScript 1.0 或 2.0 代码执行的顶部。除非在加载的 AVM1 SWF 文件中设置 <codeph>lockroot</codeph> 属性，否则加载的子级的 <codeph>_root</codeph> 属性通常均为该 AVM1 SWF 文件。</li>
	
	<li>AVM1 内容无法将文件加载到各级别。例如，它无法通过调用 <codeph>loadMovieNum("url", levelNum)</codeph> 来加载文件。</li>
	
	<li>由 AVM2 SWF 文件加载的 AVM1 SWF 文件无法将其它 SWF 文件加载到 <codeph>this</codeph>。也就是说，它无法向其自身加载其它 SWF 文件。但是，由该 SWF 文件加载的子 Sprite 对象、MovieClip 对象或其它 AVM1 SWF 文件可以加载到 <codeph>this</codeph>。</li>
	
	</ul>
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject"><linktext>DisplayObject</linktext></link><link href="flash.display.xml#Loader"><linktext>Loader</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
	 ShaderInput 实例表示着色器内核的单一输入图像。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 ShaderInput 实例表示着色器内核的单一输入图像。可以将内核定义为接受在内核执行过程中使用的 0 个、1 个或更多源图像。ShaderInput 实例提供了一种机制，用于指定在着色器执行时使用的输入图像。要为输入指定值，请创建包含图像数据的 BitmapData、ByteArray 或 Vector.&lt;Number> 实例，并将其赋予 <codeph>input</codeph> 属性。
	 
	 <p>表示 Shader 实例的输入图像的 ShaderInput 实例将作为 Shader 实例的 <codeph>data</codeph> 属性的一个属性进行访问。ShaderInput 属性的名称与着色器代码中输入的名称相同。例如，如果着色器定义一个名为 <codeph>src</codeph> 的输入，则表示 <codeph>src</codeph> 输入的 ShaderInput 实例可作为 <codeph>src</codeph> 属性使用，如此示例所示：</p>
	 
	 <codeblock>myShader.data.src.image = new BitmapData(50, 50, true, 0xFF990000);</codeblock>
	 
	 <p>对于 Shader 实例的某些用法，您无需指定输入图像，因为操作会自动指定输入图像。您只需要在 Shader 用于以下各项时指定输入：</p>
	 
	 <ul>
	   <li>着色器填充</li>
	   <li>ShaderFilter：如果将着色器定义为使用一个以上的输入，则只适用于第二个输入或其它输入。（将自动使用应用了滤镜的对象作为第一个输入。）</li>
	   <li>着色器混合模式：如果将着色器定义为使用两个以上的输入，则只适用于第三个输入或其它输入。（将自动使用正在进行混合的对象作为第一个和第二个输入。）</li>
	   <li>ShaderJob background execution</li>
	 </ul>
	 
	 <p>如果正在使用 ShaderJob 实例执行着色器来处理包含线性数据数组的 ByteArray，请在 ByteArray 中将 ShaderInput 实例的 <codeph>height</codeph> 设置为 1，并将 <codeph>width</codeph> 设置为 32 位浮点值数字。在这种情况下，必须将着色器中的输入定义为具有 <codeph>image1</codeph> 数据类型。</p>
	 
	 <p>通常，开发人员代码不直接创建 ShaderInput 实例。在创建 Shader 实例时，将为着色器的每个输入创建一个 ShaderInput 实例。</p>
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#Shader/data"><linktext>flash.display.Shader.data</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link></related-links><apiConstructor id="flash.display:ShaderInput:ShaderInput"><apiName>ShaderInput</apiName><shortdesc>
		 创建 ShaderInput 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
		 创建 ShaderInput 实例。开发人员代码不直接调用 ShaderInput 构造函数。在创建 Shader 实例时，将为着色器的每个输入创建一个 ShaderInput 实例。
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:ShaderInput:channels:get"><apiName>channels</apiName><shortdesc>
         着色器输入所需的通道数量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         着色器输入所需的通道数量。当输入数据为 ByteArray 或 Vector.&lt;Number> 实例时，必须考虑此属性。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:height:get"><apiName>height</apiName><shortdesc>
		 着色器输入的高度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 着色器输入的高度。仅在输入数据为 ByteArray 或 Vector.&lt;Number> 实例时才使用此属性。如果输入为 BitmapData 实例，则会自动确定高度。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:index:get"><apiName>index</apiName><shortdesc>
         着色器中的输入从 0 开始的索引，指示着色器中输入定义的顺序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
         着色器中的输入从 0 开始的索引，指示着色器中输入定义的顺序。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:input:get"><apiName>input</apiName><shortdesc>
		 
		 在着色器执行时使用的输入数据。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Object</apiValueClassifier></apiValueDef><apiDesc>
		 
		 在着色器执行时使用的输入数据。此属性可以是 BitmapData 实例、ByteArray 实例或 Vector.&lt;Number> 实例。
		 
		 <p>如果将 ByteArray 值赋予 <codeph>input</codeph> 属性，则必须满足下列条件：</p>
		 
		 <ul>
		   <li>必须设置 <codeph>height</codeph> 和 <codeph>width</codeph> 属性。</li>
		   <li>字节数组的内容必须只包含 32 位浮点值。可以使用 <codeph>ByteArray.writeFloat()</codeph> 方法写入这些值。</li>
		   <li>ByteArray 的总长度（以字节为单位）必须正好为：<codeph>width</codeph> x <codeph>height</codeph> x <codeph>channels</codeph> x 4。</li>
		   <li>字节数组的 <codeph>endian</codeph> 属性必须为 <codeph>Endian.LITTLE_ENDIAN</codeph>。</li>
		 </ul>
		 
		 <p>如果将 Vector.&lt;Number> 实例赋予 <codeph>input</codeph> 属性，则 Vector 的长度必须等于：<codeph>width</codeph> x <codeph>height</codeph> x <codeph>channels</codeph>。</p>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderInput:width:get"><apiName>width</apiName><shortdesc>
		 着色器输入的宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
		 着色器输入的宽度。仅在输入数据为 ByteArray 或 Vector.&lt;Number> 实例时才使用此属性。如果输入为 BitmapData 实例，则会自动确定宽度。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrection"><apiName>ColorCorrection</apiName><shortdesc>
ColorCorrection 类可为 flash.display.Stage.colorCorrection 属性提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
ColorCorrection 类可为 <codeph>flash.display.Stage.colorCorrection</codeph> 属性提供值。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrection"><linktext>flash.display.Stage.colorCorrection</linktext></link></related-links><apiValue id="flash.display:ColorCorrection:DEFAULT"><apiName>DEFAULT</apiName><shortdesc>
使用主机的默认颜色校正。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>default</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
使用主机的默认颜色校正。对于 Web 播放器，主机通常是一个浏览器，Flash Player 尝试使用相同的颜色校正作为承载 SWF 文件的网页。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:OFF"><apiName>OFF</apiName><shortdesc>
关闭颜色校正，不论播放器主机环境如何。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>off</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
关闭颜色校正，不论播放器主机环境如何。此设置可提供更快的性能。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrection:ON"><apiName>ON</apiName><shortdesc>
打开颜色校正，不论播放器主机环境（如果有）如何。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>on</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
打开颜色校正，不论播放器主机环境（如果有）如何。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:LineScaleMode"><apiName>LineScaleMode</apiName><shortdesc>
LineScaleMode 类为 Graphics.lineStyle() 方法中的 scaleMode 参数提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
LineScaleMode 类为 <codeph>Graphics.lineStyle()</codeph> 方法中的 <codeph>scaleMode</codeph> 参数提供值。


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:LineScaleMode:HORIZONTAL"><apiName>HORIZONTAL</apiName><shortdesc>
	将此设置用作 lineStyle() 方法的 scaleMode 参数时，线条粗细只会垂直缩放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>horizontal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将此设置用作 <codeph>lineStyle()</codeph> 方法的 <codeph>scaleMode</codeph> 参数时，线条粗细<i>只会</i>垂直缩放。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.VERTICAL</codeph>。左侧的圆仅在垂直方向上缩放，右侧的圆同时在垂直和水平方向上缩放。
	
    <p><adobeimage alt="一个在垂直方向缩放的圆和一个在垂直和水平方向同时缩放的圆。" href="../../images/LineScaleMode_VERTICAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NONE"><apiName>NONE</apiName><shortdesc>
	将此设置用作 lineStyle() 方法的 scaleMode 参数时，线条粗细不会缩放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将此设置用作 <codeph>lineStyle()</codeph> 方法的 <codeph>scaleMode</codeph> 参数时，线条粗细不会缩放。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:NORMAL"><apiName>NORMAL</apiName><shortdesc>
	将此设置用作 lineStyle() 方法的 scaleMode 参数时，线条粗细会始终随对象的缩放而缩放（默认值）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>normal</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将此设置用作 <codeph>lineStyle()</codeph> 方法的 <codeph>scaleMode</codeph> 参数时，线条粗细会始终随对象的缩放而缩放（默认值）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:LineScaleMode:VERTICAL"><apiName>VERTICAL</apiName><shortdesc>
	将此设置用作 lineStyle() 方法的 scaleMode 参数时，线条粗细只会水平缩放。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>vertical</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	将此设置用作 <codeph>lineStyle()</codeph> 方法的 <codeph>scaleMode</codeph> 参数时，线条粗细<i>只会</i>水平缩放。例如，考虑下面的圆形，它们是用一个像素的线条绘制的，每个圆的 <codeph>scaleMode</codeph> 参数都被设置为 <codeph>LineScaleMode.HORIZONTAL</codeph>。左侧的圆仅在水平方向上缩放，右侧的圆同时在垂直和水平方向上缩放。
	
    <p><adobeimage alt="一个在水平方向缩放的圆和一个在水平和垂直方向同时缩放的圆。" href="../../images/LineScaleMode_HORIZONTAL.jpg"/></p>
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:Shader"><apiName>Shader</apiName><shortdesc>
	 Shader 实例表示 ActionScript 中的 Pixel Bender 着色器内核。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Shader 实例表示 ActionScript 中的 Pixel Bender 着色器内核。要在应用程序中使用着色器，请为它创建一个 Shader 实例。然后，根据要创造的效果，按适当的方式使用该 Shader 实例。例如，要将着色器用作滤镜，可将 Shader 实例赋予 ShaderFilter 对象的 <codeph>shader</codeph> 属性。
	 
	 <p>着色器定义对图像中的所有像素执行的函数（一次一个像素）。对该函数的每次调用的结果都是图像中该像素坐标处的输出颜色。着色器可以指定一个或多个输入图像，这些图像的内容可用于确定函数的输出。着色器还可以指定一个或多个参数，这些参数是可用于计算函数输出的输入值。在单一着色器执行中，输入和参数值是常量。唯一发生变化的是像素（其颜色是函数结果）的坐标。针对多个输出像素坐标的着色器函数调用将并行执行，以改进着色器执行性能。</p>
	 
	 <p>可以使用 URLLoader 实例在运行时加载着色器字节码。下面的示例演示如何在运行时加载着色器字节码文件并将其链接到一个 Shader 实例。</p>
	 
	 <codeblock>
	 var loader:URLLoader = new URLLoader();
	 loader.dataFormat = URLLoaderDataFormat.BINARY;
	 loader.addEventListener(Event.COMPLETE, onLoadComplete);
	 loader.load(new URLRequest("myShader.pbj"));
	  
	 var shader:Shader;
	  
	 function onLoadComplete(event:Event):void {
	     // Create a new shader and set the loaded data as its bytecode
	     shader = new Shader();
	     shader.byteCode = loader.data;
	     
	     // You can also pass the bytecode to the Shader() constructor like this:
	     // shader = new Shader(loader.data);
	     
	     // do something with the shader
	 }
	 </codeblock>
	 
	 <p>您还可以使用 <codeph>[Embed]</codeph> 元数据标记在编译时将着色器嵌入 SWF。只有在使用 Flex SDK 编译 SWF 时，<codeph>[Embed]</codeph> 元数据标记才可用。<codeph>[Embed]</codeph> 标记的 <codeph>source</codeph> 参数指向着色器文件，并且其 <codeph>mimeType</codeph> 参数为<codeph>“application/octet-stream”</codeph>，如此例中所示：</p>
	 
	 <codeblock>
	 [Embed(source="myShader.pbj", mimeType="application/octet-stream)]
	 var MyShaderClass:Class;
	  
	 // ...
	 
	 // create a new shader and set the embedded shader as its bytecode
	 var shaderShader = new Shader();
	 shader.byteCode = new MyShaderClass();
	  
	 // You can also pass the bytecode to the Shader() constructor like this:
	 // var shader:Shader = new Shader(new MyShaderClass());
	  
	 // do something with the shader
	 </codeblock>
	 
	 <p>在任何一种情况下，都可以将原始着色器（<codeph>URLLoader.data</codeph> 属性或 <codeph>[Embed]</codeph> 数据类的实例）链接到 Shader 实例。如前面的示例所演示，您可以采用两种方式执行此操作。可以将着色器字节代码作为参数传递到 <codeph>Shader()</codeph> 构造函数。或者，可以将其设置为 Shader 实例的 <codeph>byteCode</codeph> 属性。</p>
	 
	 <p>创建了 Shader 实例后，即可通过以下若干方式之一使用该实例：</p>
	 
	 <ul>
	   <li>着色器填充：使用着色器的输出作为利用绘图 API 所绘制内容的填充。将 Shader 实例作为参数传递到 <codeph>Graphics.beginShaderFill()</codeph> 方法。</li>
	   <li>着色器滤镜：使用着色器的输出作为应用于显示对象的图形滤镜。将 Shader 实例赋予 ShaderFilter 实例的 <codeph>shader</codeph> 属性。</li>
	   <li>混合模式：着色器的输出呈现为两个重叠显示对象之间的混合。将 Shader 实例赋予两个显示对象中位于上层的对象的 <codeph>blendShader</codeph> 属性。</li>
	   <li>后台着色器处理：着色器在后台执行（避免了冻结显示的可能性），并在处理完成时分派一个事件。将 Shader 实例赋予 ShaderJob 实例的 <codeph>shader</codeph> 属性。</li>
	 </ul>
	 
	 </apiDesc><example conref="examples\ShaderExample.1.as"> 下面的示例在运行时加载着色器字节码文件，并创建一个链接到该文件的 Shader 实例。
 
 <p>请注意，此示例假设应用程序输出目录所在的同一目录中有一个名为“donothing.pbj”的着色器字节码文件。<xref href="ShaderData.html#includeExamplesSummary">ShaderData 类示例</xref>中提供了 DoNothing 着色器的 Pixel Bender 源代码。</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;
    import flash.events.Event;
    import flash.net.URLLoader;
    import flash.net.URLLoaderDataFormat;
    import flash.net.URLRequest;

    public class LoadedShaderExample extends Sprite {
        
        private var loader:URLLoader;
        
        public function LoadedShaderExample() {
            loader = new URLLoader();
            loader.dataFormat = URLLoaderDataFormat.BINARY;
            loader.addEventListener(Event.COMPLETE, loadCompleteHandler);
            loader.load(new URLRequest("donothing.pbj"));
        }
        
        private function loadCompleteHandler(event:Event):void {
            var shader:Shader = new Shader();
            shader.byteCode = loader.data;
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example><example conref="examples\ShaderExample.2.as"> 下面的示例通过将着色器字节码文件编译到 SWF 中来嵌入该文件，并创建一个链接到该文件的 Shader 实例。
 
 <p>请注意，此示例假设应用程序源代码所在的同一目录中有一个名为“donothing.pbj”的着色器字节码文件，并且使用了 Flex SDK 来编译 SWF。<xref href="ShaderData.html#includeExamplesSummary">ShaderData 类示例</xref>中提供了 DoNothing 着色器的 Pixel Bender 源代码。</p>
<codeblock>

package {
    import flash.display.Shader;
    import flash.display.Sprite;

    public class EmbeddedShaderExample extends Sprite {
        
        [Embed(source="donothing.pbj", mimeType="application/octet-stream")]
        private static var DoNothingShader:Class;
        
        public function EmbeddedShaderExample() {
            var shader:Shader = new Shader();
            shader.byteCode = new DoNothingShader();
            
            // do something with the Shader instance
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#DisplayObject/blendShader"><linktext>flash.display.DisplayObject.blendShader</linktext></link><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#ShaderJob"><linktext>flash.display.ShaderJob</linktext></link><link href="flash.filters.xml#ShaderFilter"><linktext>flash.filters.ShaderFilter</linktext></link><link href="flash.net.xml#URLLoader"><linktext>flash.net.URLLoader</linktext></link></related-links><apiConstructor id="flash.display:Shader:flash.display:Shader"><apiName>Shader</apiName><shortdesc>
		 创建一个新的 Shader 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>code</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiData>null</apiData><apiDesc>要链接到 Shader 的原始着色器字节代码。
		 
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 创建一个新的 Shader 实例。
		 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shader:data:set"><apiName>data</apiName><shortdesc>
		 提供对 Shader 实例的参数、输入图像和元数据的访问。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>flash.display:ShaderData</apiValueClassifier></apiValueDef><apiDesc>
		 提供对 Shader 实例的参数、输入图像和元数据的访问。在创建 Shader 实例时，将动态添加表示着色器参数的 ShaderParameter 对象、表示着色器输入图像的 ShaderInput 对象以及表示着色器元数据的其它值，作为 <codeph>data</codeph> 属性对象的属性。可以使用这些属性对着色器进行内部检查，以及设置参数和输入值。
		 
		 <p>有关访问和处理 <codeph>data</codeph> 对象的动态属性的信息，请参阅 ShaderData 类说明。</p>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderData"><linktext>flash.display.ShaderData</linktext></link><link href="flash.display.xml#ShaderInput"><linktext>flash.display.ShaderInput</linktext></link><link href="flash.display.xml#ShaderParameter"><linktext>flash.display.ShaderParameter</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:precisionHint:set"><apiName>precisionHint</apiName><shortdesc>
		 着色器所执行数学运算的精度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 着色器所执行数学运算的精度。
		 
		 <p><codeph>precisionHint</codeph> 属性的可能值的集合由 ShaderPrecision 类中的常量定义。</p>
		 
		 <p>默认值为 <codeph>ShaderPrecision.FULL</codeph>。将精度设置为 <codeph>ShaderPrecision.FAST</codeph> 可以加快数学运算速度，但会降低精度。</p>
		 
		 <p>full 精度模式 (<codeph>ShaderPrecision.FULL</codeph>) 将按照 IEEE 32 位浮点标准的全宽计算所有数学运算，并在所有平台上提供一致的行为。在此模式下，某些数学运算（比如三角函数和指数函数）可能速度较慢。</p>
		 
		 <p>fast 精度模式 (<codeph>ShaderPrecision.FAST</codeph>) 旨在获得最高性能，但在不同平台上和各种 CPU 配置下工作不一致。多数情况下，这种精度级别足以创建无可见失真的图形效果。</p>
		 
		 <p>精度模式选择将影响以下着色器操作。在包含 SSE 指令集的 Intel 处理器上，这些操作的执行速度较快：</p>
		 
		 <ul>
		   <li><codeph>sin(x)</codeph></li>
		   <li><codeph>cos(x)</codeph></li>
		   <li><codeph>tan(x)</codeph></li>
		   <li><codeph>asin(x)</codeph></li>
		   <li><codeph>acos(x)</codeph></li>
		   <li><codeph>atan(x)</codeph></li>
		   <li><codeph>atan(x, y)</codeph></li>
		   <li><codeph>exp(x)</codeph></li>
		   <li><codeph>exp2(x)</codeph></li>
		   <li><codeph>log(x)</codeph></li>
		   <li><codeph>log2(x)</codeph></li>
		   <li><codeph>pow(x, y)</codeph></li>
		   <li><codeph>reciprocal(x)</codeph></li>
		   <li><codeph>sqrt(x)</codeph></li>
		 </ul>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderPrecision"><linktext>flash.display.ShaderPrecision</linktext></link></related-links></apiValue><apiValue id="flash.display:Shader:byteCode:set"><apiName>byteCode</apiName><shortdesc>
		 此 Shader 实例的原始着色器字节代码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>flash.utils:ByteArray</apiValueClassifier></apiValueDef><apiDesc>
		 此 Shader 实例的原始着色器字节代码。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IGraphicsData"><apiName>IGraphicsData</apiName><shortdesc>
	此接口用于定义可用作 flash.display.Graphics 方法中的参数的对象，包括填充、笔触和路径。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	此接口用于定义可用作 flash.display.Graphics 方法中的参数的对象，包括填充、笔触和路径。使用此接口的实现器类来创建和管理绘制属性数据，并将相同的数据重新用于不同的实例。然后，使用 Graphics 类的方法来呈现绘制对象。
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:MovieClip"><apiName>MovieClip</apiName><shortdesc>
 MovieClip 类从以下类继承而来：Sprite、DisplayObjectContainer、InteractiveObject、DisplayObject 和 EventDispatcher。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip object, built-in class
 
 </keyword></asCustoms></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiDynamic/><apiTipTexts><apiTipText>ActionScript 的基本显示对象创建了对象。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:Sprite</apiBaseClassifier></apiClassifierDef><apiDesc>
 MovieClip 类从以下类继承而来：Sprite、DisplayObjectContainer、InteractiveObject、DisplayObject 和 EventDispatcher。
 
 <p>不同于 Sprite 对象，MovieClip 对象拥有一个时间轴。</p>
 
 <p product="flash">MovieClip 类的方法提供的功能与定位影片剪辑的动作所提供的功能相同。还有一些其它方法在 Flash 创作工具的“动作”面板中的“动作”工具箱中没有等效动作。 </p>
 
 <p>在 Flash 创作工具中放到舞台上的子实例无法由父实例构造函数中的代码进行访问，因为在执行代码时尚未在该位置创建这些实例。在访问子实例之前，父实例必须通过代码创建子实例，或者延迟访问用于侦听子实例以分派其 <codeph>Event.ADDED_TO_STAGE</codeph> 事件的回调函数。</p>
 
 <p>如果修改包含补间动画的 MovieClip 对象的下列任一属性，该 MovieClip 对象中的播放头便会停止：<codeph>alpha</codeph>、<codeph>blendMode</codeph>、<codeph>filters</codeph>、<codeph>height</codeph>、<codeph>opaqueBackground</codeph>、<codeph>rotation</codeph>、<codeph>scaleX</codeph>、<codeph>scaleY</codeph>、<codeph>scale9Grid</codeph>、<codeph>scrollRect</codeph>、<codeph>transform</codeph>、<codeph>visible</codeph>、<codeph>width</codeph>、<codeph>x</codeph> 或 <codeph>y</codeph>。但是，它不会停止在该 MovieClip 对象的任何子 MovieClip 对象中的播放头。</p>
 
 </apiDesc><example conref="examples\MovieClipExample.as"> 下例用 MovieClipExample 类来说明如何监视 MovieClip 的各种属性。执行下列步骤可完成该任务：
 
 <ol>
 
  <li>构造函数定义一个文本字段，该文本字段用于显示 MovieClipExample 对象（扩展了 MovieClip）的属性值。</li>
 
  <li>将 <codeph>getPropertiesString()</codeph> 方法的返回值用作 <codeph>outputText</codeph> 文本字段的文本。<codeph>getPropertiesString()</codeph> 方法返回一个使用影片剪辑的以下属性值填充的字符串：<codeph>currentFrame</codeph>、<codeph>currentLabel</codeph>、<codeph>currentScene</codeph>、<codeph>framesLoaded</codeph>、<codeph>totalFrames</codeph> 和 <codeph>trackAsMenu</codeph>。</li>
 
  <li>构造函数中的两行代码调整 <codeph>outputText</codeph> 文本字段的 <codeph>width</codeph> 和 <codeph>height</codeph> 属性。</li>
 
  <li>构造函数的最后一行将 <codeph>outputText</codeph> 文本字段添加到显示列表。</li>
 
 </ol>
<codeblock>

package {
    import flash.display.MovieClip;
    import flash.text.TextField;

    public class MovieClipExample extends MovieClip {

        public function MovieClipExample() {
            var outputText:TextField = new TextField();
            outputText.text = getPropertiesString();
            outputText.width = stage.stageWidth;
            outputText.height = outputText.textHeight;
            addChild(outputText);
        }

        private function getPropertiesString():String {
            var str:String = ""
                + "currentFrame: " + currentFrame + "\n"
                + "currentLabel: " + currentLabel + "\n"
                + "currentScene: " + currentScene + "\n"
                + "framesLoaded: " + framesLoaded + "\n"
                + "totalFrames: " + totalFrames + "\n"
                + "trackAsMenu: " + trackAsMenu + "\n";
            return str;
        }
    }
}
</codeblock></example></apiClassifierDetail><apiConstructor id="flash.display:MovieClip:MovieClip"><apiName>MovieClip</apiName><shortdesc>
	创建新的 MovieClip 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	创建新的 MovieClip 实例。创建 MovieClip 之后，调用舞台上的显示对象容器的 <codeph>addChild()</codeph> 或 <codeph>addChildAt()</codeph> 方法。
	
	</apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="flash.display:MovieClip:gotoAndPlay"><apiName>gotoAndPlay</apiName><shortdesc>
	 从指定帧开始播放 SWF 文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandplay, gotoandplay
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>表示播放头转到的帧编号的数字，或者表示播放头转到的帧标签的字符串。如果您指定了一个数字，则该数字是相对于您指定的场景的。如果不指定场景，当前场景将确定要播放的全局帧编号。如果指定场景，播放头会跳到指定场景的帧编号。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>要播放的场景的名称。此参数是可选的。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 从指定帧开始播放 SWF 文件。这会在帧中的所有剩余动作执行完毕后发生。要指定场景以及帧，请指定 <codeph>scene</codeph> 参数的值。
	 
	 </apiDesc><example conref="examples\MovieClip.gotoAndPlay.1.as"> 下面的代码使用 <codeph>gotoAndPlay()</codeph> 方法指示 <codeph>mc1</codeph> 影片剪辑的播放头从其当前位置前进 5 帧：
<codeblock>
mc1.gotoAndPlay(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndPlay.2.as"> 下面的代码使用 <codeph>gotoAndPlay()</codeph> 方法指示 <codeph>mc1</codeph> 影片剪辑的播放头移到名为 <codeph>"Scene 12"</codeph> 的场景中标记为 <codeph>"intro"</codeph> 的帧：
<codeblock>
mc1.gotoAndPlay("intro", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:gotoAndStop"><apiName>gotoAndStop</apiName><shortdesc>
	  将播放头移到影片剪辑的指定帧并停在那里。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.gotoandstop, gotoandstop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>如果未在该影片剪辑中找到指定的 <codeph>scene</codeph> 或 <codeph>frame</codeph>。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>frame</apiItemName><apiOperationClassifier>Object</apiOperationClassifier><apiDesc>表示播放头转到的帧编号的数字，或者表示播放头转到的帧标签的字符串。如果您指定了一个数字，则该数字是相对于您指定的场景的。如果不指定场景，当前场景将确定转到其中并停止的全局帧编号。如果指定了场景，播放头会转到指定场景中的帧编号并停止。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>scene</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>场景的名称。此参数是可选的。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	  将播放头移到影片剪辑的指定帧并停在那里。这会在帧中的所有剩余动作执行完毕后发生。如果除了指定帧以外，您还希望指定场景，那么请指定 <codeph>scene</codeph> 参数。
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> 下面的代码使用 <codeph>gotoAndStop()</codeph> 方法和 <codeph>currentFrame</codeph> 属性指示 <codeph>mc1</codeph> 影片剪辑的播放头从其当前位置前进 5 帧并停止：
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example><example conref="examples\MovieClip.gotoAndStop.1.as"> 下面的代码使用 <codeph>gotoAndStop()</codeph> 指示 <codeph>mc1</codeph> 影片剪辑的播放头移到名为 <codeph>"Scene 12"</codeph> 的场景中标记为 <codeph>"finale"</codeph> 的帧并停止播放头：
<codeblock>
mc1.gotoAndStop("finale", "Scene 12");
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:nextFrame"><apiName>nextFrame</apiName><shortdesc>
	 将播放头转到下一帧并停止。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.nextframe, nextframe
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 将播放头转到下一帧并停止。这会在帧中的所有剩余动作执行完毕后发生。
	 
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> 在下例中，由两个 SimpleButton 对象控制时间轴。<codeph>prev</codeph> 按钮将播放头移动到前一帧，<codeph>nextBtn</codeph> 按钮将播放头移动到下一帧：
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/prevFrame()"><linktext>prevFrame()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:nextScene"><apiName>nextScene</apiName><shortdesc>
	 将播放头移动到 MovieClip 实例的下一场景。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 将播放头移动到 MovieClip 实例的下一场景。这会在帧中的所有剩余动作执行完毕后发生。
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> 在下例中，由两个 SimpleButton 对象控制时间轴。<codeph>prevBtn</codeph> 按钮将播放头移动到前一场景，<codeph>nextBtn</codeph> 按钮将播放头移动到下一场景：
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:play"><apiName>play</apiName><shortdesc>
	 在影片剪辑的时间轴中移动播放头。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.play, play
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 在影片剪辑的时间轴中移动播放头。
	 
	 </apiDesc><example conref="examples\MovieClip.play.1.as"> 下面的代码使用 <codeph>stop()</codeph> 方法来停止名为 <codeph>mc1</codeph> 的影片剪辑，并在用户单击名为 <codeph>continueText</codeph> 的文本字段时恢复播放：
<codeblock>

import flash.text.TextField;
import flash.events.MouseEvent;

var continueText:TextField = new TextField();
continueText.text = "Play movie...";
addChild(continueText);

mc1.stop();
continueText.addEventListener(MouseEvent.CLICK, resumeMovie);

function resumeMovie(event:MouseEvent):void {
    mc1.play();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.display.xml#MovieClip/gotoAndPlay()"><linktext>gotoAndPlay()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:MovieClip:prevFrame"><apiName>prevFrame</apiName><shortdesc>
	 将播放头转到前一帧并停止。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.prevframe, prevframe, previous frame
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 将播放头转到前一帧并停止。这会在帧中的所有剩余动作执行完毕后发生。
	  
	 </apiDesc><example conref="examples\MovieClip.prevFrame.1.as"> 在下例中，由两个 SimpleButton 对象控制时间轴。<codeph>prev</codeph> 按钮将播放头移动到前一帧，<codeph>nextBtn</codeph> 按钮将播放头移动到下一帧：
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevFrame();
}

function goForward(event:MouseEvent):void {
    mc1.nextFrame();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:prevScene"><apiName>prevScene</apiName><shortdesc>
	 将播放头移动到 MovieClip 实例的前一场景。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 将播放头移动到 MovieClip 实例的前一场景。这会在帧中的所有剩余动作执行完毕后发生。
	 
	 </apiDesc><example conref="examples\MovieClip.prevScene.1.as"> 在下例中，由两个 SimpleButton 对象控制时间轴。<codeph>prevBtn</codeph> 按钮将播放头移动到前一场景，<codeph>nextBtn</codeph> 按钮将播放头移动到下一场景：
<codeblock>

import flash.events.MouseEvent;

mc1.stop();
prevBtn.addEventListener(MouseEvent.CLICK, goBack);
nextBtn.addEventListener(MouseEvent.CLICK, goForward);

function goBack(event:MouseEvent):void {
    mc1.prevScene();
}

function goForward(event:MouseEvent):void {
    mc1.nextScene();
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.display:MovieClip:stop"><apiName>stop</apiName><shortdesc>
	 停止影片剪辑中的播放头。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.stop, stop
	 </keyword></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 停止影片剪辑中的播放头。
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.display:MovieClip:currentFrame:get"><apiName>currentFrame</apiName><shortdesc>
	 指定播放头在 MovieClip 实例的时间轴中所处的帧的编号。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.currentFrame, currentFrame, currentFrame
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 指定播放头在 MovieClip 实例的时间轴中所处的帧的编号。如果影片剪辑有多个场景，该值是当前场景中的帧编号。
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrame.1.as"> 下面的代码使用 <codeph>gotoAndStop()</codeph> 方法和 <codeph>currentFrame</codeph> 属性指示 <codeph>mc1</codeph> 影片剪辑的播放头从其当前位置前进 5 帧并停止：
<codeblock>
mc1.gotoAndStop(mc1.currentFrame + 5);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentFrameLabel:get"><apiName>currentFrameLabel</apiName><shortdesc>
	 MovieClip 实例的时间轴中当前帧上的标签。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip 实例的时间轴中当前帧上的标签。如果当前帧没有标签，则 <codeph>currentLabel</codeph> 为 <codeph>null</codeph>。
	 
	 </apiDesc><example conref="examples\MovieClip.currentFrameLabel.1.as"/></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabel:get"><apiName>currentLabel</apiName><shortdesc>
	 在 MovieClip 实例的时间轴中播放头所在的当前标签。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 在 MovieClip 实例的时间轴中播放头所在的当前标签。如果当前帧没有标签，<codeph>currentLabel</codeph> 将被设置为包含标签的先前帧的名称。如果当前帧和先前帧都不包含标签，<codeph>currentLabel</codeph> 返回 <codeph>null</codeph>。
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabel.1.as"> 以下代码说明如何访问名为 <codeph>mc1</codeph> 的 MovieClip 对象的 <codeph>currentLabel</codeph> 属性：
<codeblock>
trace(mc1.currentLabel);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:currentLabels:get"><apiName>currentLabels</apiName><shortdesc>
	 返回由当前场景的 FrameLabel 对象组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 返回由当前场景的 FrameLabel 对象组成的数组。如果 MovieClip 实例不使用场景，数组会包括整个 MovieClip 实例的所有帧标签。
	 
	 </apiDesc><example conref="examples\MovieClip.currentLabels.1.as"> 以下代码说明如何使用名为 <codeph>mc1</codeph> 的 MovieClip 对象的 <codeph>currentLabels</codeph> 属性：
<codeblock>
import flash.display.FrameLabel;
 
var labels:Array = mc1.currentLabels;

for (var i:uint = 0; i &lt; labels.length; i++) {
    var label:FrameLabel = labels[i];
    trace("frame " + label.frame + ": " + label.name);
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#FrameLabel"><linktext>flash.display.FrameLabel</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:currentScene:get"><apiName>currentScene</apiName><shortdesc>
	 在 MovieClip 实例的时间轴中播放头所在的当前场景。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Scene</apiValueClassifier></apiValueDef><apiDesc>
	 在 MovieClip 实例的时间轴中播放头所在的当前场景。
	 
	 </apiDesc><example conref="examples\MovieClip.currentScene.1.as"> 以下代码说明如何使用名为 <codeph>mc1</codeph> 的 MovieClip 对象的 <codeph>currentScene</codeph> 属性：
<codeblock>
import flash.display.Scene;
 
var scene:Scene = mc1.currentScene;
trace(scene.name + ": " + scene.numFrames + " frames");
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:enabled:get"><apiName>enabled</apiName><shortdesc>
	 一个布尔值，指示影片剪辑是否处于活动状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 一个布尔值，指示影片剪辑是否处于活动状态。<codeph>enabled</codeph> 的默认值是 <codeph>true</codeph>。如果将 <codeph>enabled</codeph> 设置为 <codeph>false</codeph>，则会禁用影片剪辑的 Over、Down 和 Up 帧。影片剪辑会继续接收事件（例如 <codeph>mouseDown</codeph>、<codeph>mouseUp</codeph>、<codeph>keyDown</codeph> 和 <codeph>keyUp</codeph>）。
	 
	 <p><codeph>enabled</codeph> 属性仅控制影片剪辑的按钮式属性。可以随时更改 <codeph>enabled</codeph> 属性；修改后的影片剪辑将被立即启用或禁用。如果将 <codeph>enabled</codeph> 属性设置为 <codeph>false</codeph>，则该对象将不包含在 Tab 键的自动排序中。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.enabled.1.as"> 以下代码说明如何使用 <codeph>enabled</codeph> 属性来禁用名为 <codeph>mc1</codeph> 的 MovieClip 对象的按钮式属性：
<codeblock>
mc1.enabled = false;
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:framesLoaded:get"><apiName>framesLoaded</apiName><shortdesc>
	 从流式 SWF 文件加载的帧数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.framesLoaded, framesLoaded, framesloaded
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 从流式 SWF 文件加载的帧数。可以使用 <codeph>framesLoaded</codeph> 属性来确定特定帧及其前面所有帧的内容是否已经加载，并且是否可在浏览器中供本地使用。可以使用它监视大 SWF 文件的下载。例如，可能需要向用户显示一条消息以表明在完成 SWF 文件中指定帧的加载前，SWF 文件将会一直进行加载。
	 
	 <p>如果影片剪辑包含多个场景，<codeph>framesLoaded</codeph> 属性会返回为影片剪辑中<i>所有</i> 场景加载的帧数。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.framesLoaded.1.as"> 以下代码说明如何使用 <codeph>framesLoaded</codeph> 属性和 <codeph>totalFrames</codeph> 属性来确定名为 <codeph>mc1</codeph> 的流式 MovieClip 对象是否已完全加载：
<codeblock>
if (mc1.framesLoaded == mc1.totalFrames) {
    trace("OK.");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Loader"><linktext>Loader 类</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:scenes:get"><apiName>scenes</apiName><shortdesc>
	 一个由 Scene 对象组成的数组，每个对象都列出了 MovieClip 实例中场景的名称、帧数和帧标签。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Array</apiValueClassifier></apiValueDef><apiDesc>
	 一个由 Scene 对象组成的数组，每个对象都列出了 MovieClip 实例中场景的名称、帧数和帧标签。
	 
	 </apiDesc><example conref="examples\MovieClip.scenes.1.as"> 以下代码说明如何使用名为 <codeph>mc1</codeph> 的 MovieClip 对象的 <codeph>scenes</codeph> 属性：
<codeblock>
import flash.display.Scene;
 
for (var i:uint = 0; i &lt; mc1.scenes.length; i++) {
    var scene:Scene = mc1.scenes[i];
    trace("scene " + scene.name + ": " + scene.numFrames + " frames");
}
</codeblock></example></apiValueDetail><related-links><link href="flash.display.xml#Scene"><linktext>Scene</linktext></link></related-links></apiValue><apiValue id="flash.display:MovieClip:totalFrames:get"><apiName>totalFrames</apiName><shortdesc>
	 MovieClip 实例中帧的总数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata><asCustoms><keyword>movieclip, movieclip.totalFrames, totalFrames, totalFrames
	 </keyword></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
	 MovieClip 实例中帧的总数。
	 
	 <p>如果影片剪辑包含多个帧，<codeph>totalFrames</codeph> 属性会返回影片剪辑中的<i>所有</i> 场景中的帧的总数。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.totalFrames.1.as"> 以下代码说明如何使用名为 <codeph>mc1</codeph> 的 MovieClip 对象的 <codeph>totalFrames</codeph> 属性：
<codeblock>
 trace(mc1.totalFrames);
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.display:MovieClip:trackAsMenu:get"><apiName>trackAsMenu</apiName><shortdesc>
	 指示属于 SimpleButton 或 MovieClip 对象的其它显示对象是否可以接收鼠标释放事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
	 指示属于 SimpleButton 或 MovieClip 对象的其它显示对象是否可以接收鼠标释放事件。<codeph>trackAsMenu</codeph> 属性允许您创建菜单。可以对任何 SimpleButton 或 MovieClip 对象设置 <codeph>trackAsMenu</codeph> 属性。<codeph>trackAsMenu</codeph> 属性的默认值是 <codeph>false</codeph>。 
	 
	 <p>可以随时更改 <codeph>trackAsMenu</codeph> 属性；修改后的影片剪辑会立即使用新的行为。</p>
	 
	 </apiDesc><example conref="examples\MovieClip.trackAsMenu.1.as"> 以下代码说明如何使用 <codeph>trackAsMenu</codeph> 属性来启用名为 <codeph>mc1</codeph> 的 MovieClip 对象的鼠标释放事件：
<codeblock>
 mc1.trackAsMenu = true;
</codeblock></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SWFVersion"><apiName>SWFVersion</apiName><shortdesc>
	SWFVersion 类是可指示已加载 SWF 文件的文件格式版本的常量值枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	SWFVersion 类是可指示已加载 SWF 文件的文件格式版本的常量值枚举。提供的 SWFVersion 常量用于检查 flash.display.LoaderInfo 对象的 <codeph>swfVersion</codeph> 属性。
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/swfVersion"><linktext>flash.display.LoaderInfo.swfVersion</linktext></link></related-links><apiValue id="flash.display:SWFVersion:FLASH1"><apiName>FLASH1</apiName><shortdesc>
		SWF 文件格式版本 1.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 1.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH10"><apiName>FLASH10</apiName><shortdesc>
		SWF 文件格式版本 10.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>10</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 10.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH2"><apiName>FLASH2</apiName><shortdesc>
		SWF 文件格式版本 2.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 2.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH3"><apiName>FLASH3</apiName><shortdesc>
		SWF 文件格式版本 3.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 3.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH4"><apiName>FLASH4</apiName><shortdesc>
		SWF 文件格式版本 4.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 4.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH5"><apiName>FLASH5</apiName><shortdesc>
		SWF 文件格式版本 5.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 5.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH6"><apiName>FLASH6</apiName><shortdesc>
		SWF 文件格式版本 6.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>6</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 6.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH7"><apiName>FLASH7</apiName><shortdesc>
		SWF 文件格式版本 7.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>7</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 7.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH8"><apiName>FLASH8</apiName><shortdesc>
		SWF 文件格式版本 8.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 8.0。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SWFVersion:FLASH9"><apiName>FLASH9</apiName><shortdesc>
		SWF 文件格式版本 9.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>9</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		SWF 文件格式版本 9.0。 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:NativeWindowResize"><apiName>NativeWindowResize</apiName><shortdesc>
NativeWindowResize 类定义一些常量，它们表示 NativeWindow startResize() 方法的 edgeOrCorner 参数的可能值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
NativeWindowResize 类定义一些常量，它们表示 NativeWindow <codeph>startResize()</codeph> 方法的 <codeph>edgeOrCorner</codeph> 参数的可能值。 
<p>定义常量以命名窗口的每条边和每个角。</p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#NativeWindow/startResize()"><linktext>flash.display.NativeWindow.startResize()</linktext></link></related-links><apiValue id="flash.display:NativeWindowResize:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
窗口的底边。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的底边。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
窗口的左下角。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的左下角。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
窗口的右下角。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的右下角。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:LEFT"><apiName>LEFT</apiName><shortdesc>
窗口的左边。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的左边。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:NONE"><apiName>NONE</apiName><shortdesc>
不向系统提供有关要调整大小的边或角的提示，从而允许使用默认行为。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
不向系统提供有关要调整大小的边或角的提示，从而允许使用默认行为。

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:RIGHT"><apiName>RIGHT</apiName><shortdesc>
窗口的右边。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的右边。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP"><apiName>TOP</apiName><shortdesc>
窗口的顶边。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的顶边。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
窗口的左上角。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的左上角。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:NativeWindowResize:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
窗口的右上角。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
窗口的右上角。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:BitmapDataChannel"><apiName>BitmapDataChannel</apiName><shortdesc>
BitmapDataChannel 类是常数值枚举，指示要使用的通道：红色通道、蓝色通道、绿色通道或 Alpha 透明度通道。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
BitmapDataChannel 类是常数值枚举，指示要使用的通道：红色通道、蓝色通道、绿色通道或 Alpha 透明度通道。 

<p>调用某些方法时，您可以使用按位 OR 运算符 (<codeph>|</codeph>) 来合并 BitmapDataChannel 常数，从而指示多个颜色通道。</p>

<p>提供的 BitmapDataChannel 常数用作以下参数或属性的值：</p>

<ul>

	<li><codeph>flash.display.BitmapData.copyChannel()</codeph> 方法的 <codeph>sourceChannel</codeph> 和 <codeph>destChannel</codeph> 参数</li>

	<li><codeph>flash.display.BitmapData.noise()</codeph> 方法的 <codeph>channelOptions</codeph> 参数</li>

	<li><codeph>flash.filters.DisplacementMapFilter.componentX</codeph> 和 <codeph>flash.filters.DisplacementMapFilter.componentY</codeph> 属性</li>

</ul>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/copyChannel()"><linktext>flash.display.BitmapData.copyChannel()</linktext></link><link href="flash.display.xml#BitmapData/noise()"><linktext>flash.display.BitmapData.noise()</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentX"><linktext>flash.filters.DisplacementMapFilter.componentX</linktext></link><link href="flash.filters.xml#DisplacementMapFilter/componentY"><linktext>flash.filters.DisplacementMapFilter.componentY</linktext></link></related-links><apiValue id="flash.display:BitmapDataChannel:ALPHA"><apiName>ALPHA</apiName><shortdesc>
		Alpha 通道。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>8</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		Alpha 通道。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:BLUE"><apiName>BLUE</apiName><shortdesc> 
		蓝色通道。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc> 
		蓝色通道。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:GREEN"><apiName>GREEN</apiName><shortdesc>
		绿色通道。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		绿色通道。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:BitmapDataChannel:RED"><apiName>RED</apiName><shortdesc>
		红色通道。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		红色通道。 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 定义实心填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义实心填充。 
 
 <p>
 将 GraphicsSolidFill 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。绘制 GraphicsSolidFill 对象与调用 <codeph>Graphics.beginFill()</codeph> 方法是等效的。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginFill()"><linktext>flash.display.Graphics.beginFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsSolidFill:GraphicsSolidFill"><apiName>GraphicsSolidFill</apiName><shortdesc>
 创建新的 GraphicsSolidFill 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>color</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>颜色值。有效值采用十六进制格式 0xRRGGBB。  
 </apiDesc></apiParam><apiParam><apiItemName>alpha</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiData>1.0</apiData><apiDesc>Alpha 透明度值。有效值为 0（完全透明）到 1（完全不透明）。
 
 </apiDesc></apiParam></apiConstructorDef><apiDesc>
 创建新的 GraphicsSolidFill 对象。 
 
 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:GraphicsSolidFill:alpha"><apiName>alpha</apiName><shortdesc>
 指示填充的 Alpha 透明度值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>1.0</apiData><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
 指示填充的 Alpha 透明度值。有效值为 0（完全透明）到 1（完全不透明）。默认值为 1。Alpha 设置为 0 的显示对象是活动的，即使它们不可见。 
 
 
 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsSolidFill:color"><apiName>color</apiName><shortdesc>
 填充的颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiData>0</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
 填充的颜色。有效值采用十六进制格式 0xRRGGBB。默认值为 0xFF0000（或 uint 0）。 
 
 
 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:IBitmapDrawable"><apiName>IBitmapDrawable</apiName><shortdesc>
	IBitmapDrawable 接口由可以作为 BitmapData 类 draw() 方法 source 参数传递的对象来实现。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	IBitmapDrawable 接口由可作为 BitmapData 类 <codeph>draw()</codeph> 方法的 <codeph>source</codeph> 参数传递的对象来实现。这些对象的类型为 BitmapData 或 DisplayObject。 
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#BitmapData/draw()"><linktext>flash.display.BitmapData.draw()</linktext></link><link href="flash.display.xml#BitmapData"><linktext>flash.display.BitmapData</linktext></link><link href="flash.display.xml#DisplayObject"><linktext>flash.display.DisplayObject</linktext></link></related-links></apiClassifier><apiClassifier id="flash.display:CapsStyle"><apiName>CapsStyle</apiName><shortdesc>
 CapsStyle 类是可指定在绘制线条中使用的端点样式的常量值枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 CapsStyle 类是可指定在绘制线条中使用的端点样式的常量值枚举。常量可用作 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>caps</codeph> 参数中的值。可以指定以下三种类型的端点：
 
 <p><adobeimage alt="三种类型的端点：NONE、ROUND 和 SQUARE。" href="../../images/linecap.jpg"/></p> 
 
 </apiDesc><example conref="examples\CapsStyleExample.as"> 下例使用 <codeph>CapsStyleExample</codeph> 类绘制三条平行线，并且每条平行线具有不同的线条端点样式。
 <ol>
     <li>每条线的属性设置如下所示：
     <ul>
         <li>将线条长度设置为 80 像素。</li>
         <li>将边框颜色设置为橙色。</li>
         <li>将边框大小设置为 30 像素。 </li>
         <li>将加亮颜色设置为灰色。 </li>
         <li>加亮大小设置为 0 像素。</li>
         <li>将 Alpha 设置为 1，使其成为实线。</li>
         <li>将像素提示设置为 false（不提示笔触采用全部像素）。</li>
         <li>将线条缩放模式设置为正常，这将缩放粗细。 </li>
         <li>边框端点的联接点样式设置为 <codeph>MITER</codeph>。</li>
         <li>尖角限制设置为 1，指示在接近线条处切断尖角。</li>
     </ul></li>
    <li>类构造函数以 <i>x = 0, y = 0</i> 为起点创建三条垂直线，方法是使用三种不同的线条端点样式（无、圆头和方头）对 <codeph>drawLine()</codeph> 方法进行三次调用。<codeph>drawLine()</codeph> 方法的每次调用（共三次）都使用先前列出的端点样式和属性来绘制垂直线和相关线条加亮效果。这些调用首先创建一个新的 <codeph>child</codeph> Shape 对象，然后使用 Graphics 类的方法来设置线条样式并绘制线条及加亮效果。<codeph>child</codeph> 的每个实例添加到显示列表中并在舞台上进行绘制。</li>
     <li>通过使用 <codeph>refreshLayout()</codeph> 方法，在 <i>y = 80</i> 像素处、从 <i>x = 80</i> 像素开始以 25 像素的线段间距重绘连接的线段。</li>
 </ol>
<codeblock>
package {
    import flash.display.CapsStyle;
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class CapsStyleExample extends Sprite {
        private var lineLength:uint            = 80;
        private var borderColor:uint           = 0xFFCC00;
        private var borderSize:uint            = 30;
        private var highlightColor:uint        = 0x666666;
        private var highlightSize:uint         = 0;
        private var gutter:uint                = 25;
        private var borderAlpha:uint           = 1;
        private var borderPixelHinting:Boolean = false;
        private var borderScaleMode:String     = LineScaleMode.NORMAL;
        private var borderJointStyle:String    = JointStyle.MITER;
        private var borderMiterLimit:uint      = 1;

        public function CapsStyleExample() {
            drawLine(CapsStyle.NONE);
            drawLine(CapsStyle.ROUND);
            drawLine(CapsStyle.SQUARE);
            refreshLayout();
        }

        private function drawLine(capsStyle:String):void {
            var child:Shape = new Shape();
            child.graphics.lineStyle(borderSize,
                                     borderColor,
                                     borderAlpha,
                                     borderPixelHinting,
                                     borderScaleMode,
                                     capsStyle,
                                     borderJointStyle,
                                     borderMiterLimit);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);
            child.graphics.endFill();

            child.graphics.moveTo(0, 0);
            child.graphics.lineStyle(highlightSize, highlightColor);
            child.graphics.lineTo(0, 0);
            child.graphics.lineTo(0, lineLength);

            addChild(child);
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = lineLength;
            lastChild.y = lineLength;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = lineLength;
                lastChild = child;
            }
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/lineStyle()"><linktext>flash.display.Graphics.lineStyle()</linktext></link></related-links><apiValue id="flash.display:CapsStyle:NONE"><apiName>NONE</apiName><shortdesc>
	 
	 用于在 flash.display.Graphics.lineStyle() 方法的 caps 参数中指定没有端点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 用于在 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>caps</codeph> 参数中指定没有端点。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:ROUND"><apiName>ROUND</apiName><shortdesc>
	 
	 用于在 flash.display.Graphics.lineStyle() 方法的 caps 参数中指定圆头端点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>round</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 用于在 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>caps</codeph> 参数中指定圆头端点。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:CapsStyle:SQUARE"><apiName>SQUARE</apiName><shortdesc>
	 
	 用于在 flash.display.Graphics.lineStyle() 方法的 caps 参数中指定方头端点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>square</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 
	 用于在 <codeph>flash.display.Graphics.lineStyle()</codeph> 方法的 <codeph>caps</codeph> 参数中指定方头端点。
	 
	 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageScaleMode"><apiName>StageScaleMode</apiName><shortdesc>
StageScaleMode 类为 Stage.scaleMode 属性提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageScaleMode 类为 <codeph>Stage.scaleMode</codeph> 属性提供值。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/scaleMode"><linktext>flash.display.Stage.scaleMode</linktext></link></related-links><apiValue id="flash.display:StageScaleMode:EXACT_FIT"><apiName>EXACT_FIT</apiName><shortdesc>
指定整个应用程序在指定区域中可见，但不尝试保持原始高宽比。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>exactFit</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定整个应用程序在指定区域中可见，但不尝试保持原始高宽比。可能会发生扭曲。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_BORDER"><apiName>NO_BORDER</apiName><shortdesc>
指定整个应用程序填满指定区域，不会发生扭曲，但有可能会进行一些裁切，同时保持应用程序的原始高宽比。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noBorder</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定整个应用程序填满指定区域，不会发生扭曲，但有可能会进行一些裁切，同时保持应用程序的原始高宽比。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:NO_SCALE"><apiName>NO_SCALE</apiName><shortdesc>
指定应用程序的大小是固定的，因此，即使在更改播放器窗口大小时，它仍然保持不变。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>noScale</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定应用程序的大小是固定的，因此，即使在更改播放器窗口大小时，它仍然保持不变。如果播放器窗口比内容小，则可能进行一些裁切。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageScaleMode:SHOW_ALL"><apiName>SHOW_ALL</apiName><shortdesc>
指定整个应用程序在指定区域中可见，且不会发生扭曲，同时保持应用程序的原始高宽比。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>showAll</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定整个应用程序在指定区域中可见，且不会发生扭曲，同时保持应用程序的原始高宽比。应用程序的两侧可能会显示边框。

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:SpreadMethod"><apiName>SpreadMethod</apiName><shortdesc>
SpreadMethod 类为 Graphics 类的 beginGradientFill() 和 lineGradientStyle() 方法中的 spreadMethod 参数提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
SpreadMethod 类为 Graphics 类的 <codeph>beginGradientFill()</codeph> 和 <codeph>lineGradientStyle()</codeph> 方法中的 <codeph>spreadMethod</codeph> 参数提供值。

<p>下例显示了使用各种 spread 方法的同一渐变填充：</p>

<adobetable>





<tgroup cols="3"><tbody><row>

	<entry align="center"><adobeimage alt="以 SpreadMethod.PAD 线性渐变" href="../../images/beginGradientFill_spread_pad.jpg"/></entry>

  <entry align="center"><adobeimage alt="以 SpreadMethod.REFLECT 线性渐变" href="../../images/beginGradientFill_spread_reflect.jpg"/></entry>

  <entry align="center"><adobeimage alt="以 SpreadMethod.REPEAT 线性渐变" href="../../images/beginGradientFill_spread_repeat.jpg"/></entry>

</row><row>

	 <entry align="center"><codeph>SpreadMethod.PAD</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REFLECT</codeph></entry>

	 <entry align="center"><codeph>SpreadMethod.REPEAT</codeph></entry>


</row></tbody></tgroup></adobetable>


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginGradientFill()"><linktext>flash.display.Graphics.beginGradientFill()</linktext></link><link href="flash.display.xml#Graphics/lineGradientStyle()"><linktext>flash.display.Graphics.lineGradientStyle()</linktext></link></related-links><apiValue id="flash.display:SpreadMethod:PAD"><apiName>PAD</apiName><shortdesc>
指定渐变使用 pad spread 方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>pad</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定渐变使用 <i>pad</i> spread 方法。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REFLECT"><apiName>REFLECT</apiName><shortdesc>
指定渐变使用 reflect spread 方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>reflect</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定渐变使用 <i>reflect</i> spread 方法。
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:SpreadMethod:REPEAT"><apiName>REPEAT</apiName><shortdesc>
指定渐变使用 repeat spread 方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>repeat</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定渐变使用 <i>repeat</i> spread 方法。
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:FocusDirection"><apiName>FocusDirection</apiName><shortdesc>
 FocusDirection 类枚举用于 Stage 对象的 assignFocus() 方法的 direction 参数以及 FocusEvent 对象的 direction 属性的值。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 FocusDirection 类枚举用于 Stage 对象的 <codeph>assignFocus()</codeph> 方法的 <codeph>direction</codeph> 参数以及 FocusEvent 对象的 <codeph>direction</codeph> 属性的值。
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.events.xml#FocusEvent/direction"><linktext>flash.events.FocusEvent.direction</linktext></link><link href="flash.display.xml#Stage/assignFocus()"><linktext>flash.display.Stage.assignFocus()</linktext></link></related-links><apiValue id="flash.display:FocusDirection:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
		指示应使位于读取顺序结尾的对象获得焦点。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bottom</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		指示应使位于读取顺序结尾的对象获得焦点。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:NONE"><apiName>NONE</apiName><shortdesc>
		指示交互式对象内的焦点对象应不更改。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		指示交互式对象内的焦点对象应不更改。
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:FocusDirection:TOP"><apiName>TOP</apiName><shortdesc>
		指示应使位于读取顺序开头的对象获得焦点。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>top</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		指示应使位于读取顺序开头的对象获得焦点。
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:StageAlign"><apiName>StageAlign</apiName><shortdesc>
StageAlign 类提供了用于 Stage.align 属性的常量值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
StageAlign 类提供了用于 <codeph>Stage.align</codeph> 属性的常量值。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/align"><linktext>flash.display.Stage.align</linktext></link></related-links><apiValue id="flash.display:StageAlign:BOTTOM"><apiName>BOTTOM</apiName><shortdesc>
指定舞台靠底部对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>B</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠底部对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_LEFT"><apiName>BOTTOM_LEFT</apiName><shortdesc>
指定舞台靠左下角对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠左下角对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:BOTTOM_RIGHT"><apiName>BOTTOM_RIGHT</apiName><shortdesc>
指定舞台靠右下角对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>BR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠右下角对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:LEFT"><apiName>LEFT</apiName><shortdesc>
指定舞台靠左对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>L</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠左对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:RIGHT"><apiName>RIGHT</apiName><shortdesc>
指定舞台靠右对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>R</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠右对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP"><apiName>TOP</apiName><shortdesc>
指定舞台靠顶部对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>T</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠顶部对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_LEFT"><apiName>TOP_LEFT</apiName><shortdesc>
指定舞台靠左上角对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TL</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠左上角对齐。 
</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:StageAlign:TOP_RIGHT"><apiName>TOP_RIGHT</apiName><shortdesc>
指定舞台靠右上角对齐。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>TR</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
指定舞台靠右上角对齐。 
</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ColorCorrectionSupport"><apiName>ColorCorrectionSupport</apiName><shortdesc>
ColorCorrectionSupport 类可为 flash.display.Stage.colorCorrectionSupport 属性提供值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
ColorCorrectionSupport 类可为 <codeph>flash.display.Stage.colorCorrectionSupport</codeph> 属性提供值。 

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Stage/colorCorrectionSupport"><linktext>flash.display.Stage.colorCorrectionSupport</linktext></link></related-links><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_OFF"><apiName>DEFAULT_OFF</apiName><shortdesc>
支持颜色校正，默认情况下为关闭状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOff</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
支持颜色校正，默认情况下为关闭状态。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:DEFAULT_ON"><apiName>DEFAULT_ON</apiName><shortdesc>
支持颜色校正，默认情况下为打开状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>defaultOn</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
支持颜色校正，默认情况下为打开状态。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ColorCorrectionSupport:UNSUPPORTED"><apiName>UNSUPPORTED</apiName><shortdesc>
主机环境不支持颜色校正。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>unsupported</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
主机环境不支持颜色校正。 

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
 定义着色器填充。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsFill</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义着色器填充。 
 
 <p>
 将 GraphicsShaderFill 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。绘制 GraphicsShaderFill 对象与调用 <codeph>Graphics.beginShaderFill()</codeph> 方法是等效的。
 </p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/beginShaderFill()"><linktext>flash.display.Graphics.beginShaderFill()</linktext></link><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsShaderFill:GraphicsShaderFill"><apiName>GraphicsShaderFill</apiName><shortdesc>
     创建新的 GraphicsShaderFill 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>shader</apiItemName><apiOperationClassifier>flash.display:Shader</apiOperationClassifier><apiData>null</apiData><apiDesc>要用于填充的着色器。此 Shader 实例无需指定图像输入。但是，如果在着色器中指定了图像输入，则必须手动提供输入，方法是设置 <codeph>Shader.data</codeph> 属性的对应 ShaderInput 属性的 <codeph>input</codeph> 属性。
     
     </apiDesc></apiParam><apiParam><apiItemName>matrix</apiItemName><apiOperationClassifier>flash.geom:Matrix</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 matrix 对象（属于 flash.geom.Matrix 类），可用于对着色器定义转换。 
     
     </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的 GraphicsShaderFill 对象。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiConstructor><apiValue id="flash.display:GraphicsShaderFill:matrix"><apiName>matrix</apiName><shortdesc>
     一个 matrix 对象（属于 flash.geom.Matrix 类），可用于对着色器定义转换。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.geom:Matrix</apiValueClassifier></apiValueDef><apiDesc>
     一个 matrix 对象（属于 flash.geom.Matrix 类），可用于对着色器定义转换。例如，可以使用以下矩阵将着色器旋转 45 度（pi/4 弧度）：
     
     <codeblock>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </codeblock>
     
     <p>着色器中收到的坐标基于为 <codeph>matrix</codeph> 参数指定的矩阵。对于默认 (<codeph>null</codeph>) 矩阵，着色器中的坐标是可用于对输入采样的局部像素坐标。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.geom.xml#Matrix"><linktext>flash.geom.Matrix</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsShaderFill:shader"><apiName>shader</apiName><shortdesc>
     要用于填充的着色器。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueClassifier>flash.display:Shader</apiValueClassifier></apiValueDef><apiDesc>
     要用于填充的着色器。此 Shader 实例无需指定图像输入。但是，如果在着色器中指定了图像输入，则必须手动提供输入，方法是设置 <codeph>Shader.data</codeph> 属性的对应 ShaderInput 属性的 <codeph>input</codeph> 属性。
     
     <p>传递 Shader 实例作为参数时，将在内部复制着色器，并且绘制填充操作将使用该内部副本（而不是对原始着色器的引用）。对着色器进行的任何更改（比如更改参数值、输入或字节代码）不会应用于所复制的用于填充的着色器。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Shader"><linktext>flash.display.Shader</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:Shape"><apiName>Shape</apiName><shortdesc>
 此类用于使用 ActionScript 绘图应用程序编程接口 (API) 创建简单形状。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiTipTexts><apiTipText>用于形状的显示对象。
 
 </apiTipText></apiTipTexts><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 此类用于使用 ActionScript 绘图应用程序编程接口 (API) 创建简单形状。Shape 类包括 <codeph>graphics</codeph> 属性，该属性使您可以从 Graphics 类访问方法。
 
 <p>Sprite 类也包括 <codeph>graphics</codeph> 属性，并且它包括不可用于 Shape 类的其它功能。例如，Sprite 对象是显示对象容器，而 Shape 对象不是（并且不能包含子显示对象）。由于此原因，Shape 对象会比包含相同图形的 Sprite 对象消耗的内存少。但是，Sprite 对象支持鼠标单击事件，而 Shape 对象不支持。</p>
 
 </apiDesc><example conref="examples\ShapeExample.as"> 下例使用 <codeph>ShapeExample</codeph> 类绘制圆形、圆角矩形和正方形。执行下列步骤可完成该任务：
 
 <ol>
    <li>声明 <codeph>size</codeph> 属性以备日后在确定每个形状的大小时使用。</li>
 
     <li>声明以下属性：将背景色设置为橙色、将边框颜色设置为深灰色、将边框大小设置为 0 个像素、将角半径设置为 9 个像素并将舞台边缘与其它对象之间的间距设置为 5 个像素。</li>
 
    <li>使用在前一步骤中声明的属性以及 Graphics 类的内置方法在坐标（x = 0，y = 0）处绘制圆形、圆角矩形和正方形。</li>
 
    <li>通过使用 <codeph>refreshLayout()</codeph> 方法，沿舞台顶部重新绘制每个形状，起点为 x = 5，y = 5，各形状之间的间隔为 5 个像素。</li>
 
 </ol>
<codeblock>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.JointStyle;
    import flash.display.LineScaleMode;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class ShapeExample extends Sprite {
        private var size:uint           = 80;
        private var bgColor:uint       = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function ShapeExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size/2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</codeblock></example></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics"><linktext>flash.display.Graphics</linktext></link><link href="flash.display.xml#Sprite"><linktext>flash.display.Sprite</linktext></link></related-links><apiConstructor id="flash.display:Shape:Shape"><apiName>Shape</apiName><shortdesc>
     创建新的 Shape 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
     创建新的 Shape 对象。
     
     </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="flash.display:Shape:graphics:get"><apiName>graphics</apiName><shortdesc>
     指定属于该 Shape 对象的 Graphics 对象，可通过此对象执行矢量绘画命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.display:Graphics</apiValueClassifier><apiTipTexts><apiTipText>为 Shape 对象指定 Graphics 对象。
     
     </apiTipText></apiTipTexts></apiValueDef><apiDesc>
     指定属于该 Shape 对象的 Graphics 对象，可通过此对象执行矢量绘画命令。
     
     </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ShaderParameterType"><apiName>ShaderParameterType</apiName><shortdesc>
	 该类定义一些常量，它们表示 ShaderParameter 类的 type 属性的可能值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 该类定义一些常量，它们表示 ShaderParameter 类的 <codeph>type</codeph> 属性的可能值。每个常量都表示 Flash Player 内可用于 Pixel Bender 着色器语言中的参数的一种数据类型。
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links><apiValue id="flash.display:ShaderParameterType:BOOL"><apiName>BOOL</apiName><shortdesc>
		 指示将着色器参数定义为 bool 值，等同于 ActionScript 中的单一 Boolean 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>bool</codeph> 值，等同于 ActionScript 中的单一 Boolean 实例。
		 
		 <p>请注意，即使参数只要求单一值，<codeph>ShaderParameter.value</codeph> 属性也是数组，因此该单一值必须是分配给 <codeph>value</codeph> 属性的数组的唯一元素，如下所示：</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is bool
		 myShader.data.param.value = [true];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL2"><apiName>BOOL2</apiName><shortdesc>
		 指示将着色器参数定义为 bool2 值，等同于 ActionScript 中由 2 个 Boolean 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>bool2</codeph> 值，等同于 ActionScript 中由 2 个 Boolean 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL3"><apiName>BOOL3</apiName><shortdesc>
		 指示将着色器参数定义为 bool3 值，等同于 ActionScript 中由 3 个 Boolean 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>bool3</codeph> 值，等同于 ActionScript 中由 3 个 Boolean 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:BOOL4"><apiName>BOOL4</apiName><shortdesc>
		 指示将着色器参数定义为 bool4 值，等同于 ActionScript 中由 4 个 Boolean 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>bool4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>bool4</codeph> 值，等同于 ActionScript 中由 4 个 Boolean 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT"><apiName>FLOAT</apiName><shortdesc>
		 指示将着色器参数定义为 float 值，等同于 ActionScript 中的单一 Number 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float</codeph> 值，等同于 ActionScript 中的单一 Number 实例。
		 
		 <p>请注意，即使参数只要求单一值，<codeph>ShaderParameter.value</codeph> 属性也是数组，因此该单一值必须是分配给 <codeph>value</codeph> 属性的数组的唯一元素，如下所示：</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is float
		 myShader.data.param.value = [22.5];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT2"><apiName>FLOAT2</apiName><shortdesc>
		 指示将着色器参数定义为 float2 值，等同于 ActionScript 中由 2 个 Number 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float2</codeph> 值，等同于 ActionScript 中由 2 个 Number 实例组成的数组。
		 
		 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#ShaderParameter/type"><linktext>flash.display.ShaderParameter.type</linktext></link></related-links></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT3"><apiName>FLOAT3</apiName><shortdesc>
		 指示将着色器参数定义为 float3 值，等同于 ActionScript 中由 3 个 Number 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float3</codeph> 值，等同于 ActionScript 中由 3 个 Number 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:FLOAT4"><apiName>FLOAT4</apiName><shortdesc>
		 指示将着色器参数定义为 float4 值，等同于 ActionScript 中由 4 个 Number 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>float4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float4</codeph> 值，等同于 ActionScript 中由 4 个 Number 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT"><apiName>INT</apiName><shortdesc>
		 指示将着色器参数定义为 int 值，等同于 ActionScript 中的单一 int 或 uint 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>int</codeph> 值，等同于 ActionScript 中的单一 int 或 uint 实例。
		 
		 <p>请注意，即使参数只要求单一值，<codeph>ShaderParameter.value</codeph> 属性也是数组，因此该单一值必须是分配给 <codeph>value</codeph> 属性的数组的唯一元素，如下所示：</p>
		 
		 <codeblock>
		 // assumes the shader has a parameter named "param"
		 // whose data type is int
		 myShader.data.param.value = [275];
		 </codeblock>
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT2"><apiName>INT2</apiName><shortdesc>
		 指示将着色器参数定义为 int2 值，等同于 ActionScript 中由 2 个 int 或 uint 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>int2</codeph> 值，等同于 ActionScript 中由 2 个 int 或 uint 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT3"><apiName>INT3</apiName><shortdesc>
		 指示将着色器参数定义为 int3 值，等同于 ActionScript 中由 3 个 int 或 uint 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>int3</codeph> 值，等同于 ActionScript 中由 3 个 int 或 uint 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:INT4"><apiName>INT4</apiName><shortdesc>
		 指示将着色器参数定义为 int4 值，等同于 ActionScript 中由 4 个 int 或 uint 实例组成的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>int4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>int4</codeph> 值，等同于 ActionScript 中由 4 个 int 或 uint 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX2X2"><apiName>MATRIX2X2</apiName><shortdesc>
		 指示将着色器参数定义为 float2x2 值，等同于一个 2x2 的矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix2x2</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float2x2</codeph> 值，等同于一个 2x2 的矩阵。此矩阵表示为 ActionScript 中由 4 个 Number 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX3X3"><apiName>MATRIX3X3</apiName><shortdesc>
		 指示将着色器参数定义为 float3x3 值，等同于一个 3x3 的矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix3x3</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float3x3</codeph> 值，等同于一个 3x3 的矩阵。此矩阵表示为 ActionScript 中由 9 个 Number 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ShaderParameterType:MATRIX4X4"><apiName>MATRIX4X4</apiName><shortdesc>
		 指示将着色器参数定义为 float4x4 值，等同于一个 4x4 的矩阵。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>matrix4x4</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
		 指示将着色器参数定义为 <codeph>float4x4</codeph> 值，等同于一个 4x4 的矩阵。此矩阵表示为 ActionScript 中由 16 个 Number 实例组成的数组。
		 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathWinding"><apiName>GraphicsPathWinding</apiName><shortdesc>
GraphicsPathWinding 类为 flash.display.GraphicsPath.winding 属性和 flash.display.Graphics.drawPath() 方法提供值，以确定绘制路径的方向。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
GraphicsPathWinding 类为 <codeph>flash.display.GraphicsPath.winding</codeph> 属性和 <codeph>flash.display.Graphics.drawPath()</codeph> 方法提供值，以确定绘制路径的方向。顺时针路径为正向缠绕，逆时针路径为反向缠绕：
<p><adobeimage alt="正向和反向的缠绕方向" href="../../images/winding_positive_negative.gif"/></p>
<p> 当路径相交或重叠时，缠绕方向将确定由相交或重叠创建的区域的填充规则：</p>
<p><adobeimage alt="奇偶缠绕与非零缠绕规则之间的比较" href="../../images/winding_rules_evenodd_nonzero.gif"/></p>

</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#GraphicsPath/winding"><linktext>flash.display.GraphicsPath.winding</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiValue id="flash.display:GraphicsPathWinding:EVEN_ODD"><apiName>EVEN_ODD</apiName><shortdesc>
建立奇偶缠绕类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>evenOdd</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
建立奇偶缠绕类型。奇偶缠绕类型是由所有原始的绘图 API 使用的规则，并且是 <codeph>flash.display.Graphics.drawPath()</codeph> 方法的默认类型。任何重叠的路径将在开放填充与闭合填充之间交替。如果使用相同的填充绘制的两个正方形相交，则将不会填充相交的区域。相邻的区域是不相同的（二者没有同时填充或同时不填充）。 

</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathWinding:NON_ZERO"><apiName>NON_ZERO</apiName><shortdesc>
建立非零缠绕类型。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>nonZero</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
建立非零缠绕类型。非零缠绕类型确定：当反向缠绕的路径相交时，将不填充相交区域（与奇偶缠绕类型一样）。对于相同缠绕的路径，将填充相交区域。

</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:ActionScriptVersion"><apiName>ActionScriptVersion</apiName><shortdesc>
	ActionScriptVersion 类是表示已加载 SWF 文件的语言版本的常量值枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	ActionScriptVersion 类是表示已加载 SWF 文件的语言版本的常量值枚举。语言版本常量用于检查 flash.display.LoaderInfo 对象的 <codeph>actionScriptVersion</codeph> 属性。
	
	</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#LoaderInfo/actionScriptVersion"><linktext>flash.display.LoaderInfo.actionScriptVersion</linktext></link></related-links><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT2"><apiName>ACTIONSCRIPT2</apiName><shortdesc>
		ActionScript 语言版本 2.0 和更早版本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript 语言版本 2.0 和更早版本。 
		
		</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:ActionScriptVersion:ACTIONSCRIPT3"><apiName>ACTIONSCRIPT3</apiName><shortdesc>
		ActionScript 语言版本 3.0。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
		ActionScript 语言版本 3.0。 
		
		</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
 一组绘图命令及这些命令的坐标参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseInterface>flash.display:IGraphicsPath</apiBaseInterface><apiBaseInterface>flash.display:IGraphicsData</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 一组绘图命令及这些命令的坐标参数。
 <p>
 将 GraphicsPath 对象与 <codeph>Graphics.drawGraphicsData()</codeph> 方法一起使用。绘制 GraphicsPath 对象与调用 <codeph>Graphics.drawPath()</codeph> 方法是等效的。
 </p>
 <p>GraphicsPath 还具有一组自己的方法（<codeph>curveTo()</codeph>、<codeph>lineTo()</codeph>、<codeph>moveTo()</codeph>、<codeph>wideLineTo()</codeph> 和 <codeph>wideMoveTo()</codeph>），这些方法与 Graphics 类中用于调整 <codeph>GraphicsPath.commands</codeph> 和 <codeph>GraphicsPath.data</codeph> 矢量数组的方法类似。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawGraphicsData()"><linktext>flash.display.Graphics.drawGraphicsData()</linktext></link><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link></related-links><apiConstructor id="flash.display:GraphicsPath:GraphicsPath"><apiName>GraphicsPath</apiName><shortdesc>
     创建新的 GraphicsPath 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>commands</apiItemName><apiType value="Vector$int"/><apiData>null</apiData><apiDesc>一个由整数构成的矢量，表示由 GraphicsPathCommand 类定义的命令。
     </apiDesc></apiParam><apiParam><apiItemName>data</apiItemName><apiType value="Vector$Number"/><apiData>null</apiData><apiDesc>由数字构成的矢量，其中的每一对数字将被视为一个点（一个 x, y 对）。
     </apiDesc></apiParam><apiParam><apiItemName>winding</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>evenOdd</apiData><apiDesc>使用 GraphicsPathWinding 类中定义的值指定缠绕规则。
     
	 </apiDesc></apiParam></apiConstructorDef><apiDesc>
     创建新的 GraphicsPath 对象。
     
     </apiDesc></apiConstructorDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiConstructor><apiOperation id="flash.display:GraphicsPath:curveTo"><apiName>curveTo</apiName><shortdesc>
     将新的“curveTo”命令添加到 commands 矢量，并将新坐标添加到 data 矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>controlX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定控制点相对于父显示对象注册点的水平位置。  
     </apiDesc></apiParam><apiParam><apiItemName>controlY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定控制点相对于父显示对象注册点的垂直位置。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorX</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定下一个锚点相对于父显示对象注册点的水平位置。  
     </apiDesc></apiParam><apiParam><apiItemName>anchorY</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>一个数字，指定下一个锚点相对于父显示对象注册点的垂直位置。
     
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将新的“curveTo”命令添加到 <codeph>commands</codeph> 矢量，并将新坐标添加到 <codeph>data</codeph> 矢量。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/CURVE_TO"><linktext>flash.display.GraphicsPathCommand.CURVE_TO</linktext></link><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:lineTo"><apiName>lineTo</apiName><shortdesc>
     将新的“lineTo”命令添加到 commands 矢量，并将新坐标添加到 data 矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>直线目标点的 x 坐标。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>直线目标点的 y 坐标。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将新的“lineTo”命令添加到 <codeph>commands</codeph> 矢量，并将新坐标添加到 <codeph>data</codeph> 矢量。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>flash.display.GraphicsPathCommand.LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:moveTo"><apiName>moveTo</apiName><shortdesc>
     将新的“moveTo”命令添加到 commands 矢量，并将新坐标添加到 data 矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>目标点的 x 坐标。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>目标点的 y 坐标。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将新的“moveTo”命令添加到 <codeph>commands</codeph> 矢量，并将新坐标添加到 <codeph>data</codeph> 矢量。
      
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>flash.display.GraphicsPathCommand.MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideLineTo"><apiName>wideLineTo</apiName><shortdesc>
     将新的“wideLineTo”命令添加到 commands 矢量，并将新坐标添加到 data 矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>直线目标点的 x 坐标。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>直线目标点的 y 坐标。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将新的“wideLineTo”命令添加到 <codeph>commands</codeph> 矢量，并将新坐标添加到 <codeph>data</codeph> 矢量。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_LINE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_LINE_TO</linktext></link></related-links></apiOperation><apiOperation id="flash.display:GraphicsPath:wideMoveTo"><apiName>wideMoveTo</apiName><shortdesc>
     将新的“wideMoveTo”命令添加到 commands 矢量，并将新坐标添加到 data 矢量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>目标点的 x 坐标。
     </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>目标点的 y 坐标。
     
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
     将新的“wideMoveTo”命令添加到 <codeph>commands</codeph> 矢量，并将新坐标添加到 <codeph>data</codeph> 矢量。
     
     </apiDesc></apiOperationDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/WIDE_MOVE_TO"><linktext>flash.display.GraphicsPathCommand.WIDE_MOVE_TO</linktext></link></related-links></apiOperation><apiValue id="flash.display:GraphicsPath:commands"><apiName>commands</apiName><shortdesc>
     由绘画命令构成的矢量，其中的整数表示路径。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$int"/></apiValueDef><apiDesc>
     由绘画命令构成的矢量，其中的整数表示路径。每个命令都可以是 GraphicsPathCommand 类定义的值之一。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand"><linktext>flash.display.GraphicsPathCommand</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPath:data"><apiName>data</apiName><shortdesc>
     由数字构成的矢量，其中包含与绘图命令一起使用的参数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Vector$Number"/></apiValueDef><apiDesc>
     由数字构成的矢量，其中包含与绘图命令一起使用的参数。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPath:winding:get"><apiName>winding</apiName><shortdesc>
     使用 GraphicsPathWinding 类中定义的值指定缠绕规则。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
     使用 GraphicsPathWinding 类中定义的值指定缠绕规则。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathWinding"><linktext>flash.display.GraphicsPathWinding</linktext></link></related-links></apiValue></apiClassifier><apiClassifier id="flash.display:MorphShape"><apiName>MorphShape</apiName><shortdesc>
 MorphShape 类表示显示列表上的 MorphShape 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>flash.display:DisplayObject</apiBaseClassifier></apiClassifierDef><apiDesc>
 MorphShape 类表示显示列表上的 MorphShape 对象。无法在 ActionScript 中直接创建 MorphShape 对象；在 Flash 创作工具中创建补间形状时会创建这些对象。
 
 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="flash.display:PixelSnapping"><apiName>PixelSnapping</apiName><shortdesc>

PixelSnapping 类是可使用 Bitmap 对象的 pixelSnapping 属性来设置像素贴紧选项的常量值枚举。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>

PixelSnapping 类是可使用 Bitmap 对象的 <codeph>pixelSnapping</codeph> 属性来设置像素贴紧选项的常量值枚举。


</apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Bitmap/pixelSnapping"><linktext>flash.display.Bitmap.pixelSnapping</linktext></link></related-links><apiValue id="flash.display:PixelSnapping:ALWAYS"><apiName>ALWAYS</apiName><shortdesc>
	一个在 Bitmap 对象的 pixelSnapping 属性中使用的常量值，用于指定位图图像始终与最近的像素贴紧，与任何变形无关。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>always</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	一个在 Bitmap 对象的 <codeph>pixelSnapping</codeph> 属性中使用的常量值，用于指定位图图像始终与最近的像素贴紧，与任何变形无关。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:AUTO"><apiName>AUTO</apiName><shortdesc>
	一个在 Bitmap 对象的 pixelSnapping 属性中使用的常量值，用于指定如果位图图像是未经旋转或倾斜而绘制的，并且是以 99.9% 至 100.1% 的缩放系数绘制的，则该位图图像将与最近的像素贴紧。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>auto</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	一个在 Bitmap 对象的 <codeph>pixelSnapping</codeph> 属性中使用的常量值，用于指定如果位图图像是未经旋转或倾斜而绘制的，并且是以 99.9% 至 100.1% 的缩放系数绘制的，则该位图图像将与最近的像素贴紧。如果满足这些条件，则图像以 100% 缩放比例绘制，并与最近的像素贴紧。在内部，此设置允许使用矢量渲染器以尽可能快的速度绘制图像。
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:PixelSnapping:NEVER"><apiName>NEVER</apiName><shortdesc>
	一个在 Bitmap 对象的 pixelSnapping 属性中使用的常量值，用于指定不发生任何像素贴紧。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>never</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	一个在 Bitmap 对象的 <codeph>pixelSnapping</codeph> 属性中使用的常量值，用于指定不发生任何像素贴紧。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.display:GraphicsPathCommand"><apiName>GraphicsPathCommand</apiName><shortdesc>
 定义这些值以用于指定路径绘制命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 定义这些值以用于指定路径绘制命令。 
 
 <p>此类中的这些值由 <codeph>Graphics.drawPath()</codeph> 方法使用，或存储在 GraphicsPath 对象的 <codeph>commands</codeph> 矢量中。</p>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.display.xml#Graphics/drawPath()"><linktext>flash.display.Graphics.drawPath()</linktext></link><link href="flash.display.xml#GraphicsPath/commands"><linktext>flash.display.GraphicsPath.commands</linktext></link></related-links><apiValue id="flash.display:GraphicsPathCommand:CURVE_TO"><apiName>CURVE_TO</apiName><shortdesc>
     指定一个绘图命令，该命令使用控制点绘制一条从当前绘图位置开始，到数据矢量中指定的 x 和 y 坐标结束的曲线。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指定一个绘图命令，该命令使用控制点绘制一条从当前绘图位置开始，到数据矢量中指定的 x 和 y 坐标结束的曲线。此命令将产生与 <codeph>Graphics.lineTo()</codeph> 方法相同的效果，并使用数据矢量控制和锚记中的两个点：(cx, cy, ax, ay)。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/curveTo()"><linktext>flash.display.Graphics.curveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:LINE_TO"><apiName>LINE_TO</apiName><shortdesc>
     指定一个绘图命令，该命令绘制一条从当前绘图位置开始，到数据矢量中指定的 x 和 y 坐标结束的直线。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指定一个绘图命令，该命令绘制一条从当前绘图位置开始，到数据矢量中指定的 x 和 y 坐标结束的直线。此命令将产生与 <codeph>Graphics.lineTo()</codeph> 方法相同的效果，并使用数据矢量中的一个点：(x,y)。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:MOVE_TO"><apiName>MOVE_TO</apiName><shortdesc>
     指定一个绘图命令，该命令会将当前绘图位置移动到数据矢量中指定的 x 和 y 坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指定一个绘图命令，该命令会将当前绘图位置移动到数据矢量中指定的 x 和 y 坐标。此命令将产生与 <codeph>Graphics.moveTo()</codeph> 方法相同的效果，并使用数据矢量中的一个点：(x,y)。
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:NO_OP"><apiName>NO_OP</apiName><shortdesc>
     表示默认的“不执行任何操作”命令。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     表示默认的“不执行任何操作”命令。
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_LINE_TO"><apiName>WIDE_LINE_TO</apiName><shortdesc>
     指定一个“直线至”绘图命令，但使用两组坐标（四个值），而不是一组坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>5</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指定一个“直线至”绘图命令，但使用两组坐标（四个值），而不是一组坐标。使用此命令可在“直线至”和“曲线至”命令之间切换，而无需更改每个命令使用的数据值的个数。此命令使用数据矢量中的两组坐标：一个虚拟位置和一个 (x,y) 位置。
     
     <p><codeph>WIDE_LINE_TO</codeph> 和 <codeph>WIDE_MOVE_TO</codeph> 命令变体与 <codeph>CURVE_TO</codeph> 命令假定使用相同数目的参数。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/LINE_TO"><linktext>LINE_TO</linktext></link><link href="flash.display.xml#Graphics/lineTo()"><linktext>flash.display.Graphics.lineTo()</linktext></link></related-links></apiValue><apiValue id="flash.display:GraphicsPathCommand:WIDE_MOVE_TO"><apiName>WIDE_MOVE_TO</apiName><shortdesc>
     指定一个“移至”绘图命令，但使用两组坐标（四个值），而不是一组坐标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>4</apiData><apiValueClassifier>int</apiValueClassifier></apiValueDef><apiDesc>
     指定一个“移至”绘图命令，但使用两组坐标（四个值），而不是一组坐标。使用此命令可在“移至”和“曲线至”命令之间切换，而无需更改每个命令使用的数据值的个数。此命令使用数据矢量中的两组坐标：一个虚拟位置和一个 (x,y) 位置。
     
     <p><codeph>WIDE_LINE_TO</codeph> 和 <codeph>WIDE_MOVE_TO</codeph> 命令变体与 <codeph>CURVE_TO</codeph> 命令假定使用相同数目的参数。</p>
     
	 </apiDesc></apiValueDetail><related-links><link href="flash.display.xml#GraphicsPathCommand/MOVE_TO"><linktext>MOVE_TO</linktext></link><link href="flash.display.xml#Graphics/moveTo()"><linktext>flash.display.Graphics.moveTo()</linktext></link></related-links></apiValue></apiClassifier></apiPackage>