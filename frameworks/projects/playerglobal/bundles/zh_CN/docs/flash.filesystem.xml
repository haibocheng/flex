<?xml version="1.0"?>
<apiPackage id="flash.filesystem"><apiName>flash.filesystem</apiName><apiDetail/><apiClassifier id="flash.filesystem:FileStream"><apiName>FileStream</apiName><shortdesc>
 使用 FileStream 对象读取和写入文件。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.utils:IDataInput</apiBaseInterface><apiBaseInterface>flash.utils:IDataOutput</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
 使用 FileStream 对象读取和写入文件。通过调用 <codeph>open()</codeph> 方法可以同步打开文件，通过调用 <codeph>openAsync()</codeph> 方法可以异步打开文件。
 
 <p>以异步方式打开文件的好处是当 Adobe AIR 在后台运行读写过程时，可以执行其它代码。在以异步方式打开文件时，将随着操作的进行分派 <codeph>progress</codeph> 事件。</p>
 
 <p>以同步方式打开的 File 对象其行为很类似于 ByteArray 对象；以异步方式打开的文件其行为很类似于 Socket 或 URLStream 对象。在以同步方式打开 File 对象时，当从基础文件中读取或向其中写入需要的数据时，调用方将暂停。在以异步方式打开文件时，将会立即缓冲写入到流的任何数据，然后再写入文件。</p>
 
 <p>无论是以同步方式还是以异步方式从文件中读取数据，实际的读取方法都是同步的。两种情况都读取当前“可用的”数据。不同之处在于在以同步方式读取时，所有数据始终是可用的；而在以异步方式读取时，随着数据流入读取缓冲区，数据将逐渐变为可用。无论哪种方式，可以在当前时刻以同步方式读取的数据将用 <codeph>bytesAvailable</codeph> 属性表示。</p>
 
 <p>处理异步输入的应用程序通常会注册 <codeph>progress</codeph> 事件并使用通过调用读取方法变为可用的数据。或者，应用程序可以通过注册 <codeph>complete</codeph> 事件并处理分派 <codeph>complete</codeph> 事件时的整个数据集，从而简单地等待所有数据变为可用。 </p>
 
 </apiDesc></apiClassifierDetail><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 指出已到达流末尾。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 指出已到达流末尾。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#FileStream/position"><linktext>position</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.OutputProgressEvent.OUTPUT_PROGRESS_outputProgress"><apiName>outputProgress</apiName><shortdesc>
 指出已将缓冲数据写入文件。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.OutputProgressEvent.OUTPUT_PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.OutputProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 指出已将缓冲数据写入文件。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.ProgressEvent.PROGRESS_progress"><apiName>progress</apiName><shortdesc>
 指出流上有可用的新数据。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.ProgressEvent.PROGRESS</apiEventType><adobeApiEventClassifier>flash.events.ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 指出流上有可用的新数据。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 指示在异步文件 I/O 操作期间发生错误。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 指示在异步文件 I/O 操作期间发生错误。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream_flash.events.Event.CLOSE_close"><apiName>close</apiName><shortdesc>
 指示 close() 方法的显式调用已关闭流。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CLOSE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 指示 <codeph>close()</codeph> 方法的显式调用已关闭流。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link></related-links></adobeApiEvent><apiConstructor id="flash.filesystem:FileStream:FileStream"><apiName>FileStream</apiName><shortdesc>
	 创建 FileStream 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
	 创建 FileStream 对象。使用 <codeph>open()</codeph> 或 <codeph>openAsync()</codeph> 方法打开文件。
	 
	 </apiDesc></apiConstructorDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()"><linktext>openAsync()</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:FileStream:close"><apiName>close</apiName><shortdesc>
	 关闭 FileStream 对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 关闭 FileStream 对象。 
	 
	 <p>在调用 <codeph>close()</codeph> 方法后将无法读取或写入任何数据。如果以异步方式打开该文件（FileStream 对象使用 <codeph>openAsync()</codeph> 方法打开该文件），则调用 <codeph>close()</codeph> 方法将导致该对象分派 <codeph>close</codeph> 事件。 </p>
	 
	 <p>关闭应用程序将自动关闭与该应用程序中的 FileStream 对象相关联的所有文件。不过，最好在关闭应用程序之前，对以异步方式打开并具有要写入的未处理数据的所有 FileStream 对象注册 <codeph>closed</codeph> 事件（以确保写入数据）。</p>
	 
	 <p>通过调用 <codeph>open()</codeph> 或 <codeph>openAsync()</codeph> 方法可以重复使用 FileStream 对象。这将关闭与 FileStream 对象相关联的任何文件，但该对象不会分派 <codeph>close</codeph> 事件。</p>
	 
	 <p>对于以异步方式打开的 FileStream 对象（使用 <codeph>openAsync()</codeph> 方法），即使为 FileStream 对象调用了 <codeph>close()</codeph> 事件并删除了引用该对象的属性和变量，只要有尚未完成操作，并且为操作的完成注册了事件处理函数，就不会将 FileStream 对象作为垃圾回收。特别是，只要以下情况之一仍然可能存在，就会永久保持未引用的 FileStream 对象： </p>
	 
	 <ul>
	 
	 	<li>对于文件读取操作，尚未到达文件末尾（并且尚未分派 <codeph>complete</codeph> 事件）。 </li>
	 
	 	<li>输出数据仍然可用于写入，并且与输出有关的事件（如 <codeph>outputProgress</codeph> 事件或 <codeph>ioError</codeph> 事件）已经注册了事件侦听器。 </li>
	 
	 </ul>
	 
	 </apiDesc><example conref="examples\FileStream.close.1.as">     下面的代码<i>以异步方式</i> 打开 FileStream 对象并将一个名为 test.txt 的文本文件写入到用户文档目录的 Apollo Test 子目录中。调用 FileStream 对象的 <codeph>close()</codeph> 方法将在写入数据后关闭该文件。 
<codeblock>
import flash.filesystem.*;
import flash.events.Event;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.WRITE);
fileStream.writeUTFBytes("Hello");
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();

function fileClosed(event:Event):void {
    trace("closed");
}            
</codeblock></example><example conref="examples\FileStream.close.2.as">     下面的代码<i>以同步方式</i> 打开 FileStream 对象并将一个名为 test.txt 的文本文件写入到用户文档目录的 Apollo Test 子目录中。调用 FileStream 对象的 <codeph>close()</codeph> 方法将在写入数据后关闭该文件。
<codeblock>
import flash.filesystem.*;
            
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF("Hello");
fileStream.close();
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>open()</linktext></link><link href="flash.filesystem.xml#FileStream/event:close"><linktext>close 事件</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:close_close"><apiName>close</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>以异步方式打开的文件已关闭。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>以异步方式打开的文件已关闭。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:open"><apiName>open</apiName><shortdesc>
	 以同步方式打开 FileStream 对象，指向由 file 参数指定的文件。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件不存在；您没有足够的权限打开该文件；您正在打开文件以进行读取访问，但您没有读取权限；或您正在打开文件以进行写入访问，但您没有写入权限。 
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>文件位置位于应用程序目录中，并将 <codeph>fileMode</codeph> 参数设置为“追加”、“更新”或“写入”模式。 
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>指定要打开的文件的 File 对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fileMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>FileMode 类中的一个字符串，用于定义 FileStream 的功能（如读取或写入文件的功能）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 以同步方式打开 FileStream 对象，指向由 <codeph>file</codeph> 参数指定的文件。 
	 
	 <p>如果 FileStream 对象已打开，则调用此方法将在打开文件前关闭文件，且不会为以前打开的文件传送任何进一步事件（包括 <codeph>close</codeph>）。</p>
	 
	 <p>在支持文件锁定的系统中，在“写入”或“更新”模式（<codeph>FileMode.WRITE</codeph> 或 <codeph>FileMode.UPDATE</codeph>）下打开的文件在关闭前将是不可读的。</p>
	 
	 <p>对文件执行完操作后，调用 FileStream 对象的 <codeph>close()</codeph> 方法。某些操作系统会限制同时打开的文件数。</p>
	 
	 </apiDesc><example conref="examples\FileStream.open.1.as"> 下面的代码显示如何同步打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，然后使用系统字符集作为文本编码将该文件读入到一个字符串中。
<codeblock>
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);
fileStream.close();
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link><link href="flash.filesystem.xml#File"><linktext>File</linktext></link><link href="flash.filesystem.xml#FileMode"><linktext>FileMode</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:openAsync"><apiName>openAsync</apiName><shortdesc>
	 以异步方式打开 FileStream 对象，指向由 file 参数指定的文件。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件位置位于应用程序目录中，并将 <codeph>fileMode</codeph> 参数设置为“追加”、“更新”或“写入”模式。 
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>file</apiItemName><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier><apiDesc>指定要打开的文件的 File 对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>fileMode</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>FileMode 类中的一个字符串，用于定义 FileStream 的功能（如读取或写入文件的功能）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 以异步方式打开 FileStream 对象，指向由 <codeph>file</codeph> 参数指定的文件。 
	 
	 <p>如果 FileStream 对象已打开，则调用此方法将在打开文件前关闭文件，且不会为以前打开的文件传送任何进一步事件（包括 <codeph>close</codeph>）。</p>
	 
	 <p>如果 <codeph>fileMode</codeph> 参数设置为 <codeph>FileMode.READ</codeph> 或 <codeph>FileMode.UPDATE</codeph>，则文件一经打开，AIR 就会将数据读入到输入缓冲区中，并在将数据读入到输入缓冲区时分派 <codeph>progress</codeph> 和 <codeph>open</codeph> 事件。</p>
	 
	 <p>在支持文件锁定的系统中，在“写入”或“更新”模式（<codeph>FileMode.WRITE</codeph> 或 <codeph>FileMode.UPDATE</codeph>）下打开的文件在关闭前将是不可读的。</p>
	 
	 <p>对文件执行完操作后，调用 FileStream 对象的 <codeph>close()</codeph> 方法。某些操作系统会限制同时打开的文件数。</p>
	 
`	 </apiDesc><example conref="examples\FileStream.openAsync.1.as"> 下面的代码显示如何异步打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，然后使用系统字符集作为文本编码将该文件读入到一个字符串中。
<codeblock>
import flash.filesystem.*;
import flash.events.Event;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.addEventListener(Event.COMPLETE, fileCompleteHandler)
fileStream.openAsync(file, FileMode.READ);

function fileCompleteHandler(event:Event):void {
    var str:String = fileStream.readMultiByte(fileStream.bytesAvailable, File.systemCharset);
    trace(str);
    fileStream.close();
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/close()"><linktext>close()</linktext></link><link href="flash.filesystem.xml#FileStream/event:complete"><linktext>complete 事件</linktext></link><link href="flash.filesystem.xml#FileStream/event:ioError"><linktext>ioError 事件</linktext></link><link href="flash.filesystem.xml#FileStream/event:progress"><linktext>progress 事件</linktext></link><link href="flash.filesystem.xml#FileMode"><linktext>FileMode</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:openAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>文件不存在；您没有足够的权限打开该文件；您正在打开文件以进行读取访问，但您没有读取权限；或您正在打开文件以进行写入访问，但您没有写入权限。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>文件不存在；您没有足够的权限打开该文件；您正在打开文件以进行读取访问，但您没有读取权限；或您正在打开文件以进行写入访问，但您没有写入权限。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_progress"><apiName>progress</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ProgressEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在将数据读入到输入缓冲区时分派。（必须在 <codeph>fileMode</codeph> 参数设置为 <codeph>FileMode.READ</codeph> 或 <codeph>FileMode.UPDATE</codeph> 的情况下打开文件。）
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在将数据读入到输入缓冲区时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:FileStream:openAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>已将文件数据读入到输入缓冲区。（必须在 <codeph>fileMode</codeph> 参数设置为 <codeph>FileMode.READ</codeph> 或 <codeph>FileMode.UPDATE</codeph> 的情况下打开文件。）
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>已将文件数据读入到输入缓冲区。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBoolean"><apiName>readBoolean</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个布尔值，如果字节不为零，则为 <codeph>true</codeph>，否则为 <codeph>false</codeph>。
	 </apiDesc><apiOperationClassifier>Boolean</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取布尔值。读取单个字节，如果字节非零，则返回 <codeph>true</codeph>，否则返回 <codeph>false</codeph>。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBoolean_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readByte"><apiName>readByte</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取带符号的字节。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 -128 到 127。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取带符号的字节。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readBytes"><apiName>readBytes</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取 length 参数指定的数据字节数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要将数据读入的 <codeph>ByteArray</codeph> 对象。
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc><codeph>bytes</codeph> 参数中的偏移，应从该位置开始读取数据。
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>要读取的字节数。默认值 0 导致读取所有可用的数据。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取 <codeph>length</codeph> 参数指定的数据字节数。将从 <codeph>offset</codeph> 指定的位置开始，将字节读入 <codeph>bytes</codeph> 参数指定的 ByteArray 对象。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readDouble"><apiName>readDouble</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取 IEEE 754 双精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 IEEE 754 双精度浮点数。
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取 IEEE 754 双精度浮点数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readDouble_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readFloat"><apiName>readFloat</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取 IEEE 754 单精度浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>一个 IEEE 754 单精度浮点数。
	 </apiDesc><apiOperationClassifier>Number</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取 IEEE 754 单精度浮点数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readFloat_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readInt"><apiName>readInt</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 -2147483648 到 2147483647。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取带符号的 32 位整数。
     </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readMultiByte"><apiName>readMultiByte</apiName><shortdesc>
	
	 使用指定的字符集从文件流、字节流或字节数组中读取指定长度的多字节字符串。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>UTF-8 编码的字符串。
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要从字节流中读取的字节数。
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>表示用于解释字节的字符集的字符串。可能的字符集字符串包括 <codeph>"shift-jis"</codeph>、<codeph>"cn-gb"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character Sets</xref>。 
	 
     <p><b>注意：</b>如果当前系统无法识别 <codeph>charSet</codeph> 参数的值，则 <ph platform="actionscript">Adobe<sup>®</sup> Flash<sup>®</sup> Player 或 </ph>Adobe<sup>®</sup> AIR<sup>®</sup> 将采用系统的默认代码页作为字符集。例如，<codeph>charSet</codeph> 参数的值（如在使用 <codeph>01</codeph> 而不是 <codeph>1</codeph> 的 <codeph>myTest.readMultiByte(22, "iso-8859-01")</codeph> 中）可能适用于您的开发计算机，而不适用于其它计算机。在其它计算机上，<ph platform="actionscript">Flash Player 或</ph> AIR 运行时将使用系统的默认代码页。</p>
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 使用指定的字符集从文件流、字节流或字节数组中读取指定长度的多字节字符串。
	 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/systemCharset"><linktext>File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readMultiByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readObject"><apiName>readObject</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取以 AMF 序列化格式编码的对象。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>反序列化的对象
	 
	 </apiDesc><apiType value="any"/></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取以 AMF 序列化格式编码的对象。
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:readObject_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readShort"><apiName>readShort</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取带符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 -32768 到 32767。
	 </apiDesc><apiOperationClassifier>int</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取带符号的 16 位整数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTF"><apiName>readUTF</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>由字符的字节表示形式生成的 UTF-8 字符串。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）。
	 
	 <p>此方法类似于 Java IDataInput 接口中的 <codeph>readUTF()</codeph> 方法。<sup/></p>
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTF_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUTFBytes"><apiName>readUTFBytes</apiName><shortdesc>
	
	 从字节流或字节数组中读取 UTF-8 字节序列，并返回一个字符串。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>由指定长度字符的字节表示形式生成的 UTF-8 字符串。	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>要读取的字节数。
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 从字节流或字节数组中读取 UTF-8 字节序列，并返回一个字符串。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUTFBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedByte"><apiName>readUnsignedByte</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取无符号的字节。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 0 到 255。 	   
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取无符号的字节。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedInt"><apiName>readUnsignedInt</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 0 到 4294967295。
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取无符号的 32 位整数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:readUnsignedShort"><apiName>readUnsignedShort</apiName><shortdesc>
	
	 从文件流、字节流或字节数组中读取无符号的 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用读取功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法读取该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiException><apiDesc>为读取数据而指定的位置超过了可用的字节数（由 <codeph>bytesAvailable</codeph> 属性指定）。
	
	</apiDesc><apiItemName>EOFError</apiItemName><apiOperationClassifier>flash.errors:EOFError</apiOperationClassifier></apiException><apiReturn><apiDesc>返回值的范围是从 0 到 65535。 
	 </apiDesc><apiOperationClassifier>uint</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	
	 从文件流、字节流或字节数组中读取无符号的 16 位整数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:readUnsignedShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法读取文件或文件未打开。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法读取文件或文件未打开。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:truncate"><apiName>truncate</apiName><shortdesc>
	 在 FileStream 对象的 position 属性指定的位置截断文件。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件未打开，无法写入。
	 
	 </apiDesc><apiItemName>IllegalOperationError</apiItemName><apiOperationClassifier>flash.errors:IllegalOperationError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 在由 FileStream 对象的 <codeph>position</codeph> 属性指定的位置截断文件。 
	 
	 <p>删除从 <codeph>position</codeph> 属性指定的位置到文件末尾之间的字节。必须打开文件以进行写入。</p>
	 
	 </apiDesc><example conref="examples\FileStream.truncate.1.as"> 下面的代码以同步方式打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，如果该文件的长度大于 100 个字符，则将其长度修剪为 100 个字符。
<codeblock>
import flash.filesystem.*;

var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.UPDATE);
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.close();
</codeblock></example><example conref="examples\FileStream.truncate.2.as"> 下面的代码<i>以异步方式</i>打开用户文档目录的 Apollo Test 子目录中的 test.txt 文件，如果该文件的长度大于 100 个字符，则将其长度修剪为 100 个字符。
<codeblock>
var file:File = File.documentsDirectory;
file = file.resolvePath("Apollo Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.openAsync(file, FileMode.UPDATE);
trace("start", file.size)
if (file.size > 100) {
    fileStream.position = 100;
    fileStream.truncate();
}
fileStream.addEventListener(Event.CLOSE, fileClosed);
fileStream.close();
function fileClosed(event:Event):void {
    trace("closed", file.size); 
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#FileStream/position"><linktext>position</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBoolean"><apiName>writeBoolean</apiName><shortdesc>
	
	 写入布尔值。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiDesc>确定写入哪个字节的布尔值。如果该参数为 <codeph>true</codeph>，则写入 1；如果为 <codeph>false</codeph>，则写入 0。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入布尔值。根据 <codeph>value</codeph> 参数写入单个字节。如果为 <codeph>true</codeph>，则写入 1，如果为 <codeph>false</codeph>，则写入 0。
	 
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBoolean_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeByte"><apiName>writeByte</apiName><shortdesc>
	
	 写入一个字节。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入一个字节。使用了该参数的低 8 位；忽略了高 24 位。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeBytes"><apiName>writeBytes</apiName><shortdesc>
	
	 在指定的字节数组 bytes 中，从 offset（使用从零开始的索引）指定的字节开始，向文件流、字节流或字节数组中写入一个长度由 length 指定的字节序列。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bytes</apiItemName><apiOperationClassifier>flash.utils:ByteArray</apiOperationClassifier><apiDesc>要写入的字节数组。
	 </apiDesc></apiParam><apiParam><apiItemName>offset</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>从零开始的索引，指定在数组中开始写入的位置。
	 </apiDesc></apiParam><apiParam><apiItemName>length</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiData>0</apiData><apiDesc>一个无符号整数，指定在缓冲区中的写入范围。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 在指定的字节数组 <codeph>bytes</codeph> 中，从 <codeph>offset</codeph>（使用从零开始的索引）指定的字节开始，向文件流、字节流或字节数组中写入一个长度由 <codeph>length</codeph> 指定的字节序列。
	 
	 <p>如果省略 <codeph>length</codeph> 参数，则使用默认长度 0 并从 <codeph>offset</codeph> 开始写入整个缓冲区。如果还省略了 <codeph>offset</codeph> 参数，则写入整个缓冲区。 </p>
	 
	 <p>如果 <codeph>offset</codeph> 或 <codeph>length</codeph> 参数超出范围，它们将被锁定到 <codeph>bytes</codeph> 数组的开头和结尾。</p>
 	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeDouble"><apiName>writeDouble</apiName><shortdesc>
	
	 写入 IEEE 754 双精度（64 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>双精度（64 位）浮点数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入 IEEE 754 双精度（64 位）浮点数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeDouble_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeFloat"><apiName>writeFloat</apiName><shortdesc>
	
	 写入 IEEE 754 单精度（32 位）浮点数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>Number</apiOperationClassifier><apiDesc>单精度（32 位）浮点数。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入 IEEE 754 单精度（32 位）浮点数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeFloat_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeInt"><apiName>writeInt</apiName><shortdesc>
	
	 写入一个带符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个带符号的整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入一个带符号的 32 位整数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeMultiByte"><apiName>writeMultiByte</apiName><shortdesc>
	
	 使用指定的字符集将多字节字符串写入文件流、字节流或字节数组中。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 </apiDesc></apiParam><apiParam><apiItemName>charSet</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>指示要使用的字符集的字符串。可能的字符集字符串包括 <codeph>"shift-jis"</codeph>、<codeph>"cn-gb"</codeph>、<codeph>"iso-8859-1"</codeph>”等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character Sets</xref>。 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 使用指定的字符集将多字节字符串写入文件流、字节流或字节数组中。 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/systemCharset"><linktext>File.systemCharset</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeMultiByte_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeObject"><apiName>writeObject</apiName><shortdesc>
	
	 以 AMF 序列化格式将对象写入文件流、字节流或字节数组中。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value=""/><apiDesc>要进行序列化处理的对象。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 以 AMF 序列化格式将对象写入文件流、字节流或字节数组中。
	 </apiDesc></apiOperationDetail><related-links><link href="../../flash/net/package.html#registerClassAlias()"><linktext>flash.net.registerClassAlias()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:FileStream:writeObject_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeShort"><apiName>writeShort</apiName><shortdesc>
	
	 写入一个 16 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>int</apiOperationClassifier><apiDesc>一个整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入一个 16 位整数。使用了该参数的低 16 位；忽略了高 16 位。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeShort_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTF"><apiName>writeUTF</apiName><shortdesc>
	
	 将 UTF-8 字符串写入文件流、字节流或字节数组中。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 将 UTF-8 字符串写入文件流、字节流或字节数组中。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTF_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUTFBytes"><apiName>writeUTFBytes</apiName><shortdesc>
	
	 写入一个 UTF-8 字符串。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要写入的字符串值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入一个 UTF-8 字符串。类似于 <codeph>writeUTF()</codeph>，但不使用 16 位长度的词为字符串添加前缀。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUTFBytes_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:FileStream:writeUnsignedInt"><apiName>writeUnsignedInt</apiName><shortdesc>
	
	 写入一个无符号的 32 位整数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件尚未打开；文件已打开，但不是使用写入功能打开的；或对于已经打开以进行同步操作的文件（使用 <codeph>open()</codeph> 方法），无法写入该文件（例如因为缺少该文件）。
	
	</apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiOperationClassifier>uint</apiOperationClassifier><apiDesc>一个无符号的整型字节值。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	
	 写入一个无符号的 32 位整数。
	 </apiDesc></apiOperationDetail><adobeApiEvent id="flash.filesystem:FileStream:writeUnsignedInt_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>无法写入到该文件（例如因为缺少该文件）。仅对为进行异步操作而打开（使用 <codeph>openAsync()</codeph> 方法）的文件分派此事件。
	
	</apiDesc></adobeApiEventDetail><shortdesc>无法写入到该文件（例如因为缺少该文件）。</shortdesc></adobeApiEvent></apiOperation><apiValue id="flash.filesystem:FileStream:bytesAvailable:get"><apiName>bytesAvailable</apiName><shortdesc>
	
	 返回可在输入缓冲区中读取的数据的字节数。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
	
	 返回可在输入缓冲区中读取的数据的字节数。在尝试使用某一种读取方法读取数据之前，用户代码必须调用 <codeph>bytesAvailable</codeph> 以确保有足够的数据可用。
	 </apiDesc><example conref="examples\FileStream.bytesAvailable.1.as"/></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:endian:get"><apiName>endian</apiName><shortdesc>
	
	 数据的字节顺序：为 Endian 类中的 BIG_ENDIAN 或 LITTLE_ENDIAN 常量。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	
	 数据的字节顺序：为 Endian 类中的 <codeph>BIG_ENDIAN</codeph> 或 <codeph>LITTLE_ENDIAN</codeph> 常量。
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:objectEncoding:get"><apiName>objectEncoding</apiName><shortdesc>
     指定在使用 readObject() 或 writeObject() 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>uint</apiValueClassifier></apiValueDef><apiDesc>
     指定在使用 <codeph>readObject()</codeph> 或 <codeph>writeObject()</codeph> 方法写入或读取二进制数据时是使用 AMF3 格式还是 AMF0 格式。
	 
	 <p>该值为 ObjectEncoding 类中的常数。在默认情况下使用 AMF3 格式。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.net.xml#ObjectEncoding"><linktext>ObjectEncoding</linktext></link><link href="flash.filesystem.xml#FileStream/readObject()"><linktext>readObject()</linktext></link><link href="flash.filesystem.xml#FileStream/writeObject()"><linktext>writeObject()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:FileStream:position:get"><apiName>position</apiName><shortdesc>
	 文件中的当前位置。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 文件中的当前位置。 
	 
	 <p>此值可以按以下任一方式进行修改：</p>
	 
	 <ul>
	 
	 	<li>显式设置该属性</li>
	 
	 	<li>从 FileStream 对象中读取（通过使用一种读取方法）</li>
	 
	 	<li>写入到 FileStream 对象</li>
	 
	 </ul>
	 
	 <p>该位置定义为一个数字（而不是单位），以支持长度大于 2<sup>32</sup> 字节的文件。此属性的值始终是一个小于 2<sup>53</sup> 的整数。如果将此值设置为带有小数部分的数字，则会将此值舍入到最接近的整数。</p>
	 
	 <p>在异步读取文件时，如果设置了 <codeph>position</codeph> 属性，应用程序将开始用从指定位置开始的数据填充读取缓冲区，而 <codeph>bytesAvailable</codeph> 属性可以设置为 0。在使用一种读取方法读取数据前等待 <codeph>complete</codeph> 事件；或在使用一种读取方法前等待 <codeph>progress</codeph> 事件并检查 <codeph>bytesAvailable</codeph> 属性。</p>
	  
	 </apiDesc><example conref="examples\FileStream.position.1.as"> 下面的代码显示应用程序从文件读取数据时，FileStream 对象的 <codeph>position</codeph> 属性如何更新。
<codeblock>
import flash.fileSystem.*;
import flash.utils.ByteArray;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory.resolvePath("Apollo Test/test.txt");
var stream:FileStream = new FileStream();
stream.addEventListener(Event.COMPLETE, readBytes);
stream.openAsync(sourceFile, File);

function readBytes(e:Event):void {
    var bytes:ByteArray = new ByteArray();
    trace("position 0:", stream.position); // 0
    bytes[0] = stream.readByte();
    trace("position 1:", stream.position); // 1
    fileStream.readBytes(bytes, stream.position, 4); 
    trace("position 2:", stream.position); // 5
    stream.close();
}
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileStream:readAhead:get"><apiName>readAhead</apiName><shortdesc>
	 异步读取文件时请求的数据量。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>Should the readAhead value dwindle to 0 as the data is read in.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 异步读取文件时请求的数据量。
	 
	 <p>此属性指定异步流在当前位置以外尝试读取多少数据。此属性的默认值为无穷大：默认情况下，为执行异步读取而打开的文件一直读取到该文件的末尾。</p>
	 
	 <p>从读取缓冲区读取数据不会更改 <codeph>readAhead</codeph> 属性的值。在从缓冲区读取数据时，会读入新数据以重新填充读取缓冲区。</p>
	 
	 <p><codeph>readAhead</codeph> 属性对以同步方式打开的文件不起作用。</p>
	 
	 <p>由于数据是以异步方式读取的，因此 FileStream 对象将分派 <codeph>progress</codeph> 事件。在 <codeph>progress</codeph> 事件的事件处理函数方法中，查看所需的字节数是否可用（通过检查 <codeph>bytesAvailable</codeph> 属性），然后通过使用一种读取方法从读取缓冲区读取数据。</p>
	 
	 </apiDesc><example conref="examples\FileStream.readAhead.1.as">     下面的代码显示如何使用 <codeph>readAhead</codeph> 属性将读入一个文件的数据量限制为 100 个字节：
<codeblock>
import flash.filesystem.*;

var file:File = File.desktopDirectory.resolvePath("test.txt");
var fileStream:FileStream = new FileStream();
fileStream.readAhead = 100;
fileStream.addEventListener(ProgressEvent.PROGRESS, readProgressHandler)
fileStream.openAsync(file, FileMode.READ);
var results:ByteArray;

function readProgressHandler(event:ProgressEvent):void {
    if (fileStream.bytesAvailable >= 100) {
        fileStream.readBytes(results, 0, 100);
    }
}
</codeblock><swfblock conref="examples\FileStream.readAhead.1.swf"/></example></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filesystem:FileMode"><apiName>FileMode</apiName><shortdesc>
 FileMode 类定义 FileStream 类的 open() 和 openAsync() 方法的 fileMode 参数中使用的字符串常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
 FileMode 类定义 FileStream 类的 <codeph>open()</codeph> 和 <codeph>openAsync()</codeph> 方法的 <codeph>fileMode</codeph> 参数中使用的字符串常量。这些方法的 <codeph>fileMode</codeph> 参数确定文件打开后 FileStream 对象可用的功能。 
 
 <p>基于 open 方法中指定的 <codeph>fileMode</codeph> 参数值，可以使用以下功能的多种组合：</p>
 
 <ul>
 
 	<li>读取 — FileStream 对象可以从文件中读取数据。</li>
 	<li>写入 — FileStream 对象可以向文件中写入数据。</li>
 	<li>创建 — FileStream 对象可以在打开时创建不存在的文件。</li>
 	<li>打开时截断 — 打开文件时删除其中的数据（在写入任何数据之前）。</li>
 	<li>追加写入的数据 — 数据始终写入到文件的末尾（在调用任何写入方法时）。</li>
 
 </ul>
 
 <p>下表显示了 FileMode 类中的每个常量在作为 FileStream 对象的 open 方法的 <codeph>fileMode</codeph> 参数应用时的功能：</p>
 
 <adobetable class="innertable">
 
 
 
 
 
 <tgroup cols="6"><thead><row><entry>FileMode 常量</entry><entry align="center">读取</entry><entry align="center">编写</entry><entry align="center">创建</entry><entry align="center">打开时截断</entry><entry align="center">追加写入的数据</entry></row></thead><tbody><row>
 	<entry><codeph>READ</codeph></entry>
 	<entry align="center"> • </entry>
 	<entry> </entry>
 	<entry> </entry>
 	<entry> </entry>
 	<entry> </entry>
 </row><row>
 	<entry><codeph>WRITE</codeph></entry>
 	<entry> </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry> </entry>
 </row><row>
 	<entry><codeph>APPEND</codeph></entry>
 	<entry> </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry/>
 	<entry align="center"> • </entry>
 </row><row>
 	<entry><codeph>UPDATE</codeph></entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"> • </entry>
 	<entry align="center"/>
 	<entry> </entry>
 </row></tbody></tgroup></adobetable>
 
 </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#FileStream/open()"><linktext>FileStream.open()</linktext></link><link href="flash.filesystem.xml#FileStream/openAsync()"><linktext>FileStream.openAsync()</linktext></link></related-links><apiValue id="flash.filesystem:FileMode:APPEND"><apiName>APPEND</apiName><shortdesc> 
	用于要在写入模式下打开的文件，并将所有写入的数据附加到文件末尾。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>append</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	用于要在写入模式下打开的文件，并将所有写入的数据附加到文件末尾。打开文件时，会创建任何不存在的文件。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:READ"><apiName>READ</apiName><shortdesc> 
	用于要在只读模式中打开的文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>read</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	用于要在只读模式中打开的文件。文件必须存在（不创建缺少的文件）。
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:UPDATE"><apiName>UPDATE</apiName><shortdesc> 
	用于要在读/写模式中打开的文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>update</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	用于要在读/写模式中打开的文件。打开文件时，会创建任何不存在的文件。 
	
	</apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:FileMode:WRITE"><apiName>WRITE</apiName><shortdesc> 
	用于要在只写模式中打开的文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>write</apiData><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc> 
	用于要在只写模式中打开的文件。打开文件时，会创建任何不存在的文件，并截断任何现有的文件（删除其数据）。
	
	</apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="flash.filesystem:File"><apiName>File</apiName><shortdesc>
 File 对象表示文件或目录的路径。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.net:FileReference</apiBaseClassifier></apiClassifierDef><apiDesc>
 File 对象表示文件或目录的路径。这可以是现有的文件或目录，也可以是尚不存在的文件或目录（例如，它可以表示希望创建的文件或目录的路径）。 
 
  <p>File 类具有许多属性和方法，用于获取有关文件系统的信息和用于执行各种操作（如复制文件和目录）。</p>
  
  <p>可以与 FileStream 类一起使用 File 对象来读取和写入文件。 </p>
  
  <p>File 类扩展 FileReference 类。Flash<sup>®</sup> Player 和 Adobe<sup>®</sup> AIR<sup>®</sup> 都提供了 FileReference 类，它表示指向文件的指针，但 File 类添加了一些由于安全原因，不在 Flash Player 中（在浏览器中运行的 SWF 中）公开的属性和方法。</p>
  
  <p>File 类包含一些静态属性，供引用常用目录位置。这些静态属性包括：</p>
  
  <ul>
  	<li><codeph>File.applicationStorageDirectory</codeph> — 每个已安装的 AIR 应用程序独有的存储目录</li>
      <li><codeph>File.applicationDirectory</codeph> — 安装应用程序的只读目录（其中包括所有已安装的资源）</li>
      <li><codeph>File.desktopDirectory</codeph> — 用户的桌面目录</li>
      <li><codeph>File.documentsDirectory</codeph> — 用户的文档目录</li>
      <li><codeph>File.userDirectory</codeph> — 用户目录</li>
  </ul>
  
  <p>这些属性的值在不同操作系统中均有意义。例如，在 Mac OS、Linux 和 Windows 上，用户桌面目录的本机路径各不相同。但是，<codeph>File.desktopDirectory</codeph> 属性在其中每个平台上，都会指向正确的桌面目录路径。要编写可以跨平台正常工作的应用程序，在需要引用应用程序使用的其它文件时，请以这些属性为基础，然后使用 <codeph>resolvePath()</codeph> 方法来完善路径。例如，此代码会指向应用程序存储目录中的 preferences.xml 文件：</p>
  
  <codeblock platform="actionscript"> var prefsFile:File = File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  <codeblock platform="javascript"> var prefsFile = air.File.applicationStorageDirectory;
  prefsFile = prefsFile.resolvePath("preferences.xml");</codeblock>
  
  <p>如果引用文件时，使用了文本常量形式的本机路径，它将只在一个平台上有效。例如，下面的 File 对象仅在 Windows 上有效：</p> 
  
  <codeblock platform="actionscript">new File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  <codeblock platform="javascript">new air.File("C:\Documents and Settings\joe\My Documents\test.txt")</codeblock>
  
  <p>应用程序存储目录非常有用。它为 AIR 应用程序提供了专用存储目录。此存储目录由 <codeph>File.applicationStorageDirectory</codeph> 属性定义。</p>
  
  <p>不要在应用程序目录（AIR 应用程序的安装位置）中添加或删除内容。否则会损坏 AIR 应用程序，应用程序签名也将失效。AIR 默认不允许写入应用程序目录，因为该目录并非对所有操作系统上的所有用户帐户均为可写目录。应用程序存储目录用于写入内部应用程序文件。文档目录用于写入用户希望能在应用程序之外使用的文件，如已编辑的图片或文本文件。</p>
  
  </apiDesc></apiClassifierDetail><related-links><link href="flash.filesystem.xml#FileStream"><linktext>FileStream</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.DIRECTORY_LISTING_directoryListing"><apiName>directoryListing</apiName><shortdesc>
 当由于调用 getDirectoryListingAsync() 方法而提供目录列表时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FileListEvent.DIRECTORY_LISTING</apiEventType><adobeApiEventClassifier>flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当由于调用 <codeph>getDirectoryListingAsync()</codeph> 方法而提供目录列表时分派。
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListingAsync()"><linktext>File.getDirectoryListingAsync()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.FileListEvent.SELECT_MULTIPLE_selectMultiple"><apiName>selectMultiple</apiName><shortdesc>
 当用户从通过调用 browseForOpenMultiple() 方法打开的对话框中选择文件时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.FileListEvent.SELECT_MULTIPLE</apiEventType><adobeApiEventClassifier>flash.events.FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户从通过调用 <codeph>browseForOpenMultiple()</codeph> 方法打开的对话框中选择文件时分派。 
 
 
 </apiDesc></adobeApiEventDetail><related-links><link href="flash.filesystem.xml#File/browseForMultiple()"><linktext>browseForMultiple()</linktext></link></related-links></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.SELECT_select"><apiName>select</apiName><shortdesc>
 当用户从文件浏览或目录浏览对话框中选择文件或目录时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.SELECT</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当用户从文件浏览或目录浏览对话框中选择文件或目录时分派。 
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.SecurityErrorEvent.SECURITY_ERROR_securityError"><apiName>securityError</apiName><shortdesc>
 当操作违反安全限制时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.SecurityErrorEvent.SECURITY_ERROR</apiEventType><adobeApiEventClassifier>flash.events.SecurityErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 当操作违反安全限制时分派。
 
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.IOErrorEvent.IO_ERROR_ioError"><apiName>ioError</apiName><shortdesc>
 在执行异步文件操作期间发生错误时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.IOErrorEvent.IO_ERROR</apiEventType><adobeApiEventClassifier>flash.events.IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在执行异步文件操作期间发生错误时分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.COMPLETE_complete"><apiName>complete</apiName><shortdesc>
 在异步操作完成时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.COMPLETE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在异步操作完成时分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="flash.filesystem:File_flash.events.Event.CANCEL_cancel"><apiName>cancel</apiName><shortdesc>
 在取消未处理的异步操作时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CANCEL</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
 在取消未处理的异步操作时分派。
 
 </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="flash.filesystem:File:File"><apiName>File</apiName><shortdesc>
	File 类的构造函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiException><apiDesc><codeph>path</codeph> 参数的语法无效。
	
	</apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiParam><apiItemName>path</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiData>null</apiData><apiDesc>文件的路径。可以通过使用 URL 或使用本机路径（特定于平台）表示法来指定路径。 
	
	<p>如果指定 URL，则可以使用以下 URL 架构之一：<codeph>file</codeph>、<codeph>app</codeph> 或 <codeph>app-storage</codeph>。下面是使用 URL 表示法时 <codeph>path</codeph> 参数的有效值： </p>
	
	<ul>
	
		<li><codeph>“app:/DesktopPathTest.xml”</codeph></li> 
		<li><codeph>“app-storage:/preferences.xml”</codeph></li> 
		<li><codeph>“file:///C:/Documents%20and%20Settings/bob/Desktop”</codeph>（Bob 的 Windows 计算机桌面）</li>
		<li><codeph>“file:///Users/bob/Desktop”</codeph>（Bob 的 Mac 计算机桌面）</li>
	
	</ul>
	
	<p><codeph>app</codeph> 和 <codeph>app-storage</codeph> URL 方案很有用，因为这些方案在所有文件系统中均可指向有效的文件。不过，在另外两个使用 <codeph>file</codeph> URL 架构指向用户桌面目录的示例中，最好是<i>不</i> 将 <codeph>path</codeph> 参数传递给 <codeph>File()</codeph> 构造函数，然后将 <codeph>File.desktopDirectory</codeph> 分配给 File 对象，以此作为访问独立于平台和独立于用户的桌面目录的方式。</p>
	
	<p>如果指定本机路径，则在 Windows 中可以使用反斜杠字符或正斜杠字符作为此参数中的路径分隔符；在 Mac OS 和 Linux 中则使用正斜杠字符。下面是使用本机路径表示法时 <codeph>path</codeph> 参数的有效值：</p>
	
	<ul>
	
		<li><codeph>“C:/Documents and Settings/bob/Desktop”</codeph></li>
		<li><codeph>“/Users/bob/Desktop”</codeph></li>
	
	</ul>
	
	<p>不过，对于这两个示例，<i>不应</i> 将 <codeph>path</codeph> 参数传递给 <codeph>File()</codeph> 构造函数，然后将 <codeph>File.desktopDirectory</codeph> 分配给 File 对象，以此作为访问独立于平台和独立于用户的桌面目录的方式。</p>
	
	</apiDesc></apiParam></apiConstructorDef><apiDesc>
	File 类的构造函数。 
	
	<p>如果传递 <codeph>path</codeph> 参数，File 对象将指向指定的路径，并将设置 <codeph>nativePath</codeph> 属性和 <codeph>url</codeph> 属性以反映该路径。</p>
	
	<p>尽管可以传递 <codeph>path</codeph> 参数来指定文件路径，但请考虑这是否会生成平台专用代码。例如，<codeph>“C:\\\\Documents and Settings\\bob\\Desktop”</codeph>这样的本机路径或<codeph>“file:///C:/Documents%20and%20Settings/bob/Desktop”</codeph>这样的 URL 仅在 Windows 上有效。较好的方法是使用以下这些静态属性，它们可以表示常用目录，且在所有平台上均有效：</p>
	
	<ul>
	<li><codeph>File.applicationDirectory</codeph></li>
	<li><codeph>File.applicationStorageDirectory</codeph></li>
	<li><codeph>File.desktopDirectory</codeph></li>
	<li><codeph>File.documentsDirectory</codeph></li>
	<li><codeph>File.userDirectory</codeph></li>
	</ul>
	
	<p>然后可以使用 <codeph>resolvePath()</codeph> 方法来获取这些目录的相对路径。例如，以下代码可以设置 File 对象，使其指向应用程序存储目录中的 settings.xml 文件：</p>
	
	<codeblock platform="actionscript">var file:File = File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	<codeblock platform="javascript">var file = air.File.applicationStorageDirectory.resolvePath("settings.xml");</codeblock>
	
	</apiDesc></apiConstructorDetail><related-links><link href="flash.filesystem.xml#File/nativePath"><linktext>nativePath</linktext></link></related-links></apiConstructor><apiOperation id="flash.filesystem:File:browseForDirectory"><apiName>browseForDirectory</apiName><shortdesc>
	 显示一个目录选择器对话框，用户可从中选择一个目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>在对话框标题栏中显示的字符串。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 显示一个目录选择器对话框，用户可从中选择一个目录。当用户选择该目录时，将分派 <codeph>select</codeph> 事件。<codeph>select</codeph> 事件的 <codeph>target</codeph> 属性是指向所选目录的 File 对象。
	 
	 </apiDesc><example conref="examples\File.browseForDirectory.1.as"> 下面的代码使用 <codeph>File.browseForDirectory()</codeph> 方法让用户选择一个目录。当选择目录时，此代码会在 <codeph>trace()</codeph> 输出中列出所选目录的内容。
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var directory:File = File.documentsDirectory;

try
{
    directory.browseForDirectory("Select Directory");
    directory.addEventListener(Event.SELECT, directorySelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function directorySelected(event:Event):void 
{
    directory = event.target as File;
    var files:Array = directory.getDirectoryListing();
    for(var i:uint = 0; i &lt; files.length; i++)
    {
        trace(files[i].name);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForDirectory_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户单击“打开文件”对话框中的“取消”按钮时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户单击“打开文件”对话框中的“取消”按钮时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForDirectory_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户选择目录并关闭目录选择器对话框时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户选择目录并关闭目录选择器对话框时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpen"><apiName>browseForOpen</apiName><shortdesc>
	 显示“打开文件”对话框，用户可从中选择要打开的文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>在对话框标题栏中显示的字符串。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 FileFilter 实例数组，用于过滤在对话框中显示的文件。如果省略此参数，则显示所有文件。有关详细信息，请参阅 FileFilter 类。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 显示“打开文件”对话框，用户可从中选择要打开的文件。
	 
	 <p>当用户选择该文件时，将分派 <codeph>select</codeph> 事件。<codeph>select</codeph> 事件的 <codeph>target</codeph> 属性是指向所选文件的 File 对象。</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpen.1.as"> 下面的代码使用 <codeph>File.browseForOpen()</codeph> 方法让用户选择一个文本文件。当选择此文件时，此代码将文件数据读入到字符串中。
<codeblock>
import flash.filesystem.*;
import flash.events.Event;
import flash.net.FileFilter;

var fileToOpen:File = new File();
var txtFilter:FileFilter = new FileFilter("Text", "*.as;*.css;*.html;*.txt;*.xml");

try 
{
    fileToOpen.browseForOpen("Open", [txtFilter]);
    fileToOpen.addEventListener(Event.SELECT, fileSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function fileSelected(event:Event):void 
{
    var stream:FileStream = new FileStream();
    stream.open(event.target, FileMode.READ);
    var fileData:String = stream.readUTFBytes(stream.bytesAvailable);
    trace(fileData);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpenMultiple()"><linktext>browseForOpenMultiple()</linktext></link><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpen_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户单击“打开文件”对话框中的“取消”按钮时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户单击“打开文件”对话框中的“取消”按钮时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpen_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户选择文件并关闭“打开文件”对话框时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户选择文件并关闭“打开文件”对话框时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForOpenMultiple"><apiName>browseForOpenMultiple</apiName><shortdesc>
	 显示“打开文件”对话框，用户可从中选择一个或多个要打开的文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>在对话框标题栏中显示的字符串。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>typeFilter</apiItemName><apiOperationClassifier>Array</apiOperationClassifier><apiData>null</apiData><apiDesc>一个 FileFilter 实例数组，用于过滤在对话框中显示的文件。如果省略此参数，则显示所有文件。有关详细信息，请参阅 FileFilter 类。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 显示“打开文件”对话框，用户可从中选择一个或多个要打开的文件。
	 
	 <p>当用户选择文件时，将分派 <codeph>selectMultiple</codeph> 事件。<codeph>select</codeph> 事件的 <codeph>target</codeph> 属性是此 File 对象。与 <codeph>browseForOpen()</codeph> 不同，使用 <codeph>browseForOpenMultiple()</codeph> 方法时，此 File 对象不会更新以引用任何所选的文件。相反，生成的 <codeph>selectMultiple</codeph> 事件包含所选文件的数组。</p>
	 
	 </apiDesc><example conref="examples\File.browseForOpenMultiple.1.as"> 下面的代码使用 <codeph>File.browseForOpenMultiple()</codeph> 方法让用户选择多个文件。当选择多个文件时，此代码输出所选文件的路径。
<codeblock>
import flash.filesystem.*;
import flash.events.FileListEvent;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForOpenMultiple("Select Files");
    docsDir.addEventListener(FileListEvent.SELECT_MULTIPLE, filesSelected);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function filesSelected(event:FileListEvent):void 
{
    for (var i:uint = 0; i &lt; event.files.length; i++) 
    {
        trace(event.files[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseForSave()"><linktext>browseForSave()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/event:selectMultiple"><linktext>selectMultiple</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户单击“打开文件”对话框中的“取消”按钮时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户单击“打开文件”对话框中的“取消”按钮时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForOpenMultiple_selectMultiple"><apiName>selectMultiple</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户选择文件并关闭“打开文件”对话框时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户选择文件并关闭“打开文件”对话框时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:browseForSave"><apiName>browseForSave</apiName><shortdesc>
	 显示“保存文件”对话框，用户可从中选择一个文件目标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>title</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>在对话框标题栏中显示的字符串。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 显示“保存文件”对话框，用户可从中选择一个文件目标。 
	 
	 <p>当用户选择该文件时，将分派 <codeph>select</codeph> 事件。<codeph>select</codeph> 事件的 <codeph>target</codeph> 属性是指向所选保存目标的 File 对象。</p>
	 
	 </apiDesc><example conref="examples\File.browseForSave.1.as"> 下面的代码使用 <codeph>File.browseForSave()</codeph> 方法让用户选择用于保存文件的路径。在选择文件时，此代码将数据保存到所选的文件路径。
<codeblock>
import flash.filesystem.*;
import flash.events.Event;

var docsDir:File = File.documentsDirectory;
try
{
    docsDir.browseForSave("Save As");
    docsDir.addEventListener(Event.SELECT, saveData);
}
catch (error:Error)
{
    trace("Failed:", error.message);
}

function saveData(event:Event):void 
{
    var newFile:File = event.target as File;
    var str:String = "Hello.";
    if (!newFile.exists)
    {
        var stream:FileStream = new FileStream();
        stream.open(newFile, FileMode.WRITE);
        stream.writeUTFBytes(str);
        stream.close();
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/browseDirectory()"><linktext>browseDirectory()</linktext></link><link href="flash.filesystem.xml#File/browseForOpen()"><linktext>browseForOpen()</linktext></link><link href="flash.filesystem.xml#File/event:select"><linktext>select</linktext></link><link href="flash.net.xml#FileFilter"><linktext>flash.net.FileFilter</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:browseForSave_cancel"><apiName>cancel</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户单击“保存文件”对话框中的“取消”按钮时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户单击“保存文件”对话框中的“取消”按钮时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:browseForSave_select"><apiName>select</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在用户选择文件并关闭“保存文件”对话框时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在用户选择文件并关闭“保存文件”对话框时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:cancel"><apiName>cancel</apiName><shortdesc>
	 取消任何未处理的异步操作。</shortdesc><prolog><asMetadata><apiVersion><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 取消任何未处理的异步操作。
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:canonicalize"><apiName>canonicalize</apiName><shortdesc>
	 规范化 File 路径。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 规范化 File 路径。
	 
	 <p>如果 File 对象表示现有的文件或目录，规范化将调整该路径，使其与实际文件名或目录名的大小写相匹配。如果 File 对象是符号链接，规范化将调整该路径，使其与该链接所指向的文件或目录相匹配，不管所指向的文件或目录是否存在。在区分大小写的文件系统（如 Linux）上，当多个文件的名称只有大小写不同时，<codeph>canonicalize()</codeph> 方法将调整路径以匹配最先找到的文件（以文件系统确定的顺序）。</p>
	 
	 <p>此外，在 Windows 中通过规范化可将短文件名转换成长文件名。</p>
	 
	 </apiDesc><example conref="examples\File.canonicalize.2.as">     下面的代码显示如何使用 <codeph>canonicalize()</codeph> 方法查找目录名的正确大小写。运行此示例前，在您的计算机桌面上创建一个名为 AIR Test 的目录。
<codeblock>
import flash.filesystem.*;

var path:File = File.desktopDirectory.resolvePath("air test");
trace(path.nativePath); 
path.canonicalize();
trace(path.nativePath); // ...\AIR Test

</codeblock></example><example conref="examples\File.canonicalize.1.as">     下面的代码显示如何使用 <codeph>canonicalize()</codeph> 方法基于 Windows 目录的短名称查找其长名称。此示例假定在 C: 驱动器的根目录中有一个 AIR Test 目录，并且系统已将短名称 AIR~1 分配给该目录。
<codeblock>
import flash.filesystem.*;

var path:File = new File();
path.nativePath = "C:\\AIR~1";
path.canonicalize();
trace(path.nativePath); // C:\AIR Test
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:clone"><apiName>clone</apiName><shortdesc>
	 返回此 File 对象的副本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回此 File 对象的副本。未复制事件注册。
	 
	 <p><i>注意：</i>此方法<i>不</i> 复制文件本身。它仅制作 <ph platform="actionscript">ActionScript</ph> <ph platform="javascript">JavaScript</ph> File 对象实例的副本。要复制文件，请使用 <codeph>copyTo()</codeph> 方法。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:copyTo"><apiName>copyTo</apiName><shortdesc>
	 将由此 File 对象指定的位置的文件或目录复制到由 newLocation 参数指定的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>源不存在；或者目标存在且 <codeph>overwrite</codeph> 为 <codeph>false</codeph>；或者无法将源复制到目标；或者源和目标引用相同的文件或文件夹且 <codeph>overwrite</codeph> 设置为 <codeph>true</codeph>。在 Windows 中无法复制打开的文件，也无法复制包含已打开文件的目录。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>新文件的目标位置。请注意，此 File 对象指定生成（复制）的文件或目录，<i>不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果为 <codeph>false</codeph>，则当由 <codeph>target</codeph> 参数指定的文件已经存在时复制将失败。如果为 <codeph>true</codeph>，该操作将覆盖现有的同名文件或目录。  
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将由此 File 对象指定的位置的文件或目录复制到由 <codeph>newLocation</codeph> 参数指定的位置。复制过程将创建任何需要的父目录（如有可能）。
	 
	 </apiDesc><example conref="examples\File.copyTo.1.as"> 下面的代码显示如何使用 <codeph>copyTo()</codeph> 方法复制文件。运行此代码之前，请在计算机上文档目录的 AIR Test 子目录中创建一个 test1.txt 文件。生成的复制文件名为 test2.txt，并且也在 AIR Test 子目录中。当您将 <codeph>clobber</codeph> 参数设置为 <codeph>true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:FileReference = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:FileReference = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

if (sourceFile.copyTo(destination, true)) {
    trace("Done.");
}
</codeblock></example><example conref="examples\File.copyTo.2.as"> 下面的代码显示如何使用 <codeph>copyTo()</codeph> 方法复制文件。运行此代码之前，在计算机上主目录的 AIR Test 子目录中创建一个 test1.txt 文件。生成的复制文件名为 test2.txt。<codeph>try</codeph> 和 <codeph>catch</codeph> 语句显示如何响应错误。
<codeblock>
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

try 
{
    sourceFile.copyTo(destination, true);
}
catch (error:Error)
{
    trace("Error:", error.message);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyToAsync()"><linktext>copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()"><linktext>moveTo()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:copyToAsync"><apiName>copyToAsync</apiName><shortdesc>
	 开始将此 File 对象指定的位置中的文件或目录复制到 destination 参数指定的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>新文件的目标位置。请注意，此 File 对象指定生成（复制）的文件或目录，<i>不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果为 <codeph>false</codeph>，则当由 <codeph>target</codeph> 文件指定的文件已经存在时复制将失败。如果为 <codeph>true</codeph>，则该操作将覆盖任何现有的同名文件或目录。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 开始将此 File 对象指定的位置中的文件或目录复制到 <codeph>destination</codeph> 参数指定的位置。 
	 
	 <p>完成后，将分派 <codeph>complete</codeph> 事件（成功）或 <codeph>ioError</codeph> 事件（不成功）。复制过程将创建任何需要的父目录（如有可能）。</p>
	 
	 </apiDesc><example conref="examples\File.copyToAsync.1.as"> 下面的代码显示如何使用 <codeph>copyToAsync()</codeph> 方法复制文件。在运行此代码之前，请确保在计算机上文档目录的 AIR Test 子目录中创建一个 test1.txt 文件。生成的复制文件名为 test2.txt，并且也在 AIR Test 子目录中。当您将 <codeph>clobber</codeph> 参数设置为 <codeph>true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/test2.txt");

sourceFile.copyToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileCopiedHandler);

function fileCopiedHandler(event:Event):void {
    trace("Done.");
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyTo()"><linktext>copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()"><linktext>moveToAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:copyToAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件或目录已成功复制时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在文件或目录已成功复制时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:copyToAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>源不存在；或者目标存在且 <codeph>overwrite</codeph> 为 <codeph>false</codeph>；或者无法将源复制到目标；或者源和目标引用相同的文件或文件夹且 <codeph>overwrite</codeph> 设置为 <codeph>true</codeph>。在 Windows 中无法复制打开的文件，也无法复制包含已打开文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>源不存在；或目标存在但 overwrite 为 false；或无法将源复制到目标；或源和目标引用相同的文件或文件夹但 overwrite 设置为 true。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:createDirectory"><apiName>createDirectory</apiName><shortdesc>
	 创建指定的目录和任何所需的父目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>目录不存在且无法创建。 
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 创建指定的目录和任何所需的父目录。如果该目录已存在，则不执行任何操作。
	 
	 </apiDesc><example conref="examples\File.createDirectory.1.as">     下面的代码将桌面上名为 test.txt 的文件移动到文档目录的 AIR Test 子目录中。调用 <codeph>createDirectory()</codeph> 方法以确保 AIR Test 目录存在后才移动此文件。
<codeblock>
import flash.filesystem.*;

var source:File = File.desktopDirectory.resolvePath("test.txt");
var target:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var targetParent:File = target.parent;
targetParent.createDirectory();
source.moveTo(target, true);
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:createTempDirectory"><apiName>createTempDirectory</apiName><shortdesc>
	 返回对新临时目录的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>引用新临时目录的 File 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回对新临时目录的引用。这是一个位于系统临时目录路径中的新目录。
	 
	 <p>使用此方法来标识新的唯一目录，无需查询系统即可以确定该目录是新的唯一目录。</p>
	 
	 <p>您可能需要在关闭应用程序前删除该临时目录，因为它不会自动删除。</p>
	 
	 </apiDesc><example conref="examples\File.createTempDirectory.1.as"> 下面的代码使用 <codeph>createTempFile()</codeph> 方法获取对新临时目录的引用。
<codeblock>
import flash.File;

var temp:File = File.createTempDirectory();
trace(temp.nativePath);
</codeblock> 每次运行此代码时都会创建一个新的（唯一的）文件。 
</example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/createTempFile()"><linktext>createTempFile()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:createTempFile"><apiName>createTempFile</apiName><shortdesc>
	 返回对新临时文件的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>引用新临时文件的 File 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回对新临时文件的引用。这是一个位于系统临时目录路径中的新文件。
	 
	 <p>使用此方法来标识新的唯一文件，无需查询系统即可以确定该文件是新的唯一文件。</p>
	 
	 <p>您可能需要在关闭应用程序前删除该临时文件，因为它不会自动删除。</p>
	 
	 </apiDesc><example conref="examples\File.createTempFile.1.as"> 下面的代码使用 <codeph>createTempFile()</codeph> 方法获取对新临时文件的引用。
<codeblock>
import flash.File;

var temp:File = File.createTempFile();
trace(temp.nativePath);
</codeblock> 每次运行此代码时都会创建一个新的（唯一的）文件。 
</example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/createTempDirectory()"><linktext>createTempDirectory()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectory"><apiName>deleteDirectory</apiName><shortdesc>
	 删除目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>目录不存在或无法删除。在 Windows 中无法删除包含已打开文件的目录。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deleteDirectoryContents</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定是否删除包含文件或子目录的目录。如果为 <codeph>false</codeph>，则当该目录包含文件或目录时，调用此方法将引发异常。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 删除目录。如果此 File 实际上是指向目录的符号链接，则删除的是链接，而非目录。
	 
	 </apiDesc><example conref="examples\File.deleteDirectory.1.as"> 下面的代码创建一个空目录，然后使用 <codeph>deleteDirectory()</codeph> 方法删除该目录。 
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Empty Junk Directory/");
File.createDirectory(directory);
trace(directory.exists); // true
directory.deleteDirectory();
trace(directory.exists); // false
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectoryAsync()"><linktext>deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()"><linktext>deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteDirectoryAsync"><apiName>deleteDirectoryAsync</apiName><shortdesc>
	 异步删除目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deleteDirectoryContents</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>指定是否删除包含文件或子目录的目录。如果为 <codeph>false</codeph>，则当该目录包含文件或目录时，File 对象将分派 <codeph>ioError</codeph> 事件。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 异步删除目录。如果此 File 实际上是指向目录的符号链接，则删除的是链接，而非目录。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectory()"><linktext>deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()"><linktext>deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在目录已成功删除时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在目录已成功删除时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteDirectoryAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>目录不存在或无法删除。在 Windows 中无法删除包含已打开文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>目录不存在或无法删除。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:deleteFile"><apiName>deleteFile</apiName><shortdesc>
	 删除文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>文件不存在或无法删除。在 Windows 中无法删除当前打开的文件。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 删除文件。如果此 File 实际上是符号链接，则删除的是链接，而非目标文件。
	 
	 </apiDesc><example conref="examples\File.deleteFile.1.as"> 下面的代码创建一个临时文件，然后调用 <codeph>deleteFile()</codeph> 方法以删除该文件。
<codeblock>
import flash.filesystem.*;

var file:File = File.createTempFile();
trace(file.exists); // true
file.deleteFile();
trace(file.exists); // false
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectory()"><linktext>deleteDirectory()</linktext></link><link href="flash.filesystem.xml#File/deleteFileAsync()"><linktext>deleteFileAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:deleteFileAsync"><apiName>deleteFileAsync</apiName><shortdesc>
	 异步删除文件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 异步删除文件。如果此 File 实际上是符号链接，则删除的是链接，而非目标文件。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/deleteDirectoryAsync()"><linktext>deleteDirectoryAsync()</linktext></link><link href="flash.filesystem.xml#File/deleteFile()"><linktext>deleteFile()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件已成功删除时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在文件已成功删除时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:deleteFileAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>文件不存在或无法删除。在 Windows 中无法删除当前打开的文件。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>文件不存在或无法删除。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListing"><apiName>getDirectoryListing</apiName><shortdesc>
	 返回与此 File 对象表示的目录中的文件和目录对应的 File 对象的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>File 对象的数组。
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回与此 File 对象表示的目录中的文件和目录对应的 File 对象的数组。此方法不浏览子目录的内容。
	 
	 </apiDesc><example conref="examples\File.getDirectoryListing.1.as"> 下面的代码显示如何使用 <codeph>getDirectoryListing()</codeph> 方法枚举用户目录的内容。
<codeblock>
import flash.filesystem.File;

var directory:File = File.userDirectory;
var list:Array = directory.getDirectoryListing();
for (var i:uint = 0; i &lt; list.length; i++) {
    trace(list[i].nativePath);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListingAsync()"><linktext>getDirectoryListingAsync()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()"><linktext>getRootDirectories()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:getDirectoryListingAsync"><apiName>getDirectoryListingAsync</apiName><shortdesc>
	 异步检索与此 File 对象表示的目录内容对应的 File 对象的数组。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 异步检索与此 File 对象表示的目录内容对应的 File 对象的数组。 
	 
	 </apiDesc><example conref="examples\File.getDirectoryListingAsync.1.as"> 下面的代码显示如何使用 <codeph>getDirectoryListingAsync()</codeph> 方法枚举用户目录的内容。
<codeblock>
import flash.filesystem.File;
import flash.events.FileListEvent;

var directory:File = File.userDirectory;
directory.getDirectoryListingAsync();
directory.addEventListener(FileListEvent.DIRECTORY_LISTING, directoryListingHandler);

function directoryListingHandler(event:FileListEvent):void {
    var list:Array = event.files;
    for (var i:uint = 0; i &lt; list.length; i++) {
        trace(list[i].nativePath);
    }
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/getDirectoryListing()"><linktext>getDirectoryListing()</linktext></link><link href="flash.filesystem.xml#File/getRootDirectories()"><linktext>getRootDirectories()</linktext></link><link href="flash.filesystem.xml#File/event:directoryListing"><linktext>directoryListing 事件</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:ErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>您没有足够的权限读取此目录，或此目录不存在。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>您没有足够的权限读取此目录，或此目录不存在。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:getDirectoryListingAsync_directoryListing"><apiName>directoryListing</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:FileListEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>目录内容已成功枚举。<codeph>contents</codeph> 事件具有一个 <codeph>files</codeph> 属性，该属性是生成的 File 对象数组。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>目录内容已成功枚举。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:getRelativePath"><apiName>getRelativePath</apiName><shortdesc>
	 查找两个 File 路径之间的相对路径。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>该引用为 <codeph>null</codeph>。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>调用方不在应用程序安全沙箱中。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiReturn><apiDesc>如果可能，则为此文件（或目录）和 <codeph>ref</codeph> 文件（或目录）之间的相对路径；否则为 <codeph>null</codeph>。
	 
	 </apiDesc><apiOperationClassifier>String</apiOperationClassifier></apiReturn><apiParam><apiItemName>ref</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc> 针对其给定该路径的 File 对象。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>useDotDot</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc> 指定生成的相对路径是否可以使用“..”组件。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 查找两个 File 路径之间的相对路径。
	 
	 <p>相对路径是可以追加到此引用（据此引用进行解析）以便定位第二个（参数）引用的组件的列表。使用“/”分隔符返回相对路径。</p>
	 
	 <p>或者，相对路径可以包括“..”引用，但这样的路径将不能跨越明显的卷边界。</p>
	 
	 </apiDesc><example conref="examples\File.getRelativePath.1.as"/></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:getRootDirectories"><apiName>getRootDirectories</apiName><shortdesc>
	 返回 File 对象的数组，列出文件系统根目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>File 对象的数组，列出各个根目录。 
	 
	 </apiDesc><apiOperationClassifier>Array</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
	 返回 File 对象的数组，列出文件系统根目录。 
	 
	 <p>例如在 Windows 中，这是一个卷列表，如 C: 驱动器和 D: 驱动器。此数组中不包括空的驱动器，如未插入光盘的 CD 或 DVD 驱动器。在 Mac OS 和 Linux 中，此方法始终返回计算机的唯一根目录（“/”目录）</p>
	 
	 </apiDesc><example conref="examples\File.getRootDirectories.1.as"> 下面的代码输出根目录的列表：
<codeblock>
import flash.filesystem.File;
var rootDirs:Array = File.getRootDirectories();

for (var i:uint = 0; i &lt; rootDirs.length; i++) {
    trace(rootDirs[i].nativePath);
}
</codeblock></example></apiOperationDetail></apiOperation><apiOperation id="flash.filesystem:File:moveTo"><apiName>moveTo</apiName><shortdesc>
	 将此 File 对象指定的位置中的文件或目录移动到 destination 参数指定的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>源不存在；或者目标存在且 <codeph>overwrite</codeph> 设置为 <codeph>false</codeph>；或者无法将源文件或目录移动到目标位置；或者源和目标引用相同的文件或文件夹且 <codeph>overwrite</codeph> 设置为 <codeph>true</codeph>。在 Windows 中无法移动打开的文件，也无法移动包含已打开文件的目录。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>移动的目标位置。此对象指定生成（移动）的文件或目录的路径，<i>不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果为 <codeph>false</codeph>，则当 <codeph>target</codeph> 文件已经存在时移动将失败。如果为 <codeph>true</codeph>，则操作将覆盖任何现有的同名文件或目录。 
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 将此 File 对象指定的位置中的文件或目录移动到 <codeph>destination</codeph> 参数指定的位置。 
	 
	 <p>要重命名文件，请将 <codeph>destination</codeph> 参数设置为指向该文件目录中的路径，但使用不同的文件名。</p>
	 
	 <p>移动过程将创建任何需要的父目录（如有可能）。</p>
	 
	 </apiDesc><example conref="examples\File.moveTo.1.as"> 下面的代码显示如何使用 <codeph>moveTo()</codeph> 方法重命名文件。原始文件名为 test1.txt，生成的文件名为 test2.txt。由于源和目标 File 对象都指向同一个目录（用户文档目录的 Apollo Test 子目录），<codeph>moveTo()</codeph> 方法将重命名该文件（而不是将它移动到新的目录中）。运行此代码之前，请在计算机上文档目录的 AIR Test 子目录中创建一个 test1.txt 文件。当您将 <codeph>clobber</codeph> 参数设置为 <codeph>true</codeph> 时，此操作将覆盖任何现有的 test2.txt 文件。
<codeblock>

import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

try  
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" error.message);
}
</codeblock></example><example conref="examples\File.moveTo.2.as"> 下面的代码显示如何使用 <codeph>moveTo()</codeph> 方法移动文件。原始文件（test1.txt 文件）位于用户文档目录的 Apollo Test 子目录中，该方法将该文件移动到 Results 子目录中。运行此代码之前，在计算机上主目录的 AIR Test 子目录中创建一个 test1.txt 文件。<codeph>try</codeph> 和 <codeph>catch</codeph> 语句显示如何响应错误。
<codeblock>
import flash.filesystem.File;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("AIR Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("AIR Test/Results/test1.txt");

try 
{
    sourceFile.moveTo(destination, true);
}
catch (error:Error)
{
    trace("Error:" error.message);
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyTo()"><linktext>copyTo()</linktext></link><link href="flash.filesystem.xml#File/moveToAsync()"><linktext>moveToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveToAsync"><apiName>moveToAsync</apiName><shortdesc>
	 开始将此 File 对象指定的位置中的文件或目录移动到 newLocation 参数指定的位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newLocation</apiItemName><apiOperationClassifier>flash.net:FileReference</apiOperationClassifier><apiDesc>移动的目标位置。此对象指定生成（移动）的文件或目录的路径，<i>不是</i> 包含该文件或目录的目录的路径。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>overwrite</apiItemName><apiOperationClassifier>Boolean</apiOperationClassifier><apiData>false</apiData><apiDesc>如果为 <codeph>false</codeph>，则当 <codeph>target</codeph> 文件已经存在时移动将失败。如果为 <codeph>true</codeph>，则操作将覆盖任何现有的同名文件或目录。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 开始将此 File 对象指定的位置中的文件或目录移动到 <codeph>newLocation</codeph> 参数指定的位置。 
	 
	 <p>要重命名文件，请将 <codeph>destination</codeph> 参数设置为指向该文件目录中的路径，但使用不同的文件名。</p>
	 
	 <p>移动过程将创建任何需要的父目录（如有可能）。</p>
	 
	 </apiDesc><example conref="examples\File.moveToAsync.1.as"> 下面的代码显示如何使用 <codeph>moveToAsync()</codeph> 方法重命名文件。原始文件名为 test1.txt，生成的文件名为 test2.txt。由于源和目标 File 对象都指向同一个目录（用户文档目录的 Apollo Test 子目录），<codeph>moveToAsync()</codeph> 方法将重命名该文件（而不是将它移动到新的目录中）。在运行此代码之前，在计算机上文档目录的 Apollo Test 子目录中创建一个 test1.txt 文件。当您将 <codeph>clobber</codeph> 参数设置为 <codeph>true</codeph> 时，该操作将覆盖任何现有的 test2.txt 文件。
<codeblock>
import flash.filesystem.File;
import flash.events.Event;

var sourceFile:File = File.documentsDirectory;
sourceFile = sourceFile.resolvePath("Apollo Test/test1.txt");
var destination:File = File.documentsDirectory;
destination = destination.resolvePath("Apollo Test/test2.txt");

var sourceFile.moveToAsync(destination, true);
sourceFile.addEventListener(Event.COMPLETE, fileMoveCompleteHandler);

function fileMoveCompleteHandler(event:Event):void 
{
    trace("Done.")
}
</codeblock></example></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/copyToAsync()"><linktext>copyToAsync()</linktext></link><link href="flash.filesystem.xml#File/moveTo()"><linktext>moveTo()</linktext></link><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件或目录已成功移动时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在文件或目录已成功移动时分派。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>源不存在；或者目标存在而 <codeph>overwrite</codeph> 为 <codeph>false</codeph>；或者无法将源移动到目标；或者源和目标引用相同的文件或文件夹且 <codeph>overwrite</codeph> 设置为 <codeph>true</codeph>。在 Windows 中无法移动打开的文件，也无法移动包含已打开文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>源不存在；或目标存在但 overwrite 为 false；或无法将源移到目标；或源和目标引用相同的文件或文件夹但 overwrite 设置为 true。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:moveToTrash"><apiName>moveToTrash</apiName><shortdesc>
	 将文件或目录移动到垃圾桶。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiException><apiDesc>操作系统不允许该操作；或者文件或目录不存在。在 Windows 中无法移动打开的文件，也无法移动包含当前打开的文件的目录。
	 
	 </apiDesc><apiItemName>IOError</apiItemName><apiOperationClassifier>flash.errors:IOError</apiOperationClassifier></apiException><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 将文件或目录移动到垃圾桶。
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/moveToTrashAsync()"><linktext>moveToTrashAsync()</linktext></link></related-links></apiOperation><apiOperation id="flash.filesystem:File:moveToTrashAsync"><apiName>moveToTrashAsync</apiName><shortdesc>
	 将文件或目录异步移动到垃圾桶。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>TBC: what to do when Trash is not supported?  SB part of general policy about optional system facilities.
	 </internal></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	 将文件或目录异步移动到垃圾桶。 
	 
	 </apiDesc></apiOperationDetail><related-links><link href="flash.filesystem.xml#File/moveToTrash()"><linktext>moveToTrash()</linktext></link></related-links><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_ioError"><apiName>ioError</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:IOErrorEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>操作系统不允许该操作；或者文件或目录不存在。在 Windows 中无法移动打开的文件，也无法移动包含当前打开的文件的目录。
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>操作系统不允许该操作；或者文件或目录不存在。</shortdesc></adobeApiEvent><adobeApiEvent id="flash.filesystem:File:moveToTrashAsync_complete"><apiName>complete</apiName><prolog/><adobeApiEventDetail><adobeApiEventDef><adobeApiEventClassifier>flash.events:Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>在文件或目录已成功移动到垃圾桶时分派。 
	 
	 </apiDesc></adobeApiEventDetail><shortdesc>在文件或目录已成功移动到垃圾桶时分派。</shortdesc></adobeApiEvent></apiOperation><apiOperation id="flash.filesystem:File:resolvePath"><apiName>resolvePath</apiName><shortdesc>
	 基于 path 参数（一个字符串）创建一个其路径相对于此 File 对象路径的新 File 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>指向生成的路径的新 File 对象。
	 
	 </apiDesc><apiOperationClassifier>flash.filesystem:File</apiOperationClassifier></apiReturn><apiParam><apiItemName>path</apiItemName><apiOperationClassifier>String</apiOperationClassifier><apiDesc>要追加到此 File 对象的路径中的路径（如果 <codeph>path</codeph> 参数为相对路径）；或者要返回的路径（如果 <codeph>path</codeph> 参数为绝对路径）。
	 
	 </apiDesc></apiParam></apiOperationDef><apiDesc>
	 基于 <codeph>path</codeph> 参数（一个字符串）创建一个其路径相对于此 File 对象路径的新 File 对象。
	 
	 <p><codeph>path</codeph> 参数可以使用相对路径或绝对路径。</p>
	 
	 <p>如果指定相对路径，则将给定的 <codeph>path</codeph>“追加”到 File 对象的路径。但是，在 <codeph>path</codeph> 中使用“..”可以返回生成的路径（该路径不是 File 对象的子级）。生成的引用不必引用实际文件系统位置。</p>
	 
	 <p>如果指定一个绝对文件引用，则该方法将返回指向该路径的 File 对象。绝对文件引用应使用对用户的操作系统有效的本机路径语法（例如 Windows 上的 <codeph>"C:\\test"</codeph>）。<i>不要</i>将 URL（例如 <codeph>"file:///c:/test"</codeph>）用作 <codeph>path</codeph> 参数。</p>
	 
	 <p>所有生成的路径将按以下方式进行规范化： </p>
	 
	 <ul>
	 
	 	<li>Any "." 忽略元素。</li>
	 
	 	<li>Any ".." 元素使用其父级条目。  </li>
	 
	 	<li>否 ".." 到达文件系统根或应用程序的永久存储区根的引用通过该节点；将忽略该引用。</li>
	 
	 </ul>
	 
	 <p>应始终使用正斜杠 (<codeph>/</codeph>) 字符作为路径分隔符。在 Windows 上，还可以使用反斜杠 (<codeph>\</codeph>) 字符，但这会导致应用程序在其它平台上无法正常工作。</p>
	 
	 <p>在 Linux 上，文件名和目录名是区分大小写的。</p>
	 
	 </apiDesc></apiOperationDetail></apiOperation><apiValue id="flash.filesystem:File:applicationDirectory:get"><apiName>applicationDirectory</apiName><shortdesc>
	 包含应用程序已安装文件的文件夹。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 包含应用程序已安装文件的文件夹。
	 
	 <p>此对象的 <codeph>url</codeph> 属性使用 <codeph>app</codeph> URL 架构（而不是 <codeph>file</codeph> URL 架构）。这意味着指定的 <codeph>url</codeph> 以<codeph>"app:"</codeph>开头（而不是以 <codeph>"file:"</codeph> 开头）。此外，如果创建一个相对于 <codeph>File.applicationDirectory</codeph> 目录的 File 对象（通过使用 <codeph>resolvePath()</codeph> 方法），则该 File 对象的 <codeph>url</codeph> 也使用 <codeph>app</codeph> URL 架构。 
	 </p>
	 
	 <p><i>注意：</i>您无法对其路径使用 <codeph>app</codeph> URL 架构的文件或目录进行写入。也无法删除或创建其路径使用 <codeph>app</codeph> URL 架构的文件或文件夹。出于安全方面的原因，修改应用程序目录中的内容不是好的做法。如果想要存储特定于应用程序的数据，请考虑使用应用程序存储目录 (<codeph>File.applicationStorageDirectory</codeph>)。如果希望应用程序存储目录中的内容能够访问具有应用程序特权的功能 (AIR API)，则可以使用沙箱桥公开该功能。</p>
	 
	 <p><codeph>applicationDirectory</codeph> 属性可用于引用应用程序目录，它在所有平台上均有效。如果使用 <codeph>nativePath</codeph> 或 <codeph>url</codeph> 属性设置 File 对象，使其引用应用程序目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 </apiDesc></apiValueDetail><related-links><link href="flash.filesystem.xml#File/applicationStorageDirectory"><linktext>applicationStorageDirectory</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:applicationStorageDirectory:get"><apiName>applicationStorageDirectory</apiName><shortdesc>
     应用程序的专用存储目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
     应用程序的专用存储目录。 
	 
	 <p>每个 AIR 应用程序都有一个唯一的、永久的应用程序存储目录，该目录是您首次访问 <codeph>File.applicationStorageDirectory</codeph> 时创建的。此目录是存储特定于应用程序的数据的方便位置。</p>
	 
	 <p>在卸载某个 AIR 应用程序时，卸载程序不会删除存储在应用程序存储目录中的文件。</p>
	 
	 <p>此对象的 <codeph>url</codeph> 属性使用 <codeph>app-storage</codeph> URL 架构（而不是 <codeph>file</codeph> URL 架构）。这意味着指定的 <codeph>url</codeph> 字符串以<codeph>"app-storage:"</codeph>开头（而不是以 <codeph>"file:"</codeph> 开头）。此外，如果创建一个相对于 <codeph>File.applicationStoreDirectory</codeph> 目录的 File 对象（通过使用 <codeph>resolvePath()</codeph> 方法），则该 File 对象的 <codeph>url</codeph> 也使用 <codeph>app-storage</codeph> URL 架构（如示例中所示）。</p>
	 
	 <p><codeph>applicationStorageDirectory</codeph> 属性可用于引用应用程序存储目录，它在所有平台上均有效。如果使用 <codeph>nativePath</codeph> 或 <codeph>url</codeph> 属性设置 File 对象，使其引用应用程序存储目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 </apiDesc><example conref="examples\File.applicationStorageDirectory.1.as"> 下面的代码创建一个 File 对象，该对象指向应用程序存储目录中的“images”子目录。
<codeblock>
import flash.filesystem.File;

var tempFiles:File = File.applicationStorageDirectory;
tempFiles = tempFiles.resolvePath("images/");
trace(tempFiles.url); // app-storage:/images
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:desktopDirectory:get"><apiName>desktopDirectory</apiName><shortdesc>
	 用户桌面目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 用户桌面目录。
	 
	 <p><codeph>desktopDirectory</codeph> 属性可用于引用桌面目录，它在所有平台上均有效。如果使用 <codeph>nativePath</codeph> 或 <codeph>url</codeph> 属性设置 File 对象，使其引用桌面目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 </apiDesc><example conref="examples\File.desktopDirectory.1.as"> 下面的代码输出用户桌面目录中包含的文件和目录的列表。
<codeblock>
import flash.filesystem.File;
var desktop:File = File.desktopDirectory;

var files:Array = desktop.getDirectoryListing();

for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock><swfblock conref="examples\File.desktopDirectory.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:documentsDirectory:get"><apiName>documentsDirectory</apiName><shortdesc>
	 用户文档目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 用户文档目录。
	 
	 <p>在 Windows 中，这是“My Documents”目录（例如，C:\Documents and Settings\userName\My Documents）。在 Mac OS 中，默认位置是 /Users/userName/Documents。在 Linux 中，默认位置是 /home/userName/Documents（英语系统上），并且该属性遵守 <codeph>xdg-user-dirs</codeph> 设置。</p>
	 
	 <p><codeph>documentsDirectory</codeph> 属性可用于引用文档目录，它在所有平台上均有效。如果使用 <codeph>nativePath</codeph> 或 <codeph>url</codeph> 属性设置 File 对象，使其引用文档目录，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 </apiDesc><example conref="examples\File.documentsDirectory.1.as"> 下面的代码使用 <codeph>File.documentsDirectory</codeph> 属性和 <codeph>File.createDirectory()</codeph> 方法来确保用户文档目录中存在一个名为“AIR Test”的目录。
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory;
directory = directory.resolvePath("AIR Test");

File.createDirectory(directory);
trace(directory.exists); // true
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:exists:get"><apiName>exists</apiName><shortdesc>
     指示引用的文件或目录是否存在。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示引用的文件或目录是否存在。如果 File 对象指向现有的文件或目录，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc><example conref="examples\File.exists.1.as"> 下面的代码创建一个临时文件，然后将其删除，并使用 <codeph>File.exists</codeph> 属性来检查该文件是否存在。
<codeblock>
import flash.filesystem.*;

var temp:File = File.createTempFile();
trace(temp.exists); // true
temp.deleteFile();
trace(temp.exists); // false
</codeblock><swfblock conref="examples\File.exists.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:icon:get"><apiName>icon</apiName><shortdesc>
	 包含为文件定义的图标的 Icon 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.desktop:Icon</apiValueClassifier></apiValueDef><apiDesc>
	 包含为文件定义的图标的 Icon 对象。Icon 对象是与各种图标状态相对应的 BitmapData 对象的数组。在 Linux 中，Icon 对象不包含图标。
	 
	 </apiDesc><example conref="examples\File.icon.1.as"> 下面的代码显示如何在 <codeph>icon</codeph> 数组中查找具有最大高度的图像，并将该图像设置为 Bitmap 对象。
<codeblock>
import flash.filesystem.File;
import flash.display.*;

var directory:File = File.documentsDirectory;
var bitmaps:Array = directory.icon.bitmaps;
var bmpData:BitmapData = new BitmapData(1, 1);
for (var i:uint = 0; i &lt; bitmaps.length; i++) {
    if (bitmaps[i].height > bmpData.height) {
        bmpData = directory.icon.bitmaps[i];
    }
}
var iconBmp:Bitmap = new Bitmap(bmpData);
</codeblock> 您可以将此 Bitmap 对象作为显示对象容器的子项（如 Sprite 对象或 Flex UIComponent 对象）进行添加。
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isDirectory:get"><apiName>isDirectory</apiName><shortdesc>
     指示是否为对目录的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示是否为对目录的引用。如果 File 对象指向一个目录，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc><example conref="examples\File.isDirectory.1.as"> 下面的代码创建指向用户目录中文件和目录的 File 对象的数组，然后使用 <codeph>isDirectory</codeph> 属性仅列出指向目录（而不是文件）的那些 File 对象。
<codeblock>
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isDirectory) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isDirectory.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isHidden:get"><apiName>isHidden</apiName><shortdesc>
     指示引用的文件或目录是否为“隐藏”。如果引用的文件或目录是隐藏的，则该值为 true；否则为 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>(Waiting for Stan's OK:)
	 
	 <ul>
	 
	 	<li>On Windows, a file or directory is designated as hidden by specifying the 
	 Hidden attribute (for example, in the File Properties dialog box) for the file.</li>
	 
	 	<li>On Mac OS and Linux, files can be designated as hidden for a number of reasons. Files with 
	 names that begin with the dot (.) character are designated as hidden. A .hidden file 
	 in the root directory lists other hidden files. Also, there is a bit in the file that, 
	 when set, makes it hidden.</li>
	 
	 </ul>
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示引用的文件或目录是否为“隐藏”。如果引用的文件或目录是隐藏的，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
	 
	 </apiDesc><example conref="examples\File.isHidden.1.as"> 下面的代码创建指向用户目录中文件和目录的 File 对象的数组，然后使用 <codeph>isHidden</codeph> 属性列出隐藏的文件和目录。
<codeblock>
import flash.filesystem.*;

var userDirFiles:Array = File.userDirectory.getDirectoryListing();
for (var i:uint = 0; i &lt; userDirFiles.length; i++) {
    if (userDirFiles[i].isHidden) {
        trace(userDirFiles[i].nativePath);
    }
}    
</codeblock><swfblock conref="examples\File.isHidden.1.swf"/></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isPackage:get"><apiName>isPackage</apiName><shortdesc>
     指示引用的目录是否为包。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示引用的目录是否为包。
     
	 <p>如果引用的目录是包，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。请注意，File 类不允许直接创建包。</p>
	 
	 <ul>
	 
	 	<li>在 Mac OS 中，目录可以指定为包并将作为单个文件而不是目录显示在 Finder 中。如果引用的目录是包，则将此属性设置为 <codeph>true</codeph>；如果该文件不是目录、不存在或不是包，则将此属性设置为 <codeph>false</codeph>。</li>
	 
	 	<li>在其它操作系统上，此属性始终设置为 <codeph>false</codeph>。</li>
	 
	 </ul>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:isSymbolicLink:get"><apiName>isSymbolicLink</apiName><shortdesc>
     指示引用是否为符号链接。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Boolean</apiValueClassifier></apiValueDef><apiDesc>
     指示引用是否为符号链接。
     
	 <p>如果 File 对象是一个符号链接，则该值为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。请注意，File 类不允许直接创建符号链接。</p>
	 
	 <p>符号链接允许一个文件指向磁盘上的另一个文件或目录。符号链接虽然与 Mac OS 中的别名和 Windows 中的快捷方式相似，但并不相同。别名或快捷方式始终报告为文件（而不是目录），读取或写入别名或快捷方式从不影响它指向的原始文件或目录。另一方面，符号链接的行为大体上与其所指向的文件或目录类似。它可以报告为文件或目录，读取或写入符号链接将会影响它指向的文件或目录，而不影响符号链接本身。删除符号链接，但删除的是链接，而非链接的目标。</p>
	 
	 <p>Mac <sup>®</sup> OS <sup>®</sup>、Linux 和 Windows <sup>®</sup> Vista <sup>®</sup> 支持符号链接。此外，在 Windows 中，引用交接点（用于 NTFS 文件系统）的 File 对象的 <codeph>isSymbolicLink</codeph> 属性设置为 <codeph>true</codeph>。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:lineEnding:get"><apiName>lineEnding</apiName><shortdesc>
	 主机操作系统使用的行结束字符序列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 主机操作系统使用的行结束字符序列。
	 
	 <p>在 Mac OS 和 Linux 中，这是换行符（十六进制字符代码 0x0A）。在 Windows 中，它是回车符（十六进制字符代码 0x0D），后跟换行符（十六进制字符代码 0x0A）。</p>
	 
	 </apiDesc><example conref="examples\File.lineEnding.1.as"> 下面的代码将一个字符串 (<codeph>str</codeph>) 写入文本文件，并使用 <codeph>File.lineEnding</codeph> 静态属性，用主机操作系统首选的行尾符来替换换行符的所有实例（在代码中用正则表达式 <codeph>/\n/g</codeph> 表示）。
<codeblock>
import flash.filesystem.*;

var str:String = "Hello\n" + 
        "World\n";
str = str.replace(/\n/g, File.lineEnding);
var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.WRITE);
fileStream.writeUTF(str);
fileStream.close();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:nativePath:get"><apiName>nativePath</apiName><shortdesc>
	 采用主机操作系统表示形式的完整路径。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>调用方不在应用程序安全沙箱中。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException><apiException><apiDesc>路径的语法无效。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 采用主机操作系统表示形式的完整路径。在 Mac OS 和 Linux 中，使用正斜杠 (/) 字符作为路径分隔符。但在 Windows 中，可以使用正斜杠字符或反斜杠 (\) 字符作为路径分隔符来<i>设置</i> <codeph>nativePath</codeph> 属性，AIR 会自动用相应的反斜杠字符来替换正斜杠。
	 
	<p>在使用 <i>set</i> 命令，以代码形式直接设置 <codeph>nativePath</codeph> 属性之前，请考虑这是否会生成平台专用代码。例如，<codeph>“C:\\Documents and Settings\\bob\\Desktop”</codeph>这样的本机路径仅在 Windows 上有效。较好的方法是使用以下这些静态属性，它们可以表示常用目录，且在所有平台上均有效：</p>
	
	<ul>
	<li><codeph>File.applicationDirectory</codeph></li>
	<li><codeph>File.applicationStorageDirectory</codeph></li>
	<li><codeph>File.desktopDirectory</codeph></li>
	<li><codeph>File.documentsDirectory</codeph></li>
	<li><codeph>File.userDirectory</codeph></li>
	</ul>
	
	<p>可以使用 <codeph>resolvePath()</codeph> 方法获取这些目录的相对路径。</p>
	
	<p product="flex">某些 Flex API（如 SWFLoader 类的 <codeph>source</codeph> 属性）使用 URL（File 对象的 <codeph>url</codeph> 属性），而不使用本机路径（<codeph>nativePath</codeph> 属性）。</p>
	
	<p platform="javascript">某些 API（如 IMG 对象的 <codeph>src</codeph> 属性）使用 URL（File 对象的 <codeph>url</codeph> 属性），不使用本机路径（<codeph>nativePath</codeph> 属性）。</p>
	
	 </apiDesc><example conref="examples\File.nativePath.1.as"> 下面的代码显示 File 对象的 <codeph>nativePath</codeph> 属性和 <codeph>url</codeph> 属性之间的区别。注释将在示例 Windows 计算机上显示结果。
<codeblock>
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:parent:get"><apiName>parent</apiName><shortdesc>
     包含此 File 对象引用的文件或目录的目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
     包含此 File 对象引用的文件或目录的目录。 
	 
	 <p>如果文件或目录不存在，则 <codeph>parent</codeph> 属性仍然返回指向包含目录的 File 对象（即使该目录不存在）。</p>
	 
	 <p>此属性与 <codeph>resolvePath("..")</codeph> 的返回值相同，只不过根目录的父级为 <codeph>null</codeph>。</p>
	 
	 </apiDesc><example conref="examples\File.parent.1.as"> 下面的代码使用 <codeph>parent</codeph> 属性显示包含临时文件的目录。
<codeblock>
import flash.filesystem.File;

var tempFile:File = File.createTempDirectory();
trace(tempFile.parent.nativePath);
tempFile.deleteFile();
</codeblock></example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:separator:get"><apiName>separator</apiName><shortdesc>
	 主机操作系统的路径组件分隔符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 主机操作系统的路径组件分隔符。
	 
	 <p>在 Mac OS 和 Linux 中，这是正斜杠 (/) 字符。在 Windows 中，它是反斜杠 (\) 字符。</p>
	 
	 <p><i>注意：</i>当在字符串中使用反斜杠时，请记住键入该字符两次（例如<codeph>“directory\\file.ext”</codeph>）。字符串中的每一对反斜杠在字符串中均表示单个反斜杠。</p>
	 
	 </apiDesc><example conref="examples\File.separator.1.as"> 下面的代码使用 <codeph>getRelativePath()</codeph> 方法获取目录和文件之间的相对路径。然后，代码使用 <codeph>File.separator</codeph> 静态属性，用操作系统所用的分隔符来替换路径中的正斜杠 (/) 字符，在 Windows 中为反斜杠 (\)，在其它操作系统中为正斜杠。
<codeblock>
import flash.filesystem.File;

var directory:File = File.documentsDirectory.resolvePath("Apollo Test");
var file:File = File.documentsDirectory.resolvePath("Apollo Test/employees/bob/test.txt");

var relativePath:String = directory.getRelativePath(file); // employees/bob/test.txt
relativePath = relativePath.replace(/\//g, File.separator);
trace(relativePath); 
</codeblock> 在此示例中，<codeph>replace()</codeph> 方法使用正则表达式 <codeph>/\//g</codeph> 与<i>所有</i> 正斜杠字符匹配。
</example></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:spaceAvailable:get"><apiName>spaceAvailable</apiName><shortdesc>
	 可用于在此 File 位置使用的空间，以字节为单位。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.1"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>Number</apiValueClassifier></apiValueDef><apiDesc>
	 可用于在此 File 位置使用的空间，以字节为单位。 
	 
	 <p> 如果 File 对象引用一个目录，则 <codeph>spaceAvailable</codeph> 将指示可供文件使用的目录空间。如果 File 对象引用一个文件，则 <codeph>spaceAvailable</codeph> 将指示可供该文件使用的空间。如果该文件位置不存在，则 <codeph>spaceAvailable</codeph> 将设置为 0。如果 File 对象引用一个符号链接，则 <codeph>spaceAvailable</codeph> 将指示符号链接指向的位置的可用空间。</p>
	 
	 <p>通常，目录或文件的可用空间与包含目录或文件的卷上的可用空间相同。不过，可用空间与磁盘配额及每个目录的空间限制有关。</p>
	 
	 <p>将文件或目录添加到卷中通常需要比文件的实际大小或目录中内容的实际大小更多的空间。例如，操作系统可能需要更多空间来存储索引信息。或者，所需的磁盘扇区可能会使用额外的空间。此外，可用空间是动态变化的。因此，您不能期望为文件存储分配报告的<i>全部</i> 空间。</p>
	 
	 </apiDesc></apiValueDetail></apiValue><apiValue id="flash.filesystem:File:systemCharset:get"><apiName>systemCharset</apiName><shortdesc>
	 主机操作系统使用的默认编码。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>String</apiValueClassifier></apiValueDef><apiDesc>
	 主机操作系统使用的默认编码。 
	 
	 <p>可能值包括<codeph>“windows-1252”</codeph>、<codeph>“shift-jis”</codeph>、<codeph>“cn-gb”</codeph>、<codeph>“iso-8859-1”</codeph>等。有关完整列表，请参阅<xref href="../../charset-codes.html">Supported Character </xref>。</p>
	 
	 <p>在使用 FileStream 类的 <codeph>readMultiByte()</codeph> 和 <codeph>writeMultiByte()</codeph> 方法时，可以使用此值。</p>
	 
	 </apiDesc><example conref="examples\File.systemCharSet.1.as"> 下面的代码打开一个文件（用户文档目录的 AIR Test 子目录中的 test.txt 文件），并使用 <codeph>File.systemCharset</codeph> 静态属性作为 FileStream 对象的 <codeph>readMultiByte()</codeph> 方法调用的 <codeph>charSet</codeph> 参数。
<codeblock>
import flash.filesystem.File;

var file:File = File.documentsDirectory.resolvePath("AIR Test/test.txt");
var fileStream:FileStream = new FileStream();
fileStream.open(file, FileMode.READ);
var str:String = fileStream.readMultiByte(file.size, File.systemCharset);
trace(str);    
</codeblock></example></apiValueDetail><related-links><link href="flash.filesystem.xml#FileStream/readMultiByte()"><linktext>FileStream.readMultiByte()</linktext></link><link href="flash.filesystem.xml#FileStream/writeMultiByte()"><linktext>FileStream.writeMultiByte()</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:url:get"><apiName>url</apiName><shortdesc>
	 此文件路径的 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata><asCustoms><internal>The URL will have a null "host" specification. (As opposed to "localhost". This is more confusing than 
	 informative.
	 
	 </internal></asCustoms></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>String</apiValueClassifier><apiException><apiDesc>URL 语法无效。
	 
	 </apiDesc><apiItemName>ArgumentError</apiItemName><apiOperationClassifier>ArgumentError</apiOperationClassifier></apiException><apiException><apiDesc>调用方不在应用程序安全沙箱中。
	 
	 </apiDesc><apiItemName>SecurityError</apiItemName><apiOperationClassifier>SecurityError</apiOperationClassifier></apiException></apiValueDef><apiDesc>
	 此文件路径的 URL。
	 
	 <p>如果这是对应用程序存储目录中的路径的引用，则 URL 架构为 <codeph>"app-storage"</codeph>；如果这是对应用程序目录中路径的引用，则 URL 架构为 <codeph>"app"</codeph>；否则此架构为 <codeph>"file"</codeph>。 </p>
	 
	 <p>在向 <codeph>url</codeph> 属性<i>赋</i>值时，可以使用空格字符（而不是 <codeph>"%20"</codeph>）；AIR 会自动对该字符串进行编码（例如，将空格转换为 <codeph>"%20"</codeph>）。</p>
	 
	 </apiDesc><example conref="examples\File.nativePath.1.as"> 下面的代码显示 File 对象的 <codeph>nativePath</codeph> 属性和 <codeph>url</codeph> 属性之间的区别。注释将在示例 Windows 计算机上显示结果。
<codeblock>
import flash.filesystem.File;

var docs:File = File.documentsDirectory;
trace(docs.nativePath); // C:\Documents and Settings\turing\My Documents
trace(docs.url); // file:///C:/Documents%20and%20Settings/turing/My%20Documents
</codeblock></example></apiValueDetail><related-links><link href="flash.filesystem.xml#File/nativePath"><linktext>nativePath</linktext></link><link href="../../package.html#decodeURI()"><linktext>decodeURI() 全局函数</linktext></link><link href="../../package.html#decodeURIComponent()"><linktext>decodeURIComponent() 全局函数</linktext></link><link href="../../package.html#encodeURI()"><linktext>decodeURI() 全局函数</linktext></link><link href="../../package.html#encodeURIComponent()"><linktext>decodeURIComponent() 全局函数</linktext></link></related-links></apiValue><apiValue id="flash.filesystem:File:userDirectory:get"><apiName>userDirectory</apiName><shortdesc>
	 用户目录。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="AIR" version="1.0"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>flash.filesystem:File</apiValueClassifier></apiValueDef><apiDesc>
	 用户目录。
	 
	 <p>在 Windows 中，这是“My Documents”目录的父级（例如，C:\Documents and Settings\userName）。在 Mac OS 中，它是 /Users/userName. 在 Linux 中，它是 /home/userName。</p>
	 
	 <p><codeph>userDirectory</codeph> 属性可用于引用用户目录，它在所有平台上均有效。如果直接设置 File 对象的 <codeph>nativePath</codeph> 或 <codeph>url</codeph> 属性，此命令将仅在能够识别此路径的平台上有效。</p>
	 
	 </apiDesc><example conref="examples\File.userDirectory.1.as"> 下面的代码输出用户目录的根级别包含的文件和目录的列表：
<codeblock>
import flash.filesystem.File;

var files:Array = File.userDirectory.listDirectory();
for (var i:uint = 0; i &lt; files.length; i++) {
    trace(files[i].nativePath);
}
</codeblock></example></apiValueDetail></apiValue></apiClassifier></apiPackage>